{"name": "perturbation_1_z", "predictions": {"real": [0.5401100218296051, 0.41677600145339966, 0.3553365468978882, 0.34609052538871765, 0.02883303165435791, 0.20104306936264038, 0.9757498502731323, 0.778521716594696, 0.19938278198242188, 0.4724252223968506, 1.0451356172561646, 0.05170631408691406, 0.03851664066314697, 0.5715997219085693, -0.5001077651977539, -0.07579243183135986, 0.25501489639282227, 0.3369762897491455, 1.0437119007110596, 0.8206381797790527, 1.2063102722167969, 0.47973811626434326, 0.46597373485565186, 0.6047975420951843, 0.06674224138259888, 0.6185054183006287, 1.3221193552017212, 0.5249342918395996, 0.10114693641662598, 0.464510440826416, 0.8727983236312866, 0.8071826696395874, 1.6180719137191772, 0.7594727277755737, 0.34328335523605347, 1.0877094268798828, 0.2281808853149414, 0.40476346015930176, 0.25377368927001953, 0.13108503818511963, 0.5022801756858826, 0.33765363693237305, -0.14451634883880615, 0.4683762788772583, 0.5262247323989868, 0.8448069095611572, 0.013729095458984375, 0.0, 0.6319026350975037, 0.6359854340553284, 0.22410297393798828, 0.4783168435096741, 0.7088755369186401, 0.3648456335067749, 0.180597186088562, 0.7634834051132202, 1.0338780879974365, 0.6899980902671814, 0.6653255224227905, 1.534195065498352, 0.5336249768733978, 0.5005382299423218, 0.6205751895904541, 0.6732341647148132, 0.6917850971221924, 0.2978219985961914, 0.3289940357208252, 0.4711684584617615, 1.0127832889556885, 0.42403197288513184, 0.7402282357215881, 0.8453366756439209, 0.8901622891426086, 0.4346534013748169, 1.313982367515564, 0.6825723648071289, 0.6827101707458496, 1.2743171453475952, 0.07964015007019043, 0.6665791273117065, 0.33291447162628174, 0.07120203971862793, 0.5173203945159912, 0.8495590686798096, 0.045043110847473145, 0.8784196972846985, 0.5678391456604004, 0.015216529369354248, 0.0, 0.6472306251525879, 0.3755212426185608, 0.5468419194221497, 0.16367340087890625, 0.22382622957229614, 0.6486374735832214, 0.6393703520298004, 0.40738755464553833, 0.8308749198913574, 0.5446554720401764, 0.8699777126312256, 0.4586242437362671, 0.03895998001098633, 0.0, 0.7451692223548889, 0.327986478805542, 0.25759804248809814, 0.36963218450546265, 1.1246261596679688, 0.6415154933929443, 0.5966746807098389, 0.8145244121551514, 1.050711989402771, 0.7002660632133484, 1.1127853393554688, 0.5065878629684448, 0.9488517045974731, 1.004368245601654, 0.43802565336227417, 0.546181321144104, 0.892008364200592, 0.5279619693756104, 0.9112136363983154, 0.7419863939285278, 0.5108140408992767, 0.5496241450309753, 0.643018901348114, 0.17345988750457764, 0.7810707092285156, 0.3784828186035156, 0.5946387052536011, 0.45942211151123047, 0.08801412582397461, 0.20352256298065186, 0.590291440486908, 0.9105343818664551, 0.939603328704834, 0.7444238662719727, 0.9097466468811035, 0.7220500707626343, 0.6149579286575317, 0.48816025257110596, 0.0, 0.5591149926185608, 0.46035921573638916, 0.0, 0.07691282033920288, 0.1870478391647339, 0.013813138008117676, 0.32435864210128784, 0.6754031181335449, 0.43086183071136475, 0.5269379019737244, 0.06551408767700195, 0.37540656328201294, 0.32066643238067627, 0.6077404022216797, 0.4619450569152832, 0.5455039143562317, 1.6187081933021545, 0.4726176857948303, 1.2002140283584595, 0.7329963445663452, 0.37539076805114746, 0.44734257459640503, 0.12993621826171875, 0.5332366824150085, 0.3203556537628174, 0.9971176385879517, 0.34286201000213623, 1.0701276063919067, 0.5700425505638123, 0.5983244180679321, 0.799691915512085, 0.756851077079773, 0.13845765590667725, 0.8118278980255127, 1.1709058284759521, 0.3650047183036804, 0.7059682607650757, 0.6850512027740479, 0.7542344331741333, 0.6472826600074768, 0.6533898115158081, 0.8288022875785828, 0.712785542011261, 0.7109028100967407, 0.0, 0.7001124620437622, 0.04062509536743164, 0.569351315498352, 0.9876145124435425, 0.13089203834533691, 0.06615054607391357, 0.5977898240089417, 0.5892170071601868, 0.48640239238739014, 0.7501384019851685, 1.1165989637374878, 0.2799133062362671, 0.18303298950195312, 0.2700197696685791, 1.237572431564331, 0.7308230996131897, 0.13197016716003418, 0.42067956924438477, 0.261189341545105, 0.9224985837936401, 0.04452979564666748, 0.5544048547744751, 0.4778367280960083, 0.6500654816627502, 0.48746585845947266, 0.946460485458374, 0.0, 0.5920068025588989, 0.4119464159011841, 0.7903779745101929, 0.2340390682220459, 0.02849423885345459, 0.4426140785217285, 0.3600893020629883, 0.9042666554450989, 0.29938262701034546, 0.5992817282676697, 0.8852738738059998, 0.0, 1.0705633163452148, 0.4291846752166748, 0.9256869554519653, 0.9757739305496216, 1.287621021270752, 0.0, 0.03957188129425049, 0.39498138427734375, 0.958574652671814, 0.1319429874420166, 0.493366003036499, 1.0254965424537659, 0.395435094833374, 0.2395336627960205, 0.6067699193954468, 0.7033287882804871, 0.652712345123291, 0.2952089309692383, 0.7082953453063965, 0.540438175201416, 0.8024916648864746, 0.6404664516448975, 0.9331009387969971, 1.0977729558944702, 0.49651527404785156, 0.3001137971878052, 0.26778948307037354, 0.7571572661399841, 0.8800308704376221, 0.4316145181655884, 0.7898142337799072, 1.0508172512054443, 0.10102081298828125, 0.3349663019180298, 0.3670412302017212, 0.2390296459197998, 0.49435949325561523, 0.0018131732940673828, 0.7987090349197388, 0.783729612827301, 0.7230647802352905, 0.8056929111480713, 0.703935980796814, 1.1700797080993652, 0.1236075758934021, 0.41854241490364075, 0.42994236946105957, 1.0804253816604614, 0.3855232000350952, 0.8767927885055542, 0.009018421173095703, 0.6718960404396057, 1.1088870763778687, 0.050855398178100586, 0.4224514961242676, 1.2735514640808105, 0.41559505462646484, 0.9653407335281372, 0.8111525774002075, 0.1292724609375, 0.7388561367988586, 0.9913110136985779, 0.6818409562110901, 0.7644467353820801, 0.8175685405731201, 0.3594423532485962, 0.6340362429618835, 0.8527864217758179, 0.6496841311454773, 0.47059279680252075, 0.871613621711731, -0.21757781505584717, 0.7222667932510376, 0.612786591053009, 0.6715283393859863, 0.8675498962402344, 0.6227636337280273, 0.07488399744033813, 0.5689021348953247, 0.6597295999526978, 0.3163332939147949, 0.8469895720481873, 1.007321834564209, 0.3665924668312073, 0.7221400737762451, 0.6302565932273865, 0.5880615711212158, 0.7631007432937622, 0.9250667095184326, 0.47276532649993896, 0.6140735149383545, 0.8760466575622559, 0.2893439531326294, 0.8957724571228027, 0.840788722038269, 0.1528356671333313, 0.6774794161319733, 0.6825910806655884, 0.7489434480667114, 0.7596626281738281, 0.7633552551269531, 0.33669036626815796, 0.5926591753959656, 0.1115189790725708, 0.025295734405517578, 0.6151169538497925, 0.48878157138824463, 0.43942928314208984, 0.1191091537475586, 0.967278003692627, 0.32758423686027527, 0.5936631560325623, 0.07656002044677734, 0.3081369400024414, 0.5388465523719788, 0.6007550358772278, 0.29556208848953247, 0.9037618637084961, 0.36828434467315674, 0.5593321323394775, 0.6897242665290833, 0.957414448261261, 0.8022773265838623, 0.86753249168396, 0.8313150405883789, 0.5669836401939392, 0.4739915132522583, 0.8418780565261841, 0.4997170567512512, 0.7754446268081665, 1.1346266269683838, 0.594694972038269, 0.6627923250198364, 0.4691915512084961, 0.3380722403526306, 0.6725406646728516, 0.9092044830322266, 0.022301673889160156, 0.7816234827041626, 0.7732305526733398, 0.22102487087249756, 0.1546025276184082, 1.310037612915039, 0.6032163500785828, 0.3494431972503662, 1.1703569889068604, 0.0, 0.6500440239906311, 0.5565516948699951, 0.8066849112510681, 0.7745753526687622, 0.9134091138839722, 0.680528998374939, 0.5520777702331543, 0.4539523124694824, 0.9773144721984863, 0.5127111077308655, 0.6771903038024902, 0.3748239278793335, 0.768456220626831, 1.172766923904419, 0.6464560031890869, 0.6264300346374512, 0.680492639541626, 0.7839085459709167, 0.6317808628082275, 0.8740698099136353, 0.19867026805877686, 0.8453786969184875, 0.800029993057251, 0.24615979194641113, 0.6887184381484985, 1.0827972888946533, 0.367801308631897, 0.700104832649231, 0.5558446645736694, 0.570791482925415, 0.250832200050354, 0.333645224571228, 0.169714093208313, 0.8915146589279175, 1.387964129447937, 0.30218827724456787, 0.5021343231201172, 0.2984722852706909, 0.0, 1.3752468824386597, 0.6218386888504028, 0.9458831548690796, 0.7975029945373535, 0.7819992303848267, 0.5199230909347534, 0.9290186762809753, 0.892365038394928, 0.4798066020011902, 0.0, 0.7748544216156006, 0.34470880031585693, 0.7810029983520508, 1.2176464796066284, 0.5110936164855957, 0.9233745336532593, 0.6944983005523682, 0.12247776985168457, 0.8918780088424683, 0.3315739631652832, 0.0, 0.28003472089767456, 0.5350559949874878, 0.23915719985961914, 0.893294095993042, 0.4395052194595337, 0.0687488317489624, 0.5630283057689667, 0.19827699661254883, 0.4810594916343689, 0.4432474970817566, 0.2581061124801636, 0.0, 0.5366485714912415, 0.65533447265625, 0.817237377166748, 0.5141229629516602, 1.0624254941940308, 0.6369532346725464, 0.741185188293457, 1.0764988660812378, 0.7552603483200073, 0.8512470126152039, 0.552979588508606, 0.7163254618644714, 0.802951455116272, 1.218693494796753, 0.018871426582336426, 0.5818994641304016, 0.14412617683410645, 0.35621020197868347, 0.7713820934295654, 0.4090002775192261, 0.1119837760925293, 0.9030349850654602, 0.804283857345581, 0.27531754970550537, 0.31974339485168457, 0.7680507898330688, 0.32030177116394043, 0.8155078887939453, 0.7740185260772705, 0.28561341762542725, 0.651588499546051, 0.5162220001220703, 0.0, 1.354565680027008, 0.8235812187194824, 0.0, 0.6892632246017456, 0.7985813021659851, 0.37251198291778564, 0.2375471591949463, 0.8832439184188843, 0.0, 0.7742739915847778, 0.7799555063247681, 0.9234403371810913, 0.684201717376709, 1.1505913734436035, 0.6713634729385376, 0.620207667350769, 0.8504552841186523, 0.9464837312698364, 0.3612632751464844, 1.2767478227615356, 0.16657626628875732, 0.4987291097640991, 0.710768461227417, 0.5198490619659424, 0.6282210350036621, 0.6642315983772278, 0.28979581594467163, 1.1537050008773804, 0.8348369002342224, 0.7522444725036621, 0.7699965238571167, 0.9975694417953491, 0.6467307806015015, 0.7279085516929626, 0.8779255151748657, 0.1819453239440918, 0.499830424785614, 0.7623933553695679, 0.36454784870147705, 0.6796032190322876, 1.0585306882858276, 0.2150493860244751, 0.7180612087249756, 0.7322275638580322, 0.28695148229599, 0.7633006572723389, 1.0567289590835571, 0.44681060314178467, 0.761085033416748, 0.3978017568588257, 0.0, 0.49232107400894165, 0.8918795585632324, 0.38294076919555664, 0.777126133441925, 0.8695816993713379, 0.689343273639679, 0.9760352969169617, 0.835313081741333, 0.7202735543251038, 0.6611188650131226, 1.1924320459365845, 0.5592812299728394, 0.7604990005493164, 0.5366281270980835, 0.35634350776672363, 0.6643862128257751, 0.5422606468200684, 0.0, 0.6545389890670776, 1.0125584602355957, 0.03771793842315674, 0.4644780158996582, 0.3629645109176636, 0.02975940704345703, 0.7173949480056763, 0.172806978225708, 0.0, 0.5626423954963684, 0.7456743717193604, 0.7266700267791748, 0.40884530544281006, 0.5161905288696289, 0.9015069007873535, 0.46919339895248413, 0.9140727519989014, 0.36356961727142334, 0.9066277742385864, 1.1645840406417847, 0.0, 0.6228781938552856, 0.709221363067627, 0.6467622518539429, 0.795708179473877, 0.7745521664619446, 0.7240235805511475, 0.7105188965797424, 0.423417329788208, 0.2921101450920105, 0.4227607846260071, 0.49569928646087646, 0.2295827865600586, 0.6140369772911072, 0.6916534900665283, 0.07267391681671143, 0.9782003164291382, 0.46000826358795166, 0.0, 0.1474757194519043, 0.22380757331848145, 0.0, 0.8155173063278198, 0.8791831731796265, 0.007579326629638672, 0.9537592530250549, 0.20854055881500244, 0.0, 0.5594772100448608, 0.5618810653686523, 0.7209714651107788, 0.471823513507843, 0.983250617980957], "samples": [0.5136435925960541, 0.4069048762321472, 0.4043848514556885, 0.8523861169815063, 0.8415528833866119, 0.3126371502876282, 0.9507782459259033, 0.8566171526908875, 1.195866584777832, 0.8224462568759918, 0.9761415719985962, 0.7761448621749878, 0.9381672739982605, 0.22919398546218872, 1.090919017791748, 0.4522090554237366, 0.5097951889038086, 0.49998748302459717, 0.35330697894096375, 0.5625972747802734, 0.7155820727348328, 0.8046594560146332, 0.6780087351799011, 0.8107974529266357, 1.2252449989318848, 0.7641838788986206, 1.0666990280151367, 0.7677603363990784, 0.46019136905670166, 0.771230936050415, 0.8574466705322266, 0.71610027551651, 0.6627476215362549, 1.0816510915756226, 0.9903550446033478, 1.6356884241104126, 0.6520195603370667, 1.1863788962364197, 1.8707205057144165, 0.5628068447113037, 0.5389966666698456, 0.6231199502944946, 0.20944583415985107, 0.7528060972690582, 0.5581491589546204, 0.3236745595932007, 0.260242760181427, -0.2088918685913086, 0.5230339169502258, 0.6824767887592316, 0.8597179651260376, 0.8308943510055542, 0.8424354791641235, 1.2523692846298218, 1.0478185415267944, 0.7289577722549438, 1.512022852897644, 0.7078537940979004, 0.6985990107059479, 1.1834571957588196, 0.5458672046661377, 0.8729511797428131, 0.3683387041091919, 0.3842630982398987, 0.5307677984237671, 0.9710633158683777, 0.5755654275417328, 0.8430086970329285, 1.8018357753753662, 0.7001150250434875, 0.5303338468074799, 0.23104238510131836, 0.836701512336731, 0.7859030365943909, 1.1584919691085815, 0.5047719478607178, 0.6295775771141052, 1.381293773651123, 0.8225700259208679, 0.8912152051925659, 1.3455224633216858, 0.8112602829933167, 1.1541301310062408, 1.0435718297958374, 0.7544230818748474, 0.6933748722076416, 1.0423336029052734, 0.8751210570335388, 0.7979371547698975, 1.1183408498764038, 0.827301412820816, 0.6205970346927643, 0.8324434757232666, 0.8552986979484558, 0.8650398254394531, 1.0610649585723877, 0.663470447063446, 0.8207086026668549, 0.7642001509666443, 0.7641830444335938, 0.8239884376525879, 1.38235604763031, 0.8334493637084961, 0.7723622918128967, 0.9056228399276733, 1.0920527279376984, 1.00759956240654, 1.1324702501296997, 0.6066778302192688, 0.757766604423523, 1.239400327205658, 0.9916910529136658, 0.8729825615882874, 0.5279144048690796, 0.7644793391227722, 0.7478382587432861, 1.878932774066925, 0.575330376625061, 0.515760600566864, 0.3307853937149048, 0.3718074560165405, 1.3510777652263641, 0.5187411308288574, 0.6350606083869934, 0.7281646728515625, 0.2447817325592041, 0.8052059412002563, 0.8505719006061554, 1.0119374990463257, 0.754833996295929, 0.683394581079483, 1.0395063757896423, 1.3398556113243103, 0.49029743671417236, 1.7837103605270386, 0.6550572514533997, 0.9741355180740356, 0.6366772055625916, 1.4052430093288422, 0.6488537490367889, 0.8339391052722931, 0.245830237865448, 0.699345052242279, 0.6160619258880615, 0.6505857706069946, 0.446227490901947, 1.469067394733429, 0.17941296100616455, 0.5593618452548981, 0.27111637592315674, 0.6930789351463318, 1.0795661211013794, 0.5776801109313965, 0.9517590403556824, 0.6905487179756165, 1.3126225471496582, 1.4595574140548706, 0.9677908420562744, 0.39907145500183105, 1.083040565252304, 0.6193810701370239, 0.6873265504837036, 0.623112678527832, 1.1556320786476135, 0.7850832343101501, 0.6178315877914429, 0.6829046010971069, 0.9926362335681915, 0.7605828642845154, 0.8349288105964661, 0.6697131395339966, 0.5977756977081299, 0.8695278167724609, 1.1640651226043701, 1.250361442565918, 1.4553700685501099, 0.8605378270149231, 0.7789507508277893, 1.073513776063919, 1.1157522797584534, 0.6584700644016266, 0.9325234293937683, 0.9430496692657471, 0.8921476006507874, 0.7245637774467468, 0.9063785076141357, 0.6381891965866089, 1.2168017029762268, 1.0579197406768799, 0.8804417252540588, 0.5768407583236694, 1.5132644772529602, 0.9186732769012451, 0.834179699420929, 1.109704852104187, 0.5413923859596252, 1.1722977757453918, 0.8772804737091064, 1.4720020294189453, 0.7257699966430664, 0.9244052767753601, 1.006920874118805, 0.7765289843082428, 1.4576900005340576, 0.6370972394943237, 0.71760094165802, 0.7880030274391174, 1.4989025592803955, 0.7341997027397156, 0.7824617028236389, 0.6201708912849426, 0.611452043056488, 0.9562491178512573, 1.058588594198227, 0.7204281687736511, 1.1695317029953003, 0.46763694286346436, 0.36303240060806274, 0.4626576602458954, 0.645885556936264, 0.4930928647518158, 0.791438102722168, 0.6947730183601379, 0.7512953579425812, 0.7051172256469727, 0.6706162691116333, 0.6543861031532288, 0.723789244890213, 0.6947596669197083, 0.8425132632255554, 0.8511822819709778, 0.2751706838607788, 0.17634844779968262, 0.59102463722229, 0.5574184656143188, 0.9278097152709961, 1.0605100393295288, 0.6217801868915558, 1.0921061038970947, 1.2706804871559143, 0.6885429322719574, 0.8131188154220581, 1.1167941689491272, 0.46593016386032104, 0.8247168660163879, 1.4516948461532593, 0.7571365833282471, 0.5929263830184937, 0.985609769821167, 0.8371636271476746, 0.2983390688896179, 0.5226929187774658, 0.7436062097549438, 1.0874314457178116, 0.8375993967056274, 0.688480794429779, 0.8946278691291809, 1.1399496793746948, 0.836872935295105, 0.9424924254417419, 0.8711381554603577, 0.7743052244186401, 1.4654794931411743, 1.2015321254730225, 0.8509165346622467, 0.7849449813365936, 1.1801281571388245, 0.7546424865722656, 1.0049954056739807, 1.245465099811554, 0.5728030800819397, 0.3620465397834778, 0.3840971291065216, 0.922145426273346, 0.8016157150268555, 1.1484777331352234, 0.4957863688468933, 1.1320239305496216, 1.5705528259277344, 0.5715214908123016, 1.0377299785614014, 0.9943989515304565, 0.8149547576904297, 0.7501000165939331, 1.009613275527954, 0.6999666094779968, 0.8130117952823639, 0.9678840041160583, 0.4887343943119049, 0.7694772183895111, 1.0859275162220001, 1.3960495591163635, 0.8345881700515747, 0.8794788122177124, 0.8000004887580872, 0.6452722549438477, 1.0733768939971924, 0.860196590423584, 1.0608650147914886, 1.4498559832572937, 0.6510934829711914, 0.6638831496238708, 1.0285184979438782, 0.4986773729324341, 0.6377607583999634, 0.5144376754760742, 0.6986832916736603, 0.894937664270401, 1.4954108595848083, 0.7888446152210236, 0.9303599298000336, 0.9579915106296539, 0.5669697225093842, 0.7413468509912491, 0.823024183511734, 0.8382874131202698, 0.8710092306137085, 1.0088765025138855, 0.6617618203163147, 1.0029276013374329, 1.189313292503357, 0.6121962666511536, 0.7097012400627136, 1.1376098990440369, 0.6713318526744843, 0.7894881963729858, 1.0709015727043152, 0.7651798129081726, 0.7967658638954163, 0.758754312992096, 0.5334099531173706, 1.0657380819320679, 0.47216761112213135, 0.7293505072593689, 0.993537425994873, 1.0802263617515564, 0.8643122911453247, 0.8313558101654053, 1.3183829188346863, 0.5030075311660767, 0.9030398726463318, 1.4141966104507446, 0.8654874563217163, 0.6570625305175781, 0.8246331214904785, 0.8306258320808411, 0.916843593120575, 1.1015623807907104, 0.8392742872238159, 1.049851894378662, 1.3141003251075745, 0.7385164499282837, 0.5876230895519257, 0.7824804782867432, 0.5735801756381989, 0.9260801672935486, 0.9998998045921326, 0.8209563195705414, 1.0875189900398254, 0.9283584952354431, 1.1038116812705994, 0.9084551334381104, 0.8960844278335571, 0.8978706002235413, 0.8513185381889343, 1.0635935068130493, 0.9162081480026245, 0.7026816606521606, 0.6335500478744507, 0.540812075138092, 0.9511364698410034, 0.43651241064071655, 0.755043089389801, 0.7914695739746094, 0.8142076134681702, 0.9119433760643005, 0.5857275426387787, 0.9884723424911499, 0.662903219461441, 0.5689026713371277, 0.8269635140895844, 1.0990066528320312, 0.5875261425971985, 0.7229572534561157, 0.843783050775528, 0.8426727056503296, 0.8223461508750916, 0.6495255827903748, 0.6420020163059235, 0.915826678276062, 0.8241052329540253, 0.7285801768302917, 1.3433365225791931, 0.776512086391449, 1.0897805392742157, 1.4030352234840393, 0.7002517580986023, 1.1015481352806091, 1.26218843460083, 1.2020012140274048, 0.6065734028816223, 1.0432270169258118, 0.7819120585918427, 0.7395681440830231, 1.2959989309310913, 0.8491535186767578, 0.8773217797279358, 1.2643969058990479, 0.45239537954330444, 0.7379013299942017, 0.7687392830848694, 1.1865407228469849, 0.7662011981010437, 0.9121445417404175, 0.8748762905597687, 0.7305794358253479, 0.8788983225822449, 0.6065508127212524, 0.5848848223686218, 1.0181630551815033, 0.649264931678772, 0.5798661708831787, 0.9583829641342163, 0.7626667618751526, 0.9760209918022156, 0.9462851285934448, 0.719219982624054, 0.7028816342353821, 1.329422116279602, 0.6001213788986206, 1.4242982268333435, 0.5007197856903076, 1.0719211101531982, 0.892078161239624, 0.7106577754020691, 0.5659230947494507, 0.52885901927948, 2.114516019821167, 0.5595292150974274, 0.7654550075531006, 0.9268836975097656, 0.5240356624126434, 0.3420359790325165, 1.1512879729270935, 0.7952545881271362, 0.7544941604137421, 1.2301671504974365, 0.5942314863204956, 1.0827386677265167, 0.6527367234230042, 0.9629349410533905, 0.7856687605381012, 0.919665515422821, 0.6876617074012756, 0.9258121848106384, 1.0152553915977478, 0.5943062603473663, 0.6340022683143616, 0.7844119668006897, 1.2664607763290405, 0.6466073393821716, 0.8280406296253204, 0.6004449725151062, 0.6677787601947784, 0.7929031848907471, 0.681636393070221, 0.7432670593261719, 0.4362238645553589, 0.6854266226291656, 0.6688488721847534, 0.6696682572364807, 0.5362562835216522, 0.8232583403587341, 1.324331134557724, 0.7072237730026245, 0.7201687693595886, 0.743109941482544, 0.7230481803417206, 0.7619365453720093, 1.21983402967453, 0.6444183588027954, 0.7917551398277283, 0.7728457450866699, 0.6061541736125946, 0.6740278899669647, 0.9891799092292786, 0.6183867454528809, 0.7239450216293335, 1.0226686596870422, 0.40176284313201904, 0.6419068276882172, 0.7850961685180664, 0.45498380064964294, 0.8610813021659851, 0.7161059379577637, 1.1368683576583862, 1.2926970720291138, 1.2338491678237915, 0.612011194229126, 0.6069281697273254, 0.6257272362709045, 0.8486833572387695, 0.9032807946205139, 0.9895166158676147, 0.5590817332267761, 0.7468024492263794, 0.7295109629631042, 0.702977180480957, 0.7693313956260681, 0.9976482391357422, 0.633469969034195, 0.907436341047287, 1.1266260147094727, 0.5514814853668213, 0.7555877566337585, 0.754696249961853, 0.6907256543636322, 1.010843276977539, 0.9405694007873535, 0.8880035877227783, 0.8082346022129059, 0.5499767661094666, 0.7863166928291321, 0.7091481685638428, 1.39766263961792, 0.7673428058624268, 0.7768785953521729, 1.16517972946167, 0.6960692405700684, 0.8103049993515015, 0.822517454624176, 0.732948899269104, 0.854661226272583, 1.065606415271759, 0.9367431700229645, 0.6430284380912781, 1.4403753280639648, 0.8649170696735382, 0.8432316482067108, 0.9966086149215698, 0.6912011504173279, 0.7775712609291077, 0.8568536639213562, 0.5071477890014648, 0.6993888914585114, 0.8572756052017212, 0.7366453111171722, 0.8733716607093811, 1.093202829360962, 0.5711365342140198, 0.9199234843254089, 0.9816634654998779, 1.1664412021636963, 0.8155450224876404, 0.848325252532959, 1.0368571877479553, 0.8923006653785706, 0.9791587591171265, 0.857076108455658, 0.6326217651367188, 1.0459421277046204, 0.6916070580482483, 0.7908634543418884, 1.0368950366973877, 0.6664791703224182, 0.678851842880249, 1.4450775980949402, 0.9311513304710388, 0.674682080745697, 0.5674668550491333, 0.6791991591453552, 0.6805894672870636, 0.9580948352813721, 0.6445362567901611, 0.6806508004665375, 1.1949130296707153, 0.9839023351669312, 0.919073760509491, 1.0275456309318542, 0.32746297121047974, 0.7729719877243042, 1.1600263118743896, 1.0938047766685486, 0.8184142708778381, 0.7273286581039429, 1.1607130765914917, 0.8890221118927002, 1.2127203941345215, 0.6193053722381592, 0.9375367164611816, 0.8548241853713989, 0.8366087079048157, 0.8774158358573914, 0.9690120816230774, 0.7799481749534607, 0.8277100920677185, 1.1499414443969727, 0.7318880259990692, 0.7195476293563843, 0.9464030861854553]}, "info": {"pct_words_masked": 0.3, "span_length": 10, "n_perturbations": 1, "n_samples": 700}, "raw_results": [{"original": "#include <stdio.h>\nint main(void)\n{\n\tint a[10];\n\tint i;\n\tint MAX[3];\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(i = 0; i < 3; i++)\n\t{\n\t\tMAX[i] = 0;\n\t}\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tif(MAX[0] < a[i])\n\t\t{\n\t\t\tMAX[0] = a[i];\n\t\t}\n\t}\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tif(MAX[1] < a[i])\n\t\t{\n\t\t\tif(a[i] < MAX[0])\n\t\t\t{\n\t\t\t\tMAX[1] = a[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tif(MAX[2] < a[i])\n\t\t{\n\t\t\tif(a[i] < MAX[1])\n\t\t\t{\n\t\t\t\tMAX[2] = a[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%d\\n\", MAX[i]);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int heights[10];\n    int i, j;\n    \n    for (i = 0; i < 10; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n    \n    for (i = 0; i < 10; i++) {\n        for (j = i + 1; j < 10; j++) {\n            if (heights[i] < heights[j]) {\n                int temp = heights[i];\n                heights[i] = heights[j];\n                heights[j] = temp;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", heights[0]);\n    printf(\"%d\\n\", heights[1]);\n    printf(\"%d\\n\", heights[2]);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int heights[10]; int i, j; for (i = 0; i < 10; i++) { scanf(\"%d\", &heights[i]); } for (i = 0; i < 10; i++) { for (j = i + 1; j < 10; j++) { if (heights[i]  heights[j] =  return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int a[10]; int i; int MAX[3]; for(i = 0; i < 10; i++) { scanf(\"%d\", &a[i]); } for(i = 0; i  0; i < 10; i++) { if(MAX[0] < a[i]) { MAX[0] = a[i]; } } for(i = 0; i < 10; i++) { if(MAX[1] <   if(MAX[2] < a[i]) { if(a[i] < MAX[1]) { MAX[2] = a[i]; } } } for(i = 0; i < 3; i++) { printf(\"%d\\n\", MAX[i]); } return 0; }"], "original_ll": -0.3639797866344452, "sampled_ll": -0.3564881384372711, "all_perturbed_sampled_ll": [-0.8701317310333252], "all_perturbed_original_ll": [-0.9040898084640503], "perturbed_sampled_ll": -0.8701317310333252, "perturbed_original_ll": -0.9040898084640503, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class Main{\n\tpublic static void main(String[] a) throws Exception {\n\t\tint[] heights = new int[10];\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tBufferedReader height = new BufferedReader(new InputStreamReader(System.in));\t\n\t\t\theights[i] = Integer.parseInt(height.readLine());\n\t\t\tSystem.out.println(heights[i]);\n\t\t}\n\t\tArrays.sort(heights);\n\t\tSystem.out.println(heights[0]);\n\t\tSystem.out.println(heights[1]);\n\t\tSystem.out.println(heights[2]);\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Integer[] heights = new Integer[10];\n        \n        for (int i = 0; i < 10; i++) {\n            heights[i] = sc.nextInt();\n        }\n        \n        Arrays.sort(heights, Collections.reverseOrder());\n        \n        System.out.println(heights[0]);\n        System.out.println(heights[1]);\n        System.out.println(heights[2]);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in); Integer[] heights = new Integer[10]; for (int i = 0; i < 10; i++) { heights[i] = sc.nextInt(); } Arrays.sort(heights, Collections.reverseOrder()); System.out.println(heights[0]); System.out.println(heights[1]); System.out.println(heights[2]); sc.close(); } }"], "perturbed_original": ["public class Main{ public static void main(String[] a) throws Exception { int[] heights = new int[10]; for (int i = 0; i  heights[i] = Integer.parseInt(height.readLine()); System.out.println(heights[i]); } Arrays.sort(heights); System.out.println(heights[0]); System.out.println(heights[1]); System.out.println(heights[2]); } }"], "original_ll": -0.9742730259895325, "sampled_ll": -0.46829789876937866, "all_perturbed_sampled_ll": [-0.8752027750015259], "all_perturbed_original_ll": [-1.3910490274429321], "perturbed_sampled_ll": -0.8752027750015259, "perturbed_original_ll": -1.3910490274429321, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\ne = sys.stdin.readlines()\ne = [int(i) for i in e]\nfor i in range(3):\n    m = max(e)\n    e.remove(m)\n    print (m)\n", "sampled": "heights = []\nfor _ in range(10):\n    heights.append(int(input()))\n\nheights.sort(reverse=True)\n\nfor i in range(3):\n    print(heights[i])\n", "perturbed_sampled": ["heights = [] for _ in range(10): heights.append(int(input())) heights.sort(reverse=True) for i in range(3): print(heights[i])"], "perturbed_original": ["import sys e = sys.stdin.readlines() e = [int(i) for i in e] for i in range(3): m = max(e) e.remove(m) print (m)"], "original_ll": -1.5143702030181885, "sampled_ll": -1.0439882278442383, "all_perturbed_sampled_ll": [-1.4483730792999268], "all_perturbed_original_ll": [-1.8697067499160767], "perturbed_sampled_ll": -1.4483730792999268, "perturbed_original_ll": -1.8697067499160767, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main()\n{\nint N, i, a, b, c, max;\n\nscanf(\"%d\", &N);\n\nfor(i=0; i<N; i++){\nscanf(\"%d %d %d\", &a, &b, &c);\n\nif(a<=b && b<=c){\nmax = c;\nif(c*c==a*a+b*b){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(a<=c && c<=b){\nmax = b;\nif(b*b==a*a+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(b<=c && c<=a){\nmax = a;\nif(a*a==b*b+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(b<=a && a<=c){\nmax = c;\nif(c*c==a*a+b*b){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(c<=a && a<=b){\nmax = b;\nif(b*b==a*a+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(c<=b && b<=a){\nmax = a;\nif(a*a==b*b+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\n\n}\n\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        \n        int aa = a * a;\n        int bb = b * b;\n        int cc = c * c;\n        \n        if (aa + bb == cc || aa + cc == bb || bb + cc == aa) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  int aa = a * a; int bb = b * b; int cc = c * c; if (aa + bb == cc || aa + cc == bb || bb + cc == aa) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h>  scanf(\"%d\",  if(a<=b && b<=c){ max = c; if(c*c==a*a+b*b){ puts(\"YES\"); }else{  if(b*b==a*a+c*c){ puts(\"YES\"); }else{ puts(\"NO\"); } } else if(b<=c && c<=a){ max = a; if(a*a==b*b+c*c){ puts(\"YES\"); }else{ puts(\"NO\"); } } else if(b<=a && a<=c){ max = c; if(c*c==a*a+b*b){ puts(\"YES\"); }else{ puts(\"NO\"); } } else if(c<=a && a<=b){ max = b; if(b*b==a*a+c*c){ puts(\"YES\"); }else{ puts(\"NO\"); } } else if(c<=b && b<=a){ max = a; if(a*a==b*b+c*c){ puts(\"YES\"); }else{ puts(\"NO\"); } } } return 0; }"], "original_ll": -0.4624471366405487, "sampled_ll": -0.41610050201416016, "all_perturbed_sampled_ll": [-1.2684866189956665], "all_perturbed_original_ll": [-0.8085376620292664], "perturbed_sampled_ll": -1.2684866189956665, "perturbed_original_ll": -0.8085376620292664, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tScanner kb=new Scanner(System.in);\nint size=kb.nextInt();\nint a[][]=new int[size][3];\nint x,y,z;\nfor(int i=0;i<size;i++){\n\ta[i][0]=kb.nextInt();\n\ta[i][1]=kb.nextInt();\n\ta[i][2]=kb.nextInt();\n}\nfor(int i=0;i<size;i++){\nx=a[i][0];\ny=a[i][1];\nz=a[i][2];\nif(x*x+y*y==z*z||y*y+z*z==x*x||z*z+x*x==y*y){\n\tSystem.out.println(\"YES\");\n}else{\n\tSystem.out.println(\"NO\");\n}\n}\n\t}\n\n}", "sampled": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            int[] sides = new int[3];\n            sides[0] = sc.nextInt();\n            sides[1] = sc.nextInt();\n            sides[2] = sc.nextInt();\n            \n            Arrays.sort(sides);\n            \n            if (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; import java.util.Arrays; public class Main { public  int n = sc.nextInt(); for (int i = 0; i < n; i++) { int[] sides = new int[3]; sides[0]  (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public  ????????????????????????????????????????????? Scanner kb=new Scanner(System.in); int size=kb.nextInt(); int a[][]=new int[size][3]; int x,y,z; for(int i=0;i<size;i++){ a[i][0]=kb.nextInt(); a[i][1]=kb.nextInt(); a[i][2]=kb.nextInt(); } for(int i=0;i<size;i++){ x=a[i][0]; y=a[i][1]; z=a[i][2]; if(x*x+y*y==z*z||y*y+z*z==x*x||z*z+x*x==y*y){ System.out.println(\"YES\"); }else{ System.out.println(\"NO\"); } } } }"], "original_ll": -0.8131423592567444, "sampled_ll": -0.33265969157218933, "all_perturbed_sampled_ll": [-1.1742125749588013], "all_perturbed_original_ll": [-0.8419753909111023], "perturbed_sampled_ll": -1.1742125749588013, "perturbed_original_ll": -0.8419753909111023, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N = int(input())\nfor i in range(N):\n    triangle = sorted([int(n) for n in input().split()])\n    if triangle[0]**2 + triangle[1]**2 == triangle[2]**2:\n        print('YES')\n    else:\n        print('NO')\n\n", "sampled": "n = int(input())\nfor _ in range(n):\n    sides = list(map(int, input().split()))\n    sides.sort()\n    if sides[0]**2 + sides[1]**2 == sides[2]**2:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["n = int(input()) for _ in range(n): sides = list(map(int, input().split())) sides.sort() if sides[0]**2 + sides[1]**2 == sides[2]**2: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["N = int(input()) for i in range(N): triangle = sorted([int(n) for n in input().split()]) if triangle[0]**2 + triangle[1]**2 == triangle[2]**2: print('YES') else: print('NO')"], "original_ll": -0.9703245759010315, "sampled_ll": -0.6357772946357727, "all_perturbed_sampled_ll": [-0.9484144449234009], "all_perturbed_original_ll": [-1.1713676452636719], "perturbed_sampled_ll": -0.9484144449234009, "perturbed_original_ll": -1.1713676452636719, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main( void )\n{\n    int a,b,c,d,e,f;\n    float x,y;\n    \n    while(scanf(\"%d %d %d %d %d %d\",&a,&b,&c,&d,&e,&f)!=-1){    \n        y = (float)( c*d -a*f ) / (b*d-a*e); \n        x = (float)( c*e -b*f ) / (a*e-b*d);\n        if(-0.0005<x && x<=0 ){\n            x = 0;\n        }\n        if(-0.0005<y && y<=0 ){\n            y = 0;\n        }\n        printf( \"%.3lf %.3f\\n\",x,y); \n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double a, b, c, d, e, f;\n    \n    while (scanf(\"%lf %lf %lf %lf %lf %lf\", &a, &b, &c, &d, &e, &f) != EOF) {\n        double x, y;\n        double det = a * e - b * d;\n        \n        x = (c * e - b * f) / det;\n        y = (a * f - c * d) / det;\n        \n        printf(\"%.3f %.3f\\n\", x, y);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double a, b, c, d, e, f; while (scanf(\"%lf %lf %lf %lf %lf %lf\",  x,  d; x = (c * e - b * f) / det; y = (a * f - c * d) / det; printf(\"%.3f %.3f\\n\", x, y); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main( void ) { int a,b,c,d,e,f; float x,y; while(scanf(\"%d %d %d %d %d %d\",&a,&b,&c,&d,&e,&f)!=-1){ y = (float)( c*d -a*f ) / (b*d-a*e); x = (float)( c*e -b*f ) / (a*e-b*d); if(-0.0005<x ){ y<extra_id_3>0.5;<extra_id_4>printf( '%.3f %.5f\\n\",x ){ y = 0; } printf( \"%.3lf %.3f\\n\",x,y); } return 0; }"], "original_ll": -1.2035702466964722, "sampled_ll": -0.6027036905288696, "all_perturbed_sampled_ll": [-1.553481936454773], "all_perturbed_original_ll": [-2.1793200969696045], "perturbed_sampled_ll": -1.553481936454773, "perturbed_original_ll": -2.1793200969696045, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString t[], s;\n\t\t\tdouble a[] = new double[6];\n\t\t\twhile((s = reader.readLine())  != null) {\n\t\t\t\tt = s.split(\" \");\n\t\t\t\tfor(int i = 0;i < a.length;i++) {\n\t\t\t\t\ta[i] = Double.parseDouble(t[i]);\n\t\t\t\t}\n\t\t\t\tdouble z = a[0]*a[4]-a[1]*a[3];\n\t\t\t\tdouble x = (a[4]*a[2]-a[1]*a[5])/z;\n\t\t\t\tdouble y = (-a[3]*a[2]+a[0]*a[5])/z;\n\n\t\t\t\tif(x == -0.0)\n\t\t\t\t\tx = 0.0;\n\t\t\t\tif(y == -0.0)\n\t\t\t\t\ty = 0.0;\n\t\t\t\tSystem.out.printf(\"%4.3f %4.3f\\n\", x, y);\n\n\t\t\t}\n\n\t\t}\n\t\tcatch(IOException e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double a = sc.nextDouble();\n            double b = sc.nextDouble();\n            double c = sc.nextDouble();\n            double d = sc.nextDouble();\n            double e = sc.nextDouble();\n            double f = sc.nextDouble();\n            \n            double det = a * e - b * d;\n            double x = (c * e - b * f) / det;\n            double y = (a * f - c * d) / det;\n            \n            System.out.printf(\"%.3f %.3f%n\", x, y);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) {  = sc.nextDouble(); double b = sc.nextDouble(); double c = sc.nextDouble(); double d = sc.nextDouble();  = a * e - b * d; double x = (c * e - b * f) / det; double y = (a * f - c * d) / det; System.out.printf(\"%.3f %.3f%n\", x, y); } sc.close(); } }"], "perturbed_original": ["import java.io.*; class Main { public static void main(String args[]) { try { BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); String t[], s; double a[] = new double[6]; while((s = reader.readLine()) != null) { t = s.split(\"  Double.parseDouble(t[i]); } double z =  == -0.0) x = 0.0; if(y == -0.0) y = 0.0; System.out.printf(\"%4.3f %4.3f\\n\", x, y); } } catch(IOException e) { System.out.println(e); } } }"], "original_ll": -0.8480775952339172, "sampled_ll": -0.502366840839386, "all_perturbed_sampled_ll": [-1.3589839935302734], "all_perturbed_original_ll": [-1.6265993118286133], "perturbed_sampled_ll": -1.3589839935302734, "perturbed_original_ll": -1.6265993118286133, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor line in sys.stdin:\n    a,b,c,d,e,f = map(float, line.split())\n    print((c*e-b*f)/(a*e-b*d), (a*f-c*d)/(a*e-b*d))", "sampled": "import sys\n\nfor line in sys.stdin:\n    a, b, c, d, e, f = map(float, line.split())\n    \n    # Using Cramer's rule\n    # ax + by = c\n    # dx + ey = f\n    \n    det = a * e - b * d\n    \n    if det != 0:\n        x = (c * e - b * f) / det\n        y = (a * f - c * d) / det\n    else:\n        # This shouldn't happen as per problem statement (unique solution)\n        x = 0\n        y = 0\n    \n    print(f\"{x:.3f} {y:.3f}\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: a, b, c, d, e, f = map(float, line.split()) # Using Cramer's rule # ax + by = c # dx + ey = f det = a * e - b * d if det != 0: x = (c * e - b * f) / det y = (a  This shouldn't happen as per problem  {y:.3f}\")"], "perturbed_original": ["import sys for line in sys.stdin: a,b,c,d,e,f = map(float, line.split()) print((c*e-b*f)/(a*e-b*d), (a*f-c*d)/(a*e-b*d))"], "original_ll": -1.4892786741256714, "sampled_ll": -0.9531593322753906, "all_perturbed_sampled_ll": [-2.1490259170532227], "all_perturbed_original_ll": [-1.6886614561080933], "perturbed_sampled_ll": -2.1490259170532227, "perturbed_original_ll": -1.6886614561080933, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n    int a,b,c,tmp,tmp_a,tmp_b;\n    while(scanf(\"%d%d\", &a, &b)!=EOF){\n        c = 1;\n        if(b > a){tmp = a; a = b; b = tmp;}\n        tmp_a = a;\n        tmp_b = b;\n        for(int i=2; i<=tmp_b; i++){\n            while(tmp_b%i==0 && tmp_a%i==0){\n                c = c*i;\n                tmp_b = tmp_b / i;\n                tmp_a = tmp_a / i;\n            }\n        }\n        printf(\"%d %d\\n\", c, tmp_a*tmp_b*c);\n    }\n    return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint main() {\n    long long a, b;\n    while (scanf(\"%lld %lld\", &a, &b) != EOF) {\n        long long g = gcd(a, b);\n        long long lcm = (a / g) * b;\n        printf(\"%lld %lld\\n\", g, lcm);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> long long gcd(long long a, long long b) { while (b != 0) { long long temp = b; b = a % b; a = temp; } return a; } int main() { long long   (a / g) * b; printf(\"%lld %lld\\n\", g, lcm); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int a,b,c,tmp,tmp_a,tmp_b; while(scanf(\"%d%d\", &a, &b)!=EOF){ c = 1; if(b > a){tmp = a; a = b; b = tmp;} tmp_a = a; tmp_b = b; for(int i=2; i<=tmp_b; i++){ while(tmp_b%i==0 && tmp_a%i==0){ c = c*i; tmp_b = tmp_b / i; tmp_a = tmp_a  0; }"], "original_ll": -0.9624162912368774, "sampled_ll": -0.39545580744743347, "all_perturbed_sampled_ll": [-1.2179020643234253], "all_perturbed_original_ll": [-1.434841513633728], "perturbed_sampled_ll": -1.2179020643234253, "perturbed_original_ll": -1.434841513633728, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\npublic class Main{\n\t/*\n\tpublic static long findGcd(long f1, long f2){\n\t\tlong gcd = 1;\n\t\tlong max, min;\n\t\tif(f1 > f2){max = f1; min = f2;}\n\t\telse{max = f2; min = f1;}\n\t\tfor(long i=1; i<=(long)(Math.sqrt(min)+1); i++){\n\t\t\tif(min % i == 0){\n\t\t\t\tlong tmp = min / i;\n\t\t\t\tif((max % tmp) == 0){\n\t\t\t\t\tgcd = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn gcd;\n\t}\n\t*/\n\tstatic long findGcd(long x, long y){\n        for(long i=1; i<=x; i++){\n            if(y*i%x==0){\n                return y*i;\n            }\n        }\n        return 0;\n    }\n\t\n\tpublic static long findlcm(long f1, long f2){\n\t\tlong lcm = 0;\n\t\tlong max, min;\n\t\tif(f1 > f2){max = f1; min = f2;}\n\t\telse{max = f2; min = f1;}\n\t\tlong i=1;\n\t\twhile(lcm == 0){\n\t\t\tif((max * i)%min == 0){\n\t\t\t\tlcm = max * i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn lcm;\n\t}\n\t\n\tpublic static void main(String[] argv) throws NumberFormatException, IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\twhile((line = br.readLine()) != null){\n\t\t\tString[] lineArray = line.split(\" \");\n\t\t\tlong[] factor = {Long.parseLong(lineArray[0]), Long.parseLong(lineArray[1])};\n\t\t\tlong gcd = findGcd(factor[0], factor[1]);\n\t\t\tlong lcm = findlcm(factor[0], factor[1]);\n\t\t\tSystem.out.println(gcd + \" \" + lcm);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            long a = sc.nextLong();\n            long b = sc.nextLong();\n            \n            long gcd = gcd(a, b);\n            long lcm = (a / gcd) * b;\n            \n            System.out.println(gcd + \" \" + lcm);\n        }\n        \n        sc.close();\n    }\n    \n    static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { long a = sc.nextLong();  lcm = (a / gcd) * b; System.out.println(gcd + \" \" +  { while (b != 0) { long temp = b; b = a % b; a = temp; } return a; } }"], "perturbed_original": ["import java.io.*; public  long gcd = 1; long max, min;  f2; min = f1;} for(long i=1; i<=(long)(Math.sqrt(min)+1); i++){ if(min % i == 0){ long tmp = min / i; if((max % tmp) == 0){ gcd = tmp; break; } } } return gcd; } */ static long findGcd(long x, long y){ for(long i=1; i<=x; i++){ if(y*i%x==0){ return y*i; } } return 0; } public static long findlcm(long f1, long f2){ long lcm  min = f2;} else{max = f2; min =  0){ lcm = max * i; } i++; } return lcm; } public static void main(String[] argv) throws NumberFormatException, IOException{ BufferedReader br  null){ String[] lineArray = line.split(\" \"); long[] factor = {Long.parseLong(lineArray[0]), Long.parseLong(lineArray[1])}; long gcd = findGcd(factor[0], factor[1]); long lcm = findlcm(factor[0], factor[1]); System.out.println(gcd + \" \" + lcm); } } }"], "original_ll": -0.7123250961303711, "sampled_ll": -0.36513805389404297, "all_perturbed_sampled_ll": [-1.3412796258926392], "all_perturbed_original_ll": [-1.7574607133865356], "perturbed_sampled_ll": -1.3412796258926392, "perturbed_original_ll": -1.7574607133865356, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\ntry:\n while 1:\n  a,b=map(int,input().split())\n  print(math.gcd(a,b),a*b// math.gcd(a, b))\nexcept:\n   pass\n ", "sampled": "import sys\nimport math\n\nfor line in sys.stdin:\n    a, b = map(int, line.split())\n    gcd = math.gcd(a, b)\n    lcm = (a * b) // gcd\n    print(gcd, lcm)\n", "perturbed_sampled": ["import sys import math for line in sys.stdin: a, b = map(int, line.split()) gcd = math.gcd(a, b) lcm = (a * b) // gcd print(gcd, lcm)"], "perturbed_original": ["import math try: while 1: a,b=map(int,input().split()) print(math.gcd(a,b),a*b// math.gcd(a, b)) except: pass"], "original_ll": -1.984938144683838, "sampled_ll": -0.7474801540374756, "all_perturbed_sampled_ll": [-1.5236250162124634], "all_perturbed_original_ll": [-2.036644458770752], "perturbed_sampled_ll": -1.5236250162124634, "perturbed_original_ll": -2.036644458770752, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio,h>\n#include<string.h>\nint main(){\nchar a[20];\nint l,i;\nscanf(\"%s\",a);\nl=strlen(a);\nfor(i=l-1;i>=0;i--)\nprintf(\"%c\",a[i]);\nreturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[21];\n    scanf(\"%s\", str);\n    int len = strlen(str);\n    for (int i = len - 1; i >= 0; i--) {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char str[21]; scanf(\"%s\", str); int len = strlen(str); for (int  printf(\"%c\", str[i]); } printf(\"\\n\"); return 0; }"], "perturbed_original": ["#include<stdio,h> #include<string.h> int main(){ char a[20]; int l,i; scanf(\"%s\",a); l=strlen(a); for(i=l-1;i>=0;i--) printf(\"%c\",a[i]); return 0; }"], "original_ll": -1.2246224880218506, "sampled_ll": -0.5319109559059143, "all_perturbed_sampled_ll": [-1.4700782299041748], "all_perturbed_original_ll": [-1.2631391286849976], "perturbed_sampled_ll": -1.4700782299041748, "perturbed_original_ll": -1.2631391286849976, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n    public static void main (String [] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        char [] str = sc.next().toCharArray();\n        for(int x = str.length-1; x >= 0; x--) {\n            System.out.print(str[x]);\n        }\n\n        System.out.print(\"\\n\");\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        StringBuilder sb = new StringBuilder(str);\n        System.out.println(sb.reverse().toString());\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.next(); StringBuilder sb = new StringBuilder(str); System.out.println(sb.reverse().toString()); sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main { public static void main (String [] args) { Scanner sc = new Scanner(System.in); char [] str = sc.next().toCharArray();  } System.out.print(\"\\n\"); } }"], "original_ll": -1.0607916116714478, "sampled_ll": -0.5665239691734314, "all_perturbed_sampled_ll": [-0.7957179546356201], "all_perturbed_original_ll": [-1.632391333580017], "perturbed_sampled_ll": -0.7957179546356201, "perturbed_original_ll": -1.632391333580017, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "print(input()[::-1])\n", "sampled": "s = input()\nprint(s[::-1])\n", "perturbed_sampled": ["s = input() print(s[::-1])"], "perturbed_original": ["print(input()[::-1])"], "original_ll": -5.215368747711182, "sampled_ll": -2.1085433959960938, "all_perturbed_sampled_ll": [-3.199462413787842], "all_perturbed_original_ll": [-4.715260982513428], "perturbed_sampled_ll": -3.199462413787842, "perturbed_original_ll": -4.715260982513428, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(){\n    int n,a=100000; scanf(\"%d\",&n);\n    while(n--){\n        a*=1.05;\n        if(a%1000>0) a=(a/1000+1)*1000;\n        else        a=a/1000*1000;\n    }\n    printf(\"%d\\n\",a);\n    exit(0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int debt = 100000;\n    \n    for (int i = 0; i < n; i++) {\n        debt = debt * 105 / 100;\n        if (debt % 1000 != 0) {\n            debt = (debt / 1000 + 1) * 1000;\n        }\n    }\n    \n    printf(\"%d\\n\", debt);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n); int debt = 100000; for (int i = 0; i < n; i++) { debt = debt * 105 / 100; if (debt % 1000 != 0) {  } printf(\"%d\\n\", debt); return 0; }"], "perturbed_original": ["main(){ int n,a=100000; scanf(\"%d\",&n); while(n--){ a*=1.05; if(a%1000>0) a=(a/1000+1)*1000; else a=a/1000*1000; } printf(\"%d\\n\",a); exit(0); }"], "original_ll": -1.2316865921020508, "sampled_ll": -0.6821125149726868, "all_perturbed_sampled_ll": [-1.1343215703964233], "all_perturbed_original_ll": [-1.155894160270691], "perturbed_sampled_ll": -1.1343215703964233, "perturbed_original_ll": -1.155894160270691, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tdouble sum = 100000;   //????????????10??????\n\t\tint ??? = 0;\t\t\t//?????????????????\u00b1???\n\n\t\t??? = Integer.parseInt(br.readLine());\n\n\t\tfor(int i = 0; i < ???; i++){\n\t\t\tsum = sum * 1.05;\n\t\t\tsum = sum / 1000;\n\t\t\tsum = Math.ceil(sum) * 1000;\n\t\t}\n\n\t\tSystem.out.println(sum);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        long debt = 100000;\n        \n        for (int i = 0; i < n; i++) {\n            debt = (long) Math.ceil(debt * 1.05 / 1000.0) * 1000;\n        }\n        \n        System.out.println(debt);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); long debt = 100000;  debt = (long) Math.ceil(debt * 1.05 / 1000.0) * 1000; } System.out.println(debt); sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); double sum = 100000; //????????????10?????? int ??? = 0; //?????????????????\u00b1??? ??? = Integer.parseInt(br.readLine()); for(int i = 0; i < ???; i++){ sum = sum *  1000; } System.out.println(sum); } }"], "original_ll": -1.2653131484985352, "sampled_ll": -0.7248121500015259, "all_perturbed_sampled_ll": [-1.2346073389053345], "all_perturbed_original_ll": [-1.5203280448913574], "perturbed_sampled_ll": -1.2346073389053345, "perturbed_original_ll": -1.5203280448913574, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "x = 100000\nfor i in range(int(input())):\n    x*=1.05\n    x+=999\n    x=x//1000*1000\nprint(x)", "sampled": "import math\n\nn = int(input())\ndebt = 100000\n\nfor _ in range(n):\n    debt = debt * 1.05\n    debt = math.ceil(debt / 1000) * 1000\n\nprint(int(debt))\n", "perturbed_sampled": ["import math n = int(input()) debt = 100000 for _ in range(n): debt = debt * 1.05 debt = math.ceil(debt / 1000) * 1000 print(int(debt))"], "perturbed_original": ["x = 100000 for i in range(int(input())): x*=1.05 x+=999 x=x//1000*1000 print(x)"], "original_ll": -1.692051649093628, "sampled_ll": -1.1002912521362305, "all_perturbed_sampled_ll": [-1.6002787351608276], "all_perturbed_original_ll": [-2.0290279388427734], "perturbed_sampled_ll": -1.6002787351608276, "perturbed_original_ll": -2.0290279388427734, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n \n#define MAX 1000000\n \nchar Prime[MAX];\n \nvoid PrimeSearch_Eratos( void ) //\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\n{\n    int i = 0, j = 0;\n \n    for( i = 0 ; i < MAX ; i ++ ) Prime[i] = 1;\n \n    Prime[0] = 0;\n    Prime[1] = 0;\n \n    for( i = 2 ; i <= sqrt( ( double )MAX ) + 1 ; i ++ ) //double\u306b\u30ad\u30e3\u30b9\u30c8\u3057\u306a\u3044\u3068\n    {                                                   //\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u304c\u306a\u3093\u305f\u3089\n        if( !Prime[i] ) continue;                       //\uff08\u3000\u309c\u0434\u309c\uff09\u30dd\u30ab\u30f3\n \n        for( j = i * 2 ; j <= MAX ; j += i )\n        {\n            Prime[j] = 0;\n        }\n    }\n \n    return ;\n}\n \nint main( void )\n{\n    int n = 0;\n \n    PrimeSearch_Eratos();\n \n    while( scanf( \"%d\", &n ) != EOF )\n    {\n        int i = 0;\n        int Count = 0;\n \n        for( i = 0 ; i <= n ; i ++ )\n        {\n            if( Prime[i] ) Count ++;\n        }\n \n        printf( \"%d\\n\", Count );\n    }\n \n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX 1000000\n\nint is_prime[MAX];\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int prime_count[MAX];\n    prime_count[0] = 0;\n    for (int i = 1; i < MAX; i++) {\n        prime_count[i] = prime_count[i-1] + is_prime[i];\n    }\n    \n    int n;\n    while (scanf(\"%d\", &n) != EOF) {\n        printf(\"%d\\n\", prime_count[n]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <math.h> #define MAX 1000000 int is_prime[MAX]; void sieve() { memset(is_prime, 1, sizeof(is_prime)); is_prime[0] = is_prime[1] = 0; for (int i = 2; i * i < MAX; i++) { if (is_prime[i]) { for (int j = i * i; j < MAX; j += i) { is_prime[j] = 0; } } } } int main() { sieve(); int prime_count[MAX]; prime_count[0] = 0; for (int i = 1;  printf(\"%d\\n\", prime_count[n]); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h>  { int i = 0, j = 0; for( i = 0 ; i < MAX ; i ++ ) Prime[i] =  2 ; i <= sqrt( ( double )MAX ) + 1 ; i ++ ) //double\u306b\u30ad\u30e3\u30b9\u30c8\u3057\u306a\u3044\u3068 { //\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u304c\u306a\u3093\u305f\u3089 if( !Prime[i] ) continue; //\uff08 \u309c\u0434\u309c\uff09\u30dd\u30ab\u30f3 for( j = i * 2 ; j <= MAX ; j += i ) { Prime[j] = 0; } } return ; }  while( scanf( \"%d\", &n ) != EOF ) { int i = 0; int Count = 0; for( i = 0 ; i <= n ;  printf( \"%d\\n\", Count ); } return 0; }"], "original_ll": -1.252685308456421, "sampled_ll": -0.414530485868454, "all_perturbed_sampled_ll": [-0.7678374648094177], "all_perturbed_original_ll": [-2.2963972091674805], "perturbed_sampled_ll": -0.7678374648094177, "perturbed_original_ll": -2.2963972091674805, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = in.readLine();\n\t\twhile (line != null) {\n\t\t\tStringTokenizer tk = new StringTokenizer(line);\n\t\t\tint n = Integer.parseInt(tk.nextToken());\n\t\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\t\tfor(int i = 2; i <= n; i++) {\n\t\t\t\tqueue.add(i);\n\t\t\t}\n\t\t\tint p = queue.remove();\n\t\t\tqueue.add(p);\n\t\t\tdo {\n\t\t\t\twhile (queue.element() != p) {\n\t\t\t\t\tint temp = queue.remove();\n\t\t\t\t\tif (temp % p != 0) {\n\t\t\t\t\t\tqueue.add(temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tqueue.add(queue.remove());\n\t\t\t\tp = queue.remove();\n\t\t\t\tqueue.add(p);\n\t\t\t} while (p != 2);\n\t\t\t\n\t\t\tint length = 0;\n\t\t\twhile (!queue.isEmpty()){\n\t\t\t\tlength ++;\n\t\t\t\tqueue.remove();\n\t\t\t}\n\t\t\tSystem.out.println(length);\n\t\t\tline = in.readLine();\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    private static final int MAX = 1000000;\n    private static boolean[] isPrime;\n    private static int[] primeCount;\n    \n    static {\n        isPrime = new boolean[MAX + 1];\n        primeCount = new int[MAX + 1];\n        \n        // Sieve of Eratosthenes\n        for (int i = 2; i <= MAX; i++) {\n            isPrime[i] = true;\n        }\n        \n        for (int i = 2; i * i <= MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= MAX; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        // Precompute prime counts\n        int count = 0;\n        for (int i = 0; i <= MAX; i++) {\n            if (i >= 2 && isPrime[i]) {\n                count++;\n            }\n            primeCount[i] = count;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            System.out.println(primeCount[n]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { private static final  int[] primeCount; static { isPrime = new boolean[MAX + 1];  for (int i = 2; i <= MAX; i++) { isPrime[i] = true; } for (int i = 2; i * i <= MAX; i++) { if (isPrime[i]) { for (int j = i * i; j <= MAX; j += i) { isPrime[j] = false; } }  (int  >= 2 && isPrime[i]) { count++; } primeCount[i] = count; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextInt()) { int n = sc.nextInt(); System.out.println(primeCount[n]); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String line = in.readLine(); while (line != null) { StringTokenizer tk = new StringTokenizer(line); int n = Integer.parseInt(tk.nextToken()); Queue<Integer> queue =  { queue.add(i); } int p = queue.remove(); queue.add(p); do { while (queue.element() != p) { int temp = queue.remove(); if (temp  length = 0; while (!queue.isEmpty()){ length ++; queue.remove(); } System.out.println(length); line = in.readLine(); } } }"], "original_ll": -0.7623087167739868, "sampled_ll": -0.3652052879333496, "all_perturbed_sampled_ll": [-0.927802562713623], "all_perturbed_original_ll": [-1.5829468965530396], "perturbed_sampled_ll": -0.927802562713623, "perturbed_original_ll": -1.5829468965530396, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nimport sys\n\nlst=[0 for _ in xrange(999999+1)]\n\ndef is_prime(num):\n  if num%2==0:\n      return 0\n  for x in range(3, int(num**0.5)+1,2):\n    if num % x==0:\n        return 0\n  return 1\n\nlst[1]=0\nlst[2]=1\nfor idx in range(3, len(lst)):\n  lst[idx] = is_prime(idx) + lst[idx-1]\n\nfor line in sys.stdin:\n  print lst[int(line)]", "sampled": "def sieve_of_eratosthenes(limit):\n    if limit < 2:\n        return []\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\nmax_n = 999999\nis_prime = sieve_of_eratosthenes(max_n)\nprime_count = [0] * (max_n + 1)\n\ncount = 0\nfor i in range(max_n + 1):\n    if is_prime[i]:\n        count += 1\n    prime_count[i] = count\n\nimport sys\nfor line in sys.stdin:\n    n = int(line.strip())\n    print(prime_count[n])\n", "perturbed_sampled": [" [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(limit**0.5) + 1): if is_prime[i]: for j in range(i*i, limit + 1, i): is_prime[j] = False return is_prime max_n = 999999 is_prime =  0 for i in range(max_n + 1): if is_prime[i]: count += 1 prime_count[i] = count import sys for line in sys.stdin: n = int(line.strip()) print(prime_count[n])"], "perturbed_original": ["import math import sys lst=[0 for _ in xrange(999999+1)] def  if num % x==0: return 0 return 1 lst[1]=0 lst[2]=1 for idx in range(3, len(lst)): lst[idx] = is_prime(idx) + lst[idx-1] for line in sys.stdin: print lst[int(line)]"], "original_ll": -1.1872968673706055, "sampled_ll": -0.5776638388633728, "all_perturbed_sampled_ll": [-1.2932459115982056], "all_perturbed_original_ll": [-2.3936071395874023], "perturbed_sampled_ll": -1.2932459115982056, "perturbed_original_ll": -2.3936071395874023, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nint main(int argc, const char * argv[])\n{\n\n    double x1, y1, x2, y2, x3, y3;\n    double midx1, midx2, midy1, midy2;\n    double circlex, circley;\n    double slant1, slant2;\n    double slice1, slice2;\n    double radius;\n    int i;\n    int input;\n    \n    scanf(\"%d\", &input);\n    for (i = 0; i < input; i++) {\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3);\n        midx1 = (x1 + x2) / 2;\n        midy1 = (y1 + y2) / 2;\n        midx2 = (x1 + x3) / 2;\n        midy2 = (y1 + y3) / 2;\n        slant1 = - (x2 - x1) / (y2 - y1);\n        slant2 = - (x3 - x1) / (y3 - y1);\n        slice1 = midy1 - slant1 * midx1;\n        slice2 = midy2 - slant2 * midx2;\n        circlex = (slice2 - slice1) / (slant1 - slant2);\n        circley = slant1 * circlex + slice1;\n        \n        if (x2 == x1) {\n            circley = midy1;\n            circlex = (circley - slice2) / slant2;\n        }\n        else if (y2 == y1) {\n            circlex = midx1;\n            circley = slant2 * circlex + slice2;\n        }\n        if(x3 == x1) {\n            circley = midy2;\n            circlex = (circley - slice1) / slant1;\n        }\n        else if (y3 == y1) {\n            circlex = midx2;\n            circley = slant1 * circlex + slice1;\n        }\n        if (x2 == x1 && y3 == y1) {\n            circley = midy1;\n            circlex = midx2;\n        }\n        else if (x3 == x1 && y2 == y1){\n            circley = midy2;\n            circlex = midx1;\n        }\n        radius = sqrt((circlex - x1) * (circlex - x1) + (circley - y1) * (circley - y1));\n        printf(\"%0.3f %0.3f %0.3f\\n\", circlex, circley, radius);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        double x1, y1, x2, y2, x3, y3;\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3);\n        \n        double a = 2 * (x2 - x1);\n        double b = 2 * (y2 - y1);\n        double c = x2 * x2 - x1 * x1 + y2 * y2 - y1 * y1;\n        \n        double d = 2 * (x3 - x1);\n        double e = 2 * (y3 - y1);\n        double f = x3 * x3 - x1 * x1 + y3 * y3 - y1 * y1;\n        \n        double px = (c * e - b * f) / (a * e - b * d);\n        double py = (a * f - c * d) / (a * e - b * d);\n        \n        double r = sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));\n        \n        printf(\"%.3f %.3f %.3f\\n\", px, py, r);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int n; scanf(\"%d\", &n); while (n--) { double x1, y1, x2, y2,   - x1); double b = 2 * (y2 - y1); double c = x2 * x2 - x1 * x1 + y2 * y2 - y1 * y1; double d = 2 * (x3 - x1); double e = 2 * (y3 -  x1 + y3 * y3 - y1 * y1; double px = (c * e -  d); double py = (a * f - c * d) / (a * e - b * d); double r = sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1)); printf(\"%.3f %.3f %.3f\\n\", px, py, r); } return 0; }"], "perturbed_original": [" double midx1, midx2, midy1, midy2; double circlex, circley; double slant1, slant2; double slice1, slice2; double radius; int i; int input; scanf(\"%d\", &input); for (i  %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3); midx1 = (x1 + x2) / 2; midy1 = (y1 + y2) / 2; midx2 =  / 2; slant1 = - (x2 - x1) / (y2 - y1); slant2 = - (x3 - x1) / (y3 - y1); slice1 = midy1 - slant1 * midx1; slice2 = midy2 - slant2 * midx2; circlex = (slice2 - slice1) / (slant1 - slant2); circley = slant1 * circlex + slice1; if (x2 == x1) { circley = midy1; circlex = (circley - slice2) / slant2; } else if (y2 == y1) { circlex = midx1; circley = slant2 * circlex + slice2; } if(x3 == x1) { circley = midy2; circlex = (circley - slice1) / slant1; } else if (y3 == y1) { circlex = midx2; circley  x1 && y3 == y1) { circley = midy1;  y2 == y1){ circley = midy2; circlex = midx1; } radius = sqrt((circlex - x1) *  y1)); printf(\"%0.3f %0.3f %0.3f\\n\", circlex, circley, radius); } return 0; }"], "original_ll": -0.6058400869369507, "sampled_ll": -0.3719322979450226, "all_perturbed_sampled_ll": [-1.1765917539596558], "all_perturbed_original_ll": [-1.085578203201294], "perturbed_sampled_ll": -1.1765917539596558, "perturbed_original_ll": -1.085578203201294, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tint n;\n\t\tdouble x1,x2,x3,y1,y2,y3,xp,yp,r,a1,a2,b1,b2,c1,c2,a,b;\n\t\tn=s.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx1=s.nextDouble();\n\t\t\ty1=s.nextDouble();\n\t\t\tx2=s.nextDouble();\n\t\t\ty2=s.nextDouble();\n\t\t\tx3=s.nextDouble();\n\t\t\ty3=s.nextDouble();\n\t\t\t\n\t\t\ta1=2*(x1-x2);//a\n\t\t\tb1=2*(y1-y2);//b\n\t\t\t//c\n\t\t\tc1=(x1*x1)-(x2*x2)+(y1*y1)-(y2*y2);\n\t\t\ta2=2*(x2-x3);//d\n\t\t\tb2=2*(y2-y3);//e\n\t\t\tc2=(x2*x2)-(x3*x3)+(y2*y2)-(y3*y3);\n\t\t\t\n\t\t\tif(c1*b2-b1*c2==0 ||a1*b2-a2*b1==0)xp=0;\n\t\t\telse\n\t\t\txp=(c1*b2-b1*c2)/(a1*b2-a2*b1);\n\t\t\tif(c1*a2-c2*a1==0 ||a2*b1-a1*b2==0)yp=0;\n\t\t\telse\n\t\t\typ=(c1*a2-c2*a1)/(a2*b1-a1*b2);\n\t\t\t\n\t\t\ta=xp-x1;\n\t\t\ta=a*a;\n\t\t\tb=yp-y1;\n\t\t\tb=b*b;\n\t\t\tr=Math.sqrt(a+b);\n\t\t\tif(r==0)\n\t\t\t\tr=0;\n\t\t\tSystem.out.printf(\"%.3f %.3f %.3f\\n\",xp,yp,r);\n\t\t}//for\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double x1 = sc.nextDouble();\n            double y1 = sc.nextDouble();\n            double x2 = sc.nextDouble();\n            double y2 = sc.nextDouble();\n            double x3 = sc.nextDouble();\n            double y3 = sc.nextDouble();\n            \n            double a = 2 * (x2 - x1);\n            double b = 2 * (y2 - y1);\n            double c = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2;\n            \n            double d = 2 * (x3 - x1);\n            double e = 2 * (y3 - y1);\n            double f = x1 * x1 - x3 * x3 + y1 * y1 - y3 * y3;\n            \n            double px = (b * f - e * c) / (b * d - e * a);\n            double py = (d * c - a * f) / (b * d - e * a);\n            \n            double r = Math.sqrt((x1 - px) * (x1 - px) + (y1 - py) * (y1 - py));\n            \n            System.out.printf(\"%.3f %.3f %.3f\\n\", px, py, r);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void  = sc.nextInt(); for (int i = 0; i < n; i++) { double  sc.nextDouble(); double y2 = sc.nextDouble(); double x3 = sc.nextDouble(); double y3 = sc.nextDouble(); double a = 2 * (x2 - x1); double b = 2 * (y2 - y1); double c = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2; double d = 2 * (x3 - x1); double e = 2 * (y3 - y1); double f = x1 * x1 - x3 * x3 + y1 * y1 - y3 * y3; double px = (b * f - e * c) / (b * d - e * a); double  = Math.sqrt((x1  * (y1 - py)); System.out.printf(\"%.3f %.3f %.3f\\n\", px, py, r); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner s=new Scanner(System.in); int n; double x1,x2,x3,y1,y2,y3,xp,yp,r,a1,a2,b1,b2,c1,c2,a,b; n=s.nextInt(); for(int i=0;i<n;i++){ x1=s.nextDouble(); y1=s.nextDouble(); x2=s.nextDouble(); y2=s.nextDouble(); x3=s.nextDouble(); y3=s.nextDouble(); a1=2*(x1-x2);//a b1=2*(y1-y2);//b //c c1=(x1*x1)-(x2*x2)+(y1*y1)-(y2*y2);  yp=(c1*a2-c2*a1)/(a2*b1-a1*b2); a=xp-x1; a=a*a; b=yp-y1; b=b*b; r=Math.sqrt(a+b); if(r==0) r=0; System.out.printf(\"%.3f %.3f %.3f\\n\",xp,yp,r); }//for } }"], "original_ll": -0.7100802659988403, "sampled_ll": -0.3787868618965149, "all_perturbed_sampled_ll": [-1.056795597076416], "all_perturbed_original_ll": [-1.1760540008544922], "perturbed_sampled_ll": -1.056795597076416, "perturbed_original_ll": -1.1760540008544922, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# coding: utf-8\n\nimport math\n\nn = int(raw_input())\n\nfor i in range(n):\n\tdata = map(float, raw_input().split())\n\tx1 = data[0]\n\ty1 = data[1]\n\tx2 = data[2]\n\ty2 = data[3]\n\tx3 = data[4]\n\ty3 = data[5]\n\n\tk = 0.5 * ( (x3-x2)*(x3-x1) + (y3-y2)*(y3-y1) ) / ( (x2-x1)*(y3-y1) + (y2-y1)*(x3-x1) )\n\n\tx = 0.5 * (x1 + x2) - k * (y2 - y1)\n\ty = 0.5 * (y1 + y2) + k * (x2 - x1)\n\n\tr = math.sqrt( (x-x1)**2 + (y-y1)**2 )\n\n\tprint(\"{:.3f} {:.3f} {:.3f}\".format(x,y,r))", "sampled": "import math\n\ndef circumcircle(x1, y1, x2, y2, x3, y3):\n    # Calculate D (denominator)\n    D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    \n    # Calculate center coordinates\n    ux = ((x1**2 + y1**2) * (y2 - y3) + (x2**2 + y2**2) * (y3 - y1) + (x3**2 + y3**2) * (y1 - y2)) / D\n    uy = ((x1**2 + y1**2) * (x3 - x2) + (x2**2 + y2**2) * (x1 - x3) + (x3**2 + y3**2) * (x2 - x1)) / D\n    \n    # Calculate radius\n    r = math.sqrt((x1 - ux)**2 + (y1 - uy)**2)\n    \n    return ux, uy, r\n\nn = int(input())\nfor _ in range(n):\n    coords = list(map(float, input().split()))\n    x1, y1, x2, y2, x3, y3 = coords\n    px, py, r = circumcircle(x1, y1, x2, y2, x3, y3)\n    print(f\"{px:.3f} {py:.3f} {r:.3f}\")\n", "perturbed_sampled": ["import math def circumcircle(x1, y1, x2, y2, x3, y3): # Calculate D (denominator) D = 2 * (x1 * (y2 - y3) +  * (y3 - y1) + (x3**2 + y3**2) * (y1 - y2)) / D uy = ((x1**2 + y1**2) * (x3 - x2) + (x2**2 + y2**2) * (x1 - x3) + (x3**2 + y3**2) * (x2 - x1)) / D  - uy)**2) return ux, uy, r n = int(input()) for _ in range(n): coords = list(map(float, input().split())) x1, y1, x2, y2, x3, y3 = coords px, py, r = circumcircle(x1, y1, x2, y2, x3, y3) print(f\"{px:.3f} {py:.3f} {r:.3f}\")"], "perturbed_original": ["# coding: utf-8 import math n = int(raw_input()) for i in range(n): data = map(float, raw_input().split()) x1 = data[0] y1 = data[1] x2  data[5] k = 0.5 * ( (x3-x2)*(x3-x1) + (y3-y2)*(y3-y1) ) / ( (x2-x1)*(y3-y1) + (y2-y1)*(x3-x1) ) x = 0.5 * (x1 + x2) - k * (y2 - y1) y = 0.5 * (y1 + y2) + k * (x2  {:.3f} {:.3f}\".format(x,y,r))"], "original_ll": -0.6766015887260437, "sampled_ll": -0.46626317501068115, "all_perturbed_sampled_ll": [-1.277060627937317], "all_perturbed_original_ll": [-1.281399130821228], "perturbed_sampled_ll": -1.277060627937317, "perturbed_original_ll": -1.281399130821228, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid swap(int *a, int *b){\n  int t=*a;*a=*b;*b=t;\n}\n\nint main(void){\n  int w,n,i,l[31];\n  scanf(\"%d\\n\",&w);\n  scanf(\"%d\\n\",&n);\n  for(i=1;i<=w;i++){\n    l[i]=i;\n  }\n  for(i=0;i<n;i++) {\n    int a,b;\n    scanf(\"%d,%d\\n\",&a,&b);\n    swap(&l[a],&l[b]);\n  }\n  for(i=1;i<=w;i++){\n    printf(\"%d\\n\", l[i]);\n  }\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int w, n;\n    int lines[31];\n    \n    scanf(\"%d\", &w);\n    scanf(\"%d\", &n);\n    \n    // Initialize vertical lines with numbers 1 to w\n    for (int i = 1; i <= w; i++) {\n        lines[i] = i;\n    }\n    \n    // Process each horizontal line\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        scanf(\"%d,%d\", &a, &b);\n        \n        // Swap the values at positions a and b\n        int temp = lines[a];\n        lines[a] = lines[b];\n        lines[b] = temp;\n    }\n    \n    // Print the final state\n    for (int i = 1; i <= w; i++) {\n        printf(\"%d\\n\", lines[i]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int w, n; int lines[31]; scanf(\"%d\", &w); scanf(\"%d\", &n); // Initialize vertical lines with numbers 1 to w for (int i = 1; i <= w; i++) { lines[i] = =<extra_id_1>{<extra_id_2>a<extra_id_3>3; scanf(\"%d\", &a, &b);<extra_id_4>int temp = lines[8;<extra_id_5>3; scanf(\"%d,%d\", &a, &b);<extra_id_6>n;<extra_id_7>( int o1 ,<extra_id_8>) {<extra_id_9>lines[7]; // Swap<extra_id_10>= lines[9];<extra_id_11>i = 0; i <<extra_id_12>+= 8<extra_id_13>)<extra_id_14>, & a<extra_id_15>( int b )<extra_id_16>{ while (<extra_id_17> = 0; i < n; i++) { int a, b; scanf(\"%d,%d\", &a, &b); // Swap the values at positions a and b int temp = lines[a]; lines[a] = lines[b]; lines[b] = temp; } // Print the final state for  lines[i]); } return 0; }"], "perturbed_original": ["#include <stdio.h> void swap(int *a, int *b){ int t=*a;*a=*b;*b=t; } int main(void){ int w,n,i,l[31]; scanf(\"%d\\n\",&w); scanf(\"%d\\n\",&n); for(i=1;i<=w;i++){ l[i]=i; } for(i=0;i<n;i++) { int a,b; scanf(\"%d,%d\\n\",&a,&b); swap(&l[a],&l[b]); } for(i=1;i<=w;i++){ printf(\"%d\\n\", l[i]); } return 0; }"], "original_ll": -0.9380918145179749, "sampled_ll": -0.7137984037399292, "all_perturbed_sampled_ll": [-1.939043402671814], "all_perturbed_original_ll": [-1.0048340559005737], "perturbed_sampled_ll": -1.939043402671814, "perturbed_original_ll": -1.0048340559005737, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class AOJ3_3{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint w = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tint[] values = new int[w];\n\t\tfor(int i=0;i<values.length;i++){\n\t\t\tvalues[i] = i + 1;\n\t\t}\n\t\tfor(int i = 0;i<n;i++){\n\t\t\tString str = sc.next();\n\t\t\tString[] ab = str.split(\",\");\n\t\t\tint a = Integer.parseInt(ab[0]) -1;\n\t\t\tint b = Integer.parseInt(ab[1]) -1;\n\t\t\tint temp = values[a];\n\t\t\tvalues[a] = values[b];\n\t\t\tvalues[b] = temp;\n\t\t}\n\t\tfor(int i = 0;i<w;i++){\n\t\t\tSystem.out.println(values[i]);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System);\n        \n        int w = sc.nextInt();\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        int[] lines = new int[w + 1];\n        for (int i = 1; i <= w; i++) {\n            lines[i] = i;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            \n            int temp = lines[a];\n            lines[a] = lines[b];\n            lines[b] = temp;\n        }\n        \n        for (int i = 1; i <= w; i++) {\n            System.out.println(lines[i]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System); int w = sc.nextInt(); int n = sc.nextInt(); sc.nextLine(); int[] lines  i <= w; i++) { lines[i] = i; } for (int i = 0; i < n;  int a = Integer.parseInt(parts[0]); int b = Integer.parseInt(parts[1]); int temp = lines[a]; lines[a] = lines[b]; lines[b] = temp; } for (int i = 1; i <= w; i++) { System.out.println(lines[i]); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class AOJ3_3{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int w =  for(int i=0;i<values.length;i++){  String str = sc.next(); String[] ab = str.split(\",\"); int a = Integer.parseInt(ab[0]) -1; int b = Integer.parseInt(ab[1]) -1; int temp = values[a]; values[a] = values[b]; values[b] = temp; } for(int i = 0;i<w;i++){ System.out.println(values[i]); } } }"], "original_ll": -0.7829795479774475, "sampled_ll": -0.5010590553283691, "all_perturbed_sampled_ll": [-1.2652429342269897], "all_perturbed_original_ll": [-1.4014849662780762], "perturbed_sampled_ll": -1.2652429342269897, "perturbed_original_ll": -1.4014849662780762, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\n\ndef solve(w, n):\n    l = [i for i in range(1, w+1)]\n    for _ in range(n):\n        a, b = map(int, input().split(','))\n        l[a], l[b] = l[b], l[a]\n\n    print(*l, sep='\\n')\n\nif __name__ == '__main__':\n    w = int(input())\n    n = int(input())\n    solve(w, n)", "sampled": "w = int(input())\nn = int(input())\n\n# Initialize positions: position[i] = number at position i (0-indexed)\npositions = list(range(1, w + 1))\n\n# Process each horizontal line\nfor _ in range(n):\n    line = input().strip()\n    a, b = map(int, line.split(','))\n    # Swap the numbers at positions a-1 and b-1 (converting to 0-indexed)\n    positions[a-1], positions[b-1] = positions[b-1], positions[a-1]\n\n# Output the final positions\nfor num in positions:\n    print(num)\n", "perturbed_sampled": ["w = int(input()) n = int(input()) # Initialize positions: position[i] = number at position i (0-indexed) positions = list(range(1, w + 1)) # Process each horizontal line for _ in range(n): line = input().strip()  positions a-1 and b-1 (converting to 0-indexed) positions[a-1], positions[b-1] = positions[b-1], positions[a-1] # Output the final positions for num in positions: print(num)"], "perturbed_original": ["# -*- coding: utf-8 -*- def solve(w, n): l = [i for i in range(1, w+1)] for _ in range(n): a, b = map(int, input().split(',')) l[a], l[b] = l[b], l[a] print(*l, sep='\\n') <extra_id_3>. split ( ','<extra_id_4>)<extra_id_5>+ \" \u2191 \" +<extra_id_6>print(*l, sep='\\n') \uf192 \" *<extra_id_7>+ \"-\" +<extra_id_8>- \":\" )<extra_id_9>print(sep='\\n')<extra_id_10>print(sep='\\n')==-1:<extra_id_11>*<extra_id_12>_ solve(w, n)"], "original_ll": -0.8045748472213745, "sampled_ll": -1.1788392066955566, "all_perturbed_sampled_ll": [-2.2455382347106934], "all_perturbed_original_ll": [-2.1266942024230957], "perturbed_sampled_ll": -2.2455382347106934, "perturbed_original_ll": -2.1266942024230957, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main() {\n\tint i = 0, k = 0, n, car[100] = {0}, out[100] = {0};\n\twhile(scanf(\"%d\", &n)!= EOF) {\n\t\tif(n == 0) {\n\t\t\ti--;\n\t\t\tout[k] = car[i];\n\t\t\tk++;\n\t\t} else {\n\t\t\tcar[i] = n;\n\t\t\ti++;\n\t\t}\n\t}\n\tfor(i = 0; i < k; i++) printf(\"%d\\n\", out[i]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int stack[100];\n    int top = -1;\n    int input;\n    \n    while (scanf(\"%d\", &input) != EOF) {\n        if (input == 0) {\n            printf(\"%d\\n\", stack[top]);\n            top--;\n        } else {\n            top++;\n            stack[top] = input;\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" -1; int input; while (scanf(\"%d\", &input) != EOF) { if (input == 0) { printf(\"%d\\n\", stack[top]); top--; } else { top++; stack[top] = input; } } return 0; }"], "perturbed_original": ["#include <stdio.h>  n, car[100] = {0}, out[100] = {0}; while(scanf(\"%d\", &n)!= EOF) { if(n == 0) { i--; out[k] = car[i]; k++; } else { car[i] = n; i++; } } for(i = 0; i < k; i++) printf(\"%d\\n\", out[i]); return 0; }"], "original_ll": -0.9581671953201294, "sampled_ll": -0.6566348671913147, "all_perturbed_sampled_ll": [-1.424395203590393], "all_perturbed_original_ll": [-1.483101487159729], "perturbed_sampled_ll": -1.424395203590393, "perturbed_original_ll": -1.483101487159729, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n \npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        Stack<Integer> stack = new Stack<Integer>();\n        while(sc.hasNextInt()){\n            int a=sc.nextInt();\n            if(a==0){\n                System.out.println(stack.pop());\n            }else{\n                stack.push(a);\n            }\n        }\n    }\n}", "sampled": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Stack<Integer> stack = new Stack<>();\n        \n        while (sc.hasNext()) {\n            int num = sc.nextInt();\n            if (num == 0) {\n                System.out.println(stack.pop());\n            } else {\n                stack.push(num);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" void main(String[] args) { Scanner sc = new Scanner(System.in); Stack<Integer> stack = new Stack<>(); while (sc.hasNext()) { int num = sc.nextInt(); if (num == 0) { System.out.println(stack.pop()); } else { stack.push(num); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); Stack<Integer> stack = new Stack<Integer>(); while(sc.hasNextInt()){ int a=sc.nextInt(); if(a==0){ System.out.println(stack.pop()); }else{ stack.push(a); } } } }"], "original_ll": -0.8031933307647705, "sampled_ll": -0.46601009368896484, "all_perturbed_sampled_ll": [-0.9262014627456665], "all_perturbed_original_ll": [-0.9043402671813965], "perturbed_sampled_ll": -0.9262014627456665, "perturbed_original_ll": -0.9043402671813965, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a = []\nwhile True:\n    s = int(input())\n    if s != 0:\n        a.append(s)\n    else:\n        print(a.pop())\n    if len(a) == 0:\n        break", "sampled": "import sys\n\nstack = []\nfor line in sys.stdin:\n    num = int(line.strip())\n    if num == 0:\n        print(stack.pop())\n    else:\n        stack.append(num)\n", "perturbed_sampled": ["import sys stack = [] for line in sys.stdin: num = int(line.strip()) if num == 0: print(stack.pop()) else: stack.append(num)"], "perturbed_original": ["a = [] while True: s = int(input()) if s != 0: a.append(s) else: print(a.pop()) if len(a) == 0: break"], "original_ll": -1.2479687929153442, "sampled_ll": -1.087868571281433, "all_perturbed_sampled_ll": [-1.8590995073318481], "all_perturbed_original_ll": [-1.7124792337417603], "perturbed_sampled_ll": -1.8590995073318481, "perturbed_original_ll": -1.7124792337417603, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main()\n{\n    int n, i;\n    long long int sum;\n    \n    while(scanf(\"%d\", &n) != EOF){\n    \tsum = 0;\n        for (i = n; i <= 600 - n; i += n){\n            sum += i * i;\n        }\n        sum *= n;\n        printf(\"%lld\\n\", sum);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int d;\n    while (scanf(\"%d\", &d) != EOF) {\n        long long area = 0;\n        for (int x = d; x <= 600 - d; x += d) {\n            area += (long long)d * x * x;\n        }\n        printf(\"%lld\\n\", area);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int d; while (scanf(\"%d\", &d) != EOF) { long long area = 0; for (int x = d; x <= 600 - d; x += d) { area += (long long)d ); } }"], "perturbed_original": ["#include <stdio.h> int main() { int n, i; long long int sum;  n; i <= 600 - n; i += n){ sum += i * i; } sum *= n; printf(\"%lld\\n\", sum); } return 0; }"], "original_ll": -1.2436610460281372, "sampled_ll": -1.102943778038025, "all_perturbed_sampled_ll": [-1.9603904485702515], "all_perturbed_original_ll": [-2.116459369659424], "perturbed_sampled_ll": -1.9603904485702515, "perturbed_original_ll": -2.116459369659424, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/**\n * \n * AOJ No. 0014 Integral\n * \n * @author \tyuichirw <y.iky917@gmail.com+>\n * @see\t\thttp://rose.u-aizu.ac.jp/onlinejudge/ProblemSet/description.jsp?id=0014&lang=jp\n */\n\nimport java.util.*;\npublic class Main {\n\t\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int d;\n\t\n\tstatic boolean read() {\n\t\tif(!sc.hasNextInt()) return false;\n\t\td = sc.nextInt();\n\t\treturn true;\n\t}\n\t\n\tstatic int solve() {\n\t\tint ans,n;\n\t\tans = 0; n = 600 / d;\n\t\tfor(int x = d; x < 600; x += d) {\n\t\t\tans += d * ((x * x));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int d = sc.nextInt();\n            long area = 0;\n            \n            for (int x = d; x < 600; x += d) {\n                area += (long) d * x * x;\n            }\n            \n            System.out.println(area);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main  new Scanner(System.in); while (sc.hasNext()) { int d = sc.nextInt(); long area = 0; for (int x = d; x < 600; x += d) { area += (long) d * x * x; } System.out.println(area); } sc.close(); } }"], "perturbed_original": ["/** * * AOJ No. 0014 Integral * * @author yuichirw <y.iky917@gmail.com+> * @see http://rose.u-aizu.ac.jp/onlinejudge/ProblemSet/description.jsp?id=0014&lang=jp */ import java.util.*; public class Main { static Scanner sc = new Scanner(System.in); static int d; static boolean read() { if(!sc.hasNextInt()) return false; d = sc.nextInt(); return true; } static int solve() { int ans,n; ans = 0; n = 600 / d; for(int x = d; x <  * x)); } return ans; } public  }"], "original_ll": -1.7803517580032349, "sampled_ll": -0.9102402329444885, "all_perturbed_sampled_ll": [-1.6263405084609985], "all_perturbed_original_ll": [-2.5875344276428223], "perturbed_sampled_ll": -1.6263405084609985, "perturbed_original_ll": -2.5875344276428223, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\n\nimport sys\nimport math\n\ndef rectArea(h, w):\n    return h * w\n\n\nfor d in sys.stdin:\n    area = 0\n    d = int(d)\n    for i in range(0, 600, d):\n        area += rectArea(i*i, d)\n\n    print(area)", "sampled": "import sys\n\nfor line in sys.stdin:\n    d = int(line.strip())\n    s = 0\n    x = d\n    while x <= 600 - d:\n        s += d * (x * x)\n        x += d\n    print(s)\n", "perturbed_sampled": ["import sys for line in sys.stdin: d = int(line.strip()) s = 0 x = d while x <= 600 - d: s += d * (x * x) x += d print(s)"], "perturbed_original": ["#!/usr/bin/env python #-*-  h * w for d in sys.stdin: area = 0 d = int(d) for i in range(0, 600, d): area += rectArea(i*i, d) print(area)"], "original_ll": -1.489491581916809, "sampled_ll": -1.4992849826812744, "all_perturbed_sampled_ll": [-2.1620326042175293], "all_perturbed_original_ll": [-3.1075634956359863], "perturbed_sampled_ll": -2.1620326042175293, "perturbed_original_ll": -3.1075634956359863, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\t__int64 a, b, sum;\n\tint keta;\n\tint n;\n\tint i;\n\t\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++){\n\t\tscanf(\"%I64u\", &a);\n\t\tscanf(\"%I64u\", &b);\n\t\tsum = a + b;\n\t\t\n\t\tketa = 1;\n\t\twhile (sum / 10 > 0){\n\t\t\tketa++;\n\t\t\tsum /= 10;\n\t\t}\n\t\t\n\t\tif (keta > 80){\n\t\t\tprintf(\"overflow\\n\");\n\t\t}\n\t\telse {\n\t\t\tsum = a + b;\n\t\t\tprintf(\"%I64u\\n\", sum);\n\t\t}\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid reverseString(char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        char temp = str[i];\n        str[i] = str[len - 1 - i];\n        str[len - 1 - i] = temp;\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    while (N--) {\n        char num1[105], num2[105], result[105];\n        scanf(\"%s %s\", num1, num2);\n        \n        int len1 = strlen(num1);\n        int len2 = strlen(num2);\n        \n        // Check if input has more than 80 digits\n        if (len1 > 80 || len2 > 80) {\n            printf(\"overflow\\n\");\n            continue;\n        }\n        \n        // Reverse the strings for easier addition\n        reverseString(num1);\n        reverseString(num2);\n        \n        int maxLen = (len1 > len2) ? len1 : len2;\n        int carry = 0;\n        int resultLen = 0;\n        \n        for (int i = 0; i < maxLen || carry; i++) {\n            int digit1 = (i < len1) ? (num1[i] - '0') : 0;\n            int digit2 = (i < len2) ? (num2[i] - '0') : 0;\n            \n            int sum = digit1 + digit2 + carry;\n            result[resultLen++] = (sum % 10) + '0';\n            carry = sum / 10;\n        }\n        \n        result[resultLen] = '\\0';\n        \n        // Check if result has more than 80 digits\n        if (resultLen > 80) {\n            printf(\"overflow\\n\");\n            continue;\n        }\n        \n        // Reverse result back\n        reverseString(result);\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <ctype.h> void reverseString(char *str) { int len = strlen(str); for (int i  temp = str[i]; str[i] = str[len - 1 - i]; str[len  { int N; scanf(\"%d\", &N); while (N--) { char num1[105], num2[105], result[105];  = strlen(num2); // Check if input has more than 80 digits if (len1 > 80 || len2 > 80) { printf(\"overflow\\n\"); continue; } // Reverse the strings  len2) ? len1 : len2; int carry = 0; int resultLen = 0; for (int i = 0; i < maxLen || carry; i++) {  : 0; int digit2 = (i < len2) ? (num2[i] - '0') : 0; int sum =  + '0'; carry = sum / 10; } result[resultLen] = '\\0'; // Check if result has more than 80 digits if (resultLen > 80) { printf(\"overflow\\n\"); continue; } // Reverse result back reverseString(result); printf(\"%s\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { __int64 a, b, sum; int keta; int n;  n; i++){ scanf(\"%I64u\", &a); scanf(\"%I64u\", &b); sum = a + b; keta  /= 10; } if (keta > 80){ printf(\"overflow\\n\"); } else { sum = a + b; printf(\"%I64u\\n\", sum); } } return (0); }"], "original_ll": -1.007934331893921, "sampled_ll": -0.4213179349899292, "all_perturbed_sampled_ll": [-1.5029690265655518], "all_perturbed_original_ll": [-1.7674070596694946], "perturbed_sampled_ll": -1.5029690265655518, "perturbed_original_ll": -1.7674070596694946, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (sc.hasNext()) {\n\t\t\tString s1 = sc.next();\n\t\t\tString s2 = sc.next();\n\t\t\tif (s1.length() > 80 || s2.length() > 80)\n\t\t\t\tSystem.out.println(\"overflow\");\n\t\t\tBigInteger b = new BigInteger(s1).add(new BigInteger(s2));\n\t\t\tSystem.out.println(b.toString().length() > 80 ? \"overflow\" : b);\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\nimport java.math.BigInteger;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String a = sc.nextLine().trim();\n            String b = sc.nextLine().trim();\n            \n            if (a.length() > 80 || b.length() > 80) {\n                System.out.println(\"overflow\");\n                continue;\n            }\n            \n            BigInteger num1 = new BigInteger(a);\n            BigInteger num2 = new BigInteger(b);\n            BigInteger sum = num1.add(num2);\n            \n            String result = sum.toString();\n            if (result.length() > 80) {\n                System.out.println(\"overflow\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.math.BigInteger; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); for (int i = 0; i <  sc.nextLine().trim(); if (a.length() > 80 || b.length() > 80) { System.out.println(\"overflow\"); continue; } BigInteger num1 = new  String result = sum.toString(); if (result.length() > 80) { System.out.println(\"overflow\"); } else { System.out.println(result); } } sc.close(); } }"], "perturbed_original": ["import java.math.BigInteger; import  { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s1 = sc.next(); String s2 = sc.next(); if (s1.length() > 80 || s2.length() > 80) System.out.println(\"overflow\"); BigInteger b = new BigInteger(s1).add(new BigInteger(s2)); System.out.println(b.toString().length() > 80 ? \"overflow\" : b); } } }"], "original_ll": -0.9025217890739441, "sampled_ll": -0.46931561827659607, "all_perturbed_sampled_ll": [-1.4596706628799438], "all_perturbed_original_ll": [-1.2458051443099976], "perturbed_sampled_ll": -1.4596706628799438, "perturbed_original_ll": -1.2458051443099976, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = input()\n\nfor i in range(n):\n    a = input(),\n    b = input()\n    c = a + b\n    if len(a) > 80 or len(b) > 80 or len(c) > 80 :\n        print 'overflow'\n    else:\n        print a + b", "sampled": "N = int(input())\nfor _ in range(N):\n    a = input().strip()\n    b = input().strip()\n    \n    # Check if input integers have more than 80 digits\n    if len(a) > 80 or len(b) > 80:\n        print(\"overflow\")\n        continue\n    \n    # Convert to integers and calculate sum\n    num_a = int(a)\n    num_b = int(b)\n    result = num_a + num_b\n    \n    # Check if sum has more than 80 digits\n    if len(str(result)) > 80:\n        print(\"overflow\")\n    else:\n        print(result)\n", "perturbed_sampled": ["N  = input().strip() # Check if input integers have more than 80 digits if len(a) > 80 or len(b) > 80: print(\"overflow\") continue # Convert to integers and calculate sum num_a = int(a) num_b = int(b) result = num_a + num_b # Check if sum has  print(result)"], "perturbed_original": ["n = input() for i in  + b if len(a) > 80 or len(b) > 80 or len(c) > 80 : print 'overflow' else: print a + b"], "original_ll": -1.3746049404144287, "sampled_ll": -0.8419777154922485, "all_perturbed_sampled_ll": [-2.477666139602661], "all_perturbed_original_ll": [-2.4623143672943115], "perturbed_sampled_ll": -2.477666139602661, "perturbed_original_ll": -2.4623143672943115, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0016\nTresure hunt\n*/\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\ndouble x,y;\nint len,arg;\ndouble PAI=3.14159265;\n\nmain()\n{\n  x=0.0; y=0.0;\n  int argsum = 90; \n\n  while(EOF != scanf(\"%d,%d\",&len,&arg) && (len || arg))\n    {\n      x += cos(((double)argsum)*(PAI/180))*(double)len;\n      y += sin(((double)argsum)*(PAI/180))*(double)len;\n\n      //printf(\"%d:%d %d %d %d\\n\",(int)x,(int)y,argsum,len,arg);\n      argsum -= arg;\n    }\n  printf(\"%d\\n%d\\n\",(int)x,(int)y);\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int d, t;\n    double x = 0.0, y = 0.0;\n    double angle = 90.0; // Start facing north (90 degrees from east)\n    \n    while(1) {\n        scanf(\"%d,%d\", &d, &t);\n        if(d == 0 && t == 0) break;\n        \n        // Move d steps in current direction\n        double rad = angle * M_PI / 180.0;\n        x += d * cos(rad);\n        y += d * sin(rad);\n        \n        // Turn clockwise by t degrees (subtract from angle)\n        angle -= t;\n    }\n    \n    printf(\"%d\\n%d\\n\", (int)x, (int)y);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int d, t; double x = 0.0, y = 0.0; double angle = 90.0; // Start facing north (90 degrees from east) while(1) { scanf(\"%d,%d\", &d, &t); if(d == 0 && t == 0)  = angle * M_PI / 180.0; x += d * cos(rad); y += d  angle) angle -= t; } printf(\"%d\\n%d\\n\", (int)x, (int)y); return 0; }"], "perturbed_original": ["/* AizuOnline A0016 Tresure hunt */  double PAI=3.14159265; main() { x=0.0; y=0.0; int argsum = 90; while(EOF != scanf(\"%d,%d\",&len,&arg) && (len || arg)) { x += cos(((double)argsum)*(PAI/180))*(double)len; y += sin(((double)argsum)*(PAI/180))*(double)len; //printf(\"%d:%d %d %d %d\\n\",(int)x,(int)y,argsum,len,arg); argsum -= arg; } printf(\"%d\\n%d\\n\",(int)x,(int)y); return(0); }"], "original_ll": -1.846888542175293, "sampled_ll": -0.9779632687568665, "all_perturbed_sampled_ll": [-1.629982829093933], "all_perturbed_original_ll": [-2.0750694274902344], "perturbed_sampled_ll": -1.629982829093933, "perturbed_original_ll": -2.0750694274902344, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tpublic static void main(String[] aegs){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint a = 0,c=0;\n\t\tString t = \"\";\n\t\tdouble counta =0,countb = 0;\n\t\tdouble rad = 90.0;\n\t\tdouble PI = Math.PI;\n\t\t\n\t\twhile(true){\n\t\t\n\t\t\ttry {\n\t\t\t\tt = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tString[] tt = t.split(\",\",0);\n\t\t\ta = Integer.parseInt(tt[0]);\n\t\t\tc = Integer.parseInt(tt[1]);\n\t\t\tif(a == 0 && c == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tcounta +=  (a * Math.sin(rad*PI/180d));\n\t\t\tcountb +=  (a * Math.cos(rad*PI/180d));\n\t\t\trad = rad - c;\n\t\t\t\n\t\t}\n\t\tSystem.out.println((int)countb);\n\t\tSystem.out.println((int)counta);\n\t\t\n\t}\n\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        double x = 0;\n        double y = 0;\n        double angle = 90; // Starting facing north (90 degrees from east)\n        \n        while (true) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int d = Integer.parseInt(parts[0].trim());\n            int t = Integer.parseInt(parts[1].trim());\n            \n            if (d == 0 && t == 0) {\n                break;\n            }\n            \n            // Move d steps in current direction\n            double radians = Math.toRadians(angle);\n            x += d * Math.cos(radians);\n            y += d * Math.sin(radians);\n            \n            // Turn clockwise by t degrees (subtract because clockwise is negative rotation)\n            angle -= t;\n        }\n        \n        System.out.println((int)x);\n        System.out.println((int)y);\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args)  double y = 0; double angle = 90; // Starting facing north (90 degrees  parts = line.split(\",\"); int d = Integer.parseInt(parts[0].trim()); int t = Integer.parseInt(parts[1].trim()); if  // Move d steps in current direction double radians = Math.toRadians(angle); x += d * Math.cos(radians); y += d * Math.sin(radians); // Turn clockwise by t degrees (subtract because clockwise is negative rotation) angle -= t; } System.out.println((int)x); System.out.println((int)y); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader;  br = new BufferedReader(new InputStreamReader(System.in)); int a = 0,c=0; String t = \"\";  PI = Math.PI; while(true){ try { t = br.readLine(); } catch (IOException e) { // TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af e.printStackTrace(); } String[] tt = t.split(\",\",0); a = Integer.parseInt(tt[0]); c = Integer.parseInt(tt[1]); if(a == 0 && c == 0){ break; } counta += (a * Math.sin(rad*PI/180d)); countb += (a * Math.cos(rad*PI/180d)); rad = rad - c; } System.out.println((int)countb); System.out.println((int)counta); } }"], "original_ll": -1.1677932739257812, "sampled_ll": -0.9668667912483215, "all_perturbed_sampled_ll": [-2.153245687484741], "all_perturbed_original_ll": [-1.572556734085083], "perturbed_sampled_ll": -2.153245687484741, "perturbed_original_ll": -1.572556734085083, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import turtle\nk = turtle.Turtle()\nk.speed(0)\nk.left(90)\nwhile True:\n    x = map(int,raw_input().split(\",\"))\n    if x[0] == 0 and x[1] == 0:\n        break\n    else:\n        k.fd(x[0])\n        k.right(x[1])\n        continue\nprint int(k.xcor())\nprint int(k.ycor())", "sampled": "import math\n\nx = 0.0\ny = 0.0\nangle = 90.0  # Starting direction: north (90 degrees from east)\n\nwhile True:\n    line = input().strip()\n    d, t = map(int, line.split(','))\n    \n    if d == 0 and t == 0:\n        break\n    \n    # Move d steps in current direction\n    x += d * math.cos(math.radians(angle))\n    y += d * math.sin(math.radians(angle))\n    \n    # Turn clockwise by t degrees (subtract because clockwise is negative)\n    angle -= t\n\nprint(int(x))\nprint(int(y))\n", "perturbed_sampled": ["import math x = 0.0 y = 0.0 angle = 90.0 # Starting direction: north (90 degrees from  line.split(',')) if d == 0 and t == 0: break # Move d steps in current direction x  Turn clockwise by t degrees (subtract because clockwise is negative) angle -= t print(int(x)) print(int(y))"], "perturbed_original": ["import turtle k = turtle.Turtle() k.speed(0) k.left(90) while True: x = map(int,raw_input().split(\",\")) if x[0] == 0 and x[1] == 0: break else: k.fd(x[0]) k.right(x[1]) continue print int(k.xcor()) print int(k.ycor())"], "original_ll": -1.2465925216674805, "sampled_ll": -1.2478376626968384, "all_perturbed_sampled_ll": [-3.118558168411255], "all_perturbed_original_ll": [-1.5003662109375], "perturbed_sampled_ll": -3.118558168411255, "perturbed_original_ll": -1.5003662109375, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n    int a[5],i,j,k;\n    int x=0;\n\n    for(i=0;i<5;i++){\n        scanf(\"%d\",&a[i]);\n        for(j=0;j<5;j++){\n            if(a[i]>a[j]){\n                x=a[i];\n                a[i]=a[j];\n                a[j]=x;\n            }\n        }\n    }\n    for(k=0;k<5;k++){\n        printf(\"%d \",a[k]);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int arr[5];\n    int i, j, temp;\n    \n    for(i = 0; i < 5; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    for(i = 0; i < 4; i++) {\n        for(j = i + 1; j < 5; j++) {\n            if(arr[i] < arr[j]) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    \n    for(i = 0; i < 5; i++) {\n        if(i > 0) printf(\" \");\n        printf(\"%d\", arr[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n", "perturbed_sampled": [" temp; for(i = 0; i < 5; i++) { scanf(\"%d\", &arr[i]); } for(i  + 1; j < 5; j++) { if(arr[i] < arr[j]) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } for(i = 0; i < 5; i++) { if(i > 0) printf(\" \"); printf(\"%d\", arr[i]); } printf(\"\\n\"); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int a[5],i,j,k; int x=0; for(i=0;i<5;i++){ scanf(\"%d\",&a[i]); for(j=0;j<5;j++){ if(a[i]>a[j]){ x=a[i]; a[i]=a[j]; a[j]=x; } } } for(k=0;k<5;k++){ printf(\"%d \",a[k]); } return 0; }"], "original_ll": -0.6816065907478333, "sampled_ll": -0.38891369104385376, "all_perturbed_sampled_ll": [-0.9517205357551575], "all_perturbed_original_ll": [-0.8126916289329529], "perturbed_sampled_ll": -0.9517205357551575, "perturbed_original_ll": -0.8126916289329529, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Int implements Comparable<Int>{\n\tpublic int i;\n\tInt(int i){this.i = i;}\n\tpublic int compareTo (Int I){return I.i - this.i;}\n}\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\n\t\t//input\n\t\tScanner sc = new Scanner(System.in).useDelimiter(System.getProperty(\"line.separator\"));\n\t\tString[] s = sc.next().split(\"\\\\s\");\n\t\tInt[] ar = new Int[5];\n\t\tfor(int i=0;i<5;i++){ar[i] = new Int(Integer.parseInt(s[i]));}\n\t\t\n\t\t//calculation\n\t\tArrays.sort(ar);\n\t\t\n\t\t//output\n\t\tfor(int i=0;i<5;i++){\n\t\t\tSystem.out.print(ar[i].i);\n\t\t\tif(i < 4){System.out.print(\" \");}\n\t\t}\n\t\tSystem.out.println();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int[] arr = new int[5];\n        for (int i = 0; i < 5; i++) {\n            arr[i] = sc.nextInt();\n        }\n        Arrays.sort(arr);\n        for (int i = 4; i >= 0; i--) {\n            if (i == 4) {\n                System.out.print(arr[i]);\n            } else {\n                System.out.print(\" \" + arr[i]);\n            }\n        }\n        System.out.println();\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] arr = new int[5]; for (int i = 0; i < 5; i++) { arr[i] = sc.nextInt();  i--) { if (i == 4) { System.out.print(arr[i]); } else { System.out.print(\" \" + arr[i]); } } System.out.println(); sc.close(); } }"], "perturbed_original": ["import java.util.*;  i;} public int compareTo (Int I){return I.i - this.i;} } public class Main { public static void main(String[] args) { //input Scanner sc = new Scanner(System.in).useDelimiter(System.getProperty(\"line.separator\")); String[] s = sc.next().split(\"\\\\s\"); Int[] ar = new Int[5]; for(int i=0;i<5;i++){ar[i] = new Int(Integer.parseInt(s[i]));} //calculation Arrays.sort(ar); //output for(int i=0;i<5;i++){ System.out.print(ar[i].i); if(i < 4){System.out.print(\" \");} } System.out.println(); } }"], "original_ll": -0.9853265881538391, "sampled_ll": -0.39581212401390076, "all_perturbed_sampled_ll": [-0.9348087906837463], "all_perturbed_original_ll": [-1.4876067638397217], "perturbed_sampled_ll": -0.9348087906837463, "perturbed_original_ll": -1.4876067638397217, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a = map(int, raw_input().split())\na.sort()\na.reverse()\nprint \" \".join(map(str, a))", "sampled": "numbers = list(map(int, input().split()))\nnumbers.sort(reverse=True)\nprint(' '.join(map(str, numbers)))\n", "perturbed_sampled": ["numbers = list(map(int, input().split())) numbers.sort(reverse=True) print(' '.join(map(str, numbers)))"], "perturbed_original": ["a = map(int, raw_input().split()) a.sort() a.reverse() print \" \".join(map(str, a))"], "original_ll": -1.4211068153381348, "sampled_ll": -1.1664936542510986, "all_perturbed_sampled_ll": [-1.7896136045455933], "all_perturbed_original_ll": [-1.7587604522705078], "perturbed_sampled_ll": -1.7896136045455933, "perturbed_original_ll": -1.7587604522705078, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void)\n{\nint i,j;\n\nscanf(\"%d\",&i);\nj=1;\nfor(;i>0;i--){\nj*=i;\n}\nprintf(\"%d\\n\",j);\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    long long factorial = 1;\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i <= n; i++) {\n        factorial *= i;\n    }\n    \n    printf(\"%lld\\n\", factorial);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; long long factorial = 1; scanf(\"%d\", &n); for (int i = 1; i <= n; i++) { factorial *= i; } printf(\"%lld\\n\", factorial); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int i,j; scanf(\"%d\",&i); j=1; for(;i>0;i--){ j*=i; } printf(\"%d\\n\",j); return 0; }"], "original_ll": -1.2943612337112427, "sampled_ll": -0.5640527009963989, "all_perturbed_sampled_ll": [-0.77349853515625], "all_perturbed_original_ll": [-1.1498448848724365], "perturbed_sampled_ll": -0.77349853515625, "perturbed_original_ll": -1.1498448848724365, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.math.*;\n\npublic class Main{\n    public static void main(String[] args){\n\tScanner in = new Scanner(System.in);\n\tint a = in.nextInt();\n\tlong b = 1;\n\n\tfor(int i = 1 ; i <= a ; i++){\n\t    b = b*i;\n\t}\n\tSystem.out.println(b);\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long factorial = 1;\n        for (int i = 2; i <= n; i++) {\n            factorial *= i;\n        }\n        System.out.println(factorial);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) {  factorial = 1; for (int i = 2; i <= n; i++) { factorial *= i; } System.out.println(factorial); sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.math.*; public class Main{ public static void main(String[] args){ Scanner in = new Scanner(System.in); int a = in.nextInt();  <= a ; i++){ b = b*i; } System.out.println(b); } }"], "original_ll": -1.1288093328475952, "sampled_ll": -0.3806801736354828, "all_perturbed_sampled_ll": [-1.133486270904541], "all_perturbed_original_ll": [-1.5971856117248535], "perturbed_sampled_ll": -1.133486270904541, "perturbed_original_ll": -1.5971856117248535, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "s=int(input())\nans=1\nfor i in range(1,s+1):\n    ans *= i\n\nprint(ans)", "sampled": "n = int(input())\nresult = 1\nfor i in range(1, n + 1):\n    result *= i\nprint(result)\n", "perturbed_sampled": ["n = int(input()) result = 1 for i in range(1, n + 1): result *= i print(result)"], "perturbed_original": ["s=int(input()) ans=1 for i in range(1,s+1): ans *= i print(ans)"], "original_ll": -1.1240265369415283, "sampled_ll": -0.7729111313819885, "all_perturbed_sampled_ll": [-1.3310602903366089], "all_perturbed_original_ll": [-1.6502512693405151], "perturbed_sampled_ll": -1.3310602903366089, "perturbed_original_ll": -1.6502512693405151, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n  char ch[81];\n  int i;\n\n  gets(ch);\n  for(i = 0; ch[i] != '\\0'; ++i)\n    {\n      if('a' <= ch[i] && ch[i] <= 'z')\n\t{\n\t  ch[i] -= 32;\n\t}\n    }\n  puts(ch);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char c;\n    while ((c = getchar()) != EOF) {\n        putchar(toupper(c));\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <ctype.h> int main() { char c; while ((c = getchar()) != EOF) { putchar(toupper(c)); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { char ch[81]; int i; gets(ch); for(i = 0; ch[i] !=  { ch[i] -= 32; } } puts(ch); return 0; }"], "original_ll": -0.9261314868927002, "sampled_ll": -0.6540772318840027, "all_perturbed_sampled_ll": [-0.9777517914772034], "all_perturbed_original_ll": [-1.7709383964538574], "perturbed_sampled_ll": -0.9777517914772034, "perturbed_original_ll": -1.7709383964538574, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n\n        String input = s.nextLine();\n        System.out.println(input.toUpperCase());\n    }\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String text = sc.nextLine();\n        System.out.println(text.toUpperCase());\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String text = sc.nextLine(); System.out.println(text.toUpperCase()); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner s = new Scanner(System.in); String input = s.nextLine(); System.out.println(input.toUpperCase()); } }"], "original_ll": -0.8742524981498718, "sampled_ll": -0.5600889325141907, "all_perturbed_sampled_ll": [-0.8203316926956177], "all_perturbed_original_ll": [-0.8879815936088562], "perturbed_sampled_ll": -0.8203316926956177, "perturbed_original_ll": -0.8879815936088562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "print(input().upper())", "sampled": "print(input().upper())\n", "perturbed_sampled": ["print(input().upper())"], "perturbed_original": ["print(input().upper())"], "original_ll": -5.011203765869141, "sampled_ll": -5.220095634460449, "all_perturbed_sampled_ll": [-5.011203765869141], "all_perturbed_original_ll": [-5.011203765869141], "perturbed_sampled_ll": -5.011203765869141, "perturbed_original_ll": -5.011203765869141, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nconst double eps = 1e-10;\n\nint n;\ndouble x1, x2, x3, x4;\ndouble y1, y2, y3, y4;\n\n//\u5897\u52a0\u7387\u3092\u898b\u308b\u65b9\u6cd5\nint solve1() {\n    double r1 = (y2-y1)/(x2-x1);\n    double r2 = (y4-y3)/(x4-x3);\n    return (fabs(r1-r2) < eps);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; ++i) {\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n\n        if(solve1()) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    double x1, y1, x2, y2, x3, y3, x4, y4;\n    double dx1, dy1, dx2, dy2;\n    double cross;\n    \n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n              &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n        \n        dx1 = x2 - x1;\n        dy1 = y2 - y1;\n        dx2 = x4 - x3;\n        dy2 = y4 - y3;\n        \n        cross = dx1 * dy2 - dy1 * dx2;\n        \n        if (fabs(cross) < 1e-9) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int n; double x1, y1, x2, y2, x3, y3, x4, y4; double dx1, dy1, dx2, dy2; double cross; scanf(\"%d\", &n); while (n--) { scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2,  = y2 - y1; dx2 = x4 - x3; dy2 = y4 - y3; cross = dx1 * dy2 - dy1 * dx2; if (fabs(cross)  return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> const double eps = 1e-10; int n; double x1, x2, x3, x4; double y1, y2, y3, y4; //\u5897\u52a0\u7387\u3092\u898b\u308b\u65b9\u6cd5 int solve1() { double r1 = (y2-y1)/(x2-x1); double r2 = (y4-y3)/(x4-x3); return (fabs(r1-r2) < eps); } int main() { scanf(\"%d\", &n); for(int i=0; i<n; ++i) { scanf(\"%lf %lf %lf %lf  &x4,  }"], "original_ll": -0.8315833210945129, "sampled_ll": -0.3878070116043091, "all_perturbed_sampled_ll": [-0.9108409285545349], "all_perturbed_original_ll": [-1.4634859561920166], "perturbed_sampled_ll": -0.9108409285545349, "perturbed_original_ll": -1.4634859561920166, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\n// AOJ 0021\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic final double EPS = 1e-8;\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tdouble[] x = new double[4], y = new double[4];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tx[j] = sc.nextDouble();\n\t\t\t\ty[j] = sc.nextDouble();\n\t\t\t}\n\t\t\t\n\t\t\tComplex \n\t\t\t\tp1 = new Complex(x[0], y[0]),\n\t\t\t\tp2 = new Complex(x[1], y[1]),\n\t\t\t\tp3 = new Complex(x[2], y[2]),\n\t\t\t\tp4 = new Complex(x[3], y[3]);\n\t\t\t\n\t\t\tif (!isCross(p1, p2, p3, p4)) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic boolean isCross(Complex p1, Complex p2, Complex p3, Complex p4) {\n\t\tdouble det = p1.sub(p2).crossProduct(p3.sub(p4));\n\t\tif (Math.abs(det) < Complex.EPS) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nclass Complex {\n\tstatic final double EPS = 1e-10;\n\t\n\tdouble re, im;\n\t\n\tComplex (double r, double i) {\n\t\tre = r; im = i;\n\t}\n\n\tdouble arg() {\n\t\treturn Math.atan2(im, re);\n\t}\n\t\n\tdouble abs2() {\n\t\treturn re * re + im * im;\n\t}\n\t\n\tdouble abs() {\n\t\treturn Math.sqrt(abs2());\n\t}\n\t\n\tdouble innerProdut(Complex o) {\n\t\treturn re * o.re + im * o.im;\n\t}\n\t\n\tdouble crossProduct(Complex o) {\n\t\treturn re * o.im - im * o.re;\n\t}\n\t\n\tstatic Complex polar(double theta, double r) {\n\t\treturn new Complex(r * Math.cos(theta), r * Math.sin(theta));\n\t}\n\t\n\tComplex conj() {\n\t\treturn new Complex(re, -im);\n\t}\n\t\n\tComplex add(Complex o) {\n\t\treturn new Complex(re + o.re, im + o.im);\n\t}\n\n\tComplex sub(Complex o) {\n\t\treturn new Complex(re - o.re, im - o.im);\n\t}\n\t\n\tComplex mul(Complex o) {\n\t\treturn new Complex(re * o.re - im * o.im, re * o.im + im * o.re);\n\t}\n\t\n\tComplex div(Complex o) {\n\t\treturn new Complex((re * o.re + im * o.im) / o.abs2(), (im * o.re - re * o.im) / o.abs2());\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double x1 = sc.nextDouble();\n            double y1 = sc.nextDouble();\n            double x2 = sc.nextDouble();\n            double y2 = sc.nextDouble();\n            double x3 = sc.nextDouble();\n            double y3 = sc.nextDouble();\n            double x4 = sc.nextDouble();\n            double y4 = sc.nextDouble();\n            \n            double dx1 = x2 - x1;\n            double dy1 = y2 - y1;\n            double dx2 = x4 - x3;\n            double dy2 = y4 - y3;\n            \n            double cross = dx1 * dy2 - dy1 * dx2;\n            \n            if (Math.abs(cross) < 1e-9) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main {  Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i < n; i++) { double x1 = sc.nextDouble(); double y1 = sc.nextDouble(); double x2 = sc.nextDouble(); double y2 = sc.nextDouble(); double x3 = sc.nextDouble(); double y3 = sc.nextDouble(); double  x2 - x1; double dy1 = y2 - y1; double dx2  double cross = dx1 * dy2 - dy1 * dx2; if (Math.abs(cross) < 1e-9) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; import static java.util.Arrays.*; import static java.lang.Math.*; // AOJ 0021 public class Main { static Scanner sc = new Scanner(System.in); static int N; static final double EPS = 1e-8; public static void  double[4], y = new double[4]; for (int i = 0; i < N; i++) {  x[j] = sc.nextDouble(); y[j] = sc.nextDouble(); } Complex p1 = new Complex(x[0], y[0]), p2 = new Complex(x[1], y[1]), p3  p2, Complex p3, Complex  { return false; } else { return true; } } } class Complex { static final double EPS = 1e-10; double re, im; Complex (double r, double i) { re = r; im = i; } double arg() { return Math.atan2(im, re); } double abs2() { return re * re + im * im; } double abs() { return Math.sqrt(abs2()); } double innerProdut(Complex o) { return re * o.re + im * o.im; } double crossProduct(Complex o) {  Complex polar(double theta, double r) { return new Complex(r * Math.cos(theta), r * Math.sin(theta)); } Complex conj() { return new Complex(re, -im); } Complex add(Complex o) { return new Complex(re + o.re, im + o.im); } Complex sub(Complex o) { return new Complex(re - o.re, im - o.im); } Complex mul(Complex o) { return new Complex(re * o.re - im * o.im, re *  return new Complex((re * o.re +  * o.im) / o.abs2()); } }"], "original_ll": -0.5575758814811707, "sampled_ll": -0.2856425344944, "all_perturbed_sampled_ll": [-0.9681193232536316], "all_perturbed_original_ll": [-1.193561315536499], "perturbed_sampled_ll": -0.9681193232536316, "perturbed_original_ll": -1.193561315536499, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "ans = []\nn = input()\nfor i in range(n):\n    x1,y1,x2,y2,x3,y3,x4,y4 = map(float,raw_input().split())\n    if ((y2-y1)/(x2-x1) == (y4-y3)/(x4-x3)):\n        ans.append('YES')\n    else:\n        ans.append('NO')\nfor i in ans:\n    print i", "sampled": "n = int(input())\nfor _ in range(n):\n    coords = list(map(float, input().split()))\n    x1, y1, x2, y2, x3, y3, x4, y4 = coords\n    \n    # Direction vectors\n    dx1 = x2 - x1\n    dy1 = y2 - y1\n    dx2 = x4 - x3\n    dy2 = y4 - y3\n    \n    # Two lines are parallel if their direction vectors are parallel\n    # This means the cross product should be zero\n    cross = dx1 * dy2 - dy1 * dx2\n    \n    if abs(cross) < 1e-9:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["n = int(input())  x2, y2, x3, y3, x4, y4 = coords  y2 - y1 dx2 = x4 - x3 dy2 = y4 - y3 # Two lines are parallel if their direction vectors are parallel # This means the cross product should be zero cross = dx1 * dy2 - dy1 * dx2 if abs(cross) < 1e-9: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["ans = [] n = input() for i in range(n): x1,y1,x2,y2,x3,y3,x4,y4 = map(float,raw_input().split()) if ((y2-y1)/(x2-x1) == (y4-y3)/(x4-x3)): ans.append('YES') else: ans.append('NO') for i in ans: print i"], "original_ll": -1.0076212882995605, "sampled_ll": -0.7236678600311279, "all_perturbed_sampled_ll": [-1.5833858251571655], "all_perturbed_original_ll": [-1.2317242622375488], "perturbed_sampled_ll": -1.5833858251571655, "perturbed_original_ll": -1.2317242622375488, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct\n{\n    double x;\n    double y;\n    double r;\n}circle;\n\nint main(void)\n{\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    while (datasets--) {\n        circle a, b;\n        scanf(\" %lf %lf %lf\", &(a.x), &(a.y), &(a.r));\n        scanf(\" %lf %lf %lf\", &(b.x), &(b.y), &(b.r));\n\n        double bigr, smallr;\n        if (a.r >=  b.r) {\n            bigr = a.r;\n            smallr = b.r;\n        } else {\n            bigr = b.r;\n            smallr = a.r;\n        }\n\n        double dist = pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n        dist = sqrt(dist);\n\n        int judge;\n        if (dist > bigr + smallr) {\n            judge = 0;\n        } else if (dist > bigr - smallr) {\n            judge = 1;\n        } else {\n            if (bigr == a.r) {\n                judge = 2;\n            } else {\n                judge = -2;\n            }\n        }\n\n        printf(\"%d\\n\", judge);\n    }\n\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        double xa, ya, ra, xb, yb, rb;\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &xa, &ya, &ra, &xb, &yb, &rb);\n        \n        double dist = sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n        \n        if (dist + rb < ra + 1e-9) {\n            printf(\"2\\n\");\n        } else if (dist + ra < rb + 1e-9) {\n            printf(\"-2\\n\");\n        } else if (dist < ra + rb + 1e-9 && dist + 1e-9 > fabs(ra - rb)) {\n            printf(\"1\\n\");\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int n; scanf(\"%d\", &n); while (n--) { double  %lf %lf\", &xa, &ya, &ra, &xb, &yb, &rb); double dist = sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb)); if  else if (dist + ra < rb + 1e-9) { printf(\"-2\\n\"); } else if (dist < ra + rb + 1e-9 && dist + 1e-9  } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> typedef struct { double x; double y; double r; }circle; int main(void) { int datasets; scanf(\"%d\", &datasets); while (datasets--) { circle a, b; scanf(\" %lf %lf %lf\", &(a.x), &(a.y), &(a.r)); scanf(\" %lf %lf %lf\", &(b.x), &(b.y), &(b.r)); double bigr, smallr; if (a.r >= b.r) { bigr = a.r; smallr = b.r; } else { bigr = b.r; smallr = a.r; } double dist = pow(a.x - b.x, 2) + pow(a.y - b.y, 2); dist =  judge = 0; }  1; } else {  { judge = -2; } } printf(\"%d\\n\", judge); } return 0; }"], "original_ll": -0.7601574063301086, "sampled_ll": -0.6355171203613281, "all_perturbed_sampled_ll": [-1.4664114713668823], "all_perturbed_original_ll": [-1.2384742498397827], "perturbed_sampled_ll": -1.4664114713668823, "perturbed_original_ll": -1.2384742498397827, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        while (n-- > 0) {\n            Circle a = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n            Circle b = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n            double dx = b.x - a.x;\n            double dy = b.y - a.y;\n            double r = a.r + b.r;\n            double d = Math.sqrt(dx * dx + dy * dy);\n            if (d > r) {\n                System.out.println(0);\n            } else {\n                if (a.r < b.r && d + a.r < b.r) {\n                    System.out.println(-2);\n                } else if (a.r > b.r && d + b.r < a.r) {\n                    System.out.println(2);\n                } else {\n                    System.out.println(1);\n                }\n            }\n        }\n    }\n\n    static class Circle {\n        double x;\n        double y;\n        double r;\n\n        Circle(double x, double y, double r) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n        }\n    }\n}\n\n\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double xa = sc.nextDouble();\n            double ya = sc.nextDouble();\n            double ra = sc.nextDouble();\n            double xb = sc.nextDouble();\n            double yb = sc.nextDouble();\n            double rb = sc.nextDouble();\n            \n            double dist = Math.sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n            \n            if (dist + rb < ra || Math.abs(dist + rb - ra) < 1e-9) {\n                System.out.println(2);\n            } else if (dist + ra < rb || Math.abs(dist + ra - rb) < 1e-9) {\n                System.out.println(-2);\n            } else if (dist < ra + rb && dist > Math.abs(ra - rb)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n =  { double xa = sc.nextDouble(); double ya = sc.nextDouble(); double ra = sc.nextDouble(); double xb = sc.nextDouble(); double yb = sc.nextDouble(); double rb = sc.nextDouble(); double dist = Math.sqrt((xa - xb) * (xa - xb) + (ya  < ra || Math.abs(dist + rb - ra) < 1e-9) { System.out.println(2); } else if (dist + ra < rb || Math.abs(dist + ra - rb) < 1e-9) { System.out.println(-2); }  Math.abs(ra - rb)) { System.out.println(1); } else { System.out.println(0); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); while (n-- > 0)  = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble()); double dx = b.x - a.x; double dy = b.y - a.y; double r = a.r + b.r; double d = Math.sqrt(dx * dx + dy * dy); if (d  b.r && d  > b.r && d + b.r < a.r) { System.out.println(2); } else { System.out.println(1); } } }  r; Circle(double x, double y, double r) { this.x = x; this.y = y; this.r = r; } } }"], "original_ll": -0.5142626762390137, "sampled_ll": -0.546619176864624, "all_perturbed_sampled_ll": [-1.3890546560287476], "all_perturbed_original_ll": [-1.2231382131576538], "perturbed_sampled_ll": -1.3890546560287476, "perturbed_original_ll": -1.2231382131576538, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for a,b,r,c,d,s in[map(float,raw_input().split())for i in range(input())]:\n\td=(a-c)**2+(b-d)**2\n\tif d>(r+s)**2:print 0\n\telif d+min(r,s)>max(r,s):print 1\n\telif r>s:print 2\n\telse:print -2", "sampled": "import math\n\nn = int(input())\nfor _ in range(n):\n    xa, ya, ra, xb, yb, rb = map(float, input().split())\n    \n    # Calculate distance between centers\n    d = math.sqrt((xa - xb)**2 + (ya - yb)**2)\n    \n    # Check if B is in A\n    if d + rb <= ra:\n        print(2)\n    # Check if A is in B\n    elif d + ra <= rb:\n        print(-2)\n    # Check if circles intersect\n    elif d < ra + rb:\n        print(1)\n    # Circles do not overlap\n    else:\n        print(0)\n", "perturbed_sampled": ["import math n = int(input()) for _ in range(n): xa, ya, ra, xb, yb, rb  if B is in A if d + rb <= ra: print(2) # Check if A is in B elif d + ra <= rb: print(-2) # Check if circles intersect elif d < ra + rb: print(1) # Circles do not overlap else: print(0)"], "perturbed_original": ["for a,b,r,c,d,s in[map(float,raw_input().split())for i in range(input())]: d=(a-c)**2+(b-d)**2 if d>(r+s)**2:print 0 elif d+min(r,s)>max(r,s):print 1 elif r>s:print 2 else:print -2"], "original_ll": -1.9853733777999878, "sampled_ll": -1.011813759803772, "all_perturbed_sampled_ll": [-2.2641830444335938], "all_perturbed_original_ll": [-2.3502190113067627], "perturbed_sampled_ll": -2.2641830444335938, "perturbed_original_ll": -2.3502190113067627, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nint main(){\n\tfloat v,t,y;\n\twhile(scanf(\"%f\",&v) != EOF){\n\t\tt = v / 9.8;\n\t\ty = t * t * 4.9;\n\t\tprintf(\"%d\\n\",(int)ceilf(y / 5.0) + 1);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double v;\n    while (scanf(\"%lf\", &v) != EOF) {\n        double t = v / 9.8;\n        double y = 4.9 * t * t;\n        int floor = (int)ceil((y + 5) / 5);\n        printf(\"%d\\n\", floor);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { double v; while (scanf(\"%lf\", &v) !=  = 4.9 * t * t; int floor = (int)ceil((y + 5) / 5); printf(\"%d\\n\", floor); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> int main(){ float v,t,y; while(scanf(\"%f\",&v) != EOF){ t = v / 9.8; y = t * t * 4.9; printf(\"%d\\n\",(int)ceilf(y / 5.0) + 1); } return 0; }"], "original_ll": -1.608237862586975, "sampled_ll": -1.1466416120529175, "all_perturbed_sampled_ll": [-2.194460153579712], "all_perturbed_original_ll": [-1.788835048675537], "perturbed_sampled_ll": -2.194460153579712, "perturbed_original_ll": -1.788835048675537, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid doIt() {\n\t\twhile(true){\n\t\t\ttry{\n\t\t\t\tdouble v = sc.nextDouble();\n\t\t\t\tdouble t = v / 9.8;\n\t\t\t\tdouble y = 4.9 * t * t;\n\t\t\t\tint ans = (int) y / 5;\n\t\t\t\tdouble cnt = y % 5;\n\t\t\t\tif(cnt > 0){\n\t\t\t\t\tans++;\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t}\n\t\t\t}catch(Exception g){\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\t}\n    public static void main(String[] args) {\n    \tnew Main().doIt();\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double v = sc.nextDouble();\n            \n            // From v = 9.8t, we get t = v / 9.8\n            double t = v / 9.8;\n            \n            // Drop distance y = 4.9 * t^2\n            double y = 4.9 * t * t;\n            \n            // Height of floor N is 5*N - 5\n            // We need to find smallest N such that 5*N - 5 >= y\n            // 5*N >= y + 5\n            // N >= (y + 5) / 5\n            \n            int floor = (int) Math.ceil((y + 5) / 5.0);\n            \n            System.out.println(floor);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { double v = sc.nextDouble(); // From v = 9.8t, we get t = v / 9.8 double t = v / 9.8; // Drop distance y = 4.9   We need to find smallest N such that 5*N - 5 >= y // 5*N >= y  int floor = (int) Math.ceil((y + 5) / 5.0); System.out.println(floor); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { Scanner sc = new Scanner(System.in); void  t * t; int ans = (int) y / 5; double cnt = y % 5; if(cnt > 0){ ans++; System.out.println(ans); }else{ System.out.println(ans); } }catch(Exception g){ System.exit(0); } } } public static void main(String[] args) { new Main().doIt(); } }"], "original_ll": -1.2170612812042236, "sampled_ll": -1.0458544492721558, "all_perturbed_sampled_ll": [-1.7748122215270996], "all_perturbed_original_ll": [-1.9805446863174438], "perturbed_sampled_ll": -1.7748122215270996, "perturbed_original_ll": -1.9805446863174438, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nimport math\nv=[]\nfor line in sys.stdin:\n    v.append(float(line))\nfor i in range(len(v)):\n    print math.ceil(v[i]**2/98+1),", "sampled": "import sys\nimport math\n\nfor line in sys.stdin:\n    v = float(line.strip())\n    \n    # From v = 9.8 * t, we get t = v / 9.8\n    t = v / 9.8\n    \n    # From y = 4.9 * t^2\n    y = 4.9 * t * t\n    \n    # Height of floor N is 5*N - 5\n    # We need 5*N - 5 >= y\n    # 5*N >= y + 5\n    # N >= (y + 5) / 5\n    \n    N = math.ceil((y + 5) / 5)\n    \n    print(N)\n", "perturbed_sampled": ["import sys import math for line in sys.stdin: v = float(line.strip()) # From v = 9.8 * t, we get t = v / 9.8 t = v / 9.8 # From y = 4.9 * t^2 y = 4.9 *  - 5 # We need 5*N - 5 >= y # 5*N >= y + 5 # N  5) / 5) print(N)"], "perturbed_original": ["import sys import math v=[] for line in sys.stdin: v.append(float(line)) for i in range(len(v)): print math.ceil(v[i]**2/98+1),"], "original_ll": -2.009835720062256, "sampled_ll": -1.18108332157135, "all_perturbed_sampled_ll": [-2.693106174468994], "all_perturbed_original_ll": [-3.0437138080596924], "perturbed_sampled_ll": -2.693106174468994, "perturbed_original_ll": -3.0437138080596924, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n\tint A[4], B[4];\n\tint a, b;\n\tint hit, blow;\n\n\twhile( scanf(\"%d%d%d%d\",&A[0],&A[1],&A[2],&A[3]) != EOF ){\n\t\tscanf(\"%d%d%d%d\",&B[0],&B[1],&B[2],&B[3]);\n\n\t\thit=blow=0;\n\n\t\tfor( a=0; a<4; a++ ){\n\t\t\tfor( b=0; b<4; b++ ){\n\t\t\t\tif( A[a] == B[b] ){\n\t\t\t\t\t(a==b)? hit++ : blow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %d\\n\", hit, blow);\n\t}\n\n\treturn 0;\n}\n\t", "sampled": "#include <stdio.h>\n\nint main() {\n    int a[4], b[4];\n    \n    while(scanf(\"%d %d %d %d\", &a[0], &a[1], &a[2], &a[3]) != EOF) {\n        scanf(\"%d %d %d %d\", &b[0], &b[1], &b[2], &b[3]);\n        \n        int hit = 0, blow = 0;\n        \n        // Count hits\n        for(int i = 0; i < 4; i++) {\n            if(a[i] == b[i]) {\n                hit++;\n            }\n        }\n        \n        // Count blows\n        for(int i = 0; i < 4; i++) {\n            for(int j = 0; j < 4; j++) {\n                if(i != j && a[i] == b[j]) {\n                    blow++;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", hit, blow);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int a[4], b[4]; while(scanf(\"%d %d %d %d\", &a[0], &a[1], &a[2], &a[3]) != EOF) { scanf(\"%d %d %d %d\", &b[0], &b[1], &b[2], &b[3]); int hit = 0, blow = 0; //  { if(a[i] == b[i]) { hit++; } } // Count blows for(int i = 0; i < 4; i++) { for(int j = 0; j < 4; j++)  } } } printf(\"%d %d\\n\", hit, blow); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ int A[4],  EOF ){ scanf(\"%d%d%d%d\",&B[0],&B[1],&B[2],&B[3]); hit=blow=0; for( a=0; a<4; a++ ){ for( b=0; b<4; b++ ){ if( A[a] == B[b] ){ (a==b)? hit++ : blow++; } } } printf(\"%d %d\\n\", hit, blow); } return 0; }"], "original_ll": -0.8885037302970886, "sampled_ll": -0.4144812822341919, "all_perturbed_sampled_ll": [-1.1223350763320923], "all_perturbed_original_ll": [-1.57850182056427], "perturbed_sampled_ll": -1.1223350763320923, "perturbed_original_ll": -1.57850182056427, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint [] a = new int[4];\n\t\t\tint [] b = new int[4];\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i =0; i < 4; i++){\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint hit=0;\n\t\t\tint blow = 0;\n\t\t\tfor(int i =0; i < 4; i++){\n\t\t\t\tfor(int j =i; j < 4; j++){\n\t\t\t\t\tif(a[i] == b[j]){\n\t\t\t\t\t\tif(i == j)\n\t\t\t\t\t\t\thit++;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tblow++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(hit + \" \" + blow);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int[] a = new int[4];\n            int[] b = new int[4];\n            \n            for (int i = 0; i < 4; i++) {\n                a[i] = sc.nextInt();\n            }\n            for (int i = 0; i < 4; i++) {\n                b[i] = sc.nextInt();\n            }\n            \n            int hit = 0;\n            int blow = 0;\n            \n            for (int i = 0; i < 4; i++) {\n                if (a[i] == b[i]) {\n                    hit++;\n                } else {\n                    for (int j = 0; j < 4; j++) {\n                        if (i != j && a[i] == b[j]) {\n                            blow++;\n                            break;\n                        }\n                    }\n                }\n            }\n            \n            System.out.println(hit + \" \" + blow);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int[] a = new int[4]; int[] b = new int[4]; for (int i = 0; i < 4; i++) { a[i] = sc.nextInt(); } for (int i = 0; i < 4; i++) { b[i] = sc.nextInt(); } int hit = 0; int blow = 0; for (int i  b[i]) { hit++; } else { for (int j = 0; j < 4; j++) {  break; } } } } System.out.println(hit + \" \" + blow); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public  new Scanner(System.in); while(sc.hasNext()){ int [] a = new int[4]; int [] b = new int[4]; for(int i = 0; i < 4; i++){ a[i] = sc.nextInt(); } for(int  i < 4; i++){ for(int j =i; j < 4; j++){ if(a[i] == b[j]){ if(i == j) hit++; else{ blow++; } } } } System.out.println(hit + \" \" + blow); } } public static void main(String[] args) { Main obj = new Main(); obj.doit(); } }"], "original_ll": -0.7011843919754028, "sampled_ll": -0.39263781905174255, "all_perturbed_sampled_ll": [-1.0912368297576904], "all_perturbed_original_ll": [-1.3665099143981934], "perturbed_sampled_ll": -1.0912368297576904, "perturbed_original_ll": -1.3665099143981934, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor i in sys.stdin:\n    arrA,arrB = [],[]\n    s = i.split()\n    for i in s:\n        arrA.append(int(i))\n    s = input().split()\n    for i in s:\n        arrB.append(int(i))\n    h,b = 0,0\n    for i in range(len(arrA)):\n        if arrA[i] == arrB[i]:\n            h += 1\n        else:\n            if arrB.count(arrA[i]) > 0:\n                b += 1\n    print(h,b)", "sampled": "import sys\n\nfor line in sys.stdin:\n    numbers = list(map(int, line.split()))\n    if len(numbers) < 8:\n        continue\n    \n    a = numbers[:4]\n    b = numbers[4:8]\n    \n    hit = 0\n    blow = 0\n    \n    for i in range(4):\n        if a[i] == b[i]:\n            hit += 1\n        elif b[i] in a:\n            blow += 1\n    \n    print(hit, blow)\n", "perturbed_sampled": ["import sys for line in sys.stdin: numbers = list(map(int, line.split())) if len(numbers) < 8: continue a = numbers[:4] b = numbers[4:8] hit = 0 blow = 0 for i in range(4): if a[i] == b[i]: hit ++<extra_id_2>blow<extra_id_3>if<extra_id_4>) :<extra_id_5>return for<extra_id_6>= b [ b<extra_id_7>blow + hit] print \"blow<extra_id_8>blow >= b<extra_id_9>hit for j in<extra_id_10>] == j[k]<extra_id_11>blow)/hit for b<extra_id_12>)<extra_id_13>if b<extra_id_14>4 ] )<extra_id_15>blow [ d ] )<extra_id_16>= blow<extra_id_17>[<extra_id_18>: blow<extra_id_19>:<extra_id_20>>=<extra_id_21>#<extra_id_22>( a<extra_id_23>5 ] + blow)"], "perturbed_original": ["import sys for i in sys.stdin: arrA,arrB = [],[] s = i.split() for i in s: arrA.append(int(i)) s = input().split() for i in s: arrB.append(int(i)) h,b = 0,0 for i in range(len(arrA)): if arrA[i] == +1<extra_id_2>-1<extra_id_3>) break<extra_id_4>h,b) break for r,k,v<extra_id_5>( arrA ) return<extra_id_6>=<extra_id_7>[ \"<extra_id_8>=<extra_id_9>( arrB<extra_id_10>: arrA1 .<extra_id_11>b ) - 1 if<extra_id_12>(1): arrB1 += 1 print(h,b)"], "original_ll": -0.9364861249923706, "sampled_ll": -0.9639748930931091, "all_perturbed_sampled_ll": [-2.1474320888519287], "all_perturbed_original_ll": [-2.4706811904907227], "perturbed_sampled_ll": -2.1474320888519287, "perturbed_original_ll": -2.4706811904907227, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid fact(int ,int, int);\nvoid count(void);\n\nint a[10][10],i,j;\n\nint main(){\n  int x,y,size;\n\n  for(i = 0 ; i < 10 ; i++){\n    for(j = 0 ; j < 10 ; j++){\n      a[i][j] = 0;\n    }\n  }\n  while(scanf(\"%d,%d,%d\",&x,&y,&size) != 3){\n    fact(x,y,size);\n  }\n  count();\n  return 0;\n}\nvoid fact(int x, int y, int size){\n  int size1[2] = {1,-1};\n  int size2[2] = {2,-2};\n\n  a[y][x] += 1;\n  if(size == 1){\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size1[i] >= 0 || x+size1[i] <= 10)\n\ta[y][x+size1[i]] += 1;\n      if(y+size1[i] >= 0 || y+size1[i] <= 10)\n\ta[y+size1[i]][x] += 1;\n    }\n  }\n  if(size == 2){\n    for(i = 0 ; i < 2 ; i++){\n      for(j = 0 ; j < 2 ; j++){\n\tif(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10)\n\t  a[y+size1[i]][x+size1[j]] += 1;\n      }\n    }\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size1[i] >= 0 || x+size1[i] <= 10)\n\ta[y][x+size1[i]] += 1;\n      if(y+size1[i] >= 0 || y+size1[i] <= 10)\n\ta[y+size1[i]][x] += 1;\n    }\n  }\n  if(size == 3){\n    for(i = 0 ; i < 2 ; i++){\n      for(j = 0 ; j < 2 ; j++){\n\tif(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10)\n\t  a[y+size1[i]][x+size1[j]] += 1;\n      }\n    }\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size1[i] >= 0 || x+size1[i] <= 10)\n\ta[y][x+size1[i]] += 1;\n      if(y+size1[i] >= 0 || y+size1[i] <= 10)\n\ta[y+size1[i]][x] += 1;\n    }\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size2[i] >= 0 || x+size2[i] <= 10)\n\ta[y][x+size2[i]] += 1;\n      if(y+size2[i] >= 0 || y+size2[i] <= 10)\n\ta[y+size2[i]][x] += 1;\n    }\n  }\n}\nvoid count(void){\n  int sum = 0,x = 0;\n\n  for(i = 0 ; i < 10 ; i++){\n    for(j = 0 ; j < 10 ; j++){\n      if(a[i][j] == 0)\n\tsum++;\n      else if(x < a[i][j])\n\tx++;\n    }\n  }\n  printf(\"%d\\n%d\\n\",sum,x);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int grid[10][10];\n    memset(grid, 0, sizeof(grid));\n    \n    int x, y, s;\n    while (scanf(\"%d,%d,%d\", &x, &y, &s) == 3) {\n        // Small (s=1): only center point\n        if (s == 1) {\n            grid[y][x]++;\n        }\n        // Medium (s=2): center + adjacent (up, down, left, right)\n        else if (s == 2) {\n            grid[y][x]++;\n            if (y > 0) grid[y-1][x]++;\n            if (y < 9) grid[y+1][x]++;\n            if (x > 0) grid[y][x-1]++;\n            if (x < 9) grid[y][x+1]++;\n        }\n        // Large (s=3): center + all 8 surrounding cells + distance 2 in 4 directions\n        else if (s == 3) {\n            grid[y][x]++;\n            // 8 surrounding cells\n            if (y > 0) grid[y-1][x]++;\n            if (y < 9) grid[y+1][x]++;\n            if (x > 0) grid[y][x-1]++;\n            if (x < 9) grid[y][x+1]++;\n            if (y > 0 && x > 0) grid[y-1][x-1]++;\n            if (y > 0 && x < 9) grid[y-1][x+1]++;\n            if (y < 9 && x > 0) grid[y+1][x-1]++;\n            if (y < 9 && x < 9) grid[y+1][x+1]++;\n            // distance 2 in 4 directions\n            if (y > 1) grid[y-2][x]++;\n            if (y < 8) grid[y+2][x]++;\n            if (x > 1) grid[y][x-2]++;\n            if (x < 8) grid[y][x+2]++;\n        }\n    }\n    \n    int zero_count = 0;\n    int max_density = 0;\n    \n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (grid[i][j] == 0) {\n                zero_count++;\n            }\n            if (grid[i][j] > max_density) {\n                max_density = grid[i][j];\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", zero_count);\n    printf(\"%d\\n\", max_density);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int grid[10][10]; memset(grid, 0, sizeof(grid)); int x, y, s; while (scanf(\"%d,%d,%d\", &x, &y, &s) == 3) { // Small (s=1): only center point if (s == 1) { grid[y][x]++; } // Medium (s=2): center +  < 9) grid[y+1][x]++; if (x > 0) grid[y][x-1]++; if (x < 9) grid[y][x+1]++; } // Large (s=3): center + all 8 surrounding cells + distance 2 in 4 directions else if (s == 3) { grid[y][x]++; // 8 surrounding cells if  (x > 0) grid[y][x-1]++;  x > 0) grid[y-1][x-1]++; if (y > 0 && x < 9) grid[y-1][x+1]++; if (y < 9 && x > 0) grid[y+1][x-1]++;  1) grid[y][x-2]++; if (x < 8) grid[y][x+2]++; } } int zero_count = 0; int max_density = 0; for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { if (grid[i][j] == 0) { zero_count++; } if (grid[i][j] > max_density) { max_density = grid[i][j]; } } } printf(\"%d\\n\", zero_count); printf(\"%d\\n\", max_density); return 0; }"], "perturbed_original": ["#include <stdio.h> void fact(int ,int, int); void count(void); int a[10][10],i,j; int main(){ int x,y,size; for(i = 0  j < 10 ; j++){ a[i][j] =  0;  = {1,-1}; int size2[2] = {2,-2}; a[y][x]  < 2 ;  1;  } } if(size == 2){ for(i = 0 ; i < 2 ; i++){ for(j = 0 ; j < 2 ; j++){ if(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10) a[y+size1[i]][x+size1[j]] += 1; } } for(i = 0 ;  <= 10) a[y][x+size1[i]] += 1; if(y+size1[i] >= 0 || y+size1[i] <= 10) a[y+size1[i]][x] += 1; } } if(size == 3){ for(i = 0 ; i < 2 ; i++){ for(j = 0 ; j < 2 ; j++){ if(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10) a[y+size1[i]][x+size1[j]] += 1; } } for(i = 0 ; i < 2 ; i++){ if(x+size1[i] >= 0 || x+size1[i] <= 10) a[y][x+size1[i]] += 1; if(y+size1[i] >= 0 || y+size1[i] <= 10) a[y+size1[i]][x] += 1; } for(i = 0 ; i < 2 ; i++){ if(x+size2[i] >= 0 || x+size2[i] <= 10) a[y][x+size2[i]] += 1; if(y+size2[i] >= 0 || y+size2[i] <=  sum = 0,x = 0;  = 0 ; j < 10 ; j++){ if(a[i][j] == 0) sum++; else if(x < a[i][j]) x++; } } printf(\"%d\\n%d\\n\",sum,x); }"], "original_ll": -0.43841585516929626, "sampled_ll": -0.4122350215911865, "all_perturbed_sampled_ll": [-0.9581022262573242], "all_perturbed_original_ll": [-0.9720408320426941], "perturbed_sampled_ll": -0.9581022262573242, "perturbed_original_ll": -0.9720408320426941, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint[] area = new int[10 * 10];\n\n\t\tString str;\n\n\t\ttry {\n\t\t\twhile ((str = br.readLine()) != null) {\n\t\t\t\tString strArray[] = str.split(\",\");\n\t\t\t\tint x = Integer.parseInt(strArray[0]);\n\t\t\t\tint y = Integer.parseInt(strArray[1]);\n\t\t\t\tint size = Integer.parseInt(strArray[2]);\n\n\t\t\t\tint point = y * 10 + x;\n\n\t\t\t\tswitch (size) {\n\t\t\t\tcase 3:\n\t\t\t\t\tif (x < 8)\n\t\t\t\t\t\tarea[point + 2]++;\n\t\t\t\t\tif (x > 1)\n\t\t\t\t\t\tarea[point - 2]++;\n\t\t\t\t\tif (y < 8)\n\t\t\t\t\t\tarea[point + 20]++;\n\t\t\t\t\tif (y > 1)\n\t\t\t\t\t\tarea[point - 20]++;\n\t\t\t\tcase 2:\n\t\t\t\t\t// \u5de6\u4e0a\n\t\t\t\t\tif (x > 0 && y > 0)\n\t\t\t\t\t\tarea[point - 11]++;\n\t\t\t\t\t// \u53f3\u4e0a\n\t\t\t\t\tif (x < 9 && y > 0)\n\t\t\t\t\t\tarea[point - 9]++;\n\t\t\t\t\t// \u5de6\u4e0b\n\t\t\t\t\tif (y < 9 && x > 0)\n\t\t\t\t\t\tarea[point + 9]++;\n\t\t\t\t\t// \u53f3\u4e0b\n\t\t\t\t\tif (y < 9 && x < 9)\n\t\t\t\t\t\tarea[point + 11]++;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (x < 9)\n\t\t\t\t\t\tarea[point + 1]++;\n\t\t\t\t\tif (x > 0)\n\t\t\t\t\t\tarea[point - 1]++;\n\t\t\t\t\tif (y < 9)\n\t\t\t\t\t\tarea[point + 10]++;\n\t\t\t\t\tif (y > 1)\n\t\t\t\t\t\tarea[point - 10]++;\n\t\t\t\t\tarea[point]++;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (NumberFormatException e) {\n\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tArrays.sort(area);\n\t\tint blank = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tif (area[i] != 0) {\n\t\t\t\tblank = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// System.out.println(Arrays.binarySearch(area, 1));\n\t\tSystem.out.println(blank);\n\t\tSystem.out.println(area[99]);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int[][] paper = new int[10][10];\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int x = Integer.parseInt(parts[0]);\n            int y = Integer.parseInt(parts[1]);\n            int size = Integer.parseInt(parts[2]);\n            \n            dropInk(paper, x, y, size);\n        }\n        \n        int zeroCells = 0;\n        int maxDensity = 0;\n        \n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                if (paper[i][j] == 0) {\n                    zeroCells++;\n                }\n                maxDensity = Math.max(maxDensity, paper[i][j]);\n            }\n        }\n        \n        System.out.println(zeroCells);\n        System.out.println(maxDensity);\n        \n        sc.close();\n    }\n    \n    static void dropInk(int[][] paper, int x, int y, int size) {\n        if (size == 1) {\n            // Small: only center\n            if (isValid(x, y)) {\n                paper[y][x]++;\n            }\n        } else if (size == 2) {\n            // Medium: cross pattern with radius 1\n            int[][] offsets = {\n                {0, 0},\n                {-1, 0}, {1, 0}, {0, -1}, {0, 1}\n            };\n            for (int[] offset : offsets) {\n                int nx = x + offset[0];\n                int ny = y + offset[1];\n                if (isValid(nx, ny)) {\n                    paper[ny][nx]++;\n                }\n            }\n        } else if (size == 3) {\n            // Large: diamond pattern with radius 2\n            int[][] offsets = {\n                {0, 0},\n                {-1, 0}, {1, 0}, {0, -1}, {0, 1},\n                {-2, 0}, {2, 0}, {0, -2}, {0, 2},\n                {-1, -1}, {-1, 1}, {1, -1}, {1, 1}\n            };\n            for (int[] offset : offsets) {\n                int nx = x + offset[0];\n                int ny = y + offset[1];\n                if (isValid(nx, ny)) {\n                    paper[ny][nx]++;\n                }\n            }\n        }\n    }\n    \n    static boolean isValid(int x, int y) {\n        return x >= 0 && x < 10 && y >= 0 && y < 10;\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in); int[][] paper = new int[10][10]; while (sc.hasNext()) { String line = sc.nextLine(); String[] parts = line.split(\",\"); int x = Integer.parseInt(parts[0]); int y = Integer.parseInt(parts[1]); int size = Integer.parseInt(parts[2]); dropInk(paper, x, y, size); } int zeroCells  0; i < 10; i++) { for (int j = 0; j < 10; j++) { if (paper[i][j] == 0) { zeroCells++; } maxDensity = Math.max(maxDensity, paper[i][j]); } } System.out.println(zeroCells); System.out.println(maxDensity); sc.close(); } static void dropInk(int[][] paper, int x, int y, int size) { if (size == 1) { // Small: only center if (isValid(x, y)) { paper[y][x]++; } } else  0}, {1, 0}, {0, -1}, {0, 1} }; for (int[] offset : offsets) {  + offset[1]; if (isValid(nx, ny)) {  // Large: diamond pattern with radius 2 int[][] offsets = { {0, 0}, {-1, 0}, {1, 0}, {0, -1},  {-1, -1}, {-1, 1}, {1, -1}, {1, 1} }; for (int[] offset : offsets) { int nx = x + offset[0]; int ny = y + offset[1]; if (isValid(nx,  x, int y) { return x >= 0 && x < 10 && y >= 0 && y < 10; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader;  area = new int[10 * 10]; String str; try { while ((str = br.readLine()) != null) { String strArray[] = str.split(\",\"); int x = Integer.parseInt(strArray[0]); int y = Integer.parseInt(strArray[1]); int size = Integer.parseInt(strArray[2]); int point = y * 10  8) area[point + 2]++; if (x > 1) area[point - 2]++; if (y < 8) area[point + 20]++; if (y > 1) area[point - 20]++; case 2: // \u5de6\u4e0a if (x > 0 && y > 0) area[point - 11]++; // \u53f3\u4e0a if (x < 9 && y > 0) area[point - 9]++; //  + 9]++; // \u53f3\u4e0b if (y < 9 && x < 9) area[point + 11]++; case 1: if (x < 9) area[point + 1]++; if (x > 0) area[point - 1]++; if (y < 9) area[point + 10]++; if (y > 1) area[point - 10]++; area[point]++; } } } catch (NumberFormatException e) { //  blank = 0; for (int i = 0; i < 100; i++) { if (area[i] != 0) { blank =  }"], "original_ll": -0.6759960651397705, "sampled_ll": -0.4992695748806, "all_perturbed_sampled_ll": [-1.372220754623413], "all_perturbed_original_ll": [-1.1765342950820923], "perturbed_sampled_ll": -1.372220754623413, "perturbed_original_ll": -1.1765342950820923, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Cloth(object):\n    cell = None\n    x = 0\n    y = 0\n    def __init__(self, x, y):\n        self.cell = list([list([0 for i in range(y)]) for i in range(x)])\n        self.x = x\n        self.y = y\n    def check(self, x, y):\n        try:\n            self.cell[x][y] += 0\n            return True\n        except IndexError:\n            return False\n    def point(self, x, y):\n        try:\n            self.cell[x][y] += 1\n        except IndexError:\n            pass\n    def small(self, x, y):\n        if not self.check(x, y):\n            return\n        self.point(x, y + 1)\n        self.point(x - 1, y)\n        self.point(x, y)\n        self.point(x + 1, y)\n        self.point(x, y - 1)\n    def medium(self, x, y):\n        if not self.check(x, y):\n            return\n        self.small(x, y)\n        self.point(x + 1, y + 1)\n        self.point(x - 1, y + 1)\n        self.point(x + 1, y - 1)\n        self.point(x - 1, y - 1)\n    def large(self, x, y):\n        if not self.check(x, y):\n            return\n        self.medium(x, y)\n        self.point(x, y + 2)\n        self.point(x - 2, y)\n        self.point(x + 2, y)\n        self.point(x, y - 2)\ncloth = Cloth(10, 10)\nwhile True:\n    try:\n        (x, y, s) = map(lambda x:int(x)-1, raw_input().split(','))\n        if s == 0:\n            cloth.small(x, y)\n        elif s == 1:\n            cloth.medium(x, y)\n        elif s == 2:\n            cloth.large(x, y)\n    except EOFError:\n        break\nprint reduce(lambda x,y:x+y,map(lambda x:x.count(0),cloth.cell))\nprint max(map(max,cloth.cell))", "sampled": "import sys\n\n# Initialize 10x10 grid\ngrid = [[0 for _ in range(10)] for _ in range(10)]\n\n# Define ink patterns for each size relative to drop point\n# Size 1 (Small): just the center and 4 adjacent cells (cross pattern)\npatterns = {\n    1: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)],\n    2: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, 2), (0, -2), (2, 0), (-2, 0)],\n    3: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), \n        (0, 2), (0, -2), (2, 0), (-2, 0), (1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (0, 3), (0, -3), (3, 0), (-3, 0)]\n}\n\n# Read input and process drops\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    parts = line.split(',')\n    x = int(parts[0])\n    y = int(parts[1])\n    size = int(parts[2])\n    \n    # Apply ink pattern\n    for dx, dy in patterns[size]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < 10 and 0 <= ny < 10:\n            grid[ny][nx] += 1\n\n# Count cells with density 0 and find maximum density\nzero_count = 0\nmax_density = 0\n\nfor row in grid:\n    for cell in row:\n        if cell == 0:\n            zero_count += 1\n        max_density = max(max_density, cell)\n\nprint(zero_count)\nprint(max_density)\n", "perturbed_sampled": ["import sys # Initialize 10x10 grid grid = [[0 for _ in range(10)] for _ in range(10)] # Define ink patterns for each  the center and 4 adjacent cells (cross pattern) patterns = { 1: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)], 2: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1,  0)], 3: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, 2), (0, -2), (2, 0),  (2, 1), (2, -1), (-2, 1), (-2, -1), (0, 3), (0, -3), (3,  line: continue parts = line.split(',') x = int(parts[0]) y = int(parts[1]) size = int(parts[2]) # Apply ink pattern for dx, dy in patterns[size]: nx, ny = x + dx, y + dy if 0 <= nx < 10 and 0 <= ny < 10: grid[ny][nx] += 1  zero_count = 0 max_density = 0 for row in grid: for cell in row: if cell == 0: zero_count += 1 max_density = max(max_density, cell) print(zero_count) print(max_density)"], "perturbed_original": ["class Cloth(object): cell  x, y): self.cell =  = x self.y = y def check(self, x, y): try: self.cell[x][y] += 0 return True except IndexError: return False def point(self, x, y): try: self.cell[x][y] += 1 except IndexError: pass def small(self, x, y): if not self.check(x, y): return self.point(x, y + 1) self.point(x - 1, y) self.point(x, y) self.point(x + 1, y) self.point(x, y  return self.small(x, y) self.point(x + 1, y + 1) self.point(x - 1, y + 1) self.point(x + 1, y - 1) self.point(x - 1, y - 1) def large(self, x, y): if not self.check(x, y): return self.medium(x,  Cloth(10, 10) while True: try: (x, y, s) = map(lambda x:int(x)-1, raw_input().split(',')) if s == 0: cloth.small(x, y) elif s == 1: cloth.medium(x, y) elif s == 2: cloth.large(x, y) except EOFError: break print reduce(lambda x,y:x+y,map(lambda x:x.count(0),cloth.cell)) print max(map(max,cloth.cell))"], "original_ll": -0.7247860431671143, "sampled_ll": -0.6722749471664429, "all_perturbed_sampled_ll": [-1.0406136512756348], "all_perturbed_original_ll": [-1.3453612327575684], "perturbed_sampled_ll": -1.0406136512756348, "perturbed_original_ll": -1.3453612327575684, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n \nint dayOfWeek(int year, int month, int day)\n{\n    if (month == 1 || month == 2) {\n        year--;\n        month += 12;\n    }\n    return (year + year / 4 - year / 100 + year / 400\n        + (13 * month + 8) / 5 + day) % 7;\n}\n \nint main()\n{\n    int m, d;\n    char *day[7] = {\n        \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\n    };\n     \n    while (1) {\n        scanf(\"%d%d\", &m, &d);\n        if (m == 0 || d == 0) break;\n        puts(day[dayOfWeek(2004, m, d)]);\n    }\n    return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nint main() {\n    int days_in_month[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    char *day_names[] = {\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"};\n    \n    int m, d;\n    while(1) {\n        scanf(\"%d %d\", &m, &d);\n        if(m == 0 && d == 0) break;\n        \n        int total_days = 0;\n        for(int i = 1; i < m; i++) {\n            total_days += days_in_month[i];\n        }\n        total_days += d - 1;\n        \n        int day_index = total_days % 7;\n        printf(\"%s\\n\", day_names[day_index]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int days_in_month[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; char *day_names[] = {\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\",  total_days = 0; for(int i = 1; i < m; i++) { total_days += days_in_month[i]; } total_days += d - 1; int day_index = total_days % 7; printf(\"%s\\n\", day_names[day_index]); } return 0; }"], "perturbed_original": ["#include <stdio.h> int dayOfWeek(int year, int month, int  { year--; month += 12; } return (year + year / 4 - year / 100 + year / 400 + (13 * month + 8) / 5 + day) % 7; } int main() { int m,  \"Friday\", \"Saturday\" }; while (1) { scanf(\"%d%d\", &m, &d); if (m == 0 || d == 0) break; puts(day[dayOfWeek(2004, m, d)]); } return 0; }"], "original_ll": -0.9109442830085754, "sampled_ll": -0.5046465992927551, "all_perturbed_sampled_ll": [-0.8889096975326538], "all_perturbed_original_ll": [-1.5841784477233887], "perturbed_sampled_ll": -0.8889096975326538, "perturbed_original_ll": -1.5841784477233887, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid run(){\n\t\tint[] map={31,29,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] dp = new int [12];\n\t\tString[] str ={\n\t\t\t\t\"Monday\",\n\t\t\t\t\"Tuesday\",\n\t\t\t\t\"Wednesday\",\n\t\t\t\t\"Thursday\",\n\t\t\t\t\"Friday\",\n\t\t\t\t\"Monday\",\n\t\t\t\t\"Sunday\",\n\t\t};\n\t\tdp[0] = 2;\n\t\tfor(int i=1; i <12;i++){\n\t\t\tdp[i] = (dp[i-1] + map[i-1] +2)%7;\n\t\t}\n\t\tfor(;;){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(str[(dp[m-1]+n)%7]);\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int[] daysInMonth = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        String[] days = {\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"};\n        \n        while (true) {\n            int m = sc.nextInt();\n            int d = sc.nextInt();\n            \n            if (m == 0 && d == 0) {\n                break;\n            }\n            \n            int totalDays = 0;\n            for (int i = 1; i < m; i++) {\n                totalDays += daysInMonth[i];\n            }\n            totalDays += d - 1;\n            \n            System.out.println(days[totalDays % 7]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] daysInMonth = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; String[] days = {\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"}; while (true) {  == 0 && d == 0) { break; } int totalDays  i++) { totalDays += daysInMonth[i]; } totalDays += d - 1; System.out.println(days[totalDays % 7]); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import  new Scanner(System.in); void run(){ int[] map={31,29,31,30,31,30,31,31,30,31,30,31}; int[] dp = new int [12]; String[] str ={ \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Monday\", \"Sunday\", }; dp[0] = 2; for(int i=1; i <12;i++){  = sc.nextInt(); int n = sc.nextInt(); if((m|n)==0){ break; } System.out.println(str[(dp[m-1]+n)%7]); } } public static void main(String[] args){ Main m = new Main(); m.run(); } }"], "original_ll": -1.004957675933838, "sampled_ll": -0.4278634190559387, "all_perturbed_sampled_ll": [-0.9586312174797058], "all_perturbed_original_ll": [-1.6967427730560303], "perturbed_sampled_ll": -0.9586312174797058, "perturbed_original_ll": -1.6967427730560303, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "month, day = map(int, raw_input().split())\ndays = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\nyoubi = [\"Sunday\", \"Monday\", \"Tuesday\",\n         \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\nwhile month != 0:\n    Days = 0\n    for i in range(month - 1):\n        Days += days[i]\n    Days += day\n    print youbi[Days % 7]\n    month, day = map(int, raw_input().split())", "sampled": "days_of_week = [\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"]\ndays_in_month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nwhile True:\n    line = input().split()\n    m, d = int(line[0]), int(line[1])\n    \n    if m == 0 and d == 0:\n        break\n    \n    total_days = 0\n    for i in range(1, m):\n        total_days += days_in_month[i]\n    total_days += d - 1\n    \n    day_index = total_days % 7\n    print(days_of_week[day_index])\n", "perturbed_sampled": ["days_of_week = [\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"] days_in_month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] while True: line = input().split() m, d = int(line[0]), int(line[1]) if <extra_id_5>=<extra_id_6>12, 29]<extra_id_7>+=<extra_id_8>4 return False break 0 for i in range(1, m): total_days += days_in_month[i] total_days += d - 1 day_index = total_days % 7 print(days_of_week[day_index])"], "perturbed_original": ["month, day = map(int, raw_input().split()) days = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] youbi = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"] while month != 0: Days = 0 for i in range(month - 1): Days += days[i]  map(int, raw_input().split())"], "original_ll": -0.9888721704483032, "sampled_ll": -0.618447482585907, "all_perturbed_sampled_ll": [-1.5895107984542847], "all_perturbed_original_ll": [-1.2866941690444946], "perturbed_sampled_ll": -1.5895107984542847, "perturbed_original_ll": -1.2866941690444946, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n  int countArray[101], number, mx_number = 0;\n  memset(countArray, 0, sizeof countArray);\n\n  while(scanf(\"%d\", &number)!=EOF){\n    ++countArray[number];\n  }\n\n  for(number = 100; number > 0; --number)\n    if(countArray[number] > countArray[mx_number])\n      mx_number = number;\n\n  for(number = 1; number <= mx_number; ++number)\n    if(countArray[number] == countArray[mx_number])\n      printf(\"%d\\n\", number);\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int count[101] = {0};\n    int num;\n    int maxCount = 0;\n    \n    while (scanf(\"%d\", &num) != EOF) {\n        count[num]++;\n        if (count[num] > maxCount) {\n            maxCount = count[num];\n        }\n    }\n    \n    for (int i = 1; i <= 100; i++) {\n        if (count[i] == maxCount) {\n            printf(\"%d\\n\", i);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int count[101] = {0}; int num; int maxCount = 0; while (scanf(\"%d\", &num) != EOF)  } } for (int i = 1; i <= 100; i++) { if (count[i] == maxCount) { printf(\"%d\\n\", i); } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main() { int countArray[101], number, mx_number  for(number = 100; number > 0; --number) if(countArray[number] > countArray[mx_number]) mx_number = number; for(number = 1; number <= mx_number; ++number) if(countArray[number] == countArray[mx_number]) printf(\"%d\\n\", number); return 0; }"], "original_ll": -0.9871660470962524, "sampled_ll": -0.4140847623348236, "all_perturbed_sampled_ll": [-0.9896501898765564], "all_perturbed_original_ll": [-1.3161600828170776], "perturbed_sampled_ll": -0.9896501898765564, "perturbed_original_ll": -1.3161600828170776, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u30fb\u30b9\u30bf\u30d6\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString tmp = null;\n\t\tint cup = 0;\n\t\tint mun = 0;\n\t\tint ter = 0;\n\t\tString[] rrr;\n\t\tint st = 0,sr = 0;\n\t\tint mon = 0;\n\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\ttry {\n\t\t\t\ttmp = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp == null){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp.equals(\"\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tal.add(Integer.parseInt(tmp));\n\t\t}\n\t\t\n\t\t//System.out.println(al.toString());\n\t\tCollections.sort(al);\n\t\t//System.out.println(al.toString());\n\t\tArrayList<Integer> al2 = new ArrayList<Integer>();\n\t\tArrayList<Integer> al3 = new ArrayList<Integer>();\n\t\tint tmpr = 0;\n\t\t\n\t\tfor(int i=0;i<al.size();i++){\n\t\t\tif(tmpr ==0){\n\t\t\t\tal2.add(al.get(i));\n\t\t\t}\n\t\t\tif(al2.get(tmpr) < al.get(i)){\n\t\t\t\ttmpr++;\n\t\t\t\tal2.add(al.get(i));\n\t\t\t}\n\t\t}\n\t\tint aaa = 0;\n\t\tfor(int i=0;i<al2.size();i++){\n\t\t\ttmpr = 0;\n\t\t\tfor(int j=0;j<al.size();j++){\n\t\t\t\tif(al.get(j) == al2.get(i)){\n\t\t\t\t\ttmpr++;\n\t\t\t\t}\n\t\t\t\tal3.add(tmpr);\n\t\t\t\tif(aaa < tmpr){\n\t\t\t\t\taaa = tmpr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<al3.size();i++){\n\t\t\tif(aaa == al3.get(i)){\n\t\t\t\tSystem.out.println(al2.get(i));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Map<Integer, Integer> count = new HashMap<>();\n        \n        while (sc.hasNextInt()) {\n            int num = sc.nextInt();\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n        \n        int maxCount = 0;\n        for (int c : count.values()) {\n            maxCount = Math.max(maxCount, c);\n        }\n        \n        List<Integer> modes = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                modes.add(entry.getKey());\n            }\n        }\n        \n        Collections.sort(modes);\n        \n        for (int mode : modes) {\n            System.out.println(mode);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); Map<Integer, Integer> count = new HashMap<>(); while (sc.hasNextInt()) { int  maxCount = 0; for (int c : count.values()) { maxCount = Math.max(maxCount, c);  : count.entrySet()) { if (entry.getValue() == maxCount) { modes.add(entry.getKey()); } } Collections.sort(modes); for (int mode : modes) { System.out.println(mode); } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Collections;  // TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u30fb\u30b9\u30bf\u30d6 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String tmp = null; int cup = 0; int mun = 0; int ter = 0; String[] rrr; int st   catch  if(tmp == null){ break; } if(tmp.equals(\"\")){ break; } al.add(Integer.parseInt(tmp)); } //System.out.println(al.toString()); Collections.sort(al); //System.out.println(al.toString()); ArrayList<Integer> al2 = new ArrayList<Integer>(); ArrayList<Integer> al3 = new ArrayList<Integer>(); int tmpr = 0; for(int i=0;i<al.size();i++){ if(tmpr ==0){ al2.add(al.get(i)); } if(al2.get(tmpr) < al.get(i)){ tmpr++; al2.add(al.get(i)); } } int aaa = 0; for(int i=0;i<al2.size();i++){ tmpr = 0; for(int j=0;j<al.size();j++){ if(al.get(j) == al2.get(i)){ tmpr++; } al3.add(tmpr); if(aaa < tmpr){ aaa = tmpr; } } } for(int i=0;i<al3.size();i++){ if(aaa == al3.get(i)){ System.out.println(al2.get(i)); } } } }"], "original_ll": -0.8464222550392151, "sampled_ll": -0.3624679446220398, "all_perturbed_sampled_ll": [-1.2054766416549683], "all_perturbed_original_ll": [-1.3175907135009766], "perturbed_sampled_ll": -1.2054766416549683, "perturbed_original_ll": -1.3175907135009766, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "num = [[0,i+1] for i in range(100)]\nwhile True:\n    try:\n        num[int(input())-1][0] += 1\n    except:\n        num.sort(reverse = True)\n        ans = []\n        for i in range(100):\n            if num[i][0] == num[0][0]:\n                ans.append(num[i][1])\n            else:\n                ans.sort()\n                for z in ans:\n                    print(z)\n                break\n        break\n", "sampled": "import sys\nfrom collections import Counter\n\nnumbers = []\nfor line in sys.stdin:\n    numbers.append(int(line.strip()))\n\ncounter = Counter(numbers)\nmax_count = max(counter.values())\nmode_values = sorted([num for num, count in counter.items() if count == max_count])\n\nfor val in mode_values:\n    print(val)\n", "perturbed_sampled": ["import sys from collections import Counter numbers = [] for line in sys.stdin: numbers.append(int(line.strip()))  num, count in counter.items() if count == max_count]) for val in mode_values: print(val)"], "perturbed_original": ["num = [[0,i+1] for i in range(100)] while True: try: num[int(input())-1][0] += 1 except: num.sort(reverse  num[i][0] == num[0][0]: ans.append(num[i][1]) else: ans.sort() for z in ans: print(z) break break"], "original_ll": -1.135990858078003, "sampled_ll": -1.0147686004638672, "all_perturbed_sampled_ll": [-2.8166043758392334], "all_perturbed_original_ll": [-2.1487741470336914], "perturbed_sampled_ll": -2.8166043758392334, "perturbed_original_ll": -2.1487741470336914, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void){\n\tint i=0,j,c,max=0,ans1=100,ans2=100,count=0;\n\tchar s[1000][33]={0};\n\tchar ch;\n\t\n\twhile(1){\n\t\tscanf(\"%c\",&ch);\n\t\tif(ch=='\\n')break;\n\t\tif(ch==' '){\n\t\t\tcount++;\n\t\t\ti=0;\n\t\t}\n\t\ts[count][i]=ch;\n\t\tif(max<1+i){\n\t\t\tmax=i+1;\n\t\t\tans2=count;\n\t\t}\n\t\tif(ch!=' ')i++;\n\t}\n\tmax=0;\n\tfor(i=0;i<count;i++){\n\t\tfor(j=i+1,c=0;j<count;j++){\n\t\t\tif(strcmp(s[i],s[j])==0){\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tif(max<c){\n\t\t\t\tmax=c;\n\t\t\t\tans1=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%s %s\\n\",s[ans1],s[ans2]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    char text[1001];\n    char words[100][33];\n    int count[100] = {0};\n    int wordCount = 0;\n    \n    fgets(text, sizeof(text), stdin);\n    \n    // Remove newline if present\n    int len = strlen(text);\n    if (len > 0 && text[len-1] == '\\n') {\n        text[len-1] = '\\0';\n    }\n    \n    // Parse words\n    char *token = strtok(text, \" \");\n    while (token != NULL) {\n        int found = -1;\n        for (int i = 0; i < wordCount; i++) {\n            if (strcmp(words[i], token) == 0) {\n                found = i;\n                break;\n            }\n        }\n        \n        if (found != -1) {\n            count[found]++;\n        } else {\n            strcpy(words[wordCount], token);\n            count[wordCount] = 1;\n            wordCount++;\n        }\n        \n        token = strtok(NULL, \" \");\n    }\n    \n    // Find most frequent word\n    int maxCount = 0;\n    int maxCountIndex = 0;\n    for (int i = 0; i < wordCount; i++) {\n        if (count[i] > maxCount) {\n            maxCount = count[i];\n            maxCountIndex = i;\n        }\n    }\n    \n    // Find longest word\n    int maxLen = 0;\n    int maxLenIndex = 0;\n    for (int i = 0; i < wordCount; i++) {\n        int len = strlen(words[i]);\n        if (len > maxLen) {\n            maxLen = len;\n            maxLenIndex = i;\n        }\n    }\n    \n    printf(\"%s %s\\n\", words[maxCountIndex], words[maxLenIndex]);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <ctype.h> int main() { char  0; fgets(text, sizeof(text), stdin); // Remove newline if present int len = strlen(text); if (len >  while (token != NULL) { int found = -1; for (int i  == 0) { found = i; break; } } if (found != -1) { count[found]++; } else { strcpy(words[wordCount], token); count[wordCount] = 1; wordCount++; } token = strtok(NULL, \" \"); } // Find most frequent word int maxCount = 0; int maxCountIndex = 0; for  (count[i] > maxCount) { maxCount = count[i]; maxCountIndex = i; } } // Find longest word int maxLen = 0; int maxLenIndex = 0; for (int i = 0; i < wordCount; i++) { int len = strlen(words[i]); if (len > maxLen) { maxLen = len; maxLenIndex = i; } } printf(\"%s %s\\n\", words[maxCountIndex], words[maxLenIndex]); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(void){ int i=0,j,c,max=0,ans1=100,ans2=100,count=0; char s[1000][33]={0}; char ch; while(1){ scanf(\"%c\",&ch); if(ch=='\\n')break; if(ch==' '){ count++; i=0; } s[count][i]=ch; if(max<1+i){ max=i+1; ans2=count; } if(ch!=' ')i++;  } } } printf(\"%s %s\\n\",s[ans1],s[ans2]); return 0; }"], "original_ll": -1.0555611848831177, "sampled_ll": -0.43979984521865845, "all_perturbed_sampled_ll": [-1.139914870262146], "all_perturbed_original_ll": [-1.4795931577682495], "perturbed_sampled_ll": -1.139914870262146, "perturbed_original_ll": -1.4795931577682495, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.HashMap;\nimport java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\n\t\tString[] st = sc.nextLine().split(\" \");\n\t\t\n\t\tfor(int i = 0; i < st.length; i++)\n\t\t\tif(map.containsKey(st[i]))\n\t\t\t\tmap.put(st[i], map.get(st[i])+1);\n\t\t\telse\n\t\t\t\tmap.put(st[i], 1);\n\t\t\n\t\tString max = st[0];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < st.length-1; i++){\n\t\t\tif(map.get(st[i]) < map.get(st[i+1]))max = st[i+1];\n\t\t    if(st[i].length() < st[i+1].length())count = i+1;\n\t\t}\n\t\t\tSystem.out.println(max + \" \" + st[count]);\n\t\t\t\n\t\t\tsc.close();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] words = line.split(\" \");\n        \n        Map<String, Integer> frequency = new HashMap<>();\n        for (String word : words) {\n            frequency.put(word, frequency.getOrDefault(word, 0) + 1);\n        }\n        \n        String mostFrequent = \"\";\n        int maxFreq = 0;\n        for (Map.Entry<String, Integer> entry : frequency.entrySet()) {\n            if (entry.getValue() > maxFreq) {\n                maxFreq = entry.getValue();\n                mostFrequent = entry.getKey();\n            }\n        }\n        \n        String longest = \"\";\n        int maxLen = 0;\n        for (String word : words) {\n            if (word.length() > maxLen) {\n                maxLen = word.length();\n                longest = word;\n            }\n        }\n        \n        System.out.println(mostFrequent + \" \" + longest);\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  String[] words = line.split(\" \"); Map<String, Integer> frequency = new HashMap<>(); for (String word : words) { frequency.put(word, frequency.getOrDefault(word, 0) + 1);  (Map.Entry<String, Integer> entry : frequency.entrySet()) { if (entry.getValue() > maxFreq) { maxFreq = entry.getValue(); mostFrequent = entry.getKey(); } } String longest = \"\"; int maxLen = 0; for (String word : words) { if (word.length() > maxLen) { maxLen = word.length(); longest = word; } } System.out.println(mostFrequent + \" \" + longest); } }"], "perturbed_original": ["import java.util.HashMap; import java.util.Scanner; class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); HashMap<String, Integer> map = new HashMap<String, Integer>(); String[] st = sc.nextLine().split(\" \"); for(int i = 0; i < st.length;  st[0]; int count = 0; for(int i = 0; i < st.length-1; i++){ if(map.get(st[i]) < map.get(st[i+1]))max =  \" + st[count]); sc.close(); } }"], "original_ll": -0.8052243590354919, "sampled_ll": -0.35838332772254944, "all_perturbed_sampled_ll": [-0.8887171745300293], "all_perturbed_original_ll": [-1.54545259475708], "perturbed_sampled_ll": -0.8887171745300293, "perturbed_original_ll": -1.54545259475708, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def solve():\n    text = input()\n    longest, length = '', 0\n    dic = {}\n    for word in text.split():\n        if word in dic.keys():\n            dic[word] += 1\n        else:\n            dic[word] = 1\n        \n        if length < len(word):\n            longest = word\n            length = len(word)\n    \n    target, cnt = '', 0\n    for k, v in dic.items():\n        if v > cnt:\n            target = k\n            cnt = v\n    print(target, longest)\n\nif __name__ == \"__main__\":\n    solve()\n\n", "sampled": "text = input().split()\nword_count = {}\nfor word in text:\n    word_count[word] = word_count.get(word, 0) + 1\n\nmost_frequent = max(word_count, key=word_count.get)\nlongest = max(text, key=len)\n\nprint(most_frequent, longest)\n", "perturbed_sampled": ["text = input().split() word_count = {} for word in text: word_count[word] = word_count.get(word, 0) + 1 most_frequent = max(word_count, key=word_count.get) longest = max(text, key=len) print(most_frequent, longest)"], "perturbed_original": ["def solve(): text = input() longest, length = '', 0 dic = {} for word in text.split(): if  if length < len(word): longest = word length = len(word) target, cnt = '', 0 for k, v in dic.items(): if v > cnt: target = k cnt = v print(target, longest) if __name__ == \"__main__\": solve()"], "original_ll": -0.9060442447662354, "sampled_ll": -1.0406062602996826, "all_perturbed_sampled_ll": [-1.271648645401001], "all_perturbed_original_ll": [-1.7513809204101562], "perturbed_sampled_ll": -1.271648645401001, "perturbed_original_ll": -1.7513809204101562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\n\nint val[10];\nint s;\n\nint getWay(int x, int n, int sum)\n{\n\tint ret = 0;\n\tint i;\n\t\n\tif (n == 0){\n\t\tif (sum == s){\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\t\n\tfor (i = x; i < 10; i++){\n\t\tif (val[i] == 0 && sum + i <= s){\n\t\t\tval[i] = 1;\n\t\t\tret += getWay(i, n - 1, i + sum);\n\t\t\tval[i] = 0;\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint main(void)\n{\n\twhile (1){\n\t\tint n;\n\t\t\n\t\tscanf(\"%d%d\", &n, &s);\n\t\tmemset(val, 0, sizeof(val));\n\t\t\n\t\tif (n == 0 && s == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", getWay(0, n, 0));\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n\nint count_combinations(int pos, int n, int s, int used) {\n    if (n == 0) {\n        return (s == 0) ? 1 : 0;\n    }\n    if (pos > 9 || s < 0) {\n        return 0;\n    }\n    \n    int result = 0;\n    // Don't use current digit\n    result += count_combinations(pos + 1, n, s, used);\n    // Use current digit\n    result += count_combinations(pos + 1, n - 1, s - pos, used);\n    \n    return result;\n}\n\nint main() {\n    int n, s;\n    \n    while (1) {\n        scanf(\"%d %d\", &n, &s);\n        if (n == 0 && s == 0) {\n            break;\n        }\n        \n        int result = count_combinations(0, n, s, 0);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int count_combinations(int pos, int n, int s, int used) { if (n == 0) { return (s == 0) ? 1 : 0; } if (pos > 9 || s  // Don't use current digit result += count_combinations(pos +  count_combinations(pos + 1, n - 1, s - pos, used); return result; } int main() { int n, s; while (1) { scanf(\"%d %d\", &n, &s); if (n  result = count_combinations(0, n, s, 0); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int val[10]; int s; int getWay(int x, int n, int sum) { int ret = 0; int i; if (n == 0){ if (sum  0 && sum + i <= s){ val[i] = 1; ret += getWay(i, n -  (ret); } int main(void) { while (1){ int n; scanf(\"%d%d\", &n, &s); memset(val, 0, sizeof(val)); if (n == 0 && s == 0){ break; } printf(\"%d\\n\", getWay(0, n, 0)); } return (0); }"], "original_ll": -0.8791469931602478, "sampled_ll": -0.6037840843200684, "all_perturbed_sampled_ll": [-1.4404855966567993], "all_perturbed_original_ll": [-1.7693092823028564], "perturbed_sampled_ll": -1.4404855966567993, "perturbed_original_ll": -1.7693092823028564, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main {\n    public static void main(String args[]){\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try{\n            String line;\n            \n            while((line=br.readLine())!=null){\n                if(line.equals(\"\"))break;\n                String[] splited = line.split(\" \");\n                int n = Integer.parseInt(splited[0]);\n                s = Integer.parseInt(splited[1]);\n                if(n==0&&s==0)break;if(n>=10)System.out.println(\"0\");\n                    combis(1,n);\n                    System.out.println(count);\n                count=0;\n            }         \n        }catch(Exception e){e.printStackTrace();}\n        \n    }\n    static int[] com = new int[10];\n    static int count = 0,s=0;\n    static void combis(int st,int r){\n        if(st<=r){\n            for(int i=(st==1)? 0:com[st-1]+1;i<=9-r+st;i++){\n                com[st]=i;\n                combis(st+1,r);\n            }\n        }else{\n            //System.out.println(Arrays.toString(com));\n            int sum=0; for(int i=1;i<=r;i++) sum+=com[i];\n            if(sum==s)count++;\n        }\n        \n        }\n    static int _10Cn(int n){\n            int _n=1,d=1;\n            for(int i=1; i<=n;i++){\n                _n*=11-i; d*=i;\n            }\n            return _n/d;\n        }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int s = sc.nextInt();\n            \n            if (n == 0 && s == 0) {\n                break;\n            }\n            \n            int count = countCombinations(n, s, 0, 0);\n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n    \n    private static int countCombinations(int n, int s, int start, int depth) {\n        if (depth == n) {\n            return s == 0 ? 1 : 0;\n        }\n        \n        if (start > 9) {\n            return 0;\n        }\n        \n        int count = 0;\n        for (int i = start; i <= 9; i++) {\n            count += countCombinations(n, s - i, i + 1, depth + 1);\n        }\n        \n        return count;\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); int s = sc.nextInt(); if (n == 0 && s == 0) { break; } int count = countCombinations(n, s, 0, 0); System.out.println(count);  { return s == 0 ? 1 : 0; } if (start > 9) { return 0; } int count = 0; for (int i = start; i <= 9; i++) { count += countCombinations(n, s - i, i + 1, depth + 1); } return count; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; public class Main { public static void main(String args[]){ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); try{ String line; while((line=br.readLine())!=null){ if(line.equals(\"\"))break; String[] splited = line.split(\" \"); int n = Integer.parseInt(splited[0]); s = Integer.parseInt(splited[1]); if(n==0&&s==0)break;if(n>=10)System.out.println(\"0\"); combis(1,n); System.out.println(count); count=0; } }catch(Exception e){e.printStackTrace();} } static int[] com = new int[10]; static int count  0:com[st-1]+1;i<=9-r+st;i++){ com[st]=i; combis(st+1,r); } }else{ //System.out.println(Arrays.toString(com)); int sum=0; for(int i=1;i<=r;i++) sum+=com[i]; if(sum==s)count++; } }  d*=i; } return _n/d; } }"], "original_ll": -1.3355286121368408, "sampled_ll": -0.42449766397476196, "all_perturbed_sampled_ll": [-1.2104007005691528], "all_perturbed_original_ll": [-1.7701820135116577], "perturbed_sampled_ll": -1.2104007005691528, "perturbed_original_ll": -1.7701820135116577, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nsys.setrecursionlimit(10000)\n\ndef solve(i,wa,use):\n    global ct,s,n\n    if wa==s and use==n:\n        ct+=1\n        return\n    if use>=n or i==10 or wa>s:\n        return\n    solve(i+1,wa,use)\n    solve(i+1,wa+i,use+1)\n\nwhile 1:\n    n,s=map(int,raw_input().split())\n    if n==0 and s==0:\n        break\n    ct=0\n    wa=0\n    solve(0,0,0)\n    print ct", "sampled": "from itertools import combinations\n\nwhile True:\n    n, s = map(int, input().split())\n    if n == 0 and s == 0:\n        break\n    \n    count = 0\n    for combo in combinations(range(10), n):\n        if sum(combo) == s:\n            count += 1\n    \n    print(count)\n", "perturbed_sampled": ["from itertools import combinations while True: n, s = map(int, input().split()) if n == 0 and s == 0:  sum(combo) == s: count += 1 print(count)"], "perturbed_original": ["import  ct+=1 return if use>=n or i==10 or wa>s: return solve(i+1,wa,use) solve(i+1,wa+i,use+1) while 1: n,s=map(int,raw_input().split()) if n==0 and s==0: break ct=0 wa=0 solve(0,0,0) print ct"], "original_ll": -1.1724587678909302, "sampled_ll": -0.6921679973602295, "all_perturbed_sampled_ll": [-1.850659966468811], "all_perturbed_original_ll": [-2.486441135406494], "perturbed_sampled_ll": -1.850659966468811, "perturbed_original_ll": -2.486441135406494, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0031\nWeight\n*/\n#include <stdio.h>\n\n\nmain()\n{\n  int weight;\n  int fundou;\n  int flag;\n  \n  while(EOF !=scanf(\"%d\",&weight))\n    {\n      flag = 0;\n      for(fundou=1;fundou <= 512;fundou <<= 1)\n      { if(weight & fundou)\n        {\n          if(flag)\n            printf(\" \");\n          printf(\"%d\",fundou);\n          flag = 1;\n        }\n      }\n        printf(\"\\n\");\n    }\n\nreturn(0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int weight;\n    int weights[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};\n    \n    while(scanf(\"%d\", &weight) != EOF) {\n        int first = 1;\n        for(int i = 0; i < 10; i++) {\n            if(weight & (1 << i)) {\n                if(!first) {\n                    printf(\" \");\n                }\n                printf(\"%d\", weights[i]);\n                first = 0;\n            }\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int weight; int weights[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512}; while(scanf(\"%d\", &weight) != EOF) { int first = 1; for(int i = 0; i < 10; i++) { if(weight & (1 << i)) { if(!first) {  printf(\"\\n\"); } return 0; }"], "perturbed_original": ["/* AizuOnline A0031 Weight */ #include <stdio.h> main() { int weight; int fundou; int flag; while(EOF !=scanf(\"%d\",&weight)) { flag = 0;  if(flag) printf(\" \"); printf(\"%d\",fundou); flag = 1; } } printf(\"\\n\"); } return(0); }"], "original_ll": -1.9631786346435547, "sampled_ll": -0.6626967191696167, "all_perturbed_sampled_ll": [-1.1674686670303345], "all_perturbed_original_ll": [-2.6457509994506836], "perturbed_sampled_ll": -1.1674686670303345, "perturbed_original_ll": -2.6457509994506836, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n        public static void main(String[] args){\n                Scanner sc = new Scanner(System.in);\n                while(sc.hasNext()){\n                        String b = Integer.toString(sc.nextInt(), 2); \n                        String s = \"\"; \n                        for(int i = 0; i < b.length(); i++){\n                                if(b.charAt(b.length()-1-i) == '1'){\n                                        if(!s.equals(\"\")){\n                                                s += \" \";\n                                        }   \n                                        s += (int)Math.pow(2,i);\n                                }   \n                        }   \n                        System.out.println(s);\n                }   \n                sc.close();\n        }   \n}", "sampled": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int weight = sc.nextInt();\n            ArrayList<Integer> weights = new ArrayList<>();\n            \n            int[] powers = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};\n            \n            for (int i = 0; i < powers.length; i++) {\n                if ((weight & (1 << i)) != 0) {\n                    weights.add(powers[i]);\n                }\n            }\n            \n            for (int i = 0; i < weights.size(); i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(weights.get(i));\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; import java.util.ArrayList; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int weight = sc.nextInt(); ArrayList<Integer> weights = new ArrayList<>(); int[] powers = {1, 2, 4, 8, 16, 32, 64, 128,  i++) { if ((weight & (1 << i)) != 0) { weights.add(powers[i]); }  { if (i > 0) System.out.print(\" \"); System.out.print(weights.get(i)); } System.out.println(); } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); while(sc.hasNext()){ String b = Integer.toString(sc.nextInt(), 2); String s = \"\"; for(int  if(!s.equals(\"\")){ s += \" \"; } s += (int)Math.pow(2,i); } } System.out.println(s); } sc.close(); } }"], "original_ll": -1.0754268169403076, "sampled_ll": -0.5055698752403259, "all_perturbed_sampled_ll": [-1.1351474523544312], "all_perturbed_original_ll": [-1.7581369876861572], "perturbed_sampled_ll": -1.1351474523544312, "perturbed_original_ll": -1.7581369876861572, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#encoding=utf-8\nimport itertools as iter\nimport sys\nfor i in sys.stdin:\n    omori = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n    x = int(i)\n    for i in xrange(1,11):\n        for element in iter.combinations(omori,i):\n             if sum(element) == x:\n                 for k in xrange(len(element)):\n                     print element[k],\n                 print \"\"", "sampled": "import sys\n\nfor line in sys.stdin:\n    weight = int(line.strip())\n    weights = []\n    power = 0\n    \n    while weight > 0:\n        if weight & 1:\n            weights.append(2 ** power)\n        weight >>= 1\n        power += 1\n    \n    print(' '.join(map(str, weights)))\n", "perturbed_sampled": ["import sys for line in sys.stdin: weight =  0: if weight & 1: weights.append(2 ** power) weight >>= 1 power += 1 print(' '.join(map(str, weights)))"], "perturbed_original": ["#encoding=utf-8 import itertools as iter import sys for i in  128, 256, 512] x = int(i) for i in xrange(1,11): for element in iter.combinations(omori,i): if sum(element) == x: for k in xrange(len(element)): print element[k], print \"\""], "original_ll": -1.3029707670211792, "sampled_ll": -1.1976935863494873, "all_perturbed_sampled_ll": [-2.5789873600006104], "all_perturbed_original_ll": [-2.5772879123687744], "perturbed_sampled_ll": -2.5789873600006104, "perturbed_original_ll": -2.5772879123687744, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint tyou=0, hisi=0;\n\tint a, b, c;\n\t\n\twhile(scanf(\"%d,%d,%d\", &a, &b, &c)!=EOF) {\n\t\tif(c*c==a*a+b*b) tyou++;\n\t\tif(a==b) hisi++;\n\t}\n\t\n\tprintf(\"%d\\n%d\\n\", tyou, hisi);\n\t\n\treturn 0;\n}\n", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[256];\n    int rectangles = 0;\n    int rhombuses = 0;\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int a, b, c;\n        if (sscanf(line, \"%d,%d,%d\", &a, &b, &c) == 3) {\n            // Check if it's a rectangle: a^2 + b^2 = c^2\n            if (a * a + b * b == c * c) {\n                rectangles++;\n            }\n            // Check if it's a rhombus: a = b\n            else if (a == b) {\n                rhombuses++;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", rectangles);\n    printf(\"%d\\n\", rhombuses);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char line[256]; int rectangles = 0; int rhombuses = 0; while (fgets(line, sizeof(line), stdin)) { int a,  b^2 = c^2 if (a * a + b * b == c * c) { rectangles++; } // Check if it's a rhombus: a = b else if (a == b) { rhombuses++; } } } printf(\"%d\\n\", rectangles); printf(\"%d\\n\", rhombuses); return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int tyou=0, hisi=0; int a, b, c; while(scanf(\"%d,%d,%d\", &a, &b, &c)!=EOF) { if(c*c==a*a+b*b) tyou++; if(a==b) hisi++; } printf(\"%d\\n%d\\n\", tyou, hisi); return 0; }"], "original_ll": -1.362696886062622, "sampled_ll": -0.6247656941413879, "all_perturbed_sampled_ll": [-1.4473357200622559], "all_perturbed_original_ll": [-1.4423370361328125], "perturbed_sampled_ll": -1.4473357200622559, "perturbed_original_ll": -1.4423370361328125, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = null;\n\t\ttry {\n\t\t\tsc = new Scanner(System.in);\n\t\t\tint countRectangle = 0;\n\t\t\tint countRhombus = 0;\n\t\t\twhile (sc.hasNextLine()) {\n\t\t\t\tString[] input = sc.nextLine().split(\",\");\n\t\t\t\tint[] x = new int[3];\n\t\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\t\tx[i] = Integer.parseInt(input[i]);\n\t\t\t\tif (x[0] * x[0] + x[1] * x[1] == x[2] * x[2])\n\t\t\t\t\tcountRectangle++;\n\t\t\t\telse if (x[0] == x[1])\n\t\t\t\t\tcountRhombus++;\n\t\t\t}\n\t\t\tSystem.out.println(countRectangle);\n\t\t\tSystem.out.println(countRhombus);\n\t\t} finally {\n\t\t\tsc.close();\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int rectangles = 0;\n        int rhombuses = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            int c = Integer.parseInt(parts[2]);\n            \n            // Check if rectangle: a^2 + b^2 = c^2 (diagonal satisfies Pythagorean theorem)\n            if (a * a + b * b == c * c) {\n                rectangles++;\n            }\n            // Check if rhombus: all sides equal (a == b)\n            else if (a == b) {\n                rhombuses++;\n            }\n        }\n        \n        System.out.println(rectangles);\n        System.out.println(rhombuses);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;   rhombuses = 0; while (sc.hasNextLine()) { String line =  = Integer.parseInt(parts[0]); int b = Integer.parseInt(parts[1]); int c = Integer.parseInt(parts[2]); // Check if rectangle: a^2 + b^2 = c^2 (diagonal satisfies Pythagorean theorem) if (a * a + b * b == c * c) { rectangles++; } // Check if rhombus: all sides equal (a == b) else if (a == b) { rhombuses++; } } System.out.println(rectangles); System.out.println(rhombuses); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String[] args) { Scanner sc  = 0; int countRhombus = 0; while (sc.hasNextLine()) { String[] input = sc.nextLine().split(\",\"); int[] x = new int[3];  = Integer.parseInt(input[i]); if (x[0] * x[0] + x[1] * x[1] == x[2] * x[2]) countRectangle++; else if (x[0] == x[1]) countRhombus++; } System.out.println(countRectangle); System.out.println(countRhombus); } finally { sc.close(); } } }"], "original_ll": -0.6246577501296997, "sampled_ll": -0.6703314781188965, "all_perturbed_sampled_ll": [-1.5615466833114624], "all_perturbed_original_ll": [-1.2912368774414062], "perturbed_sampled_ll": -1.5615466833114624, "perturbed_original_ll": -1.2912368774414062, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nnum1=0                                          #\u9577\u65b9\u5f62\u306e\u6570                                                 \nnum2=0                                          #\u3072\u3057\u5f62\u306e\u6570\nwhile True:\n    try:\n        a,b,c=list(map(int, input().split(\",\")))\n    except:\n        break\n    \n    if pow(a,2)+pow(b,2)==pow(c,2):\n        num1+=1\n    elif a==b and a+b>c:\n        num2+=1\n\nprint(num1)\nprint(num2)\n\n", "sampled": "import sys\nimport math\n\nrectangle_count = 0\nrhombus_count = 0\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    \n    parts = line.split(',')\n    a, b, c = int(parts[0]), int(parts[1]), int(parts[2])\n    \n    # Check if it's a rectangle\n    # In a rectangle, the diagonal satisfies: c^2 = a^2 + b^2\n    if a * a + b * b == c * c:\n        rectangle_count += 1\n    \n    # Check if it's a rhombus\n    # In a rhombus, all sides are equal: a == b\n    if a == b:\n        rhombus_count += 1\n\nprint(rectangle_count)\nprint(rhombus_count)\n", "perturbed_sampled": ["import sys import math rectangle_count = 0 rhombus_count = 0 for line in sys.stdin: line = line.strip() if not  int(parts[1]), int(parts[2]) # Check if it's a rectangle # In a  a * a + b * b == c * c: rectangle_count += 1 # Check if it's a rhombus # In a rhombus, all sides are equal: a == b if a == b: rhombus_count += 1 print(rectangle_count) print(rhombus_count)"], "perturbed_original": ["import math num1=0 #\u9577\u65b9\u5f62\u306e\u6570 num2=0 #\u3072\u3057\u5f62\u306e\u6570 while True: try: a,b,c=list(map(int, input().split(\",\"))) except: break if pow(a,2)+pow(b,2)==pow(c,2): num1+=1 elif a==b and a+b>c: num2+=1 print(num1) print(num2)"], "original_ll": -1.7677839994430542, "sampled_ll": -0.735996425151825, "all_perturbed_sampled_ll": [-2.0815188884735107], "all_perturbed_original_ll": [-2.100698471069336], "perturbed_sampled_ll": -2.0815188884735107, "perturbed_original_ll": -2.100698471069336, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n\n\tint i,j,n,a[10],b,c,nflag;\n\n\tscanf(\"%d\",&n);\n\n\tfor(i=0;i<n;i++){\n\t\tnflag=0;\n\t\tfor(j=0;j<9;j++) scanf(\"%d \",&a[j]);\n\t\tscanf(\"%d\",&a[9]);\n\n\t\tb=a[0];\n\t\tc=0;\n\t\tfor(j=1;j<10;j++){\n\t\t\tif(b<a[j]) b=a[j];\n\t\t\telse if(c<a[j]) c=a[j];\n\t\t\telse{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\tnflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(nflag) continue;\n\t\tprintf(\"YES\\n\");\n\n\t}\n\n\n\n\treturn 0;\n\n}", "sampled": "#include <stdio.h>\n#include <stdbool.h>\n\nbool canArrange(int balls[10]) {\n    // Try all possible combinations of putting balls in B or C\n    // Use bitmask: 0 = put in B, 1 = put in C\n    for (int mask = 0; mask < (1 << 10); mask++) {\n        int b[10], c[10];\n        int bCount = 0, cCount = 0;\n        bool valid = true;\n        \n        // Distribute balls according to mask\n        for (int i = 0; i < 10; i++) {\n            if ((mask & (1 << i)) == 0) {\n                // Put in B\n                if (bCount > 0 && b[bCount - 1] > balls[i]) {\n                    valid = false;\n                    break;\n                }\n                b[bCount++] = balls[i];\n            } else {\n                // Put in C\n                if (cCount > 0 && c[cCount - 1] > balls[i]) {\n                    valid = false;\n                    break;\n                }\n                c[cCount++] = balls[i];\n            }\n        }\n        \n        if (valid) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        int balls[10];\n        for (int j = 0; j < 10; j++) {\n            scanf(\"%d\", &balls[j]);\n        }\n        \n        if (canArrange(balls)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdbool.h> bool canArrange(int balls[10]) { // Try all possible combinations of putting balls in B or C // Use bitmask: 0 = put in B, 1 = put in C for (int mask = 0; mask < (1 << 10); mask++) { int b[10], c[10]; int bCount = 0, cCount = 0; bool valid = true; // Distribute  (bCount > 0 && b[bCount -  = balls[i]; } else { // Put in C if (cCount > 0 && c[cCount - 1] > balls[i]) { valid = false; break; } c[cCount++] = balls[i]; } } if (valid) { return true; } } return false; } int main() { int n; scanf(\"%d\", &n); for (int i = 0; i < n; i++) { int balls[10]; for (int j = 0; j < 10;  else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int i,j,n,a[10],b,c,nflag; scanf(\"%d\",&n); for(i=0;i<n;i++){ nflag=0; for(j=0;j<9;j++) scanf(\"%d \",&a[j]); scanf(\"%d\",&a[9]); b=a[0]; c=0; for(j=1;j<10;j++){ if(b<a[j]) b=a[j]; else if(c<a[j]) c=a[j]; else{ printf(\"NO\\n\"); nflag=1; break; } } if(nflag) continue; printf(\"YES\\n\"); } return 0; }"], "original_ll": -1.075134515762329, "sampled_ll": -0.5315077900886536, "all_perturbed_sampled_ll": [-1.3427680730819702], "all_perturbed_original_ll": [-1.146336555480957], "perturbed_sampled_ll": -1.3427680730819702, "perturbed_original_ll": -1.146336555480957, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static final int N = 12;\n\tint[] a = new int[N];\n\tint small = 0;\n\tint big = 0;\n\t\n\tprivate int s=0;     //\u6570?\u7684\u4e2a\u6570\n\t\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.Sort();\n\t}\n\t\n\t\n\tprivate void Sort(){\t\n\n\t\tScanner sc = new Scanner(System.in);\n\t\ts = sc.nextInt();\n\t\t\n\t\twhile(s!= 0){\t\n\t\t\t\n\t\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t/*for (int m = 1; m <= 10; m++) {\n\t\t\t\tSystem.out.print(a[m]+ \" \");\n\t\t\t}*/\n\t\t\t\n\t\t\tif (a[1] > a[2]) {\n\t\t\t\tbig = a[1];\n\t\t\t\tsmall = a[2];\n\t\t\t}else {\n\t\t\t\tbig = a[2];\n\t\t\t\tsmall = a[1];\n\t\t\t}\n\t\t\t//System.out.println(big);\n\t\t\t\n\t\t\tfor (int j = 3; j <= 10; j++) {\n\t\t\t\tif (a[j] > big) {\n\t\t\t\t\tbig = a[j];\n\t\t\t\t}\n\t\t\t\tif (a[j] < big && a[j] > small) {\n\t\t\t\t\tsmall = a[j];\n\t\t\t\t}\n\t\t\t\tif (a[j] < small) {\n\t\t\t\t\tSystem.out.printf(\"%s\\n\",\"NO\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 10) {\n\t\t\t\t\tSystem.out.printf(\"%s\\n\",\"YES\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(s);\n\t\t\ts--;\n\t\t\t\t\n\t\t}\n\t\tsc.close();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[] balls;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            balls = new int[10];\n            for (int j = 0; j < 10; j++) {\n                balls[j] = sc.nextInt();\n            }\n            \n            if (canArrange(0, new ArrayList<>(), new ArrayList<>())) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        sc.close();\n    }\n    \n    static boolean canArrange(int index, List<Integer> b, List<Integer> c) {\n        if (index == 10) {\n            return true;\n        }\n        \n        int current = balls[index];\n        \n        // Try to put in B\n        boolean canPutInB = true;\n        if (!b.isEmpty() && b.get(b.size() - 1) > current) {\n            canPutInB = false;\n        }\n        \n        if (canPutInB) {\n            b.add(current);\n            if (canArrange(index + 1, b, c)) {\n                return true;\n            }\n            b.remove(b.size() - 1);\n        }\n        \n        // Try to put in C\n        boolean canPutInC = true;\n        if (!c.isEmpty() && c.get(c.size() - 1) > current) {\n            canPutInC = false;\n        }\n        \n        if (canPutInC) {\n            c.add(current);\n            if (canArrange(index + 1, b, c)) {\n                return true;\n            }\n            c.remove(c.size() - 1);\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class ) <<extra_id_6>true; } c.remove(c.size() - 1);<extra_id_7>i = 0;<extra_id_8><=<extra_id_9>return false; }<extra_id_10>e =<extra_id_11>; if (<extra_id_12>} if<extra_id_13>; } return false<extra_id_14>//<extra_id_15>return true; }<extra_id_16>{ throw  for (int i = 0; i < n; i++) { balls = new int[10]; for (int j = 0; j < 10; j++) { balls[j] = sc.nextInt(); } if (canArrange(0, new ArrayList<>(), new ArrayList<>())) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); } static boolean canArrange(int index, List<Integer> b, List<Integer> c) { if (index == 10) { return true; } int current = balls[index]; // Try to put in B boolean canPutInB = true; if (!b.isEmpty() && b.get(b.size() -  return true; } b.remove(b.size() - 1); } // Try to put in C boolean canPutInC = true; if (!c.isEmpty() && c.get(c.size() - 1) > current) { canPutInC = false; } if (canPutInC) { c.add(current);  c.remove(c.size() - 1); } return false; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { private static final int N = 12; int[] a = new int[N]; int small = 0; int big = 0; private int s=0; //\u6570?\u7684\u4e2a\u6570 public static void main(String[] args) { Main m = new  Scanner(System.in); s = sc.nextInt(); while(s!= 0){ for (int i = 1; i <= 10; i++)  if (a[1] > a[2]) { big = a[1]; small = a[2]; }else { big = a[2]; small = a[1]; } //System.out.println(big); for (int j = 3; j <= 10; j++) { if (a[j] > big) { big = a[j]; } if (a[j] < big && a[j] > small) { small = a[j]; } if (a[j] < small) { System.out.printf(\"%s\\n\",\"NO\"); break;  //System.out.println(s); s--; } sc.close(); } }"], "original_ll": -0.9852482080459595, "sampled_ll": -0.4311102330684662, "all_perturbed_sampled_ll": [-1.585240364074707], "all_perturbed_original_ll": [-1.5025686025619507], "perturbed_sampled_ll": -1.585240364074707, "perturbed_original_ll": -1.5025686025619507, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for data in range(input()):\n    dataset=map(int,raw_input().split(\" \"))\n    B,C=0,0\n    B=dataset.pop(0)\n    while len(dataset)!=0:\n        ball = dataset.pop(0)\n        if ball-B<0 or ball-C<0:\n            if ball-B<0 and ball-C<0:\n                print \"NO\"\n                break\n            elif ball-B<0:\n                C=ball\n            else:\n                B=ball\n        else:\n            if ball-B<ball-C:\n                B=ball\n            else:\n                C=ball\n    if(len(dataset)==0):\n        print \"YES\"", "sampled": "def can_sort(sequence):\n    def is_valid(b_stack, c_stack, index):\n        if index == 10:\n            return True\n        \n        ball = sequence[index]\n        \n        # Try putting in B\n        can_put_b = len(b_stack) == 0 or b_stack[-1] < ball\n        if can_put_b:\n            b_stack.append(ball)\n            if is_valid(b_stack, c_stack, index + 1):\n                return True\n            b_stack.pop()\n        \n        # Try putting in C\n        can_put_c = len(c_stack) == 0 or c_stack[-1] < ball\n        if can_put_c:\n            c_stack.append(ball)\n            if is_valid(b_stack, c_stack, index + 1):\n                return True\n            c_stack.pop()\n        \n        return False\n    \n    return is_valid([], [], 0)\n\nn = int(input())\nfor _ in range(n):\n    sequence = list(map(int, input().split()))\n    if can_sort(sequence):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["def can_sort(sequence): def is_valid(b_stack, c_stack, index): if index == 10: return True ball = sequence[index] # Try putting in B can_put_b = len(b_stack) == 0 or b_stack[-1] < ball if can_put_b: b_stack.append(ball) if is_valid(b_stack, c_stack, index + 1): return True b_stack.pop() # Try putting in C can_put_c = len(c_stack) == 0 or c_stack[-1] < ball if  c_stack.pop() return False return is_valid([], [], 0) n =  can_sort(sequence): print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["for data in range(input()): dataset=map(int,raw_input().split(\" \")) B,C=0,0 B=dataset.pop(0) while len(dataset)!=0: ball = dataset.pop(0) if ball-B<0 or ball-C<0: if ball-B<0 and ball-C<0:  ball-B<ball-C: B=ball else: C=ball if(len(dataset)==0): print \"YES\""], "original_ll": -1.2449607849121094, "sampled_ll": -0.7508653402328491, "all_perturbed_sampled_ll": [-1.7944371700286865], "all_perturbed_original_ll": [-2.094519853591919], "perturbed_sampled_ll": -1.7944371700286865, "perturbed_original_ll": -2.094519853591919, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nmain(){\n  int i,ans;\n  double l[10],km,k,v[2];\n  while(scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\",&l[0],&l[1],&l[2],&l[3],&l[4],&l[5],&l[6],&l[7],&l[8],&l[9],&v[0],&v[1])!=EOF){\n    km=l[0]+l[1]+l[2]+l[3]+l[4]+l[5]+l[6]+l[7]+l[8]+l[9];\n    k=km*v[0]/(v[0]+v[1]);\n    for(i=0;i>=0;i++){\n      k-=l[i];\n      if(k<=0){\n\tans=i+1;\n\ti=-2;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[256];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int l[10];\n        int v1, v2;\n        \n        sscanf(line, \"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\",\n               &l[0], &l[1], &l[2], &l[3], &l[4],\n               &l[5], &l[6], &l[7], &l[8], &l[9],\n               &v1, &v2);\n        \n        // Calculate total distance\n        int total = 0;\n        for (int i = 0; i < 10; i++) {\n            total += l[i];\n        }\n        \n        // Calculate cumulative distances from left\n        int cum[11];\n        cum[0] = 0;\n        for (int i = 0; i < 10; i++) {\n            cum[i + 1] = cum[i] + l[i];\n        }\n        \n        // Find meeting point\n        // Train 1 travels distance d1 = v1 * t\n        // Train 2 travels distance d2 = v2 * t\n        // d1 + d2 = total\n        // v1 * t + v2 * t = total\n        // t = total / (v1 + v2)\n        // d1 = v1 * total / (v1 + v2)\n        \n        double d1 = (double)v1 * total / (v1 + v2);\n        \n        // Find which section this is in\n        for (int i = 0; i < 10; i++) {\n            if (d1 <= cum[i + 1]) {\n                printf(\"%d\\n\", i + 1);\n                break;\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char line[256]; while (fgets(line, sizeof(line), stdin)) { int l[10];  &l[5], &l[6], &l[7], &l[8], &l[9], &v1, &v2); // Calculate total distance int total = 0; for (int i = 0; i < 10; i++) { total += l[i]; } // Calculate cumulative distances from left int cum[11]; cum[0] = 0; for (int i = 0; i < 10; i++) { cum[i + 1] = cum[i] + l[i]; } // Find meeting point // Train 1 travels distance d1 = v1 * t // Train 2 travels distance d2 = v2 * t // d1 + d2 = total // v1 * t +  (v1 + v2) // d1 = v1 * total / (v1 + v2) double d1 = (double)v1 * total / (v1 + v2); // Find which section this is  }"], "perturbed_original": ["#include<stdio.h> main(){ int i,ans; double l[10],km,k,v[2]; while(scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\",&l[0],&l[1],&l[2],&l[3],&l[4],&l[5],&l[6],&l[7],&l[8],&l[9],&v[0],&v[1])!=EOF){ km=l[0]+l[1]+l[2]+l[3]+l[4]+l[5]+l[6]+l[7]+l[8]+l[9]; k=km*v[0]/(v[0]+v[1]); for(i=0;i>=0;i++){ k-=l[i]; if(k<=0){ ans=i+1; i=-2; } } printf(\"%d\\n\",ans); } return 0; }"], "original_ll": -0.9417028427124023, "sampled_ll": -0.6957040429115295, "all_perturbed_sampled_ll": [-1.450127124786377], "all_perturbed_original_ll": [-0.9867459535598755], "perturbed_sampled_ll": -1.450127124786377, "perturbed_original_ll": -0.9867459535598755, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = null;\n\t\tint[] l = new int[10];\n\t\tint[] v = new int[2];\n\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tString[] data = line.trim().split(\",\");\n\t\t\tint distance = 0;\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tl[i] = Integer.parseInt(data[i]);\n\t\t\t\tdistance += l[i];\n\t\t\t}\n\t\t\tfor (int i = 0; i < 2; i++)\n\t\t\t\tv[i] = Integer.parseInt(data[i + 10]);\n\t\t\tdouble see = distance * ((double) v[0] / (v[1] + v[0]));\n\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif (see - l[i] > 0) {\n\t\t\t\t\tsee -= l[i];\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(i + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            line = line.trim();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            int[] lengths = new int[10];\n            for (int i = 0; i < 10; i++) {\n                lengths[i] = Integer.parseInt(parts[i].trim());\n            }\n            int v1 = Integer.parseInt(parts[10].trim());\n            int v2 = Integer.parseInt(parts[11].trim());\n            \n            // Calculate cumulative distances from station 0\n            int[] cumDist = new int[11];\n            cumDist[0] = 0;\n            for (int i = 0; i < 10; i++) {\n                cumDist[i + 1] = cumDist[i] + lengths[i];\n            }\n            int totalDistance = cumDist[10];\n            \n            // They meet when: distance1 + distance2 = totalDistance\n            // time is same for both: t = distance1 / v1 = distance2 / v2\n            // distance1 = v1 * t, distance2 = v2 * t\n            // v1 * t + v2 * t = totalDistance\n            // t = totalDistance / (v1 + v2)\n            // distance1 = v1 * totalDistance / (v1 + v2)\n            \n            double meetDistance = (double) v1 * totalDistance / (v1 + v2);\n            \n            // Find which section this distance falls into\n            int section = 1;\n            for (int i = 1; i <= 10; i++) {\n                if (meetDistance <= cumDist[i]) {\n                    section = i;\n                    break;\n                }\n            }\n            \n            System.out.println(section);\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while  (line.isEmpty()) break; String[] parts = line.split(\",\"); int[] lengths = new int[10]; for (int i = 0; i < 10; i++) { lengths[i] = Integer.parseInt(parts[i].trim()); } int v1 = Integer.parseInt(parts[10].trim()); int v2 = Integer.parseInt(parts[11].trim()); // Calculate cumulative distances from station 0 int[] cumDist = new int[11]; cumDist[0] = 0; for (int i = 0; i < 10; i++)  totalDistance = cumDist[10]; // They meet when: distance1 + distance2 = totalDistance // time is same for both: t = distance1 / v1 =  / (v1 + v2) // distance1 = v1 * totalDistance / (v1 + v2) double meetDistance = (double) v1 * totalDistance / (v1 + v2); // Find which section this distance falls into int section = 1; for (int i = 1; i  = i; break; } } System.out.println(section); } } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = null; int[] l = new int[10]; int[] v = new  = line.trim().split(\",\"); int distance = 0; for (int  Integer.parseInt(data[i]); distance += l[i]; } for (int i = 0; i < 2; i++) v[i] = Integer.parseInt(data[i + 10]); double see = distance * ((double) v[0] / (v[1] + v[0])); for (int i = 0; i  { see -= l[i]; } else { System.out.println(i + 1); break; } } } } }"], "original_ll": -0.6926061511039734, "sampled_ll": -0.7299249172210693, "all_perturbed_sampled_ll": [-1.423299789428711], "all_perturbed_original_ll": [-1.5710258483886719], "perturbed_sampled_ll": -1.423299789428711, "perturbed_original_ll": -1.5710258483886719, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,v1,v2=map(int,input().split(\",\"))\n        kyo=0\n        for i in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10:\n            kyo +=i\n        v=v1+v2\n        x=kyo/v\n        ans=v1*x\n        flag=0\n        for j in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10:\n            if ans>0:\n                ans -=j\n                flag +=1\n            elif ans==0:\n                print(flag)\n                break\n            elif ans<0:\n                print(flag)\n                break\n    except:break\n\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    parts = line.strip().split(',')\n    lengths = list(map(int, parts[:10]))\n    v1, v2 = int(parts[10]), int(parts[11])\n    \n    total_length = sum(lengths)\n    \n    # Time when trains meet\n    t_meet = total_length / (v1 + v2)\n    \n    # Distance traveled by train from section 1 side\n    d1 = v1 * t_meet\n    \n    # Find which section this distance falls into\n    cumulative = 0\n    for i in range(10):\n        cumulative += lengths[i]\n        if d1 <= cumulative:\n            print(i + 1)\n            break\n", "perturbed_sampled": ["import sys for line in sys.stdin: parts = line.strip().split(',') lengths = list(map(int, parts[:10])) v1, v2 = int(parts[10]), int(parts[11]) total_length = sum(lengths) # Time when trains meet t_meet = total_length / (v1 + v2) <extra_id_3>=<extra_id_4>print ( e<extra_id_5>i + 1):<extra_id_6>#<extra_id_7>a<extra_id_8>.<extra_id_9>#<extra_id_10>>=<extra_id_11>#<extra_id_12>if d2_meet ><extra_id_13>+<extra_id_14>: print(i+1)<extra_id_15>e): c1 if d1<extra_id_16>: sum_length = len<extra_id_17>length) = v1 * t_meet # Find  i in range(10): cumulative += lengths[i] if d1 <= cumulative: print(i + 1) break"], "perturbed_original": ["while True: try: l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,v1,v2=map(int,input().split(\",\")) kyo=0 for i in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10: kyo +=i v=v1+v2 x=kyo/v ans=v1*x flag=0 for j in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10: if ans>0: ans -=j  except:break"], "original_ll": -1.0209673643112183, "sampled_ll": -1.3985567092895508, "all_perturbed_sampled_ll": [-2.440890312194824], "all_perturbed_original_ll": [-1.5888065099716187], "perturbed_sampled_ll": -2.440890312194824, "perturbed_original_ll": -1.5888065099716187, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\ndouble gaiseki(double x0,double y0,double x1,double y1,double x2,double y2){\nreturn(x0-x1)*(y0-y1)-(x0-x2)*(y0-y2);\n}\nint main(){\ndouble x0,y0,x1,y1,x2,y2,x3,y3;\nwhile (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3)!=EOF){\nif (gaiseki(x0,y0,x1,y1,x3,y3)>=0&&gaiseki(x1,y1,x2,y2,x3,y3)>=0&&gaiseki(x2,y2,x0,y0,x3,y3)>=0){\nprintf(\"YES\\n\");\n}else{\nprintf(\"NO\\n\");\n}\n}\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\ndouble cross(double ax, double ay, double bx, double by, double cx, double cy) {\n    return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);\n}\n\nint main() {\n    double xa, ya, xb, yb, xc, yc, xd, yd;\n    \n    while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\", \n                 &xa, &ya, &xb, &yb, &xc, &yc, &xd, &yd) == 8) {\n        \n        double c1 = cross(xa, ya, xb, yb, xc, yc);\n        double c2 = cross(xb, yb, xc, yc, xd, yd);\n        double c3 = cross(xc, yc, xd, yd, xa, ya);\n        double c4 = cross(xd, yd, xa, ya, xb, yb);\n        \n        if ((c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0) ||\n            (c1 < 0 && c2 < 0 && c3 < 0 && c4 < 0)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> double cross(double ax, double ay, double bx, double by, double cx, double cy) { return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);  yc, xd, yd; while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\", &xa, &ya, &xb, &yb, &xc, &yc, &xd, &yd) == 8) { double c1 = cross(xa, ya, xb, yb, xc, yc); double c2 = cross(xb, yb, xc, yc, xd, yd); double c3 =  yd, xa, ya, xb, yb); if ((c1 > 0 && c2 > 0 &&  && c4 < 0)) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> double gaiseki(double x0,double y0,double x1,double y1,double x2,double y2){ return(x0-x1)*(y0-y1)-(x0-x2)*(y0-y2); } int main(){ double x0,y0,x1,y1,x2,y2,x3,y3; while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3)!=EOF){ if (gaiseki(x0,y0,x1,y1,x3,y3)>=0&&gaiseki(x1,y1,x2,y2,x3,y3)>=0&&gaiseki(x2,y2,x0,y0,x3,y3)>=0){ printf(\"YES\\n\"); }else{ printf(\"NO\\n\"); } } return 0; }"], "original_ll": -0.752171516418457, "sampled_ll": -0.4255961775779724, "all_perturbed_sampled_ll": [-1.3007172346115112], "all_perturbed_original_ll": [-0.7673880457878113], "perturbed_sampled_ll": -1.3007172346115112, "perturbed_original_ll": -0.7673880457878113, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;class Main{public static void main(String[]z){double[]b=new double[8];for(Scanner s=new Scanner(System.in);s.hasNext();System.out.println((f(b[0],b[1],b[4],b[5],b[6],b[7])>0&&f(b[4],b[5],b[0],b[1],b[2],b[3])>0&&f(b[2],b[3],b[6],b[7],b[0],b[1])>0&&f(b[6],b[7],b[2],b[3],b[4],b[5])>0)||(f(b[0],b[1],b[4],b[5],b[6],b[7])<0&&f(b[4],b[5],b[0],b[1],b[2],b[3])<0&&f(b[2],b[3],b[6],b[7],b[0],b[1])<0&&f(b[6],b[7],b[2],b[3],b[4],b[5])<0)?\"YES\":\"NO\")){z=s.next().split(\",\");for(int i=0;i<8;++i)b[i]=new Double(z[i]);}}static double f(double a,double b,double c,double d,double e,double f){return ((d-b)*e+(a-c)*f+c*b-a*d);}}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            \n            double xa = Double.parseDouble(parts[0]);\n            double ya = Double.parseDouble(parts[1]);\n            double xb = Double.parseDouble(parts[2]);\n            double yb = Double.parseDouble(parts[3]);\n            double xc = Double.parseDouble(parts[4]);\n            double yc = Double.parseDouble(parts[5]);\n            double xd = Double.parseDouble(parts[6]);\n            double yd = Double.parseDouble(parts[7]);\n            \n            double cross1 = crossProduct(xa, ya, xb, yb, xc, yc);\n            double cross2 = crossProduct(xb, yb, xc, yc, xd, yd);\n            double cross3 = crossProduct(xc, yc, xd, yd, xa, ya);\n            double cross4 = crossProduct(xd, yd, xa, ya, xb, yb);\n            \n            boolean allPositive = cross1 > 0 && cross2 > 0 && cross3 > 0 && cross4 > 0;\n            boolean allNegative = cross1 < 0 && cross2 < 0 && cross3 < 0 && cross4 < 0;\n            \n            if (allPositive || allNegative) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static double crossProduct(double x1, double y1, double x2, double y2, double x3, double y3) {\n        double v1x = x2 - x1;\n        double v1y = y2 - y1;\n        double v2x = x3 - x2;\n        double v2y = y3 - y2;\n        return v1x * v2y - v1y * v2x;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  sc.nextLine(); String[] parts = line.split(\",\"); double xa =  yb = Double.parseDouble(parts[3]); double xc = Double.parseDouble(parts[4]); double yc = Double.parseDouble(parts[5]); double xd = Double.parseDouble(parts[6]); double yd = Double.parseDouble(parts[7]); double cross1 = crossProduct(xa, ya, xb, yb, xc, yc); double cross2 = crossProduct(xb, yb, xc, yc, xd, yd); double cross3 = crossProduct(xc, yc, xd, yd, xa, ya); double cross4  cross1 > 0 && cross2 > 0  = cross1 < 0 && cross2 < 0 && cross3 < 0 && cross4 < 0; if (allPositive || allNegative) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); } private static double crossProduct(double x1, double y1, double x2, double y2, double x3, double y3) { double v1x = x2 - x1; double v1y = y2 - y1; double v2x = x3 -  v2y - v1y * v2x; } }"], "perturbed_original": ["import java.util.*;class Main{public static void main(String[]z){double[]b=new double[8];for(Scanner s=new Scanner(System.in);s.hasNext();System.out.println((f(b[0],b[1],b[4],b[5],b[6],b[7])>0&&f(b[4],b[5],b[0],b[1],b[2],b[3])>0&&f(b[2],b[3],b[6],b[7],b[0],b[1])>0&&f(b[6],b[7],b[2],b[3],b[4],b[5])>0)||(f(b[0],b[1],b[4],b[5],b[6],b[7])<0&&f(b[4],b[5],b[0],b[1],b[2],b[3])<0&&f(b[2],b[3],b[6],b[7],b[0],b[1])<0&&f(b[6],b[7],b[2],b[3],b[4],b[5])<0)?\"YES\":\"NO\")){z=s.next().split(\",\");for(int i=0;i<8;++i)b[i]=new Double(z[i]);}}static double f(double a,double b,double c,double d,double e,double f){return ((d-b)*e+(a-c)*f+c*b-a*d);}}"], "original_ll": -0.7968534231185913, "sampled_ll": -0.2911105155944824, "all_perturbed_sampled_ll": [-1.0890476703643799], "all_perturbed_original_ll": [-0.7968534231185913], "perturbed_sampled_ll": -1.0890476703643799, "perturbed_original_ll": -0.7968534231185913, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from __future__ import (division, absolute_import, print_function,\n                        unicode_literals)\nfrom sys import stdin\nfrom collections import namedtuple\nPoint = namedtuple('Point', 'x y')\n\ndef make_test(p1, p2):\n    if p1.x == p2.x:\n        gradient = p1.x\n        return lambda p: gradient > p.x\n    gradient = (p1.y - p2.y) / (p1.x - p2.x)\n    y_intercept = p1.y - gradient * p1.x\n    return lambda p: gradient * p.x + y_intercept > p.y\n\nfor line in stdin:\n    it = (float(s) for s in line.split(','))\n    A, B, C, D = (Point(next(it), next(it)) for _ in xrange(4))\n\n    f = make_test(A, C)\n    g = make_test(B, D)\n    if f(B) == f(D) or g(A) == g(C):\n        print('NO')\n    else:\n        print('YES')", "sampled": "import sys\n\ndef cross_product(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef is_convex(points):\n    n = len(points)\n    sign = None\n    \n    for i in range(n):\n        o = points[i]\n        a = points[(i + 1) % n]\n        b = points[(i + 2) % n]\n        \n        cp = cross_product(o, a, b)\n        \n        if cp != 0:\n            if sign is None:\n                sign = cp > 0\n            elif (cp > 0) != sign:\n                return False\n    \n    return True\n\nfor line in sys.stdin:\n    coords = list(map(float, line.strip().split(',')))\n    points = [(coords[i], coords[i+1]) for i in range(0, 8, 2)]\n    \n    if is_convex(points):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys def cross_product(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1])  = None for i in range(n): o = points[i] a = points[(i +  cp = cross_product(o, a, b) if cp  0 elif (cp > 0) != sign: return False return True for line in sys.stdin: coords = list(map(float, line.strip().split(','))) points = [(coords[i], coords[i+1]) for i in range(0, 8, 2)] if is_convex(points): print(\"YES\") else: print(\"NO\")"], "perturbed_original": [" y') def make_test(p1, p2): if p1.x ==  gradient = (p1.y - p2.y) / (p1.x - p2.x) y_intercept = p1.y - gradient * p1.x return lambda p: gradient * p.x + y_intercept > p.y for line in stdin: it = (float(s) for s in line.split(',')) A, B, C, D = (Point(next(it), next(it)) for _ in xrange(4)) f = make_test(A, C) g = make_test(B, D) if f(B) == f(D) or g(A) == g(C): print('NO') else: print('YES')"], "original_ll": -1.1101133823394775, "sampled_ll": -0.638117790222168, "all_perturbed_sampled_ll": [-1.7564586400985718], "all_perturbed_original_ll": [-1.7573440074920654], "perturbed_sampled_ll": -1.7564586400985718, "perturbed_original_ll": -1.7573440074920654, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\n#define X 8\n#define Y 8\n#define L 3\n#define M 2\n#define S 1\n\n\nint main(void)\n{\n        char ppr[X][Y];/*\u7d19*/\n        int x = 0, y = 0;\n        int i = 0, j = 0;\n        int size = 0;\n        int count = 0;\n        int max = 0;\n        int farst = 0;\n        int k = 0;\n        int h = 0;\n        char ans[4][2];\n\n        for(i = 0; i < X; i++)\n        {\n                for(j = 0;j < Y; j++)\n                {\n                        ppr[i][j] = '0';\n                }\n        }\n\n        for(i = 0; i < 4; i++)\n        {\n                for(j = 0;j < 2; j++)\n                {\n                        ans[i][j] = '0';\n                }\n        }\n\n        while(scanf(\"%s\", ppr[0]) != EOF)\n        {\n                for(i = 1; i < X; i++)\n                {\n                        scanf(\"%s\", ppr[i]);\n                }\n                for(i = 0; i < X; i++)\n                {\n                        for(j = 0; j < Y; j++)\n                        {\n                                if( ppr[i][j] == '1')\n                                {\n                                        ans[k][0] = j;\n                                        ans[k][1] = i;\n                                        k++;\n                                }\n                        }\n                }\n/*\n                for(i = 0;i < 4; i++)\n                {\n                        printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n                }\n*/\n                x = ans[0][0];\n                y = ans[0][1];\n                ans[0][0] -= x; ans[0][1] -= y;\n                ans[1][0] -= x; ans[1][1] -= y;\n                ans[2][0] -= x; ans[2][1] -= y;\n                ans[3][0] -= x; ans[3][1] -= y;\n                /*\n                for(i = 0;i < 4; i++)\n                {\n                        printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n                }*/\n\n                if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                   ans[1][0] ==  0 && ans[1][1] == 1 &&\n                   ans[2][0] ==  1 && ans[2][1] == 0 &&\n                   ans[3][0] ==  1 && ans[3][1] == 1 )\n                {\n                        printf(\"A\\n\");\n                }\n                else if(ans[0][0] == 0 &&ans[0][1] == 0 &&\n                   ans[1][0] ==  1 && ans[1][1] == 0 &&\n                   ans[2][0] ==  2 && ans[2][1] == 0 &&\n                   ans[3][0] ==  3 && ans[3][1] == 0 )\n                {\n                        printf(\"B\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                        ans[1][0] ==  0 && ans[1][1] == 1 &&\n                        ans[2][0] ==  0 && ans[2][1] == 2 &&\n                        ans[3][0] ==  0 && ans[3][1] == 3 )\n                {\n                        printf(\"C\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 1 &&\n                        ans[1][0] ==  1 && ans[1][1] == 0 &&\n                        ans[2][0] ==  1 && ans[2][1] == 1 &&\n                        ans[3][0] ==  2 && ans[3][1] == 0 )\n                {\n                        printf(\"D\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                        ans[1][0] ==  0 && ans[1][1] == 1 &&\n                        ans[2][0] ==  1 && ans[2][1] == 1 &&\n                        ans[3][0] ==  1 && ans[3][1] == 2 )\n                {\n                        printf(\"E\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                        ans[1][0] ==  1 && ans[1][1] == 0 &&\n                        ans[2][0] ==  1 && ans[2][1] == 1 &&\n                        ans[3][0] ==  2 && ans[3][1] == 1 )\n                {\n                        printf(\"F\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 1 &&\n                        ans[1][0] ==  0 && ans[1][1] == 2 &&\n                        ans[2][0] ==  1 && ans[2][1] == 0 &&\n                        ans[3][0] ==  1 && ans[3][1] == 1 )\n                {\n                        printf(\"G\\n\");\n                }\n\n\n        }\n\n        return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char grid[8][9];\n    \n    while(scanf(\"%s\", grid[0]) != EOF) {\n        for(int i = 1; i < 8; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        // Extract the shape pattern\n        int minR = 8, maxR = -1, minC = 8, maxC = -1;\n        for(int i = 0; i < 8; i++) {\n            for(int j = 0; j < 8; j++) {\n                if(grid[i][j] == '1') {\n                    if(i < minR) minR = i;\n                    if(i > maxR) maxR = i;\n                    if(j < minC) minC = j;\n                    if(j > maxC) maxC = j;\n                }\n            }\n        }\n        \n        int height = maxR - minR + 1;\n        int width = maxC - minC + 1;\n        \n        // Extract normalized pattern\n        int pattern[4][4] = {0};\n        for(int i = minR; i <= maxR; i++) {\n            for(int j = minC; j <= maxC; j++) {\n                if(grid[i][j] == '1') {\n                    pattern[i-minR][j-minC] = 1;\n                }\n            }\n        }\n        \n        // Check each shape\n        char result = '?';\n        \n        // Shape A: 2x2 square\n        if(height == 2 && width == 2 && \n           pattern[0][0] && pattern[0][1] && \n           pattern[1][0] && pattern[1][1]) {\n            result = 'A';\n        }\n        // Shape B: 1x4 horizontal\n        else if(height == 1 && width == 4 && \n                pattern[0][0] && pattern[0][1] && \n                pattern[0][2] && pattern[0][3]) {\n            result = 'B';\n        }\n        // Shape C: 4x1 vertical\n        else if(height == 4 && width == 1 && \n                pattern[0][0] && pattern[1][0] && \n                pattern[2][0] && pattern[3][0]) {\n            result = 'C';\n        }\n        // Shape D: 3x1 vertical\n        else if(height == 3 && width == 1 && \n                pattern[0][0] && pattern[1][0] && \n                pattern[2][0]) {\n            result = 'D';\n        }\n        // Shape E: zigzag\n        else if(height == 2 && width == 3 && \n                pattern[0][0] && pattern[0][1] && !pattern[0][2] &&\n                !pattern[1][0] && pattern[1][1] && pattern[1][2]) {\n            result = 'E';\n        }\n        // Shape F: reverse zigzag\n        else if(height == 2 && width == 3 && \n                !pattern[0][0] && pattern[0][1] && pattern[0][2] &&\n                pattern[1][0] && pattern[1][1] && !pattern[1][2]) {\n            result = 'F';\n        }\n        // Shape G: L-shape\n        else if(height == 2 && width == 2 && \n                pattern[0][0] && !pattern[0][1] && \n                pattern[1][0] && pattern[1][1]) {\n            result = 'G';\n        }\n        \n        printf(\"%c\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char grid[8][9]; while(scanf(\"%s\", grid[0]) != EOF) { for(int i = 1; i < 8; i++) { scanf(\"%s\",  8, maxR = -1, minC = 8, maxC = -1; for(int i = 0; i < 8; i++) { for(int j = 0; j < 8; j++) { if(grid[i][j] == '1') { if(i < minR) minR = i; if(i > maxR) maxR  maxC) maxC = j; } } } int height = maxR - minR + 1; int width = maxC - minC + 1; // Extract  i <= maxR; i++) { for(int j = minC; j <= maxC; j++) { if(grid[i][j] == '1')  shape char result = '?'; // Shape A: 2x2 square if(height == 2 && width == 2 &&  'A'; } // Shape B: 1x4 horizontal else if(height == 1 && width == 4 && pattern[0][0] && pattern[0][1] && pattern[0][2] && pattern[0][3]) { result = 'B'; } // Shape C:  && pattern[0][0] && pattern[1][0] && pattern[2][0] && pattern[3][0]) { result = 'C'; } // Shape D: 3x1 vertical else if(height == 3 && width == 1 && pattern[0][0] && pattern[1][0] && pattern[2][0]) { result =  !pattern[0][2] && !pattern[1][0] && pattern[1][1]  reverse zigzag else if(height ==  pattern[0][2] && pattern[1][0] && pattern[1][1] && !pattern[1][2]) { result = 'F'; } // Shape G: L-shape else if(height == 2 && width == 2 && pattern[0][0] && !pattern[0][1] && pattern[1][0] && pattern[1][1]) { result = 'G'; } printf(\"%c\\n\", result); } return 0; }"], "perturbed_original": ["#include<stdio.h> #define X 8 #define Y 8 #define L 3 #define M 2 #define S 1 int main(void) { char ppr[X][Y];/*\u7d19*/ int x = 0, y = 0; int i = 0, j = 0; int size = 0;  = 0; int k = 0; int h  ppr[i][j] = '0'; } } for(i = 0; i < 4; i++) { for(j = 0;j < 2; j++) { ans[i][j] = '0'; } } while(scanf(\"%s\", ppr[0]) != EOF) { for(i = 1; i < X; i++) { scanf(\"%s\", ppr[i]); } for(i  j < Y; j++) { if( ppr[i][j] == '1') { ans[k][0] = j; ans[k][1] = i; k++; } } } /* for(i = 0;i < 4; i++) { printf(\"%d %d\\n\",ans[i][0],ans[i][1]); } */ x = ans[0][0]; y =  ans[1][1] -= y; ans[2][0] -= x; ans[2][1] -=  0;i < 4; i++) { printf(\"%d %d\\n\",ans[i][0],ans[i][1]); }*/ if(ans[0][0] == 0 && ans[0][1] == 0 && ans[1][0] == 0 &&  0 && ans[3][0] == 1 && ans[3][1] == 1 ) { printf(\"A\\n\"); } else if(ans[0][0] == 0 &&ans[0][1] == 0 && ans[1][0] == 1 &&  0 && ans[3][0]  == 0 && ans[2][1] == 2 && ans[3][0] == 0 && ans[3][1] == 3 ) { printf(\"C\\n\"); } else if(ans[0][0] == 0 && ans[0][1] == 1 && ans[1][0] == 1 && ans[1][1] == 0 && ans[2][0] == 1 && ans[2][1] == 1 && ans[3][0] == 2 && ans[3][1] == 0 ) { printf(\"D\\n\"); } else if(ans[0][0] == 0 && ans[0][1] == 0 && ans[1][0] == 0 && ans[1][1] == 1 && ans[2][0] == 1 && ans[2][1] == 1 && ans[3][0] == 1 && ans[3][1] == 2 ) { printf(\"E\\n\"); } else if(ans[0][0] == 0 && ans[0][1] == 0 &&  1 && ans[2][1] ==  { printf(\"F\\n\"); } else if(ans[0][0] == 0 && ans[0][1] == 1 && ans[1][0] == 0 && ans[1][1] == 2 && ans[2][0] == 1 && ans[2][1] == 0 && ans[3][0] == 1 && ans[3][1] == 1 ) { printf(\"G\\n\"); } } return 0; }"], "original_ll": -0.4194045662879944, "sampled_ll": -0.4454434812068939, "all_perturbed_sampled_ll": [-1.27274489402771], "all_perturbed_original_ll": [-0.7949258089065552], "perturbed_sampled_ll": -1.27274489402771, "perturbed_original_ll": -0.7949258089065552, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new java.util.Scanner(System.in);\n\n\n\tpublic static void main(String[] args) {\n\n\t\tint[][] num = new int[15][15];\n\t\tString str = \"\";\n\n\t\twhile (sc.hasNextLine()) {\n\t\t\t// ?????????\n\t\t\t//syokika(num);\n\t\t\tfor (int i = 0; i < 15; i++) {\n\t\t\t\tfor (int j = 0; j < 15; j++) {\n\t\t\t\t\tnum[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????\u00a8????????????????\u00b4?\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tstr = sc.next();\n\t\t\t\tString[] st = str.split(\"\");\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tnum[i][j] = Integer.parseInt(st[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????????\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (num[i][j] == 1 && num[i][j + 1] == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"A\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i + 1][j] == 1 && num[i + 2][j] == 1 && num[i + 3][j] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"B\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i][j + 3] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"C\");\n\t\t\t\t\t} else if (num[i][j + 1] == 1 && num[i + 1][j] == 1 && num[i][j + 1] == 1 && num[i + 2][j] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"D\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i + 1][j + 1] == 1\n\t\t\t\t\t\t\t&& num[i + 1][j + 2] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"E\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1\n\t\t\t\t\t\t\t&& num[i + 2][j + 1] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"F\");\n\t\t\t\t\t} else if (num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i + 1][j] == 1\n\t\t\t\t\t\t\t&& num[i + 1][j + 1] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"G\");\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String[][] grid = new String[8][8];\n            List<int[]> points = new ArrayList<>();\n            \n            for (int i = 0; i < 8; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < 8; j++) {\n                    grid[i][j] = String.valueOf(line.charAt(j));\n                    if (line.charAt(j) == '1') {\n                        points.add(new int[]{i, j});\n                    }\n                }\n            }\n            \n            if (points.size() == 0) break;\n            \n            // Normalize the shape\n            int minRow = Integer.MAX_VALUE;\n            int minCol = Integer.MAX_VALUE;\n            for (int[] p : points) {\n                minRow = Math.min(minRow, p[0]);\n                minCol = Math.min(minCol, p[1]);\n            }\n            \n            Set<String> normalized = new HashSet<>();\n            for (int[] p : points) {\n                normalized.add((p[0] - minRow) + \",\" + (p[1] - minCol));\n            }\n            \n            String result = identifyShape(normalized);\n            System.out.println(result);\n            \n            if (sc.hasNextLine()) {\n                String blank = sc.nextLine();\n            }\n        }\n        sc.close();\n    }\n    \n    static String identifyShape(Set<String> shape) {\n        // Define all shapes\n        Map<String, Set<String>> shapes = new HashMap<>();\n        \n        // A: 2x2 square\n        Set<String> a = new HashSet<>();\n        a.add(\"0,0\"); a.add(\"0,1\"); a.add(\"1,0\"); a.add(\"1,1\");\n        shapes.put(\"A\", a);\n        \n        // B: vertical line\n        Set<String> b = new HashSet<>();\n        b.add(\"0,0\"); b.add(\"1,0\"); b.add(\"2,0\"); b.add(\"3,0\");\n        shapes.put(\"B\", b);\n        \n        // C: horizontal line\n        Set<String> c = new HashSet<>();\n        c.add(\"0,0\"); c.add(\"0,1\"); c.add(\"0,2\"); c.add(\"0,3\");\n        shapes.put(\"C\", c);\n        \n        // D: L shape\n        Set<String> d = new HashSet<>();\n        d.add(\"0,0\"); d.add(\"1,0\"); d.add(\"2,0\"); d.add(\"2,1\");\n        shapes.put(\"D\", d);\n        \n        // E: Z shape\n        Set<String> e = new HashSet<>();\n        e.add(\"0,0\"); e.add(\"0,1\"); e.add(\"1,1\"); e.add(\"1,2\");\n        shapes.put(\"E\", e);\n        \n        // F: T shape\n        Set<String> f = new HashSet<>();\n        f.add(\"0,0\"); f.add(\"0,1\"); f.add(\"0,2\"); f.add(\"1,1\");\n        shapes.put(\"F\", f);\n        \n        // G: small L\n        Set<String> g = new HashSet<>();\n        g.add(\"0,0\"); g.add(\"1,0\"); g.add(\"1,1\");\n        shapes.put(\"G\", g);\n        \n        // Try all rotations and reflections\n        for (String key : shapes.keySet()) {\n            Set<String> pattern = shapes.get(key);\n            if (matchesWithTransformations(shape, pattern)) {\n                return key;\n            }\n        }\n        \n        return \"?\";\n    }\n    \n    static boolean matchesWithTransformations(Set<String> shape, Set<String> pattern) {\n        Set<String> current = pattern;\n        \n        for (int rotation = 0; rotation < 4; rotation++) {\n            if (matches(shape, current)) return true;\n            Set<String> reflected = reflect(current);\n            if (matches(shape, reflected)) return true;\n            current = rotate90(current);\n        }\n        \n        return false;\n    }\n    \n    static boolean matches(Set<String> shape, Set<String> pattern) {\n        Set<String> normalized = normalize(pattern);\n        return shape.equals(normalized);\n    }\n    \n    static Set<String> normalize(Set<String> pattern) {\n        int minRow = Integer.MAX_VALUE;\n        int minCol = Integer.MAX_VALUE;\n        \n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            minRow = Math.min(minRow, r);\n            minCol = Math.min(minCol, c);\n        }\n        \n        Set<String> result = new HashSet<>();\n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            result.add((r - minRow) + \",\" + (c - minCol));\n        }\n        \n        return result;\n    }\n    \n    static Set<String> rotate90(Set<String> pattern) {\n        Set<String> result = new HashSet<>();\n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            result.add(c + \",\" + (-r));\n        }\n        return normalize(result);\n    }\n    \n    static Set<String> reflect(Set<String> pattern) {\n        Set<String> result = new HashSet<>();\n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            result.add(r + \",\" + (-c));\n        }\n        return normalize(result);\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args)  grid = new String[8][8]; List<int[]> points = new ArrayList<>(); for (int  =  { grid[i][j] = String.valueOf(line.charAt(j)); if (line.charAt(j) == '1') { points.add(new int[]{i, j}); } } } if (points.size() == 0) break; // Normalize the shape int minRow = Integer.MAX_VALUE; int minCol = Integer.MAX_VALUE; for (int[] p : points) { minRow = Math.min(minRow, p[0]); minCol = Math.min(minCol, p[1]); } Set<String> normalized = new HashSet<>(); for (int[] p : points) { normalized.add((p[0] - minRow) + \",\" + (p[1] - minCol)); } String result = identifyShape(normalized); System.out.println(result); if (sc.hasNextLine()) { String blank  { // Define all shapes Map<String, Set<String>> shapes = new HashMap<>(); // A: 2x2 square Set<String> a = new HashSet<>(); a.add(\"0,0\"); a.add(\"0,1\"); a.add(\"1,0\"); a.add(\"1,1\"); shapes.put(\"A\", a); // B: vertical line Set<String> b =  horizontal line Set<String> c =  L shape Set<String> d =  Z   small L Set<String> g = new HashSet<>(); g.add(\"0,0\"); g.add(\"1,0\"); g.add(\"1,1\"); shapes.put(\"G\", g); // Try all   } return \"?\"; } static boolean matchesWithTransformations(Set<String> shape, Set<String> pattern) { Set<String> current = pattern; for (int rotation = 0; rotation < 4; rotation++) { if (matches(shape, current)) return true; Set<String> reflected  pattern) { Set<String> normalized = normalize(pattern); return shape.equals(normalized); } static Set<String> normalize(Set<String> pattern) { int minRow = Integer.MAX_VALUE; int minCol = Integer.MAX_VALUE; for (String p : pattern) { String[] parts = p.split(\",\"); int r = Integer.parseInt(parts[0]); int c = Integer.parseInt(parts[1]); minRow = Math.min(minRow, r); minCol = Math.min(minCol, c); } Set<String> result = new HashSet<>(); for (String p : pattern) { String[] parts = p.split(\",\"); int r = Integer.parseInt(parts[0]); int c = Integer.parseInt(parts[1]); result.add((r - minRow) + \",\" + (c - minCol)); } return result; } static Set<String> rotate90(Set<String> pattern) { Set<String> result = new HashSet<>(); for (String p : pattern) { String[] parts = p.split(\",\"); int r = Integer.parseInt(parts[0]); int c = Integer.parseInt(parts[1]); result.add(c + \",\" + (-r)); } return normalize(result); } static Set<String> reflect(Set<String> pattern) { Set<String> result = new HashSet<>(); for (String p : pattern) { String[] parts = p.split(\",\"); int r = Integer.parseInt(parts[0]); int c = Integer.parseInt(parts[1]); result.add(r + \",\" + (-c)); } return normalize(result); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { static  { int[][] num = new int[15][15]; String str = \"\"; while (sc.hasNextLine()) { // ????????? //syokika(num); for (int i =  0; j < 15; j++) { num[i][j] = 0; } } // ???????????\u00a8????????????????\u00b4? for (int i = 0; i < 8; i++) { str = sc.next();  < 8; j++) { num[i][j] = Integer.parseInt(st[j]); } } // ???????????? for (int i = 0; i < 8; i++) { for (int j = 0; j < 8;  == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1) { System.out.println(\"A\"); } else if (num[i][j] == 1 && num[i +  num[i + 3][j] == 1) { System.out.println(\"B\"); } else if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i][j +  2][j] == 1) { System.out.println(\"D\"); } else if (num[i][j] == 1 && num[i][j + 1] == 1 &&  1][j + 2] == 1) { System.out.println(\"E\"); } else if (num[i][j] == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1 && num[i + 2][j + 1] == 1) { System.out.println(\"F\"); } else if (num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1) { System.out.println(\"G\"); } } } } } }"], "original_ll": -0.5062336325645447, "sampled_ll": -0.4144364297389984, "all_perturbed_sampled_ll": [-1.0350334644317627], "all_perturbed_original_ll": [-1.0530755519866943], "perturbed_sampled_ll": -1.0350334644317627, "perturbed_original_ll": -1.0530755519866943, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys;import re\nfor s in sys.stdin.read().split('\\n\\n'):print 'BCD F GAE'[len(re.findall('1.*1',s.replace('\\n',''))[0])%12-3]", "sampled": "import sys\n\ndef normalize_shape(points):\n    if not points:\n        return []\n    min_r = min(p[0] for p in points)\n    min_c = min(p[1] for p in points)\n    normalized = sorted([(r - min_r, c - min_c) for r, c in points])\n    return normalized\n\ndef get_shape_signature(grid):\n    points = []\n    for r in range(8):\n        for c in range(8):\n            if grid[r][c] == '1':\n                points.append((r, c))\n    return normalize_shape(points)\n\n# Define the shapes A-G\nshapes = {\n    'A': [(0, 0), (0, 1), (1, 0), (1, 1)],\n    'B': [(0, 0), (0, 1), (0, 2), (0, 3)],\n    'C': [(0, 0), (0, 1), (0, 2), (0, 3)],\n    'D': [(0, 0), (1, 0), (1, 1), (2, 1)],\n    'E': [(0, 0), (0, 1), (1, 0), (1, 1)],\n    'F': [(0, 1), (1, 0), (1, 1), (2, 0)],\n    'G': [(0, 0), (0, 1), (0, 2), (1, 1)]\n}\n\n# Generate all rotations and reflections for each shape\ndef get_all_orientations(points):\n    orientations = set()\n    pts = points[:]\n    \n    for _ in range(4):  # 4 rotations\n        orientations.add(tuple(normalize_shape(pts)))\n        # Rotate 90 degrees clockwise: (r, c) -> (c, -r)\n        pts = [(c, -r) for r, c in pts]\n    \n    # Mirror horizontally\n    pts = [(r, -c) for r, c in points]\n    for _ in range(4):  # 4 rotations of mirrored\n        orientations.add(tuple(normalize_shape(pts)))\n        pts = [(c, -r) for r, c in pts]\n    \n    return orientations\n\nshape_orientations = {}\nfor name, shape in shapes.items():\n    shape_orientations[name] = get_all_orientations(shape)\n\ndef identify_shape(grid):\n    sig = tuple(get_shape_signature(grid))\n    \n    for name, orientations in shape_orientations.items():\n        if sig in orientations:\n            return name\n    \n    return None\n\n# Read input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.rstrip('\\n'))\n\n# Process datasets\ni = 0\nwhile i < len(lines):\n    grid = []\n    while i < len(lines) and lines[i] != '':\n        grid.append(lines[i])\n        i += 1\n    \n    if len(grid) == 8:\n        result = identify_shape(grid)\n        print(result)\n    \n    i += 1  # Skip empty line\n", "perturbed_sampled": ["import sys  for p in points) min_c = min(p[1] for p in points) normalized = sorted([(r - min_r, c - min_c) for r, c in points])  range(8): for c in range(8): if grid[r][c] == '1': points.append((r, c)) return normalize_shape(points) # Define the shapes A-G shapes = { 'A': [(0, 0), (0, 1), (1, 0), (1, 1)], 'B': [(0, 0), (0, 1), (0, 2), (0, 3)], 'C': [(0, 0), (0, 1), (0, 2), (0, 3)], 'D': [(0, 0), (1, 0), (1, 1), (2, 1)], 'E': [(0, 0), (0, 1), (1, 0), (1,  'G': [(0, 0), (0,  and reflections for each shape def get_all_orientations(points): orientations = set() pts = points[:] for _ in range(4): # 4 rotations orientations.add(tuple(normalize_shape(pts))) # Rotate 90 degrees clockwise: (r, c) -> (c,  # Mirror horizontally pts = [(r, -c)  4 rotations of mirrored orientations.add(tuple(normalize_shape(pts))) pts = [(c, -r) for r, c in pts] return orientations shape_orientations = {} for name, shape in shapes.items(): shape_orientations[name] = get_all_orientations(shape) def identify_shape(grid): sig = tuple(get_shape_signature(grid)) for name, orientations in shape_orientations.items(): if sig in orientations: return name return None # Read input lines = [] for line in sys.stdin: lines.append(line.rstrip('\\n')) # Process datasets i = 0 while i < len(lines): grid = [] while i < len(lines)  # Skip empty line"], "perturbed_original": ["import sys;import re for s in sys.stdin.read().split('\\n\\n'):print 'BCD F GAE'[len(re.findall('1.*1',s.replace('\\n',''))[0])%12-3]"], "original_ll": -3.175971746444702, "sampled_ll": -0.7605741024017334, "all_perturbed_sampled_ll": [-1.593017578125], "all_perturbed_original_ll": [-3.3396451473236084], "perturbed_sampled_ll": -1.593017578125, "perturbed_original_ll": -3.3396451473236084, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n  int tate[8][4],yoko[8][3];\n  int h,i,j,k,x=0,y=0;\n  for(i=0;i<9;i++){\n    if(i%2==0){\n      scanf(\"%1d%1d%1d%1d\",&yoko[i][0],&yoko[i][1],&yoko[i][2],&yoko[i][3]);\n      yoko[i][4]=0;   \n    }else{  \n      scanf(\"%1d%1d%1d%1d%1d\",&tate[i][0],&tate[i][1],&tate[i][2],&tate[i][3],&tate[i][4]);\n      tate[i][5]=0;\n    }\n  }\n\n  //printf(\"----------------------------------------\\n\");\n       for(k=0;k<=9;k++){\n       if(k%2==0){\n\t //printf(\"%d%d%d%d%d\\n\",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]);\n       }else{\n\t //printf(\"%d%d%d%d%d%d\\n\",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]);\n       }\n       }\n  \n\n \n  int sl=1;\n  printf(\"R\");\n  do{\n   \n    switch(sl){\n    case 1:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n\n      if(tate[y-1][x+1]==1&&y>0){\n\tx++;\n\ty--;\n\tsl=4;\n      }else if(yoko[y][x+1]==1&&x<3){\n\t//printf(\"ok\\n\");\n\tx++;\n\tsl=1;\n\t//printf(\"s=%d\",s);\n      }else if(tate[y+1][x+1]==1&&y<8){\n\tx++;\n\ty++;\n\t\n\tsl=2;\n      }\n      // printf(\"tate74=%d\\n\",tate[7][4]);\n\n      break;\n\n    case 2:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"%d %d\\n\",x+1,y+2);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n      if(yoko[y+1][x]==1&&x<3){\n\ty++;sl=1;\n      }else if(tate[y+2][x]==1&&y<8){\n\ty=y+2;sl=2;\n      }else if(yoko[y+1][x-1]==1&&x>0){\n\ty++;\n\tx--;\n\tsl=3;\n      }\n      break;\n\n\n    case 3:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n       if(tate[y+1][x]==1&&y<8){\n\tsl=2;y++;\n      }else if(yoko[y][x-1]==1&&x>0){\n\tx--;sl=3;\n      }else if(tate[y-1][x]==1&&y>0){\n\ty--;sl=4;\n      }\n      break;\n\n\n    case 4:\n      // printf(\"x=%d:y=%d\\n\",x,y);\n      if(yoko[y-1][x-1]==1&&x>0){\n\tx--;y--;sl=3;\n      }else if(tate[y-2][x]==1&&y>0){\n\ty=y-2;sl=4;\n      }else if(yoko[y-1][x]==1&&x<3){\n\ty--;sl=1;\n      }\n      break;\n\n\n    }\n    //printf(\"sl=%d\\n\",sl);\n    if(sl==1)printf(\"R\");\n    if(sl==2)printf(\"D\");\n    if(sl==3)printf(\"L\");\n    if(sl==4)printf(\"U\");\n    //printf(\"tate74=%d\\n\",tate[7][4]);\n    //printf(\"\\n\");\n   \n   \n  }while(x!=0||y!=0);\n  printf(\"\\n\");\n  return 0;\n  \n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char h[5][5]; // horizontal walls\n    char v[4][5]; // vertical walls\n    char input[10];\n    \n    // Read input\n    for (int i = 0; i < 9; i++) {\n        scanf(\"%s\", input);\n        if (i % 2 == 0) {\n            // horizontal walls\n            int row = i / 2;\n            strcpy(h[row], input);\n        } else {\n            // vertical walls\n            int row = i / 2;\n            strcpy(v[row], input);\n        }\n    }\n    \n    // Start at point A (0,0), facing right (east)\n    int x = 0, y = 0;\n    int dir = 0; // 0=East, 1=South, 2=West, 3=North\n    char dirChars[] = {'R', 'D', 'L', 'U'};\n    \n    // Direction vectors: dx[dir], dy[dir]\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, 1, 0, -1};\n    \n    char path[10000];\n    int pathLen = 0;\n    \n    // Right-hand rule: keep wall on right\n    do {\n        // Try to turn right first\n        int rightDir = (dir + 3) % 4; // turn right\n        int rightX = x + dx[rightDir];\n        int rightY = y + dy[rightDir];\n        \n        // Check if we can move right\n        int canMoveRight = 0;\n        if (rightX >= 0 && rightX <= 4 && rightY >= 0 && rightY <= 4) {\n            if (rightDir == 0 && rightX <= 4 && v[y][x] == '0') canMoveRight = 1;\n            else if (rightDir == 1 && rightY <= 4 && h[y][x] == '0') canMoveRight = 1;\n            else if (rightDir == 2 && rightX >= 0 && v[y][rightX] == '0') canMoveRight = 1;\n            else if (rightDir == 3 && rightY >= 0 && h[rightY][x] == '0') canMoveRight = 1;\n        }\n        \n        if (canMoveRight) {\n            dir = rightDir;\n            x = rightX;\n            y = rightY;\n            path[pathLen++] = dirChars[dir];\n        } else {\n            // Try to move forward\n            int fwdX = x + dx[dir];\n            int fwdY = y + dy[dir];\n            \n            int canMoveFwd = 0;\n            if (fwdX >= 0 && fwdX <= 4 && fwdY >= 0 && fwdY <= 4) {\n                if (dir == 0 && fwdX <= 4 && v[y][x] == '0') canMoveFwd = 1;\n                else if (dir == 1 && fwdY <= 4 && h[y][x] == '0') canMoveFwd = 1;\n                else if (dir == 2 && fwdX >= 0 && v[y][fwdX] == '0') canMoveFwd = 1;\n                else if (dir == 3 && fwdY >= 0 && h[fwdY][x] == '0') canMoveFwd = 1;\n            }\n            \n            if (canMoveFwd) {\n                x = fwdX;\n                y = fwdY;\n                path[pathLen++] = dirChars[dir];\n            } else {\n                // Turn left\n                dir = (dir + 1) % 4;\n            }\n        }\n    } while (!(x == 0 && y == 0 && dir == 0));\n    \n    path[pathLen] = '\\0';\n    printf(\"%s\\n\", path);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char h[5][5]; // horizontal walls char v[4][5]; // vertical walls char input[10]; // Read input for (int i = 0; i <  0) { // horizontal walls  { // vertical walls int row = i / 2; strcpy(v[row], input); } } // Start at point A (0,0), facing right  = 0; // 0=East, 1=South, 2=West, 3=North char dirChars[] = {'R', 'D', 'L', 'U'};  -1, 0}; int dy[] = {0, 1, 0, -1}; char path[10000]; int pathLen = 0; // Right-hand rule: keep wall on right do { // Try to turn right first int rightDir = (dir + 3) % 4;  can move right int canMoveRight = 0; if (rightX >= 0 && rightX <= 4 &&  == 0 && rightX <= 4 && v[y][x] == '0') canMoveRight = 1; else if (rightDir == 1 && rightY <= 4 && h[y][x]  && rightX >= 0 && v[y][rightX] == '0') canMoveRight = 1; else if (rightDir == 3 && rightY >= 0 && h[rightY][x] == '0') canMoveRight = 1; } if (canMoveRight) { dir = rightDir; x = rightX; y = rightY; path[pathLen++] = dirChars[dir]; } else { // Try to move forward int fwdX = x + dx[dir]; int fwdY = y + dy[dir]; int canMoveFwd = 0; if (fwdX >= 0 && fwdX <= 4 && fwdY >= 0 && fwdY <= 4) { if (dir == 0 && fwdX <= 4 && v[y][x] == '0') canMoveFwd =  (dir == 2 && fwdX >= 0 && v[y][fwdX] == '0') canMoveFwd = 1; else if (dir == 3 && fwdY >= 0 && h[fwdY][x] == '0') canMoveFwd = 1; } if  dirChars[dir]; } else { // Turn left dir = (dir  0 && y == 0 && dir == 0)); path[pathLen] = '\\0'; printf(\"%s\\n\", path); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){  } } int sl=1; printf(\"R\"); do{ switch(sl){ case 1: //printf(\"x=%d:y=%d\\n\",x,y); //printf(\"tate74=%d\\n\",tate[7][4]); if(tate[y-1][x+1]==1&&y>0){ x++; y--;  y++; sl=2; } // printf(\"tate74=%d\\n\",tate[7][4]); break; case 2: //printf(\"x=%d:y=%d\\n\",x,y); //printf(\"%d %d\\n\",x+1,y+2); //printf(\"tate74=%d\\n\",tate[7][4]); if(yoko[y+1][x]==1&&x<3){ y++;sl=1; }else if(tate[y+2][x]==1&&y<8){ y=y+2;sl=2; }else if(yoko[y+1][x-1]==1&&x>0){ y++; x--; sl=3; } break; case 3: //printf(\"x=%d:y=%d\\n\",x,y); if(tate[y+1][x]==1&&y<8){ sl=2;y++; }else if(yoko[y][x-1]==1&&x>0){ x--;sl=3; }else if(tate[y-1][x]==1&&y>0){ y--;sl=4; } break; case 4: // printf(\"x=%d:y=%d\\n\",x,y); if(yoko[y-1][x-1]==1&&x>0){ x--;y--;sl=3; }else if(tate[y-2][x]==1&&y>0){ y=y-2;sl=4; }else if(yoko[y-1][x]==1&&x<3){ y--;sl=1; } break; } //printf(\"sl=%d\\n\",sl); if(sl==1)printf(\"R\"); if(sl==2)printf(\"D\"); if(sl==3)printf(\"L\"); if(sl==4)printf(\"U\"); //printf(\"tate74=%d\\n\",tate[7][4]); //printf(\"\\n\"); }while(x!=0||y!=0); printf(\"\\n\"); return 0; }"], "original_ll": -0.8594191670417786, "sampled_ll": -0.5614480376243591, "all_perturbed_sampled_ll": [-1.416746735572815], "all_perturbed_original_ll": [-1.0832453966140747], "perturbed_sampled_ll": -1.416746735572815, "perturbed_original_ll": -1.0832453966140747, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\n// AOJ 0037\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final double EPS = 1e-10;\n\tpublic static void main(String[] args) {\n\t\tchar[][] cs = new char[20][1000];\n\t\tfor (int i = 0; i < 20; i++) fill(cs[i], '0');\n\t\t\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tString buf = sc.next();\n\t\t\tfor (int j = 0; j < buf.length(); j++) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tcs[i + 1][j * 2 + 2] = buf.charAt(j);\n\t\t\t\t} else {\n\t\t\t\t\tcs[i + 1][j * 2 + 1] = buf.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tint[] dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n\t\tString[] str = {\"R\", \"D\", \"L\", \"U\"}; \n\t\tint x = 1, y = 1, d = 0;\n\t\twhile (!(x == 1 && y == 1 && d == 2)) {\n\t\t\tif (cs[y + dy[d]][x + dx[d]] == '1') {\n\t\t\t\tx += dx[d] * 2; \n\t\t\t\ty += dy[d] * 2;\n\t\t\t\tSystem.out.print(str[d]);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (cs[y + dy[(d - 1 + 4) % 4]][x + dx[(d - 1 + 4) % 4]] == '1') {\n\t\t\t\t\td = (d - 1 + 4) % 4;\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\td = (d + 1) % 4;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class State {\n        int row, col;\n        int dir; // 0=right, 1=down, 2=left, 3=up\n        \n        State(int row, int col, int dir) {\n            this.row = row;\n            this.col = col;\n            this.dir = dir;\n        }\n    }\n    \n    static int[][] horizontal = new int[5][4]; // 5 horizontal lines, 4 segments each\n    static int[][] vertical = new int[4][5]; // 4 vertical lines, 5 segments each\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Read horizontal walls\n        for (int i = 0; i < 5; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 4; j++) {\n                horizontal[i][j] = line.charAt(j) - '0';\n            }\n        }\n        \n        // Read vertical walls\n        for (int i = 0; i < 4; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 5; j++) {\n                vertical[i][j] = line.charAt(j) - '0';\n            }\n        }\n        \n        // Start at position (0,0), facing right (dir=0)\n        // Right hand is on the wall above (horizontal[0][0] = 1)\n        State state = new State(0, 0, 0);\n        StringBuilder result = new StringBuilder();\n        \n        do {\n            // Try to turn right first (right-hand rule)\n            int rightDir = (state.dir + 3) % 4; // Turn right\n            \n            if (canMove(state.row, state.col, rightDir)) {\n                // Turn right and move\n                state.dir = rightDir;\n                move(state, result);\n            } else if (canMove(state.row, state.col, state.dir)) {\n                // Move straight\n                move(state, result);\n            } else {\n                // Turn left\n                state.dir = (state.dir + 1) % 4;\n            }\n        } while (!(state.row == 0 && state.col == 0 && state.dir == 0));\n        \n        System.out.println(result.toString());\n    }\n    \n    static boolean canMove(int row, int col, int dir) {\n        if (dir == 0) { // Right\n            if (col >= 4) return false;\n            return vertical[col][row] == 0;\n        } else if (dir == 1) { // Down\n            if (row >= 4) return false;\n            return horizontal[row + 1][col] == 0;\n        } else if (dir == 2) { // Left\n            if (col <= 0) return false;\n            return vertical[col - 1][row] == 0;\n        } else { // Up\n            if (row <= 0) return false;\n            return horizontal[row][col] == 0;\n        }\n    }\n    \n    static void move(State state, StringBuilder result) {\n        if (state.dir == 0) { // Right\n            result.append('R');\n            state.col++;\n        } else if (state.dir == 1) { // Down\n            result.append('D');\n            state.row++;\n        } else if (state.dir == 2) { // Left\n            result.append('L');\n            state.col--;\n        } else { // Up\n            result.append('U');\n            state.row--;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class State { int row, col; int dir; // 0=right, 1=down, 2=left, 3=up State(int row, int col, int dir) {  } static int[][] horizontal = new int[5][4]; // 5 horizontal lines, 4 segments each static int[][]  each public static void main(String[] args) {  (int i = 0; i < 5; i++) { String line = sc.nextLine(); for (int j = 0; j < 4; j++) { horizontal[i][j] = line.charAt(j) - '0'; } } // Read vertical walls for  line = sc.nextLine(); for (int j = 0; j < 5; j++) { vertical[i][j] = line.charAt(j) - '0'; } } // Start at position (0,0), facing right (dir=0) // Right hand is on the wall above (horizontal[0][0] = 1) State state = new State(0, 0, 0); StringBuilder result = new StringBuilder(); do { // Try to turn right first (right-hand rule) int rightDir = (state.dir + 3) % 4; // Turn right if (canMove(state.row, state.col, rightDir)) { // Turn right and move state.dir   Turn left state.dir = (state.dir + 1) % 4; } } while (!(state.row == 0 && state.col == 0 && state.dir == 0)); System.out.println(result.toString()); } static boolean canMove(int row, int col, int dir) { if (dir == 0) { //  0; } else if (dir  false; return horizontal[row + 1][col] == 0; } else  0) return  // Up if (row <= 0) return false; return horizontal[row][col] == 0; } } static void move(State state, StringBuilder result) { if (state.dir == 0) { // Right result.append('R'); state.col++; } else if (state.dir == 1) { // Down result.append('D'); state.row++; } else if (state.dir == 2)  result.append('U'); state.row--; } } }"], "perturbed_original": ["import java.util.*; import static java.util.Arrays.*; import static java.lang.Math.*; // AOJ 0037 public class Main { static Scanner sc = new Scanner(System.in); static final double EPS = 1e-10; public static void main(String[] args) { char[][] cs = new char[20][1000]; for (int i = 0; i < 20;  9; i++) { String buf = sc.next(); for (int j = 0; j < buf.length(); j++) { if (i % 2 == 0) { cs[i + 1][j * 2 + 2] = buf.charAt(j); } else { cs[i + 1][j * 2 + 1] = buf.charAt(j); } } } int[] dx = {1, 0, -1, 0}, dy = {0,  int x = 1, y  y == 1 && d == 2)) { if (cs[y + dy[d]][x + dx[d]] == '1') { x += dx[d] * 2; y +=  - 1 + 4) % 4]] == '1') { d = (d - 1 + 4) % 4;  } } } System.out.println(); } }"], "original_ll": -0.7912678122520447, "sampled_ll": -0.5232971906661987, "all_perturbed_sampled_ll": [-1.3883370161056519], "all_perturbed_original_ll": [-1.4399052858352661], "perturbed_sampled_ll": -1.3883370161056519, "perturbed_original_ll": -1.4399052858352661, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "path = [[[] for i in range(5)] for i in range(5)]\nfor i in range(9):\n    if i%2 == 0:\n        a = [int(i) for i in list(input())]\n        for j in range(4):\n            if a[j] == 1:\n                path[int(i/2)][j].append(\"R\")\n                path[int(i/2)][j+1].append(\"L\")\n    else:\n        a = [int(i) for i in list(input())]\n        for j in range(5):\n            if a[j] == 1:\n                path[int(i/2)][j].append(\"D\")\n                path[int(i/2)+1][j].append(\"U\")\n\nprev = \"R\"\np = \"R\"\nx = 0\ny = 0\nwhile(1):\n    if prev == \"R\":\n        if \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n    elif prev == \"L\":\n        if \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n    elif prev == \"U\":\n        if \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n    elif prev == \"D\":\n        if \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n    if x == 0 and y == 0:\n        break\nprint(p[1:])\n\n\n    \n\n", "sampled": "def solve():\n    # Read input\n    lines = []\n    for _ in range(9):\n        lines.append(input().strip())\n    \n    # Parse walls\n    # h_walls[i][j] = horizontal wall between row i and i+1, at column j\n    # v_walls[i][j] = vertical wall between column j and j+1, at row i\n    h_walls = []\n    v_walls = []\n    \n    for i in range(9):\n        if i % 2 == 0:  # horizontal walls\n            h_walls.append([int(c) for c in lines[i]])\n        else:  # vertical walls\n            v_walls.append([int(c) for c in lines[i]])\n    \n    # Start at point A (top-left corner, position (0, 0))\n    # Initial direction: facing right (since we start by going right with wall on right)\n    # Directions: 0=Right, 1=Down, 2=Left, 3=Up\n    pos = (0, 0)\n    direction = 0  # facing right\n    path = []\n    \n    # Direction vectors\n    dx = [1, 0, -1, 0]  # Right, Down, Left, Up\n    dy = [0, 1, 0, -1]\n    dir_chars = ['R', 'D', 'L', 'U']\n    \n    def has_wall(r, c, d):\n        \"\"\"Check if there's a wall when moving from (r,c) in direction d\"\"\"\n        if d == 0:  # Right\n            if c >= len(v_walls[0]):\n                return True\n            return v_walls[r][c] == 1\n        elif d == 1:  # Down\n            if r >= len(h_walls) - 1:\n                return True\n            return h_walls[r + 1][c] == 1\n        elif d == 2:  # Left\n            if c == 0:\n                return True\n            return v_walls[r][c - 1] == 1\n        else:  # Up (d == 3)\n            if r == 0:\n                return True\n            return h_walls[r][c] == 1\n    \n    while True:\n        # Try to turn right first (right-hand rule)\n        right_dir = (direction - 1) % 4\n        \n        # Check if we can go right\n        if not has_wall(pos[1], pos[0], right_dir):\n            # Turn right and move\n            direction = right_dir\n            pos = (pos[0] + dx[direction], pos[1] + dy[direction])\n            path.append(dir_chars[direction])\n        # Check if we can go straight\n        elif not has_wall(pos[1], pos[0], direction):\n            # Move straight\n            pos = (pos[0] + dx[direction], pos[1] + dy[direction])\n            path.append(dir_chars[direction])\n        else:\n            # Turn left\n            direction = (direction + 1) % 4\n            continue\n        \n        # Check if we're back at start\n        if pos == (0, 0) and len(path) > 0:\n            break\n    \n    print(''.join(path))\n\nsolve()\n", "perturbed_sampled": ["def solve(): # Read input lines = [] for _ in range(9): lines.append(input().strip()) # Parse walls # h_walls[i][j] = horizontal wall between row i and i+1, at column j # v_walls[i][j] = vertical  = []  2 == 0: # horizontal walls h_walls.append([int(c) for c in lines[i]]) else: # vertical walls v_walls.append([int(c) for c in lines[i]]) # Start at point A (top-left corner, position (0, 0)) # Initial direction: facing right (since we start by going right with wall  (0, 0) direction = 0 # facing right path = [] # Direction vectors dx = [1, 0, -1, 0] # Right, Down, Left, Up dy = [0, 1, 0, -1] dir_chars = ['R',  a wall when moving from (r,c) in direction d\"\"\" if d == 0: # Right if c >= len(v_walls[0]): return True return v_walls[r][c] == 1 elif d == 1: # Down if r >= len(h_walls) - 1: return True return h_walls[r + 1][c] == 1 elif d == 2: # Left if c == 0: return True return v_walls[r][c - 1] == 1 else: # Up (d == 3) if r ==  Try to turn right first (right-hand rule) right_dir = (direction - 1) % 4 # Check  # Turn right and move direction = right_dir pos = (pos[0] + dx[direction], pos[1] + dy[direction]) path.append(dir_chars[direction]) # Check if we can  pos = (pos[0] + dx[direction], pos[1] + dy[direction]) path.append(dir_chars[direction])  4 continue # Check if we're  > 0: break print(''.join(path)) solve()"], "perturbed_original": ["path = [[[] for i in range(5)] for i in range(5)] for i in range(9): if i%2 == 0: a = [int(i) for i in list(input())] for j in range(4): if a[j] == 1: path[int(i/2)][j].append(\"R\") path[int(i/2)][j+1].append(\"L\") else: a = [int(i) for i in list(input())] for j in range(5): if a[j] == 1: path[int(i/2)][j].append(\"D\") path[int(i/2)+1][j].append(\"U\")  = 0 while(1): if prev == \"R\": if \"U\" in path[x][y]: x -= 1 prev =  1 prev = \"R\" p += \"R\" elif \"D\" in path[x][y]: x += 1 prev = \"D\" p += \"D\" elif \"L\" in path[x][y]: y -= 1 prev =  += \"D\" elif \"L\" in path[x][y]: y -=  path[x][y]: x -= 1 prev = \"U\" p += \"U\" elif \"R\" in path[x][y]: y += 1 prev = \"R\" p += \"R\" elif prev == \"U\": if \"L\" in path[x][y]: y -= 1 prev = \"L\" p += \"L\" elif \"U\" in path[x][y]: x -= 1 prev = \"U\" p   1 prev = \"R\" p += \"R\" elif \"D\" in path[x][y]: x += 1 prev = \"D\" p += \"D\" elif \"L\" in path[x][y]: y -= 1 prev = \"L\" p += \"L\" elif \"U\" in path[x][y]: x -= 1 prev = \"U\" p += \"U\" if x == 0 and y == 0: break print(p[1:])"], "original_ll": -0.37163588404655457, "sampled_ll": -0.8005430698394775, "all_perturbed_sampled_ll": [-1.8616080284118652], "all_perturbed_original_ll": [-1.011006236076355], "perturbed_sampled_ll": -1.8616080284118652, "perturbed_original_ll": -1.011006236076355, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint isstraight(int[5]);\n\nint main(void) {\n\tint cards[5];\n\tint i,j,temp;\n\tint yaku;\n\tchar yakuname[7][11]={\"null\",\"one pair\",\"two pair\",\"three card\",\n\t\t\t\t\t\t\"straight\",\"full house\",\"four card\"};\n\twhile(1) {\n\t\tif(scanf(\"%d,%d,%d,%d,%d\",\n\t\t\t&cards[0],&cards[1],&cards[2],&cards[3],&cards[4])==-1)break;\n\t\tfor(i=4;i>0;i--) {\n\t\t\tfor(j=0;j<i;j++) {\n\t\t\t\tif(cards[j]>cards[j+1]) {\n\t\t\t\t\ttemp=cards[j];\n\t\t\t\t\tcards[j]=cards[j+1];\n\t\t\t\t\tcards[j+1]=temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tyaku=0;\n\t\tif(cards[1]==cards[2] && cards[2]==cards[3]) {\n\t\t\tif(cards[0]==cards[1] || cards[3]==cards[4])yaku=6;\n\t\t\telse yaku=3;\n\t\t} else if(cards[0]==cards[1] && cards[1]==cards[2]) {\n\t\t\tif(cards[3]==cards[4])yaku=5; else yaku=3;\n\t\t} else if(cards[2]==cards[3] && cards[3]==cards[4]) {\n\t\t\tif(cards[0]==cards[1])yaku=5; else yaku=3;\n\t\t} else if(isstraight(cards))yaku=4;\n\t\telse {\n\t\t\tfor(i=0;i<4;i++) {\n\t\t\t\tif(cards[i]==cards[i+1])yaku++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",yakuname[yaku]);\n\t}\n\treturn 0;\n}\n\nint isstraight(int cards[5]) {\n\tint i;\n\tfor(i=0;i<4;i++) {\n\t\tif(cards[i]+1!=cards[i+1])break;\n\t}\n\tif(i<4) {\n\t\tif(cards[0]==1 && cards[1]==10 && cards[2]==11 &&\n\t\t\tcards[3]==12 && cards[4]==13)return 1; else return 0;\n\t} else return 1;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    char line[100];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int cards[5];\n        sscanf(line, \"%d,%d,%d,%d,%d\", &cards[0], &cards[1], &cards[2], &cards[3], &cards[4]);\n        \n        // Count frequency of each card value\n        int count[14] = {0};\n        for (int i = 0; i < 5; i++) {\n            count[cards[i]]++;\n        }\n        \n        // Check for pairs, three of a kind, four of a kind\n        int pairs = 0, threes = 0, fours = 0;\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 2) pairs++;\n            else if (count[i] == 3) threes++;\n            else if (count[i] == 4) fours++;\n        }\n        \n        // Check for straight\n        qsort(cards, 5, sizeof(int), compare);\n        int is_straight = 0;\n        \n        // Normal straight\n        if (cards[1] == cards[0] + 1 && \n            cards[2] == cards[1] + 1 && \n            cards[3] == cards[2] + 1 && \n            cards[4] == cards[3] + 1) {\n            is_straight = 1;\n        }\n        \n        // A-2-3-4-5 straight\n        if (cards[0] == 1 && cards[1] == 2 && cards[2] == 3 && \n            cards[3] == 4 && cards[4] == 5) {\n            is_straight = 1;\n        }\n        \n        // 10-J-Q-K-A straight\n        if (cards[0] == 1 && cards[1] == 10 && cards[2] == 11 && \n            cards[3] == 12 && cards[4] == 13) {\n            is_straight = 1;\n        }\n        \n        // Determine the hand\n        if (fours > 0) {\n            printf(\"four card\\n\");\n        } else if (threes > 0 && pairs > 0) {\n            printf(\"full house\\n\");\n        } else if (is_straight) {\n            printf(\"straight\\n\");\n        } else if (threes > 0) {\n            printf(\"three card\\n\");\n        } else if (pairs == 2) {\n            printf(\"two pair\\n\");\n        } else if (pairs == 1) {\n            printf(\"one pair\\n\");\n        } else {\n            printf(\"null\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> int compare(const void *a, const void *b) { return (*(int*)a - *(int*)b); } int main() { char line[100]; while (fgets(line, sizeof(line), stdin)) { int cards[5]; sscanf(line, \"%d,%d,%d,%d,%d\", &cards[0], &cards[1],  int count[14] = {0}; for (int i = 0; i < 5; i++) { count[cards[i]]++; } // Check for pairs, three of a kind, four of a kind int pairs = 0, threes = 0, fours = 0; for (int i = 1; i <= 13; i++) { if (count[i] == 2) pairs++; else if  } //  0; // Normal straight if (cards[1] ==  + 1) { is_straight = 1; } //  && cards[2] == 3 && cards[3] == 4 && cards[4] == 5) { is_straight = 1; } // 10-J-Q-K-A straight if (cards[0] == 1 && cards[1] == 10 && cards[2] == 11  = 1; } // Determine the hand if (fours > 0) { printf(\"four card\\n\"); } else if (threes > 0 && pairs > 0) { printf(\"full house\\n\"); }  0) { printf(\"three card\\n\"); } else if (pairs == 2) { printf(\"two pair\\n\"); } else if (pairs == 1) { printf(\"one pair\\n\"); } else { printf(\"null\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int isstraight(int[5]); int main(void) { int cards[5]; int i,j,temp; int yaku; char yakuname[7][11]={\"null\",\"one pair\",\"two pair\",\"three card\", \"straight\",\"full house\",\"four card\"}; while(1) { if(scanf(\"%d,%d,%d,%d,%d\", &cards[0],&cards[1],&cards[2],&cards[3],&cards[4])==-1)break; for(i=4;i>0;i--) { for(j=0;j<i;j++) { if(cards[j]>cards[j+1]) { temp=cards[j]; cards[j]=cards[j+1];  { if(cards[0]==cards[1])yaku=5; else yaku=3; } else if(isstraight(cards))yaku=4; else { for(i=0;i<4;i++) { if(cards[i]==cards[i+1])yaku++; } } printf(\"%s\\n\",yakuname[yaku]); } return 0; } int isstraight(int cards[5]) { int i; for(i=0;i<4;i++) { if(cards[i]+1!=cards[i+1])break; } if(i<4) { if(cards[0]==1 && cards[1]==10 && cards[2]==11 && cards[3]==12 && cards[4]==13)return 1; else return 0; } else return 1; }"], "original_ll": -0.8021338582038879, "sampled_ll": -0.5267094969749451, "all_perturbed_sampled_ll": [-1.1901799440383911], "all_perturbed_original_ll": [-1.2095214128494263], "perturbed_sampled_ll": -1.1901799440383911, "perturbed_original_ll": -1.2095214128494263, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tprivate static boolean checkFourCard(int[] group){\n\t\tboolean flag = false;\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(group[i] == 4){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\t\n\tprivate static boolean checkFullHouse(int[] group){\n\t\tboolean two=false, three=false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(group[i] == 2){\n\t\t\t\ttwo = true;\n\t\t\t}else if(group[i] == 3){\n\t\t\t\tthree = true;\n\t\t\t}\n\t\t}\n\t\tif(two && three){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate static boolean checkStraight(int[] group){\n\t\tboolean flag = false;\n\t\tint count = 0;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(group[i] == 1){\n\t\t\t\t//\u307e\u305f\u3044\u3060\u56de\u6570\n\t\t\t\tint over = 0;\n\t\t\t\tfor(int j=i; j<i+5; ++j){\n\t\t\t\t\tover += j/group.length;\n\t\t\t\t\tif(over > 1){\t//2\u307e\u3067\u884c\u3063\u305f\u3089\u3001\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint num = j%13;\n\t\t\t\t\tif(num == 0){ num = 13; }\n\t\t\t\t\tif(group[num] == 1){\n\t\t\t\t\t\t++count;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count == 5){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\tprivate static boolean checkThreeCard(int[] group){\n\t\tboolean flag = false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\t//main \u3067 else if \u3084\u3063\u3066\u3044\u308b\u304b\u3089\u5927\u4e08\u592b\u3060\u3051\u3069\u3001full house \u8aa4\u8a8d\u9632\u6b62\n\t\t\tif(group[i] == 2){\n\t\t\t\treturn false;\n\t\t\t}else if(group[i] == 3){\t\t//four card\u3082false\u3067\u5e30\u308b\u3002\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\t\n\tprivate static boolean checkTwoPair(int[] group){\n\t\tboolean flag = false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(flag){\t\t//one pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001\n\t\t\t\tif(group[i] == 2){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(group[i] == 2){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate static boolean checkOnePair(int[] group){\n\t\tboolean flag = false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(flag){\t\t//one pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001\n\t\t\t\tif(group[i] == 2 || group[i] == 3){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(group[i] == 2){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\t\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scan = new Scanner(System.in);\n\t\tint hand[] = new int [5];\n\t\t\n\t\twhile(scan.hasNext()){\n\t\t\tString[] str = scan.next().split(\",\");\n\t\t\tfor(int i=0; i<str.length; ++i){\n\t\t\t\thand[i] = Integer.parseInt(str[i]);\n\t\t\t}\n\t\t\t\n\t\t\tint group[] = new int [14];\t//\u6dfb\u5b57\u304c\u30ab\u30fc\u30c9\u30ca\u30f3\u30d0\u3068\u5bfe\u5fdc\u3002\uff10\u306f\u6b20\u756a\n\t\t\tArrays.fill(group, 0);\n\t\t\tfor(int i=0; i<hand.length; ++i){\n\t\t\t\t++group[hand[i]];\n\t\t\t}\n\t\t\t\n\t\t\tif(checkFourCard(group)){\n\t\t\t\tSystem.out.println(\"four card\");\n\t\t\t}else if(checkFullHouse(group)){\n\t\t\t\tSystem.out.println(\"full house\");\n\t\t\t}else if(checkStraight(group)){\n\t\t\t\tSystem.out.println(\"straight\");\n\t\t\t}else if(checkThreeCard(group)){\n\t\t\t\tSystem.out.println(\"three card\");\n\t\t\t}else if(checkTwoPair(group)){\n\t\t\t\tSystem.out.println(\"two pair\");\n\t\t\t}else if(checkOnePair(group)){\n\t\t\t\tSystem.out.println(\"one pair\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"null\");\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] cards = line.split(\",\");\n            int[] hand = new int[5];\n            for (int i = 0; i < 5; i++) {\n                hand[i] = Integer.parseInt(cards[i]);\n            }\n            \n            System.out.println(evaluateHand(hand));\n        }\n        \n        sc.close();\n    }\n    \n    static String evaluateHand(int[] hand) {\n        int[] count = new int[14];\n        for (int card : hand) {\n            count[card]++;\n        }\n        \n        // Check for four card\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 4) {\n                return \"four card\";\n            }\n        }\n        \n        // Check for full house\n        boolean hasThree = false;\n        boolean hasTwo = false;\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 3) hasThree = true;\n            if (count[i] == 2) hasTwo = true;\n        }\n        if (hasThree && hasTwo) {\n            return \"full house\";\n        }\n        \n        // Check for straight\n        if (isStraight(hand)) {\n            return \"straight\";\n        }\n        \n        // Check for three card\n        if (hasThree) {\n            return \"three card\";\n        }\n        \n        // Check for two pair\n        int pairCount = 0;\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 2) pairCount++;\n        }\n        if (pairCount == 2) {\n            return \"two pair\";\n        }\n        \n        // Check for one pair\n        if (pairCount == 1) {\n            return \"one pair\";\n        }\n        \n        return \"null\";\n    }\n    \n    static boolean isStraight(int[] hand) {\n        int[] sorted = hand.clone();\n        Arrays.sort(sorted);\n        \n        // Check normal straight\n        boolean isConsecutive = true;\n        for (int i = 1; i < 5; i++) {\n            if (sorted[i] != sorted[i-1] + 1) {\n                isConsecutive = false;\n                break;\n            }\n        }\n        if (isConsecutive) return true;\n        \n        // Check A-2-3-4-5\n        if (sorted[0] == 1 && sorted[1] == 2 && sorted[2] == 3 && sorted[3] == 4 && sorted[4] == 5) {\n            return true;\n        }\n        \n        // Check 10-J-Q-K-A\n        if (sorted[0] == 1 && sorted[1] == 10 && sorted[2] == 11 && sorted[3] == 12 && sorted[4] == 13) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String line = sc.nextLine().trim(); if  int[5]; for (int  Integer.parseInt(cards[i]); } System.out.println(evaluateHand(hand));  = new int[14]; for (int card : hand) { count[card]++; } // Check for four card for (int i = 1; i <= 13; i++) { if (count[i] == 4) { return \"four card\"; } } // Check for full house boolean hasThree = false; boolean hasTwo = false; for (int i = 1; i <= 13; i++) { if (count[i] ==  true; } if (hasThree && hasTwo) { return \"full house\"; } // Check for straight if (isStraight(hand)) { return \"straight\"; } // Check for three card if (hasThree) { return \"three card\"; } // Check  = 1; i <= 13; i++) {  { return \"two pair\"; }  return \"one pair\"; } return \"null\"; } static boolean isStraight(int[] hand) { int[] sorted = hand.clone(); Arrays.sort(sorted); // Check normal straight boolean isConsecutive = true; for (int i = 1; i < 5; i++) { if (sorted[i] != sorted[i-1] + 1) { isConsecutive = false; break; } } if (isConsecutive) return true; // Check A-2-3-4-5 if (sorted[0] == 1 && sorted[1] == 2 && sorted[2] == 3 && sorted[3] == 4 && sorted[4] == 5) {  && sorted[1] == 10 &&  13) { return true; } return false; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { private static boolean checkFourCard(int[] group){ boolean flag = false; for(int i=1; i<group.length; ++i){ if(group[i] == 4){ flag = true; } } return flag; } private static boolean checkFullHouse(int[] group){ boolean two=false, three=false; for(int i=1; i<group.length; ++i){ if(group[i] == 2){ two = true; }else if(group[i] == 3){ three = true; } } if(two && three){ return true; }else{ return false; } } private static boolean checkStraight(int[] group){  i<group.length; ++i){ if(group[i] == 1){ //\u307e\u305f\u3044\u3060\u56de\u6570 int over = 0; for(int j=i; j<i+5; ++j){ over += j/group.length; if(over > 1){ //2\u307e\u3067\u884c\u3063\u305f\u3089\u3001 return false; } int num = j%13; if(num  }else{ count = 0; break;  group){ boolean flag = false; for(int i=1; i<group.length; ++i){ //main \u3067 else if \u3084\u3063\u3066\u3044\u308b\u304b\u3089\u5927\u4e08\u592b\u3060\u3051\u3069\u3001full house \u8aa4\u8a8d\u9632\u6b62 if(group[i] == 2){ return false; }else if(group[i] == 3){ //four card\u3082false\u3067\u5e30\u308b\u3002 flag = true; } } return flag; } private static  ++i){ if(flag){ //one pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001 if(group[i] == 2){ return true; } } if(group[i] == 2){ flag = true; } } return false; } private   } /** * @param args */ public static void main(String[] args) { // TODO Auto-generated method stub Scanner scan = new Scanner(System.in); int hand[] = new int [5]; while(scan.hasNext()){ String[] str = scan.next().split(\",\"); for(int i=0; i<str.length; ++i){ hand[i] = Integer.parseInt(str[i]); } int group[] = new int [14]; //\u6dfb\u5b57\u304c\u30ab\u30fc\u30c9\u30ca\u30f3\u30d0\u3068\u5bfe\u5fdc\u3002\uff10\u306f\u6b20\u756a Arrays.fill(group, 0); for(int i=0; i<hand.length; ++i){ ++group[hand[i]];  System.out.println(\"straight\"); }else if(checkThreeCard(group)){ System.out.println(\"three card\"); }else if(checkTwoPair(group)){ System.out.println(\"two pair\"); }else if(checkOnePair(group)){ System.out.println(\"one pair\"); }else{ System.out.println(\"null\"); } } } }"], "original_ll": -0.8529282808303833, "sampled_ll": -0.41500619053840637, "all_perturbed_sampled_ll": [-1.2357147932052612], "all_perturbed_original_ll": [-1.6838032007217407], "perturbed_sampled_ll": -1.2357147932052612, "perturbed_original_ll": -1.6838032007217407, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nfor s in sys.stdin:\n    A = list(map(int, s.split(',')))\n    A.sort()\n    #print(A)\n\n    if (A[0] == A[1] == A[2] == A[3]) or (A[1] == A[2] == A[3] == A[4]):\n        print('four card')\n\n    # full house\n    elif (A[0] == A[1] == A[2]) and (A[3] == A[4]):\n        print('full house')\n    elif (A[0] == A[1]) and (A[2] == A[3] == A[4]):\n        print('full house')\n\n    # straight\n    elif A[0] == A[1] - 1 == A[2] - 2 == A[3] - 3 == A[4] - 4:\n        print('straight')\n    elif A[1] == 10 and A[2] == 11 and A[3] == 12 and A[4] == 13 and A[0] == 1:\n        print('straight')\n\n    # three card\n    elif (A[0] == A[1] == A[2]) or (A[1] == A[2] == A[3]) or (A[2] == A[3] == A[4]):\n        print('three card')\n\n    # two pair\n    elif ((A[0] == A[1]) and (A[2] == A[3])) or ((A[0] == A[1]) and (A[3] == A[4])) or ((A[1] == A[2]) and (A[3] == A[4])):\n        print('two pair')\n\n    # one pair\n    elif (A[0] == A[1]) or (A[1] == A[2]) or (A[2] == A[3]) or (A[3] == A[4]):\n        print('one pair')\n\n    else:\n        print('null')", "sampled": "import sys\nfrom collections import Counter\n\ndef get_hand_rank(cards):\n    counts = Counter(cards)\n    count_values = sorted(counts.values(), reverse=True)\n    \n    # Check for four card\n    if count_values[0] == 4:\n        return \"four card\"\n    \n    # Check for full house\n    if count_values[0] == 3 and count_values[1] == 2:\n        return \"full house\"\n    \n    # Check for straight\n    sorted_cards = sorted(cards)\n    is_straight = True\n    for i in range(4):\n        if sorted_cards[i+1] - sorted_cards[i] != 1:\n            is_straight = False\n            break\n    \n    if is_straight:\n        return \"straight\"\n    \n    # Check for A-2-3-4-5 straight\n    if sorted_cards == [1, 2, 3, 4, 5]:\n        return \"straight\"\n    \n    # Check for 10-J-Q-K-A straight\n    if sorted_cards == [1, 10, 11, 12, 13]:\n        return \"straight\"\n    \n    # Check for three card\n    if count_values[0] == 3:\n        return \"three card\"\n    \n    # Check for two pair\n    if count_values[0] == 2 and count_values[1] == 2:\n        return \"two pair\"\n    \n    # Check for one pair\n    if count_values[0] == 2:\n        return \"one pair\"\n    \n    return \"null\"\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        break\n    cards = list(map(int, line.split(',')))\n    print(get_hand_rank(cards))\n", "perturbed_sampled": ["import sys  = sorted(counts.values(), reverse=True) # Check  # Check for full house if count_values[0] == 3 and count_values[1] == 2: return \"full house\" # Check for straight sorted_cards = sorted(cards) is_straight = True for i in range(4): if sorted_cards[i+1] - sorted_cards[i] != 1: is_straight = False break if is_straight: return \"straight\" # Check for A-2-3-4-5 straight if sorted_cards == [1, 2, 3, 4, 5]: return \"straight\" #  if count_values[0] == 3: return \"three card\" # Check for two pair if count_values[0] == 2 and count_values[1] == 2: return \"two pair\" # Check for one pair if count_values[0] == 2: return \"one pair\" return \"null\" for line in sys.stdin: line = line.strip() if not line: break cards = list(map(int, line.split(','))) print(get_hand_rank(cards))"], "perturbed_original": ["# -*- coding: utf-8 -*-  list(map(int, s.split(','))) A.sort() #print(A) if (A[0] == A[1] == A[2] == A[3]) or (A[1] == A[2] == A[3] == A[4]): print('four card') # full house elif (A[0] == A[1] == A[2]) and (A[3] == A[4]): print('full house') elif (A[0] == A[1]) and (A[2] == A[3] == A[4]): print('full house')  - 2 == A[3] - 3 == A[4] - 4: print('straight') elif A[1] == 10 and A[2] == 11 and A[3] == 12 and A[4] == 13 and A[0] == 1: print('straight') # three card elif  # two pair elif ((A[0] == A[1]) and (A[2] == A[3])) or ((A[0] == A[1]) and  A[4])): print('two pair') # one pair elif (A[0] == A[1]) or (A[1] == A[2]) or (A[2] == A[3]) or (A[3] == A[4]): print('one pair') else: print('null')"], "original_ll": -0.4635232388973236, "sampled_ll": -0.5993234515190125, "all_perturbed_sampled_ll": [-1.3635236024856567], "all_perturbed_original_ll": [-1.0081787109375], "perturbed_sampled_ll": -1.3635236024856567, "perturbed_original_ll": -1.0081787109375, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\n\n\nint main(){\n  int i,j,k,l,al[]={0,1,5,7,11,17,19,23,25},n,clen;\n  char ci[257],ans[257];\n  fgets(ci,256,stdin);\n  n=atoi(ci);\n  for(i=0;i<n;i++){\n    fgets(ci,256,stdin);\n    clen=strlen(ci);\n    ans[clen]='\\0';\n    for(j=0;j<9;j++){\n      for(k=0;k<26;k++){\n\tfor(l=0;l<clen;l++){\n\t  if(isalpha(ci[l]))\n\t    ans[l]=(al[j]*((int)ci[l]-(int)'a')+k)%26+'a';\n\t  else\n\t    ans[l]=ci[l];\n\t}\n\tif(strstr(ans,\"that\")||strstr(ans,\"this\")){\n\t  printf(\"%s\",ans);\n\t  goto find;\n\t}\n      }\n    }\n  find:;\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint mod_inverse(int a, int m) {\n    for (int i = 1; i < m; i++) {\n        if ((a * i) % m == 1) return i;\n    }\n    return -1;\n}\n\nvoid decrypt(char *text, int alpha, int beta, char *result) {\n    int alpha_inv = mod_inverse(alpha, 26);\n    if (alpha_inv == -1) {\n        result[0] = '\\0';\n        return;\n    }\n    \n    int len = strlen(text);\n    for (int i = 0; i < len; i++) {\n        if (isalpha(text[i])) {\n            int c = text[i] - 'a';\n            int decoded = (alpha_inv * (c - beta + 26)) % 26;\n            if (decoded < 0) decoded += 26;\n            result[i] = decoded + 'a';\n        } else {\n            result[i] = text[i];\n        }\n    }\n    result[len] = '\\0';\n}\n\nint contains_word(char *text, char *word) {\n    int text_len = strlen(text);\n    int word_len = strlen(word);\n    \n    for (int i = 0; i <= text_len - word_len; i++) {\n        if (i > 0 && isalpha(text[i-1])) continue;\n        if (i + word_len < text_len && isalpha(text[i + word_len])) continue;\n        \n        int match = 1;\n        for (int j = 0; j < word_len; j++) {\n            if (text[i + j] != word[j]) {\n                match = 0;\n                break;\n            }\n        }\n        if (match) return 1;\n    }\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\\n\", &n);\n    \n    for (int t = 0; t < n; t++) {\n        char text[257];\n        fgets(text, 257, stdin);\n        int len = strlen(text);\n        if (text[len-1] == '\\n') text[len-1] = '\\0';\n        \n        char result[257];\n        int found = 0;\n        \n        for (int alpha = 1; alpha < 26 && !found; alpha++) {\n            if (gcd(alpha, 26) != 1) continue;\n            \n            for (int beta = 0; beta < 26 && !found; beta++) {\n                decrypt(text, alpha, beta, result);\n                \n                if (contains_word(result, \"that\") || contains_word(result, \"this\")) {\n                    printf(\"%s\\n\", result);\n                    found = 1;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <ctype.h> int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); } int mod_inverse(int a, int m) { for (int i = 1; i < m; i++)  alpha, int beta, char *result) { int alpha_inv = mod_inverse(alpha, 26); if (alpha_inv == -1) { result[0] = '\\0'; return; } int len = strlen(text); for (int i = 0; i < len; i++) { if (isalpha(text[i])) { int c = text[i]  + 26)) % 26; if (decoded < 0) decoded +=  = text[i]; } } result[len] = '\\0'; } int contains_word(char *text, char *word) { int text_len = strlen(text); int word_len = strlen(word); for (int i = 0; i <= text_len - word_len; i++) { if (i > 0 && isalpha(text[i-1])) continue; if (i + word_len < text_len && isalpha(text[i + word_len]))  != word[j]) {  } return 0; } int main() { int n; scanf(\"%d\\n\", &n); for (int t = 0; t < n; t++) { char text[257]; fgets(text, 257, stdin);  '\\0'; char result[257]; int found = 0; for (int alpha = 1; alpha  1) continue; for (int beta = 0; beta < 26 && !found; beta++) { decrypt(text, alpha, beta, result); if (contains_word(result, \"that\") || contains_word(result, \"this\")) { printf(\"%s\\n\", result); found = 1; } } } } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> int  ans[clen]='\\0'; for(j=0;j<9;j++){ for(k=0;k<26;k++){ for(l=0;l<clen;l++){ if(isalpha(ci[l])) ans[l]=(al[j]*((int)ci[l]-(int)'a')+k)%26+'a'; else ans[l]=ci[l]; } if(strstr(ans,\"that\")||strstr(ans,\"this\")){ printf(\"%s\",ans); goto find; } } } find:; } return 0; }"], "original_ll": -1.324188470840454, "sampled_ll": -0.5105780363082886, "all_perturbed_sampled_ll": [-1.2747610807418823], "all_perturbed_original_ll": [-2.1941661834716797], "perturbed_sampled_ll": -1.2747610807418823, "perturbed_original_ll": -2.1941661834716797, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\n\n\n class Main{\n     \n    static  ArrayList<String> al=new ArrayList<String>();\n    static int A=1,B=0;\n    static char chars[]= new char[]{\n         'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',\n         'q','r','s','t','u','v','w','x','y','z'\n     };\n    static char getChar(int n){return chars[n];}\n    static int getCode(char c){return (int)c-(int)'a';}\n    static int F(int m){return (A*m+B)%26;}\n    static String replace(String str){\n        StringBuilder sb=new StringBuilder();\n        for(int i=0; i<str.length(); i++){\n           // System.out.println(str.charAt(i)+\" \"+F(getCode(str.charAt(i))));\n            char replaced = getChar(F(getCode(str.charAt(i))));\n            //System.out.println(replaced);\n            sb.append(replaced);\n        }        return new String(sb);\n    }\n    static void detectAB(){\n        A=1;B=0;\n        for(int a=1; a<30000;a+=2){\n            for(int b=0; b<26;b++){\n                A=a;B=b;\n                for(String str:al){\n                    String rep = replace(str);\n                    //System.out.println(rep);\n                    if(rep.equals(\"this\")||rep.equals(\"that\"))return;\n                }\n            }\n        }\n    }\n    \n     public static void main(String args[]){\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // System.out.println(getCode('a')+\"\"+getCode('b')+\"\"+getCode('z'));\n         //System.out.println(replace(\"abz\"));\n         //String line;\n         try{\n         int n=Integer.parseInt(br.readLine());\n         //int n=1;\n         //for(int i=0; i<n;i++){\n         String line;\n         while((line=br.readLine())!=null){\n             //System.out.println(\"aa\"+n);\n             al.clear();\n             \n             //System.out.println(line);\n             String split[]=line.split(\" \");\n             for(String str:split)if(str.length()==4)al.add(str);\n            detectAB();\n             System.out.print(replace(split[0]));\n            for(int j=1; j<split.length;j++){\n                System.out.print(\" \"+replace(split[j]));\n            }\n             System.out.println();\n         }\n         }catch(Exception e){}\n         \n     }\n     \n }", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String encrypted = sc.nextLine();\n            String decrypted = decrypt(encrypted);\n            System.out.println(decrypted);\n        }\n    }\n    \n    static String decrypt(String encrypted) {\n        // Try all possible alpha and beta values\n        for (int alpha = 1; alpha < 26; alpha++) {\n            if (gcd(alpha, 26) != 1) continue; // alpha must be coprime with 26\n            \n            for (int beta = 0; beta < 26; beta++) {\n                String decrypted = tryDecrypt(encrypted, alpha, beta);\n                if (decrypted != null && (decrypted.contains(\"that\") || decrypted.contains(\"this\"))) {\n                    return decrypted;\n                }\n            }\n        }\n        return encrypted;\n    }\n    \n    static String tryDecrypt(String encrypted, int alpha, int beta) {\n        // Find modular inverse of alpha\n        int alphaInv = modInverse(alpha, 26);\n        if (alphaInv == -1) return null;\n        \n        StringBuilder sb = new StringBuilder();\n        for (char c : encrypted.toCharArray()) {\n            if (c >= 'a' && c <= 'z') {\n                int y = c - 'a';\n                int x = (alphaInv * (y - beta + 26)) % 26;\n                if (x < 0) x += 26;\n                sb.append((char)('a' + x));\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n    \n    static int gcd(int a, int b) {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n    \n    static int modInverse(int a, int m) {\n        for (int x = 1; x < m; x++) {\n            if ((a * x) % m == 1) {\n                return x;\n            }\n        }\n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int  < n; i++) { String encrypted = sc.nextLine(); String decrypted = decrypt(encrypted); System.out.println(decrypted); } } static String decrypt(String encrypted) { // Try all possible  < 26; alpha++) { if (gcd(alpha, 26) != 1) continue; // alpha must be coprime with 26 for (int beta = 0; beta < 26; beta++) { String decrypted = tryDecrypt(encrypted, alpha, beta); if (decrypted != null && (decrypted.contains(\"that\")  { // Find modular inverse of alpha int alphaInv = modInverse(alpha, 26); if (alphaInv == -1) return null; StringBuilder sb = new StringBuilder(); for (char c : encrypted.toCharArray()) { if (c >= 'a' && c <= 'z') { int y = c - 'a'; int x = (alphaInv * (y - beta + 26)) % 26; if (x < 0) x += 26; sb.append((char)('a' + x)); } else { sb.append(c); } } return sb.toString(); } static int gcd(int   int m) { for (int x = 1; x < m; x++) {  x; } } return -1; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; class Main{ static ArrayList<String> al=new ArrayList<String>(); static int A=1,B=0; static char chars[]= new char[]{ 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p', 'q','r','s','t','u','v','w','x','y','z' }; static char getChar(int n){return chars[n];} static int getCode(char c){return (int)c-(int)'a';} static int  for(int i=0; i<str.length(); i++){ // System.out.println(str.charAt(i)+\" \"+F(getCode(str.charAt(i)))); char replaced = getChar(F(getCode(str.charAt(i)))); //System.out.println(replaced); sb.append(replaced); } return new String(sb); } static void detectAB(){ A=1;B=0; for(int a=1; a<30000;a+=2){ for(int b=0; b<26;b++){ A=a;B=b; for(String str:al){  public static void main(String args[]){ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // System.out.println(getCode('a')+\"\"+getCode('b')+\"\"+getCode('z')); //System.out.println(replace(\"abz\")); //String line; try{ int n=Integer.parseInt(br.readLine()); //int n=1; //for(int i=0;  for(String str:split)if(str.length()==4)al.add(str); detectAB();  e){} } }"], "original_ll": -1.1537333726882935, "sampled_ll": -0.566597580909729, "all_perturbed_sampled_ll": [-1.390586018562317], "all_perturbed_original_ll": [-1.6123576164245605], "perturbed_sampled_ll": -1.390586018562317, "perturbed_original_ll": -1.6123576164245605, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for _ in[0]*int(input()):\n e=input()\n for i in range(1,26,2):\n  for j in range(26):\n   a=''.join([c,chr(((ord(c)-97)*i+j)%26+97)][c.islower()]for c in e)\n   if'that'in a or'this'in a:print(a);break\n", "sampled": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    if gcd(a, m) != 1:\n        return None\n    for i in range(1, m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef decrypt_char(c, alpha, beta):\n    if not c.isalpha():\n        return c\n    alpha_inv = mod_inverse(alpha, 26)\n    if alpha_inv is None:\n        return c\n    val = ord(c) - ord('a')\n    decrypted_val = (alpha_inv * (val - beta)) % 26\n    return chr(decrypted_val + ord('a'))\n\ndef decrypt_text(text, alpha, beta):\n    return ''.join(decrypt_char(c, alpha, beta) for c in text)\n\ndef try_decrypt(encrypted):\n    keywords = [\"that\", \"this\"]\n    \n    for alpha in range(1, 26):\n        if gcd(alpha, 26) != 1:\n            continue\n        \n        for beta in range(26):\n            decrypted = decrypt_text(encrypted, alpha, beta)\n            \n            for keyword in keywords:\n                if keyword in decrypted:\n                    return decrypted\n    \n    return encrypted\n\nn = int(input())\nfor _ in range(n):\n    encrypted = input()\n    print(try_decrypt(encrypted))\n", "perturbed_sampled": ["def gcd(a, b): while b: a, b = b, a % b return a def mod_inverse(a, m): if gcd(a, m) != is not<extra_id_8>return None<extra_id_9>=<extra_id_10>a<extra_id_11>=<extra_id_12>, beta):<extra_id_13>; k<extra_id_14>= int(input()) for i in<extra_id_15>i<extra_id_16>for i<extra_id_17>i = None return<extra_id_18>[ - 1<extra_id_19>= 'a' , 'a' ,<extra_id_20>\"a\"<extra_id_21>10 * i) % m == 1: return i return None  = mod_inverse(alpha, 26) if  decrypted_val = (alpha_inv * (val - beta)) % 26 return chr(decrypted_val + ord('a')) def decrypt_text(text, alpha, beta): return ''.join(decrypt_char(c, alpha, beta) for c in text) def try_decrypt(encrypted): keywords = [\"that\", \"this\"] for alpha in range(1, 26): if  = decrypt_text(encrypted, alpha, beta) for keyword in keywords: if keyword in decrypted: return decrypted return encrypted n = int(input()) for _ in range(n): encrypted = input() print(try_decrypt(encrypted))"], "perturbed_original": ["for _ in[0]*int(input()): e=input() for i in range(1,26,2): for j in range(26): a=''.join([c,chr(((ord(c)-97)*i+j)%26+97)][c.islower()]for c in e) if'that'in a or'this'in a:print(a);break"], "original_ll": -2.2450149059295654, "sampled_ll": -0.7217479944229126, "all_perturbed_sampled_ll": [-2.1041040420532227], "all_perturbed_original_ll": [-2.2839748859405518], "perturbed_sampled_ll": -2.1041040420532227, "perturbed_original_ll": -2.2839748859405518, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "d[4],e[9],f,k;char x[];z(){int b,c,a=e[f++];a>9?x[k++]=40,b=z(),x[k++]=a,c=z(),x[k++]=41,a=a-43?a-45?b*c:b-c:b+c:(x[k++]=a+48);return a;}y(o,n,i,j){if(i==7){f=k=0;if(z()==10){x[k]=0;puts(x);return 1;}return 0;}if(o)for(;j--;){e[i]=\"+-*\"[j];if(y(o-1,n+1,i+1,3))return 1;}if(n|i==6)for(j=4;j--;)if(e[i]=d[j]){d[j]=0;if(y(o,n-1,i+1,3))return 1;d[j]=e[i];}return 0;}main(){for(;scanf(\"%d%d%d%d\",d,d+1,d+2,d+3),f=*d;)y(3,0,0,3)||puts(\"0\");}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint nums[4];\nchar result[1025];\nint found;\n\nvoid generate(int depth, int count, int used, int values[], char* exprs[], int value, char* expr) {\n    if (found) return;\n    \n    if (count == 1) {\n        if (value == 10) {\n            strcpy(result, expr);\n            found = 1;\n        }\n        return;\n    }\n    \n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            int newValues[4];\n            char* newExprs[4];\n            int newCount = 0;\n            \n            for (int k = 0; k < count; k++) {\n                if (k != i && k != j) {\n                    newValues[newCount] = values[k];\n                    newExprs[newCount] = exprs[k];\n                    newCount++;\n                }\n            }\n            \n            char expr1[1025], expr2[1025], expr3[1025];\n            \n            // Addition\n            sprintf(expr1, \"(%s + %s)\", exprs[i], exprs[j]);\n            newValues[newCount] = values[i] + values[j];\n            newExprs[newCount] = expr1;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr1);\n            if (found) return;\n            \n            // Subtraction (i - j)\n            sprintf(expr2, \"(%s - %s)\", exprs[i], exprs[j]);\n            newValues[newCount] = values[i] - values[j];\n            newExprs[newCount] = expr2;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr2);\n            if (found) return;\n            \n            // Subtraction (j - i)\n            sprintf(expr3, \"(%s - %s)\", exprs[j], exprs[i]);\n            newValues[newCount] = values[j] - values[i];\n            newExprs[newCount] = expr3;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr3);\n            if (found) return;\n            \n            // Multiplication\n            sprintf(expr1, \"(%s * %s)\", exprs[i], exprs[j]);\n            newValues[newCount] = values[i] * values[j];\n            newExprs[newCount] = expr1;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr1);\n            if (found) return;\n        }\n    }\n}\n\nvoid permute(int pos, int used, int perm[]) {\n    if (found) return;\n    \n    if (pos == 4) {\n        int values[4];\n        char* exprs[4];\n        char exprBuf[4][10];\n        \n        for (int i = 0; i < 4; i++) {\n            values[i] = perm[i];\n            sprintf(exprBuf[i], \"%d\", perm[i]);\n            exprs[i] = exprBuf[i];\n        }\n        \n        generate(0, 4, 0, values, exprs, 0, \"\");\n        return;\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (!(used & (1 << i))) {\n            perm[pos] = nums[i];\n            permute(pos + 1, used | (1 << i), perm);\n            if (found) return;\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d %d\", &nums[0], &nums[1], &nums[2], &nums[3]);\n        \n        if (nums[0] == 0 && nums[1] == 0 && nums[2] == 0 && nums[3] == 0) {\n            break;\n        }\n        \n        found = 0;\n        result[0] = '\\0';\n        \n        int perm[4];\n        permute(0, 0, perm);\n        \n        if (found) {\n            printf(\"%s\\n\", result);\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int nums[4]; char result[1025]; int found; void generate(int depth, int count, int  if (found)  { strcpy(result, expr); found = 1; } return; } for (int i = 0; i < count; i++) { for (int j = i + 1; j < count; j++) { int newValues[4]; char*  k < count; k++) { if (k != i && k != j) { newValues[newCount] = values[k]; newExprs[newCount] = exprs[k]; newCount++; } } char expr1[1025], expr2[1025], expr3[1025]; // Addition sprintf(expr1, \"(%s +  expr1; generate(depth + 1, newCount +  Subtraction (i  values[i] - values[j]; newExprs[newCount] = expr2; generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr2); if (found) return; // Subtraction (j - i) sprintf(expr3, \"(%s - %s)\", exprs[j], exprs[i]); newValues[newCount] = values[j] - values[i]; newExprs[newCount] = expr3; generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount],  exprs[i], exprs[j]); newValues[newCount] = values[i] * values[j];  } void permute(int pos, int used, int perm[]) { if (found) return; if (pos == 4) { int values[4]; char* exprs[4]; char exprBuf[4][10]; for (int i = 0; i < 4; i++) { values[i] = perm[i]; sprintf(exprBuf[i], \"%d\", perm[i]); exprs[i] = exprBuf[i]; } generate(0, 4, 0, values, exprs, 0, \"\"); return; } for (int i = 0; i < 4; i++) { if (!(used & (1 << i))) { perm[pos] = nums[i]; permute(pos + 1, used | (1 << i), perm); if (found) return; } } } int main() { while (1) { scanf(\"%d %d %d %d\", &nums[0], &nums[1], &nums[2], &nums[3]);  == 0 && nums[3] == 0)  perm[4]; permute(0, 0, perm); if (found) { printf(\"%s\\n\", result); } else { printf(\"0\\n\"); } } return 0; }"], "perturbed_original": ["d[4],e[9],f,k;char x[];z(){int b,c,a=e[f++];a>9?x[k++]=40,b=z(),x[k++]=a,c=z(),x[k++]=41,a=a-43?a-45?b*c:b-c:b+c:(x[k++]=a+48);return a;}y(o,n,i,j){if(i==7){f=k=0;if(z()==10){x[k]=0;puts(x);return 1;}return 0;}if(o)for(;j--;){e[i]=\"+-*\"[j];if(y(o-1,n+1,i+1,3))return 1;}if(n|i==6)for(j=4;j--;)if(e[i]=d[j]){d[j]=0;if(y(o,n-1,i+1,3))return 1;d[j]=e[i];}return 0;}main(){for(;scanf(\"%d%d%d%d\",d,d+1,d+2,d+3),f=*d;)y(3,0,0,3)||puts(\"0\");}"], "original_ll": -2.5349209308624268, "sampled_ll": -0.5034188032150269, "all_perturbed_sampled_ll": [-1.336868166923523], "all_perturbed_original_ll": [-2.5349209308624268], "perturbed_sampled_ll": -1.336868166923523, "perturbed_original_ll": -2.5349209308624268, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n  public static ArrayList<int[]> perm(int n){\n    int[] num = new int[n];\n    boolean[] flag = new boolean[n];\n    ArrayList<int[]> arrList = new ArrayList<int[]>();\n    permCalc(0,num,flag,arrList);\n    return arrList;\n  }\n\n  public static void permCalc(int rank, int[] num, boolean[] flag, ArrayList<int[]> arrList){\n    if (rank == num.length) {\n      arrList.add(num.clone());\n    }\n    else {\n      for (int i = 0; i < num.length; i++) {\n        if (!flag[i]) {\n          num[rank] = i;\n          flag[i] = true;\n          permCalc(rank+1,num,flag,arrList);\n          flag[i] = false;\n        }\n      }\n    }\n  }\n\n  public static int ope(int a, int b, int operand){\n    switch (operand) {\n      case 0:\n        return a+b;\n      case 1:\n        return a-b;\n      default:\n        return a*b;\n    }\n  }\n\n  public static String opeToStr(int operand){\n    switch (operand) {\n      case 0:\n        return \"+\";\n      case 1:\n        return \"-\";\n      default:\n        return \"*\";\n    }\n  }\n\n  public static String check(int[] num, int[] op){\n    int a = num[0];\n    int b = num[1];\n    int c = num[2];\n    int d = num[3];\n    if(ope(ope(ope(a,b,op[0]),c,op[1]),d,op[2]) == 10) {\n      return \"((\"+a+\" \"+opeToStr(op[0])+\" \"+b+\") \"+opeToStr(op[1])+\" \"+c+\") \"+opeToStr(op[2])+\" \"+d;\n    }\n    else if(ope(ope(a,b,op[0]),ope(c,d,op[2]),op[1]) == 10) {\n      return \"(\"+a+\" \"+opeToStr(op[0])+\" \"+b+\") \"+opeToStr(op[1])+\" (\"+c+\" \"+opeToStr(op[2])+\" \"+d+\")\";\n    }\n    else if(ope(ope(a,ope(b,c,op[1]),op[0]),d,op[2]) == 10) {\n      return \"(\"+a+\" \"+opeToStr(op[0])+\" (\"+b+\" \"+opeToStr(op[1])+\" \"+c+\")) \"+opeToStr(op[2])+\" \"+d;\n    }\n    else if(ope(a,ope(ope(b,c,op[1]),d,op[2]),op[0]) == 10) {\n      return a+\" \"+opeToStr(op[0])+\" ((\"+b+\" \"+opeToStr(op[1])+\" \"+c+\") \"+opeToStr(op[2])+\" \"+d+\")\";\n    }\n    else if(ope(a,ope(b,ope(c,d,op[2]),op[1]),op[0]) == 10) {\n      return a+\" \"+opeToStr(op[0])+\" (\"+b+\" \"+opeToStr(op[1])+\" (\"+c+\" \"+opeToStr(op[2])+\" \"+d+\"))\";\n    }\n    else {\n      return null;\n    }\n  }\n\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    ArrayList<int[]> arrList = perm(4);\n    int[][] operand = new int[27][];\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 3; j++) {\n        for (int k = 0; k < 3; k++) {\n          int[] temp = {i,j,k};\n          operand[9*i+3*j+k] = temp;\n        }\n      }\n    }\n    while(true) {\n      int[] num0 = new int[4];\n      for (int i = 0; i < 4; i++) {\n        num0[i] = sc.nextInt();\n      }\n      if (num0[0] == 0 && num0[1] == 0 && num0[2] == 0 && num0[3] == 0) {\n        break;\n      }\n      String chk = null;\n      search:\n      for (int i = 0; i < arrList.size(); i++) {\n        int[] num = {num0[arrList.get(i)[0]],num0[arrList.get(i)[1]],\n                     num0[arrList.get(i)[2]],num0[arrList.get(i)[3]]};\n        for (int j = 0; j < operand.length; j++) {\n          chk = check(num, operand[j]);\n          if (chk != null) {\n            break search;\n          }\n        }\n      }\n      if (chk == null) {\n        System.out.println(0);\n      }\n      else {\n        System.out.println(chk);\n      }\n    }\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Expr {\n        String str;\n        int val;\n        Expr(String s, int v) {\n            str = s;\n            val = v;\n        }\n    }\n    \n    static String result;\n    static boolean found;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int d = sc.nextInt();\n            \n            if (a == 0 && b == 0 && c == 0 && d == 0) break;\n            \n            int[] nums = {a, b, c, d};\n            result = null;\n            found = false;\n            \n            permute(nums, 0);\n            \n            if (result != null) {\n                System.out.println(result);\n            } else {\n                System.out.println(\"0\");\n            }\n        }\n    }\n    \n    static void permute(int[] nums, int start) {\n        if (found) return;\n        \n        if (start == nums.length) {\n            solve(nums);\n            return;\n        }\n        \n        for (int i = start; i < nums.length; i++) {\n            swap(nums, start, i);\n            permute(nums, start + 1);\n            swap(nums, start, i);\n            if (found) return;\n        }\n    }\n    \n    static void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    \n    static void solve(int[] nums) {\n        List<Expr> exprs = new ArrayList<>();\n        for (int num : nums) {\n            exprs.add(new Expr(String.valueOf(num), num));\n        }\n        \n        generate(exprs);\n    }\n    \n    static void generate(List<Expr> exprs) {\n        if (found) return;\n        \n        if (exprs.size() == 1) {\n            if (exprs.get(0).val == 10) {\n                result = exprs.get(0).str;\n                found = true;\n            }\n            return;\n        }\n        \n        for (int i = 0; i < exprs.size(); i++) {\n            for (int j = 0; j < exprs.size(); j++) {\n                if (i == j) continue;\n                \n                Expr e1 = exprs.get(i);\n                Expr e2 = exprs.get(j);\n                \n                char[] ops = {'+', '-', '*'};\n                \n                for (char op : ops) {\n                    int newVal = calc(e1.val, e2.val, op);\n                    String newStr = \"(\" + e1.str + \" \" + op + \" \" + e2.str + \")\";\n                    \n                    List<Expr> newExprs = new ArrayList<>();\n                    for (int k = 0; k < exprs.size(); k++) {\n                        if (k != i && k != j) {\n                            newExprs.add(exprs.get(k));\n                        }\n                    }\n                    newExprs.add(new Expr(newStr, newVal));\n                    \n                    generate(newExprs);\n                    if (found) return;\n                }\n            }\n        }\n    }\n    \n    static int calc(int a, int b, char op) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n        }\n        return 0;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Expr { String str; int val; Expr(String s, int v) { str = s; val =  static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int a = sc.nextInt(); int b = sc.nextInt(); int c = sc.nextInt(); int d = sc.nextInt(); if (a == 0 && b == 0 && c == 0 && d == 0) break; int[] nums = {a, b, c, d}; result = null; found = false; permute(nums, 0); if  if (found) return; if (start == nums.length) { solve(nums); return;  { swap(nums, start, i); permute(nums, start + 1); swap(nums, start, i); if (found) return; } } static void swap(int[]  nums[i] = nums[j]; nums[j] = temp; } static void solve(int[] nums) { List<Expr> exprs = new ArrayList<>(); for (int num : nums) { exprs.add(new Expr(String.valueOf(num), num)); } generate(exprs); } static void generate(List<Expr> exprs) { if (found) return; if (exprs.size() == 1)  = 0; j < exprs.size(); j++) { if (i == j) continue; Expr e1 = exprs.get(i); Expr e2 = exprs.get(j); char[] ops = {'+', '-', '*'}; for (char op : ops) { int newVal = calc(e1.val, e2.val, op); String newStr = \"(\" + e1.str + \" \" + op + \" \" + e2.str + \")\"; List<Expr> newExprs =  k++) { if (k != i && k != j) { newExprs.add(exprs.get(k)); } } newExprs.add(new Expr(newStr, newVal)); generate(newExprs); if (found) return; } } } } static int calc(int a, int b, char op) { switch (op) { case '+': return a  return a * b; } return 0; } }"], "perturbed_original": ["import java.util.*; class Main{ public static ArrayList<int[]> perm(int n){ int[] num = new int[n]; boolean[] flag = new boolean[n]; ArrayList<int[]> arrList = new ArrayList<int[]>(); permCalc(0,num,flag,arrList); return arrList; } public static void permCalc(int rank, int[] num, boolean[] flag, ArrayList<int[]> arrList){ if (rank == num.length) { arrList.add(num.clone()); } else { for (int i = 0; i < num.length; i++) { if (!flag[i]) { num[rank] = i; flag[i] = true; permCalc(rank+1,num,flag,arrList); flag[i] = false; } } } } public static int ope(int a, int b, int operand){ switch (operand) { case 0: return a+b;  static String opeToStr(int operand){ switch (operand) { case 0: return \"+\"; case 1: return  = num[1]; int c = num[2];  \"+opeToStr(op[2])+\" \"+d+\")\"; } else if(ope(ope(a,ope(b,c,op[1]),op[0]),d,op[2]) == 10) { return \"(\"+a+\" \"+opeToStr(op[0])+\" (\"+b+\" \"+opeToStr(op[1])+\" \"+c+\")) \"+opeToStr(op[2])+\" \"+d; } else  \"+opeToStr(op[2])+\" \"+d+\")\"; } else if(ope(a,ope(b,ope(c,d,op[2]),op[1]),op[0]) == 10) { return a+\" \"+opeToStr(op[0])+\" (\"+b+\" \"+opeToStr(op[1])+\" (\"+c+\" \"+opeToStr(op[2])+\" \"+d+\"))\"; } else { return null; } } public  arrList = perm(4); int[][] operand = new int[27][]; for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { for (int k = 0; k < 3; k++) { int[]  { int[] num0 = new int[4]; for (int i = 0; i < 4; i++) { num0[i] =  && num0[2] == 0 && num0[3] == 0) { break; } String chk = null; search: for (int i = 0; i < arrList.size(); i++) { int[] num  operand.length; j++) { chk = check(num, operand[j]); if (chk != null) { break search; } } } if (chk == null) { System.out.println(0); } else { System.out.println(chk); } } } }"], "original_ll": -0.5566064715385437, "sampled_ll": -0.39151710271835327, "all_perturbed_sampled_ll": [-1.16387939453125], "all_perturbed_original_ll": [-1.3017756938934326], "perturbed_sampled_ll": -1.16387939453125, "perturbed_original_ll": -1.3017756938934326, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import *\ndef f(s):\n if sum(s)==10:return\"((({} + {}) + {}) + {})\".format(*s)\n for a,b,c,d in permutations(s):\n  for x,y,z in permutations('+-**',3):\n   for t in[f\"({a} {x} {b}) {y} ({c} {z} {d})\",f\"(({a} {x} {b}) {y} {c}) {z} {d}\",f\"({a} {x} ({b} {y} {c})) {z} {d}\"]:\n    if eval(t)==10:return'('+t+')'\n else:return 0\nfor e in iter(input,'0 0 0 0'):print(f(list(map(int,e.split()))))\n", "sampled": "from itertools import permutations, product\n\ndef evaluate(expr):\n    try:\n        return eval(expr)\n    except:\n        return None\n\ndef generate_expressions(nums):\n    operators = ['+', '-', '*']\n    \n    # Template patterns for 4 numbers with different parenthesizations\n    patterns = [\n        # No parentheses\n        \"{} {} {} {} {} {} {}\",\n        # One pair of parentheses\n        \"({} {} {}) {} {} {} {}\",\n        \"{} {} ({} {} {}) {} {}\",\n        \"{} {} {} {} ({} {} {})\",\n        # Two pairs of parentheses\n        \"({} {} {}) {} ({} {} {})\",\n        \"(({} {} {}) {} {}) {} {}\",\n        \"{} {} (({} {} {}) {} {})\",\n        \"({} {} ({} {} {})) {} {}\",\n        \"{} {} ({} {} ({} {} {}))\",\n        # Three pairs of parentheses\n        \"(({} {} {}) {} ({} {} {}))\",\n        \"((({} {} {}) {} {}) {} {})\",\n        \"({} {} (({} {} {}) {} {}))\",\n        \"({} {} ({} {} ({} {} {})))\",\n        \"{} {} ((({} {} {}) {} {}))\",\n        \"{} {} (({} {} ({} {} {})))\",\n        \"{} {} ({} {} (({} {} {})))\",\n        # More complex patterns\n        \"((({} {} {}) {} ({} {} {})))\",\n        \"(({} {} ({} {} {})) {} {})\",\n        \"({} {} (({} {} ({} {} {}))))\",\n        \"(({} {} {}) {} (({} {} {})))\",\n        \"((({} {} ({} {} {}))) {} {})\",\n        \"{} {} (((({} {} {})) {} {}))\",\n    ]\n    \n    for perm in permutations(nums):\n        for ops in product(operators, repeat=3):\n            for pattern in patterns:\n                try:\n                    # Interleave numbers and operators\n                    elements = []\n                    num_idx = 0\n                    op_idx = 0\n                    for char in pattern:\n                        if char == '{}':\n                            if num_idx < 4:\n                                elements.append(str(perm[num_idx]))\n                                num_idx += 1\n                            elif op_idx < 3:\n                                elements.append(ops[op_idx])\n                                op_idx += 1\n                    \n                    if num_idx == 4 and op_idx == 3:\n                        expr = pattern.format(perm[0], ops[0], perm[1], ops[1], perm[2], ops[2], perm[3])\n                        result = evaluate(expr)\n                        if result == 10:\n                            return expr\n                except:\n                    continue\n    \n    return None\n\ndef solve():\n    results = []\n    while True:\n        line = input().split()\n        nums = [int(x) for x in line]\n        \n        if nums == [0, 0, 0, 0]:\n            break\n        \n        expr = generate_expressions(nums)\n        if expr:\n            results.append(expr)\n        else:\n            results.append(\"0\")\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "perturbed_sampled": ["from itertools import permutations, product def evaluate(expr): try: return eval(expr) except: return None  for 4 numbers with different parenthesizations patterns = [ # No parentheses \"{} {} {} {} {} {} {}\", # One pair of parentheses \"({} {} {}) {} {} {} {}\", \"{} {} ({} {} {}) {} {}\", \"{} {} {} {} ({} {} {})\", # Two pairs of  {}) {} {}) {} {}\", \"{} {} (({} {} {}) {} {})\", \"({} {}  {} {}))\",  {} {}))\", \"((({} {} {}) {} {}) {} {})\", \"({} {} (({} {} {}) {} {}))\", \"({} {} ({} {} ({} {} {})))\", \"{} {} ((({} {} {}) {}  ({} {} (({} {} {})))\", # More complex  ({} {} {})) {} {})\", \"({} {} (({} {} ({} {} {}))))\", \"(({} {} {}) {} (({} {} {})))\", \"((({} {} ({} {} {}))) {} {})\", \"{} {} (((({} {} {})) {} {}))\", ] for perm in permutations(nums): for ops in product(operators, repeat=3):  elements = [] num_idx = 0 op_idx = 0 for char in pattern: if char == '{}': if num_idx < 4: elements.append(str(perm[num_idx])) num_idx += 1 elif op_idx < 3:  == 3: expr = pattern.format(perm[0], ops[0], perm[1], ops[1], perm[2], ops[2], perm[3]) result = evaluate(expr) if result  results = [] while True: line = input().split() nums = [int(x) for x in line] if nums == [0, 0, 0, 0]: break expr = generate_expressions(nums) if expr: results.append(expr) else: results.append(\"0\") for result in results: print(result) solve()"], "perturbed_original": ["from itertools  + {})\".format(*s) for a,b,c,d in permutations(s): for x,y,z in permutations('+-**',3): for t in[f\"({a} {x} {b}) {y} ({c} {z} {d})\",f\"(({a} {x} {b}) {y} {c}) {z} {d}\",f\"({a} {x} ({b} {y} {c})) {z} {d}\"]: if eval(t)==10:return'('+t+')' else:return 0 for e in iter(input,'0 0 0 0'):print(f(list(map(int,e.split()))))"], "original_ll": -1.8911123275756836, "sampled_ll": -0.8875479698181152, "all_perturbed_sampled_ll": [-1.7931708097457886], "all_perturbed_original_ll": [-2.2190988063812256], "perturbed_sampled_ll": -1.7931708097457886, "perturbed_original_ll": -2.2190988063812256, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void)\n{\n  int i,j;\n  int prime[70000];\n  int n;\n  for(i=0;i<60000;i++){\n    prime[i] = 1;\n  }\n  prime[0]=0;\n  scanf(\"%d\",&n);\n\n  for(i=1;i*i<=60000;i++){\n    if(prime[i]==1){\n      for(j=i+1;(i+1)*j<=60000;j++){\n\tprime[(i+1)*j-1]=0;\n      }\n    }\n  }\n\n  for(i=n-2;0<=i;i--){\n    if(prime[i]==1){\n      printf(\"%d \",i+1); break;\n    }\n  }\n\n  for(i=n;i<60000;i++){\n    if(prime[i]==1){\n      printf(\"%d\",i+1); break;\n    }\n  }\n  putchar('\\n');\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    \n    int sqrt_num = (int)sqrt(num);\n    for (int i = 3; i <= sqrt_num; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) != EOF) {\n        int smaller = n - 1;\n        int larger = n + 1;\n        \n        while (smaller >= 2 && !is_prime(smaller)) {\n            smaller--;\n        }\n        \n        while (!is_prime(larger)) {\n            larger++;\n        }\n        \n        printf(\"%d %d\\n\", smaller, larger);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdbool.h> #include <math.h> bool is_prime(int num) { if (num < 2) return false; if (num == 2) return true; if (num %  (int i = 3; i <=  0) return false; } return true; } int main()  smaller = n - 1; int larger = n + 1; while (smaller >= 2 && !is_prime(smaller)) { smaller--; } while (!is_prime(larger)) { larger++; } printf(\"%d %d\\n\", smaller, larger); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int i,j; int prime[70000]; int n; for(i=0;i<60000;i++){ prime[i] = 1; } prime[0]=0; scanf(\"%d\",&n); for(i=1;i*i<=60000;i++){ if(prime[i]==1){ for(j=i+1;(i+1)*j<=60000;j++){ prime[(i+1)*j-1]=0; } } } for(i=n-2;0<=i;i--){ if(prime[i]==1){ printf(\"%d \",i+1); break; }  }"], "original_ll": -0.9927850961685181, "sampled_ll": -0.41554173827171326, "all_perturbed_sampled_ll": [-1.5075944662094116], "all_perturbed_original_ll": [-1.2503831386566162], "perturbed_sampled_ll": -1.5075944662094116, "perturbed_original_ll": -1.2503831386566162, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tfor(int i=n-1;i>=2;i--){\n\t\t\t\tboolean flag=true;\n\t\t\t\tfor(int j=2;j<Math.sqrt(i)+1;j++){\n\t\t\t\t\tif(i%j==0){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tSystem.out.print(i+\" \");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=n+1;i<50000;i++){\n\t\t\t\tboolean flag=true;\n\t\t\t\tfor(int j=2;j<Math.sqrt(i)+1;j++){\n\t\t\t\t\tif(i%j==0){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static boolean[] isPrime;\n    static final int MAX = 100001;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Sieve of Eratosthenes\n        isPrime = new boolean[MAX];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i < MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < MAX; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            \n            int smaller = 0;\n            for (int i = n - 1; i >= 2; i--) {\n                if (isPrime[i]) {\n                    smaller = i;\n                    break;\n                }\n            }\n            \n            int larger = 0;\n            for (int i = n + 1; i < MAX; i++) {\n                if (isPrime[i]) {\n                    larger = i;\n                    break;\n                }\n            }\n            \n            System.out.println(smaller + \" \" + larger);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static boolean[] isPrime; static final int MAX =  new Scanner(System.in); // Sieve of  i < MAX; i++) { if (isPrime[i]) { for (int j = i * i; j < MAX; j += i) { isPrime[j] = false; } } } while (sc.hasNext()) { int n = sc.nextInt(); int smaller = 0; for (int i = n - 1; i  break; } } int larger = 0; for (int i = n + 1; i < MAX; i++) { if (isPrime[i]) { larger = i; break; } } System.out.println(smaller + \" \" + larger); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main  int n=sc.nextInt(); for(int i=n-1;i>=2;i--){ boolean flag=true; for(int j=2;j<Math.sqrt(i)+1;j++){ if(i%j==0){ flag=false; break; } } if(flag){ System.out.print(i+\" \"); break; } } for(int i=n+1;i<50000;i++){ boolean flag=true; for(int j=2;j<Math.sqrt(i)+1;j++){ if(i%j==0){ flag=false; break; } } if(flag){ System.out.println(i); break; } } } } }"], "original_ll": -0.5573487281799316, "sampled_ll": -0.3601272404193878, "all_perturbed_sampled_ll": [-1.3677268028259277], "all_perturbed_original_ll": [-0.9269809126853943], "perturbed_sampled_ll": -1.3677268028259277, "perturbed_original_ll": -0.9269809126853943, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\nr = 50000\nsqrt = int(math.sqrt(r))\np = [1]*r\np[0] = 0\nfor i in range(1,sqrt):\n    if p[i]:\n        for j in range(2*i+1,r,i+1):\n            p[j] = 0\n            \nwhile True:\n    try:\n        n = int(raw_input())\n        for i in range(n,50000):\n            if p[i] == 1:\n                lp = i+1\n                break\n        for i in range(n-2,0,-1):\n            if p[i] == 1:\n                sp = i+1\n                break\n        print sp, lp\n    except:\n        break", "sampled": "import sys\n\ndef sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\n# Precompute primes up to a reasonable limit\nMAX_LIMIT = 100000\nis_prime = sieve_of_eratosthenes(MAX_LIMIT)\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    \n    # Find largest prime less than n\n    smaller = n - 1\n    while smaller > 1 and not is_prime[smaller]:\n        smaller -= 1\n    \n    # Find smallest prime greater than n\n    larger = n + 1\n    while larger <= MAX_LIMIT and not is_prime[larger]:\n        larger += 1\n    \n    print(smaller, larger)\n", "perturbed_sampled": ["import sys def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(limit**0.5) +  i): is_prime[j] = False return is_prime # Precompute primes up to a reasonable limit MAX_LIMIT = 100000 is_prime = sieve_of_eratosthenes(MAX_LIMIT) for line in sys.stdin: n = int(line.strip()) # Find largest prime less than n smaller =  smaller -= 1 #  1 while larger <= MAX_LIMIT and not is_prime[larger]: larger += 1 print(smaller, larger)"], "perturbed_original": ["import math r = 50000 sqrt = int(math.sqrt(r)) p = [1]*r p[0] = 0 for i in range(1,sqrt): if p[i]: for j in range(2*i+1,r,i+1): p[j] = 0 while True: try: n = int(raw_input()) for i in range(n,50000): if p[i] == 1: lp = i+1 break for i + 1: print sp<extra_id_4>0,50000)<extra_id_5>else: p[i] =<extra_id_6>= (1,r,2*i+1) for<extra_id_7>for<extra_id_8>i.sp_i++ if p[lp:] <<extra_id_9>print<extra_id_10>sp,<extra_id_11>: break<extra_id_12>print sp , lp ]<extra_id_13>if p[lp] > 2:<extra_id_14>2 : print sp, p[ print sp, lp except: break"], "original_ll": -1.1883025169372559, "sampled_ll": -0.5478832721710205, "all_perturbed_sampled_ll": [-1.6803535223007202], "all_perturbed_original_ll": [-2.3129286766052246], "perturbed_sampled_ll": -1.6803535223007202, "perturbed_original_ll": -2.3129286766052246, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(int argc, char *argv[]){\n  int prise,num;\n  long long int sum = 0;\n  int num_sum = 0;\n  int times = 0;\n  \n  while(scanf(\"%d,%d\",&prise,&num) != EOF){\n    sum += (long long int)(prise)*(long long int)(num);\n    num_sum += num;\n    ++times;\n  }\n\n  printf(\"%lld\\n%.0lf\\n\",sum,(double)(num_sum)/times);\n  \n  return 0;    \n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int price, quantity;\n    int total_sales = 0;\n    int total_quantity = 0;\n    int count = 0;\n    \n    while (scanf(\"%d,%d\", &price, &quantity) == 2) {\n        total_sales += price * quantity;\n        total_quantity += quantity;\n        count++;\n    }\n    \n    int average = (total_quantity + count / 2) / count;\n    \n    printf(\"%d\\n\", total_sales);\n    printf(\"%d\\n\", average);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int price, quantity; int total_sales = 0; int total_quantity = 0; int count = 0; while (scanf(\"%d,%d\", &price, &quantity) == 2) { total_sales += price * quantity; total_quantity += quantity;  / count; printf(\"%d\\n\", total_sales); printf(\"%d\\n\", average); return 0; }"], "perturbed_original": ["#include <stdio.h> int main(int argc, char *argv[]){ int prise,num; long long int  0; while(scanf(\"%d,%d\",&prise,&num) != EOF){ sum += (long long int)(prise)*(long long int)(num); num_sum += num; ++times; } printf(\"%lld\\n%.0lf\\n\",sum,(double)(num_sum)/times); return 0; }"], "original_ll": -1.5315985679626465, "sampled_ll": -0.9056623578071594, "all_perturbed_sampled_ll": [-1.5123401880264282], "all_perturbed_original_ll": [-2.173114061355591], "perturbed_sampled_ll": -1.5123401880264282, "perturbed_original_ll": -2.173114061355591, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tint count = 0;\n\t\tint sum = 0;\n\t\tint sum2 = 0;\n\t\twhile(stdIn.hasNext()) {\n\t\t\tcount++;\n\t\t\tString[] in = stdIn.next().split(\",\");\n\t\t\tint a = Integer.parseInt(in[0]);\n\t\t\tint b = Integer.parseInt(in[1]);\n\t\t\tsum += a*b;\n\t\t\tsum2 += b;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\tdouble ave = sum2/(double)count*10;\n\t\tif(ave%10 >= 5) {\n\t\t\tave += 10-ave%10;\n\t\t}\n\t\telse {\n\t\t\tave -= (ave*10)%10;\n\t\t}\n\t\tave /=10;\n\t\t\n\t\tSystem.out.println((int)ave);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int totalAmount = 0;\n        int totalQuantity = 0;\n        int count = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            int price = Integer.parseInt(parts[0]);\n            int quantity = Integer.parseInt(parts[1]);\n            \n            totalAmount += price * quantity;\n            totalQuantity += quantity;\n            count++;\n        }\n        \n        int averageQuantity = (int) Math.round((double) totalQuantity / count);\n        \n        System.out.println(totalAmount);\n        System.out.println(averageQuantity);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int totalAmount  while (sc.hasNextLine()) { String line = sc.nextLine(); if (line.isEmpty()) break; String[] parts = line.split(\",\"); int price = Integer.parseInt(parts[0]); int quantity = Integer.parseInt(parts[1]); totalAmount += price * quantity; totalQuantity +=  count); System.out.println(totalAmount); System.out.println(averageQuantity); sc.close(); } }"], "perturbed_original": ["import java.io.*; import java.util.ArrayList; import java.util.Arrays; import java.util.Scanner; public class Main { public static void  0; while(stdIn.hasNext()) { count++; String[] in = stdIn.next().split(\",\"); int a = Integer.parseInt(in[0]); int b = Integer.parseInt(in[1]); sum += a*b; sum2 += b; } System.out.println(sum); double ave = sum2/(double)count*10; if(ave%10 >= 5) { ave += 10-ave%10; } else { ave -= (ave*10)%10; } ave /=10; System.out.println((int)ave); } }"], "original_ll": -0.9452118873596191, "sampled_ll": -0.49470651149749756, "all_perturbed_sampled_ll": [-1.2524731159210205], "all_perturbed_original_ll": [-1.541886568069458], "perturbed_sampled_ll": -1.2524731159210205, "perturbed_original_ll": -1.541886568069458, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# _*_ coding: utf-8 _*_\n\nsum = 0\ntotal = 0\ncnt = 0\n\nwhile True:\n\ts = input()\n\t\n\tif s == '':\n\t\tbreak\n\t\n\tlist = s.split(',')\n\tsum += int(list[0])*int(list[1])\n\ttotal += int(list[1])\n\tcnt += 1\n\nave = total / cnt + 0.5\n\nprint(sum)\nprint(int(ave))", "sampled": "import sys\n\ntotal_amount = 0\ntotal_quantity = 0\ncount = 0\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        price, quantity = map(int, line.split(','))\n        total_amount += price * quantity\n        total_quantity += quantity\n        count += 1\n\naverage_quantity = round(total_quantity / count)\n\nprint(total_amount)\nprint(average_quantity)\n", "perturbed_sampled": ["import sys total_amount = 0 total_quantity =  line.strip() if line: price, quantity = map(int, line.split(',')) total_amount += price * quantity total_quantity += quantity count += 1 average_quantity = round(total_quantity / count) print(total_amount) print(average_quantity)"], "perturbed_original": ["# _*_ coding: utf-8 _*_ sum = 0 total = 0 cnt = 0 while True: s = input() if s == '': break  += 1 ave = total / cnt + 0.5 print(sum) print(int(ave))"], "original_ll": -1.3868882656097412, "sampled_ll": -0.7718766331672668, "all_perturbed_sampled_ll": [-2.011276960372925], "all_perturbed_original_ll": [-2.2014126777648926], "perturbed_sampled_ll": -2.011276960372925, "perturbed_original_ll": -2.2014126777648926, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void) {\n    double i,max,min;\n    scanf(\"%lf\",&max);\n    min=max;\n    while(1) {\n        if(scanf(\"%lf\",&i) == -0){\n            break;\n        }\n        if(i < min){\n            min = i;\n        }\n        if(i > max){\n            max = i;\n        }\n    }\n    printf(\"%f\\n\",max-min);\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double height;\n    double max = -1;\n    double min = 1000001;\n    \n    while (scanf(\"%lf\", &height) == 1) {\n        if (height > max) {\n            max = height;\n        }\n        if (height < min) {\n            min = height;\n        }\n    }\n    \n    printf(\"%.1f\\n\", max - min);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double height; double  == 1) { if (height > max) { max = height; } if (height < min) { min = height; } } printf(\"%.1f\\n\", max - min); return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { double i,max,min; scanf(\"%lf\",&max); min=max; while(1) { if(scanf(\"%lf\",&i) == -0){ break; } if(i < min){ min =  printf(\"%f\\n\",max-min); return 0; }"], "original_ll": -1.170035481452942, "sampled_ll": -0.8074646592140198, "all_perturbed_sampled_ll": [-1.7991557121276855], "all_perturbed_original_ll": [-2.220747470855713], "perturbed_sampled_ll": -1.7991557121276855, "perturbed_original_ll": -2.220747470855713, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tdouble height = Double.MIN_VALUE,min = Double.MAX_VALUE;\n\t\twhile(scan.hasNext()) {\n\t\t\tdouble mount = scan.nextDouble();\n\t\t\tif(height < mount) {\n\t\t\t\theight = mount;\n\t\t\t}\n\t\t\tif(min > mount) {\n\t\t\t\tmin = mount;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(height - min);\n\t\tscan.close();\n\t}\n}\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        double max = Double.MIN_VALUE;\n        double min = Double.MAX_VALUE;\n        \n        while (sc.hasNextDouble()) {\n            double height = sc.nextDouble();\n            if (height > max) {\n                max = height;\n            }\n            if (height < min) {\n                min = height;\n            }\n        }\n        \n        double diff = max - min;\n        System.out.println(diff);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  = Double.MAX_VALUE; while (sc.hasNextDouble()) { double height = sc.nextDouble(); if (height > max) { max = height; } if (height < min) { min = height; } } double diff = max - min; System.out.println(diff); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scan = new Scanner(System.in); double height = Double.MIN_VALUE,min = Double.MAX_VALUE; while(scan.hasNext()) { double mount = scan.nextDouble(); if(height < mount) { height = mount; } if(min > mount)  } }"], "original_ll": -0.8598654866218567, "sampled_ll": -0.5299980044364929, "all_perturbed_sampled_ll": [-1.4029805660247803], "all_perturbed_original_ll": [-1.560131549835205], "perturbed_sampled_ll": -1.4029805660247803, "perturbed_original_ll": -1.560131549835205, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "fir=0\nsec=0\n\nwhile True:\n        try:\n                a=raw_input()\n                if a >= fir:\n                        sec = fir\n                        fir = a\n                elif a >= sec:\n                        sec = a\n        except EOFError:\n                break\n\nprint fir-sec", "sampled": "import sys\n\nheights = []\nfor line in sys.stdin:\n    heights.append(float(line.strip()))\n\nprint(max(heights) - min(heights))\n", "perturbed_sampled": ["import sys heights = [] for line in sys.stdin: heights.append(float(line.strip())) print(max(heights) - min(heights))"], "perturbed_original": ["fir=0 sec=0 while True: try: a=raw_input() if a >= fir: sec = fir fir = a elif a >= sec: sec = a except EOFError: break print fir-sec"], "original_ll": -1.8585329055786133, "sampled_ll": -1.4075459241867065, "all_perturbed_sampled_ll": [-1.9354603290557861], "all_perturbed_original_ll": [-2.971318244934082], "perturbed_sampled_ll": -1.9354603290557861, "perturbed_original_ll": -2.971318244934082, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\tint ball[3];\n\tint x,y,temp;\n\tchar a,b;\n\tball[0]=1;ball[1]=0;ball[2]=0;\n\twhile(scanf(\"%c,%c\",&a,&b)!=EOF){\n\t\tswitch(a){\n\t\tcase 'A':x=0;break;\n\t\tcase 'B':x=1;break;\n\t\tcase 'C':x=2;break;\n\t\t}\n\t\tswitch(b){\n\t\tcase 'A':y=0;break;\n\t\tcase 'B':y=1;break;\n\t\tcase 'C':y=2;break;\n\t\t}\n\t\ttemp=ball[x];ball[x]=ball[y];ball[y]=temp;\n\t}\n\tif(ball[0]==1){\n\t\tprintf(\"A\\n\");\n\t}else if(ball[1]==1){\n\t\tprintf(\"B\\n\");\n\t}else{printf(\"C\\n\");}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    char ball = 'A';\n    char line[10];\n    \n    while (fgets(line, sizeof(line), stdin) != NULL) {\n        char pos1 = line[0];\n        char pos2 = line[2];\n        \n        if (ball == pos1) {\n            ball = pos2;\n        } else if (ball == pos2) {\n            ball = pos1;\n        }\n    }\n    \n    printf(\"%c\\n\", ball);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() {  != NULL) { char pos1 = line[0]; char pos2 = line[2]; if (ball == pos1) { ball = pos2; } else if (ball == pos2) { ball = pos1; } } printf(\"%c\\n\", ball); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){  'A':x=0;break; case 'B':x=1;break; case 'C':x=2;break; } switch(b){ case 'A':y=0;break; case 'B':y=1;break; case 'C':y=2;break; } temp=ball[x];ball[x]=ball[y];ball[y]=temp; } if(ball[0]==1){ printf(\"A\\n\"); }else if(ball[1]==1){ printf(\"B\\n\"); }else{printf(\"C\\n\");} return 0; }"], "original_ll": -0.7393728494644165, "sampled_ll": -0.8172886967658997, "all_perturbed_sampled_ll": [-1.5817680358886719], "all_perturbed_original_ll": [-1.2459607124328613], "perturbed_sampled_ll": -1.5817680358886719, "perturbed_original_ll": -1.2459607124328613, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s;\n\t\tString[] t;\n\t\tint[] location=new int[3];\n\t\tlocation[0]=1;\n\t\tlocation[1]=0;\n\t\tlocation[2]=0;\n\t\tint alt;\n\t\tint[] number=new int[2];\n\t\twhile((s=reader.readLine())!=null){\n\t\t\tif(s.isEmpty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(s==\"\"){break;}\n\t\t\tt=s.split(\",\");\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tif(t[i]==\"A\"){number[i]=0;}\n\t\t\t\t\telse if(t[i]==\"B\"){number[i]=1;}\n\t\t\t\t\telse if(t[i]==\"C\"){number[i]=2;}\t\n\t\t\t}\n\t\t\talt=location[number[0]];\n\t\t\tlocation[number[0]]=location[number[1]];\n\t\t\tlocation[number[1]]=alt;\n\t\t}\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tif(location[j]==1){\n\t\t\t\t\tswitch(j){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tSystem.out.println(\"A\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tSystem.out.println(\"B\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tSystem.out.println(\"C\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        char ball = 'A';\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] positions = line.split(\",\");\n            char pos1 = positions[0].charAt(0);\n            char pos2 = positions[1].charAt(0);\n            \n            if (ball == pos1) {\n                ball = pos2;\n            } else if (ball == pos2) {\n                ball = pos1;\n            }\n        }\n        \n        System.out.println(ball);\n        sc.close();\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in);  sc.nextLine().trim(); if (line.isEmpty()) break; String[] positions = line.split(\",\"); char pos1 = positions[0].charAt(0); char pos2 = positions[1].charAt(0); if (ball == pos1) { ball = pos2; } else if (ball == pos2) { ball = pos1; } } System.out.println(ball); sc.close(); } }"], "perturbed_original": ["import java.io.*; public class Main{ public static void main(String[] args)throws IOException{ BufferedReader reader=new BufferedReader(new InputStreamReader(System.in)); String s; String[] t; int[] location=new int[3]; location[0]=1; location[1]=0; location[2]=0; int alt; int[] number=new int[2]; while((s=reader.readLine())!=null){ if(s.isEmpty()){ break; } if(s==\"\"){break;} t=s.split(\",\"); for(int i=0;i<2;i++){ if(t[i]==\"A\"){number[i]=0;} else if(t[i]==\"B\"){number[i]=1;} else if(t[i]==\"C\"){number[i]=2;} } alt=location[number[0]]; location[number[0]]=location[number[1]]; <extra_id_1>2 ]; if(num[3]!=4){<extra_id_2>case<extra_id_3>; location[num]=0;<extra_id_4>case<extra_id_5>case<extra_id_6>case<extra_id_7>2<extra_id_8>case<extra_id_9>; case case } }<extra_id_10>int [] data )<extra_id_11>== null ) continue<extra_id_12>} } } } } }"], "original_ll": -0.7999553680419922, "sampled_ll": -0.6121368408203125, "all_perturbed_sampled_ll": [-1.3599750995635986], "all_perturbed_original_ll": [-1.7488070726394653], "perturbed_sampled_ll": -1.3599750995635986, "perturbed_original_ll": -1.7488070726394653, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nimport itertools\n\nA = [1, 0, 0]\n\nfor s in sys.stdin:\n    s = s.strip()\n    a, b = s.split(',')\n\n    if a == 'A':\n        i = 0\n    elif a == 'B':\n        i = 1\n    elif a == 'C':\n        i = 2\n\n    if b == 'A':\n        j = 0\n    elif b == 'B':\n        j = 1\n    elif b == 'C':\n        j = 2\n\n    A[i], A[j] = A[j], A[i]\n\nif A[0] == 1:\n    print('A')\nelif A[1] == 1:\n    print('B')\nelse:\n    print('C')", "sampled": "import sys\n\nball_position = 'A'\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    pos1, pos2 = line.split(',')\n    \n    if ball_position == pos1:\n        ball_position = pos2\n    elif ball_position == pos2:\n        ball_position = pos1\n\nprint(ball_position)\n", "perturbed_sampled": ["import sys ball_position = 'A' for line in sys.stdin: line = line.strip() if not line:  = pos2 elif ball_position == pos2: ball_position = pos1 print(ball_position)"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys import os import math import itertools A = [1, 0, 0] for s in sys.stdin: s = s.strip() a, b = s.split(',') if a  = 1 elif a == 'C': i = 2 if b == 'A': j = 0 elif b ==  2 A[i], A[j] = A[j], A[i] if A[0] == 1: print('A') elif A[1] == 1: print('B') else: print('C')"], "original_ll": -0.6653038859367371, "sampled_ll": -0.9812659621238708, "all_perturbed_sampled_ll": [-2.860198736190796], "all_perturbed_original_ll": [-1.6696721315383911], "perturbed_sampled_ll": -2.860198736190796, "perturbed_original_ll": -1.6696721315383911, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tfloat g;\n\t\n\tscanf(\"%f\", &g);\n\t\n\tif (g <= 48.00){\n\t\tprintf(\"light fly\\n\");\n\t}\n\telse if ((48.00 < g)&&(g <= 51.00)){\n\t\tprintf(\"fly\\n\");\n\t}\n\telse if ((51.00 < g)&&(g <= 54.00)){\n\t\tprintf(\"bantam\\n\");\n\t}\n\telse if ((54.00 < g)&&(g <= 57.00)){\n\t\tprintf(\"feather\\n\");\n\t}\n\telse if ((57.00 < g)&&(g <= 60.00)){\n\t\tprintf(\"light\\n\");\n\t}\n\telse if ((60.00 < g)&&(g <= 64.00)){\n\t\tprintf(\"light welter\\n\");\n\t}\n\telse if ((64.00 < g)&&(g <= 69.00)){\n\t\tprintf(\"welter\\n\");\n\t}\n\telse if ((69.00 < g)&&(g <= 75.00)){\n\t\tprintf(\"light middle\\n\");\n\t}\n\telse if ((75.00 < g)&&(g <= 81.00)){\n\t\tprintf(\"middle\\n\");\n\t}\n\telse if ((81.00 < g)&&(g <= 91.00)){\n\t\tprintf(\"light heavy\\n\");\n\t}\n\telse if (91.00 < g){\n\t\tprintf(\"heavy\\n\");\n\t}\n\t\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double w;\n    \n    while (scanf(\"%lf\", &w) != EOF) {\n        if (w <= 48.00) {\n            printf(\"light fly\\n\");\n        } else if (w <= 51.00) {\n            printf(\"fly\\n\");\n        } else if (w <= 54.00) {\n            printf(\"bantam\\n\");\n        } else if (w <= 57.00) {\n            printf(\"feather\\n\");\n        } else if (w <= 60.00) {\n            printf(\"light\\n\");\n        } else if (w <= 64.00) {\n            printf(\"light welter\\n\");\n        } else if (w <= 69.00) {\n            printf(\"welter\\n\");\n        } else if (w <= 75.00) {\n            printf(\"light middle\\n\");\n        } else if (w <= 81.00) {\n            printf(\"middle\\n\");\n        } else if (w <= 91.00) {\n            printf(\"light heavy\\n\");\n        } else {\n            printf(\"heavy\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double w; while (scanf(\"%lf\", &w) !=  else if (w <= 51.00) { printf(\"fly\\n\"); } else if (w <= 54.00) { printf(\"bantam\\n\"); } else if (w <= 57.00) { printf(\"feather\\n\"); } else if (w <= 60.00) { printf(\"light\\n\"); }  if (w <= 69.00) { printf(\"welter\\n\"); } else if (w <= 75.00) { printf(\"light middle\\n\"); }  (w <= 91.00) { printf(\"light heavy\\n\"); } else { printf(\"heavy\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { float g; scanf(\"%f\", &g); if (g  <= 51.00)){ printf(\"fly\\n\"); } else if ((51.00 < g)&&(g <= 54.00)){ printf(\"bantam\\n\"); } else if ((54.00 < g)&&(g <= 57.00)){ printf(\"feather\\n\"); } else if ((57.00 <  <= 64.00)){ printf(\"light welter\\n\"); } else if ((64.00 < g)&&(g <= 69.00)){ printf(\"welter\\n\"); } else if ((69.00 < g)&&(g <= 75.00)){ printf(\"light middle\\n\"); } else if ((75.00 < g)&&(g <= 81.00)){ printf(\"middle\\n\"); } else if ((81.00 < g)&&(g <= 91.00)){  return (0); }"], "original_ll": -0.6938264966011047, "sampled_ll": -0.7214959859848022, "all_perturbed_sampled_ll": [-1.2968263626098633], "all_perturbed_original_ll": [-1.131852149963379], "perturbed_sampled_ll": -1.2968263626098633, "perturbed_original_ll": -1.131852149963379, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str;\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\twhile((str=br.readLine())!=null){\n\t\t\tlist.add(check(Double.parseDouble(str)));\n\t\t}\n\t\tfor(String d : list){\n\t\t\tSystem.out.println(d);\n\t\t}\n\t\t\n\t}\n\tpublic static String check(double weight){\n\t\tif(weight > 91.0){\n            return \"heavy\";\n        }\n        else if(weight > 81.0){\n            return \"light heavy\";\n        }\n        else if(weight > 75.0){\n            return \"middle\";\n        }\n        else if(weight > 69.0){\n            return \"light middle\";\n        }\n        else if(weight > 64.0){\n            return \"welter\";\n        }\n        else if(weight > 60.0){\n            return \"light welter\";\n        }\n        else if(weight > 57.0){\n            return \"light\";\n        }\n        else if(weight > 54.0){\n            return \"feather\";\n        }\n        else if(weight > 51.0){\n            return \"bantam\";\n        }\n        else if(weight > 48.0){\n            return \"fly\";\n        }\n        else{\n            return \"light fly\";\n        }\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double w = sc.nextDouble();\n            \n            if (w <= 48.00) {\n                System.out.println(\"light fly\");\n            } else if (w <= 51.00) {\n                System.out.println(\"fly\");\n            } else if (w <= 54.00) {\n                System.out.println(\"bantam\");\n            } else if (w <= 57.00) {\n                System.out.println(\"feather\");\n            } else if (w <= 60.00) {\n                System.out.println(\"light\");\n            } else if (w <= 64.00) {\n                System.out.println(\"light welter\");\n            } else if (w <= 69.00) {\n                System.out.println(\"welter\");\n            } else if (w <= 75.00) {\n                System.out.println(\"light middle\");\n            } else if (w <= 81.00) {\n                System.out.println(\"middle\");\n            } else if (w <= 91.00) {\n                System.out.println(\"light heavy\");\n            } else {\n                System.out.println(\"heavy\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  = new Scanner(System.in); while (sc.hasNext()) { double w = sc.nextDouble(); if (w <= 48.00) { System.out.println(\"light fly\"); } else if (w <= 51.00) { System.out.println(\"fly\"); } else if (w <= 54.00) { System.out.println(\"bantam\"); }  (w <= 60.00) { System.out.println(\"light\");  else if (w <= 69.00) { System.out.println(\"welter\"); } else if (w <= 75.00) { System.out.println(\"light middle\"); } else if (w <= 81.00) { System.out.println(\"middle\"); } else if (w <= 91.00) { System.out.println(\"light heavy\"); } else { System.out.println(\"heavy\"); } } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList;  BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str; ArrayList<String> list = new ArrayList<String>(); while((str=br.readLine())!=null){ list.add(check(Double.parseDouble(str))); } for(String d : list){ System.out.println(d); } } public static String check(double weight){ if(weight > 91.0){ return \"heavy\"; } else if(weight > 81.0){ return \"light heavy\"; } else if(weight  \"light middle\"; } else if(weight > 64.0){ return \"welter\"; } else if(weight > 60.0){ return \"light welter\"; } else if(weight > 57.0){ return \"light\"; } else if(weight > 54.0){ return \"feather\";  > 48.0){ return \"fly\"; } else{ return \"light fly\"; } } }"], "original_ll": -0.7446013689041138, "sampled_ll": -0.6390803456306458, "all_perturbed_sampled_ll": [-1.1548409461975098], "all_perturbed_original_ll": [-1.2907826900482178], "perturbed_sampled_ll": -1.1548409461975098, "perturbed_original_ll": -1.2907826900482178, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from decimal import Decimal\nimport sys\n\ndef classify(w):\n    if w <= Decimal(\"48.00\"):\n        return \"light fly\"\n    elif Decimal(\"48.00\") < w <= Decimal(\"51.00\"):\n        return \"fly\"\n    elif Decimal(\"51.00\") < w <= Decimal(\"54.00\"):\n        return \"bantam\"\n    elif Decimal(\"54.00\") < w <= Decimal(\"57.00\"):\n        return \"feather\"\n    elif Decimal(\"57.00\") < w <= Decimal(\"60.00\"):\n        return \"light\"\n    elif Decimal(\"60.00\") < w <= Decimal(\"64.00\"):\n        return \"light welter\"\n    elif Decimal(\"64.00\") < w <= Decimal(\"69.00\"):\n        return \"welter\"\n    elif Decimal(\"69.00\") < w <= Decimal(\"75.00\"):\n        return \"light middle\"\n    elif Decimal(\"75.00\") < w <= Decimal(\"81.00\"):\n        return \"middle\"\n    elif Decimal(\"81.00\") < w <= Decimal(\"91.00\"):\n        return \"light heavy\"\n    else:\n        return \"heavy\"\n    \n[print(classify(Decimal(j))) for j in [i for i in sys.stdin]]\n\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    w = float(line.strip())\n    \n    if w <= 48.00:\n        print(\"light fly\")\n    elif w <= 51.00:\n        print(\"fly\")\n    elif w <= 54.00:\n        print(\"bantam\")\n    elif w <= 57.00:\n        print(\"feather\")\n    elif w <= 60.00:\n        print(\"light\")\n    elif w <= 64.00:\n        print(\"light welter\")\n    elif w <= 69.00:\n        print(\"welter\")\n    elif w <= 75.00:\n        print(\"light middle\")\n    elif w <= 81.00:\n        print(\"middle\")\n    elif w <= 91.00:\n        print(\"light heavy\")\n    else:\n        print(\"heavy\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: w = float(line.strip()) if w <= 48.00: print(\"light fly\") elif w <= 51.00: print(\"fly\") elif w <= 54.00: print(\"bantam\") elif  w <= 64.00: print(\"light welter\") elif w <= 69.00: print(\"welter\") elif w <= 75.00: print(\"light middle\") elif w <= 81.00: print(\"middle\") elif w <= 91.00: print(\"light heavy\") else: print(\"heavy\")"], "perturbed_original": ["from decimal import  \"light fly\" elif Decimal(\"48.00\") < w <= Decimal(\"51.00\"): return \"fly\" elif Decimal(\"51.00\") < w <= Decimal(\"54.00\"): return \"bantam\" elif Decimal(\"54.00\") < w <= Decimal(\"57.00\"): return \"feather\" elif Decimal(\"57.00\") < w <= Decimal(\"60.00\"): return \"light\" elif Decimal(\"60.00\") < w <= Decimal(\"64.00\"): return \"light welter\" elif Decimal(\"64.00\") < w <= Decimal(\"69.00\"):  middle\"  < w <= Decimal(\"91.00\"): return \"light heavy\" else: return \"heavy\" [print(classify(Decimal(j))) for j in [i for i in sys.stdin]]"], "original_ll": -0.75665682554245, "sampled_ll": -0.9437844753265381, "all_perturbed_sampled_ll": [-1.2745698690414429], "all_perturbed_original_ll": [-1.648665189743042], "perturbed_sampled_ll": -1.2745698690414429, "perturbed_original_ll": -1.648665189743042, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol0 0049: Blood Groups\n// 2017.7.29\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar *gets(char *);\n\n#define MAX 50\n\nint blood[MAX + 5];\nint cnt[5];\n\nint main()\n{\n\tchar buf[100], *p;\n\tint k, t;\n\n\tfor (k = 0; k <= MAX; k++) blood[k] = 0;\n\tfor (k = 1; k < 5; k++) cnt[k] = 0;\n\twhile (gets(buf) != NULL) {\n\t\tp = buf;\n\n\t\twhile (isspace(*p)) p++;\n\t\tk = *p++ - '0';\n\t\tif (isdigit(*p)) k = k * 10 + (*p++ - '0');\n\n\t\twhile (isspace(*p)) p++;  // ','\n\t\tp++;\n\n\t\twhile (isspace(*p)) p++;\n\t\tif (*p == 'A' && *(p + 1) == 'B') t = 3;\n\t\telse if (*p == 'B') t = 2;\n\t\telse if (*p == 'O') t = 4;\n\t\telse t = 1;\n\n\t\tif (blood[k] == 0) {\n\t\t\tblood[k] = t;\n\t\t\tcnt[t]++;\n\t\t} else if (blood[k] != t) while (1);\n\t}\n\tfor (k = 1; k < 5; k++) printf(\"%d\\n\", cnt[k]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int num;\n    char blood[10];\n    int countA = 0, countB = 0, countAB = 0, countO = 0;\n    \n    while (scanf(\"%d,%s\", &num, blood) == 2) {\n        if (strcmp(blood, \"A\") == 0) {\n            countA++;\n        } else if (strcmp(blood, \"B\") == 0) {\n            countB++;\n        } else if (strcmp(blood, \"AB\") == 0) {\n            countAB++;\n        } else if (strcmp(blood, \"O\") == 0) {\n            countO++;\n        }\n    }\n    \n    printf(\"%d\\n\", countA);\n    printf(\"%d\\n\", countB);\n    printf(\"%d\\n\", countAB);\n    printf(\"%d\\n\", countO);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int num; char blood[10]; int countA = 0, countB = 0, countAB = 0, countO = 0; while (scanf(\"%d,%s\", &num, blood) == 2) { if (strcmp(blood, \"A\") == 0) { countA++; } else if (strcmp(blood, \"B\") == 0) {  } } printf(\"%d\\n\", countA); printf(\"%d\\n\", countB); printf(\"%d\\n\", countAB); printf(\"%d\\n\", countO); return 0; }"], "perturbed_original": ["// Aizu Vol0 0049: Blood Groups // 2017.7.29 #include <stdio.h> #include <stdlib.h> #include <ctype.h> char *gets(char *); #define MAX 50 int blood[MAX + 5]; int  for (k = 0; k <= MAX; k++) blood[k] = 0; for (k = 1; k < 5; k++)  if (isdigit(*p)) k = k * 10 + (*p++ - '0'); while (isspace(*p)) p++; // ',' p++; while (isspace(*p)) p++; if (*p == 'A' && *(p + 1) == 'B') t = 3; else  == 'O') t = 4; else t = 1; if (blood[k] == 0) { blood[k] = t; cnt[t]++; } else if (blood[k] != t) while (1); } for (k = 1; k < 5; k++) printf(\"%d\\n\", cnt[k]); return 0; }"], "original_ll": -1.144757628440857, "sampled_ll": -0.43018639087677, "all_perturbed_sampled_ll": [-0.8019938468933105], "all_perturbed_original_ll": [-1.6727195978164673], "perturbed_sampled_ll": -0.8019938468933105, "perturbed_original_ll": -1.6727195978164673, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint[] abo = {0,0,0,0};\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString tmp = null;\n\t\tint cup = 0;\n\t\tint mun = 0;\n\t\tint ter = 0;\n\t\tString[] rrr;\n\t\tint st = 0,sr = 0;\n\t\tint mon = 0;\n\t\tint syo=0,hisi=0;\n\t\t\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\ttry {\n\t\t\t\ttmp = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp == null){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp.equals(\"\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trrr = tmp.split(\",\");\n\t\t\t\n\t\t\tif(rrr[1].equals(\"A\")){\n\t\t\t\tabo[0]++;\n\t\t\t}else if(rrr[1].equals(\"B\")){\n\t\t\t\tabo[1]++;\n\t\t\t}else if(rrr[1].equals(\"AB\")){\n\t\t\t\tabo[2]++;\n\t\t\t}else if(rrr[1].equals(\"O\")){\n\t\t\t\tabo[3]++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(abo[0]);\n\t\tSystem.out.println(abo[1]);\n\t\tSystem.out.println(abo[2]);\n\t\tSystem.out.println(abo[3]);\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int countA = 0;\n        int countB = 0;\n        int countAB = 0;\n        int countO = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            String bloodType = parts[1];\n            \n            switch (bloodType) {\n                case \"A\":\n                    countA++;\n                    break;\n                case \"B\":\n                    countB++;\n                    break;\n                case \"AB\":\n                    countAB++;\n                    break;\n                case \"O\":\n                    countO++;\n                    break;\n            }\n        }\n        \n        System.out.println(countA);\n        System.out.println(countB);\n        System.out.println(countAB);\n        System.out.println(countO);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int countA = 0; int countB = 0; int countAB <extra_id_10>;<extra_id_11>=<extra_id_12>int countO<extra_id_13>//countAB++; if(countO++*100<extra_id_14>new int[] c =<extra_id_15> line = sc.nextLine(); if (line.isEmpty()) break; String[] parts = line.split(\",\"); String bloodType  \"B\": countB++; break; case \"AB\": countAB++; break; case \"O\": countO++; break; } } System.out.println(countA); System.out.println(countB); System.out.println(countAB); System.out.println(countO); sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader;  abo = {0,0,0,0}; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String tmp = null; int cup = 0; int mun = 0; int ter = 0; String[] rrr; int st = 0,sr = 0; int mon = 0; int syo=0,hisi=0; while(true){ try { tmp = br.readLine(); } catch (IOException e) { // TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af e.printStackTrace();  abo[2]++; }else if(rrr[1].equals(\"O\")){ abo[3]++; } } System.out.println(abo[0]); System.out.println(abo[1]); System.out.println(abo[2]); System.out.println(abo[3]); } }"], "original_ll": -0.9485359191894531, "sampled_ll": -0.4884323179721832, "all_perturbed_sampled_ll": [-1.8395100831985474], "all_perturbed_original_ll": [-1.8597495555877686], "perturbed_sampled_ll": -1.8395100831985474, "perturbed_original_ll": -1.8597495555877686, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\na = 0\nb = 0\nab = 0\no = 0\nfor i in sys.stdin.readlines():\n    if i.find(\",AB\") > -1:\n        ab += 1\n    elif i.find(\",B\") > -1:\n        b += 1\n    elif i.find(\",A\") >-1:\n        a += 1\n    else:\n        o += 1\nprint(a)\nprint(b)\nprint(ab)\nprint(o)", "sampled": "import sys\n\ncount = {'A': 0, 'B': 0, 'AB': 0, 'O': 0}\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        parts = line.split(',')\n        blood_type = parts[1]\n        count[blood_type] += 1\n\nprint(count['A'])\nprint(count['B'])\nprint(count['AB'])\nprint(count['O'])\n", "perturbed_sampled": ["import sys count = {'A': 0, 'B': 0, 'AB': 0, 'O': 0} for line in sys.stdin: line = line.strip()  1 print(count['A']) print(count['B']) print(count['AB']) print(count['O'])"], "perturbed_original": ["import sys a = 0 b = 0 ab = 0 o = 0 for i in sys.stdin.readlines(): if i.find(\",AB\") > -1: ab += 1 elif i.find(\",B\") > -1:  o += 1 print(a) print(b) print(ab) print(o)"], "original_ll": -1.0676217079162598, "sampled_ll": -1.0100289583206177, "all_perturbed_sampled_ll": [-1.528770089149475], "all_perturbed_original_ll": [-1.8096081018447876], "perturbed_sampled_ll": -1.528770089149475, "perturbed_original_ll": -1.8096081018447876, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void){\n\tchar text[1002],i,n;\n\tfgets(text,1002,stdin);\n\tn=strlen(text);\n\tfor(i=0;i<n-5;i++){\n\t\tif(text[i]=='a' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){\n\t\t\ttext[i]='p';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h';\n\t\t}\n\t\telse if(text[i]=='p' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){\n\t\t\ttext[i]='a';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e';\n\t\t}\n\t\tif(text[i]=='A' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){\n\t\t\ttext[i]='P';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h';\n\t\t}\n\t\telse if(text[i]=='P' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){\n\t\t\ttext[i]='A';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e';\n\t\t}\n\t}\n\tprintf(\"%s\",text);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[1001];\n    char result[10001];\n    int i, j;\n    \n    fgets(line, sizeof(line), stdin);\n    \n    i = 0;\n    j = 0;\n    while (line[i] != '\\0' && line[i] != '\\n') {\n        if (strncmp(&line[i], \"apple\", 5) == 0) {\n            strcpy(&result[j], \"peach\");\n            j += 5;\n            i += 5;\n        } else if (strncmp(&line[i], \"peach\", 5) == 0) {\n            strcpy(&result[j], \"apple\");\n            j += 5;\n            i += 5;\n        } else {\n            result[j] = line[i];\n            j++;\n            i++;\n        }\n    }\n    result[j] = '\\0';\n    \n    printf(\"%s\\n\", result);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char line[1001]; char result[10001]; int i, j; fgets(line, sizeof(line), stdin); i  line[i] != '\\n') { if (strncmp(&line[i], \"apple\", 5) == 0) { strcpy(&result[j], \"peach\"); j += 5; i += 5; } else if (strncmp(&line[i], \"peach\", 5) == 0) { strcpy(&result[j], \"apple\"); j += 5; i  } } result[j] = '\\0'; printf(\"%s\\n\", result); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int (String text[])<extra_id_1>{ return sprintf(\"%s\",text);<extra_id_2>[<extra_id_3>] }<extra_id_4>, int text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){ text[i]='p';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h'; } else if(text[i]=='p' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){ text[i]='a';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e'; } if(text[i]=='A' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){ text[i]='P';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h'; } else if(text[i]=='P' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){ text[i]='A';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e'; } } printf(\"%s\",text); return 0; }"], "original_ll": -0.4309473931789398, "sampled_ll": -0.5426062941551208, "all_perturbed_sampled_ll": [-1.1776669025421143], "all_perturbed_original_ll": [-0.9417614340782166], "perturbed_sampled_ll": -1.1776669025421143, "perturbed_original_ll": -0.9417614340782166, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tStringBuilder ans = new StringBuilder();\n\t\twhile(in.hasNext()) {\n\t\t\tString x = in.next();\n\t\t\tif(x.contains(\"apple\"))\n\t\t\t\tans.append(x.replace(\"apple\",\"peach\")).append(\" \");\n\t\t\telse if(x.contains(\"peach\"))\n\t\t\t\tans.append(x.replace(\"peach\",\"apple\")).append(\" \");\n\t\t\telse\n\t\t\t\tans.append(x).append(\" \");\n\t\t}\n\t\tSystem.out.println(ans.toString().trim());\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        \n        String result = line.replace(\"apple\", \"TEMP\")\n                           .replace(\"peach\", \"apple\")\n                           .replace(\"TEMP\", \"peach\");\n        \n        System.out.println(result);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  Scanner sc = new Scanner(System.in); String line = sc.nextLine(); String result = line.replace(\"apple\", \"TEMP\") .replace(\"peach\", \"apple\") .replace(\"TEMP\", \"peach\"); System.out.println(result); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public  StringBuilder ans = new StringBuilder(); while(in.hasNext()) { String x = in.next(); if(x.contains(\"apple\")) ans.append(x.replace(\"apple\",\"peach\")).append(\" \"); else if(x.contains(\"peach\")) ans.append(x.replace(\"peach\",\"apple\")).append(\" \"); else ans.append(x).append(\" \"); } System.out.println(ans.toString().trim()); } }"], "original_ll": -0.7529372572898865, "sampled_ll": -1.2295308113098145, "all_perturbed_sampled_ll": [-1.957695484161377], "all_perturbed_original_ll": [-1.3025614023208618], "perturbed_sampled_ll": -1.957695484161377, "perturbed_original_ll": -1.3025614023208618, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nsent = map(str, raw_input().split(' '))\n\nfor i in range(len(sent)):\n    if sent[i] == 'apple' :\n        sent[i] = 'peach'\n    elif sent[i] == 'peach':\n        sent[i] = 'apple'\n\n    elif sent[i] == 'apple,' :\n        sent[i] = 'peach,'\n    elif sent[i] == 'peach,':\n        sent[i] = 'apple,'\n\n    elif sent[i] == 'apple.' :\n        sent[i] = 'peach.'\n    elif sent[i] == 'peach.':\n        sent[i] = 'apple.'\n\n    elif sent[i] == 'apple!' :\n        sent[i] = 'peach!'\n    elif sent[i] == 'peach!':\n        sent[i] = 'apple!'\n\n    elif sent[i] == 'apple?' :\n        sent[i] = 'peach?'\n    elif sent[i] == 'peach?':\n        sent[i] = 'apple?'\n\n \n\n\n\nfor sen in sent:\n    print sen,\n    ", "sampled": "s = input()\ns = s.replace('apple', '@TEMP@').replace('peach', 'apple').replace('@TEMP@', 'peach')\nprint(s)\n", "perturbed_sampled": ["s = input() s = s.replace('apple', '@TEMP@').replace('peach', 'apple').replace('@TEMP@', 'peach') print(s)"], "perturbed_original": ["sent = map(str, raw_input().split(' ')) for i  elif sent[i] == 'peach': sent[i] = 'apple' elif sent[i] == 'apple,' : sent[i] = 'peach,' elif sent[i] == 'peach,': sent[i] = 'apple,' elif sent[i] == 'apple.' : sent[i] = 'peach.' elif sent[i] == 'peach.': sent[i] = 'apple.' elif sent[i] == 'apple!' : sent[i] = 'peach!' elif sent[i] == 'peach!': sent[i]  elif sent[i] == 'peach?': sent[i] = 'apple?' for sen in sent: print sen,"], "original_ll": -0.7041298747062683, "sampled_ll": -2.0857276916503906, "all_perturbed_sampled_ll": [-2.3305094242095947], "all_perturbed_original_ll": [-1.3471487760543823], "perturbed_sampled_ll": -2.3305094242095947, "perturbed_original_ll": -1.3471487760543823, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  long a,b,i,n;\n\n  while(scanf(\"%ld\",&n),n!=0){\n    a=0;\n    for(i=5;i<=n;i++){\n      b=i;\n      while(b>0){\n        if(b%5!=0) break;\n        a++;\n        b=b/5;\n      }\n    }\n    printf(\"%ld\\n\",a);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int count = 0;\n        int temp = n;\n        \n        while(temp >= 5) {\n            temp /= 5;\n            count += temp;\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) { scanf(\"%d\", &n); if(n == 0) break; int count = 0;  5; count += temp; } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ long a,b,i,n; while(scanf(\"%ld\",&n),n!=0){ a=0; for(i=5;i<=n;i++){ b=i; while(b>0){ if(b%5!=0) break; a++; b=b/5; } } printf(\"%ld\\n\",a); } return 0; }"], "original_ll": -1.1651694774627686, "sampled_ll": -0.6737091541290283, "all_perturbed_sampled_ll": [-1.4789150953292847], "all_perturbed_original_ll": [-1.3386293649673462], "perturbed_sampled_ll": -1.4789150953292847, "perturbed_original_ll": -1.3386293649673462, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Scanner;\npublic class Main {\n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakePrimeList();\n\t\twhile(true) {\n\t\t\tint a = stdIn.nextInt();\n\t\t\tif(a == 0) break;\n\t\t\tint c2 = 0;\n\t\t\tint c5 = 0;\n\t\t\tfor(int i = a; i >= 1; i--) {\n\t\t\t\tint[] ret = f(i);\n\t\t\t\tc2 += ret[0];\n\t\t\t\tc5 += ret[2];\n\t\t\t}\n\t\t\tint count = Math.min(c2, c5);\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tpublic static void makePrimeList() {\n\t\tboolean[] isntPrime = new boolean[20001];\n\t\tisntPrime[0] = isntPrime[1] = true;\n\t\tlist.add(2);\n\t\tfor(int i = 3; i < 20001; i+= 2) {\n\t\t\tif(!isntPrime[i]) {\n\t\t\t\tlist.add(i);\n\t\t\t\tfor(int j = i + i; j < 20001; j+= i) {\n\t\t\t\t\tisntPrime[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int[] f(int a) {\n\t\tint[] ret = new int[list.size()];\n\t\twhile(a > 1) {\n\t\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\t\tif(a % list.get(i) == 0) {\n\t\t\t\t\ta /= list.get(i);\n\t\t\t\t\tret[i]++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\t\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            int temp = n;\n            while (temp > 0) {\n                temp /= 5;\n                count += temp;\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int  0) { temp /= 5; count += temp; } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.io.*; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.Scanner; public class Main  main(String[] args)  a = stdIn.nextInt(); if(a == 0) break; int c2 = 0; int c5 = 0; for(int i = a; i >=  c5 += ret[2]; } int count = Math.min(c2, c5); System.out.println(count); } } public static void makePrimeList() { boolean[] isntPrime = new boolean[20001]; isntPrime[0] = isntPrime[1] = true; list.add(2); for(int i = 3; i < 20001; i+= 2) { if(!isntPrime[i]) { list.add(i); for(int j =  = true; } } } } public static int[] f(int a) { int[] ret = new int[list.size()]; while(a > 1) { for(int i = 0; i < list.size(); i++) { if(a % list.get(i) == 0) {  }"], "original_ll": -0.7259248495101929, "sampled_ll": -0.4999849498271942, "all_perturbed_sampled_ll": [-1.3505568504333496], "all_perturbed_original_ll": [-1.5069955587387085], "perturbed_sampled_ll": -1.3505568504333496, "perturbed_original_ll": -1.5069955587387085, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f(n):\n    for i in range(1,n):\n        n*=i\n    return n\n        \n        \nwhile True:\n    n=int(input())\n    if n==0:\n        break\n    else:\n        a=str(f(n))\n        s=0\n        l=len(a)\n        for i in range(l-1,-1,-1):\n            if a[i]==\"0\":\n                s+=1\n            else:\n                break\n        print(s)\n", "sampled": "import sys\n\ndef count_trailing_zeros(n):\n    count = 0\n    power_of_5 = 5\n    while power_of_5 <= n:\n        count += n // power_of_5\n        power_of_5 *= 5\n    return count\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    if n == 0:\n        break\n    print(count_trailing_zeros(n))\n", "perturbed_sampled": ["import sys def count_trailing_zeros(n): count = 0 power_of_5 = 5 while power_of_5 <= n: count += n // power_of_5 power_of_5 *=  if n == 0: break print(count_trailing_zeros(n))"], "perturbed_original": ["def f(n): for i in range(1,n): n*=i return n while True: n=int(input()) if n==0: break else: a=str(f(n)) s=0 l=len(a) for i in range(l-1,-1,-1): if a[i]==\"0\": s+=1 else: break print(s)"], "original_ll": -1.079493522644043, "sampled_ll": -0.5933793783187866, "all_perturbed_sampled_ll": [-1.6053168773651123], "all_perturbed_original_ll": [-1.4579763412475586], "perturbed_sampled_ll": -1.6053168773651123, "perturbed_original_ll": -1.4579763412475586, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\n\nint main()\n{\n\tint n=0,d,sw;\n\tlong int i,j,k,s[1000],sum;\n\n\twhile(1)\n\t{\n\t\tn=1;\n\t\tsum=0;\n\t\tscanf(\"%d\",&d);\n\t\tif(!d)\n\t\t\tbreak;\n\t\ts[0]=2;\n\t\ts[1]=3;\n\t\tif(d<=2)\n\t\t{\n\t\t\tfor(i=0;i<d;i++)\n\t\t\t\tsum+=s[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum=5;\n\t\t\tfor(i=5;;i+=2)\n\t\t\t{\n\t\t\t\tsw=0;\n\t\t\t\tk=(long int)sqrt((double)i);\n\t\t\t\tfor(j=0;s[j]<=k;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i%s[j]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsw=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!sw)\n\t\t\t\t{\n\t\t\t\t\tn++;\n\t\t\t\t\tif(n<1000)\n\t\t\t\t\t\ts[n]=i;\n\t\t\t\t\tsum+=i;\n\t\t\t\t\tif(n==d-1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 10000\n#define MAX_PRIME 104730\n\nint is_prime[MAX_PRIME + 1];\nint primes[MAX_N];\nint prime_count = 0;\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i <= MAX_PRIME; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= MAX_PRIME; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n    \n    for (int i = 2; i <= MAX_PRIME && prime_count < MAX_N; i++) {\n        if (is_prime[i]) {\n            primes[prime_count++] = i;\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += primes[i];\n        }\n        printf(\"%lld\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> #define MAX_N 10000 #define MAX_PRIME 104730 int is_prime[MAX_PRIME + 1]; int primes[MAX_N]; int prime_count = 0; void sieve() { memset(is_prime, 1, sizeof(is_prime)); is_prime[0] = is_prime[1] = 0; for (int i = 2; i * i <= MAX_PRIME;  * i; j <= MAX_PRIME;  for (int i = 2;  (is_prime[i]) { primes[prime_count++] = i; } } } int main() { sieve(); int n; while (scanf(\"%d\", &n) == 1 && n != 0) { long long sum = 0; for (int i = 0; i < n; i++) { sum += primes[i]; } printf(\"%lld\\n\", sum); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h> int main() { int n=0,d,sw; long int i,j,k,s[1000],sum; while(1) { n=1; sum=0; scanf(\"%d\",&d); if(!d) break; s[0]=2; s[1]=3; if(d<=2) { for(i=0;i<d;i++) sum+=s[i]; } else { sum=5; for(i=5;;i+=2) { sw=0; k=(long int)sqrt((double)i); for(j=0;s[j]<=k;j++) { if(i%s[j]==0) { sw=1; break; } } if(!sw) { n++;  return 0; }"], "original_ll": -1.0099388360977173, "sampled_ll": -0.4413456320762634, "all_perturbed_sampled_ll": [-1.1961796283721924], "all_perturbed_original_ll": [-1.6045775413513184], "perturbed_sampled_ll": -1.1961796283721924, "perturbed_original_ll": -1.6045775413513184, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main{\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\tint[] p = new int[1000000];\n\tsetP(p);\n\twhile(kbd.hasNext()){\n\t    int n = kbd.nextInt();\n\t    if(n!=0) solve(p, n);\n\t}\n    }\n\n    static void solve(int[] p, int n){\n\tint sum=0, i;\n\tfor(i=0; p[i]<=n; i++){\n\t    if(p[i]!=-1) {\n\t\tsum+=i;\n\t\t//System.out.println(i);\n\t    }\n\t}\n\n\tSystem.out.println(sum);\n    }\n\n    static void setP(int[] p){\n\tint a=1, i, j;\n\tArrays.fill(p, 1);\n\tp[0] = -1;\n\tp[1] = -1;\n\tfor(i=2; i<p.length; i++){\n\t    if(p[i] == 1){\n\t\t//System.out.println(i+\" \"+a);\n\t\tp[i] = a;\n\t\ta++;\t\n\t    }\n\t    for(j=i+i; j<p.length; j+=i){\n\t\tp[j] = -1;\n\t    }\n\t}\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Pre-calculate primes up to a reasonable limit\n        // For n=10000, we need the 10000th prime\n        // The 10000th prime is approximately 104729\n        int limit = 110000;\n        boolean[] isPrime = new boolean[limit];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        // Sieve of Eratosthenes\n        for (int i = 2; i * i < limit; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < limit; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        // Collect primes in order\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < limit; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        // Pre-calculate cumulative sums\n        long[] cumulativeSum = new long[primes.size() + 1];\n        for (int i = 0; i < primes.size(); i++) {\n            cumulativeSum[i + 1] = cumulativeSum[i] + primes.get(i);\n        }\n        \n        // Process queries\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            System.out.println(cumulativeSum[n]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); //  we need the 10000th prime // The 10000th prime is approximately 104729 int limit = 110000; boolean[] isPrime = new boolean[limit]; Arrays.fill(isPrime, true); isPrime[0] = isPrime[1] = false; //  (int j =  isPrime[j] = false; } } } //  (int i = 2; i < limit; i++) { if (isPrime[i]) { primes.add(i); } } // Pre-calculate cumulative sums long[] cumulativeSum = new long[primes.size() + 1]; for (int i = 0; i < primes.size(); i++) { cumulativeSum[i + 1] = cumulativeSum[i] + primes.get(i); } // Process queries while (true) { int n = sc.nextInt(); if (n == 0) break; System.out.println(cumulativeSum[n]); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ static Scanner kbd = new Scanner(System.in); public static void main(String[] args){ int[] p = new int[1000000]; setP(p); while(kbd.hasNext()){ int n = kbd.nextInt(); if(n!=0) solve(p, n); } } static  i++){ if(p[i]!=-1) { sum+=i; //System.out.println(i); } } System.out.println(sum); } static void setP(int[] p){ int  -1; for(i=2; i<p.length; i++){ if(p[i] == 1){ //System.out.println(i+\" \"+a); p[i] = a; a++; } for(j=i+i; j<p.length; j+=i){ p[j] = -1; } } } }"], "original_ll": -1.0193012952804565, "sampled_ll": -0.45408186316490173, "all_perturbed_sampled_ll": [-1.1374764442443848], "all_perturbed_original_ll": [-1.478723406791687], "perturbed_sampled_ll": -1.1374764442443848, "perturbed_original_ll": -1.478723406791687, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import *\nn=range(104730);a=list(n)\nfor i in range(2,321):a[i*2::i]=[0]*len(a[i*2::i])\np=list(compress(n,a))\nfor e in iter(input,'0'):print(sum(p[:int(e)+1])-1)\n", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    primes = [i for i in range(2, limit + 1) if is_prime[i]]\n    return primes\n\n# Pre-compute primes up to a sufficient limit\n# For n=10000, we need the 10000th prime\n# The 10000th prime is 104729\nprimes = sieve_of_eratosthenes(105000)\n\n# Pre-compute cumulative sums\ncumsum = [0]\nfor prime in primes:\n    cumsum.append(cumsum[-1] + prime)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(cumsum[n])\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(limit**0.5) + 1): if is_prime[i]: for j in [n:<extra_id_6>1: for i in<extra_id_7>p[i] >=<extra_id_8>1:<extra_id_9>. append (<extra_id_10>)<extra_id_11>if p == 1 :<extra_id_12>p [p[p[p[p]]] = 1<extra_id_13>[p[p][p] < n-1]<extra_id_14>#<extra_id_15>n:<extra_id_16>( n0,104729) for<extra_id_17>n<extra_id_18>p<extra_id_19>n = [i for i in range(2, limit + 1) if is_prime[i]] return primes # Pre-compute primes up to a sufficient limit # For n=10000,  104729 primes = sieve_of_eratosthenes(105000) # Pre-compute cumulative sums cumsum = [0] for prime in primes: cumsum.append(cumsum[-1] + prime) while True: n = int(input()) if n == 0: break print(cumsum[n])"], "perturbed_original": ["from itertools import * n=range(104730);a=list(n) for i in range(2,321):a[i*2::i]=[0]*len(a[i*2::i]) p=list(compress(n,a)) for e in iter(input,'0'):print(sum(p[:int(e)+1])-1)"], "original_ll": -2.5868303775787354, "sampled_ll": -0.6957857012748718, "all_perturbed_sampled_ll": [-1.7352920770645142], "all_perturbed_original_ll": [-2.67484450340271], "perturbed_sampled_ll": -1.7352920770645142, "perturbed_original_ll": -2.67484450340271, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void) {\n\tint a,b,n;\n\tint sum;\n\tint i,j;\n\twhile(1) {\n\t\tif(scanf(\"%d %d %d\",&a,&b,&n)==-1)break;\n\t\ta-=a/b*b;\n\t\tsum=0;\n\t\tfor(i=1;i<=n;i++) {\n\t\t\ta*=10;\n\t\t\tfor(j=9;j>=0;j--) {\n\t\t\t\tif(b*j<=a)break;\n\t\t\t}\n\t\t\ta-=b*j;\n\t\t\tsum+=j;\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a, b, n;\n    \n    while (scanf(\"%d %d %d\", &a, &b, &n) == 3) {\n        int sum = 0;\n        int remainder = a % b;\n        \n        for (int i = 0; i < n; i++) {\n            remainder *= 10;\n            int digit = remainder / b;\n            sum += digit;\n            remainder = remainder % b;\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int a, b, n; while (scanf(\"%d %d %d\", &a, &b, &n) == 3) { int sum = 0; int remainder = a % b; for (int i = 0; i remainder /<extra_id_8>b; n++;<extra_id_9>//<extra_id_10>int digit; for (int<extra_id_11>i=<extra_id_12>n; i++ )<extra_id_13>i<extra_id_14>n<extra_id_15>digit) { for(int i=0;<extra_id_16>digit < 10;<extra_id_17>(digit); } var digit<extra_id_18>if (digit; for(i< remainder / b; sum += digit; remainder = remainder % b; } printf(\"%d\\n\", sum); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int a,b,n; int sum; int i,j; while(1) { if(scanf(\"%d %d %d\",&a,&b,&n)==-1)break; a-=a/b*b; sum=0; for(i=1;i<=n;i++) { a*=10; for(j=9;j>=0;j--) { if(b*j<=a)break; } a-=b*j; sum+=j; } printf(\"%d\\n\",sum); } return 0; }"], "original_ll": -1.2095630168914795, "sampled_ll": -0.6085061430931091, "all_perturbed_sampled_ll": [-1.9483617544174194], "all_perturbed_original_ll": [-1.4130855798721313], "perturbed_sampled_ll": -1.9483617544174194, "perturbed_original_ll": -1.4130855798721313, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main{\n\tMain(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tint n = sc.nextInt();\n\t\t\tint s = 0;\n\t\t\tString str = Double.toString((a/b)) + \"0000000000\";\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\ts += Integer.parseInt(str.substring(i+2, i+3));\n\t\t\t}\n\t\t\tSystem.out.println(Integer.toString(s));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int n = sc.nextInt();\n            \n            int sum = 0;\n            int remainder = a % b;\n            \n            for (int i = 0; i < n; i++) {\n                remainder *= 10;\n                int digit = remainder / b;\n                sum += digit;\n                remainder = remainder % b;\n            }\n            \n            System.out.println(sum);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int a = sc.nextInt(); int b = sc.nextInt(); int n = sc.nextInt(); int sum = 0; int remainder = a % b; for (int i = 0; i <  b; } System.out.println(sum); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main{ Main(){ Scanner sc = new Scanner(System.in); while(sc.hasNext()){ double a  int s = 0; String str = Double.toString((a/b)) + \"0000000000\"; for(int i = 0; i < n; i++){ s += Integer.parseInt(str.substring(i+2, i+3)); } System.out.println(Integer.toString(s)); } } public static void main(String[] args){ new Main(); } }"], "original_ll": -0.9731116890907288, "sampled_ll": -0.566260576248169, "all_perturbed_sampled_ll": [-1.0565580129623413], "all_perturbed_original_ll": [-1.5634031295776367], "perturbed_sampled_ll": -1.0565580129623413, "perturbed_original_ll": -1.5634031295776367, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "t=10**9\nwhile 1:\n    try:\n        a,b,n=map(int,raw_input().split())\n        if b==0:\n            print 0\n            continue\n        f=a*t/b\n        f=str(f%t)\n        ans=0\n        for i in range(n):\n            ans+=int(f[i])\n        print ans\n    except:\n        break", "sampled": "import sys\n\nfor line in sys.stdin:\n    a, b, n = map(int, line.split())\n    s = 0\n    remainder = a % b\n    \n    for i in range(n):\n        remainder *= 10\n        digit = remainder // b\n        s += digit\n        remainder = remainder % b\n    \n    print(s)\n", "perturbed_sampled": ["import sys for line in sys.stdin: a, b, n =  for i in range(n): remainder *= 10 digit = remainder // b s += digit remainder = remainder % b print(s)"], "perturbed_original": ["t=10**9 while 1: try: a,b,n=map(int,raw_input().split()) if b==0: print 0 continue f=a*t/b f=str(f%t) ans=0 for i in range(n): ans+=int(f[i]) print ans except: break"], "original_ll": -1.3663463592529297, "sampled_ll": -1.1175869703292847, "all_perturbed_sampled_ll": [-2.9012973308563232], "all_perturbed_original_ll": [-2.2768807411193848], "perturbed_sampled_ll": -2.9012973308563232, "perturbed_original_ll": -2.2768807411193848, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n  int k;\n  double a[11];\n  double sum;\n  while(scanf(\"%lf\",&a[1])!=EOF){\n    sum = a[1];\n    printf(\"test\");\n    for(k=2;k=10;k++){\n      if(k%2==0){\n        a[k] = a[k-1] * 2;\n      }else{\n        a[k] = a[k-1] / 3;\n      }\n      sum += a[k];\n    }\n    printf(\"%lf\\n\",sum);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double a;\n    while (scanf(\"%lf\", &a) != EOF) {\n        double sum = 0.0;\n        double current = a;\n        \n        for (int i = 1; i <= 10; i++) {\n            sum += current;\n            if (i % 2 == 0) {\n                current = current / 3.0;\n            } else {\n                current = current * 2.0;\n            }\n        }\n        \n        printf(\"%.8lf\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double a; while (scanf(\"%lf\",  = a; for (int i = 1; i <= 10; i++) { sum += current; if (i % 2 == 0) { current = current / 3.0; } else { current = current * 2.0; } } printf(\"%.8lf\\n\", sum); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int k; double a[11]; double sum; while(scanf(\"%lf\",&a[1])!=EOF){  2; }else{ a[k] = a[k-1] / 3; } sum += a[k]; } printf(\"%lf\\n\",sum); } return 0; }"], "original_ll": -1.18648099899292, "sampled_ll": -0.6376007199287415, "all_perturbed_sampled_ll": [-1.2926579713821411], "all_perturbed_original_ll": [-2.126084327697754], "perturbed_sampled_ll": -1.2926579713821411, "perturbed_original_ll": -2.126084327697754, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n    private static double calculation(double value){\n\tdouble sum = value;\n\tdouble[] values = new double[10];\n\tvalues[0] = value;\n\t\n\tfor(int i = 1; i < 10; ++i){\n\t    if(i%2 == 1){\n\t\tvalues[i] = values[i-1]*2.0;\n\t    } else {\n\t\tvalues[i] = values[i-1]/3.0;\n\t    }\n\t    sum += values[i];\n\t}\n\t\n\n\treturn sum;\n    }\n    \n    public static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\t\n\twhile(sc.hasNext()){\n\t    double value = sc.nextDouble();\n\t    System.out.printf(\"%f\\n\", calculation(value));\n\t}\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double a = sc.nextDouble();\n            double sum = 0;\n            double current = a;\n            \n            for (int i = 1; i <= 10; i++) {\n                sum += current;\n                if (i % 2 == 0) {\n                    current = current / 3.0;\n                } else {\n                    current = current * 2.0;\n                }\n            }\n            \n            System.out.printf(\"%.8f%n\", sum);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  sc.nextDouble(); double sum = 0; double current = a; for (int i = 1; i <= 10; i++) { sum +=  current / 3.0; } else { current = current * 2.0; } } System.out.printf(\"%.8f%n\", sum); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ private static double calculation(double value){ double sum = value; double[] values  i < 10; ++i){ if(i%2 == 1){ values[i] = values[i-1]*2.0; } else { values[i] = values[i-1]/3.0;  void main(String[] args){ Scanner sc = new Scanner(System.in); while(sc.hasNext()){ double value = sc.nextDouble(); System.out.printf(\"%f\\n\", calculation(value)); } } }"], "original_ll": -0.9494082927703857, "sampled_ll": -0.616515040397644, "all_perturbed_sampled_ll": [-1.5906505584716797], "all_perturbed_original_ll": [-1.6938321590423584], "perturbed_sampled_ll": -1.5906505584716797, "perturbed_original_ll": -1.6938321590423584, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    try:n=float(input())\n    except:break\n    s=n\n    for i in range(9):\n        n=n/3 if i%2 else n*2\n        s+=n\n    print(s)", "sampled": "import sys\n\nfor line in sys.stdin:\n    a = float(line.strip())\n    \n    terms = [a]\n    for i in range(1, 10):\n        if i % 2 == 1:  # odd index (2nd, 4th, 6th... terms)\n            terms.append(terms[-1] * 2)\n        else:  # even index (3rd, 5th, 7th... terms)\n            terms.append(terms[-1] / 3)\n    \n    s = sum(terms)\n    print(f\"{s:.8f}\")\n", "perturbed_sampled": ["import sys for line in sys.stdin:  10): if i % 2 == 1: # odd index (2nd, 4th, 6th... terms) terms.append(terms[-1] * 2) else: # even index (3rd, 5th, 7th... terms) terms.append(terms[-1] / 3) s = sum(terms) print(f\"{s:.8f}\")"], "perturbed_original": ["while 1: try:n=float(input()) except:break s=n for i in range(9): n=n/3 if i%2 else n*2 s+=n print(s)"], "original_ll": -1.83852219581604, "sampled_ll": -0.9661317467689514, "all_perturbed_sampled_ll": [-1.602808952331543], "all_perturbed_original_ll": [-2.7482688426971436], "perturbed_sampled_ll": -1.602808952331543, "perturbed_original_ll": -2.7482688426971436, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint prime[50001];\nvoid set(void){\n    int i,o;\n    for(i=4;i<=5000;i+=2)\n        prime[i]=1;\n    for(i=3;i*i<=5000;i+=2){\n        if(prime[i]==0)\n            for(o=i*2;o<=5000;o+=i)\n                prime[o]=1;\n    }\n}\nint main(void){\n    int num,count,sum,i,o;\n    set();\n    for(;count=0,scanf(\"%d\",&num),num;){\n        for(i=2;i<=num;i++)\n            if(!prime[i]){\n                if(i>num)\n                     break;\n                for(o=2;o<=num;o++)\n                    if(!prime[o]){\n                        sum=i+o;\n                        if(sum == num){\n                            count++;\n                            break;\n                        }\n                        if(sum > num)\n                            break;\n                    }\n            }\n        printf(\"%d\\n\",count%2?(count/2+1):(count/2));\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 50001\n\nint is_prime[MAX];\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int count = 0;\n        for (int i = 2; i <= n / 2; i++) {\n            if (is_prime[i] && is_prime[n - i]) {\n                count++;\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #define MAX 50001 int ++; sieve();<extra_id_16>.<extra_id_17>j = 0; for (int i = 2; i * i < MAX; i++) { if (is_prime[i]) { for (int j <extra_id_18>j ++<extra_id_19>; } return j { sieve(); int n; while (scanf(\"%d\", &n) == 1 && n != 0) { int count = 0; for (int i = 2; i <= n / 2; i++) { if (is_prime[i] && is_prime[n - i]) { count++; } } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include  if(prime[i]==0) for(o=i*2;o<=5000;o+=i) prime[o]=1; } } int main(void){ int num,count,sum,i,o; set(); for(;count=0,scanf(\"%d\",&num),num;){ for(i=2;i<=num;i++) if(!prime[i]){ if(i>num) break; for(o=2;o<=num;o++) if(!prime[o]){ sum=i+o; if(sum == num){ count++; break; } if(sum > num) break; } } printf(\"%d\\n\",count%2?(count/2+1):(count/2)); } return 0; }"], "original_ll": -1.1158311367034912, "sampled_ll": -0.36023810505867004, "all_perturbed_sampled_ll": [-1.7654811143875122], "all_perturbed_original_ll": [-1.8378812074661255], "perturbed_sampled_ll": -1.7654811143875122, "perturbed_original_ll": -1.8378812074661255, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static boolean[] p=new boolean[50000];\n\tpublic static int counter(int n){\n\t\tint c=0,i,j;\n\t\tfor(i=2;i<=n/2;i++){\n\t\t\tif(p[i])\n\t\t\tfor(j=2;i+j<=n;j++){\n\t\t\t\tif(p[j]){\n\t\t\t\t\tif(i+j==n){\n\t\t\t\t\t\tc++;\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}//\n\t\treturn c;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,i,j;\n\t\tArrays.fill(p, true);\n\t\tfor(i=2;i<50000;i++){\n\t\t\tif(p[i])\n\t\t\tfor(j=2;i*j<50000;j++){\n\t\t\t\tp[i*j]=false;\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tSystem.out.println(counter(n));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static boolean[] isPrime;\n    static int MAX = 50001;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Sieve of Eratosthenes\n        isPrime = new boolean[MAX];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i < MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < MAX; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            for (int i = 2; i <= n / 2; i++) {\n                if (isPrime[i] && isPrime[n - i]) {\n                    count++;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static  Sieve of Eratosthenes isPrime = new boolean[MAX]; Arrays.fill(isPrime, true); isPrime[0] = isPrime[1] = false; for (int i = 2; i * i < MAX; i++) { if (isPrime[i]) { for (int j = i * i; j < MAX; j += i) { isPrime[j] = false; } } } while (true) { int n = sc.nextInt(); if (n == 0) break; int count = 0; for (int i = 2; i <=  i]) { count++; } } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { public static boolean[] p=new boolean[50000]; public static int counter(int n){ int c=0,i,j; for(i=2;i<=n/2;i++){ if(p[i]) for(j=2;i+j<=n;j++){ if(p[j]){ if(i+j==n){ c++; // System.out.println(i+\" \"+j); } } } }// return c; } public static void main(String[] args) {  p[i*j]=false; } } while(true){ n=sc.nextInt(); if(n==0) break; System.out.println(counter(n)); } } }"], "original_ll": -0.9992666244506836, "sampled_ll": -0.3539169132709503, "all_perturbed_sampled_ll": [-1.0027706623077393], "all_perturbed_original_ll": [-1.6142245531082153], "perturbed_sampled_ll": -1.0027706623077393, "perturbed_original_ll": -1.6142245531082153, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N=50000+1\np=[True]*N\np[0],p[1]=False,False\nfor i in xrange(2,int(N**0.5)+1):\n    if p[i]==True:\n        for j in xrange(i**2,N,i):\n            p[j]=False\nwhile True:\n    n=input()\n    if n==0:break\n    c=0\n    for i in xrange(n/2+1):\n        if p[i] and p[n-i]:c+=1\n    print c", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\nlimit = 50000\nis_prime = sieve_of_eratosthenes(limit)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = 0\n    for i in range(2, n // 2 + 1):\n        if is_prime[i] and is_prime[n - i]:\n            count += 1\n    \n    print(count)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(limit**0.5) + 1): if  = False return is_prime limit = 50000 is_prime = sieve_of_eratosthenes(limit) while True: n = int(input()) if n == 0: break count = 0 for  and is_prime[n - i]: count += 1 print(count)"], "perturbed_original": ["N=50000+1 p=[True]*N p[0],p[1]=False,False for i in xrange(2,int(N**0.5)+1): if p[i]==True: for j in xrange(i**2,N,i): p[j]=False while True: n=input() if n==0:break c=0 for i in xrange(n/2+1): if p[i] and p[n-i]:c+=1 print c"], "original_ll": -0.9976736307144165, "sampled_ll": -0.38441094756126404, "all_perturbed_sampled_ll": [-1.2183500528335571], "all_perturbed_original_ll": [-1.4858338832855225], "perturbed_sampled_ll": -1.2183500528335571, "perturbed_original_ll": -1.4858338832855225, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N,main(){while(~scanf(\"%d\",&N))printf(\"%d\\n\",N*(N+1)/2+1);}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) != EOF) {\n        long long result = 1 + (long long)n * (n + 1) / 2;\n        printf(\"%lld\\n\", result);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while (scanf(\"%d\", &n) != EOF) { long long result = 1 + (long long)n * (n + 1) / 2; printf(\"%lld\\n\", result); } return 0; }"], "perturbed_original": ["N,main(){while(~scanf(\"%d\",&N))printf(\"%d\\n\",N*(N+1)/2+1);}"], "original_ll": -2.3594918251037598, "sampled_ll": -0.7457207441329956, "all_perturbed_sampled_ll": [-0.9915509819984436], "all_perturbed_original_ll": [-2.3594918251037598], "perturbed_sampled_ll": -0.9915509819984436, "perturbed_original_ll": -2.3594918251037598, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n\tScanner s = new Scanner(System.in);\n\tint[] d = new int[10001];\n\td[0]=1;\n\td[1]=2;\n\tfor(int i=2 ; i<10001 ; i++)\n\t    d[i] = d[i-1]+i;\n\twhile(s.hasNext())\n\t    System.out.println(d[s.nextInt()]);\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            long result = (long) n * (n + 1) / 2 + 1;\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt();  2 + 1; System.out.println(result); } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main { public static void main(String[] args) { Scanner s = new Scanner(System.in); int[] d = new int[10001];  d[i-1]+i; while(s.hasNext()) System.out.println(d[s.nextInt()]); } }"], "original_ll": -0.9584491848945618, "sampled_ll": -0.6549385190010071, "all_perturbed_sampled_ll": [-1.3542835712432861], "all_perturbed_original_ll": [-1.5175641775131226], "perturbed_sampled_ll": -1.3542835712432861, "perturbed_original_ll": -1.5175641775131226, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        a = int(input())\n        print(((a * a) + a + 2) / 2)\n    except EOFError:\n        break", "sampled": "import sys\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    result = 1 + n * (n + 1) // 2\n    print(result)\n", "perturbed_sampled": ["import sys for line in sys.stdin: n = int(line.strip()) result = 1 + n * (n + 1) // 2 print(result)"], "perturbed_original": ["while True: try: a = int(input()) print(((a * a) + a + 2) / 2) except EOFError: break"], "original_ll": -1.3567216396331787, "sampled_ll": -1.0850199460983276, "all_perturbed_sampled_ll": [-1.7010818719863892], "all_perturbed_original_ll": [-1.8170808553695679], "perturbed_sampled_ll": -1.7010818719863892, "perturbed_original_ll": -1.8170808553695679, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "i;main(){float A,a,B,b,C,c,D,d;for(;~scanf(\"%f\",&d+i*2);)if(++i==8)puts((A-B)*(C-D)+(a-b)*(c-d)?\"NO\":\"YES\",i=0);}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double xA, yA, xB, yB, xC, yC, xD, yD;\n    \n    while (scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n                 &xA, &yA, &xB, &yB, &xC, &yC, &xD, &yD) == 8) {\n        double dx1 = xB - xA;\n        double dy1 = yB - yA;\n        double dx2 = xD - xC;\n        double dy2 = yD - yC;\n        \n        double dot = dx1 * dx2 + dy1 * dy2;\n        \n        if (fabs(dot) < 1e-9) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main()  &xA, &yA, &xB, &yB, &xC, &yC, &xD, &yD) == 8) { double dx1 = xB - xA; double dy1 = yB - yA; double dx2 = xD - xC; double dy2 = yD - yC; double dot = dx1 * dx2 + dy1 * dy2; if (fabs(dot) < 1e-9) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["i;main(){float A,a,B,b,C,c,D,d;for(;~scanf(\"%f\",&d+i*2);)if(++i==8)puts((A-B)*(C-D)+(a-b)*(c-d)?\"NO\":\"YES\",i=0);}"], "original_ll": -3.3201801776885986, "sampled_ll": -0.4434913396835327, "all_perturbed_sampled_ll": [-1.0940771102905273], "all_perturbed_original_ll": [-3.3201801776885986], "perturbed_sampled_ll": -1.0940771102905273, "perturbed_original_ll": -3.3201801776885986, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main{\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        while(sc.hasNext()){\n            double[][]point=new double[4][2];\n            for(int i=0;i<4;i++){\n                point[i][0]=sc.nextDouble();\n                point[i][1]=sc.nextDouble();\n            }\n            double x1=point[1][0]-point[0][0],y1=point[1][1]-point[0][1],x2=point[3][0]-point[2][0],y2=point[3][1]-point[2][1];\n            System.out.println((x1*x2+y1*y2)==0?\"YES\":\"NO\");\n            \n        }\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double xA = sc.nextDouble();\n            double yA = sc.nextDouble();\n            double xB = sc.nextDouble();\n            double yB = sc.nextDouble();\n            double xC = sc.nextDouble();\n            double yC = sc.nextDouble();\n            double xD = sc.nextDouble();\n            double yD = sc.nextDouble();\n            \n            double dx1 = xB - xA;\n            double dy1 = yB - yA;\n            double dx2 = xD - xC;\n            double dy2 = yD - yC;\n            \n            double dotProduct = dx1 * dx2 + dy1 * dy2;\n            \n            if (Math.abs(dotProduct) < 1e-9) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { double xA = sc.nextDouble(); double yA = sc.nextDouble(); double xB = sc.nextDouble(); double yB = sc.nextDouble(); double xC = sc.nextDouble(); double yC = sc.nextDouble(); double xD = sc.nextDouble(); double yD = sc.nextDouble(); double dx1 = xB - xA; double dy1 = yB - yA; double dx2  { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main{ public static void main(String[] args) { Scanner sc=new Scanner(System.in); while(sc.hasNext()){ double[][]point=new double[4][2]; for(int i=0;i<4;i++){ point[i][0]=sc.nextDouble(); point[i][1]=sc.nextDouble(); } double x1=point[1][0]-point[0][0],y1=point[1][1]-point[0][1],x2=point[3][0]-point[2][0],y2=point[3][1]-point[2][1]; System.out.println((x1*x2+y1*y2)==0?\"YES\":\"NO\"); } } }"], "original_ll": -0.653437614440918, "sampled_ll": -0.3822898268699646, "all_perturbed_sampled_ll": [-0.8285173177719116], "all_perturbed_original_ll": [-0.7303504347801208], "perturbed_sampled_ll": -0.8285173177719116, "perturbed_original_ll": -0.7303504347801208, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        xA,yA,xB,yB,xC,yC,xD,yD = map(float,raw_input().split())\n        if (100000*(yB-yA))*(100000*(yD-yC)) + (100000*(xB-xA))*(100000*(xD-xC)) < 1.e-10:\n            print \"YES\"\n        else:\n            print \"NO\"\n    except:\n        break", "sampled": "import sys\n\nfor line in sys.stdin:\n    coords = list(map(float, line.split()))\n    xa, ya, xb, yb, xc, yc, xd, yd = coords\n    \n    # Vector AB\n    vab_x = xb - xa\n    vab_y = yb - ya\n    \n    # Vector CD\n    vcd_x = xd - xc\n    vcd_y = yd - yc\n    \n    # Dot product\n    dot = vab_x * vcd_x + vab_y * vcd_y\n    \n    # Check if perpendicular (dot product is 0)\n    if abs(dot) < 1e-9:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: coords = list(map(float, line.split())) xa, ya, xb, yb, xc, yc,  - xa vab_y = yb - ya # Vector CD vcd_x = xd - xc vcd_y = yd - yc # Dot product dot = vab_x * vcd_x + vab_y * vcd_y # Check  print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["while True: try: xA,yA,xB,yB,xC,yC,xD,yD = map(float,raw_input().split()) if (100000*(yB-yA))*(100000*(yD-yC)) + (100000*(xB-xA))*(100000*(xD-xC)) < 1.e-10: print \"YES\" else: print \"NO\" except: break"], "original_ll": -1.1582998037338257, "sampled_ll": -0.777967631816864, "all_perturbed_sampled_ll": [-2.247035026550293], "all_perturbed_original_ll": [-1.3453476428985596], "perturbed_sampled_ll": -2.247035026550293, "perturbed_original_ll": -1.3453476428985596, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\n#include <stdlib.h>\n#include<string.h>\n#include<limits.h>\n\nint main(){\n\tdouble x[4],y[4];\n\tint i;\n\t\n\twhile(scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2],&x[3],&y[3])!=EOF){\n\t\n\t\tif(x[0]<=x[2] && x[1]>=x[2]){\n\t\t\tif((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t\telse if(x[0]<=x[3] && x[1]>=x[3]){\n\t\t\tif((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t\telse printf(\"NO\\n\");\n\t}\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2;\n    \n    while (scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n                  &xa1, &ya1, &xa2, &ya2, &xb1, &yb1, &xb2, &yb2) == 8) {\n        \n        if (xa2 >= xb1 && xb2 >= xa1 && ya2 >= yb1 && yb2 >= ya1) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2; while (scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &xa1, &ya1, &xa2, &ya2, &xb1, &yb1, &xb2, &yb2) == 8) { if (xa2 >= xb1 && xb2 >= xa1 && ya2 >= yb1 && yb2 >= ya1)  }"], "perturbed_original": [" int i; while(scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2],&x[3],&y[3])!=EOF){ if(x[0]<=x[2] && x[1]>=x[2]){ if((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(\"YES\\n\"); else printf(\"NO\\n\"); } else if(x[0]<=x[3] && x[1]>=x[3]){ if((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(\"YES\\n\"); else printf(\"NO\\n\"); } else printf(\"NO\\n\"); } return 0; }"], "original_ll": -0.5937101244926453, "sampled_ll": -0.5137386918067932, "all_perturbed_sampled_ll": [-0.6931516528129578], "all_perturbed_original_ll": [-0.6075232625007629], "perturbed_sampled_ll": -0.6931516528129578, "perturbed_original_ll": -0.6075232625007629, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main {\n\tstatic double x1[]=new double[2];\n\tstatic double y1[]=new double[2];\n\tstatic double x2[]=new double[2];\n\tstatic double y2[]=new double[2];\n\tpublic static boolean check(double x,double y) {\n\t\tif(x1[0]<=x && x<=x1[1] && y1[0]<=y && y<=y1[1]){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static boolean check2(double x,double y) {\n\t\tif(x2[0]<=x && x<=x2[1] && y2[0]<=y && y<=y2[1]){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble tmp;\n\t\tint i,j;\n\t\twhile(sc.hasNext()){\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tx1[i]=sc.nextDouble();\n\t\t\t\ty1[i]=sc.nextDouble();\n\t\t\t}\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tx2[i]=sc.nextDouble();\n\t\t\t\ty2[i]=sc.nextDouble();\n\t\t\t}\n\t\t\tif(x1[1]<x1[0]){\n\t\t\t\ttmp=x1[1];\n\t\t\t\tx1[0]=x1[1];\n\t\t\t\tx1[1]=tmp;\n\t\t\t}\n\t\t\tif(y1[1]<y1[0]){\n\t\t\t\ttmp=y1[1];\n\t\t\t\ty1[0]=y1[1];\n\t\t\t\ty1[1]=tmp;\n\t\t\t}\n\t\t\tif(x2[1]<x2[0]){\n\t\t\t\ttmp=x2[1];\n\t\t\t\tx2[0]=x2[1];\n\t\t\t\tx2[1]=tmp;\n\t\t\t}\n\t\t\tif(y2[1]<y2[0]){\n\t\t\t\ttmp=y2[1];\n\t\t\t\ty2[0]=y2[1];\n\t\t\t\ty2[1]=tmp;\n\t\t\t}\n\t\t\tboolean f=false;\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t//System.out.println(f+\" \"+x2[i]+\" \"+y2[j]);\n\t\t\t\t\tif(f) break;\n\t\t\t\t\tf=check(x2[i],y2[j]);\n\t\t\t\t}\n\t\t\t}//\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t//System.out.println(f);\n\t\t\t\t\tif(f) break;\n\t\t\t\t\tf=check2(x1[i],y1[j]);\n\t\t\t\t}\n\t\t\t}//\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double xa1 = sc.nextDouble();\n            double ya1 = sc.nextDouble();\n            double xa2 = sc.nextDouble();\n            double ya2 = sc.nextDouble();\n            double xb1 = sc.nextDouble();\n            double yb1 = sc.nextDouble();\n            double xb2 = sc.nextDouble();\n            double yb2 = sc.nextDouble();\n            \n            boolean xOverlap = !(xa2 < xb1 || xb2 < xa1);\n            boolean yOverlap = !(ya2 < yb1 || yb2 < ya1);\n            \n            if (xOverlap && yOverlap) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { double xa1 =   sc.nextDouble(); double xb2 = sc.nextDouble(); double yb2 = sc.nextDouble(); boolean xOverlap = !(xa2 < xb1 || xb2 < xa1); boolean yOverlap = !(ya2 < yb1 || yb2 < ya1); if (xOverlap && yOverlap) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { static double x1[]=new double[2]; static double y1[]=new double[2]; static  check(double x,double y) { if(x1[0]<=x && x<=x1[1] && y1[0]<=y && y<=y1[1]){ return true; } return false; } public static boolean check2(double x,double y) { if(x2[0]<=x && x<=x2[1] && y2[0]<=y && y<=y2[1]){  args) { Scanner sc=new Scanner(System.in); double tmp; int i,j; while(sc.hasNext()){ for(i=0;i<2;i++){ x1[i]=sc.nextDouble(); y1[i]=sc.nextDouble(); } for(i=0;i<2;i++){ x2[i]=sc.nextDouble(); y2[i]=sc.nextDouble(); } if(x1[1]<x1[0]){ tmp=x1[1]; x1[0]=x1[1]; x1[1]=tmp; } if(y1[1]<y1[0]){ tmp=y1[1]; y1[0]=y1[1]; y1[1]=tmp; } if(x2[1]<x2[0]){ tmp=x2[1]; x2[0]=x2[1]; x2[1]=tmp; } if(y2[1]<y2[0]){ tmp=y2[1]; y2[0]=y2[1]; y2[1]=tmp; } boolean f=false; for(i=0;i<2;i++){ for(j=0;j<2;j++){ //System.out.println(f+\" \"+x2[i]+\" \"+y2[j]); if(f) break; f=check(x2[i],y2[j]); }  System.out.println(\"YES\"); } else{ System.out.println(\"NO\"); } } } }"], "original_ll": -0.38706761598587036, "sampled_ll": -0.45130082964897156, "all_perturbed_sampled_ll": [-1.0106626749038696], "all_perturbed_original_ll": [-0.7114262580871582], "perturbed_sampled_ll": -1.0106626749038696, "perturbed_original_ll": -0.7114262580871582, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\n\nfor line in sys.stdin.readline():\n    xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2 = map(float, line.rstrip('\\n').split(' '))\n    if ((xb1<=xa1 and xa1<=xb2) or (xa1<=xb1 and xb1<=xa2)) and ((yb1<=ya2 and ya2<=yb2) or (ya1<=yb2 and yb2<=ya2)):\n        print 'YES'\n    else:\n        print 'NO'", "sampled": "import sys\n\nfor line in sys.stdin:\n    coords = []\n    coords.append(list(map(float, line.split())))\n    for _ in range(7):\n        coords.append(list(map(float, input().split())))\n    \n    xa1, ya1 = coords[0][0], coords[1][0]\n    xa2, ya2 = coords[2][0], coords[3][0]\n    xb1, yb1 = coords[4][0], coords[5][0]\n    xb2, yb2 = coords[6][0], coords[7][0]\n    \n    if xa2 >= xb1 and xb2 >= xa1 and ya2 >= yb1 and yb2 >= ya1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys for line  range(7): coords.append(list(map(float, input().split()))) xa1, ya1 = coords[0][0], coords[1][0] xa2, ya2 = coords[2][0], coords[3][0] xb1, yb1 = coords[4][0], coords[5][0] xb2, yb2 = coords[6][0], coords[7][0] if xa2 >= xb1 and xb2 >= xa1 and ya2 >= yb1 and yb2 >= ya1: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["import sys for line in sys.stdin.readline(): xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2 = map(float,  and ((yb1<=ya2 and ya2<=yb2) or (ya1<=yb2 and yb2<=ya2)): print 'YES' else: print 'NO'"], "original_ll": -0.9972597360610962, "sampled_ll": -0.6717944741249084, "all_perturbed_sampled_ll": [-0.9429108500480652], "all_perturbed_original_ll": [-1.6726628541946411], "perturbed_sampled_ll": -0.9429108500480652, "perturbed_original_ll": -1.6726628541946411, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main()\n{\n        int c1, c2, c3, i, cnt = 0;\n        int card[11];\n\n        for ( int i = 1 ; i < 11 ; i++ ) {\n                card[i] = 1;\n        }\n\n        while ( scanf( \"%d %d %d\", &c1, &c2, &c3 ) == 3 ) {\n                cnt = 0;\n                for ( i = 1 ; i < 11 ; i++ ) {\n                        if ( c1 != i && c2 != i && c3 != i ) {\n                                if ( c1 + c2 + i <= 20 ) {\n                                        cnt++;\n                                }\n                        }\n                }\n                if ( cnt >= 4 ) {\n                        printf( \"YES\\n\" );\n                } else {\n                        printf( \"NO\\n\" );\n                }\n        }\n        return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nint main() {\n    int c1, c2, c3;\n    \n    while (scanf(\"%d %d %d\", &c1, &c2, &c3) == 3) {\n        int current_sum = c1 + c2;\n        int max_allowed = 20 - current_sum;\n        \n        int count_valid = 0;\n        int count_total = 0;\n        \n        for (int i = 1; i <= 10; i++) {\n            if (i != c1 && i != c2 && i != c3) {\n                count_total++;\n                if (i <= max_allowed) {\n                    count_valid++;\n                }\n            }\n        }\n        \n        if (count_valid * 2 >= count_total) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int c1, c2, c3; while (scanf(\"%d %d %d\", &c1, &c2, &c3) == 3) { int current_sum = c1 + c2; int max_allowed = 20 -  (int i = 1; i <= 10; i++) {  != c3) { count_total++; if (i <= max_allowed) { count_valid++; } } } if (count_valid * 2 >= count_total) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int main() { int c1, c2, c3, i, cnt = 0; int card[11]; for ( int i =  = 1; } while ( scanf( \"%d %d %d\", &c1, &c2, &c3 ) == 3 ) { cnt = 0; for ( i = 1 ; i < 11 ; i++ ) { if ( c1 != i && c2  cnt++; } } } if ( cnt >= 4 ) { printf( \"YES\\n\" ); } else { printf( \"NO\\n\" ); } } return 0; }"], "original_ll": -0.900566577911377, "sampled_ll": -0.7280890345573425, "all_perturbed_sampled_ll": [-1.4211679697036743], "all_perturbed_original_ll": [-1.3314284086227417], "perturbed_sampled_ll": -1.4211679697036743, "perturbed_original_ll": -1.3314284086227417, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint count = 0;\n\t\t\tfor(int i=1;i<=10;i++){\n\t\t\t\tif(i!=a && i!=b && i!=c && a+b+i>20) count++;\n\t\t\t}\n\t\t\tif(count<=3) System.out.println(\"YES\");\n\t\t\telse System.out.println(\"NO\");\t\n\t\t}\n\t}\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int c1 = sc.nextInt();\n            int c2 = sc.nextInt();\n            int c3 = sc.nextInt();\n            \n            int currentSum = c1 + c2;\n            \n            // Count how many cards from remaining 7 cards would make sum <= 20\n            int count = 0;\n            for (int i = 1; i <= 10; i++) {\n                if (i != c1 && i != c2 && i != c3) {\n                    if (currentSum + i <= 20) {\n                        count++;\n                    }\n                }\n            }\n            \n            // Total remaining cards is 7 (10 - 3 known cards)\n            // Probability is count/7\n            // 50% or more means count/7 >= 0.5, which is count >= 3.5, so count >= 4\n            if (count * 2 >= 7) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) {  Count how many cards from remaining 7 cards would make sum <= 20 int count  i++) { if (i != c1 && i != c2 && i != c3) { if (currentSum + i <= 20) { count++; } } } // Total remaining cards is 7 (10 - 3 known cards) // Probability is count/7 // 50% or more means count/7 >= 0.5, which is count >= 3.5, so count >= 4 if (count  } } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(sc.hasNext()){ int a = sc.nextInt(); int b =  i=1;i<=10;i++){ if(i!=a && i!=b && i!=c && a+b+i>20) count++; } if(count<=3) System.out.println(\"YES\"); else System.out.println(\"NO\"); } } }"], "original_ll": -0.8495214581489563, "sampled_ll": -1.0624080896377563, "all_perturbed_sampled_ll": [-2.1419742107391357], "all_perturbed_original_ll": [-1.3764593601226807], "perturbed_sampled_ll": -2.1419742107391357, "perturbed_original_ll": -1.3764593601226807, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor x in sys.stdin:\n e=list(map(int,x.split()))\n print(['YES','NO'][len(set(range(1,21-sum(e[:2])))-set(e))/7<.5])\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    c1, c2, c3 = map(int, line.strip().split())\n    \n    current_sum = c1 + c2\n    used_cards = {c1, c2, c3}\n    \n    available_cards = []\n    for i in range(1, 11):\n        if i not in used_cards:\n            available_cards.append(i)\n    \n    valid_count = 0\n    for card in available_cards:\n        if current_sum + card <= 20:\n            valid_count += 1\n    \n    total_count = len(available_cards)\n    \n    if valid_count / total_count >= 0.5:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: c1, c2, c3 = map(int, line.strip().split()) current_sum = c1 + c2 used_cards = {c1, c2, c3} available_cards = [] for i in range(1, 11): if i not in used_cards: available_cards.append(i) valid_count  <= 20: valid_count += 1 total_count = len(available_cards) if valid_count / total_count >= 0.5: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["import sys for x in sys.stdin: e=list(map(int,x.split())) print(['YES','NO'][len(set(range(1,21-sum(e[:2])))-set(e))/7<.5])"], "original_ll": -3.4410805702209473, "sampled_ll": -0.8978514671325684, "all_perturbed_sampled_ll": [-1.4755315780639648], "all_perturbed_original_ll": [-3.506594657897949], "perturbed_sampled_ll": -1.4755315780639648, "perturbed_original_ll": -3.506594657897949, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint i,j,k;\n\tint team[100],score[100];\n\tint rank[100];\n\tint count,number,tmp1,tmp2,info;\n\t\n\tcount=0;\n\t//\u5165\u529b\n\tfor(i=0;i<100;i++)\n\t{\n\t\tscanf(\"%d,%d\",&team[i],&score[i]);\n\t\tif(team[i]+score[i]==0)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\t\n\t//\u4e26\u3073\u66ff\u3048\n\tfor(i=0;i<count;i++)\n\t{\n\t\tfor(j=count-1;j>i;j--)\n\t\t{\n\t\t\tif(score[i]<=score[j])\n\t\t\t{\n\t\t\t\ttmp1=score[i];\n\t\t\t\tscore[i]=score[j];\n\t\t\t\tscore[j]=tmp1;\n\t\t\t\t\n\t\t\t\ttmp1=team[i];\n\t\t\t\tteam[i]=team[j];\n\t\t\t\tteam[j]=tmp1;\n\t\t\t}\n\t\t}\n\t}\n\t//\u9806\u4f4d\u4ed8\u3051\n\tnumber=1;\n\trank[0]=number;\n\ttmp2=score[0];\n\tfor(i=1;i<count;i++)\n\t{\n\t\t//printf(\"%d %d\\n\",score[i],tmp2);\n\t\tif(score[i]!=tmp2)\n\t\t{\n\t\t\tnumber++;\n\t\t\ttmp2=score[i];\n\t\t}\n\t\trank[i]=number;\n\t}\n\t\n\t\n\t//\u554f\u3044\u5408\u308f\u305b\n\twhile(scanf(\"%d\",&info)!=EOF)\n\t{\n\t\tfor(i=0;i<count;i++)\n\t\t{\n\t\t\tif(info==team[i])\n\t\t\t\tprintf(\"%d\\n\",rank[i]);\n\t\t\t//printf(\"%d,%d\\n\",team[i],score[i]);\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int score;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    return tb->score - ta->score;\n}\n\nint main() {\n    Team teams[100];\n    int count = 0;\n    int id, score;\n    \n    while (1) {\n        scanf(\"%d,%d\", &id, &score);\n        if (id == 0 && score == 0) break;\n        teams[count].id = id;\n        teams[count].score = score;\n        count++;\n    }\n    \n    qsort(teams, count, sizeof(Team), compare);\n    \n    int query;\n    while (scanf(\"%d\", &query) != EOF) {\n        int target_score = -1;\n        for (int i = 0; i < count; i++) {\n            if (teams[i].id == query) {\n                target_score = teams[i].score;\n                break;\n            }\n        }\n        \n        int rank = 1;\n        int prev_score = -1;\n        int current_rank = 0;\n        \n        for (int i = 0; i < count; i++) {\n            if (teams[i].score != prev_score) {\n                current_rank++;\n                prev_score = teams[i].score;\n            }\n            if (teams[i].score == target_score) {\n                rank = current_rank;\n                break;\n            }\n        }\n        \n        printf(\"%d\\n\", rank);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int id; int score; } Team; int compare(const void *a, const void *b) { Team *ta = (Team *)a; Team *tb =  Team teams[100]; int count = 0; int id, score; while (1) { scanf(\"%d,%d\", &id, &score); if (id == 0 && score == 0)  count, sizeof(Team), compare); int query; while (scanf(\"%d\", &query) != EOF) { int target_score = -1; for (int i = 0; i < count; i++) { if (teams[i].id == query) { target_score = teams[i].score; break; } } int rank = 1; int prev_score = -1; int current_rank = 0; for (int i =  { current_rank++; prev_score = teams[i].score; } if (teams[i].score == target_score) { rank  }"], "perturbed_original": [" rank[100]; int count,number,tmp1,tmp2,info; count=0; //\u5165\u529b for(i=0;i<100;i++) { scanf(\"%d,%d\",&team[i],&score[i]); if(team[i]+score[i]==0) break; count++; } //\u4e26\u3073\u66ff\u3048 for(i=0;i<count;i++) { for(j=count-1;j>i;j--) { if(score[i]<=score[j]) { tmp1=score[i]; score[i]=score[j]; score[j]=tmp1; tmp1=team[i]; team[i]=team[j]; team[j]=tmp1; } } } //\u9806\u4f4d\u4ed8\u3051 number=1; rank[0]=number; tmp2=score[0]; for(i=1;i<count;i++) { //printf(\"%d %d\\n\",score[i],tmp2); if(score[i]!=tmp2) { number++; tmp2=score[i]; } rank[i]=number; } //\u554f\u3044\u5408\u308f\u305b while(scanf(\"%d\",&info)!=EOF) { for(i=0;i<count;i++) { if(info==team[i]) printf(\"%d\\n\",rank[i]); //printf(\"%d,%d\\n\",team[i],score[i]); } } return 0; }"], "original_ll": -0.8656981587409973, "sampled_ll": -0.531158983707428, "all_perturbed_sampled_ll": [-1.4829180240631104], "all_perturbed_original_ll": [-1.2411047220230103], "perturbed_sampled_ll": -1.4829180240631104, "perturbed_original_ll": -1.2411047220230103, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString point[]= new String[100];\n\t\tint rank[]= new int[30];\n\t\tint n = 0;\n\t\tint count=0;\n\t\twhile(sc.hasNext()){\n\t\t\tString get = sc.next();\n\t\t\tif(get.equals(\"0,0\"))break;\n\t\t\tString str[] = get.split(\",\");\n\t\t\tpoint[n = Integer.parseInt(str[0])]=str[1];\n\t\t\trank[n= Integer.parseInt(str[1])-1]++;\n\t\t}\n\t\twhile(sc.hasNext()){\n\t\t\tcount=1;\n\t\t\tn = sc.nextInt();\n\t\t\tfor(int i = 29 ;i > Integer.parseInt(point[n]);i--){\n\t\t\t\tif(rank[i]>0)count++;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Map<Integer, Integer> teamScores = new HashMap<>();\n        \n        while (true) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int teamId = Integer.parseInt(parts[0]);\n            int score = Integer.parseInt(parts[1]);\n            \n            if (teamId == 0 && score == 0) {\n                break;\n            }\n            \n            teamScores.put(teamId, score);\n        }\n        \n        List<Integer> sortedScores = new ArrayList<>(teamScores.values());\n        Collections.sort(sortedScores, Collections.reverseOrder());\n        \n        Map<Integer, Integer> scoreToRank = new HashMap<>();\n        int rank = 1;\n        for (int score : sortedScores) {\n            if (!scoreToRank.containsKey(score)) {\n                scoreToRank.put(score, rank);\n                rank++;\n            }\n        }\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            int queryTeam = Integer.parseInt(line.trim());\n            int score = teamScores.get(queryTeam);\n            int teamRank = scoreToRank.get(score);\n            System.out.println(teamRank);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public  Map<Integer, Integer> teamScores = new HashMap<>(); while (true) { String line = sc.nextLine(); String[] parts = line.split(\",\"); int teamId = Integer.parseInt(parts[0]); int score = Integer.parseInt(parts[1]); if (teamId == 0 && score == 0) {  Collections.sort(sortedScores, Collections.reverseOrder()); Map<Integer, Integer> scoreToRank = new HashMap<>(); int rank = 1; for (int score : sortedScores) { if (!scoreToRank.containsKey(score)) { scoreToRank.put(score, rank); rank++; } } while (sc.hasNextLine()) { String line = sc.nextLine(); if  int teamRank = scoreToRank.get(score); System.out.println(teamRank); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main{ public static void main(String args[]){ Scanner sc = new Scanner(System.in); String point[]= new String[100]; int rank[]= new int[30]; int n = 0; int count=0; while(sc.hasNext()){ String get = sc.next(); if(get.equals(\"0,0\"))break; String str[] = get.split(\",\"); point[n = Integer.parseInt(str[0])]=str[1]; rank[n= Integer.parseInt(str[1])-1]++; } while(sc.hasNext()){ count=1; n = sc.nextInt();  } } }"], "original_ll": -1.347314715385437, "sampled_ll": -0.5559727549552917, "all_perturbed_sampled_ll": [-1.2465214729309082], "all_perturbed_original_ll": [-1.6679811477661133], "perturbed_sampled_ll": -1.2465214729309082, "perturbed_original_ll": -1.6679811477661133, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "nums={}\nwhile True:\n    p,s=map(int,input().split(','))\n    if(p==0 and s==0):break\n    if not s in nums:\n        nums[s]=[]\n    nums[s].append(p)\n\nwhile True:\n    try:\n        q=int(input())\n        ans=len(nums)\n        for ns in nums.items():\n            if q in ns[1]:\n                print(ans)\n                break\n            ans-=1\n    except:\n        break", "sampled": "# Read team data\nteams = {}\nwhile True:\n    line = input().strip()\n    parts = line.split(',')\n    team_id = int(parts[0])\n    score = int(parts[1])\n    if team_id == 0 and score == 0:\n        break\n    teams[team_id] = score\n\n# Get unique scores and sort them in descending order\nunique_scores = sorted(set(teams.values()), reverse=True)\n\n# Create a mapping from score to rank\nscore_to_rank = {}\nfor i, score in enumerate(unique_scores):\n    score_to_rank[score] = i + 1\n\n# Process queries\nimport sys\nfor line in sys.stdin:\n    query = int(line.strip())\n    score = teams[query]\n    rank = score_to_rank[score]\n    print(rank)\n", "perturbed_sampled": ["# Read team data teams = {} while True:  = int(parts[1]) if team_id == 0 and score == 0: break teams[team_id] = score # Get unique scores and sort them in descending order unique_scores = sorted(set(teams.values()), reverse=True) # Create a mapping from score to rank score_to_rank = {} for i, score in enumerate(unique_scores):  for line in sys.stdin: query = int(line.strip()) score = teams[query] rank = score_to_rank[score] print(rank)"], "perturbed_original": ["nums={} while True: p,s=map(int,input().split(',')) if(p==0 and s==0):break if not s in nums: nums[s]=[] nums[s].append(p) while True: try: q=int(input()) ans=len(nums) for ns in nums.items(): if q in ns[1]: print(ans) break ans-=1 except: break"], "original_ll": -1.3176860809326172, "sampled_ll": -0.9851930141448975, "all_perturbed_sampled_ll": [-2.2978155612945557], "all_perturbed_original_ll": [-1.9254264831542969], "perturbed_sampled_ll": -2.2978155612945557, "perturbed_original_ll": -1.9254264831542969, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#define N 100\n\nvoid hanten(char str[],int n){\n  char t;\n  int i,j;\n    for (j=0;j<n/2;j++){\n      t=str[j];\n      str[j]=str[n-j-1];\n      str[n-j-1]=t;\n    }\n}\n\nint main()\n{\n  int i,j,cnt=0;\n  char str1[N],str2[N];\n  while (scanf(\"%s\",str1)!=EOF){\n    strcpy(str2,str1);\n    hanten(str1,strlen(str1));\n    if (strcmp(str1,str2)==0)\n      cnt++;\n  }\n  printf(\"%d\\n\",cnt);\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint isPalindrome(char *str) {\n    int len = strlen(str);\n    if (str[len-1] == '\\n') {\n        str[len-1] = '\\0';\n        len--;\n    }\n    \n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - 1 - i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char line[101];\n    int count = 0;\n    \n    while (fgets(line, sizeof(line), stdin) != NULL) {\n        if (isPalindrome(line)) {\n            count++;\n        }\n    }\n    \n    printf(\"%d\\n\", count);\n    \n    return 0;\n}\n", "perturbed_sampled": [";<extra_id_2>(int n=-1; n<3; n++)<extra_id_3>0;<extra_id_4>length+3); /*count<extra_id_5>if('fgets(line, sizeof(line), stdin)<extra_id_6>{if (line[len-2] == '\\0')<extra_id_7>{ count++; } /*count++;i++;<extra_id_8>i++; }<extra_id_9>} String<extra_id_10>println(\"<extra_id_11>count<extra_id_12>fgets(line, = strlen(str); if (str[len-1] == '\\n') { str[len-1] = '\\0'; len--; } for (int i = 0; i  - 1 - i]) { return 0; } } return 1; } int main() { char line[101]; int count = 0; while (fgets(line, sizeof(line), stdin) != NULL) { if (isPalindrome(line)) { count++; } } printf(\"%d\\n\", count); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #define N 100  t=str[j]; str[j]=str[n-j-1]; str[n-j-1]=t; } } int main() { int i,j,cnt=0; char str1[N],str2[N]; while (scanf(\"%s\",str1)!=EOF){ strcpy(str2,str1); hanten(str1,strlen(str1)); if (strcmp(str1,str2)==0) cnt++; } printf(\"%d\\n\",cnt); return 0; }"], "original_ll": -1.0074193477630615, "sampled_ll": -0.5331399440765381, "all_perturbed_sampled_ll": [-1.9926973581314087], "all_perturbed_original_ll": [-1.4693644046783447], "perturbed_sampled_ll": -1.9926973581314087, "perturbed_original_ll": -1.4693644046783447, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n    private static final Scanner scn = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int cnt = 0;\n        while(scn.hasNext()) {\n            String str = scn.next();\n            String rev = new String(new StringBuilder(str).reverse());\n            if(str.equals(rev)) {\n                cnt++;\n            }\n        }\n        System.out.println(cnt);\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (isPalindrome(line)) {\n                count++;\n            }\n        }\n        \n        System.out.println(count);\n        sc.close();\n    }\n    \n    static boolean isPalindrome(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int count = 0; while (sc.hasNextLine()) { String line = sc.nextLine(); if (isPalindrome(line)) { count++; } } System.out.println(count); sc.close();  int right = s.length() - 1; while (left < right)  right--; } return true; } }"], "perturbed_original": ["import java.util.*;  new Scanner(System.in); public static void main(String[] args) { int cnt = 0; while(scn.hasNext()) { String str = scn.next(); String rev = new String(new StringBuilder(str).reverse()); if(str.equals(rev)) { cnt++; } } System.out.println(cnt); } }"], "original_ll": -0.8267020583152771, "sampled_ll": -0.3024909496307373, "all_perturbed_sampled_ll": [-1.2702817916870117], "all_perturbed_original_ll": [-1.3722059726715088], "perturbed_sampled_ll": -1.2702817916870117, "perturbed_original_ll": -1.3722059726715088, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef is_pal(s):\n    l = len(s)-1\n    for i in range(l/2):\n        if s[i] != s[l-1-i]:\n            return False\n    return True\n\ncount = 0\nfor line in sys.stdin:\n    if is_pal(line):\n        count += 1\nprint count", "sampled": "import sys\n\ncount = 0\nfor line in sys.stdin:\n    s = line.strip()\n    if s == s[::-1]:\n        count += 1\n\nprint(count)\n", "perturbed_sampled": ["import sys count = 0 for line in sys.stdin: s = line.strip() if s == s[::-1]: count += 1 print(count)"], "perturbed_original": ["# -*- coding: utf-8 -*- import  if s[i] != s[l-1-i]: return False return True count = 0 for line in sys.stdin: if is_pal(line): count += 1 print count"], "original_ll": -0.8122162222862244, "sampled_ll": -0.9955853223800659, "all_perturbed_sampled_ll": [-1.394656777381897], "all_perturbed_original_ll": [-2.430924415588379], "perturbed_sampled_ll": -1.394656777381897, "perturbed_original_ll": -2.430924415588379, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <ctype.h>\n\nint main()\n{\n        char str[81], tmp[6];\n        int num = 0, i, sum = 0;\n\n        while ( scanf( \"%s\", str ) == 1 ) {\n                i = 0;\n                while ( str[i] ) {\n                        if ( isdigit( str[i] ) ) {\n                                num = 0;\n                                while ( isdigit( str[i] ) ) {\n                                        num = 10 * num + ( str[i] - '0' );\n                                        i++;\n                                }\n                                sum = sum + num;\n                        } else {\n                                i++;\n                        }\n                }\n        }\n\n        printf( \"%d\\n\", sum );\n\n        return 0;\n}\n\n", "sampled": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    int sum = 0;\n    int num = 0;\n    int in_number = 0;\n    char c;\n    \n    while ((c = getchar()) != EOF) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n            in_number = 1;\n        } else {\n            if (in_number) {\n                sum += num;\n                num = 0;\n                in_number = 0;\n            }\n        }\n    }\n    \n    if (in_number) {\n        sum += num;\n    }\n    \n    printf(\"%d\\n\", sum);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <ctype.h> int main() { int sum = 0; int num = 0; int in_number  { if  '0'); in_number = 1; } else { if (in_number) { sum += num; num = 0; in_number = 0; } } } if (in_number) { sum += num; } printf(\"%d\\n\", sum); return 0; }"], "perturbed_original": ["#include <stdio.h> #include  0, i, sum = 0; while ( scanf( \"%s\", str ) == 1 ) { i = 0; while ( str[i] ) { if ( isdigit(  str[i] ) ) { num = 10 * num + ( str[i] - '0' ); i++; } sum = sum + num; } else { i++; } } } printf( \"%d\\n\", sum ); return 0; }"], "original_ll": -0.9237989783287048, "sampled_ll": -0.4305321276187897, "all_perturbed_sampled_ll": [-1.5135726928710938], "all_perturbed_original_ll": [-1.3964166641235352], "perturbed_sampled_ll": -1.5135726928710938, "perturbed_original_ll": -1.3964166641235352, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = 0,sum = 0;\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] ch = sc.next().toCharArray();\n\t\tfor(int i = 0; i < ch.length; i++){\n\t\t\tif('0' <= ch[i] && ch[i] <= '9'){\n\t\t\t\tn = n * 10;\n\t\t\t\tn += ch[i] - '0';\n\t\t\t}else{\n\t\t\t\tsum += n;\n\t\t\t\tn = 0;\n\t\t\t}\n\t\t}\n\t\tsum += n;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t\tsc.close();\n\t}\n}", "sampled": "import java.util.*;\nimport java.util.regex.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int sum = 0;\n        Pattern pattern = Pattern.compile(\"\\\\d+\");\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            Matcher matcher = pattern.matcher(line);\n            \n            while (matcher.find()) {\n                sum += Integer.parseInt(matcher.group());\n            }\n        }\n        \n        System.out.println(sum);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import  { Scanner sc = new Scanner(System.in); int sum = 0; Pattern pattern = Pattern.compile(\"\\\\d+\"); while (sc.hasNextLine()) { String line = sc.nextLine(); Matcher matcher = pattern.matcher(line); while (matcher.find()) { sum += Integer.parseInt(matcher.group()); } } System.out.println(sum); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc =  ch = sc.next().toCharArray(); for(int i =  <= '9'){ n = n * 10; n += ch[i] - '0'; }else{ sum += n; n = 0; } } sum += n; } System.out.println(sum); sc.close(); } }"], "original_ll": -0.7045949697494507, "sampled_ll": -0.5067358016967773, "all_perturbed_sampled_ll": [-1.1261168718338013], "all_perturbed_original_ll": [-1.9048089981079102], "perturbed_sampled_ll": -1.1261168718338013, "perturbed_original_ll": -1.9048089981079102, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import re\nans = 0\nwhile True:\n    try:\n        line = input()\n    except:\n        print(ans)\n        break\n    ans += sum(map(int, re.findall(\"[0-9]+\", line)))", "sampled": "import sys\nimport re\n\ntotal = 0\nfor line in sys.stdin:\n    numbers = re.findall(r'\\d+', line)\n    for num in numbers:\n        total += int(num)\n\nprint(total)\n", "perturbed_sampled": ["import sys import re total = 0 for line in sys.stdin: numbers = re.findall(r'\\d+', line) for num in numbers: total += int(num) print(total)"], "perturbed_original": ["import re ans = 0 while True: try: line = input() except: print(ans) break ans += sum(map(int, re.findall(\"[0-9]+\", line)))"], "original_ll": -1.2053115367889404, "sampled_ll": -0.8612873554229736, "all_perturbed_sampled_ll": [-1.5486139059066772], "all_perturbed_original_ll": [-1.9383078813552856], "perturbed_sampled_ll": -1.5486139059066772, "perturbed_original_ll": -1.9383078813552856, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\n#include <stdlib.h>\n#include<string.h>\n#include<limits.h>\n#include<time.h>\n\nvoid sosu(int n){\n\tint i,j,num[n];\n\t\n\tfor(i=2;i<=n;i++)num[i]=i;\n\tfor(i=2;i<=sqrt(n);i++){\n\t\tfor(j=2;j*i<=n;j++)num[j*i]=0;\n\t}\n}\n\nint main(){\n\tint number[10000]={0};\n\tint ac[10000]={0};\n\tint i,j,k,count;\n\t\n\tfor(i=0;scanf(\"%d,%d\",&number[i],&ac[i])!=EOF;i++);\n\tfor(j=i;scanf(\"%d,%d\",&number[j],&ac[j])!=EOF;j++);\n\tcount=j;\n\t\n\tfor(i=0;i<count;i++){\n\t\tfor(j=0;j<count;j++){\n\t\t\tif(number[i]<number[j]){\n\t\t\t\tk=number[i];\n\t\t\t\tnumber[i]=number[j];\n\t\t\t\tnumber[j]=k;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0,k=0;i<count;i++){\n\t\tfor(j=i;j<count;j++){\n\t\t\tif(number[i]==number[j] && i!=j)k++;\n\t\t}\n\t\ti+=k;\n\t\tif(k>=1)printf(\"%d %d\\n\",number[i],k+1);\n\t\tk=0;\n\t}\n\t\nreturn 0;\n\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int this_month[1001] = {0};\n    int last_month[1001] = {0};\n    int customer, day;\n    char line[100];\n    int reading_this_month = 1;\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        if (line[0] == '\\n' || strlen(line) <= 1) {\n            reading_this_month = 0;\n            continue;\n        }\n        \n        if (sscanf(line, \"%d,%d\", &customer, &day) == 2) {\n            if (reading_this_month) {\n                this_month[customer]++;\n            } else {\n                last_month[customer]++;\n            }\n        }\n    }\n    \n    for (int i = 1; i <= 1000; i++) {\n        if (this_month[i] > 0 && last_month[i] > 0) {\n            printf(\"%d %d\\n\", i, this_month[i] + last_month[i]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int this_month[1001] = {0}; int last_month[1001] = {0}; int customer, day; char line[100]; int reading_this_month = 1; while (fgets(line, sizeof(line), stdin)) { if (line[0] == '\\n' || strlen(line) <= 1) { reading_this_month = 0; continue;  (reading_this_month) { this_month[customer]++; } else { last_month[customer]++; } } } for (int i = 1; i <= 1000; i++) { if (this_month[i]  this_month[i] + last_month[i]); } } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h> #include <stdlib.h> #include<string.h> #include<limits.h> #include<time.h> void sosu(int n){ int  int ac[10000]={0}; int i,j,k,count; for(i=0;scanf(\"%d,%d\",&number[i],&ac[i])!=EOF;i++); for(j=i;scanf(\"%d,%d\",&number[j],&ac[j])!=EOF;j++); count=j; for(i=0;i<count;i++){ for(j=0;j<count;j++){ if(number[i]<number[j]){ k=number[i]; number[i]=number[j]; number[j]=k; } } } for(i=0,k=0;i<count;i++){ for(j=i;j<count;j++){ if(number[i]==number[j] && i!=j)k++; } i+=k; if(k>=1)printf(\"%d %d\\n\",number[i],k+1); k=0; } return 0; }"], "original_ll": -1.059664011001587, "sampled_ll": -0.7164496183395386, "all_perturbed_sampled_ll": [-1.3395622968673706], "all_perturbed_original_ll": [-1.4350547790527344], "perturbed_sampled_ll": -1.3395622968673706, "perturbed_original_ll": -1.4350547790527344, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.util.Map.Entry;\n\n//\u6587\u5b57\u64cd\u4f5c\nclass Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic void run() {\n\t\tHashtable<Integer,Integer> data1=new Hashtable<Integer, Integer>();\n\t\tHashtable<Integer,Integer> data2=new Hashtable<Integer, Integer>();\n\n\t\twhile(sc.hasNext()){\n\t\t\tString[] str=sc.nextLine().split(\",\");\n\t\t\tif(\"\".equals(str[0]))break;\n\t\t\tint[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])};\n\t\t\tif(data1.containsKey(vals[0])){\n\t\t\t\tdata1.put(vals[0],data1.get(vals[0])+1);\n\t\t\t}else{\n\t\t\t\tdata1.put(vals[0],1);\n\t\t\t}\n\t\t}\n\t\twhile(sc.hasNext()){\n\t\t\tString[] str=sc.nextLine().split(\",\");\n\t\t\tif(\"\".equals(str[0]))break;\n\t\t\tint[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])};\n\t\t\tif(data2.containsKey(vals[0])){\n\t\t\t\tdata2.put(vals[0],data2.get(vals[0])+1);\n\t\t\t}else{\n\t\t\t\tdata2.put(vals[0],1);\n\t\t\t}\n\t\t}\n\t\tArrayList<Entry<Integer,Integer>> data1list=new ArrayList<Entry<Integer,Integer>>(data1.entrySet());\n\t\tCollections.sort(data1list,new Comparator<Entry<Integer,Integer>>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Entry<Integer, Integer> o1,\n\t\t\t\t\tEntry<Integer, Integer> o2) {\n\t\t\t\treturn o1.getKey()-o2.getKey();\n\t\t\t}\n\t\t});\n\t\tfor(Entry<Integer,Integer> entry:data1list){\n\t\t\tif(data2.containsKey(entry.getKey())){\n\t\t\t\tln(entry.getKey()+\" \"+ (entry.getValue()+data2.get(entry.getKey())));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Map<Integer, Integer> thisMonth = new HashMap<>();\n        Map<Integer, Integer> lastMonth = new HashMap<>();\n        \n        // Read this month's data\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.trim().isEmpty()) {\n                break;\n            }\n            String[] parts = line.split(\",\");\n            int customer = Integer.parseInt(parts[0]);\n            thisMonth.put(customer, thisMonth.getOrDefault(customer, 0) + 1);\n        }\n        \n        // Read last month's data\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.trim().isEmpty()) {\n                break;\n            }\n            String[] parts = line.split(\",\");\n            int customer = Integer.parseInt(parts[0]);\n            lastMonth.put(customer, lastMonth.getOrDefault(customer, 0) + 1);\n        }\n        \n        // Find customers in both months\n        Set<Integer> commonCustomers = new HashSet<>(thisMonth.keySet());\n        commonCustomers.retainAll(lastMonth.keySet());\n        \n        // Sort and output\n        List<Integer> sortedCustomers = new ArrayList<>(commonCustomers);\n        Collections.sort(sortedCustomers);\n        \n        for (int customer : sortedCustomers) {\n            int total = thisMonth.get(customer) + lastMonth.get(customer);\n            System.out.println(customer + \" \" + total);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); Map<Integer, Integer> thisMonth  Read this month's data while (sc.hasNextLine()) { String line = sc.nextLine(); if (line.trim().isEmpty()) { break;  thisMonth.getOrDefault(customer, 0) + 1); } // Read last month's data while (sc.hasNextLine()) { String line = sc.nextLine(); if (line.trim().isEmpty()) { break; } String[] parts = line.split(\",\"); int customer = Integer.parseInt(parts[0]); lastMonth.put(customer,  months Set<Integer> commonCustomers = new HashSet<>(thisMonth.keySet()); commonCustomers.retainAll(lastMonth.keySet()); // Sort and output  sortedCustomers) { int total = thisMonth.get(customer) + lastMonth.get(customer); System.out.println(customer + \" \" + total); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.util.Map.Entry; //\u6587\u5b57\u64cd\u4f5c  Integer>(); while(sc.hasNext()){ String[] str=sc.nextLine().split(\",\"); if(\"\".equals(str[0]))break; int[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])}; if(data1.containsKey(vals[0])){ data1.put(vals[0],data1.get(vals[0])+1);  int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])}; if(data2.containsKey(vals[0])){ data2.put(vals[0],data2.get(vals[0])+1); }else{ data2.put(vals[0],1); } } ArrayList<Entry<Integer,Integer>> data1list=new ArrayList<Entry<Integer,Integer>>(data1.entrySet()); Collections.sort(data1list,new Comparator<Entry<Integer,Integer>>() { @Override public int compare(Entry<Integer, Integer> o1, Entry<Integer, Integer> o2) { return o1.getKey()-o2.getKey(); } }); for(Entry<Integer,Integer> entry:data1list){ if(data2.containsKey(entry.getKey())){ ln(entry.getKey()+\" \"+ (entry.getValue()+data2.get(entry.getKey()))); } } } public static void main(String[] args) { new Main().run(); } public static void pr(Object o) { System.out.print(o); } public static void ln(Object o) { System.out.println(o); } public static void ln() { System.out.println(); } }"], "original_ll": -0.6889062523841858, "sampled_ll": -0.44719964265823364, "all_perturbed_sampled_ll": [-1.6028317213058472], "all_perturbed_original_ll": [-1.1362488269805908], "perturbed_sampled_ll": -1.6028317213058472, "perturbed_original_ll": -1.1362488269805908, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nb=0\na=[{},{}]\nfor e in sys.stdin:\n if'\\n'==e:b=1\n else:c=int(e.split(',')[0]);a[b].setdefault(c,0);a[b][c]+=1\nfor k in sorted({*a[0]}&{*a[1]}):print(k,a[0][k]+a[1][k])\n", "sampled": "import sys\n\n# Read all input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.strip())\n\n# Find the empty line that separates this month and last month\nseparator_idx = -1\nfor i, line in enumerate(lines):\n    if line == '':\n        separator_idx = i\n        break\n\n# Parse this month's data\nthis_month = lines[:separator_idx]\nlast_month = lines[separator_idx + 1:]\n\n# Count transactions for each customer\nthis_month_customers = {}\nlast_month_customers = {}\n\nfor line in this_month:\n    if line:\n        parts = line.split(',')\n        customer_id = int(parts[0])\n        this_month_customers[customer_id] = this_month_customers.get(customer_id, 0) + 1\n\nfor line in last_month:\n    if line:\n        parts = line.split(',')\n        customer_id = int(parts[0])\n        last_month_customers[customer_id] = last_month_customers.get(customer_id, 0) + 1\n\n# Find customers who appear in both months\ncommon_customers = set(this_month_customers.keys()) & set(last_month_customers.keys())\n\n# Calculate total transactions and sort by customer ID\nresults = []\nfor customer_id in common_customers:\n    total_transactions = this_month_customers[customer_id] + last_month_customers[customer_id]\n    results.append((customer_id, total_transactions))\n\nresults.sort()\n\n# Output\nfor customer_id, total in results:\n    print(customer_id, total)\n", "perturbed_sampled": ["import sys # Read all input lines = [] for line in sys.stdin: lines.append(line.strip()) # Find the empty line that separates this month and last month separator_idx = -1 for i, line in enumerate(lines): if line == '': separator_idx = i break # Parse this month's data this_month = lines[:separator_idx] last_month = lines[separator_idx + 1:] # Count transactions for each customer this_month_customers = {} last_month_customers = {} for line in this_month: if line: parts = line.split(',') customer_id = int(parts[0]) this_month_customers[customer_id] = this_month_customers.get(customer_id, 0) + 1 for line in last_month: if line:  for customer_id in common_customers: total_transactions = this_month_customers[customer_id] + last_month_customers[customer_id] results.append((customer_id, total_transactions)) results.sort() # Output for customer_id, total in results: print(customer_id, total)"], "perturbed_original": ["import sys b=0 a=[{},{}] for e in sys.stdin: if'\\n'==e:b=1 else:c=int(e.split(',')[0]);a[b].setdefault(c,0);a[b][c]+=1 for k in sorted({*a[0]}&{*a[1]}):print(k,a[0][k]+a[1][k])"], "original_ll": -2.024172067642212, "sampled_ll": -0.742479145526886, "all_perturbed_sampled_ll": [-1.5275623798370361], "all_perturbed_original_ll": [-2.1541082859039307], "perturbed_sampled_ll": -1.5275623798370361, "perturbed_original_ll": -2.1541082859039307, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nchar map[16][16] = {0};\n\nvoid delete_island(int x, int y)\n{\n\tif (map[x][y] == 0) return;\n\tmap[x][y] = 0;\n\tdelete_island(x - 1, y);\n\tdelete_island(x + 1, y);\n\tdelete_island(x, y - 1);\n\tdelete_island(x, y + 1);\n}\n\nint main(void)\n{\n\twhile (scanf(\"%s\", &map[0][1]) != EOF){\n\t\tint i, j;\n\t\tint count = 0;\n\t\t\n\t\tfor (i = 1; i < 12; i++) scanf(\"%s\", &map[i][1]);\n\t\tfor (i = 0; i < 12; i++){\n\t\t\tfor (j = 0; j < 12; j++) map[i][j + 1] -= '0';\n\t\t}\n\t\t\n\t\tfor (i = 0; i < 12; i++){\n\t\t\tfor (j = 0; j < 12; j++){\n\t\t\t\tif (map[i][j + 1] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tdelete_island(i, j + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", count);\n\t\tscanf(\"%*c\");\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint grid[12][12];\nint visited[12][12];\n\nvoid dfs(int i, int j) {\n    if (i < 0 || i >= 12 || j < 0 || j >= 12) return;\n    if (grid[i][j] == 0 || visited[i][j]) return;\n    \n    visited[i][j] = 1;\n    \n    dfs(i-1, j);\n    dfs(i+1, j);\n    dfs(i, j-1);\n    dfs(i, j+1);\n}\n\nint main() {\n    char line[100];\n    \n    while (1) {\n        int hasInput = 0;\n        \n        for (int i = 0; i < 12; i++) {\n            if (fgets(line, sizeof(line), stdin) == NULL) {\n                return 0;\n            }\n            \n            if (strlen(line) > 1 && line[0] != '\\n') {\n                hasInput = 1;\n                for (int j = 0; j < 12; j++) {\n                    grid[i][j] = line[j] - '0';\n                }\n            } else if (strlen(line) <= 1 || line[0] == '\\n') {\n                if (!hasInput) {\n                    i--;\n                    continue;\n                } else {\n                    return 0;\n                }\n            }\n        }\n        \n        if (!hasInput) break;\n        \n        memset(visited, 0, sizeof(visited));\n        \n        int islands = 0;\n        for (int i = 0; i < 12; i++) {\n            for (int j = 0; j < 12; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    dfs(i, j);\n                    islands++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", islands);\n        \n        while (fgets(line, sizeof(line), stdin) != NULL) {\n            if (line[0] != '\\n' && strlen(line) > 1) {\n                fseek(stdin, -(long)strlen(line), SEEK_CUR);\n                break;\n            }\n            if (feof(stdin)) return 0;\n        }\n        \n        if (feof(stdin)) break;\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int grid[12][12]; int visited[12][12]; void  i >= 12 || j < 0 || j >= 12) return; if (grid[i][j] == 0 || visited[i][j]) return; visited[i][j] = 1; dfs(i-1, j);  char line[100]; while (1) { int hasInput = 0; for (int i = 0; i < 12; i++) {  if (strlen(line) > 1 && line[0] != '\\n') { hasInput = 1; for (int j = 0; j < 12; j++) { grid[i][j] = line[j] - '0'; } } else if (strlen(line) <= 1 || line[0]  { return 0; } } } if (!hasInput) break; memset(visited, 0, sizeof(visited)); int islands = 0; for (int i = 0; i < 12; i++) { for (int j = 0; j < 12; j++) { if (grid[i][j]  }  (line[0] != '\\n' && strlen(line) > 1) { fseek(stdin, -(long)strlen(line), SEEK_CUR); break; } if (feof(stdin)) return 0; } if (feof(stdin)) break; } return 0; }"], "perturbed_original": ["#include <stdio.h> char map[16][16] = {0}; void delete_island(int  = 0; delete_island(x - 1, y); delete_island(x + 1, y); delete_island(x, y - 1); delete_island(x, y + 1); } int main(void) { while (scanf(\"%s\", &map[0][1]) != EOF){ int i, j; int count = 0; for (i = 1; i < 12; i++) scanf(\"%s\", &map[i][1]);  = 0; j < 12;  0; i < 12; i++){ for (j = 0; j < 12; j++){ if (map[i][j + 1] == 1){ count++; delete_island(i, j + 1); } } } printf(\"%d\\n\", count); scanf(\"%*c\"); } return 0; }"], "original_ll": -0.6796762347221375, "sampled_ll": -0.502373218536377, "all_perturbed_sampled_ll": [-1.1202048063278198], "all_perturbed_original_ll": [-1.212912917137146], "perturbed_sampled_ll": -1.1202048063278198, "perturbed_original_ll": -1.212912917137146, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u30fb\u30b9\u30bf\u30d6\n\t\tnew Main().run();\n\t}\n\t\n\tint filed[][]=new int[12][12];\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint count=0;\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tchar ch[]=sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\t\tfiled[i][j]=ch[j]-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\t\tif(filed[i][j]==1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tdfs(j,i,12,12);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n    int mx[]={-1,0,1,0};\n    int my[]={0,-1,0,1};\n\tvoid dfs(int x,int y,int w,int h){\n        int i,nx,ny;\n        for(i=0;i<4;i++){\n            nx=x+mx[i];\n            ny=y+my[i];\n            if(0<=nx && nx<w && 0<=ny && ny<h && filed[ny][nx]!=0){\n                filed[ny][nx]=0;\n                dfs(nx,ny,w,h);\n            }\n        }\n    }\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[][] grid;\n    static boolean[][] visited;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            grid = new int[12][12];\n            visited = new boolean[12][12];\n            \n            // Read 12 lines for the grid\n            boolean validInput = true;\n            for (int i = 0; i < 12; i++) {\n                if (!sc.hasNextLine()) {\n                    validInput = false;\n                    break;\n                }\n                String line = sc.nextLine().trim();\n                if (line.isEmpty()) {\n                    validInput = false;\n                    break;\n                }\n                for (int j = 0; j < 12 && j < line.length(); j++) {\n                    grid[i][j] = line.charAt(j) - '0';\n                }\n            }\n            \n            if (!validInput) {\n                break;\n            }\n            \n            // Count islands\n            int islands = 0;\n            for (int i = 0; i < 12; i++) {\n                for (int j = 0; j < 12; j++) {\n                    if (grid[i][j] == 1 && !visited[i][j]) {\n                        dfs(i, j);\n                        islands++;\n                    }\n                }\n            }\n            \n            System.out.println(islands);\n            \n            // Skip empty line between datasets\n            if (sc.hasNextLine()) {\n                String line = sc.nextLine();\n                // If the line is not empty, we need to check if it's the start of next dataset\n                if (!line.trim().isEmpty()) {\n                    // This is the first line of next dataset\n                    grid = new int[12][12];\n                    visited = new boolean[12][12];\n                    \n                    // Process this first line\n                    for (int j = 0; j < 12 && j < line.length(); j++) {\n                        grid[0][j] = line.charAt(j) - '0';\n                    }\n                    \n                    // Read remaining 11 lines\n                    for (int i = 1; i < 12; i++) {\n                        if (!sc.hasNextLine()) break;\n                        line = sc.nextLine().trim();\n                        if (line.isEmpty()) break;\n                        for (int j = 0; j < 12 && j < line.length(); j++) {\n                            grid[i][j] = line.charAt(j) - '0';\n                        }\n                    }\n                    \n                    // Count islands\n                    islands = 0;\n                    for (int i = 0; i < 12; i++) {\n                        for (int j = 0; j < 12; j++) {\n                            if (grid[i][j] == 1 && !visited[i][j]) {\n                                dfs(i, j);\n                                islands++;\n                            }\n                        }\n                    }\n                    \n                    System.out.println(islands);\n                    \n                    // Skip empty line\n                    if (sc.hasNextLine()) {\n                        sc.nextLine();\n                    }\n                }\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static void dfs(int x, int y) {\n        visited[x][y] = true;\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if (nx >= 0 && nx < 12 && ny >= 0 && ny < 12 && \n                grid[nx][ny] == 1 && !visited[nx][ny]) {\n                dfs(nx, ny);\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int[][] grid; static boolean[][] visited; static int[] dx = {-1, 1, 0, 0}; static int[] dy =  Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { grid = new int[12][12]; visited = new boolean[12][12]; // Read 12 lines for the grid boolean validInput = true; for (int i = 0; i < 12; i++) { if (!sc.hasNextLine()) { validInput = false; break; } String line = sc.nextLine().trim(); if (line.isEmpty()) { validInput = false; break; } for (int j = 0; j < 12 && j < line.length(); j++) { grid[i][j] = line.charAt(j) - '0'; }  islands = 0; for (int i = 0; i < 12; i++) { for (int j  } System.out.println(islands); // Skip empty line between datasets if (sc.hasNextLine()) { String line = sc.nextLine(); // If the line is not empty, we need to check if it's the start of next dataset if (!line.trim().isEmpty()) { // This is the first line of next dataset grid = new int[12][12]; visited = new boolean[12][12]; // Process this first line for (int j = 0; j < 12 && j < line.length(); j++) { grid[0][j] = line.charAt(j) - '0'; }  = sc.nextLine().trim(); if (line.isEmpty()) break; for (int j = 0; j  line.charAt(j) - '0'; } } // Count islands islands  i++) { for (int j = 0; j < 12; j++) { if (grid[i][j] == 1 && !visited[i][j]) { dfs(i, j); islands++; } } } System.out.println(islands); // Skip empty line if (sc.hasNextLine()) { sc.nextLine(); } } } } sc.close(); } static void dfs(int x, int y) { visited[x][y]  ny = y + dy[i]; if  0 && ny < 12 && grid[nx][ny] == 1 && !visited[nx][ny]) { dfs(nx, ny); } } } }"], "perturbed_original": ["import java.util.Scanner; public class Main {  Main().run(); } int filed[][]=new int[12][12]; void run(){ Scanner sc=new Scanner(System.in); while(sc.hasNext()){  } for(int i=0;i<12;i++){ for(int j=0;j<12;j++){ if(filed[i][j]==1){ count++; dfs(j,i,12,12); } } } System.out.println(count); } } int mx[]={-1,0,1,0}; int my[]={0,-1,0,1}; void dfs(int x,int y,int w,int h){ int i,nx,ny; for(i=0;i<4;i++){ nx=x+mx[i]; ny=y+my[i]; if(0<=nx && nx<w && 0<=ny && ny<h && filed[ny][nx]!=0){ filed[ny][nx]=0; dfs(nx,ny,w,h); } } } }"], "original_ll": -0.8550409078598022, "sampled_ll": -0.4221113920211792, "all_perturbed_sampled_ll": [-1.1050159931182861], "all_perturbed_original_ll": [-1.1753965616226196], "perturbed_sampled_ll": -1.1050159931182861, "perturbed_original_ll": -1.1753965616226196, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Depth_First_Search_stack:\n    def __init__(self, map):\n        self.map = map\n        self.num_island = 0\n        self.stack = []\n        self.start_point = None\n\n    def get_start_point(self):\n        get_start = False\n        for i in range(12):\n            for j in range(12):\n                if self.map[i][j] == '1':\n                    self.start_point = [i, j]\n                    get_start = True\n        return get_start\n\n    def check(self, new_r, new_c):\n        return 0<=new_r<12 and 0<=new_c<12 and self.map[new_r][new_c] == '1'\n\n    def search(self, r, c):\n        while self.stack:\n            r, c = self.stack.pop()\n            self.map[r][c] = '0'\n            for (i, j) in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n                if self.check(r+i, c+j):\n                    self.stack.append([r+i, c+j])\n\n    def run(self):\n        while self.get_start_point():\n            r, c = self.start_point\n            self.stack.append([r, c])\n            self.search(r, c)\n            self.num_island += 1\n\nif __name__ == '__main__':\n    while 1:\n        map = []\n        for i in range(12):\n            row = [x for x in input()]\n            map.append(row)\n\n        if len(map[0]) != 12:\n            break\n\n        DFS = Depth_First_Search_stack(map)\n        DFS.run()\n        print(DFS.num_island)\n\n        empty = input()", "sampled": "import sys\nfrom collections import deque\n\ndef count_islands(grid):\n    rows = 12\n    cols = 12\n    visited = [[False] * cols for _ in range(rows)]\n    count = 0\n    \n    def bfs(start_r, start_c):\n        queue = deque([(start_r, start_c)])\n        visited[start_r][start_c] = True\n        \n        while queue:\n            r, c = queue.popleft()\n            # Check 4 directions: up, down, left, right\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == 1:\n                    visited[nr][nc] = True\n                    queue.append((nr, nc))\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1 and not visited[i][j]:\n                bfs(i, j)\n                count += 1\n    \n    return count\n\ndef main():\n    lines = []\n    for line in sys.stdin:\n        lines.append(line.rstrip('\\n'))\n    \n    datasets = []\n    current_dataset = []\n    \n    for line in lines:\n        if line == '':\n            if current_dataset:\n                datasets.append(current_dataset)\n                current_dataset = []\n        else:\n            current_dataset.append(line)\n    \n    if current_dataset:\n        datasets.append(current_dataset)\n    \n    for dataset in datasets:\n        grid = []\n        for line in dataset:\n            row = [int(c) for c in line]\n            grid.append(row)\n        \n        result = count_islands(grid)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from  12 visited = [[False] * cols for _ in range(rows)] count = 0 def bfs(start_r, start_c): queue = deque([(start_r, start_c)]) visited[start_r][start_c] = True  up, down, left, right for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < rows and  == 1: visited[nr][nc] = True queue.append((nr, nc)) for i in range(rows): for j in range(cols): if grid[i][j] == 1 and  main(): lines = [] for line in sys.stdin: lines.append(line.rstrip('\\n')) datasets = [] current_dataset = [] for line in lines: if line == '': if current_dataset: datasets.append(current_dataset) current_dataset = [] else: current_dataset.append(line) if current_dataset: datasets.append(current_dataset) for dataset in datasets: grid = [] for line  result = count_islands(grid) print(result) if __name__ == \"__main__\": main()"], "perturbed_original": ["class Depth_First_Search_stack: def __init__(self,  self.start_point = None def get_start_point(self): get_start = False for i  self.start_point = [i, j] get_start = True return  self.map[new_r][new_c] == '1' def search(self, r, c): while self.stack: r, c = self.stack.pop() self.map[r][c] = '0' for (i, j) in [[1, 0], [0, 1], [-1, 0], [0, -1]]: if self.check(r+i, c+j): self.stack.append([r+i, c+j]) def run(self): while self.get_start_point(): r, c = self.start_point self.stack.append([r, c]) self.search(r, c) self.num_island += 1 if __name__ == '__main__': while 1: map =  in input()] map.append(row) if len(map[0]) != 12: break DFS = Depth_First_Search_stack(map) DFS.run() print(DFS.num_island) empty = input()"], "original_ll": -0.721847653388977, "sampled_ll": -0.3918014466762543, "all_perturbed_sampled_ll": [-1.3844376802444458], "all_perturbed_original_ll": [-1.7189652919769287], "perturbed_sampled_ll": -1.3844376802444458, "perturbed_original_ll": -1.7189652919769287, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x,y;\n} xy_t;\n\nint qsort_comp(const void* x,const void* y) {\n\tconst xy_t* a=(const xy_t*)x;\n\tconst xy_t* b=(const xy_t*)y;\n\tif((a->x)>(b->x))return 1;\n\tif((a->x)<(b->x))return -1;\n\tif((a->y)>(b->y))return 1;\n\tif((a->y)<(b->y))return -1;\n\treturn 0;\n}\n\nint zahyou_num;\nxy_t zahyou[100];\n\nint th_up_n;\nint th_down_n;\nxy_t th_up[100];\nxy_t th_down[100];\n\nint main(void) {\n\tint i;\n\twhile(1) {\n\t\tscanf(\"%d\",&zahyou_num);\n\t\tif(zahyou_num==0)break;\n\t\tfor(i=0;i<zahyou_num;i++) {\n\t\t\tscanf(\"%lf,%lf\",&zahyou[i].x,&zahyou[i].y);\n\t\t}\n\t\tqsort(zahyou,zahyou_num,sizeof(xy_t),qsort_comp);\n\t\t//sita no totu-ho\n\t\tth_down_n=1;\n\t\tth_down[0].x=zahyou[0].x;\n\t\tth_down[0].y=zahyou[0].y;\n\t\tfor(i=1;i<zahyou_num;i++) {\n\t\t\t//if(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\twhile(th_down_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_down[th_down_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_down[th_down_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_down[th_down_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_down[th_down_n-1].x==th_down[th_down_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_down[th_down_n-1].y<th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else if(th_down[th_down_n-1].y>th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_down[th_down_n-1].y-th_down[th_down_n-2].y)/\n\t\t\t\t\t\t   (th_down[th_down_n-1].x-th_down[th_down_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_down_n--;\n\t\t\t\t}\n\t\t\t//}\n\t\t\tth_down[th_down_n].x=zahyou[i].x;\n\t\t\tth_down[th_down_n].y=zahyou[i].y;\n\t\t\tth_down_n++;\n\t\t}\n\t\t//ue no totu-ho\n\t\tth_up_n=1;\n\t\tth_up[0].x=zahyou[zahyou_num-1].x;\n\t\tth_up[0].y=zahyou[zahyou_num-1].y;\n\t\tfor(i=zahyou_num-2;i>=0;i--) {\n\t\t\t//if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\twhile(th_up_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_up[th_up_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_up[th_up_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_up[th_up_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_up[th_up_n-1].x==th_up[th_up_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_up[th_up_n-1].y<th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else if(th_up[th_up_n-1].y>th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_up[th_up_n-1].y-th_up[th_up_n-2].y)/\n\t\t\t\t\t\t   (th_up[th_up_n-1].x-th_up[th_up_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_up_n--;\n\t\t\t\t}\n\t\t\t//}\n\t\t\tth_up[th_up_n].x=zahyou[i].x;\n\t\t\tth_up[th_up_n].y=zahyou[i].y;\n\t\t\tth_up_n++;\n\t\t}\n\t\tprintf(\"%d\\n\",zahyou_num-(th_down_n+th_up_n-2));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross(Point O, Point A, Point B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nint convexHull(Point points[], int n, int hull[]) {\n    int k = 0;\n    \n    // Find bottommost point (or leftmost in case of tie)\n    int minIdx = 0;\n    for (int i = 1; i < n; i++) {\n        if (points[i].y < points[minIdx].y || \n            (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {\n            minIdx = i;\n        }\n    }\n    \n    // Start from bottommost point\n    int current = minIdx;\n    do {\n        hull[k++] = current;\n        int next = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == current) continue;\n            \n            if (next == current) {\n                next = i;\n            } else {\n                double cp = cross(points[current], points[next], points[i]);\n                if (cp < 0 || (cp == 0 && \n                    (pow(points[i].x - points[current].x, 2) + pow(points[i].y - points[current].y, 2)) >\n                    (pow(points[next].x - points[current].x, 2) + pow(points[next].y - points[current].y, 2)))) {\n                    next = i;\n                }\n            }\n        }\n        current = next;\n    } while (current != minIdx);\n    \n    return k;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Point points[100];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf,%lf\", &points[i].x, &points[i].y);\n        }\n        \n        if (n == 3) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        int hull[100];\n        int hullSize = convexHull(points, n, hull);\n        \n        printf(\"%d\\n\", n - hullSize);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> typedef struct { double x, y; } Point; double cross(Point O, Point A, Point B) { return (A.x - O.x) * (B.y - O.y)  convexHull(Point points[], int n, int hull[]) { int k = 0; // Find bottommost point (or leftmost in case of tie) int minIdx = 0; for (int i = 1; i < n; i++) { if (points[i].y < points[minIdx].y  = i; } } // Start from bottommost point int current = minIdx; do { hull[k++] = current; int next = 0; for (int i = 0; i < n; i++) { if (i  i; } else { double cp = cross(points[current], points[next], points[i]); if (cp < 0 || (cp == 0 && (pow(points[i].x - points[current].x, 2) + pow(points[i].y - points[current].y, 2)) > (pow(points[next].x - points[current].x, 2) + pow(points[next].y - points[current].y, 2)))) {  { int n; while (scanf(\"%d\", &n) == 1 && n != 0) { Point points[100]; for (int  &points[i].y); } if (n == 3) { printf(\"0\\n\"); continue; }  - hullSize); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> typedef struct  y) { const xy_t* a=(const xy_t*)x; const xy_t* b=(const xy_t*)y; if((a->x)>(b->x))return 1; if((a->x)<(b->x))return -1; if((a->y)>(b->y))return 1; if((a->y)<(b->y))return -1; return 0; }  xy_t th_down[100]; int main(void) { int i; while(1) { scanf(\"%d\",&zahyou_num); if(zahyou_num==0)break; for(i=0;i<zahyou_num;i++) { scanf(\"%lf,%lf\",&zahyou[i].x,&zahyou[i].y); } qsort(zahyou,zahyou_num,sizeof(xy_t),qsort_comp); //sita no totu-ho th_down_n=1; th_down[0].x=zahyou[0].x; th_down[0].y=zahyou[0].y; for(i=1;i<zahyou_num;i++) { //if(zahyou[i].y<th_down[th_down_n-1].y) { while(th_down_n>1) { double k1,k2; if(zahyou[i].x==th_down[th_down_n-1].x) { //INF if(zahyou[i].y<th_down[th_down_n-1].y) { k1=-1e+200; } else if(zahyou[i].y>th_down[th_down_n-1].y) { k1=1e+200; } else k1=0; } else { k1=(zahyou[i].y-th_down[th_down_n-1].y)/ (zahyou[i].x-th_down[th_down_n-1].x); } if(th_down[th_down_n-1].x==th_down[th_down_n-2].x) { //INF if(th_down[th_down_n-1].y<th_down[th_down_n-2].y) { k2=-1e+200; } else if(th_down[th_down_n-1].y>th_down[th_down_n-2].y) { k2=1e+200; } else k2=0;  th_down[th_down_n].x=zahyou[i].x; th_down[th_down_n].y=zahyou[i].y; th_down_n++; } //ue no totu-ho  k1,k2; if(zahyou[i].x==th_up[th_up_n-1].x) { //INF if(zahyou[i].y<th_up[th_up_n-1].y) { k1=1e+200; } else if(zahyou[i].y>th_up[th_up_n-1].y) { k1=-1e+200; } else k1=0; } else { k1=(zahyou[i].y-th_up[th_up_n-1].y)/ (zahyou[i].x-th_up[th_up_n-1].x); } if(th_up[th_up_n-1].x==th_up[th_up_n-2].x) { //INF if(th_up[th_up_n-1].y<th_up[th_up_n-2].y) { k2=1e+200; } else if(th_up[th_up_n-1].y>th_up[th_up_n-2].y) { k2=-1e+200; } else k2=0; } else {  } printf(\"%d\\n\",zahyou_num-(th_down_n+th_up_n-2)); } return 0; }"], "original_ll": -0.4097282290458679, "sampled_ll": -0.5593058466911316, "all_perturbed_sampled_ll": [-1.319888710975647], "all_perturbed_original_ll": [-0.7525902390480042], "perturbed_sampled_ll": -1.319888710975647, "perturbed_original_ll": -0.7525902390480042, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\t\n\tclass Point{\n\t\tpublic double x,y;\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t\t\n\t\tpublic Point(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\t\n\tdouble getTheta(Point p,Point p0){\n\t\tdouble theta=Math.acos((p.x-p0.x)/Math.hypot(p.x-p0.x,p.y-p0.y));\n\t\tif(p.y<p0.y)theta=Math.PI*2-theta;\n\t\treturn theta;\n\t}\n\t\n\tint solve(Point[] points){\n\t\tPoint start=points[0];\n\t\tfor(Point v:points){\n\t\t\tif(v.y<start.y)start=v;\n\t\t}\n\t\tPoint p0=start;\n\t\tint n=0;\n\t\tdouble prev=0;\n\t\tdo{\n\t\t\tdouble min=Math.PI*3;\n\t\t\tPoint next=p0;\n\t\t\tfor(Point p: points){\n\t\t\t\tdouble theta=getTheta(p,p0);\n\t\t\t\tif(theta>=prev&&theta<min){\n\t\t\t\t\tmin=theta;\n\t\t\t\t\tnext=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp0=next;\n\t\t\tprev=min;\n\t\t\t++n;\n\t\t}while(p0!=start);\n\t\treturn points.length-n;\n\t}\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in).useDelimiter(\",|\\r\\n|\\n\");\n\t\t\n\t\tint n;\n\t\tPoint[] points;\n\t\twhile((n=ni())!=0){\n\t\t\tpoints=new Point[n];\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tpoints[i]=new Point(nd(),nd());\n\t\t\t}\n\t\t\tSystem.out.println(solve(points));\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            Point[] points = new Point[n];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\",\");\n                double x = Double.parseDouble(parts[0]);\n                double y = Double.parseDouble(parts[1]);\n                points[i] = new Point(x, y);\n            }\n            \n            List<Integer> hull = convexHull(points);\n            System.out.println(n - hull.size());\n        }\n    }\n    \n    static List<Integer> convexHull(Point[] points) {\n        int n = points.length;\n        if (n < 3) {\n            List<Integer> result = new ArrayList<>();\n            for (int i = 0; i < n; i++) result.add(i);\n            return result;\n        }\n        \n        // Find the bottommost point (or leftmost in case of tie)\n        int start = 0;\n        for (int i = 1; i < n; i++) {\n            if (points[i].y < points[start].y || \n                (points[i].y == points[start].y && points[i].x < points[start].x)) {\n                start = i;\n            }\n        }\n        \n        List<Integer> hull = new ArrayList<>();\n        int current = start;\n        \n        do {\n            hull.add(current);\n            int next = (current + 1) % n;\n            \n            for (int i = 0; i < n; i++) {\n                if (i == current) continue;\n                double cross = crossProduct(points[current], points[next], points[i]);\n                if (cross > 0) {\n                    next = i;\n                } else if (cross == 0) {\n                    // Collinear points - choose the farthest one\n                    if (distance(points[current], points[i]) > distance(points[current], points[next])) {\n                        next = i;\n                    }\n                }\n            }\n            \n            current = next;\n        } while (current != start);\n        \n        return hull;\n    }\n    \n    static double crossProduct(Point o, Point a, Point b) {\n        return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n    }\n    \n    static double distance(Point a, Point b) {\n        double dx = a.x - b.x;\n        double dy = a.y - b.y;\n        return dx * dx + dy * dy;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class Point { double x, y; Point(double x, double y) { this.x = x; this.y = y;  BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { int n = Integer.parseInt(line.trim()); if (n == 0) break; Point[] points = new Point[n]; for (int i = 0; i < n; i++) { String[] parts = br.readLine().trim().split(\",\"); double x  y); } List<Integer> hull = convexHull(points); System.out.println(n - hull.size()); } } static  < 3) { List<Integer> result = new ArrayList<>(); for (int i = 0; i < n; i++) result.add(i); return result; }   i < n; i++) { if (points[i].y < points[start].y || (points[i].y == points[start].y && points[i].x < points[start].x)) { start = i; } } List<Integer> hull = new ArrayList<>(); int current = start; do { hull.add(current); int next = (current + 1) % n; for (int i = 0; i < n; i++)  i; } else if (cross == 0) {  points[i]) > distance(points[current], points[next])) { next = i; } } } current = next; } while (current != start); return hull; } static  - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x); } static double distance(Point a, Point b) { double dx = a.x - b.x; double dy = a.y - b.y; return dx * dx + dy * dy; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { Scanner sc; class Point{ public double x,y; public String toString(){ return \"(\"+x+\",\"+y+\")\"; } public Point(double x,double y){ this.x=x; this.y=y;  theta; } int solve(Point[] points){ Point start=points[0]; for(Point v:points){ if(v.y<start.y)start=v; } Point p0=start; int n=0; double prev=0; do{ double min=Math.PI*3; Point next=p0; for(Point  prev=min; ++n; }while(p0!=start); return points.length-n; } double nd(){ return sc.nextDouble(); } int ni(){ return sc.nextInt(); } void io(){ sc=new Scanner(System.in).useDelimiter(\",|\\r\\n|\\n\"); int n; Point[] points; while((n=ni())!=0){ points=new  public static void main(String[] args) { // TODO Auto-generated method stub new Main().io(); } }"], "original_ll": -0.9743269681930542, "sampled_ll": -0.4412460923194885, "all_perturbed_sampled_ll": [-1.2761749029159546], "all_perturbed_original_ll": [-2.044454574584961], "perturbed_sampled_ll": -1.2761749029159546, "perturbed_original_ll": -2.044454574584961, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f(x,y,x1,y1,x2,y2):\n    if x1 <= x2:\n        return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1\n    else:\n        return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1)\n\ndef DC(a):\n    if len(a) > 3:\n        # Divide\n        la = a[:len(a)/2]\n        ra = a[len(a)/2:]\n        # Conquer\n        la,ra = DC(la),DC(ra)\n        while f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0 and len(ra) > 1:\n            ra.pop(0)\n        while f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0 and len(la) > 1:\n            la.pop(-1)\n        return la+ra\n    else:\n        return a\n\nwhile True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(map(float, raw_input().split(\",\")))\n    p = sorted(p, key = lambda x: x[0])\n    print n - len(DC(p))", "sampled": "def cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef convex_hull(points):\n    points = sorted(points)\n    if len(points) <= 1:\n        return points\n    \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    points = []\n    for _ in range(n):\n        line = input().strip()\n        x, y = map(float, line.split(','))\n        points.append((x, y))\n    \n    hull = convex_hull(points)\n    hull_set = set(hull)\n    \n    count = 0\n    for p in points:\n        if p not in hull_set:\n            count += 1\n    \n    print(count)\n", "perturbed_sampled": ["def cross(o, a, b): return (a[0] -  (b[0] - o[0]) def convex_hull(points): points = sorted(points) if len(points) <= 1: return points lower = [] for p in points: while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0: lower.pop() lower.append(p) upper = [] for p in reversed(points): while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) return lower[:-1] + upper[:-1] while True: n  = map(float, line.split(',')) points.append((x, y)) hull = convex_hull(points) hull_set = set(hull) count = 0 for p in points: if p not in hull_set: count += 1 print(count)"], "perturbed_original": ["def f(x,y,x1,y1,x2,y2): if x1 <= x2: return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1 else: return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1) def DC(a): if len(a) > 3: # Divide la = a[:len(a)/2] ra = a[len(a)/2:] # Conquer la,ra = DC(la),DC(ra) while f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0 and len(ra) > 1: ra.pop(0) while f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0 and len(la) > 1: la.pop(-1) return la+ra else: return a while True: n = int(raw_input()) if n == 0:  n - len(DC(p))"], "original_ll": -0.9147688746452332, "sampled_ll": -0.5048861503601074, "all_perturbed_sampled_ll": [-1.174599289894104], "all_perturbed_original_ll": [-1.4848114252090454], "perturbed_sampled_ll": -1.174599289894104, "perturbed_original_ll": -1.4848114252090454, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint i, j;\nint flag;\nint n;\nint m;\nint atari;\nint d;\nchar amida[11][31];\nint temp[10], keep[10];\n\nint check_amida(void){\n\tint k, l;\n\tfor (k = 0; k < d; k++){\n\t\tfor (l = 0; l < n - 1; l++){\n\t\t\tif (amida[k][l] == '1'){\n\t\t\t\ttemp[l] += temp[l + 1];\n\t\t\t\ttemp[l + 1] = temp[l] - temp[l + 1];\n\t\t\t\ttemp[l] -= temp[l + 1];\n\t\t\t}\n\t\t}\n\t}\n\tif (temp[atari - 1] == m){\n\t\treturn (1);\n\t}\n\telse {\n\t\treturn (0);\n\t}\n}\n\nint ins_amida(int a, int b){\n\tint res;\n\tamida[a][b] = '1';\n\tres = check_amida();\n\tamida[a][b] = '0';\n\t\n\treturn (res);\n}\n\nint main(void)\n{\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tif (!n){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\ttemp[i] = i + 1;\n\t\t\tkeep[i] = i + 1;\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &atari);\n\t\tscanf(\"%d\", &d);\n\t\t\n\t\tfor (i = 0; i < d; i++){\n\t\t\tscanf(\"%s\", amida[i]);\n\t\t\tgetchar();\n\t\t}\n\t\t\n\t\tflag = 0;\n\t\t\n\t\tif (check_amida() == 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tflag = 1;\n\t\t}\n\t\tif (flag == 0){\n\t\t\tfor (i = 0; i < d; i++){\n\t\t\t\tfor (j = 0; j < n - 1; j++){\n\t\t\t\t\tmemcpy(temp, keep, sizeof(keep));\n\t\t\t\t\tif (amida[i][j] == '1'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (j > 0){\n\t\t\t\t\t\tif (amida[i][j - 1] == '1'){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j != n - 2){\n\t\t\t\t\t\tif (amida[i][j + 1] == '1'){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ins_amida(i, j) == 1){\n\t\t\t\t\t\tprintf(\"%d %d\\n\", i + 1, j + 1);\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag == 1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag == 0){\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint n, m, target, d;\nint amida[31][10];\n\nint trace(int start, int skipRow, int skipCol) {\n    int pos = start;\n    for (int row = 1; row <= d; row++) {\n        if (row == skipRow && skipCol == pos && amida[row][pos] == 0) {\n            pos++;\n        } else if (row == skipRow && skipCol == pos - 1 && amida[row][pos - 1] == 0) {\n            pos--;\n        } else if (pos > 1 && amida[row][pos - 1] == 1) {\n            pos--;\n        } else if (pos < n && amida[row][pos] == 1) {\n            pos++;\n        }\n    }\n    return pos;\n}\n\nint canAdd(int row, int col) {\n    if (amida[row][col] == 1) return 0;\n    if (col > 1 && amida[row][col - 1] == 1) return 0;\n    if (col < n - 1 && amida[row][col + 1] == 1) return 0;\n    return 1;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        scanf(\"%d\", &m);\n        scanf(\"%d\", &target);\n        scanf(\"%d\", &d);\n        \n        for (int i = 1; i <= d; i++) {\n            char line[11];\n            scanf(\"%s\", line);\n            for (int j = 0; j < n - 1; j++) {\n                amida[i][j + 1] = line[j] - '0';\n            }\n        }\n        \n        int result = trace(m, -1, -1);\n        if (result == target) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        int found = 0;\n        for (int row = 1; row <= d && !found; row++) {\n            for (int col = 1; col < n && !found; col++) {\n                if (canAdd(row, col)) {\n                    int res = trace(m, row, col);\n                    if (res == target) {\n                        printf(\"%d %d\\n\", row, col);\n                        found = 1;\n                    }\n                }\n            }\n        }\n        \n        if (!found) {\n            printf(\"1\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int n, m, target, d; int amida[31][10]; int trace(int start, int skipRow, int skipCol) { int pos = start; for (int row = 1; row <= d; row++) { if (row == skipRow && skipCol == pos && amida[row][pos] == 0) { pos++; } else if (row == skipRow && skipCol == pos - 1 && amida[row][pos - 1] == 0) { pos--;  == 1) {  1) { pos++;  { if (amida[row][col] == 1)  ==  } int main() { while (1) { scanf(\"%d\", &n); if (n == 0) break; scanf(\"%d\", &m); scanf(\"%d\", &target); scanf(\"%d\", &d); for (int i = 1; i <= d; i++) { char line[11]; scanf(\"%s\", line); for (int j = 0; j < n - 1; j++) { amida[i][j + 1] = line[j] - '0'; } } int result = trace(m, -1, -1); if (result == target) { printf(\"0\\n\"); continue; } int found = 0; for (int  for (int col = 1;  { int res = trace(m, row, col); if (res == target) { printf(\"%d %d\\n\", row, col); found = 1; } } } } if (!found) { printf(\"1\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int i, j; int flag; int n; int m; int atari; int d; char amida[11][31]; int temp[10], keep[10]; int check_amida(void){ int k, l; for (k = 0; k < d; k++){ for (l = 0; l < n - 1; l++){ if (amida[k][l] == '1'){ temp[l]  temp[l + 1]; temp[l] -= temp[l + 1]; } } } if (temp[atari - 1] == m){ return (1); } else { return (0); } } int ins_amida(int a, int b){ int res; amida[a][b] = '1'; res = check_amida(); amida[a][b] = '0'; return (res); } int main(void) { while (1){ scanf(\"%d\", &n); if (!n){ break; } for  + 1; keep[i] = i + 1; } scanf(\"%d\", &m); scanf(\"%d\", &atari); scanf(\"%d\", &d); for (i = 0; i < d; i++){ scanf(\"%s\", amida[i]); getchar(); } flag = 0; if (check_amida() == 1){ printf(\"0\\n\"); flag = 1; }  d; i++){ for (j =  if (amida[i][j] == '1'){ continue;  '1'){ continue; } } if (j != n - 2){ if (amida[i][j + 1] == '1'){ continue; } } if (ins_amida(i, j) == 1){  } } } if (flag == 0){ printf(\"1\\n\"); } } return (0); }"], "original_ll": -0.7526494264602661, "sampled_ll": -0.6088991165161133, "all_perturbed_sampled_ll": [-1.2066748142242432], "all_perturbed_original_ll": [-1.3509738445281982], "perturbed_sampled_ll": -1.2066748142242432, "perturbed_original_ll": -1.3509738445281982, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tString string;\n\t\t\n\t\twhile(!(string = reader.readLine()).equals(\"0\")){\n\t\t\tint n = Integer.valueOf(string);\n\t\t\tint m = Integer.valueOf(reader.readLine()) - 1;\n\t\t\tint a = Integer.valueOf(reader.readLine()) - 1;\n\t\t\tint d = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint node[][] = new int[n - 1][d];\n\t\t\tfor(int i = 0; i < d; i++){\n\t\t\t\tstring = reader.readLine();\n\t\t\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\t\t\tnode[j][i] = string.charAt(j) - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(doing(node, n, m, d) == a){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tboolean judge = false;\n\t\t\t\tx : for(int i = 0; i < d; i++){\n\t\t\t\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\t\t\t\tif(j + 1 < n && j - 1 >= 0)\n\t\t\t\t\t\tif(node[j][i] == 0){\n\t\t\t\t\t\t\tnode[j][i] = 1;\n\t\t\t\t\t\t\tif(doing(node, n, m, d) == a){\n\t\t\t\t\t\t\t\tSystem.out.println((i + 1) + \" \" + (j + 1));\n\t\t\t\t\t\t\t\tjudge = true;\n\t\t\t\t\t\t\t\tbreak x;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnode[j][i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!judge) System.out.println(1);\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t}\n\t\n\tpublic static int doing(int node[][], int n, int s, int d){\n\t\tfor(int i = 0; i < d; i++){\n\t\t\tif(s > 0 && node[s - 1][i] == 1) s--;\n\t\t\telse if(s < n - 1 && node[s][i] == 1) s++;\n\t\t}\n\t\treturn s;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int m = sc.nextInt();\n            int target = sc.nextInt();\n            int d = sc.nextInt();\n            \n            int[][] ladder = new int[d][n - 1];\n            for (int i = 0; i < d; i++) {\n                String line = sc.next();\n                for (int j = 0; j < n - 1; j++) {\n                    ladder[i][j] = line.charAt(j) - '0';\n                }\n            }\n            \n            // Check if we can reach without adding\n            int result = traverse(ladder, m - 1, d, n);\n            if (result == target - 1) {\n                System.out.println(0);\n                continue;\n            }\n            \n            // Try adding one horizontal line\n            boolean found = false;\n            for (int row = 0; row < d; row++) {\n                for (int col = 0; col < n - 1; col++) {\n                    if (canAddLine(ladder, row, col, n)) {\n                        ladder[row][col] = 1;\n                        int newResult = traverse(ladder, m - 1, d, n);\n                        if (newResult == target - 1) {\n                            System.out.println((row + 1) + \" \" + (col + 1));\n                            found = true;\n                            ladder[row][col] = 0;\n                            break;\n                        }\n                        ladder[row][col] = 0;\n                    }\n                }\n                if (found) break;\n            }\n            \n            if (!found) {\n                System.out.println(1);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static int traverse(int[][] ladder, int start, int d, int n) {\n        int pos = start;\n        for (int row = 0; row < d; row++) {\n            // Check left\n            if (pos > 0 && ladder[row][pos - 1] == 1) {\n                pos--;\n            }\n            // Check right\n            else if (pos < n - 1 && ladder[row][pos] == 1) {\n                pos++;\n            }\n        }\n        return pos;\n    }\n    \n    static boolean canAddLine(int[][] ladder, int row, int col, int n) {\n        if (ladder[row][col] == 1) {\n            return false;\n        }\n        \n        // Check if adjacent positions have lines\n        if (col > 0 && ladder[row][col - 1] == 1) {\n            return false;\n        }\n        if (col < n - 2 && ladder[row][col + 1] == 1) {\n            return false;\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": [" { int n = sc.nextInt(); if (n == 0) break; int m = sc.nextInt(); int target = sc.nextInt(); int d = sc.nextInt(); int[][] ladder = new int[d][n - 1]; for (int i = 0; i <  = 0; j < n - 1; j++) { ladder[i][j] = line.charAt(j) - '0'; } } // Check if we can reach without adding int result = traverse(ladder, m - 1, d, n); if (result == target - 1) { System.out.println(0); continue;  false; for (int row = 0; row < d; row++) { for (int col = 0;  col, n)) { ladder[row][col] = 1; int newResult = traverse(ladder, m - 1, d, n); if (newResult == target - 1) { System.out.println((row + 1) + \" \" + (col + 1)); found  } } if (found) break; } if (!found) { System.out.println(1); } } sc.close(); } static int traverse(int[][] ladder, int start, int  row = 0; row < d;  ladder[row][pos - 1] == 1) { pos--; } // Check right else if (pos < n - 1 && ladder[row][pos] == 1) { pos++; } } return pos; } static boolean canAddLine(int[][]  == 1) { return false; } // Check if adjacent positions have lines if (col > 0 && ladder[row][col - 1] == 1) { return false; } if (col < n - 2 && ladder[row][col + 1] == 1) { return false; } return true; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main{ public static void main(String[] args)throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader reader = new BufferedReader(isr); String  = Integer.valueOf(reader.readLine()) - 1; int a = Integer.valueOf(reader.readLine()) - 1; int d = Integer.valueOf(reader.readLine());  0; i < d; i++){ string = reader.readLine(); for(int j = 0; j < n - 1; j++){ node[j][i]  == a){ System.out.println(0); continue; }else{ boolean judge = false; x : for(int i = 0; i < d; i++){ for(int j = 0; j < n - 1; j++){ if(j + 1 < n && j - 1 >= 0) if(node[j][i] == 0){ node[j][i] = 1; if(doing(node, n, m, d) == a){ System.out.println((i + 1)  break x; } node[j][i] = 0; } } } if(!judge) System.out.println(1); } } reader.close(); } public static int doing(int node[][], int n, int s, int d){ for(int i = 0; i <  node[s][i] == 1) s++; } return s; } }"], "original_ll": -0.7589021921157837, "sampled_ll": -0.5889236927032471, "all_perturbed_sampled_ll": [-1.458451509475708], "all_perturbed_original_ll": [-1.5585941076278687], "perturbed_sampled_ll": -1.458451509475708, "perturbed_original_ll": -1.5585941076278687, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nimport itertools\n\n\ndef one_step(lo,lis):\n    nu = [ e for e in lis ]\n    for j in xrange(len(nu)):\n        if lo[0][j] == 1:\n            nu[j],nu[j+1] = nu[j+1],nu[j]\n    return lo[1:],nu\n\n\ndef solve(lo,lis):\n    if len(lo) == 0:\n        return lis\n    nu = [ e for e in lis]\n    lo2,nu2 = one_step(lo,nu)\n    return solve(lo2,nu2)\n\nn = input()\nm = input()\nstar = input()\nd = input()\nlis = range(n+1)\nlots = []\nfor i in xrange(d):\n    lots.append([0]+[ 1 if e == '1' else 0 for e in list(raw_input()) ] +[0])\n\nif solve(lots,lis)[star] == m: print 0;exit()\nfor i in xrange(d):\n    for j in xrange(1,n):\n        if lots[0][j-1] == 0 and lots[0][j] == 0 and lots[0][j+1] == 0:\n            lots[0][j] = 1\n            if solve(lots,lis)[star] == m: print i+1,j;exit()\n            lots[0][j] = 0\n    lots,lis = one_step(lots,lis)\nprint 1", "sampled": "def follow_amida(n, start, lines):\n    pos = start\n    for line in lines:\n        if pos > 1 and line[pos-2] == 1:\n            pos -= 1\n        elif pos < n and line[pos-1] == 1:\n            pos += 1\n    return pos\n\ndef can_add_line(lines, level, bridge_pos):\n    # Check if we can add a horizontal line at level between bridge_pos and bridge_pos+1\n    line = lines[level]\n    \n    # Check if there's already a line there\n    if line[bridge_pos] == 1:\n        return False\n    \n    # Check left neighbor\n    if bridge_pos > 0 and line[bridge_pos-1] == 1:\n        return False\n    \n    # Check right neighbor\n    if bridge_pos < len(line) - 1 and line[bridge_pos+1] == 1:\n        return False\n    \n    return True\n\ndef solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        m = int(input())\n        target = int(input())\n        d = int(input())\n        \n        lines = []\n        for _ in range(d):\n            line_str = input().strip()\n            line = [int(c) for c in line_str]\n            lines.append(line)\n        \n        # Check if already reaches target without adding any line\n        result = follow_amida(n, m, lines)\n        if result == target:\n            print(0)\n            continue\n        \n        # Try adding one line at each possible position\n        found = False\n        for level in range(d):\n            for bridge_pos in range(n-1):\n                if can_add_line(lines, level, bridge_pos):\n                    # Make a copy and add the line\n                    new_lines = [line[:] for line in lines]\n                    new_lines[level][bridge_pos] = 1\n                    \n                    # Check if this reaches target\n                    result = follow_amida(n, m, new_lines)\n                    if result == target:\n                        print(level + 1, bridge_pos + 1)\n                        found = True\n                        break\n            if found:\n                break\n        \n        if not found:\n            print(1)\n\nsolve()\n", "perturbed_sampled": ["def follow_amida(n, start, lines): pos = start for line in lines: if pos > 1 and line[pos-2] == 1: pos -= 1 elif pos < n and line[pos-1] == 1: pos += 1 return pos def can_add_line(lines, level,  at level between bridge_pos and bridge_pos+1 line = lines[level] # Check if there's already a line there if line[bridge_pos] == 1: return False # Check left neighbor if bridge_pos > 0 and line[bridge_pos-1] == 1:  - 1 and line[bridge_pos+1] ==  int(input()) target = int(input()) d =  input().strip() line = [int(c) for c in line_str] lines.append(line) # Check if already reaches target without adding any line result = follow_amida(n, m, lines) if result  each possible position found = False for level in range(d): for bridge_pos in range(n-1): if can_add_line(lines, level, bridge_pos): #  for line in lines] new_lines[level][bridge_pos] = 1 # Check if this reaches target result = follow_amida(n, m, new_lines) if result == target: print(level + 1, bridge_pos + 1) found = True break if found: break if not found: print(1) solve()"], "perturbed_original": ["import sys import itertools def one_step(lo,lis): nu = [ e for e in lis  = nu[j+1],nu[j] return lo[1:],nu def solve(lo,lis): if len(lo) == 0: return lis nu = [ e for e in lis] lo2,nu2 = one_step(lo,nu) return solve(lo2,nu2) n = input() m = input() star = input() d = input() lis = range(n+1) lots = [] for i in xrange(d): lots.append([0]+[  list(raw_input()) ] +[0]) if solve(lots,lis)[star] == m: print 0;exit() for i in xrange(d): for j in xrange(1,n): if lots[0][j-1] == 0 and lots[0][j] == 0 and lots[0][j+1] == 0: lots[0][j] =  lots,lis = one_step(lots,lis) print 1"], "original_ll": -1.3814579248428345, "sampled_ll": -0.9201996326446533, "all_perturbed_sampled_ll": [-2.0842647552490234], "all_perturbed_original_ll": [-2.1383090019226074], "perturbed_sampled_ll": -2.0842647552490234, "perturbed_original_ll": -2.1383090019226074, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint num[10]={1,2,3,4,5,6,7,8,9,0}, dp[11][331];\n#define exch(A,B) {int t; t=A, A=B, B=t;}\n\n/* k\u0095\u00b6\u008e\u009a\u0096\u00da\u0082\u00f0\u008c\u0088\u0082\u00df\u0082\u00e9, s\u0082\u00c9\u0082\u00cd\u0082\u00bb\u0082\u00cc\u008e\u009e\u0093_\u0082\u00c5\u0082\u00cc\u0098a\u0082\u00f0\u0083\u0081\u0083\u0082 */\nvoid solve(int k, int s){\n     int i, j, ts;\n\n     for(i=k; i<10; i++){\n\t  exch(num[i],num[k]);\n\n\t  /* n=k\u0082\u00c5\u0082\u00ccs\u0082\u00f0\u008bL\u0098^ */\n\t  ts=s;\n\t  ts+=num[k]*(k+1);\n\t  dp[k+1][ts]++;\n\n\t  if(k<9) solve(k+1,ts);\n\n\t  exch(num[i],num[k]);\n     }\n}\n\nint main(int argc, char *argv[]){\n     int n, s;\n\n     solve(0,0);\n     \n     while(~scanf(\"%d %d\",&n,&s))\n\t  printf(\"%d\\n\",(n<=10 && s<=330)?dp[n][s]:0);\n\n     return 0;\n}", "sampled": "#include <stdio.h>\n\nint n, s;\nint count;\nint used[10];\nint seq[11];\n\nvoid solve(int pos, int sum) {\n    if (pos > n) {\n        if (sum == s) {\n            count++;\n        }\n        return;\n    }\n    \n    for (int i = 0; i <= 9; i++) {\n        if (!used[i]) {\n            used[i] = 1;\n            seq[pos] = i;\n            solve(pos + 1, sum + pos * i);\n            used[i] = 0;\n        }\n    }\n}\n\nint main() {\n    while (scanf(\"%d %d\", &n, &s) == 2) {\n        count = 0;\n        for (int i = 0; i <= 9; i++) {\n            used[i] = 0;\n        }\n        solve(1, 0);\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int n, s; int count; int used[10]; int seq[11]; void solve(int pos, int sum) { if (pos > n) { if (sum == s)  i <= 9; i++) {  + 1, sum + pos * i); used[i] = 0; } } } int main() { while (scanf(\"%d %d\", &n, &s) == 2) { count = 0; for (int i = 0;  0); printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include <stdio.h> int num[10]={1,2,3,4,5,6,7,8,9,0}, dp[11][331]; #define exch(A,B) {int t; t=A, A=B, B=t;} /* k\u0095\u00b6\u008e\u009a\u0096\u00da\u0082\u00f0\u008c\u0088\u0082\u00df\u0082\u00e9, s\u0082\u00c9\u0082\u00cd\u0082\u00bb\u0082\u00cc\u008e\u009e\u0093_\u0082\u00c5\u0082\u00cc\u0098a\u0082\u00f0\u0083\u0081\u0083\u0082 */ void solve(int k, int s){  */ ts=s; ts+=num[k]*(k+1); dp[k+1][ts]++; if(k<9) solve(k+1,ts); exch(num[i],num[k]); } } int main(int argc, char *argv[]){ int n, s; solve(0,0); while(~scanf(\"%d %d\",&n,&s)) printf(\"%d\\n\",(n<=10 && s<=330)?dp[n][s]:0); return 0; }"], "original_ll": -1.9702337980270386, "sampled_ll": -0.5576450824737549, "all_perturbed_sampled_ll": [-1.8080065250396729], "all_perturbed_original_ll": [-2.108691453933716], "perturbed_sampled_ll": -1.8080065250396729, "perturbed_original_ll": -2.108691453933716, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * Combination of Number Sequences\n */\npublic class Main {\n\n\tstatic int count;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint s = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tcount = 0;\n\t\t\tsolve(0, n, 1, s);\n\t\t\tSystem.out.println(count);\n\n\t\t}\n\n\t}\n\n\tstatic void solve(int p, int n, int a, int s) {\n\n\t\tif (p > 9 || n <= 0 || p * a > s) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (n == 1 && p * a == s) {\n\t\t\t++count;\n\t\t} else {\n\t\t\tsolve(p + 1, n - 1, a + 1, s - p * a);\n\t\t\tsolve(p + 1, n, a, s);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int n, s;\n    static int count;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            n = sc.nextInt();\n            s = sc.nextInt();\n            \n            count = 0;\n            boolean[] used = new boolean[10];\n            solve(1, 0, used);\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n    \n    static void solve(int pos, int sum, boolean[] used) {\n        if (pos > n) {\n            if (sum == s) {\n                count++;\n            }\n            return;\n        }\n        \n        for (int i = 0; i <= 9; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                solve(pos + 1, sum + pos * i, used);\n                used[i] = false;\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int n, s; static int count; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { n = sc.nextInt(); s = sc.nextInt(); count = 0; boolean[] used = new boolean[10]; solve(1, 0, used); <extra_id_4>==<extra_id_5>}<extra_id_6>0;<extra_id_7>(<extra_id_8>} } public<extra_id_9>void<extra_id_10>int i = -<extra_id_11>)<extra_id_12>return null ;<extra_id_13>; }<extra_id_14>.<extra_id_15>;<extra_id_16>( \" \"<extra_id_17>, \" \"<extra_id_18>i < 10 ; ++<extra_id_19>int i ++ )<extra_id_20>if ( i<extra_id_21>) ;<extra_id_22>< 2 )<extra_id_23>} //<extra_id_24>>=<extra_id_25>> boolean[] used) { if (pos > n) { if (sum == s) { count++;  solve(pos + 1, sum + pos * i, used); used[i] = false; } } } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; /**  static int count; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = \"\"; while ((line = br.readLine()) != null &&  n, 1, s); System.out.println(count); } } static void solve(int p, int n, int a, int s) { if (p > 9 || n <= 0 || p * a > s) { return; } if (n == 1 && p * a ==  - 1, a + 1, s - p * a); solve(p + 1, n, a, s); } } }"], "original_ll": -0.7944003343582153, "sampled_ll": -0.5080924034118652, "all_perturbed_sampled_ll": [-1.963462471961975], "all_perturbed_original_ll": [-1.606228232383728], "perturbed_sampled_ll": -1.963462471961975, "perturbed_original_ll": -1.606228232383728, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport sys\nimport itertools\n\n\ntable = [[], [], [], [], [], [], [], [], [], [], []]\n\ndef solv(n, s):\n    if s > 330:\n        return 0\n    dp = table[n]\n    if dp:\n        return dp[s]\n    else:\n        for i in xrange(331):\n            dp.append(0)\n        for p in itertools.permutations(xrange(10), n):\n            s0 = foo(p, n)\n            dp[s0] += 1\n        return dp[s]\n\n\ndef foo(perm, n):\n    return sum(map(lambda x, y: x * y, xrange(1, n+1), perm))\n\n\nfor line in sys.stdin:\n    n, s = map(int, line.split(' '))\n    print solv(n, s)", "sampled": "import sys\nfrom itertools import permutations\n\ndef count_combinations(n, s):\n    count = 0\n    # Generate all permutations of n numbers from 0-9\n    for perm in permutations(range(10), n):\n        # Calculate the weighted sum\n        weighted_sum = sum((i + 1) * perm[i] for i in range(n))\n        if weighted_sum == s:\n            count += 1\n    return count\n\nfor line in sys.stdin:\n    n, s = map(int, line.strip().split())\n    print(count_combinations(n, s))\n", "perturbed_sampled": ["import sys from itertools import permutations def count_combinations(n, s): count = 0 # Generate all permutations of n numbers from 0-9 for perm in permutations(range(10), n): # Calculate the weighted sum weighted_sum = sum((i + 1) * perm[i] for i in range(n)) if weighted_sum == s: count += 1 return  print(count_combinations(n, s))"], "perturbed_original": ["import sys import itertools table = [[], [], [], [], [], [], [], [], [], [], []] def solv(n, s):  dp: return dp[s] else: for i in xrange(331): dp.append(0) for p in itertools.permutations(xrange(10), n): s0 = foo(p,  sum(map(lambda x, y: x * y, xrange(1, n+1), perm)) for line in sys.stdin: n, s = map(int, line.split(' ')) print solv(n, s)"], "original_ll": -1.341007947921753, "sampled_ll": -0.871116578578949, "all_perturbed_sampled_ll": [-1.731654405593872], "all_perturbed_original_ll": [-2.511913776397705], "perturbed_sampled_ll": -1.731654405593872, "perturbed_original_ll": -2.511913776397705, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid bomb(int field[8][8],int x,int y);\n\nint main(){\n\tint i,j,k,n;\n\tint field[8][8];\n\tchar line[9];\n\tint x,y;\n\t\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\t\t\n\t\tfor(j=0;j<8;j++){\n\t\t\tscanf(\"%s\",line);\n\t\t\tfor(k=0;k<8;k++){\n\t\t\t\tfield[j][k] = line[k] - '0';\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&x);\n\t\tscanf(\"%d\",&y);\n\t\tx--; y--;\n\t\t\n\t\tbomb(field,y,x);\n\t\t\n\t\tprintf(\"Data %d:\\n\",i);\n\t\tfor(j=0;j<8;j++){\n\t\t\tfor(k=0;k<8;k++){\n\t\t\t\tprintf(\"%d\",field[j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nvoid bomb(int field[8][8],int x,int y){\n\tint i;\n\tfield[x][y] = 0;\n\tfor(i=1;i<=3&&x-i>=0;i++){\n\t\tif(field[x-i][y] == 1){\n\t\t\tfield[x-i][y] = 0;\n\t\t\tbomb(field,x-i,y);\n\t\t}\n\t}\n\tfor(i=1;i<=3&&x+i<8;i++){\n\t\tif(field[x+i][y] == 1){\n\t\t\tfield[x+i][y] = 0;\n\t\t\tbomb(field,x+i,y);\n\t\t}\n\t}\n\tfor(i=1;i<=3&&y-i>=0;i++){\n\t\tif(field[x][y-i] == 1){\n\t\t\tfield[x][y-i] = 0;\n\t\t\tbomb(field,x,y-i);\n\t\t}\n\t}\n\tfor(i=1;i<=3&&y+i<8;i++){\n\t\tif(field[x][y+i] == 1){\n\t\t\tfield[x][y+i] = 0;\n\t\t\tbomb(field,x,y+i);\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint grid[8][8];\nint exploded[8][8];\n\nvoid explode(int x, int y) {\n    if (x < 0 || x >= 8 || y < 0 || y >= 8) return;\n    if (exploded[y][x]) return;\n    if (grid[y][x] == 0) return;\n    \n    exploded[y][x] = 1;\n    \n    // Explode bombs in range (3 squares in each direction)\n    for (int i = 1; i <= 3; i++) {\n        if (x - i >= 0) explode(x - i, y);\n        if (x + i < 8) explode(x + i, y);\n        if (y - i >= 0) explode(x, y - i);\n        if (y + i < 8) explode(x, y + i);\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int dataset = 1; dataset <= n; dataset++) {\n        // Read the grid\n        for (int i = 0; i < 8; i++) {\n            char line[10];\n            scanf(\"%s\", line);\n            for (int j = 0; j < 8; j++) {\n                grid[i][j] = line[j] - '0';\n            }\n        }\n        \n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--; y--; // Convert to 0-indexed\n        \n        // Initialize exploded array\n        memset(exploded, 0, sizeof(exploded));\n        \n        // Start the chain reaction\n        explode(x, y);\n        \n        // Output\n        printf(\"Data %d:\\n\", dataset);\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                if (exploded[i][j]) {\n                    printf(\"0\");\n                } else {\n                    printf(\"%d\", grid[i][j]);\n                }\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int grid[8][8]; int exploded[8][8]; void explode(int x, int y) { if (x < 0 || x >= 8 || y < 0 || y >= 8) return; if (exploded[y][x]) return; if (grid[y][x] == 0) return; exploded[y][x] = 1; // Explode bombs in range (3 squares in each direction) for (int i = 1; i <= 3; i++) { if (x - i >= 0) explode(x - i, y); if (x + i < 8) explode(x + i, y); if (y - i >= 0) explode(x, y -  &n); for (int dataset = 1; dataset <= n; dataset++) { // Read the grid for (int i = 0; i <  = 0; j < 8; j++) { grid[i][j] = line[j] - '0'; } } int x, y; scanf(\"%d %d\", &x, &y); x--; y--; // Convert to 0-indexed // Initialize exploded  = 0; i < 8; i++) { for (int j = 0;  else { printf(\"%d\", grid[i][j]); } } printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> void bomb(int  line[9]; int x,y; scanf(\"%d\",&n); for(i=1;i<=n;i++){ for(j=0;j<8;j++){ scanf(\"%s\",line); for(k=0;k<8;k++){ field[j][k] = line[k]  %d:\\n\",i); for(j=0;j<8;j++){ for(k=0;k<8;k++){ printf(\"%d\",field[j][k]); } printf(\"\\n\"); } } return 0; } void bomb(int field[8][8],int x,int y){ int i; field[x][y] = 0; for(i=1;i<=3&&x-i>=0;i++){ if(field[x-i][y] == 1){ field[x-i][y] = 0; bomb(field,x-i,y); } } for(i=1;i<=3&&x+i<8;i++){ if(field[x+i][y] == 1){ field[x+i][y] = 0; bomb(field,x+i,y); } } for(i=1;i<=3&&y-i>=0;i++){ if(field[x][y-i] == 1){ field[x][y-i] = 0; bomb(field,x,y-i); } } for(i=1;i<=3&&y+i<8;i++){ if(field[x][y+i] == 1){ field[x][y+i] = 0; bomb(field,x,y+i); } } }"], "original_ll": -0.5113551616668701, "sampled_ll": -0.545032799243927, "all_perturbed_sampled_ll": [-1.3239835500717163], "all_perturbed_original_ll": [-0.8763598799705505], "perturbed_sampled_ll": -1.3239835500717163, "perturbed_original_ll": -0.8763598799705505, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tint[][] map;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint sets = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor (int index = 0; index < sets; index++) {\n\t\t\tsc.nextLine();\n\t\t\t\n\t\t\tmap = new int[8][8];\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\tmap[j][i] = line.charAt(j) - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer[]> boms = new LinkedList<Integer[]>();\n\t\t\tInteger[] xy = new Integer[2];\n\t\t\txy[0] = Integer.parseInt(sc.nextLine()) - 1;\n\t\t\txy[1] = Integer.parseInt(sc.nextLine()) - 1;\n\t\t\tmap[xy[0]][xy[1]] = 0;\n\t\t\tboms.add(xy);\n\t\t\t\n\t\t\twhile (boms.isEmpty() == false) {\n\t\t\t\txy = boms.pop();\n\t\t\t\t\n\t\t\t\tint tx = xy[0];\n\t\t\t\tint ty = xy[1];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = -3; i < 4; i++) {\n\t\t\t\t\tif ((tx + i) < 0) continue;\n\t\t\t\t\tif ((tx + i) > 7) break;\n\t\t\t\t\t\n\t\t\t\t\tif (map[tx + i][ty] == 1) {\n\t\t\t\t\t\tmap[tx + i][ty] = 0;\n\t\t\t\t\t\txy[0] = tx + i;\n\t\t\t\t\t\txy[1] = ty;\n\t\t\t\t\t\tboms.add(xy);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = -3; i < 4; i++) {\n\t\t\t\t\tif ((ty + i) < 0) continue;\n\t\t\t\t\tif ((ty + i) > 7) break;\t\n\t\t\t\t\t\n\t\t\t\t\tif (map[tx][ty + i] == 1) {\n\t\t\t\t\t\tmap[tx][ty + i] = 0;\n\t\t\t\t\t\txy[0] = tx;\n\t\t\t\t\t\txy[1] = ty + i;\n\t\t\t\t\t\tboms.add(xy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"Data \" + (index + 1) + \":\");\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\tSystem.out.print(map[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int dataSet = 1; dataSet <= n; dataSet++) {\n            sc.nextLine(); // empty line\n            \n            int[][] grid = new int[8][8];\n            for (int y = 0; y < 8; y++) {\n                String line = sc.nextLine();\n                for (int x = 0; x < 8; x++) {\n                    grid[y][x] = line.charAt(x) - '0';\n                }\n            }\n            \n            int startX = sc.nextInt() - 1;\n            int startY = sc.nextInt() - 1;\n            sc.nextLine();\n            \n            // BFS to explode bombs\n            Queue<int[]> queue = new LinkedList<>();\n            boolean[][] exploded = new boolean[8][8];\n            \n            queue.offer(new int[]{startX, startY});\n            exploded[startY][startX] = true;\n            \n            while (!queue.isEmpty()) {\n                int[] pos = queue.poll();\n                int x = pos[0];\n                int y = pos[1];\n                \n                // Check up to 3 cells in each direction\n                for (int dy = -3; dy <= 3; dy++) {\n                    int ny = y + dy;\n                    if (ny >= 0 && ny < 8 && grid[ny][x] == 1 && !exploded[ny][x]) {\n                        exploded[ny][x] = true;\n                        queue.offer(new int[]{x, ny});\n                    }\n                }\n                \n                for (int dx = -3; dx <= 3; dx++) {\n                    int nx = x + dx;\n                    if (nx >= 0 && nx < 8 && grid[y][nx] == 1 && !exploded[y][nx]) {\n                        exploded[y][nx] = true;\n                        queue.offer(new int[]{nx, y});\n                    }\n                }\n            }\n            \n            // Update grid\n            for (int y = 0; y < 8; y++) {\n                for (int x = 0; x < 8; x++) {\n                    if (exploded[y][x]) {\n                        grid[y][x] = 0;\n                    }\n                }\n            }\n            \n            // Output\n            System.out.println(\"Data \" + dataSet + \":\");\n            for (int y = 0; y < 8; y++) {\n                for (int x = 0; x < 8; x++) {\n                    System.out.print(grid[y][x]);\n                }\n                System.out.println();\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  = new Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); for (int dataSet = 1; dataSet <= n; dataSet++) { sc.nextLine(); // empty line int[][] grid = new int[8][8]; for (int y = 0; y < 8; y++) { String line = sc.nextLine(); for (int x = 0; x < 8; x++) { grid[y][x] = line.charAt(x) - '0'; } } int startX = sc.nextInt() - 1; int startY = sc.nextInt() - 1; sc.nextLine(); // BFS to explode bombs Queue<int[]> queue = new LinkedList<>(); boolean[][] exploded = new boolean[8][8]; queue.offer(new int[]{startX, startY}); exploded[startY][startX] =  = pos[0]; int y  direction for (int dy = -3; dy <= 3; dy++) { int ny = y + dy; if (ny >= 0 && ny < 8 && grid[ny][x] == 1 && !exploded[ny][x]) { exploded[ny][x] = true; queue.offer(new int[]{x, ny}); } } for (int dx =  + dx;  int[]{nx, y}); } } } // Update grid for (int y = 0; y < 8; y++) { for (int x  grid[y][x] = 0; } } } // Output System.out.println(\"Data  y < 8; y++) { for (int x = 0; x < 8; x++) { System.out.print(grid[y][x]); } System.out.println(); } } sc.close(); } }"], "perturbed_original": ["import java.util.LinkedList; import java.util.Scanner; public class Main { private Scanner sc; int[][] map; public   (int index = 0; index < sets; index++) { sc.nextLine(); map = new int[8][8]; for (int i = 0; i < map.length; i++) { String line = sc.nextLine(); for (int j = 0; j < map.length; j++) { map[j][i] = line.charAt(j) - '0'; } } LinkedList<Integer[]> boms = new LinkedList<Integer[]>(); Integer[] xy = new Integer[2]; xy[0] = Integer.parseInt(sc.nextLine()) - 1; xy[1] = Integer.parseInt(sc.nextLine()) - 1; map[xy[0]][xy[1]] = 0; boms.add(xy); while (boms.isEmpty() == false) { xy = boms.pop();  ((tx + i) < 0) continue; if ((tx + i) > 7) break; if (map[tx + i][ty] == 1) { map[tx + i][ty] =  } } for (int i = -3; i < 4; i++) { if ((ty + i) < 0) continue; if ((ty + i) > 7) break; if (map[tx][ty +  = tx; xy[1] = ty + i; boms.add(xy); } } } System.out.println(\"Data \" + (index + 1) + \":\"); for (int i =  0; j < map.length; j++) { System.out.print(map[j][i]); } System.out.println(); } } } }"], "original_ll": -0.5534349679946899, "sampled_ll": -0.4734344184398651, "all_perturbed_sampled_ll": [-1.5469481945037842], "all_perturbed_original_ll": [-1.2594032287597656], "perturbed_sampled_ll": -1.5469481945037842, "perturbed_original_ll": -1.2594032287597656, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def bomb(x,y):\n    s=M[y]\n    if s[x]==\"0\":return\n    M[y]=s[:x]+\"0\"+s[x+1:]\n    R=[-3,-2,-1,1,2,3]\n    for e in R:\n        bomb(x+e,y)\n        bomb(x,y+e)\n    return\n\nA=range(3,11)\nM=[\"00000000000000\" for i in range(14)]\nz=\"000\"\nn=input()\nfor i in range(n):\n    s=raw_input()\n    for j in A:\n        M[j]=z+raw_input()+z\n    x=input()+2\n    y=input()+2\n    bomb(x,y)\n    print \"Data %d:\" %(i+1)\n    for j in A:\n        print M[j][3:-3]", "sampled": "from collections import deque\n\ndef solve():\n    n = int(input())\n    \n    for dataset_num in range(1, n + 1):\n        # Read empty line\n        input()\n        \n        # Read 8x8 grid\n        grid = []\n        for i in range(8):\n            line = input().strip()\n            grid.append([int(c) for c in line])\n        \n        # Read starting position\n        x = int(input())\n        y = int(input())\n        \n        # Convert to 0-indexed\n        x -= 1\n        y -= 1\n        \n        # BFS to simulate chain explosions\n        exploded = [[False] * 8 for _ in range(8)]\n        queue = deque()\n        \n        # Start explosion at (x, y)\n        if grid[y][x] == 1:\n            queue.append((x, y))\n            exploded[y][x] = True\n        \n        while queue:\n            cx, cy = queue.popleft()\n            \n            # Explosion affects 3 squares in each direction (up, down, left, right)\n            directions = []\n            # Up\n            for dy in range(1, 4):\n                if cy - dy >= 0:\n                    directions.append((cx, cy - dy))\n            # Down\n            for dy in range(1, 4):\n                if cy + dy < 8:\n                    directions.append((cx, cy + dy))\n            # Left\n            for dx in range(1, 4):\n                if cx - dx >= 0:\n                    directions.append((cx - dx, cy))\n            # Right\n            for dx in range(1, 4):\n                if cx + dx < 8:\n                    directions.append((cx + dx, cy))\n            \n            for nx, ny in directions:\n                if grid[ny][nx] == 1 and not exploded[ny][nx]:\n                    exploded[ny][nx] = True\n                    queue.append((nx, ny))\n        \n        # Remove exploded bombs from grid\n        for i in range(8):\n            for j in range(8):\n                if exploded[i][j]:\n                    grid[i][j] = 0\n        \n        # Output result\n        print(f\"Data {dataset_num}:\")\n        for row in grid:\n            print(''.join(map(str, row)))\n\nsolve()\n", "perturbed_sampled": ["from collections import deque def solve(): n = int(input()) for dataset_num in range(1, n + 1): # Read empty line input() # Read 8x8 grid grid = [] for i in range(8): line = input().strip() grid.append([int(c) for c in line]) # Read starting position x = int(input()) y = int(input()) # Convert to 0-indexed x -= 1 y -= 1 # BFS to simulate chain explosions exploded = [[False] * 8 for _  y) if grid[y][x] ==  = queue.popleft() # Explosion affects 3 squares in each direction (up, down,  range(1, 4): if cy - dy >= 0: directions.append((cx, cy - dy)) # Down for dy in range(1, 4): if cy + dy < 8: directions.append((cx, cy + dy)) # Left for dx in range(1, 4): if cx -  dx in range(1, 4): if cx + dx < 8: directions.append((cx + dx, cy)) for nx, ny in directions: if grid[ny][nx] ==  Remove exploded bombs from grid  grid[i][j] = 0 # Output result print(f\"Data {dataset_num}:\") for row in grid: print(''.join(map(str, row))) solve()"], "perturbed_original": ["def bomb(x,y): s=M[y] if s[x]==\"0\":return M[y]=s[:x]+\"0\"+s[x+1:] R=[-3,-2,-1,1,2,3] for e in R: bomb(x+e,y) bomb(x,y+e) return A=range(3,11) M=[\"00000000000000\" for i in range(14)] z=\"000\" n=input() for i  bomb(x,y) print \"Data %d:\" %(i+1) for j in A: print M[j][3:-3]"], "original_ll": -1.5403037071228027, "sampled_ll": -0.7144481539726257, "all_perturbed_sampled_ll": [-1.830200433731079], "all_perturbed_original_ll": [-2.2253549098968506], "perturbed_sampled_ll": -1.830200433731079, "perturbed_original_ll": -2.2253549098968506, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#define INF 1000000\n\nint cost[100][100];\nint mincost[100];\nchar used[100];\nint V;\n\nint min(int a, int b){\n\tif (a > b){\n\t\treturn (b);\n\t}\n\treturn (a);\n}\n\nint prim(void)\n{\n\tint i;\n\tint res;\n\tint u, v;\n\t\n\tfor (i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = 0;\n\t}\n\t\n\tmincost[0] = 0;\n\tres = 0;\n\t\n\twhile (1){\n\t\tv = -1;\n\t\tfor (u = 0; u < V; u++){\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\t\n\t\tfor (u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn (res);\n}\n\nint main(void)\n{\n\tint num, from, to, dist;\n\tint i,j;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &V);\n\t\tif (V == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tfor (j = 0; j < num; j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &dist);\n\t\t\tcost[from][to] = cost[to][from] = (dist / 100) - 1;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", prim());\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100\n#define MAX_M 5000\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint parent[MAX_N];\nEdge edges[MAX_M];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    if (px != py) {\n        parent[px] = py;\n    }\n}\n\nint compare(const void *a, const void *b) {\n    Edge *ea = (Edge *)a;\n    Edge *eb = (Edge *)b;\n    return ea->w - eb->w;\n}\n\nint main() {\n    int n, m;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        scanf(\"%d\", &m);\n        \n        for (int i = 0; i < m; i++) {\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            edges[i].u = a;\n            edges[i].v = b;\n            edges[i].w = d;\n        }\n        \n        qsort(edges, m, sizeof(Edge), compare);\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        int total_lanterns = 0;\n        int edges_used = 0;\n        \n        for (int i = 0; i < m && edges_used < n - 1; i++) {\n            int u = edges[i].u;\n            int v = edges[i].v;\n            int w = edges[i].w;\n            \n            if (find(u) != find(v)) {\n                unite(u, v);\n                edges_used++;\n                total_lanterns += (w / 100 - 1);\n            }\n        }\n        \n        printf(\"%d\\n\", total_lanterns);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> #define MAX_N 100 #define MAX_M 5000 typedef struct { int u, v, w; } Edge; int  void unite(int x, int y) { int px = find(x); int py = find(y); if (px != py) { parent[px] = py; } } int compare(const void *a, const void *b) { Edge *ea = (Edge *)a; Edge *eb = (Edge *)b; return ea->w - eb->w; } int main() { int n, m; while (scanf(\"%d\", &n) == 1 && n != 0) { scanf(\"%d\", &m); for (int   compare); for (int i = 0; i < n; i++) { parent[i] = i; } int total_lanterns = 0; int edges_used = 0; for (int i = 0; i < m && edges_used < n - 1; i++) { int u = edges[i].u; int v =  unite(u, v); edges_used++; total_lanterns += (w / 100 - 1); } } printf(\"%d\\n\", total_lanterns); } return 0; }"], "perturbed_original": ["#include <stdio.h> #define INF  min(int a, int b){ if (a > b){ return (b); } return (a); } int prim(void) { int i; int res; int u, v; for (i = 0; i < V; i++){ mincost[i] = INF; used[i] = 0; } mincost[0] = 0; res = 0; while (1){ v = -1; for (u = 0; u < V; u++){ if (!used[u] && (v == -1 || mincost[u] < mincost[v])){ v = u; } } if (v == -1){ break; }  u < V; u++){ mincost[u] = min(mincost[u], cost[v][u]); } } return (res); } int main(void) { int num, from, to,  0){ break; } scanf(\"%d\", &num);  } } for (i = 0; i < num; i++){ scanf(\"%d,%d,%d\", &from, &to, &dist); cost[from][to] = cost[to][from] = (dist / 100) - 1; } printf(\"%d\\n\", prim()); } return (0); }"], "original_ll": -0.593109130859375, "sampled_ll": -0.42744705080986023, "all_perturbed_sampled_ll": [-1.0859171152114868], "all_perturbed_original_ll": [-1.3473435640335083], "perturbed_sampled_ll": -1.0859171152114868, "perturbed_original_ll": -1.3473435640335083, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = 0, m = 0, a = 0, b = 0, c = 0;\n\t\t\n\t\twhile(!(sb.append(reader.readLine())).equals(\"0\")){\n\t\t\tn = Integer.valueOf(sb.toString());\n\t\t\tm = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint map[][] = new int[n][n];\n\t\t\tboolean visit[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tsb.setLength(0);\n\t\t\t\tsb.append(reader.readLine());\n\t\t\t\ta = Integer.valueOf(sb.toString().split(\",\")[0]);\n\t\t\t\tb = Integer.valueOf(sb.toString().split(\",\")[1]);\n\t\t\t\tc = (Integer.valueOf(sb.toString().split(\",\")[2]) - 100) / 100;\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tvisit[0] = true;\n\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\tm = 1 << 29;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(map[0][i] < m && !visit[i]){\n\t\t\t\t\t\tm = map[0][i];\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisit[b] = true;\n\t\t\t\tc += map[0][b];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tmap[0][i] = Math.min(map[0][i], map[b][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t\tsb.setLength(0);\n\t\t}\n\t\treader.close();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, dist;\n        Edge(int to, int dist) {\n            this.to = to;\n            this.dist = dist;\n        }\n    }\n    \n    static class UnionFind {\n        int[] parent, rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        void union(int x, int y) {\n            int px = find(x);\n            int py = find(y);\n            if (px == py) return;\n            \n            if (rank[px] < rank[py]) {\n                parent[px] = py;\n            } else if (rank[px] > rank[py]) {\n                parent[py] = px;\n            } else {\n                parent[py] = px;\n                rank[px]++;\n            }\n        }\n        \n        boolean connected(int x, int y) {\n            return find(x) == find(y);\n        }\n    }\n    \n    static class MSTEdge implements Comparable<MSTEdge> {\n        int u, v, dist;\n        MSTEdge(int u, int v, int dist) {\n            this.u = u;\n            this.v = v;\n            this.dist = dist;\n        }\n        \n        public int compareTo(MSTEdge other) {\n            return this.dist - other.dist;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int m = sc.nextInt();\n            sc.nextLine();\n            \n            List<MSTEdge> edges = new ArrayList<>();\n            \n            for (int i = 0; i < m; i++) {\n                String line = sc.nextLine();\n                String[] parts = line.split(\",\");\n                int a = Integer.parseInt(parts[0]);\n                int b = Integer.parseInt(parts[1]);\n                int d = Integer.parseInt(parts[2]);\n                edges.add(new MSTEdge(a, b, d));\n            }\n            \n            // Kruskal's algorithm to find MST\n            Collections.sort(edges);\n            UnionFind uf = new UnionFind(n);\n            \n            int totalLanterns = 0;\n            \n            for (MSTEdge edge : edges) {\n                if (!uf.connected(edge.u, edge.v)) {\n                    uf.union(edge.u, edge.v);\n                    // Calculate lanterns needed for this edge\n                    // Distance is in meters, lanterns are every 100m\n                    // First lantern at 100m from one end, last at 100m from other end\n                    // For distance d, we need (d/100 - 1) lanterns\n                    int lanterns = edge.dist / 100 - 1;\n                    totalLanterns += lanterns;\n                }\n            }\n            \n            System.out.println(totalLanterns);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {  dist) { this.to = to; this.dist = dist; } } static class UnionFind { int[] parent, rank; UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i <  x) { if (parent[x] != x) { parent[x] =  { int px = find(x); int py = find(y); if (px == py) return; if (rank[px] < rank[py]) { parent[px] = py; } else if (rank[px] > rank[py]) { parent[py] = px;   } static class MSTEdge implements Comparable<MSTEdge> { int u, v, dist; MSTEdge(int u, int v, int dist) { this.u = u; this.v =  return this.dist - other.dist; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int m = sc.nextInt(); sc.nextLine(); List<MSTEdge> edges = new ArrayList<>(); for (int i = 0; i < m; i++) { String line =  b = Integer.parseInt(parts[1]); int d = Integer.parseInt(parts[2]); edges.add(new MSTEdge(a,  UnionFind uf = new UnionFind(n); int totalLanterns = 0; for (MSTEdge edge : edges) { if (!uf.connected(edge.u, edge.v)) { uf.union(edge.u, edge.v); // Calculate lanterns needed for this edge // Distance is in meters, lanterns are every 100m // First lantern at 100m from one end, last at 100m from other end // For distance d, we need (d/100 - 1) lanterns int lanterns = edge.dist  } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; public class Main{ public static void main(String[] args)throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader reader = new BufferedReader(isr); StringBuilder sb = new StringBuilder(); int n = 0, m = 0, a = 0, b =  Arrays.fill(map[i], 1 << 29); for(int i = 0; i < m; i++){ sb.setLength(0);  - 100) / 100; map[a][b] = map[b][a] = c; } c = 0; visit[0] = true; for(int x = 0; x < n - 1; x++){ m = 1 << 29;  m && !visit[i]){ m = map[0][i]; b = i; } } visit[b] = true; c += map[0][b]; for(int i = 0; i < n; i++){ map[0][i] = Math.min(map[0][i], map[b][i]); } } System.out.println(c); sb.setLength(0); } reader.close(); } }"], "original_ll": -0.7757416367530823, "sampled_ll": -0.4814315438270569, "all_perturbed_sampled_ll": [-1.4139549732208252], "all_perturbed_original_ll": [-1.423024296760559], "perturbed_sampled_ll": -1.4139549732208252, "perturbed_original_ll": -1.423024296760559, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n  n=int(input())\n  if not n:break\n  X={0}\n  Y=set(range(n))-X\n  s=0\n  l=[tuple(map(int,input().split(\",\"))) for _ in range(int(input()))]\n\n  while Y:\n    cd=[i for i in l if (i[0] in X and i[1] in Y) or (i[0] in Y and i[1] in X)]\n    cd=sorted(cd,key=lambda x:x[2])[0]\n    if cd[0] in X and cd[1] in Y:\n      X.add(cd[1])\n      Y=Y-X\n    elif cd[0] in Y and cd[1] in X:\n      X.add(cd[0])\n      Y=Y-X\n    s+=int(cd[2]/100-1)\n  print(s)\n", "sampled": "import sys\nfrom collections import defaultdict\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    px, py = find(parent, x), find(parent, y)\n    if px == py:\n        return False\n    if rank[px] < rank[py]:\n        px, py = py, px\n    parent[py] = px\n    if rank[px] == rank[py]:\n        rank[px] += 1\n    return True\n\ndef kruskal_mst(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n    edges.sort(key=lambda x: x[2])\n    mst_edges = []\n    \n    for a, b, d in edges:\n        if union(parent, rank, a, b):\n            mst_edges.append((a, b, d))\n            if len(mst_edges) == n - 1:\n                break\n    \n    return mst_edges\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    m = int(input())\n    edges = []\n    \n    for _ in range(m):\n        line = input().strip()\n        a, b, d = map(int, line.split(','))\n        edges.append((a, b, d))\n    \n    # Find MST\n    mst_edges = kruskal_mst(n, edges)\n    \n    # Calculate total lanterns needed\n    total_lanterns = 0\n    for a, b, d in mst_edges:\n        # Distance between two sites is d meters\n        # Lanterns are placed every 100m\n        # First lantern is 100m from site a, last is 100m from site b\n        # So number of lanterns = d/100 - 1\n        lanterns = d // 100 - 1\n        total_lanterns += lanterns\n    \n    print(total_lanterns)\n", "perturbed_sampled": ["import sys from collections import defaultdict def find(parent, x): if parent[x] != x: parent[x] =  py = find(parent, x), find(parent, y) if px == py: return False if rank[px] < rank[py]: px, py = py, px parent[py] = px if rank[px] == rank[py]: rank[px] += 1 return True def kruskal_mst(n, edges): parent  mst_edges = [] for a, b, d in edges: if union(parent, rank, a, b): mst_edges.append((a, b, d)) if len(mst_edges) == n - 1: break return mst_edges while True:  int(input()) edges = [] for _ in range(m): line = input().strip() a, b, d = map(int, line.split(',')) edges.append((a, b, d)) # Find MST mst_edges = kruskal_mst(n, edges) # Calculate total lanterns needed total_lanterns = 0 for a, b, d in mst_edges: # Distance between two sites is d  is 100m from site a, last is 100m from site b # So number of lanterns = d/100 -  lanterns print(total_lanterns)"], "perturbed_original": ["while 1: n=int(input()) if not n:break X={0} Y=set(range(n))-X s=0 l=[tuple(map(int,input().split(\",\"))) for _ in range(int(input()))] while Y: cd=[i for i in l if (i[0] in X and i[1]  cd=sorted(cd,key=lambda x:x[2])[0] if cd[0] in X and cd[1] in Y: X.add(cd[1]) Y=Y-X elif cd[0] in Y and cd[1] in X: X.add(cd[0]) Y=Y-X s+=int(cd[2]/100-1) print(s)"], "original_ll": -1.2589569091796875, "sampled_ll": -0.6471632719039917, "all_perturbed_sampled_ll": [-1.5902129411697388], "all_perturbed_original_ll": [-1.9123467206954956], "perturbed_sampled_ll": -1.5902129411697388, "perturbed_original_ll": -1.9123467206954956, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid timePrint(int time);\n\nint main(void){\n  int t, h, s;\n  int time;\n\n  scanf(\"%d%d%d\", &t, &h, &s);\n  while(!(t == -1 && h == -1 && s == -1)){\n    time = t*3600 + h*60 + s;\n    timePrint(7200-time);\n    timePrint(7200-time/3);\n    scanf(\"%d%d%d\", &t, &h, &s);\n  }\n  return 0;\n}\n\nvoid timePrint(int time){\n  printf(\"%02d:\", time/3600);\n  time %= 3600;\n  printf(\"%02d:\", time/60);\n  time %= 60;\n  printf(\"%02d\\n\", time);\n  return;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int T, H, S;\n    \n    while(1) {\n        scanf(\"%d %d %d\", &T, &H, &S);\n        \n        if(T == -1 && H == -1 && S == -1) {\n            break;\n        }\n        \n        // Convert current time to seconds\n        int current_seconds = T * 3600 + H * 60 + S;\n        \n        // Total tape is 120 minutes = 7200 seconds\n        int total_seconds = 120 * 60;\n        \n        // Remaining seconds\n        int remaining_seconds = total_seconds - current_seconds;\n        \n        // Standard mode: remaining time as is\n        int std_hours = remaining_seconds / 3600;\n        int std_minutes = (remaining_seconds % 3600) / 60;\n        int std_seconds = remaining_seconds % 60;\n        \n        // 3x mode: 3 times the remaining time\n        int triple_total_seconds = remaining_seconds * 3;\n        int triple_hours = triple_total_seconds / 3600;\n        int triple_minutes = (triple_total_seconds % 3600) / 60;\n        int triple_seconds = triple_total_seconds % 60;\n        \n        printf(\"%02d:%02d:%02d\\n\", std_hours, std_minutes, std_seconds);\n        printf(\"%02d:%02d:%02d\\n\", triple_hours, triple_minutes, triple_seconds);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int T, H, S; while(1) { scanf(\"%d %d %d\", &T, &H, &S); if(T == -1 && H == -1 && S == -1) { break; } // Convert current time to seconds int current_seconds = T  tape is 120 minutes = 7200 seconds int total_seconds = 120 * 60; //  mode: remaining time as is int std_hours = remaining_seconds / 3600; int std_minutes = (remaining_seconds % 3600)  mode: 3 times the remaining time int triple_total_seconds = remaining_seconds * 3; int triple_hours = triple_total_seconds / 3600; int triple_minutes = (triple_total_seconds % 3600) / 60; int triple_seconds = triple_total_seconds % 60; printf(\"%02d:%02d:%02d\\n\",  }"], "perturbed_original": ["#include <stdio.h> time; scanf(\"%d%d%d\", &t,<extra_id_8>H (t).h<extra_id_9>(t);<extra_id_10>/ 5); scanf(\"%d%d%d%d\", &s,<extra_id_11>&h); scanf(\"%d%d time; scanf(\"%d%d%d\", &t, &h, &s); while(!(t == -1 && h == -1 && s == -1)){ time = t*3600 + h*60 + s; timePrint(7200-time); timePrint(7200-time/3); scanf(\"%d%d%d\", &t, &h, &s); } return 0; } void timePrint(int time){ printf(\"%02d:\", time/3600); time %= 3600; printf(\"%02d:\", time/60); time %= 60; printf(\"%02d\\n\", time); return; }"], "original_ll": -0.8655926585197449, "sampled_ll": -0.6725392937660217, "all_perturbed_sampled_ll": [-1.564686894416809], "all_perturbed_original_ll": [-1.6943949460983276], "perturbed_sampled_ll": -1.564686894416809, "perturbed_original_ll": -1.6943949460983276, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tint s = scanner.nextInt();\n\t\t\tif (h == -1 && m == -1 && s == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint sc = 7200 - (h * 3600 + m * 60 + s);\n\t\t\tint sc3 = sc * 3;\n\t\t\tSystem.out.println(String.format(\"%02d:%02d:%02d\", sc / 3600,\n\t\t\t\t\tsc / 60 % 60, sc % 60));\n\t\t\tSystem.out.println(String.format(\"%02d:%02d:%02d\", sc3 / 3600,\n\t\t\t\t\tsc3 / 60 % 60, sc3 % 60));\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int h = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            \n            if (h == -1 && m == -1 && s == -1) {\n                break;\n            }\n            \n            // Convert current counter to seconds\n            int usedSeconds = h * 3600 + m * 60 + s;\n            \n            // Total tape capacity in seconds (120 minutes)\n            int totalSeconds = 120 * 60;\n            \n            // Remaining seconds\n            int remainingSeconds = totalSeconds - usedSeconds;\n            \n            // Standard recording mode (remaining time as is)\n            int stdHours = remainingSeconds / 3600;\n            int stdMinutes = (remainingSeconds % 3600) / 60;\n            int stdSeconds = remainingSeconds % 60;\n            \n            // 3x recording mode (remaining time * 3)\n            int tripleSeconds = remainingSeconds * 3;\n            int tripleHours = tripleSeconds / 3600;\n            int tripleMinutes = (tripleSeconds % 3600) / 60;\n            int tripleSecs = tripleSeconds % 60;\n            \n            System.out.printf(\"%02d:%02d:%02d%n\", stdHours, stdMinutes, stdSeconds);\n            System.out.printf(\"%02d:%02d:%02d%n\", tripleHours, tripleMinutes, tripleSecs);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int h = sc.nextInt(); int m = sc.nextInt(); int s = sc.nextInt(); if (h == -1 && m == -1 && s == -1) { break; } // Convert current counter to seconds int usedSeconds = h * 3600 + m * 60 + s; //  120 * 60; // Remaining seconds int remainingSeconds = totalSeconds -  stdHours = remainingSeconds /  stdSeconds = remainingSeconds % 60; // 3x recording mode (remaining time *  tripleSeconds / 3600; int tripleMinutes = (tripleSeconds % 3600) / 60; int tripleSecs = tripleSeconds % 60; System.out.printf(\"%02d:%02d:%02d%n\", stdHours, stdMinutes, stdSeconds); System.out.printf(\"%02d:%02d:%02d%n\", tripleHours, tripleMinutes, tripleSecs); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (true) { int h = scanner.nextInt(); int m = scanner.nextInt(); int s = scanner.nextInt(); if (h == -1 && m == -1 && s == -1) { break; } int sc = 7200 - (h * 3600 + m * 60 +  3600, sc / 60 %  60 % 60, sc3 % 60)); } } }"], "original_ll": -0.5642449259757996, "sampled_ll": -0.712867796421051, "all_perturbed_sampled_ll": [-1.4374315738677979], "all_perturbed_original_ll": [-1.2770304679870605], "perturbed_sampled_ll": -1.4374315738677979, "perturbed_original_ll": -1.2770304679870605, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#!/usr/bin/python\n# coding: utf-8\n\nwhile True:\n    h, m, s = map(int, raw_input().split())\n    if h == m == s == -1:\n        break\n\n    full = 2 * 3600\n    rest = full - (h * 3600 + m * 60 + s)\n\n    h = int(rest / 3600)\n    m = int((rest - h * 3600) / 60)\n    s = rest - h * 3600 - m * 60 \n\n    th = int(rest / 1200)\n    tm = int((rest - th * 1200) / 20)\n    ts = (rest - th * 1200 - tm * 20) * 3\n\n    print \"{:02d}:{:02d}:{:02d}\".format(h, m, s)\n    print \"{:02d}:{:02d}:{:02d}\".format(th, tm, ts)", "sampled": "while True:\n    T, H, S = map(int, input().split())\n    if T == -1 and H == -1 and S == -1:\n        break\n    \n    # Convert current counter to seconds\n    current_seconds = T * 3600 + H * 60 + S\n    \n    # Total tape capacity in seconds (120 minutes)\n    total_seconds = 120 * 60\n    \n    # Remaining tape in seconds\n    remaining_seconds = total_seconds - current_seconds\n    \n    # Standard recording: remaining time is as is\n    std_hours = remaining_seconds // 3600\n    std_minutes = (remaining_seconds % 3600) // 60\n    std_seconds = remaining_seconds % 60\n    \n    # 3x recording: can record 3 times the remaining tape time\n    triple_total_seconds = remaining_seconds * 3\n    triple_hours = triple_total_seconds // 3600\n    triple_minutes = (triple_total_seconds % 3600) // 60\n    triple_seconds = triple_total_seconds % 60\n    \n    print(f\"{std_hours:02d}:{std_minutes:02d}:{std_seconds:02d}\")\n    print(f\"{triple_hours:02d}:{triple_minutes:02d}:{triple_seconds:02d}\")\n", "perturbed_sampled": ["while True: T, H, S = map(int, input().split()) if T == -1 and H == -1 and S == -1: break # Convert current counter to seconds current_seconds = T *  capacity in seconds (120 minutes) total_seconds = 120 * 60 # Remaining tape in seconds remaining_seconds = total_seconds - current_seconds # Standard recording: remaining time is as is std_hours = remaining_seconds // 3600 std_minutes = (remaining_seconds % 3600) // 60 std_seconds = remaining_seconds % 60 # 3x recording: can record   3600) // 60 triple_seconds = triple_total_seconds % 60 print(f\"{std_hours:02d}:{std_minutes:02d}:{std_seconds:02d}\") print(f\"{triple_hours:02d}:{triple_minutes:02d}:{triple_seconds:02d}\")"], "perturbed_original": ["#!/usr/bin/python # coding: utf-8 while True: h, m, s = map(int, raw_input().split()) if h == m == s == -1: break full =  + m * 60  - h * 3600) / 60) s = rest - h * 3600 - m * 60 th = int(rest / 1200) tm = int((rest - th * 1200) / 20) ts = (rest - th * 1200 - tm * 20) * 3 print \"{:02d}:{:02d}:{:02d}\".format(h, m, s) print \"{:02d}:{:02d}:{:02d}\".format(th, tm, ts)"], "original_ll": -0.7150968313217163, "sampled_ll": -0.9008345603942871, "all_perturbed_sampled_ll": [-1.8072130680084229], "all_perturbed_original_ll": [-1.425999641418457], "perturbed_sampled_ll": -1.8072130680084229, "perturbed_original_ll": -1.425999641418457, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(n){while(~scanf(\"%d\",&n)){float x=1,y=0,r,t;for(;--n>0;x=t)r=hypot(x,y),t=x-y/r,y+=x/r;n+2&&printf(\"%f\\n%f\\n\",x,y);}}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != -1) {\n        double x = 1.0, y = 0.0;\n        double wx = 0.0, wy = 0.0;\n        \n        for (int i = 2; i <= n; i++) {\n            double dx = wx - x;\n            double dy = wy - y;\n            double dist = sqrt(dx * dx + dy * dy);\n            \n            double ux = dx / dist;\n            double uy = dy / dist;\n            \n            double rx = -uy;\n            double ry = ux;\n            \n            x = x + rx;\n            y = y + ry;\n        }\n        \n        printf(\"%.2f\\n%.2f\\n\", x, y);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int n; while (scanf(\"%d\", &n) == 1 && n != -1) { double x = 1.0, y = 0.0; double wx = 0.0, wy = 0.0;  double dx =  double ux = dx / dist; double uy = dy / dist; double rx = -uy; double ry = ux; x = x + rx; y = y + ry; } printf(\"%.2f\\n%.2f\\n\", x, y); } return 0; }"], "perturbed_original": ["main(n){while(~scanf(\"%d\",&n)){float x=1,y=0,r,t;for(;--n>0;x=t)r=hypot(x,y),t=x-y/r,y+=x/r;n+2&&printf(\"%f\\n%f\\n\",x,y);}}"], "original_ll": -2.8992536067962646, "sampled_ll": -0.7283958196640015, "all_perturbed_sampled_ll": [-1.3665850162506104], "all_perturbed_original_ll": [-2.8992536067962646], "perturbed_sampled_ll": -1.3665850162506104, "perturbed_original_ll": -2.8992536067962646, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble x, y;\n\t\tint n;\n\n\t\tn = sc.nextInt();\n\t\twhile (n != -1) {\n\t\t\tx = 1.0;\n\t\t\ty = 0.0;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (x == 0.0) {\n\t\t\t\t\tif (0 < y) {\n\t\t\t\t\t\tx -= 1.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx += 1.0;\n\t\t\t\t\t}\n\t\t\t\t} else if (y == 0.0) {\n\t\t\t\t\tif (0 < x) {\n\t\t\t\t\t\ty += 1.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty -= 1.0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdouble theta = Math.atan2(y, x) + Math.PI / 2;\n\t\t\t\t\tx += Math.cos(theta);\n\t\t\t\t\ty += Math.sin(theta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(x);\n\t\t\tSystem.out.println(y);\n\t\t\tn = sc.nextInt();\n\t\t}\t\t\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == -1) break;\n            \n            // Start at position (1, 0) - 1m east of the well at (0, 0)\n            double x = 1.0;\n            double y = 0.0;\n            \n            // Initial direction: facing the well (west)\n            double dx = -1.0;\n            double dy = 0.0;\n            \n            // Process steps 2 to n\n            for (int i = 2; i <= n; i++) {\n                // Turn right 90 degrees\n                double newDx = dy;\n                double newDy = -dx;\n                dx = newDx;\n                dy = newDy;\n                \n                // Move 1m forward\n                x += dx;\n                y += dy;\n                \n                // Face the well again\n                double dist = Math.sqrt(x * x + y * y);\n                dx = -x / dist;\n                dy = -y / dist;\n            }\n            \n            System.out.printf(\"%.2f\\n%.2f\\n\", x, y);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) {  = sc.nextInt(); if (n == -1) break; // Start at position (1, 0) - 1m east of the well at (0, 0) double x = 1.0; double y = 0.0; // Initial direction: facing the well (west) double dx = -1.0; double dy = 0.0; // Process steps 2 to n for (int i = 2; i <= n; i++) { // Turn right 90 degrees double  dy = newDy; // Move 1m  well again double dist = Math.sqrt(x * x  = -y / dist; } System.out.printf(\"%.2f\\n%.2f\\n\", x, y); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String args[]) { Scanner sc = new Scanner(System.in); double  -1) { x = 1.0; y = 0.0; for (int i = 0; i < n; i++) { if (x == 0.0) { if (0  += 1.0; } } else if (y == 0.0) { if (0 < x)  } } else { double theta = Math.atan2(y, x) + Math.PI / 2; x += Math.cos(theta); y += Math.sin(theta); } } System.out.println(x); System.out.println(y); n = sc.nextInt(); } } }"], "original_ll": -0.5416090488433838, "sampled_ll": -0.9549543261528015, "all_perturbed_sampled_ll": [-2.1717560291290283], "all_perturbed_original_ll": [-1.241721510887146], "perturbed_sampled_ll": -2.1717560291290283, "perturbed_original_ll": -1.241721510887146, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for e in iter(input,'-1'):\n z=1\n for _ in[0]*~-int(e):d=z*1j;z+=d/abs(d)\n print(z.real)\n print(z.imag)\n", "sampled": "import math\n\ndef solve(n):\n    # Start at position (1, 0) - 1m east of the well\n    x, y = 1.0, 0.0\n    \n    # Initial direction: facing the well (west)\n    # We'll track the angle we're facing\n    \n    for step in range(2, n + 1):\n        # Calculate direction to well from current position\n        dx_to_well = -x\n        dy_to_well = -y\n        angle_to_well = math.atan2(dy_to_well, dx_to_well)\n        \n        # Turn right 90 degrees from facing the well\n        new_angle = angle_to_well - math.pi / 2\n        \n        # Move 1m in that direction\n        x += math.cos(new_angle)\n        y += math.sin(new_angle)\n    \n    return x, y\n\nwhile True:\n    n = int(input())\n    if n == -1:\n        break\n    \n    x, y = solve(n)\n    print(f\"{x:.2f}\")\n    print(f\"{y:.2f}\")\n", "perturbed_sampled": ["import math def solve(n): # Start at position (1, 0)  0.0 # Initial direction: facing the well (west) # We'll track the angle we're facing for step in range(2, n + 1): # Calculate direction to well from current position dx_to_well = -x dy_to_well = -y angle_to_well = math.atan2(dy_to_well, dx_to_well) # Turn right 90 degrees from  # Move 1m in that  while True: n = int(input()) if n == -1: break x, y = solve(n) print(f\"{x:.2f}\") print(f\"{y:.2f}\")"], "perturbed_original": ["for e in iter(input,'-1'): z=1 for _ in[0]*~-int(e):d=z*1j;z+=d/abs(d) print(z.real) print(z.imag)"], "original_ll": -3.55255389213562, "sampled_ll": -1.252183198928833, "all_perturbed_sampled_ll": [-2.310102939605713], "all_perturbed_original_ll": [-3.5931789875030518], "perturbed_sampled_ll": -2.310102939605713, "perturbed_original_ll": -3.5931789875030518, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#define LENGTH 1001\n\nint main(void)\n{\n  char st[LENGTH];\n  int i, j, k, l, m, check, fix, count, kosuu, decimal=1;\n  int a, b, t=0;\n  char ch;\n\n  i = 0;\n  while(scanf(\"%1c\",&ch)!=EOF)\n    {\n      st[i] = ch;\n      i++;\n    }\n  st[i+1] = 0;\n  st[i+2] = 0;\n  st[i+3] = 0;\n\n  k = strlen(st);\n\n\n  /*\n  printf(\"k = %d\\n\",strlen(st));\n\n  for(i=0;i<=strlen(st);i++)\n    {\n      printf(\"st[%d] %d\\n\",i,st[i]); \n      }\n  */\n\n  j = 1;\n  count = 1;\n  kosuu = 0;\n\n  i = 0;\n  t = 0;\n  while(1)\n    {\n      if(st[i]=='@')\n\t{\n\t  kosuu = st[i+1]-48;\n\t  for(j=0;j<=kosuu-1;j++)\n\t    {\n\t      printf(\"%c\",st[i+2]);\n\t    }\n\t  i = i + 3;\n\t}\n      else if(st[i]==10)\n\t{\n\t  printf(\"\\n\");\n\t  i++;\n\t}\n      else if(st[i]==0)\n\t{\n\t  break;\n\t}\n      else\n\t{\n\t  printf(\"%c\",st[i]);\n\t  i++;\n\t}\n    }\n  printf(\"\\n\");\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    char line[256];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int len = strlen(line);\n        if (len > 0 && line[len-1] == '\\n') {\n            line[len-1] = '\\0';\n            len--;\n        }\n        \n        int i = 0;\n        while (i < len) {\n            if (line[i] == '@') {\n                i++;\n                int count = line[i] - '0';\n                i++;\n                char ch = line[i];\n                for (int j = 0; j < count; j++) {\n                    putchar(ch);\n                }\n                i++;\n            } else {\n                putchar(line[i]);\n                i++;\n            }\n        }\n        putchar('\\n');\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <ctype.h> int main() { char line[256]; while (fgets(line, sizeof(line), stdin)) { int len = strlen(line); if (len > 0 && line[len-1] ==  0; while (i < len) { if (line[i] == '@') { i++; int count = line[i] - '0'; i++; char ch = line[i]; for (int j = 0;  { putchar(line[i]); i++; } } putchar('\\n'); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #define LENGTH 1001 int main(void) { char st[LENGTH]; int i, j, k, l, m, check, fix, count, kosuu, decimal=1; int a, b, t=0; char ch; i = 0; while(scanf(\"%1c\",&ch)!=EOF) { st[i] =  = 0; k = strlen(st); /* printf(\"k = %d\\n\",strlen(st)); for(i=0;i<=strlen(st);i++) { printf(\"st[%d] %d\\n\",i,st[i]); } */ j = 1; count  0; while(1)  i = i + 3; } else if(st[i]==10) { printf(\"\\n\"); i++; } else if(st[i]==0) { break; } else { printf(\"%c\",st[i]); i++; } } printf(\"\\n\"); return 0; }"], "original_ll": -1.1808665990829468, "sampled_ll": -0.5646564364433289, "all_perturbed_sampled_ll": [-1.4450981616973877], "all_perturbed_original_ll": [-1.7502179145812988], "perturbed_sampled_ll": -1.4450981616973877, "perturbed_original_ll": -1.7502179145812988, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.FileInputStream;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) throws Exception{\n        while(hasNext()){\n            StringBuilder s = new StringBuilder(NLine());\n            StringBuilder ans=new StringBuilder();\n            if(s.length()==0)return;\n            for (int i = 0; i < s.length(); i++) {\n                if(s.charAt(i)=='@'){\n                    i++;\n                    int len = s.charAt(i)-'0';\n                    i++;\n                    for (int j = 0; j < len; j++) {\n                        ans.append(s.charAt(i));\n                    }\n                } else {\n                    ans.append(s.charAt(i));\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n\n    \n    static int c=0;\n    static int NI(){\n        return (int)NL();\n    }\n    \n    static long NL(){\n        try {\n            long r = 0;\n            skip();\n            if(c=='-') return -NL();\n            for(;'0'<=c&&c<='9';c=System.in.read())\n                r = r * 10 + c - '0';\n            return r;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    \n    static char NC(){\n        try {\n            skip();\n            return (char)c;\n        } catch (Exception e) {\n            return 0;\n        }\n    }\n    \n    static String NS(){\n        StringBuilder sb=new StringBuilder();\n        try {\n            skip();\n            for(;!isSkip();){\n                sb.append((char)c);\n                c=System.in.read();\n            }\n            return sb.toString();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n    \n    static String NLine(){\n        StringBuilder sb=new StringBuilder();\n        try {\n            for(;c!='\\n'&&c!='\\r';){\n                sb.append((char)c);\n                c=System.in.read();\n//                System.out.println(c);\n            }\n            c=System.in.read();\n            return sb.toString();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n    \n    static void skip(){\n        try{\n            while(isSkip()){\n                c=System.in.read();\n            }\n        } catch (Exception e){}\n        \n    }\n    \n    static boolean hasNext(){\n        skip();\n        return c!=-1;\n    }\n    \n    static boolean isSkip(){\n        return 0 <= c && c <= ' ';\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            StringBuilder result = new StringBuilder();\n            \n            int i = 0;\n            while (i < line.length()) {\n                if (line.charAt(i) == '@') {\n                    // Found @ symbol, next character is count, character after that is the character to repeat\n                    i++; // move past @\n                    int count = line.charAt(i) - '0'; // get the count digit\n                    i++; // move to the character to repeat\n                    char charToRepeat = line.charAt(i);\n                    \n                    // Append the character 'count' times\n                    for (int j = 0; j < count; j++) {\n                        result.append(charToRepeat);\n                    }\n                    i++; // move past the repeated character\n                } else {\n                    // Regular character, just append it\n                    result.append(line.charAt(i));\n                    i++;\n                }\n            }\n            \n            System.out.println(result.toString());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String line = sc.nextLine(); StringBuilder result = new StringBuilder(); int i = 0; while (i < line.length()) { if (line.charAt(i) == '@') { // Found @ symbol, next character is count, character after that is the character to repeat i++; // move past @  char charToRepeat = line.charAt(i);  0; j < count; j++) { result.append(charToRepeat); } i++; // move past the repeated character } else { // Regular character, just append it result.append(line.charAt(i)); i++; } } System.out.println(result.toString()); } sc.close(); } }"], "perturbed_original": ["import java.io.FileInputStream; import java.util.Scanner; public class Main { /** * @param args */ public static void main(String[] args) throws Exception{ while(hasNext()){ StringBuilder s =  0; i < s.length(); i++) { if(s.charAt(i)=='@'){ i++; int  < len; j++) { ans.append(s.charAt(i)); } } else { ans.append(s.charAt(i)); } } System.out.println(ans); } } static int c=0; static int NI(){ return (int)NL(); } static long NL(){ try  r = r  (Exception e) { return -1; } } static char NC(){ try { skip(); return (char)c; } catch  } return sb.toString(); } catch (Exception e) { return \"\"; } } static String NLine(){ StringBuilder sb=new StringBuilder(); try { for(;c!='\\n'&&c!='\\r';){ sb.append((char)c); c=System.in.read(); // System.out.println(c); } c=System.in.read(); return sb.toString(); } catch (Exception e) { return \"\"; } } static void skip(){ try{ while(isSkip()){ c=System.in.read(); } } catch (Exception e){} } static boolean hasNext(){ skip(); return c!=-1; } static boolean isSkip(){ return 0 <= c && c <= ' '; } }"], "original_ll": -0.9108266830444336, "sampled_ll": -0.7468795776367188, "all_perturbed_sampled_ll": [-1.3237203359603882], "all_perturbed_original_ll": [-1.898441195487976], "perturbed_sampled_ll": -1.3237203359603882, "perturbed_original_ll": -1.898441195487976, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\n\ndef method(l):\n    return l if l.find('@') < 0 else method(l.replace(l[l.find('@'):l.find('@')+3], l[l.find('@')+2]*int(l[l.find('@')+1])))\n\nif __name__ == '__main__':\n    for line in sys.stdin:\n        print(method(line))", "sampled": "import sys\nimport re\n\nfor line in sys.stdin:\n    line = line.rstrip('\\n')\n    result = []\n    i = 0\n    while i < len(line):\n        if line[i] == '@':\n            # Find the digit(s) after @\n            j = i + 1\n            while j < len(line) and line[j].isdigit():\n                j += 1\n            count = int(line[i+1:j])\n            # The character to repeat is at position j\n            if j < len(line):\n                char = line[j]\n                result.append(char * count)\n                i = j + 1\n            else:\n                i = j\n        else:\n            result.append(line[i])\n            i += 1\n    print(''.join(result))\n", "perturbed_sampled": ["import sys import re for line in sys.stdin: line = line.rstrip('\\n') result = [] i  # Find the digit(s) after @ j = i  1 count = int(line[i+1:j]) # The character to repeat is at position j if j < len(line): char = line[j] result.append(char * count) i = j + 1 else: i = j else: result.append(line[i]) i += 1 print(''.join(result))"], "perturbed_original": ["import sys def method(l): return l if l.find('@') < 0 else method(l.replace(l[l.find('@'):l.find('@')+3], l[l.find('@')+2]*int(l[l.find('@')+1]))) if __name__ == '__main__': for line in sys.stdin: print(method(line))"], "original_ll": -1.884974718093872, "sampled_ll": -0.8884026408195496, "all_perturbed_sampled_ll": [-2.4016671180725098], "all_perturbed_original_ll": [-2.015866756439209], "perturbed_sampled_ll": -2.4016671180725098, "perturbed_original_ll": -2.015866756439209, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\nint main(){\n\tint i=0,j;\n\tdouble x[20],y[20],s=0;\n    //\u5024\u306e\u8aad\u307f\u8fbc\u307f\n    \n    while(scanf(\"%lf,%lf\\n\",&x[i],&y[i]) !=EOF) {\n    \t\t//scanf(\"%lf%lf\",&x[i],&y[i]);\n    \t\ti++;\n    \t}\n    \tj=i\n    \tfor(i=1;i<j;i++){\n    \t\ts+=(x[i]*y[i+1]-x[i+1]*y[i]);\n    \t}\n        s+=(x[i]*y[0]-x[0]*y[i]);\n    \tprintf(\"%0.6lf\\n\",fabs(s)/2.0);\n    \n    return 0;\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x[20], y[20];\n    int n = 0;\n    char c;\n    \n    while (scanf(\"%lf,%lf\", &x[n], &y[n]) == 2) {\n        n++;\n        while ((c = getchar()) != '\\n' && c != EOF);\n        if (c == EOF) break;\n    }\n    \n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        area += x[i] * y[j] - x[j] * y[i];\n    }\n    area = fabs(area) / 2.0;\n    \n    printf(\"%.6f\\n\", area);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  0; char c; while (scanf(\"%lf,%lf\", &x[n], &y[n]) == 2) { n++; while ((c = getchar()) != '\\n' && c != EOF); if (c == EOF) break; } double area = 0.0; for (int i = 0; i < n; i++) { int j = (i + 1) % n; area += x[i] * y[j] - x[j]  return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> int main(){ int i=0,j; double x[20],y[20],s=0; //\u5024\u306e\u8aad\u307f\u8fbc\u307f while(scanf(\"%lf,%lf\\n\",&x[i],&y[i]) !=EOF) { //scanf(\"%lf%lf\",&x[i],&y[i]); i++; } j=i for(i=1;i<j;i++){ s+=(x[i]*y[i+1]-x[i+1]*y[i]); } s+=(x[i]*y[0]-x[0]*y[i]); printf(\"%0.6lf\\n\",fabs(s)/2.0); return 0; }"], "original_ll": -1.4230117797851562, "sampled_ll": -0.6654309034347534, "all_perturbed_sampled_ll": [-1.5841041803359985], "all_perturbed_original_ll": [-1.4891623258590698], "perturbed_sampled_ll": -1.5841041803359985, "perturbed_original_ll": -1.4891623258590698, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tdouble[] x = new double[20];\n\t\tdouble[] y = new double[20];\n\t\tint i = 0;\n\t\tString string;\n\t\t\n\t\twhile((string = reader.readLine()) != null){\n\t\t\tx[i] = Double.valueOf(string.split(\",\")[0]);\n\t\t\ty[i] = Double.valueOf(string.split(\",\")[1]);\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tdouble a = Math.hypot(x[1] - x[0], y[1] - y[0]);\n\t\tdouble b = Math.hypot(x[2] - x[0], y[2] - y[0]);\n\t\tdouble c = Math.hypot(x[2] - x[1], y[2] - y[1]);\n\t\tdouble z = (a + b + c) / 2;\n\t\tdouble S = Math.sqrt(z * (z - a) * (z - b) * (z - c));\n\t\tfor(int j = 2; j < i - 1; j++){\n\t\t\ta = Math.hypot(x[j] - x[0], y[j] - y[0]);\n\t\t\tb = Math.hypot(x[j + 1] - x[0], y[j + 1] - y[0]);\n\t\t\tc = Math.hypot(x[j + 1] - x[j], y[j + 1] - y[j]);\n\t\t\tz = (a + b + c) / 2;\n\t\t\tS += Math.sqrt(z * (z - a) * (z - b) * (z - c));\n\t\t}\n\t\tSystem.out.println(S);\n\t}\n}", "sampled": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ArrayList<Double> x = new ArrayList<>();\n        ArrayList<Double> y = new ArrayList<>();\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) continue;\n            \n            String[] parts = line.split(\",\");\n            x.add(Double.parseDouble(parts[0]));\n            y.add(Double.parseDouble(parts[1]));\n        }\n        \n        int n = x.size();\n        double area = 0.0;\n        \n        for (int i = 0; i < n; i++) {\n            int j = (i + 1) % n;\n            area += x.get(i) * y.get(j);\n            area -= x.get(j) * y.get(i);\n        }\n        \n        area = Math.abs(area) / 2.0;\n        \n        System.out.printf(\"%.6f\\n\", area);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; import java.util.ArrayList; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); ArrayList<Double> x = new ArrayList<>(); ArrayList<Double> y = new ArrayList<>(); while (sc.hasNext()) { String line = sc.nextLine().trim(); if  n = x.size(); double area  i++) { int j = (i + 1) % n; area += x.get(i) * y.get(j); area -= x.get(j) * y.get(i); } area = Math.abs(area) / 2.0; System.out.printf(\"%.6f\\n\", area); sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader;  isr = new InputStreamReader(System.in); BufferedReader reader = new BufferedReader(isr); double[] x = new double[20]; double[] y = new double[20]; int  x[i] = Double.valueOf(string.split(\",\")[0]); y[i] = Double.valueOf(string.split(\",\")[1]); i++; } double a  Math.hypot(x[2] - x[0], y[2] - y[0]);  z = (a + b + c) / 2; double S = Math.sqrt(z * (z - a) * (z - b) * (z - c)); for(int j = 2; j < i - 1; j++){ a = Math.hypot(x[j] - x[0], y[j] - y[0]); b = Math.hypot(x[j + 1] - x[0], y[j +  y[j + 1] - y[j]); z = (a + b + c) / 2; S += Math.sqrt(z * (z - a) * (z - b) * (z - c)); } System.out.println(S); } }"], "original_ll": -0.45653730630874634, "sampled_ll": -0.48011547327041626, "all_perturbed_sampled_ll": [-1.3142951726913452], "all_perturbed_original_ll": [-1.054327130317688], "perturbed_sampled_ll": -1.3142951726913452, "perturbed_original_ll": -1.054327130317688, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "i = 0\nx = []\ny = []\nwhile 1:\n    try:\n        a,b = map(float,input().split(\",\"))\n        x.append(a)\n        y.append(b)\n    except EOFError:\n        break\n\nS = 0\nfor i in range(len(x)-2):\n    a = ((x[0]-x[i+1]) ** 2 + (y[0]-y[i+1]) ** 2) ** 0.5\n    b = ((x[0]-x[i+2]) ** 2 + (y[0]-y[i+2]) ** 2) ** 0.5\n    c = ((x[i+1]-x[i+2]) ** 2 + (y[i+1]-y[i+2]) ** 2) ** 0.5\n    z = (a + b + c)/2\n    S += (z * (z - a) * (z - b) * (z - c)) ** 0.5\nprint(S)\n", "sampled": "import sys\nimport math\n\ndef polygon_area(points):\n    n = len(points)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    area = abs(area) / 2.0\n    return area\n\npoints = []\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        x, y = map(float, line.split(','))\n        points.append((x, y))\n\narea = polygon_area(points)\nprint(f\"{area:.6f}\")\n", "perturbed_sampled": ["import sys import math def polygon_area(points): n = len(points) area = 0.0 for i in range(n): j = (i  -= points[j][0] * points[i][1] area = abs(area) / 2.0 return area points = [] for line in sys.stdin: line = line.strip() if line: x, y = map(float, line.split(',')) points.append((x, y)) area = polygon_area(points) print(f\"{area:.6f}\")"], "perturbed_original": ["i = 0 x = [] y = [] while 1: try: a,b = map(float,input().split(\",\")) x.append(a) y.append(b)  a = ((x[0]-x[i+1]) ** 2 + (y[0]-y[i+1]) ** 2) ** 0.5 b =  = ((x[i+1]-x[i+2]) ** 2 + (y[i+1]-y[i+2]) ** 2) ** 0.5 z = (a + b + c)/2 S += (z * (z - a) * (z - b) * (z - c)) ** 0.5 print(S)"], "original_ll": -0.6898422837257385, "sampled_ll": -0.41704094409942627, "all_perturbed_sampled_ll": [-1.5267457962036133], "all_perturbed_original_ll": [-1.2790592908859253], "perturbed_sampled_ll": -1.5267457962036133, "perturbed_original_ll": -1.2790592908859253, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nint main(int argc,char* argv[]){\n  \n  for(;;){\n    int q;\n    double x;\n\n    scanf(\"%d\",&q);\n    if(q == -1){break;}\n    \n    x = q/2;\n    while(!(fabs(x*x*x - q) < 0.00001*q)){\n      x = x - (x*x*x-q)/(3*x*x);\n    }\n\n    printf(\"%lf\\n\",x);\n  }\n\n  return 0;\n  \n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double q;\n    \n    while(1) {\n        scanf(\"%lf\", &q);\n        if(q == -1) break;\n        \n        double x = q / 2.0;\n        \n        while(fabs(x * x * x - q) >= 0.00001 * q) {\n            x = x - (x * x * x - q) / (3 * x * x);\n        }\n        \n        printf(\"%.6f\\n\", x);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { double q; while(1) { scanf(\"%lf\", &q); if(q == -1) break; double x = q / 2.0; while(fabs(x  { x = x - (x * x * x - q) / (3 * x * x); } printf(\"%.6f\\n\", x); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> int main(int argc,char* argv[]){ for(;;){ int q; double x; scanf(\"%d\",&q); if(q == -1){break;} x  - (x*x*x-q)/(3*x*x); } printf(\"%lf\\n\",x); } return 0; }"], "original_ll": -1.5093169212341309, "sampled_ll": -0.9079319834709167, "all_perturbed_sampled_ll": [-1.449324369430542], "all_perturbed_original_ll": [-1.995719313621521], "perturbed_sampled_ll": -1.449324369430542, "perturbed_original_ll": -1.995719313621521, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-5;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tdouble q = sc.nextDouble();\n\t\t\tif( q == 0 ) { System.out.println(0.00000); continue; }\n\t\t\tif( q == -1 ) break;\n\t\t\tdouble x = q / 2;\n\t\t\twhile( abs( x*x*x - q) >= EPS * q ) {\n\t\t\t\tx = f(x, q);\n\t\t\t}\n\t\t\tdebug(EPS*q);\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n\t\n\tdouble f(double x, double q) {\n\t\treturn x - (x*x*x - q) / ( 3 * x*x);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int q = sc.nextInt();\n            if (q == -1) break;\n            \n            double x = q / 2.0;\n            \n            while (Math.abs(x * x * x - q) >= 0.00001 * q) {\n                x = x - (x * x * x - q) / (3 * x * x);\n            }\n            \n            System.out.printf(\"%.6f\\n\", x);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main {  Scanner(System.in); while (true) { int q = sc.nextInt(); if (q == -1) break;  * x - q) >= 0.00001 * q) { x = x - (x * x * x - q) / (3 * x * x); } System.out.printf(\"%.6f\\n\", x); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import static java.lang.Math.*; import  << 28; double EPS = 1e-5; void run() {  sc.nextDouble(); if( q == 0 ) { System.out.println(0.00000); continue; } if( q == -1 ) break; double x = q / 2; while( abs(  = f(x, q); } debug(EPS*q); System.out.println(x); } } double f(double x, double q) { return x - (x*x*x - q) / ( 3 * x*x); } public static void main(String[] args) { new Main().run(); } void debug(Object... os) { // System.err.println(Arrays.deepToString(os)); } }"], "original_ll": -1.3572689294815063, "sampled_ll": -0.7332218289375305, "all_perturbed_sampled_ll": [-1.9055196046829224], "all_perturbed_original_ll": [-2.107407331466675], "perturbed_sampled_ll": -1.9055196046829224, "perturbed_original_ll": -2.107407331466675, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True :\n    q = int(input())\n    if q == -1 :\n        break\n    \n    n = 1\n    x = q / 2\n    while True :\n        if abs(x**3 - q) < (0.00001 * q) :\n            break\n        x = x - (x**3 - q) / (3 * x**2)\n    \n    print('{:.6f}'.format(x))\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    q = int(line.strip())\n    if q == -1:\n        break\n    \n    x = q / 2.0\n    \n    while abs(x**3 - q) >= 0.00001 * q:\n        x = x - (x**3 - q) / (3 * x**2)\n    \n    print(f\"{x:.6f}\")\n", "perturbed_sampled": ["import sys for line in sys.stdin:  q / 2.0 while abs(x**3 - q) >= 0.00001 * q: x = x - (x**3 - q) / (3 * x**2) print(f\"{x:.6f}\")"], "perturbed_original": ["while True : q = int(input()) if q == -1 : break n = 1 x = q / 2 while True : if abs(x**3 - q) < (0.00001 *  / (3 * x**2) print('{:.6f}'.format(x))"], "original_ll": -1.2298182249069214, "sampled_ll": -1.2198901176452637, "all_perturbed_sampled_ll": [-2.09717059135437], "all_perturbed_original_ll": [-2.346417188644409], "perturbed_sampled_ll": -2.09717059135437, "perturbed_original_ll": -2.346417188644409, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\n  double x1,y1,x2,y2,xq,yq,x,y;\n  double a,b,A,B,cx,cy;\n\n  while(~scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\",&x1,&y1,&x2,&y2,&xq,&yq)){\n    \n    if(y1==0 && y2==0){\n      printf(\"%lf %lf\\n\",xq,-yq);\n      continue;\n    }\n    if(xx1==0 && x2==0){\n      printf(\"%lf %lf\\n\",-xq,yq);\n      continue;\n    }\n    a=(y2-y1)?(x2-x1)/(y2-y1):0;\n    b=y2-a*x2;\n\n    A=a?-1/a:0;\n    B=yq-A*xq;\n\n    cx=(a-A)?(B-b)/(a-A):0;\n    cy=A*cx+B;\n\n    x=2*cx-xq;\n    y=2*cy-yq;\n\n    printf(\"%lf %lf\\n\",x,y);\n  }\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double x1, y1, x2, y2, xq, yq;\n    \n    while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\", &x1, &y1, &x2, &y2, &xq, &yq) == 6) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        \n        double a = dx * dx + dy * dy;\n        double t = ((xq - x1) * dx + (yq - y1) * dy) / a;\n        \n        double px = x1 + t * dx;\n        double py = y1 + t * dy;\n        \n        double rx = 2 * px - xq;\n        double ry = 2 * py - yq;\n        \n        printf(\"%.6f %.6f\\n\", rx, ry);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double  &x2, &y2, &xq, &yq) == 6) { double dx = x2 -  dx * dx + dy * dy; double t = ((xq - x1) * dx + (yq - y1) * dy) / a; double px = x1 + t * dx; double py = y1 + t * dy; double rx = 2 * px -  %.6f\\n\", rx, ry); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ double x1,y1,x2,y2,xq,yq,x,y; double a,b,A,B,cx,cy; while(~scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\",&x1,&y1,&x2,&y2,&xq,&yq)){ if(y1==0 && y2==0){  } a=(y2-y1)?(x2-x1)/(y2-y1):0; b=y2-a*x2; A=a?-1/a:0; B=yq-A*xq; cx=(a-A)?(B-b)/(a-A):0; cy=A*cx+B; x=2*cx-xq; y=2*cy-yq; printf(\"%lf %lf\\n\",x,y); } return 0; }"], "original_ll": -1.2229639291763306, "sampled_ll": -0.5952796936035156, "all_perturbed_sampled_ll": [-2.067281723022461], "all_perturbed_original_ll": [-1.5028772354125977], "perturbed_sampled_ll": -2.067281723022461, "perturbed_original_ll": -1.5028772354125977, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(in.hasNext())new AOJ0081().doIt();\n\t}\n\n\tclass AOJ0081{\n\t\t//p0-p1\u306e\u76f4\u7dda\u304c\u3042\u308b\u3068\u304d\u306b\u76f4\u7ddap2\u304b\u3089\u76f4\u7dda\u3089\u3057\u305f\u3068\u304dp0-p1\u4e0a\u306e\u5782\u76f4\u306a\u70b9\u3092\u6c42\u3081\u308b\u3002\n\t\tprivate Point2D projection(Line2D l,Point2D p2){\n\t\t\tdouble kyori = l.getP1().distance(l.getP2());\n\t\t\tdouble angle = angle(l.getP1(),l.getP2(), p2);\n\t\t\tdouble t = l.getP1().distance(p2) * Math.cos(angle);\n\t\t\tPoint2D result = new Point2D.Double(l.getP1().getX()+(l.getP2().getX()-l.getP1().getX())*t/kyori,\n\t\t\t\t\tl.getP1().getY()+(l.getP2().getY()-l.getP1().getY())*t/kyori);\n\t\t\treturn result;\n\t\t}\n\t\tprivate double angle(Point2D p0, Point2D p1, Point2D p2){\n\t\t\treturn Math.atan2(p2.getY()-p0.getY(),p2.getX()-p0.getX())-\n\t\t\t\t\tMath.atan2(p1.getY()-p0.getY(),p1.getX()-p0.getX());\n\t\t}\n\t\t\n\t\t\n\t\tvoid doIt(){\n\t\t\tString input[] = in.next().split(\",\");\n\t\t\tdouble a[] = new double[input.length];\n\t\t\tfor(int i=0;i<a.length;i++)a[i] = Double.parseDouble(input[i]);\n\t\t\tLine2D l = new Line2D.Double(a[0], a[1], a[2], a[3]);\n\t\t\tPoint2D p = new Point2D.Double(a[4],a[5]);\n\t\t\tPoint2D result = projection(l, p);\n\t\t\t double dx = result.getX()-p.getX();\n             double dy = result.getY()-p.getY();\n             double tx = dx+result.getX();\n             double ty = dy+result.getY();\n             System.out.printf(\"%.9f %.9f\\n\",tx,ty);\n\t\t}\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            \n            double x1 = Double.parseDouble(parts[0]);\n            double y1 = Double.parseDouble(parts[1]);\n            double x2 = Double.parseDouble(parts[2]);\n            double y2 = Double.parseDouble(parts[3]);\n            double xq = Double.parseDouble(parts[4]);\n            double yq = Double.parseDouble(parts[5]);\n            \n            // Direction vector of the line P1P2\n            double dx = x2 - x1;\n            double dy = y2 - y1;\n            \n            // Vector from P1 to Q\n            double qx = xq - x1;\n            double qy = yq - y1;\n            \n            // Project Q onto the line P1P2\n            // Parameter t for the projection point\n            double t = (qx * dx + qy * dy) / (dx * dx + dy * dy);\n            \n            // Projection point H on the line\n            double hx = x1 + t * dx;\n            double hy = y1 + t * dy;\n            \n            // R is the reflection of Q across H\n            double rx = 2 * hx - xq;\n            double ry = 2 * hy - yq;\n            \n            System.out.printf(\"%.6f %.6f%n\", rx, ry);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String line = sc.nextLine(); String[] parts = line.split(\",\"); double x1 = Double.parseDouble(parts[0]); double y1 = Double.parseDouble(parts[1]); double x2 = Double.parseDouble(parts[2]); double y2 = Double.parseDouble(parts[3]); double xq = Double.parseDouble(parts[4]); double yq = Double.parseDouble(parts[5]); // Direction vector of the line P1P2 double dx = x2 - x1; double dy = y2 - y1; // Vector from P1 to Q double qx = xq - x1; double qy = yq - y1; // Project Q  point double t = (qx * dx +  hx = x1 + t * dx;  is the reflection of  xq; double ry = 2 * hy - yq; System.out.printf(\"%.6f %.6f%n\", rx, ry); } sc.close(); } }"], "perturbed_original": ["import java.awt.geom.Line2D; import java.awt.geom.Point2D; import java.util.*; public class Main { Scanner in = new Scanner(System.in); public static void main(String[] args) { new Main(); } public Main() { while(in.hasNext())new AOJ0081().doIt(); } class AOJ0081{  double angle = angle(l.getP1(),l.getP2(), p2); double t = l.getP1().distance(p2) * Math.cos(angle); Point2D result = new Point2D.Double(l.getP1().getX()+(l.getP2().getX()-l.getP1().getX())*t/kyori, l.getP1().getY()+(l.getP2().getY()-l.getP1().getY())*t/kyori); return result; } private double angle(Point2D p0, Point2D p1, Point2D p2){ return Math.atan2(p2.getY()-p0.getY(),p2.getX()-p0.getX())- Math.atan2(p1.getY()-p0.getY(),p1.getX()-p0.getX()); } void doIt(){ String input[] = in.next().split(\",\"); double a[] = new double[input.length]; for(int i=0;i<a.length;i++)a[i] = Double.parseDouble(input[i]); Line2D l = new Line2D.Double(a[0], a[1], a[2], a[3]); Point2D  dx = result.getX()-p.getX();  = dy+result.getY(); System.out.printf(\"%.9f %.9f\\n\",tx,ty); } } }"], "original_ll": -1.0994253158569336, "sampled_ll": -0.6274902820587158, "all_perturbed_sampled_ll": [-1.3532602787017822], "all_perturbed_original_ll": [-1.2824583053588867], "perturbed_sampled_ll": -1.3532602787017822, "perturbed_original_ll": -1.2824583053588867, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfrom math import complex as C\nfor e in sys.stdin:\n a,b,c,d,e,f=map(float,e.split(','))\n z,w,q=C(a,b),C(c,d),C(e,f)\n w-=z\n z+=(w/abs(w))**2*(q-z).conjugate()\n print(z.real,z.imag)\n", "sampled": "import sys\n\ndef reflect_point(x1, y1, x2, y2, xq, yq):\n    # Vector along the line P1P2\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    # Vector from P1 to Q\n    qx = xq - x1\n    qy = yq - y1\n    \n    # Project Q onto the line P1P2\n    # t = dot(PQ, P1P2) / dot(P1P2, P1P2)\n    t = (qx * dx + qy * dy) / (dx * dx + dy * dy)\n    \n    # Point on the line closest to Q\n    px = x1 + t * dx\n    py = y1 + t * dy\n    \n    # Reflect Q across the line\n    rx = 2 * px - xq\n    ry = 2 * py - yq\n    \n    return rx, ry\n\nfor line in sys.stdin:\n    coords = list(map(float, line.strip().split(',')))\n    x1, y1, x2, y2, xq, yq = coords\n    rx, ry = reflect_point(x1, y1, x2, y2, xq, yq)\n    print(f\"{rx:.6f} {ry:.6f}\")\n", "perturbed_sampled": ["import sys def reflect_point(x1, y1, x2, y2, xq, yq): # Vector along the line P1P2 dx = x2 - x1 dy = y2 - y1 # Vector from P1 to Q qx = xq - x1 qy = yq - y1 # Project Q onto the line P1P2 # t = dot(PQ, P1P2) /  dy) / (dx * dx + dy * dy)  x1 + t * dx py = y1 + t * dy  px - xq ry  line in sys.stdin: coords = list(map(float, line.strip().split(','))) x1, y1, x2, y2, xq, yq = coords rx, ry = reflect_point(x1, y1, x2, y2, xq, yq) print(f\"{rx:.6f} {ry:.6f}\")"], "perturbed_original": ["import sys from math import complex as C for e in sys.stdin: a,b,c,d,e,f=map(float,e.split(',')) z,w,q=C(a,b),C(c,d),C(e,f) w-=z z+=(w/abs(w))**2*(q-z).conjugate() print(z.real,z.imag)"], "original_ll": -2.270040273666382, "sampled_ll": -0.6999838948249817, "all_perturbed_sampled_ll": [-1.6243891716003418], "all_perturbed_original_ll": [-2.540060043334961], "perturbed_sampled_ll": -1.6243891716003418, "perturbed_original_ll": -2.540060043334961, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <limits.h>\n\nstatic int units[8];\nstatic int waitings[8];\n\nvoid setup() {\n\tunits[0] = 4;\n\tunits[1] = 1;\n\tunits[2] = 4;\n\tunits[3] = 1;\n\tunits[4] = 2;\n\tunits[5] = 1;\n\tunits[6] = 2;\n\tunits[7] = 1;\n}\n\nint scan_waitings() {\n\treturn scanf(\"%d %d %d %d %d %d %d %d\",\n\t\t\t&waitings[0], &waitings[1], &waitings[2], &waitings[3],\n\t\t\t&waitings[4], &waitings[5], &waitings[6], &waitings[7]);\n}\n\nint count_passengers(int offset) {\n\tint sum = 0;\n\tint i;\n\tfor (i = 0; i < 8; i++) {\n\t\tsum += (units[(i + offset) % 8] > waitings[i]) ? waitings[i] : units[(i + offset) % 8];\n\t}\n\treturn sum;\n}\n\nvoid print_result(int offset) {\n\tint i;\n\tfor (i = 0; i < 8; i++) {\n\t\tprintf(\"%d\", units[(i + offset) % 8]);\n\t\tif (i < 7) {\n\t\t\tprintf(\" \");\n\t\t} else {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}\n\nint main() {\n\tint offset = 0;\n\tint max = 0;\n\tint count = 0;\n\tint max_offset = 0;\n\tchar str[9];\n\tint num = INT_MAX;\n\tsetup();\n\n\twhile (scan_waitings() > 0) {\n\t\tmax = 0;\n\t\tcount = 0;\n\t\tmax_offset = 0;\n\t\tnum = INT_MAX;\n\t\tfor (offset = 0; offset < 8; offset++) {\n\t\t\tcount = count_passengers(offset);\n\t\t\tsprintf(str, \"%d%d%d%d%d%d%d%d\",\n\t\t\t\t\t\tunits[(0 + offset) % 8],\n\t\t\t\t\t\tunits[(1 + offset) % 8],\n\t\t\t\t\t\tunits[(2 + offset) % 8],\n\t\t\t\t\t\tunits[(3 + offset) % 8],\n\t\t\t\t\t\tunits[(4 + offset) % 8],\n\t\t\t\t\t\tunits[(5 + offset) % 8],\n\t\t\t\t\t\tunits[(6 + offset) % 8],\n\t\t\t\t\t\tunits[(7 + offset) % 8]\n\t\t\t\t\t\t);\n\t\t\tif (count > max) {\n//\t\t\t\tprintf(\"\u65b0\u8a18\u9332   offset = %d, \u914d\u7f6e = %d\\n\", offset, atoi(str));\n\t\t\t\tnum = atoi(str);\n\t\t\t\tmax_offset = offset;\n\t\t\t\tmax = count;\n\t\t\t} else if (count == max) {\n\t\t\t\tprintf(\"\u30bf\u30a4\u8a18\u9332 offset = %d, \u914d\u7f6e = %d\\n\", offset, atoi(str));\n\t\t\t\tif (num > atoi(str)) {\n\t\t\t\t\tmax = count;\n\t\t\t\t\tnum = atoi(str);\n\t\t\t\t\tmax_offset = offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprint_result(max_offset);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int p[8];\n    int rides[8] = {4, 1, 4, 1, 2, 1, 2, 1}; // Initial configuration\n    \n    while (scanf(\"%d %d %d %d %d %d %d %d\", &p[0], &p[1], &p[2], &p[3], &p[4], &p[5], &p[6], &p[7]) == 8) {\n        int best_rotation = 0;\n        int min_left = 1000000;\n        long long min_value = 99999999;\n        \n        // Try all 8 rotations\n        for (int rot = 0; rot < 8; rot++) {\n            int left = 0;\n            long long value = 0;\n            \n            // Calculate how many customers can't ride and the resulting value\n            for (int i = 0; i < 8; i++) {\n                int ride_pos = (i - rot + 8) % 8;\n                int capacity = rides[ride_pos];\n                int customers = p[i];\n                \n                if (customers > capacity) {\n                    left += customers - capacity;\n                }\n                \n                value = value * 10 + capacity;\n            }\n            \n            // Update best if this is better\n            if (left < min_left || (left == min_left && value < min_value)) {\n                min_left = left;\n                min_value = value;\n                best_rotation = rot;\n            }\n        }\n        \n        // Output the best configuration\n        for (int i = 0; i < 8; i++) {\n            int ride_pos = (i - best_rotation + 8) % 8;\n            if (i > 0) printf(\" \");\n            printf(\"%d\", rides[ride_pos]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int p[8]; int rides[8] = {4, 1, 4, 1, 2, 1, 2, 1}; // Initial configuration while (scanf(\"%d   = 0; int min_left = 1000000; long long min_value = 99999999; // Try all 8 rotations for (int rot = 0; rot < 8; rot++) { int left = 0; long long value = 0; //  for (int i = 0; i < 8; i++) { int ride_pos = (i - rot + 8) % 8; int capacity = rides[ride_pos]; int customers = p[i]; if (customers > capacity) { left += customers - capacity; } value = value * 10 + capacity; } // Update best if this is better if (left < min_left  = left; min_value =  i++) { int ride_pos = (i - best_rotation + 8) % 8; if (i > 0) printf(\" \"); printf(\"%d\", rides[ride_pos]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <limits.h> static int units[8]; static int waitings[8]; void setup() { units[0] = 4; units[1] ;<extra_id_1>int<extra_id_2>for (<extra_id_3>= waitings[i] [ 2; units[5] = 1; units[6] = 2; units[7] = 1; } %<extra_id_4>sum = bytes.length;<extra_id_5>i=<extra_id_6>[i]; num[i]<extra_id_7>+=<extra_id_8>if (invariant(offset) <<extra_id_9>{ if (bytes.length %<extra_id_10>/ 8; if(!parseUInt(offset)) { printf(\"\u30bf\u30a4\u8a18\u9332<extra_id_11>{ count ++ ;<extra_id_12>- 8*count;<extra_id_13><< 0 %d %d\", &waitings[0], &waitings[1], &waitings[2], &waitings[3], &waitings[4], &waitings[5], &waitings[6], &waitings[7]); } int count_passengers(int offset) { int sum = 0; int i; for (i = 0;  % 8] > waitings[i]) ? waitings[i] : units[(i +  { int i; for (i = 0; i < 8; i++) { printf(\"%d\", units[(i + offset) % 8]); if (i < 7) { printf(\" \"); } else { printf(\"\\n\"); } } } int main() { int offset = 0; int max = 0; int count = 0; int max_offset = 0; char str[9]; int num = INT_MAX; setup(); while (scan_waitings() > 0) { max = 0; count = 0; max_offset = 0; num = INT_MAX;  = count_passengers(offset); sprintf(str, \"%d%d%d%d%d%d%d%d\", units[(0 + offset) % 8],  units[(3 + offset) % 8], units[(4 + offset) % 8], units[(5 + offset) % 8], units[(6 + offset)  > max) { // printf(\"\u65b0\u8a18\u9332 offset = %d, \u914d\u7f6e = %d\\n\", offset, atoi(str)); num = atoi(str); max_offset = offset; max = count; } else if (count == max) { printf(\"\u30bf\u30a4\u8a18\u9332 offset = %d,  max = count; num = atoi(str); max_offset = offset; } } } print_result(max_offset); } return 0; }"], "original_ll": -0.71744704246521, "sampled_ll": -0.8195293545722961, "all_perturbed_sampled_ll": [-1.826450228691101], "all_perturbed_original_ll": [-1.955019474029541], "perturbed_sampled_ll": -1.826450228691101, "perturbed_original_ll": -1.955019474029541, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Main {\n    \n    public static void main( final String[] args ) {\n\t\n\tfinal Scanner stdin = new Scanner( System.in );\n\tfinal int[] ls = { 4, 1, 4, 1, 2, 1, 2, 1 };\n\t\n\twhile ( stdin.hasNextInt() ) {\n\t    final int[] ps = new int[8];\n\t    for ( int i = 0; i < 8; i++ ) {\n\t\tps[i] = stdin.nextInt();\n\t    }\n\t    \n\t    final int[] ans = new int[8];\t    \n\t    int maxPeople = 0;\n\t    for ( int i = 0; i < 8; i++ ) {\n\t\tfinal int p = ip( ps, ls );\n\t\tif ( p > maxPeople ) {\n\t\t    maxPeople = p;\n\t\t    System.arraycopy( ls, 0, ans, 0, 8 );\n\t\t}\n\t\tnext( ls );\n\t    }\n\t    System.out.print( ans[0] );\n\t    for ( int i = 1; i < 8; i++ ) {\n\t\tSystem.out.print( \" \" + ans[i] );\n\t    }\n\t    System.out.println();\n\t}\n    }\n    \n    static void next( int[] a ) {\n\tfinal int front = a[0];\n\tfor ( int i = 0; i < 7; i++ ) {\n\t    a[i] = a[i + 1];\n\t}\n\ta[7] = front;\n    }\n\n    static int ip( int[] ps, int[] ls ) {\n\tint sum = 0;\n\tfor ( int i = 0; i < ps.length; i++ ){\n\t    sum += min( ls[i], ps[i] );\n\t}\n\treturn sum;\n    }    \n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int[] people = new int[8];\n            for (int i = 0; i < 8; i++) {\n                people[i] = sc.nextInt();\n            }\n            \n            int[] rides = {4, 1, 4, 1, 2, 1, 2, 1};\n            \n            int minUnserved = Integer.MAX_VALUE;\n            int[] bestArrangement = new int[8];\n            \n            for (int rotation = 0; rotation < 8; rotation++) {\n                int[] currentArrangement = new int[8];\n                for (int i = 0; i < 8; i++) {\n                    currentArrangement[i] = rides[(i - rotation + 8) % 8];\n                }\n                \n                int unserved = 0;\n                for (int i = 0; i < 8; i++) {\n                    unserved += Math.max(0, people[i] - currentArrangement[i]);\n                }\n                \n                if (unserved < minUnserved) {\n                    minUnserved = unserved;\n                    bestArrangement = currentArrangement.clone();\n                } else if (unserved == minUnserved) {\n                    if (isSmaller(currentArrangement, bestArrangement)) {\n                        bestArrangement = currentArrangement.clone();\n                    }\n                }\n            }\n            \n            for (int i = 0; i < 8; i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(bestArrangement[i]);\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean isSmaller(int[] a, int[] b) {\n        for (int i = 0; i < 8; i++) {\n            if (a[i] < b[i]) return true;\n            if (a[i] > b[i]) return false;\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int[]  < 8; i++) { people[i] = sc.nextInt(); } int[] rides = {4, 1, 4, 1, 2, 1, 2, 1}; int minUnserved = Integer.MAX_VALUE; int[] bestArrangement = new int[8]; for (int rotation = 0; rotation < 8; rotation++) { int[] currentArrangement = new int[8]; for (int i = 0; i < 8; i++) { currentArrangement[i] = rides[(i - rotation + 8) % 8]; } int unserved = 0; for (int i = 0; i < 8; i++) { unserved += Math.max(0, people[i] - currentArrangement[i]); } if (unserved < minUnserved) { minUnserved = unserved; bestArrangement = currentArrangement.clone(); } else  = currentArrangement.clone(); } } } for (int  } private static boolean isSmaller(int[] a, int[]  i++)  b[i]) return false; } return false; } }"], "perturbed_original": ["import java.util.*; import java.io.*;  final String[] args ) {  2, 1 }; while ( stdin.hasNextInt() ) { final int[] ps = new int[8]; for ( int i = 0; i < 8; i++ ) { ps[i] = stdin.nextInt(); } final int[] ans = new int[8]; int maxPeople =  i++ ) { final int p = ip( ps, ls ); if ( p > maxPeople ) { maxPeople = p; System.arraycopy( ls, 0, ans, 0, 8 ); } next( ls ); } System.out.print( ans[0] ); for ( int i = 1; i < 8; i++ ) { System.out.print( \" \" + ans[i] );  { final int front = a[0]; for ( int i = 0; i  } a[7] = front; } static int ip( int[] ps, int[] ls ) { int sum = 0; for ( int i = 0; i < ps.length; i++ ){ sum += min( ls[i], ps[i] ); } return sum; } }"], "original_ll": -0.8131682276725769, "sampled_ll": -0.45858606696128845, "all_perturbed_sampled_ll": [-1.2351150512695312], "all_perturbed_original_ll": [-1.5439913272857666], "perturbed_sampled_ll": -1.2351150512695312, "perturbed_original_ll": -1.5439913272857666, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\np=['41412121','41212141','21414121','21214141','14141212','14121214','12141412','12121414']\ng=lambda x:list(map(int,x))\nfor e in sys.stdin:\n d={}\n for f in p:d[sum(s-t for s,t in zip(g(e.split()),g(f))if s>t)]=f\n print(*list(d[min(d)]))\n", "sampled": "import sys\nfrom itertools import permutations\n\ndef solve(passengers):\n    # Define the vehicles: 4, 4, 2, 2, 1, 1, 1, 1\n    vehicles = [4, 4, 2, 2, 1, 1, 1, 1]\n    \n    min_unable = float('inf')\n    best_arrangement = None\n    \n    # Generate all unique permutations of vehicles\n    seen = set()\n    for perm in permutations(vehicles):\n        if perm in seen:\n            continue\n        seen.add(perm)\n        \n        # Calculate unable to ride\n        unable = 0\n        for i in range(8):\n            if passengers[i] > perm[i]:\n                unable += passengers[i] - perm[i]\n        \n        # Check if this is better\n        if unable < min_unable:\n            min_unable = unable\n            best_arrangement = perm\n        elif unable == min_unable:\n            # Compare lexicographically\n            if perm < best_arrangement:\n                best_arrangement = perm\n    \n    return best_arrangement\n\n# Read all input\nlines = []\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        lines.append(line)\n\n# Process each dataset\nfor line in lines:\n    passengers = list(map(int, line.split()))\n    result = solve(passengers)\n    print(' '.join(map(str, result)))\n", "perturbed_sampled": ["import sys from itertools import  2, 1, 1, 1, 1 vehicles  = float('inf') best_arrangement = None # Generate all unique permutations of vehicles seen = set() for perm in permutations(vehicles): if perm in seen: continue seen.add(perm) # Calculate unable to ride unable = 0 for i in range(8): if passengers[i] > perm[i]: unable += passengers[i] - perm[i] # Check  unable best_arrangement = perm elif unable == min_unable: # Compare lexicographically if perm < best_arrangement: best_arrangement = perm return best_arrangement # Read all input lines = [] for line in sys.stdin: line = line.strip() if line: lines.append(line) # Process each  = solve(passengers) print(' '.join(map(str, result)))"], "perturbed_original": ["import sys p=['41412121','41212141','21414121','21214141','14141212','14121214','12141412','12121414'] g=lambda x:list(map(int,x)) for e in sys.stdin: d={} for f in p:d[sum(s-t for s,t in zip(g(e.split()),g(f))if s>t)]=f print(*list(d[min(d)]))"], "original_ll": -1.858563780784607, "sampled_ll": -0.8732151985168457, "all_perturbed_sampled_ll": [-2.3309051990509033], "all_perturbed_original_ll": [-1.9905339479446411], "perturbed_sampled_ll": -2.3309051990509033, "perturbed_original_ll": -1.9905339479446411, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int a,b,c,d,t=0;\n  char s;\n  while(scanf(\"%d %d %d\",&a,&b,&c)!=EOF){\n    if(a<=1868 && b<=9 && c<8){\n      printf(\"pre-meiji\\n\");\n      d=1;\n      t=1;\n    }\n    else if(a<=1912){\n      if(a!=1912){\n\tprintf(\"meiji \");\n\ta=a-1868+1;\n\td=0;\n\tt=1;\n      }\n      else if(a==1912){\n\tif(b<7){\n\t  printf(\"meiji \");\n\t  a=a-1868+1;\n\t  d=0;\n\t  t=1;\n\t}\n\telse if(b>=7){\n\t  if(c<30){\n\t    printf(\"meiji \");\n\t    a=a-1868+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t}\n      }\n    }\n    if(a<=1926 && t==0){\n      if(a!=1926){\n\tprintf(\"taisyo \");\n\ta=a-1912+1;\n\td=0;\n\tt=1;\n      }\n      else if(a==1926){\n\tif(b<12){\n\t  printf(\"taisyo \");\n\t  a=a-1912+1;\n\t  d=0;\n\t  t=1;\n\t}\n\telse if(b==12){\n\t  if(c<25){\n\t    printf(\"taisyo \");\n\t    a=a-1912+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t  if(c>=25){\n\t    printf(\"showa \");\n\t    a=a-1926+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t}\n      }\n    }\n    if(a<=1989 && t==0){\n      if(a!=1989){\n\tprintf(\"showa \");\n\ta=a-1926+1;\n\td=0;\n\tt=1;\n      }\n      else if(a==1989){\n\tif(b==1){\n\t  if(c<8){\n\t    printf(\"showa \");\n\t    a=a-1926+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t}\n      }\n    }\n    if(a>=1989 && t==0){\n      if(a!=1989){\n      printf(\"heisei \");\n      a=a-1989+1;\n      d=0;\n    }\n      else if(a==1989){\n\tif(b!=1){\n\t  printf(\"heisei \");\n\t  a=a-1989+1;\n\t  d=0;\n\t}\n\telse if(b==1){\n\t  if(c>=8){\n\t  printf(\"heisei \");\n\t  a=a-1989+1;\n\t  d=0;\n\t  }\n\t}\n      }\n    }\n    if(d==0){\n      printf(\"%d %d %d\\n\",a,b,c);\n    }\n  }\n  return (0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int year, month, day;\n    \n    while (scanf(\"%d %d %d\", &year, &month, &day) != EOF) {\n        if (year < 1868 || (year == 1868 && month < 9) || (year == 1868 && month == 9 && day < 8)) {\n            printf(\"pre-meiji\\n\");\n        }\n        else if (year < 1912 || (year == 1912 && month < 7) || (year == 1912 && month == 7 && day <= 29)) {\n            printf(\"meiji %d %d %d\\n\", year - 1868 + 1, month, day);\n        }\n        else if (year < 1926 || (year == 1926 && month < 12) || (year == 1926 && month == 12 && day <= 24)) {\n            printf(\"taisho %d %d %d\\n\", year - 1912 + 1, month, day);\n        }\n        else if (year < 1989 || (year == 1989 && month == 1 && day <= 7)) {\n            printf(\"showa %d %d %d\\n\", year - 1926 + 1, month, day);\n        }\n        else {\n            printf(\"heisei %d %d %d\\n\", year - 1989 + 1, month, day);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int year, month, day; while (scanf(\"%d %d %d\", &year, &month, &day) != EOF) { if (year < 1868 || (year == 1868 && month < 9) || (year == 1868 && month == 9 && day < 8)) { printf(\"pre-meiji\\n\"); } else if (year < 1912 || (year == 1912 && month < 7) || (year ==  printf(\"meiji %d  else if (year  day <=  1, month, day); } else if (year < 1989 || (year == 1989 && month == 1 && day <= 7)) { printf(\"showa %d %d %d\\n\", year - 1926 + 1, month, day); } else { printf(\"heisei %d %d %d\\n\", year - 1989 + 1, month, day); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){  && c<8){ printf(\"pre-meiji\\n\"); d=1;  } else if(a==1912){ if(b<7){ printf(\"meiji \"); a=a-1868+1;  t=1; } } } } if(a<=1926 && t==0){ if(a!=1926){ printf(\"taisyo \"); a=a-1912+1; d=0; t=1; } else if(a==1926){ if(b<12){ printf(\"taisyo \"); a=a-1912+1; d=0; t=1; } else if(b==12){ if(c<25){ printf(\"taisyo \"); a=a-1912+1; d=0; t=1; } if(c>=25){ printf(\"showa \"); a=a-1926+1; d=0; t=1; } } } } if(a<=1989 && t==0){ if(a!=1989){ printf(\"showa \"); a=a-1926+1; d=0; t=1; } else if(a==1989){ if(b==1){ if(c<8){ printf(\"showa \"); a=a-1926+1; d=0; t=1; } } } } if(a>=1989 && t==0){ if(a!=1989){ printf(\"heisei \"); a=a-1989+1;  else if(b==1){ if(c>=8){ printf(\"heisei \"); a=a-1989+1; d=0; } } } } if(d==0){ printf(\"%d %d %d\\n\",a,b,c); } } return (0); }"], "original_ll": -0.720138430595398, "sampled_ll": -0.6122177839279175, "all_perturbed_sampled_ll": [-1.2493150234222412], "all_perturbed_original_ll": [-1.1408179998397827], "perturbed_sampled_ll": -1.2493150234222412, "perturbed_original_ll": -1.1408179998397827, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nclass Main\n{\n    public static void main(String args[])throws IOException\n    {\n\tBufferedReader input=new BufferedReader(new InputStreamReader(System.in));\n\tString str;\n\twhile((str=input.readLine())!=null)\n\t    {\n\t\tString str_ary[]=str.split(\" \");\n\t\tint x[]=new int[3];\n\t\tfor(int i=0;i<3;i++)\n\t\t    {\n\t\t\tx[i]=Integer.parseInt(str_ary[i]);\n\t\t\t\n\t\t    }\n\t\tif((x[0]<1868) \n\t\t   || ((x[0]==1868) && (x[1]<9))\n\t\t   || ((x[0]==1868) && (x[1]==9) && (x[2]<8)))System.out.println(\"pre-meiji\");\n\t\tif(((1869<=x[0]) && (x[0]<=1911))\n\t\t   || (x[0]==1868) && (9<=x[1]) && (8<=x[2])\n\t\t   \n\t\t   || (x[0]==1912 && x[1]==7 && x[2]<=29)\n\t\t   || (x[0]==1912) && x[1]<=7)System.out.println(\"meiji\");\n\t\tif(((1913<=x[0]) && (x[0]<=1925))\n\t\t   || ((x[0]==1912) && (7<=x[1]) && (30<=x[2]))\n\t\t   || (x[0]==1926 && x[1]==12 && x[2]<=24)\n\t\t   || ((x[0]==1912) && (7<=x[1]))\n\t\t   )System.out.println(\"taisho\");\n\t\tif(((1927<=x[0]) && (x[0]<=1988))\n\t\t   || ((x[0]==1926) && (12==x[1]) && (25<=x[2]))\n\t\t   || ((x[0]==1989) && (x[1]==1) && (x[2]<=7))\n\t\t   \n\t\t   \n)System.out.println(\"showa\");\n\t\tif((1989==x[0]) && (1<=x[1]) && (8<=x[2])\n\t\t   || 1990<=x[0]\n\t\t   || (1989==x[0]) && (1<x[1]))System.out.println(\"heisei\");\n\t    }\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int year = sc.nextInt();\n            int month = sc.nextInt();\n            int day = sc.nextInt();\n            \n            // Convert to comparable format (YYYYMMDD)\n            int date = year * 10000 + month * 100 + day;\n            \n            // Define era boundaries\n            int meijiStart = 18680908;\n            int meijiEnd = 19120729;\n            int taishoStart = 19120730;\n            int taishoEnd = 19261224;\n            int showaStart = 19261225;\n            int showaEnd = 19890107;\n            int heiseiStart = 19890108;\n            \n            if (date < meijiStart) {\n                System.out.println(\"pre-meiji\");\n            } else if (date >= meijiStart && date <= meijiEnd) {\n                int eraYear = year - 1868 + 1;\n                System.out.println(\"meiji \" + eraYear + \" \" + month + \" \" + day);\n            } else if (date >= taishoStart && date <= taishoEnd) {\n                int eraYear = year - 1912 + 1;\n                System.out.println(\"taisho \" + eraYear + \" \" + month + \" \" + day);\n            } else if (date >= showaStart && date <= showaEnd) {\n                int eraYear = year - 1926 + 1;\n                System.out.println(\"showa \" + eraYear + \" \" + month + \" \" + day);\n            } else if (date >= heiseiStart) {\n                int eraYear = year - 1989 + 1;\n                System.out.println(\"heisei \" + eraYear + \" \" + month + \" \" + day);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int year = sc.nextInt(); int month = sc.nextInt(); int day = sc.nextInt(); // Convert to comparable format (YYYYMMDD) int date = year * 10000 +  meijiStart  int taishoEnd = 19261224; int showaStart = 19261225; int showaEnd = 19890107; int heiseiStart = 19890108; if (date < meijiStart) { System.out.println(\"pre-meiji\"); } else if (date >= meijiStart && date <= meijiEnd) { int eraYear = year - 1868 + 1; System.out.println(\"meiji \" + eraYear + \" \" + month + \" \" + day); } else if (date >= taishoStart && date <= taishoEnd) { int eraYear = year - 1912 + 1; System.out.println(\"taisho \"  + day); } else if (date >= showaStart && date <= showaEnd) {  + eraYear + \" \" + month + \" \" + day); } else if (date >= heiseiStart) { int eraYear =  } } sc.close(); } }"], "perturbed_original": ["import java.io.*; class Main { public static  str; while((str=input.readLine())!=null) { String str_ary[]=str.split(\" \"); int x[]=new int[3]; for(int i=0;i<3;i++) { x[i]=Integer.parseInt(str_ary[i]); } if((x[0]<1868) || ((x[0]==1868) && (x[1]<9)) || ((x[0]==1868) && (x[1]==9) && (x[2]<8)))System.out.println(\"pre-meiji\"); if(((1869<=x[0]) && (x[0]<=1911)) || (x[0]==1868) && (9<=x[1]) && (8<=x[2]) || (x[0]==1912 && x[1]==7 && x[2]<=29) || (x[0]==1912) && x[1]<=7)System.out.println(\"meiji\"); if(((1913<=x[0]) && (x[0]<=1925)) || ((x[0]==1912) && (7<=x[1])  && (7<=x[1])) )System.out.println(\"taisho\"); if(((1927<=x[0])  && (x[1]==1) && (x[2]<=7)) )System.out.println(\"showa\"); if((1989==x[0]) && (1<=x[1]) && (8<=x[2]) || 1990<=x[0] || (1989==x[0]) && (1<x[1]))System.out.println(\"heisei\"); } } }"], "original_ll": -1.0417203903198242, "sampled_ll": -0.5819061994552612, "all_perturbed_sampled_ll": [-1.2995071411132812], "all_perturbed_original_ll": [-1.3029097318649292], "perturbed_sampled_ll": -1.2995071411132812, "perturbed_original_ll": -1.3029097318649292, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from datetime import datetime\ndef era(f):\n    meiji_st  = datetime(1868, 9, 8)\n    taisho_st = datetime(1912, 7,30)\n    showa_st  = datetime(1926,12,25)\n    heisei_st = datetime(1989, 1, 8)\n\n    y,m,d = f\n    dt = datetime(y,m,d)\n    if dt > heisei_st:\n        ret = \"heisei %d %d %d\" % (dt.year - heisei_st.year+1,dt.month,dt.day) \n    elif dt > showa_st:\n        ret = \"showa %d %d %d\" % (dt.year - showa_st.year+1,dt.month,dt.day) \n    elif dt > taisho_st:\n        ret = \"taisho %d %d %d\" % (dt.year - taisho_st.year+1,dt.month,dt.day) \n    elif dt > meiji_st:\n        ret = \"meiji %d %d %d\" % (dt.year - meiji_st.year+1,dt.month,dt.day) \n    else:\n       ret = \"pre-meiji\"\n\n    return(ret)\n\nwhile True:\n    try:\n        f = map(int, input().strip().split())\n        print(era(f))\n    except EOFError:\n        break", "sampled": "import sys\n\ndef to_wareki(year, month, day):\n    # Convert date to comparable format (YYYYMMDD)\n    date = year * 10000 + month * 100 + day\n    \n    # Era boundaries in YYYYMMDD format\n    meiji_start = 18680908\n    meiji_end = 19120729\n    taisho_start = 19120730\n    taisho_end = 19261224\n    showa_start = 19261225\n    showa_end = 19890107\n    heisei_start = 19890108\n    \n    if date < meiji_start:\n        return \"pre-meiji\"\n    elif date <= meiji_end:\n        wareki_year = year - 1868 + 1\n        return f\"meiji {wareki_year} {month} {day}\"\n    elif date <= taisho_end:\n        wareki_year = year - 1912 + 1\n        return f\"taisho {wareki_year} {month} {day}\"\n    elif date <= showa_end:\n        wareki_year = year - 1926 + 1\n        return f\"showa {wareki_year} {month} {day}\"\n    else:\n        wareki_year = year - 1989 + 1\n        return f\"heisei {wareki_year} {month} {day}\"\n\nfor line in sys.stdin:\n    parts = line.strip().split()\n    year = int(parts[0])\n    month = int(parts[1])\n    day = int(parts[2])\n    print(to_wareki(year, month, day))\n", "perturbed_sampled": ["import sys def to_wareki(year, month, day): # Convert date to comparable format (YYYYMMDD) date = year * 10000 + month * 100 + day # Era boundaries in YYYYMMDD format meiji_start = 18680908 meiji_end = 19120729 taisho_start = 19120730 taisho_end = 19261224 showa_start = 19261225 showa_end = 19890107 heisei_start = 19890108 if date < meiji_start: return \"pre-meiji\"  1 return f\"meiji {wareki_year} {month} {day}\" elif date <= taisho_end: wareki_year = year - 1912 + 1 return f\"taisho {wareki_year} {month} {day}\" elif date <= showa_end: wareki_year = year - 1926  = int(parts[0]) month = int(parts[1]) day = int(parts[2]) print(to_wareki(year, month, day))"], "perturbed_original": ["from datetime import datetime def era(f): meiji_st = datetime(1868, 9, 8) taisho_st = datetime(1912, 7,30) showa_st = datetime(1926,12,25) heisei_st = datetime(1989, 1, 8) y,m,d = f dt = datetime(y,m,d) if dt > heisei_st: ret =  > showa_st: ret = \"showa %d %d %d\" % (dt.year  %d %d\" % (dt.year - taisho_st.year+1,dt.month,dt.day) elif dt > meiji_st: ret = \"meiji %d %d %d\" % (dt.year - meiji_st.year+1,dt.month,dt.day) else: ret =  except EOFError: break"], "original_ll": -0.9097607135772705, "sampled_ll": -0.7724727988243103, "all_perturbed_sampled_ll": [-1.5604758262634277], "all_perturbed_original_ll": [-1.8322592973709106], "perturbed_sampled_ll": -1.5604758262634277, "perturbed_original_ll": -1.8322592973709106, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<stdlib.h>\nint main(void){\n\tint n,m,i,j;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=j=0;i++<n;j%=i){j+=m;}\n\t\tprintf(\"%d\\n\",j+1);\n\t}\n\treturn 0; \n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n, m;\n    \n    while(1) {\n        scanf(\"%d %d\", &n, &m);\n        if(n == 0 && m == 0) break;\n        \n        int people[1000];\n        for(int i = 0; i < n; i++) {\n            people[i] = i + 1;\n        }\n        \n        int count = n;\n        int pos = n - 1;\n        \n        while(count > 1) {\n            int steps = m % count;\n            if(steps == 0) steps = count;\n            \n            pos = (pos + steps) % count;\n            \n            for(int i = pos; i < count - 1; i++) {\n                people[i] = people[i + 1];\n            }\n            count--;\n            \n            if(count > 0) {\n                pos = pos % count;\n            }\n        }\n        \n        printf(\"%d\\n\", people[0]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int ; i++) {<extra_id_15>p . foo) }<extra_id_16>(pm)<extra_id_17>} printf(\"%d\\n\", &m); if(n == 0 && m == 0) break; int people[1000]; for(int i = 0; i < n; i++) { people[i] = i + 1; } int count = n; int pos = n - 1; while(count > 1) { int steps = m % count; if(steps == 0) steps = count; pos = (pos + steps) % count; for(int i = pos; i <  % count; } } printf(\"%d\\n\", people[0]); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<stdlib.h> int main(void){ int n,m,i,j; while(scanf(\"%d\",&n)!=EOF){ scanf(\"%d\",&m); for(i=j=0;i++<n;j%=i){j+=m;} printf(\"%d\\n\",j+1); } return 0; }"], "original_ll": -1.532901644706726, "sampled_ll": -0.7276737689971924, "all_perturbed_sampled_ll": [-2.226576328277588], "all_perturbed_original_ll": [-1.5774314403533936], "perturbed_sampled_ll": -2.226576328277588, "perturbed_original_ll": -1.5774314403533936, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main ( String[] args ) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tArrayList<Integer> List;\n\t\twhile ( true ) {\n\t\t\tint remove = 0;\n\t\t\tList = new ArrayList<Integer>();\n\t\t\tint size = sc.nextInt();\n\t\t\tint space = sc.nextInt();\n\t\t\tif ( size == 0 && space == 0 ) break;\n\t\t\tspace--;\n\t\t\tfor ( int i = 1; i <= size; i++ )\n\t\t\t\tList.add(i);\n\t\t\twhile ( List.size() != 1 ) {\n\t\t\t\tremove += space;\n\t\t\t\twhile ( remove >= List.size() )\n\t\t\t\t\tremove -= List.size();\n\t\t\t\tList.remove(remove);\n\t\t\t}\n\t\t\tSystem.out.println(List.get(0));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) {\n                break;\n            }\n            \n            ArrayList<Integer> people = new ArrayList<>();\n            for (int i = 1; i <= n; i++) {\n                people.add(i);\n            }\n            \n            int currentIndex = 0;\n            \n            while (people.size() > 1) {\n                currentIndex = (currentIndex + m - 1) % people.size();\n                people.remove(currentIndex);\n                if (currentIndex == people.size() && people.size() > 0) {\n                    currentIndex = 0;\n                }\n            }\n            \n            System.out.println(people.get(0));\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  = new Scanner(System.in); while (true) { int n = sc.nextInt(); int m = sc.nextInt(); if (n == 0 && m == 0) { break; } ArrayList<Integer> people = new ArrayList<>(); for (int i = 1; i <= n; i++) { people.add(i); } int currentIndex  + m - 1) % people.size(); people.remove(currentIndex); if (currentIndex == people.size() && people.size() > 0) { currentIndex = 0; } } System.out.println(people.get(0)); } sc.close(); } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main { public static void main ( String[] args ) { Scanner sc = new Scanner(System.in); ArrayList<Integer> List; while ( true ) { int remove = 0; List = new ArrayList<Integer>(); int size = sc.nextInt(); int space = sc.nextInt();  break; space--; for ( int i = 1; i <= size; i++ ) List.add(i); while ( List.size() != 1 ) {  -= List.size(); List.remove(remove); } System.out.println(List.get(0)); } } }"], "original_ll": -0.8894232511520386, "sampled_ll": -0.5209279656410217, "all_perturbed_sampled_ll": [-1.2551276683807373], "all_perturbed_original_ll": [-1.4438281059265137], "perturbed_sampled_ll": -1.2551276683807373, "perturbed_original_ll": -1.4438281059265137, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n  n,m=map(int,raw_input().split())\n  if n==0==m:break\n  p=0\n  for i in range(2,n+1):p=(p+m)%i\n  print p+1", "sampled": "def find_winner(n, m):\n    people = list(range(1, n + 1))\n    current = 0\n    \n    while len(people) > 1:\n        current = (current + m - 1) % len(people)\n        people.pop(current)\n        if current == len(people) and len(people) > 0:\n            current = 0\n    \n    return people[0]\n\nwhile True:\n    n, m = map(int, input().split())\n    if n == 0 and m == 0:\n        break\n    print(find_winner(n, m))\n", "perturbed_sampled": ["def find_winner(n, m): people = list(range(1, n + 1)) current = 0 while len(people) > 1: current  current == len(people) and len(people) > 0: current = 0 return people[0] while True: n, m = map(int, input().split()) if n == 0 and m == 0: break print(find_winner(n, m))"], "perturbed_original": ["while 1: n,m=map(int,raw_input().split()) if n==0==m:break p=0 for i in range(2,n+1):p=(p+m)%i print p+1"], "original_ll": -1.485678791999817, "sampled_ll": -0.754582941532135, "all_perturbed_sampled_ll": [-1.537044644355774], "all_perturbed_original_ll": [-1.9635155200958252], "perturbed_sampled_ll": -1.537044644355774, "perturbed_original_ll": -1.9635155200958252, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(int argc,char* argv[]){\n  int i;\n  int graph[101];\n\n  for(;;){\n    int from = -1,to = -1,odd_num = 0;\n\n    for(i = 1; i <= 100; i++){\n      graph[i] = -1;\n    }\n\n    while(scanf(\"%d %d\",&from,&to) != EOF){\n      if(from == 0 && to == 0){\n\tbreak;\n      }else{\n\tgraph[to] = (graph[to] == -1) ? 1 : graph[to]+1;\n\tgraph[from] = (graph[from] == -1) ? 1 : graph[from]+1;\n      }\n    }\n\n    if(from != 0 || to != 0){\n      break;\n    }\n\n    for(i = 1; i <= 100; i++){\n      if(graph[i] == -1){break;}\n      if(graph[i]%2 == 1){odd_num++;}\n    }\n\n    if(odd_num == 0 || odd_num == 2){\n      printf(\"OK\\n\");\n    }else{\n      printf(\"NG\\n\");\n    }\n  }\n\n  return 0;\n  \n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAXN 105\n\nint adj[MAXN][MAXN];\nint n;\nint visited[MAXN];\nint path[MAXN];\nint pathlen;\nint found;\n\nvoid dfs(int u, int goal) {\n    if (found) return;\n    if (u == goal) {\n        found = 1;\n        return;\n    }\n    \n    for (int v = 1; v <= n; v++) {\n        if (adj[u][v] > 0 && !visited[v]) {\n            visited[v] = 1;\n            path[pathlen++] = v;\n            \n            for (int i = 0; i < adj[u][v]; i++) {\n                dfs(v, goal);\n                if (found) return;\n            }\n            \n            pathlen--;\n            visited[v] = 0;\n        }\n    }\n}\n\nint canReach(int start, int goal, int avoid) {\n    memset(visited, 0, sizeof(visited));\n    visited[start] = 1;\n    visited[avoid] = 1;\n    \n    pathlen = 0;\n    path[pathlen++] = start;\n    found = 0;\n    \n    dfs(start, goal);\n    return found;\n}\n\nint main() {\n    int a, b;\n    \n    while (1) {\n        memset(adj, 0, sizeof(adj));\n        n = 0;\n        \n        int first = 1;\n        while (1) {\n            if (scanf(\"%d %d\", &a, &b) != 2) return 0;\n            if (a == 0 && b == 0) break;\n            \n            adj[a][b]++;\n            adj[b][a]++;\n            \n            if (a > n) n = a;\n            if (b > n) n = b;\n            first = 0;\n        }\n        \n        if (first) break;\n        \n        memset(visited, 0, sizeof(visited));\n        visited[1] = 1;\n        pathlen = 0;\n        path[pathlen++] = 1;\n        found = 0;\n        \n        dfs(1, 2);\n        \n        if (!found) {\n            printf(\"NG\\n\");\n            continue;\n        }\n        \n        int ok = 1;\n        for (int i = 1; i < pathlen - 1; i++) {\n            int v = path[i];\n            if (!canReach(1, v, 2) || !canReach(v, 2, 1)) {\n                ok = 0;\n                break;\n            }\n        }\n        \n        if (ok) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAXN 105 int adj[MAXN][MAXN]; int n; int visited[MAXN]; int path[MAXN]; int pathlen; int found; void dfs(int u, int goal) { if (found) return; if (u == goal) { found = 1; return; } for (int v = 1; v <= n; v++) { if (adj[u][v] > 0 && !visited[v]) { visited[v] = 1; path[pathlen++] = v; for (int i = 0; i  pathlen--; visited[v] = 0; } } } int canReach(int start, int goal, int avoid) {  = 0; path[pathlen++] = start; found = 0; dfs(start, goal); return found; } int main() { int a, b; while (1) { memset(adj, 0, sizeof(adj)); n = 0; int first = 1; while (1) { if  == 0 && b == 0) break; adj[a][b]++; adj[b][a]++; if (a  = b; first = 0; } if (first) break; memset(visited, 0, sizeof(visited)); visited[1] = 1; pathlen = 0; path[pathlen++] =  = 1; i < pathlen - 1; i++) { int v =  ok = 0; break; } } if (ok) { printf(\"OK\\n\"); } else { printf(\"NG\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int  = -1,to = -1,odd_num = 0; for(i = 1; i <= 100; i++){ graph[i] = -1; } while(scanf(\"%d %d\",&from,&to) != EOF){ if(from == 0 && to == 0){ break; }else{ graph[to] = (graph[to] == -1) ? 1 : graph[to]+1; graph[from] = (graph[from] == -1) ?  != 0){ break; } for(i = 1; i <= 100; i++){ if(graph[i] == -1){break;} if(graph[i]%2 == 1){odd_num++;} } if(odd_num ==  return 0; }"], "original_ll": -0.9215033650398254, "sampled_ll": -0.5667259097099304, "all_perturbed_sampled_ll": [-1.186896800994873], "all_perturbed_original_ll": [-1.5715688467025757], "perturbed_sampled_ll": -1.186896800994873, "perturbed_original_ll": -1.5715688467025757, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n/*answer*/\n    int a, b;\n    int[] count;\n    int i, n;\n\n    count = new int[100];\n    for(;sc.hasNext();){\n      for(i = 0;i < 100;i++)count[i] = 0;\n      n = 0;\n      for(;;){\n        a = sc.nextInt();\n        b = sc.nextInt();\n        if(a == 0 && b == 0)break;\n        count[a - 1]++; count[b - 1]++;\n      }\n\n      for(i = 0;i < 2;i++)if(count[i] % 2 == 0)n = 1;\n      for(i = 2;i < 100;i++)if(count[i] % 2 != 0)n = 1;\n\n      if(n == 1)out.println(\"NG\");\n      else out.println(\"OK\");\n    }\n\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to;\n        int id;\n        Edge(int to, int id) {\n            this.to = to;\n            this.id = id;\n        }\n    }\n    \n    static List<List<Edge>> graph;\n    static int[] edgeCount;\n    static boolean[] visited;\n    static boolean[] edgeUsed;\n    static int start = 1, goal = 2;\n    static boolean found;\n    static List<Integer> path;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            Map<String, Integer> edges = new HashMap<>();\n            List<int[]> edgeList = new ArrayList<>();\n            Set<Integer> nodes = new HashSet<>();\n            \n            while (true) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                if (a == 0 && b == 0) break;\n                \n                nodes.add(a);\n                nodes.add(b);\n                edgeList.add(new int[]{a, b});\n                \n                String key = Math.min(a, b) + \"-\" + Math.max(a, b);\n                edges.put(key, edges.getOrDefault(key, 0) + 1);\n            }\n            \n            int maxNode = 0;\n            for (int node : nodes) {\n                maxNode = Math.max(maxNode, node);\n            }\n            \n            graph = new ArrayList<>();\n            for (int i = 0; i <= maxNode; i++) {\n                graph.add(new ArrayList<>());\n            }\n            \n            edgeCount = new int[edgeList.size()];\n            int edgeId = 0;\n            for (int[] edge : edgeList) {\n                int a = edge[0];\n                int b = edge[1];\n                graph.get(a).add(new Edge(b, edgeId));\n                graph.get(b).add(new Edge(a, edgeId));\n                edgeId++;\n            }\n            \n            visited = new boolean[maxNode + 1];\n            edgeUsed = new boolean[edgeList.size()];\n            found = false;\n            path = new ArrayList<>();\n            \n            dfs(start, new ArrayList<>());\n            \n            if (found) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NG\");\n            }\n        }\n        sc.close();\n    }\n    \n    static void dfs(int current, List<Integer> currentPath) {\n        if (found) return;\n        \n        if (current == goal) {\n            // Check if all edges are used exactly once\n            boolean allUsed = true;\n            for (boolean used : edgeUsed) {\n                if (!used) {\n                    allUsed = false;\n                    break;\n                }\n            }\n            if (allUsed) {\n                found = true;\n                path = new ArrayList<>(currentPath);\n            }\n            return;\n        }\n        \n        visited[current] = true;\n        currentPath.add(current);\n        \n        for (Edge edge : graph.get(current)) {\n            if (!edgeUsed[edge.id]) {\n                edgeUsed[edge.id] = true;\n                dfs(edge.to, currentPath);\n                edgeUsed[edge.id] = false;\n                if (found) return;\n            }\n        }\n        \n        currentPath.remove(currentPath.size() - 1);\n        visited[current] = false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Edge { int to; int id; Edge(int to, int id) { this.to = to; this.id = id; } } static List<List<Edge>> graph; static int[] edgeCount; static boolean[] visited; static boolean[] edgeUsed; static int start = 1, goal = 2; static boolean found; static List<Integer> path; public static void main(String[] args)  Integer> edges = new HashMap<>(); List<int[]> edgeList = new ArrayList<>(); Set<Integer> nodes = new HashSet<>(); while (true) { int a = sc.nextInt(); int b = sc.nextInt(); if (a == 0 && b == 0) break; nodes.add(a); nodes.add(b); edgeList.add(new  Math.max(a, b); edges.put(key, edges.getOrDefault(key, 0) + 1); } int maxNode = 0; for (int node : nodes) { maxNode = Math.max(maxNode, node); } graph = new ArrayList<>(); for (int i = 0; i <= maxNode; i++) {  { System.out.println(\"OK\"); } else { System.out.println(\"NG\"); } } sc.close(); } static void dfs(int current, List<Integer> currentPath) { if (found) return; if (current == goal) { // Check if all edges are used exactly once boolean allUsed = true; for (boolean used : edgeUsed) { if (!used) { allUsed = false; break; } } if (allUsed) { found = true; path =  (Edge edge : graph.get(current)) { if (!edgeUsed[edge.id]) { edgeUsed[edge.id] = true; dfs(edge.to, currentPath); edgeUsed[edge.id] = false; if (found) return; } } currentPath.remove(currentPath.size() - 1); visited[current] = false; } }"], "perturbed_original": ["public class Main{ public void run(java.io.InputStream in, java.io.PrintStream out){ java.util.Scanner sc = new java.util.Scanner(in); /*answer*/ int a, b; int[] count; int i, n; count  0; n = 0; for(;;){ a = sc.nextInt(); b = sc.nextInt(); if(a == 0 && b == 0)break; count[a - 1]++; count[b - 1]++; } for(i = 0;i < 2;i++)if(count[i] % 2  2 != 0)n = 1; if(n == 1)out.println(\"NG\"); else out.println(\"OK\"); } sc.close(); } public static void main(String[] args){ (new Main()).run(System.in, System.out); } }"], "original_ll": -1.04280686378479, "sampled_ll": -0.5282217860221863, "all_perturbed_sampled_ll": [-1.1396738290786743], "all_perturbed_original_ll": [-1.5302727222442627], "perturbed_sampled_ll": -1.1396738290786743, "perturbed_original_ll": -1.5302727222442627, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfrom collections import defaultdict\ndata_list = []\n\nfor line in sys.stdin:\n    data_list.append(list(map(int, line.split())))\n\ndef is_half_euler_graph(node_list):\n\n    for node in node_list:\n        odd_num_counter = 0\n        for dic_value in node.values():\n            if dic_value % 2 != 0:\n                odd_num_counter = odd_num_counter + 1\n\n        if odd_num_counter == 2:\n            print(\"OK\")\n        else :\n            print(\"NG\")\n\n\nif __name__ == '__main__' :\n    node_data_lists = []\n    tmp_list = []\n    count_lists = []\n    tmp_dic = {}\n    tmp_dic = defaultdict(int)\n\n    for i in range(0, len(data_list)):\n        if data_list[i][0] == 0 and data_list[i][1] == 0:\n            node_data_lists.append(tmp_list[:])\n            tmp_list.clear()\n        else :\n            tmp_list.append(data_list[i])\n\n    for node_data_list in node_data_lists :\n        tmp_dic.clear()\n        for i in range(0, len(node_data_list)):\n            tmp_dic[node_data_list[i][0]] += 1\n            tmp_dic[node_data_list[i][1]] += 1\n\n        count_lists.append(tmp_dic.copy())\n    is_half_euler_graph(count_lists)\n\n", "sampled": "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    datasets = []\n    current_edges = []\n    \n    for line in sys.stdin:\n        line = line.strip()\n        if not line:\n            continue\n        a, b = map(int, line.split())\n        if a == 0 and b == 0:\n            if current_edges:\n                datasets.append(current_edges)\n                current_edges = []\n        else:\n            current_edges.append((a, b))\n    \n    return datasets\n\ndef can_reach(graph, start, end, excluded_edge=None):\n    \"\"\"BFS to check if we can reach end from start, optionally excluding an edge\"\"\"\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                # Check if this edge should be excluded\n                if excluded_edge:\n                    edge = tuple(sorted([node, neighbor]))\n                    if edge == excluded_edge:\n                        continue\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\ndef check_conditions(edges):\n    # Build adjacency list (undirected graph)\n    graph = defaultdict(list)\n    edge_set = set()\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        edge_set.add(tuple(sorted([a, b])))\n    \n    # Condition 1: There must be a path from 1 to 2\n    if not can_reach(graph, 1, 2):\n        return False\n    \n    # Condition 2: Every road must be on some path from 1 to 2\n    for edge in edge_set:\n        a, b = edge\n        # Remove this edge temporarily and check if we can still reach 2 from 1\n        if not can_reach(graph, 1, 2, excluded_edge=edge):\n            # This edge is essential, so condition 2 is satisfied for this edge\n            continue\n        else:\n            # This edge is not essential, condition 2 fails\n            return False\n    \n    # Condition 3: Every intersection (except 1 and 2) must be on some path from 1 to 2\n    all_nodes = set()\n    for a, b in edges:\n        all_nodes.add(a)\n        all_nodes.add(b)\n    \n    for node in all_nodes:\n        if node == 1 or node == 2:\n            continue\n        \n        # Check if node is on some path from 1 to 2\n        # Node is on a path from 1 to 2 if:\n        # - we can reach node from 1, AND\n        # - we can reach 2 from node\n        if can_reach(graph, 1, node) and can_reach(graph, node, 2):\n            # Additionally, we need to check if removing this node disconnects 1 and 2\n            # But a simpler check: node is critical if there's no path from 1 to 2 avoiding it\n            \n            # For now, just check basic reachability\n            # Actually, we need to verify the node is on SOME path, not ALL paths\n            # If we can reach it from 1 and reach 2 from it, it's on some path\n            continue\n        else:\n            return False\n    \n    return True\n\ndef solve():\n    datasets = read_input()\n    \n    for edges in datasets:\n        if check_conditions(edges):\n            print(\"OK\")\n        else:\n            print(\"NG\")\n\nsolve()\n", "perturbed_sampled": ["import sys from collections import defaultdict, deque def read_input(): datasets = []  if not line: continue a, b = map(int, line.split()) if a == 0 and b == 0: if current_edges: datasets.append(current_edges) current_edges = [] else:  to check if we can reach end from start, optionally excluding an edge\"\"\" visited = set() queue = deque([start]) visited.add(start) while queue: node = queue.popleft() if node == end: return True for neighbor in graph[node]: if neighbor not in visited: # Check if this edge should be excluded if  visited.add(neighbor) queue.append(neighbor) return False def check_conditions(edges): # Build adjacency list (undirected graph) graph = defaultdict(list) edge_set = set()  # Condition 2: Every road must be on some path from 1 to 2  this edge temporarily and check if we can still reach 2 from 1 if not can_reach(graph, 1, 2, excluded_edge=edge): # This edge is essential, so condition 2 is satisfied for this edge continue else: # This edge is not essential, condition 2 fails return False # Condition 3: Every intersection  1 to 2 all_nodes = set() for a, b in edges: all_nodes.add(a) all_nodes.add(b) for node in all_nodes: if node == 1 or node == 2: continue # Check if node is on some path from 1 to 2 # Node is on a path from 1 to 2 if: # - we can reach node from 1, AND # - we can reach 2 from node if can_reach(graph, 1, node) and can_reach(graph, node, 2): # Additionally, we need to check if removing this node disconnects 1 and 2 # But a simpler check: node is critical if  For  and reach 2 from it, it's on some path continue else: return False return True def solve(): datasets = read_input() for edges in datasets: if check_conditions(edges): print(\"OK\") else: print(\"NG\") solve()"], "perturbed_original": ["import sys from collections import defaultdict data_list = [] for line in sys.stdin: data_list.append(list(map(int, line.split()))) def is_half_euler_graph(node_list): for node in node_list: odd_num_counter = 0 for dic_value in node.values(): if dic_value % 2 != 0: odd_num_counter  : print(\"NG\") if __name__ == '__main__' : node_data_lists = []  = defaultdict(int) for  == 0: node_data_lists.append(tmp_list[:]) tmp_list.clear() else : tmp_list.append(data_list[i]) for node_data_list in node_data_lists : tmp_dic.clear() for i in range(0, len(node_data_list)): tmp_dic[node_data_list[i][0]] += 1 tmp_dic[node_data_list[i][1]] += 1 count_lists.append(tmp_dic.copy()) is_half_euler_graph(count_lists)"], "original_ll": -1.1033661365509033, "sampled_ll": -1.0053069591522217, "all_perturbed_sampled_ll": [-1.961556077003479], "all_perturbed_original_ll": [-2.0498266220092773], "perturbed_sampled_ll": -1.961556077003479, "perturbed_original_ll": -2.0498266220092773, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "double*q,a[99],b;char s[9];main(){for(q=a;~scanf(\"%s\",s);getchar()<14&&printf(\"%f\\n\",*q)){!sscanf(s,\"%lf\",q+1)?b=*q--,*q=*s-47?*s-42?*s-45?*q+b:*q-b:*q*b:*q/b:*++q;}}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_STACK 1000\n\ndouble stack[MAX_STACK];\nint top = -1;\n\nvoid push(double val) {\n    stack[++top] = val;\n}\n\ndouble pop() {\n    return stack[top--];\n}\n\nint is_operator(char *token) {\n    return (strlen(token) == 1 && (token[0] == '+' || token[0] == '-' || \n            token[0] == '*' || token[0] == '/'));\n}\n\ndouble calculate(double a, double b, char op) {\n    switch(op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return a / b;\n    }\n    return 0;\n}\n\nint main() {\n    char line[1000];\n    \n    while(fgets(line, sizeof(line), stdin)) {\n        if(line[0] == '\\n') break;\n        \n        top = -1;\n        char *token = strtok(line, \" \\n\");\n        \n        while(token != NULL) {\n            if(is_operator(token)) {\n                double b = pop();\n                double a = pop();\n                double result = calculate(a, b, token[0]);\n                push(result);\n            } else {\n                double num = atof(token);\n                push(num);\n            }\n            token = strtok(NULL, \" \\n\");\n        }\n        \n        printf(\"%f\\n\", stack[0]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> #include <ctype.h> #define MAX_STACK 1000 double stack[MAX_STACK]; int top = -1; void push(double val) { stack[++top] = val; } double pop() { return stack[top--]; } int is_operator(char *token) { return (strlen(token) == 1 && (token[0] == '+' || token[0] == '-' || token[0] == '*' || <extra_id_2>= a; int<extra_id_3>0; } printf(\"%.2f\\n\", stack[top]); }<extra_id_4>#include <stdio.h> #include <stdlib.h><extra_id_5><stdlib.h> #include <ctype.h> #include<extra_id_6>#include <stdlib.h><extra_id_7>int i)<extra_id_8>//int<extra_id_9>=<extra_id_10>//System.out.println(\"1 op) { switch(op) { case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': return a / b; } return 0; } int main() { char line[1000]; while(fgets(line, sizeof(line), stdin)) { if(line[0] == '\\n') break;  != NULL) { if(is_operator(token)) { double  = atof(token); push(num); } token = strtok(NULL, \" \\n\"); } printf(\"%f\\n\", stack[0]); } return 0; }"], "perturbed_original": ["double*q,a[99],b;char s[9];main(){for(q=a;~scanf(\"%s\",s);getchar()<14&&printf(\"%f\\n\",*q)){!sscanf(s,\"%lf\",q+1)?b=*q--,*q=*s-47?*s-42?*s-45?*q+b:*q-b:*q*b:*q/b:*++q;}}"], "original_ll": -3.0488882064819336, "sampled_ll": -0.4858161509037018, "all_perturbed_sampled_ll": [-1.5444047451019287], "all_perturbed_original_ll": [-3.0488882064819336], "perturbed_sampled_ll": -1.5444047451019287, "perturbed_original_ll": -3.0488882064819336, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc;\n\n\tstatic final int INF=1<<28;\n\tstatic final double EPS=1e-9;\n\n\tvoid run(){\n\t\tsc=new Scanner(System.in);\n\t\tfor(; sc.hasNext();){\n\t\t\tScanner c=new Scanner(sc.nextLine());\n\t\t\tLinkedList<Double> stack=new LinkedList<Double>();\n\t\t\tfor(; c.hasNext();){\n\t\t\t\tString s=c.next();\n\t\t\t\tif(Character.isDigit(s.charAt(0))){\n\t\t\t\t\tstack.addFirst(Double.parseDouble(s));\n\t\t\t\t}else{\n\t\t\t\t\tdouble d2=stack.removeFirst();\n\t\t\t\t\tdouble d1=stack.removeFirst();\n\t\t\t\t\tdouble d=0;\n//\t\t\t\t\tdouble d1=0,d2=0,d=0;\n\t\t\t\t\tswitch(s.charAt(0)){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\td=d1+d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\td=d1-d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\td=d1*d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\td=d1/d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstack.addFirst(d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble ans=stack.removeFirst();\n\t\t\tprintln(ans+\"\");\n\t\t}\n\t\tsc.close();\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line == null || line.trim().isEmpty()) {\n                break;\n            }\n            \n            String[] tokens = line.trim().split(\"\\\\s+\");\n            Stack<Double> stack = new Stack<>();\n            \n            for (String token : tokens) {\n                if (token.equals(\"+\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a + b);\n                } else if (token.equals(\"-\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a - b);\n                } else if (token.equals(\"*\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a * b);\n                } else if (token.equals(\"/\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a / b);\n                } else {\n                    stack.push(Double.parseDouble(token));\n                }\n            }\n            \n            System.out.printf(\"%.6f%n\", stack.pop());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String line = sc.nextLine(); if (line == null || line.trim().isEmpty()) { break; } String[] tokens = line.trim().split(\"\\\\s+\"); Stack<Double> stack = new Stack<>(); for (String token : tokens) { if (token.equals(\"+\")) { double b = stack.pop(); double a = stack.pop(); stack.push(a + b);  a = stack.pop(); stack.push(a - b); } else if (token.equals(\"*\")) {  b); } else if (token.equals(\"/\")) { double b = stack.pop(); double a = stack.pop(); stack.push(a  } sc.close(); } }"], "perturbed_original": ["import java.util.*; import  java.util.Arrays.*; public class Main{ Scanner sc; static final int INF=1<<28; static final double EPS=1e-9; void run(){ sc=new Scanner(System.in); for(; sc.hasNext();){ Scanner c=new Scanner(sc.nextLine());  double d2=stack.removeFirst(); double d1=stack.removeFirst(); double d=0; // double d1=0,d2=0,d=0; switch(s.charAt(0)){ case '+': d=d1+d2; break; case '-': d=d1-d2; break; case '*': d=d1*d2; break; case '/': d=d1/d2; break; } stack.addFirst(d); } } double ans=stack.removeFirst(); println(ans+\"\"); }  System.out.println(s); } public static void main(String[] args){ new Main().run(); } }"], "original_ll": -0.8057289123535156, "sampled_ll": -0.3060522675514221, "all_perturbed_sampled_ll": [-1.0264804363250732], "all_perturbed_original_ll": [-1.3977357149124146], "perturbed_sampled_ll": -1.0264804363250732, "perturbed_original_ll": -1.3977357149124146, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor l in sys.stdin:\n  t=l.split()\n  l=[]\n  for i in t:\n    try:\n      j=int(i)\n      l.append(j)\n    except:\n      b=l.pop()\n      a=l.pop()\n      l.append(eval(\"a\"+i+\"b\"))\n  print(\"{:.6f}\".format(l[0]))\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    tokens = line.strip().split()\n    stack = []\n    \n    for token in tokens:\n        if token in ['+', '-', '*', '/']:\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+':\n                result = a + b\n            elif token == '-':\n                result = a - b\n            elif token == '*':\n                result = a * b\n            elif token == '/':\n                result = a / b\n            stack.append(result)\n        else:\n            stack.append(float(token))\n    \n    print(f\"{stack[0]:.6f}\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: tokens = line.strip().split()  ['+', '-', '*', '/']: b = stack.pop() a = stack.pop() if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a  b stack.append(result) else: stack.append(float(token)) print(f\"{stack[0]:.6f}\")"], "perturbed_original": ["import sys for l in sys.stdin: t=l.split() l=[] for i in t: try: j=int(i) l.append(j) except: b=l.pop() a=l.pop() l.append(eval(\"a\"+i+\"b\")) print(\"{:.6f}\".format(l[0]))"], "original_ll": -1.5558589696884155, "sampled_ll": -0.49571919441223145, "all_perturbed_sampled_ll": [-1.6652508974075317], "all_perturbed_original_ll": [-1.9678053855895996], "perturbed_sampled_ll": -1.6652508974075317, "perturbed_original_ll": -1.9678053855895996, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main()\n{\n  unsigned char *a = \"\\n ',-.?ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  unsigned char *b[] = {\n    \"101\",\"101\",\"000000\",\"000011\",\"10010001\",\"010001\",\"000001\",\"100101\",\n    \"10011010\",\"0101\",\"0001\",\"110\",\"01001\",\"10011011\",\"010000\",\"0111\",\n    \"10011000\",\"0110\",\"00100\",\"10011001\",\"10011110\",\"00101\",\"111\",\n    \"10011111\",\"1000\",\"00110\",\"00111\",\"10011100\",\"10011101\",\"000010\",\n    \"10010010\",\"10010011\",\"10010000\"\n  };\n  unsigned char *c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?\";\n  unsigned char d[4096];\n  unsigned char *p;\n  int i,j,k;\n  i = 0;\n  while((k = getc(stdin)) != '\\n'){\n    j = 0;\n    while(*(a + j) != k) j++;\n    p = b[j];\n    while(*p) d[i++] = *p++;\n  }\n  while(i % 5) d[i++] = '0';\n  d[i] = '\\0';\n  i = 0;\n  while(d[i]) {\n    k = 0;\n    j = 4;\n    do {\n      k |= (d[i++] == '1') << j;\n    } while(j--);\n    putc(*(c + k),stdout);\n  }\n  putc('\\n',stdout);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char *encode1[] = {\n        \"101\", \"000000\", \"000011\", \"10010001\", \"010001\", \"000001\",\n        \"100101\", \"10011010\", \"0101\", \"0001\", \"110\", \"01001\",\n        \"10011011\", \"010000\", \"0111\", \"10011000\", \"0110\", \"00100\",\n        \"10011001\", \"10011110\", \"00101\", \"111\", \"10011111\", \"1000\",\n        \"00110\", \"00111\", \"10011100\", \"10011101\", \"000010\", \"10010010\",\n        \"10010011\", \"10010000\"\n    };\n    \n    char *decode2[] = {\n        \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\",\n        \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\",\n        \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\",\n        \"Y\", \"Z\", \" \", \".\", \",\", \"-\", \"'\", \"?\"\n    };\n    \n    char input[1024];\n    \n    while (fgets(input, sizeof(input), stdin)) {\n        int len = strlen(input);\n        if (len > 0 && input[len-1] == '\\n') {\n            input[len-1] = '\\0';\n            len--;\n        }\n        \n        char binary[10000] = \"\";\n        \n        for (int i = 0; i < len; i++) {\n            char c = input[i];\n            int idx = -1;\n            \n            if (c == ' ') idx = 0;\n            else if (c == '\\'') idx = 1;\n            else if (c == ',') idx = 2;\n            else if (c == '-') idx = 3;\n            else if (c == '.') idx = 4;\n            else if (c == '?') idx = 5;\n            else if (c >= 'A' && c <= 'Z') idx = c - 'A' + 6;\n            \n            if (idx >= 0) {\n                strcat(binary, encode1[idx]);\n            }\n        }\n        \n        int blen = strlen(binary);\n        if (blen % 5 != 0) {\n            int pad = 5 - (blen % 5);\n            for (int i = 0; i < pad; i++) {\n                strcat(binary, \"0\");\n            }\n            blen = strlen(binary);\n        }\n        \n        char result[10000] = \"\";\n        for (int i = 0; i < blen; i += 5) {\n            char chunk[6];\n            strncpy(chunk, binary + i, 5);\n            chunk[5] = '\\0';\n            \n            int val = 0;\n            for (int j = 0; j < 5; j++) {\n                val = val * 2 + (chunk[j] - '0');\n            }\n            \n            strcat(result, decode2[val]);\n        }\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char *encode1[] = { \"101\", \"000000\", \"000011\", \"10010001\", \"010001\", \"000001\", \"100101\", \"10011010\", \"0101\", \"0001\", \"110\", \"01001\", \"10011011\", \"010000\", \"0111\", \"10011000\", \"0110\", \"00100\", \"10011001\", \"10011110\", \"00101\", \"111\", \"10011111\", \"1000\", \"00110\", \"00111\",  {  \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \" \", \".\", \",\", \"-\", \"'\", \"?\" }; char input[1024]; while  > 0 && input[len-1] == '\\n') { input[len-1] = '\\0'; len--; } char binary[10000] = \"\"; for (int i = 0; i < len; i++) { char c = input[i]; int idx = -1; if (c  '\\'') idx = 1; else  == '-') idx = 3;  (c == '?') idx = 5; else if (c >= 'A' && c <= 'Z') idx = c - 'A' + 6; if (idx >= 0) { strcat(binary, encode1[idx]); } } int blen = strlen(binary); if (blen % 5 != 0) { int pad = 5 - (blen % 5); for (int i = 0; i < pad; i++) { strcat(binary, \"0\"); } blen = strlen(binary); } char result[10000] = \"\"; for (int i = 0; i < blen; i += 5) { char chunk[6]; strncpy(chunk, binary + i, 5); chunk[5] = '\\0'; int val = 0; for  = val  printf(\"%s\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main() { unsigned char *a = \"\\n  \"10010010\",\"10010011\",\"10010000\" }; unsigned char *c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?\"; unsigned char d[4096]; unsigned char *p; int i,j,k; i = 0; while((k = getc(stdin)) != '\\n'){ j = 0; while(*(a + j) != k) j++; p = b[j]; while(*p) d[i++] = *p++; } while(i % 5) d[i++] =  = 0; j =  } while(j--); putc(*(c + k),stdout); } putc('\\n',stdout); return 0; }"], "original_ll": -1.1476904153823853, "sampled_ll": -0.6183356046676636, "all_perturbed_sampled_ll": [-1.085972547531128], "all_perturbed_original_ll": [-1.9380683898925781], "perturbed_sampled_ll": -1.085972547531128, "perturbed_original_ll": -1.9380683898925781, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) throws java.io.IOException{\n        Scanner scan = new Scanner(System.in);\n        HashMap<Character,String> ep =new HashMap<Character,String>();\n        HashMap<String,Character> dp =new HashMap<String,Character>();\n\n\t\tep.put(' ', \"101\");\n\t\tep.put('\\'', \"000000\");\n\t\tep.put(',', \"000011\");\n\t\tep.put('-', \"10010001\");\n\t\tep.put('.', \"010001\");\n\t\tep.put('?', \"000001\");\n\t\tep.put('A', \"100101\");\n\t\tep.put('B', \"10011010\");\n\t\tep.put('C', \"0101\");\n\t\tep.put('D', \"0001\");\n\t\tep.put('E', \"110\");\n\t\tep.put('F', \"01001\");\n\t\tep.put('G', \"10011011\");\n\t\tep.put('H', \"010000\");\n\t\tep.put('I', \"0111\");\n\t\tep.put('J', \"10011000\");\n\t\tep.put('K', \"0110\");\n\t\tep.put('L', \"00100\");\n\t\tep.put('M', \"10011001\");\n\t\tep.put('N', \"10011110\");\n\t\tep.put('O', \"00101\");\n\t\tep.put('P', \"111\");\n\t\tep.put('Q', \"10011111\");\n\t\tep.put('R', \"1000\");\n\t\tep.put('S', \"00110\");\n\t\tep.put('T', \"00111\");\n\t\tep.put('U', \"10011100\");\n\t\tep.put('V', \"10011101\");\n\t\tep.put('W', \"000010\");\n\t\tep.put('X', \"10010010\");\n\t\tep.put('Y', \"10010011\");\n\t\tep.put('Z', \"10010000\");\n        \n\t\tdp.put(\"00000\", 'A');\n\t\tdp.put(\"00001\", 'B');\n\t\tdp.put(\"00010\", 'C');\n\t\tdp.put(\"00011\", 'D');\n\t\tdp.put(\"00100\", 'E');\n\t\tdp.put(\"00101\", 'F');\n\t\tdp.put(\"00110\", 'G');\n\t\tdp.put(\"00111\", 'H');\n\t\tdp.put(\"01000\", 'I');\n\t\tdp.put(\"01001\", 'J');\n\t\tdp.put(\"01010\", 'K');\n\t\tdp.put(\"01011\", 'L');\n\t\tdp.put(\"01100\", 'M');\n\t\tdp.put(\"01101\", 'N');\n\t\tdp.put(\"01110\", 'O');\n\t\tdp.put(\"01111\", 'P');\n\t\tdp.put(\"10000\", 'Q');\n\t\tdp.put(\"10001\", 'R');\n\t\tdp.put(\"10010\", 'S');\n\t\tdp.put(\"10011\", 'T');\n\t\tdp.put(\"10100\", 'U');\n\t\tdp.put(\"10101\", 'V');\n\t\tdp.put(\"10110\", 'W');\n\t\tdp.put(\"10111\", 'X');\n\t\tdp.put(\"11000\", 'Y');\n\t\tdp.put(\"11001\", 'Z');\n\t\tdp.put(\"11010\", ' ');\n\t\tdp.put(\"11011\", '.');\n\t\tdp.put(\"11100\", ',');\n\t\tdp.put(\"11101\", '-');\n\t\tdp.put(\"11110\", '\\'');\n\t\tdp.put(\"11111\", '?');\n        \n        while(scan.hasNext()){\n        \tchar [] line= scan.nextLine().toCharArray();\n        \tString tmp=\"\";\n        \tfor(int i=0;i<line.length;i++)\n        \t\ttmp+=ep.get(line[i]);\n        \tString [] splitedCode =new String[tmp.length()/5+1];\n        \tfor(int i=0;i<splitedCode.length;i++){\t\n        \t\tif(i==(splitedCode.length-1))\n        \t\t\tsplitedCode[i]=tmp.substring(5*i,tmp.length());\n        \t\telse splitedCode[i]=tmp.substring(5*i,5*i+5);\n        \t}\n        \t\tif(tmp.length()%5!=0)\n        \tfor(int i=0;i<(5-tmp.length()%5);i++)\n        \t\tsplitedCode[splitedCode.length-1]+=\"0\";\n        \t\n        \tStringBuilder sb = new StringBuilder();\n        \tfor(int i=0;i<splitedCode.length;i++)\n        \t\tsb.append(dp.get(splitedCode[i]));\n        \tSystem.out.println(sb);\n        }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Map<Character, String> encode1 = new HashMap<>();\n        encode1.put(' ', \"101\");\n        encode1.put('\\'', \"000000\");\n        encode1.put(',', \"000011\");\n        encode1.put('-', \"10010001\");\n        encode1.put('.', \"010001\");\n        encode1.put('?', \"000001\");\n        encode1.put('A', \"100101\");\n        encode1.put('B', \"10011010\");\n        encode1.put('C', \"0101\");\n        encode1.put('D', \"0001\");\n        encode1.put('E', \"110\");\n        encode1.put('F', \"01001\");\n        encode1.put('G', \"10011011\");\n        encode1.put('H', \"010000\");\n        encode1.put('I', \"0111\");\n        encode1.put('J', \"10011000\");\n        encode1.put('K', \"0110\");\n        encode1.put('L', \"00100\");\n        encode1.put('M', \"10011001\");\n        encode1.put('N', \"10011110\");\n        encode1.put('O', \"00101\");\n        encode1.put('P', \"111\");\n        encode1.put('Q', \"10011111\");\n        encode1.put('R', \"1000\");\n        encode1.put('S', \"00110\");\n        encode1.put('T', \"00111\");\n        encode1.put('U', \"10011100\");\n        encode1.put('V', \"10011101\");\n        encode1.put('W', \"000010\");\n        encode1.put('X', \"10010010\");\n        encode1.put('Y', \"10010011\");\n        encode1.put('Z', \"10010000\");\n        \n        Map<String, Character> encode2 = new HashMap<>();\n        encode2.put(\"00000\", 'A');\n        encode2.put(\"00001\", 'B');\n        encode2.put(\"00010\", 'C');\n        encode2.put(\"00011\", 'D');\n        encode2.put(\"00100\", 'E');\n        encode2.put(\"00101\", 'F');\n        encode2.put(\"00110\", 'G');\n        encode2.put(\"00111\", 'H');\n        encode2.put(\"01000\", 'I');\n        encode2.put(\"01001\", 'J');\n        encode2.put(\"01010\", 'K');\n        encode2.put(\"01011\", 'L');\n        encode2.put(\"01100\", 'M');\n        encode2.put(\"01101\", 'N');\n        encode2.put(\"01110\", 'O');\n        encode2.put(\"01111\", 'P');\n        encode2.put(\"10000\", 'Q');\n        encode2.put(\"10001\", 'R');\n        encode2.put(\"10010\", 'S');\n        encode2.put(\"10011\", 'T');\n        encode2.put(\"10100\", 'U');\n        encode2.put(\"10101\", 'V');\n        encode2.put(\"10110\", 'W');\n        encode2.put(\"10111\", 'X');\n        encode2.put(\"11000\", 'Y');\n        encode2.put(\"11001\", 'Z');\n        encode2.put(\"11010\", ' ');\n        encode2.put(\"11011\", '.');\n        encode2.put(\"11100\", ',');\n        encode2.put(\"11101\", '-');\n        encode2.put(\"11110\", '\\'');\n        encode2.put(\"11111\", '?');\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            \n            StringBuilder binary = new StringBuilder();\n            for (char c : line.toCharArray()) {\n                binary.append(encode1.get(c));\n            }\n            \n            while (binary.length() % 5 != 0) {\n                binary.append('0');\n            }\n            \n            StringBuilder result = new StringBuilder();\n            for (int i = 0; i < binary.length(); i += 5) {\n                String chunk = binary.substring(i, i + 5);\n                result.append(encode2.get(chunk));\n            }\n            \n            System.out.println(result.toString());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); Map<Character, String> encode1 = new HashMap<>(); encode1.put(' ', \"101\"); encode1.put('\\'', \"000000\"); encode1.put(',', \"000011\"); encode1.put('-', \"10010001\"); encode1.put('.', \"010001\"); encode1.put('?', \"000001\"); encode1.put('A', \"100101\"); encode1.put('B', \"10011010\"); encode1.put('C', \"0101\"); encode1.put('D', \"0001\"); encode1.put('E', \"110\"); encode1.put('F', \"01001\");   encode1.put('Q', \"10011111\"); encode1.put('R', \"1000\"); encode1.put('S', \"00110\"); encode1.put('T', \"00111\"); encode1.put('U', \"10011100\"); encode1.put('V', \"10011101\"); encode1.put('W', \"000010\"); encode1.put('X', \"10010010\"); encode1.put('Y', \"10010011\"); encode1.put('Z', \"10010000\"); Map<String,  'C'); encode2.put(\"00011\", 'D'); encode2.put(\"00100\", 'E'); encode2.put(\"00101\", 'F'); encode2.put(\"00110\", 'G'); encode2.put(\"00111\", 'H'); encode2.put(\"01000\", 'I'); encode2.put(\"01001\", 'J'); encode2.put(\"01010\", 'K'); encode2.put(\"01011\",  encode2.put(\"10101\", 'V'); encode2.put(\"10110\", 'W'); encode2.put(\"10111\", 'X'); encode2.put(\"11000\", 'Y'); encode2.put(\"11001\", 'Z'); encode2.put(\"11010\", ' '); encode2.put(\"11011\", '.'); encode2.put(\"11100\", ','); encode2.put(\"11101\", '-'); encode2.put(\"11110\", '\\''); encode2.put(\"11111\", '?'); while (sc.hasNextLine()) { String line = sc.nextLine(); StringBuilder binary = new StringBuilder(); for (char c : line.toCharArray()) { binary.append(encode1.get(c)); } while (binary.length() % 5 != 0) { binary.append('0'); } StringBuilder result = new StringBuilder(); for (int i =  = binary.substring(i, i + 5); result.append(encode2.get(chunk)); } System.out.println(result.toString()); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main  = new Scanner(System.in); HashMap<Character,String> ep =new HashMap<Character,String>(); HashMap<String,Character> dp =new HashMap<String,Character>(); ep.put(' ', \"101\"); ep.put('\\'', \"000000\"); ep.put(',', \"000011\"); ep.put('-', \"10010001\"); ep.put('.', \"010001\"); ep.put('?', \"000001\"); ep.put('A', \"100101\"); ep.put('B', \"10011010\"); ep.put('C', \"0101\"); ep.put('D', \"0001\"); ep.put('E', \"110\"); ep.put('F', \"01001\"); ep.put('G', \"10011011\"); ep.put('H', \"010000\"); ep.put('I', \"0111\"); ep.put('J', \"10011000\"); ep.put('K', \"0110\"); ep.put('L', \"00100\"); ep.put('M', \"10011001\"); ep.put('N', \"10011110\"); ep.put('O', \"00101\"); ep.put('P', \"111\"); ep.put('Q', \"10011111\"); ep.put('R', \"1000\"); ep.put('S', \"00110\"); ep.put('T', \"00111\"); ep.put('U', \"10011100\"); ep.put('V', \"10011101\"); ep.put('W', \"000010\"); ep.put('X', \"10010010\"); ep.put('Y', \"10010011\"); ep.put('Z', \"10010000\"); dp.put(\"00000\", 'A'); dp.put(\"00001\", 'B'); dp.put(\"00010\", 'C'); dp.put(\"00011\", 'D'); dp.put(\"00100\", 'E'); dp.put(\"00101\", 'F'); dp.put(\"00110\", 'G'); dp.put(\"00111\", 'H'); dp.put(\"01000\", 'I');  dp.put(\"01110\", 'O');  dp.put(\"10100\",  'Z'); dp.put(\"11010\", ' '); dp.put(\"11011\", '.');  [] line= scan.nextLine().toCharArray(); String tmp=\"\"; for(int i=0;i<line.length;i++) tmp+=ep.get(line[i]); String [] splitedCode =new String[tmp.length()/5+1]; for(int i=0;i<splitedCode.length;i++){ if(i==(splitedCode.length-1)) splitedCode[i]=tmp.substring(5*i,tmp.length()); else splitedCode[i]=tmp.substring(5*i,5*i+5); } if(tmp.length()%5!=0) for(int i=0;i<(5-tmp.length()%5);i++) splitedCode[splitedCode.length-1]+=\"0\"; StringBuilder sb = new StringBuilder(); for(int i=0;i<splitedCode.length;i++) sb.append(dp.get(splitedCode[i])); System.out.println(sb); } } }"], "original_ll": -0.5282508730888367, "sampled_ll": -0.3539580702781677, "all_perturbed_sampled_ll": [-0.7169904708862305], "all_perturbed_original_ll": [-0.7622899413108826], "perturbed_sampled_ll": -0.7169904708862305, "perturbed_original_ll": -0.7622899413108826, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nd={' ':'101',\"'\":'000000',',':'000011','-':'10010001','.':'010001','?':'000001','A':'100101','B':'10011010','C':'0101','D':'0001','E':'110',\n'F':'01001','G':'10011011','H':'010000','I':'0111','J':'10011000','K':'0110','L':'00100','M':'10011001','N':'10011110','O':'00101','P':'111',\n'Q':'10011111','R':'1000','S':'00110','T':'00111','U':'10011100','V':'10011101','W':'000010','X':'10010010','Y':'10010011','Z':'10010000'}\nfor e in sys.stdin:\n a=''.join(d[c]for c in e[:-1])\n a+='0'*(-len(a)%5)\n print(''.join(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?\"[int(a[i*5:i*5+5],2)]for i in range(len(a)//5)))\n", "sampled": "import sys\n\n# First encoding table (character to binary code)\nencode1 = {\n    ' ': '101',\n    \"'\": '000000',\n    ',': '000011',\n    '-': '10010001',\n    '.': '010001',\n    '?': '000001',\n    'A': '100101',\n    'B': '10011010',\n    'C': '0101',\n    'D': '0001',\n    'E': '110',\n    'F': '01001',\n    'G': '10011011',\n    'H': '010000',\n    'I': '0111',\n    'J': '10011000',\n    'K': '0110',\n    'L': '00100',\n    'M': '10011001',\n    'N': '10011110',\n    'O': '00101',\n    'P': '111',\n    'Q': '10011111',\n    'R': '1000',\n    'S': '00110',\n    'T': '00111',\n    'U': '10011100',\n    'V': '10011101',\n    'W': '000010',\n    'X': '10010010',\n    'Y': '10010011',\n    'Z': '10010000'\n}\n\n# Second encoding table (5-bit binary to character)\nencode2 = {\n    '00000': 'A',\n    '00001': 'B',\n    '00010': 'C',\n    '00011': 'D',\n    '00100': 'E',\n    '00101': 'F',\n    '00110': 'G',\n    '00111': 'H',\n    '01000': 'I',\n    '01001': 'J',\n    '01010': 'K',\n    '01011': 'L',\n    '01100': 'M',\n    '01101': 'N',\n    '01110': 'O',\n    '01111': 'P',\n    '10000': 'Q',\n    '10001': 'R',\n    '10010': 'S',\n    '10011': 'T',\n    '10100': 'U',\n    '10101': 'V',\n    '10110': 'W',\n    '10111': 'X',\n    '11000': 'Y',\n    '11001': 'Z',\n    '11010': ' ',\n    '11011': '.',\n    '11100': ',',\n    '11101': '-',\n    '11110': \"'\",\n    '11111': '?'\n}\n\nfor line in sys.stdin:\n    line = line.rstrip('\\n')\n    \n    # Step 1: Convert each character to its binary code\n    binary_string = ''.join(encode1[c] for c in line)\n    \n    # Step 2: Pad with zeros to make length multiple of 5\n    remainder = len(binary_string) % 5\n    if remainder != 0:\n        binary_string += '0' * (5 - remainder)\n    \n    # Step 3: Split into chunks of 5 and convert using second table\n    result = ''\n    for i in range(0, len(binary_string), 5):\n        chunk = binary_string[i:i+5]\n        result += encode2[chunk]\n    \n    print(result)\n", "perturbed_sampled": ["import sys #  ' ': '101', \"'\": '000000', ',': '000011', '-': '10010001', '.': '010001', '?': '000001', 'A': '100101', 'B':  '10011011', 'H': '010000', 'I': '0111', 'J': '10011000', 'K': '0110', 'L': '00100', 'M': '10011001', 'N': '10011110', 'O': '00101', 'P': '111', 'Q': '10011111', 'R': '1000', 'S': '00110', 'T': '00111', 'U': '10011100', 'V': '10011101', 'W': '000010', 'X': '10010010', 'Y': '10010011', 'Z': '10010000' } # Second encoding table  '00110': 'G', '00111': 'H', '01000': 'I', '01001': 'J', '01010':  'P', '10000': 'Q', '10001': 'R', '10010': 'S', '10011': 'T', '10100': 'U', '10101': 'V', '10110': 'W', '10111': 'X', '11000': 'Y', '11001': 'Z', '11010': ' ', '11011': '.', '11100': ',', '11101': '-', '11110': \"'\", '11111': '?' } for line in sys.stdin: line = line.rstrip('\\n') #  = ''.join(encode1[c] for  make length multiple of 5 remainder = len(binary_string) % 5 if remainder != 0: binary_string += '0' * (5 - remainder) # Step 3: Split into chunks of 5 and convert using second table result = '' for i in range(0, len(binary_string), 5): chunk = binary_string[i:i+5] result += encode2[chunk] print(result)"], "perturbed_original": ["import sys d={' ':'101',\"'\":'000000',',':'000011','-':'10010001','.':'010001','?':'000001','A':'100101','B':'10011010','C':'0101','D':'0001','E':'110', 'F':'01001','G':'10011011','H':'010000','I':'0111','J':'10011000','K':'0110','L':'00100','M':'10011001','N':'10011110','O':'00101','P':'111', 'Q':'10011111','R':'1000','S':'00110','T':'00111','U':'10011100','V':'10011101','W':'000010','X':'10010010','Y':'10010011','Z':'10010000'} for e in sys.stdin: a=''.join(d[c]for c in e[:-1]) a+='0'*(-len(a)%5) print(''.join(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?\"[int(a[i*5:i*5+5],2)]for i in range(len(a)//5)))"], "original_ll": -1.205153465270996, "sampled_ll": -0.49995502829551697, "all_perturbed_sampled_ll": [-0.9626126885414124], "all_perturbed_original_ll": [-1.2336477041244507], "perturbed_sampled_ll": -0.9626126885414124, "perturbed_original_ll": -1.2336477041244507, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????\u00b0???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned long\t\tI4;\ntypedef unsigned long \tU4;\n\n/* ?????\u00b0?????? */\n#define MAXOFNUM_ROW \t99\t\t\t\t\t/* ?????\u00b0????????\u00a7??? */\n#define MAXOFSUM_COLUMN\t(MAXOFNUM_ROW+1)/2\t/* ?????\u00b0????????\u00a7??? */\n\n/* ??\u00b0?????????????????\u00b0 */\nU1 mu1InputNum[MAXOFNUM_ROW][MAXOFSUM_COLUMN];\t/* ??\\??????????????\u00b0??????????\u00b4????????????? */\n\n/* \n??\u00a2??\u00b0??????u1ReadData\n???????????\\???????????????????????????????????\u00b0???????????? \n?????\u00b0???\n?????????\n????????????U1 ??\\?????????????????\u00b0\n*/\nU1 u1ReadData();\n\n/*\n??\u00a2??\u00b0??????u2SearchMax\n???????????\u00a8????????????????????\u00a7?????\u00a7???????????????\n?????\u00b0???\n????\u00ac\u00ac1?????\u00b0????????\u00b0\n????????????U2 ?????\u00a7???\n*/\nU2 u2SearchMax(U1 u1NumOfRow);\n\n/*\n??\u00a2??\u00b0??????\n?????????2????????\u00b0??????????????\u00a7????????\u00b0????????????\n?????\u00b0???\n????\u00ac\u00ac1?????\u00b0?????\u00b0???1\n????\u00ac\u00ac2?????\u00b0?????\u00b0???2\n????????????U2 ??\u00a7??????????????\u00b0???\n*/\nU2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2);\n\nVD main(void)\n{\n\tU1 u1NumOfRow;\t\t\t\t\t\t/* ?????????????????\u00b0 */\n\tU2 u2MaxOfSum;\t\t\t\t\t\t/* ???????????\u00a7??? */\n\t\n\tu1NumOfRow = u1ReadData();\t\t\t\t/* ??????1 ??\\??????????????????????????? */\n\tu2MaxOfSum = u2SearchMax(u1NumOfRow);\t/* ??????2 ?????\u00a7????????\u00a2??? */\n\tprintf(\"%d\\n\",u2MaxOfSum);\t\t\t\t/* ??????3 ?????\u00a7????????\u00a8????????? */\n}\n\nU1 u1ReadData()\n{\n\tU1 u1NumOfRow;\t\t/* ?????????????????\u00b0 */\n\tU1 u1NumOfColumn;\t/* ?????????????????\u00b0 */\n\tU1 u1TmpChar;\t\t/* ','????????????'\\n'???????\u00b4????????????\u00b0 */\n\tI1 i1ReturnScanf;\t/* scanf??\u00a2??\u00b0???????????????????\u00b4????????????\u00b0 */\n\t\n\tU1 u1OnlyNumCnt;\n\t\n\tu1NumOfRow = 0;\n\tu1NumOfColumn = 0;\n\tu1OnlyNumCnt = 0;\n\t\n\twhile(u1OnlyNumCnt != 2){\n\t\tscanf(\"%d%c\",&mu1InputNum[u1NumOfRow][u1NumOfColumn],&u1TmpChar);\n\t\tif(u1TmpChar == ','){\n\t\t\tu1NumOfColumn++;\n\t\t\tu1TmpChar = 0;\n\t\t}\n\t\telse{\n\t\t\tif(u1NumOfColumn == 0){\n\t\t\t\tu1OnlyNumCnt++;\n\t\t\t}\n\t\t\tu1NumOfRow++;\n\t\t\tu1NumOfColumn = 0;\n\t\t}\n\t}\n\treturn u1NumOfRow;\n}\n\n\nU2 u2SearchMax(U1 u1NumOfRow)\n{\n\tU2 mu2work[MAXOFNUM_ROW][MAXOFSUM_COLUMN];\t/* ?\u00a8???????????????????????\u00b4????????????? */\n\tU1 u1RowCnt;\t\t/* ?????\u00b0???????????? */\n\tU1 u1ColumnCnt;\t\t/* ?????\u00b0???????????? */\n\tU1 u1HalfNumOfRow;\t/* ?????\u00b0????????? */\n\tU2 u2Num1;\t\t\t/* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */\n\tU2 u2Num2;\t\t\t/* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */\n\t\n\tu1HalfNumOfRow = u1NumOfRow/2+1;\n\t\n\t/* ??\\?????????????????????mu2work?????????????????? */\n\tfor(u1RowCnt = 0; u1RowCnt < u1NumOfRow; u1RowCnt++){\n\t\tfor(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){\n\t\t\tif(u1RowCnt >= u1HalfNumOfRow){\n\t\t\t\tif(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt];\n\t\t}\n\t}\n\t\n\tfor(u1RowCnt = 1; u1RowCnt < u1NumOfRow; u1RowCnt++){\n\t\tfor(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){\n\t\t\t/* ????????\u00a2?????\u00a8???????\u00b4???\u00b0????\u00a8????????????\u00b4??? */\n\t\t\tif(u1RowCnt < u1HalfNumOfRow){\t\t\t\t\n\t\t\t\tif(u1ColumnCnt == 0){\n\t\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][0];\n\t\t\t\t}\n\t\t\t\telse if(u1ColumnCnt == u1RowCnt){\n\t\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][u1RowCnt-1];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tu2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt-1];\n\t\t\t\t\tu2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt];\n\t\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* ????????\u00a2?????\u00a8???????\u00b4???\u00b0????\u00a8????????????\u00b4??? */\n\t\t\telse{\n\t\t\t\tif(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tu2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt];\n\t\t\t\tu2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt+1];\n\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2);\n\t\t\t}\n\t\t}\n\t}\n\treturn mu2work[u1NumOfRow-1][0];\n}\n\nU2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2)\n{\n\tU2 u2Rtn;\t/* ????????????????\u00b4????????????\u00b0 */\n\t\n\tif(u2Num1 >= u2Num2){\n\t\tu2Rtn = u2Num1;\n\t}else{\n\t\tu2Rtn = u2Num2;\n\t}\t\n\treturn u2Rtn;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    int diamond[200][100];\n    int dp[200][100];\n    int rows = 0;\n    char line[1000];\n    \n    // Read input\n    while (fgets(line, sizeof(line), stdin)) {\n        int len = strlen(line);\n        if (len > 0 && line[len-1] == '\\n') {\n            line[len-1] = '\\0';\n        }\n        \n        int col = 0;\n        char *token = strtok(line, \",\");\n        while (token != NULL) {\n            diamond[rows][col] = atoi(token);\n            col++;\n            token = strtok(NULL, \",\");\n        }\n        rows++;\n    }\n    \n    // Find the middle row (widest part)\n    int maxRow = 0;\n    for (int i = 0; i < rows; i++) {\n        if (i > maxRow) {\n            maxRow = i;\n        }\n    }\n    \n    // Initialize dp\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < 100; j++) {\n            dp[i][j] = -1;\n        }\n    }\n    \n    // Start with first element\n    dp[0][0] = diamond[0][0];\n    \n    // Determine middle row\n    int mid = rows / 2;\n    \n    // Process upper half (expanding)\n    for (int i = 0; i < mid; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (dp[i][j] != -1) {\n                // Move to left-down diagonal\n                if (dp[i+1][j] < dp[i][j] + diamond[i+1][j]) {\n                    dp[i+1][j] = dp[i][j] + diamond[i+1][j];\n                }\n                // Move to right-down diagonal\n                if (dp[i+1][j+1] < dp[i][j] + diamond[i+1][j+1]) {\n                    dp[i+1][j+1] = dp[i][j] + diamond[i+1][j+1];\n                }\n            }\n        }\n    }\n    \n    // Process lower half (contracting)\n    for (int i = mid; i < rows - 1; i++) {\n        int width = rows - i - 1;\n        for (int j = 0; j <= width; j++) {\n            if (dp[i][j] != -1) {\n                // Move to left-down diagonal\n                if (j > 0) {\n                    if (dp[i+1][j-1] < dp[i][j] + diamond[i+1][j-1]) {\n                        dp[i+1][j-1] = dp[i][j] + diamond[i+1][j-1];\n                    }\n                }\n                // Move to right-down diagonal\n                if (j < width) {\n                    if (dp[i+1][j] < dp[i][j] + diamond[i+1][j]) {\n                        dp[i+1][j] = dp[i][j] + diamond[i+1][j];\n                    }\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", dp[rows-1][0]);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int main() {  //  strlen(line); if (len > 0 && line[len-1]  0; char *token =  col++; token = strtok(NULL, \",\"); } rows++; } // Find the middle row (widest  i < rows; i++) { if (i > maxRow) { maxRow = i; } } // Initialize dp for (int i = 0; i < rows; i++) { for (int j = 0; j < 100; j++) { dp[i][j] = -1; } } // Start with first element dp[0][0] = diamond[0][0]; // Determine  upper half (expanding) for (int i = 0; i < mid; i++) { for (int j = 0; j <= i; j++) { if (dp[i][j] != -1) { // Move to left-down diagonal if (dp[i+1][j] < dp[i][j] + diamond[i+1][j]) { dp[i+1][j] = dp[i][j] + diamond[i+1][j]; } // Move to right-down diagonal if (dp[i+1][j+1] < dp[i][j] + diamond[i+1][j+1]) { dp[i+1][j+1]   rows - 1; i++) { int width = rows - i - 1; for (int j = 0; j <= width;  left-down diagonal if (j > 0) { if (dp[i+1][j-1] < dp[i][j] + diamond[i+1][j-1]) { dp[i+1][j-1] = dp[i][j] + diamond[i+1][j-1]; } } // Move to right-down diagonal if (j < width) { if (dp[i+1][j] < dp[i][j] + diamond[i+1][j]) { dp[i+1][j] = dp[i][j] + diamond[i+1][j]; } } } } } printf(\"%d\\n\", dp[rows-1][0]); return 0; }"], "perturbed_original": ["/* ????????????????????????????????????????????? */ #include <stdio.h> /* ?????\u00b0???????????? */ typedef void VD; typedef signed char I1; typedef unsigned char U1; typedef signed short I2; typedef unsigned short U2; typedef signed  MAXOFNUM_ROW 99 /* ?????\u00b0????????\u00a7??? */ #define MAXOFSUM_COLUMN (MAXOFNUM_ROW+1)/2  */ /* ??\u00a2??\u00b0??????u1ReadData ???????????\\???????????????????????????????????\u00b0???????????? ?????\u00b0??? ????????? ????????????U1 ??\\?????????????????\u00b0 */ U1 u1ReadData(); /* ??\u00a2??\u00b0??????u2SearchMax ???????????\u00a8????????????????????\u00a7?????\u00a7??????????????? ?????\u00b0??? ????\u00ac\u00ac1?????\u00b0????????\u00b0 ????????????U2  ????\u00ac\u00ac2?????\u00b0?????\u00b0???2 ????????????U2 ??\u00a7??????????????\u00b0??? */ U2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2); VD main(void) { U1 u1NumOfRow; /* ?????????????????\u00b0 */ U2 u2MaxOfSum; /* ???????????\u00a7??? */ u1NumOfRow = u1ReadData(); /* ??????1 ??\\??????????????????????????? */ u2MaxOfSum = u2SearchMax(u1NumOfRow); /* ??????2 ?????\u00a7????????\u00a2??? */ printf(\"%d\\n\",u2MaxOfSum); /* ??????3 ?????\u00a7????????\u00a8?????????  U1 u1NumOfColumn; /* ?????????????????\u00b0 */ U1 u1TmpChar; /*  != 2){ scanf(\"%d%c\",&mu1InputNum[u1NumOfRow][u1NumOfColumn],&u1TmpChar); if(u1TmpChar == ','){ u1NumOfColumn++; u1TmpChar = 0; } else{ if(u1NumOfColumn == 0){ u1OnlyNumCnt++; } u1NumOfRow++; u1NumOfColumn = 0; } } return u1NumOfRow; } U2 u2SearchMax(U1 u1NumOfRow) { U2 mu2work[MAXOFNUM_ROW][MAXOFSUM_COLUMN]; /* ?\u00a8???????????????????????\u00b4????????????? */ U1 u1RowCnt; /* ?????\u00b0???????????? */ U1 u1ColumnCnt; /* ?????\u00b0???????????? */ U1 u1HalfNumOfRow; /* ?????\u00b0????????? */ U2 u2Num1; /* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */ U2 u2Num2; /* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */ u1HalfNumOfRow = u1NumOfRow/2+1; /* ??\\?????????????????????mu2work?????????????????? */ for(u1RowCnt = 0; u1RowCnt < u1NumOfRow;  u1HalfNumOfRow){ if(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){ break; } } mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]; } } for(u1RowCnt = 1; u1RowCnt < u1NumOfRow; u1RowCnt++){ for(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){ /* ????????\u00a2?????\u00a8???????\u00b4???\u00b0????\u00a8????????????\u00b4??? */ if(u1RowCnt < u1HalfNumOfRow){ if(u1ColumnCnt == 0){ mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][0]; } else if(u1ColumnCnt ==  = mu2work[u1RowCnt-1][u1ColumnCnt];  >= u1HalfNumOfRow*2-(u1RowCnt+1)){ break; } u2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt]; u2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt+1]; mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2); } } } return mu2work[u1NumOfRow-1][0]; } U2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2) {  u2Num1; }else{ u2Rtn = u2Num2; } return u2Rtn; }"], "original_ll": -1.0170522928237915, "sampled_ll": -0.4945202171802521, "all_perturbed_sampled_ll": [-1.1404057741165161], "all_perturbed_original_ll": [-1.45966637134552], "perturbed_sampled_ll": -1.1404057741165161, "perturbed_original_ll": -1.45966637134552, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] now, next;\n\tint[] dp1, dp2;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] str = sc.next().split(\",\");\n\t\tnow = new int[str.length+4];\n\t\tnow[2] = Integer.parseInt(str[0]);\n\t\tdp1 = new int[51];\n\t\tdp2 = new int[51];\n\t\tdp1[1] = now[2]; \n\t\tfor(;sc.hasNext();) {\n\t//\t\tdebug(dp1);\n\t\t\tstr = sc.next().split(\",\");\n\t\t\tdp2 = dp1.clone();\n\t//\t\tif(str[0].equals(\"0\")) break;\n\t\t\tnext = new int[str.length+4];\n\t\t\tfor(int i=0;i<str.length;i++) next[i+2] = Integer.parseInt(str[i]);\n\t//\t\tdebug(next);\n\t\t\tfor(int i=2;i<=str.length+1;i++) {\n\t\t\t\tif(now.length < next.length) dp1[i-1] = max( dp2[i-2] + next[i], dp2[i-1] + next[i]);\n\t\t\t\telse dp1[i-1] = max( dp2[i-1] + next[i], dp2[i] + next[i]);\n\t\t\t}\n\t\t\tnow = next.clone();\n\t\t}\n\t\tSystem.out.println(dp1[1]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<List<Integer>> diamond = new ArrayList<>();\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            List<Integer> row = new ArrayList<>();\n            if (line.contains(\",\")) {\n                String[] parts = line.split(\",\");\n                for (String part : parts) {\n                    row.add(Integer.parseInt(part));\n                }\n            } else {\n                row.add(Integer.parseInt(line));\n            }\n            diamond.add(row);\n        }\n        \n        int n = diamond.size();\n        int mid = n / 2;\n        \n        List<List<Integer>> dp = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            List<Integer> row = new ArrayList<>();\n            for (int j = 0; j < diamond.get(i).size(); j++) {\n                row.add(Integer.MIN_VALUE);\n            }\n            dp.add(row);\n        }\n        \n        dp.get(0).set(0, diamond.get(0).get(0));\n        \n        for (int i = 0; i < n - 1; i++) {\n            int currSize = diamond.get(i).size();\n            int nextSize = diamond.get(i + 1).size();\n            \n            if (nextSize > currSize) {\n                for (int j = 0; j < currSize; j++) {\n                    if (dp.get(i).get(j) != Integer.MIN_VALUE) {\n                        dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j), \n                            dp.get(i).get(j) + diamond.get(i + 1).get(j)));\n                        dp.get(i + 1).set(j + 1, Math.max(dp.get(i + 1).get(j + 1), \n                            dp.get(i).get(j) + diamond.get(i + 1).get(j + 1)));\n                    }\n                }\n            } else {\n                for (int j = 0; j < currSize; j++) {\n                    if (dp.get(i).get(j) != Integer.MIN_VALUE) {\n                        if (j > 0) {\n                            dp.get(i + 1).set(j - 1, Math.max(dp.get(i + 1).get(j - 1), \n                                dp.get(i).get(j) + diamond.get(i + 1).get(j - 1)));\n                        }\n                        if (j < nextSize) {\n                            dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j), \n                                dp.get(i).get(j) + diamond.get(i + 1).get(j)));\n                        }\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp.get(n - 1).get(0));\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  Scanner sc = new Scanner(System.in); List<List<Integer>> diamond = new ArrayList<>(); while (sc.hasNextLine()) { String line = sc.nextLine().trim(); if (line.isEmpty()) break; List<Integer> row = new ArrayList<>(); if (line.contains(\",\")) { String[] parts = line.split(\",\"); for (String part : parts) { row.add(Integer.parseInt(part)); } } else { row.add(Integer.parseInt(line)); } diamond.add(row); } int n = diamond.size(); int mid = n / 2; List<List<Integer>> dp = new ArrayList<>(); for (int i = 0; i < n; i++) { List<Integer> row = new ArrayList<>(); for (int j = 0; j < diamond.get(i).size(); j++)  = 0; i < n - 1; i++) {   { dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j),  1).get(j + 1))); } } } else { for (int j = 0; j < currSize; j++) { if (dp.get(i).get(j) != Integer.MIN_VALUE) { if (j > 0) { dp.get(i + 1).set(j - 1, Math.max(dp.get(i + 1).get(j - 1), dp.get(i).get(j) + diamond.get(i + 1).get(j - 1))); } if (j < nextSize) { dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j), dp.get(i).get(j) + diamond.get(i + 1).get(j))); } } } } } System.out.println(dp.get(n - 1).get(0)); } }"], "perturbed_original": ["import java.util.*; import static java.lang.Math.*; import static java.util.Arrays.*; public class Main { int INF = 1 << 28; int[] now, next; int[] dp1, dp2; void run() { Scanner sc = new Scanner(System.in); String[] str = sc.next().split(\",\"); now = new int[str.length+4]; now[2] = Integer.parseInt(str[0]); dp1 = new int[51]; dp2 =  = sc.next().split(\",\");  { if(now.length < next.length) dp1[i-1] = max( dp2[i-2] + next[i], dp2[i-1] + next[i]); else dp1[i-1] = max( dp2[i-1] + next[i], dp2[i] + next[i]); } now = next.clone(); } System.out.println(dp1[1]); } public static void main(String[] args) { new Main().run(); } void debug(Object... os) { System.err.println(Arrays.deepToString(os)); } }"], "original_ll": -1.1418027877807617, "sampled_ll": -0.33317098021507263, "all_perturbed_sampled_ll": [-0.8262638449668884], "all_perturbed_original_ll": [-1.50189208984375], "perturbed_sampled_ll": -0.8262638449668884, "perturbed_original_ll": -1.50189208984375, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def path(mx,w,h):\n\tif h < c/2:\n\t\tif w > 0:\n\t\t\tmx[h][w] = max(mx[h-1][w],mx[h-1][w-1]) + inp[h][w]\n\t\telse:\n\t\t\tmx[h][w] = mx[h-1][w] + inp[h][w]\n\telse:\n\t\tif w < len(inp[h])-1:\n\t\t\tmx[h][w] = max(mx[h-1][w],mx[h-1][w+1]) + inp[h][w]\n\t\telse:\n\t\t\tmx[h][w] = mx[h-1][w] + inp[h][w]\n\treturn mx\n\t\nc = 0\ninp = []\nwhile True:\n\ttry:\n\t\tinp.append(map(int, raw_input().split(\",\")))\n\t\tc += 1\n\texcept:\n\t\tmx = [[0 for i in range((c+1)/2)] for i in range(c)]\n\t\tmx[0][0] = inp[0][0]\n\t\tfor h in range(1,c):\n\t\t\tfor w in range(len(inp[h])):\n\t\t\t\tmx = path(mx,w,h)\n\t\tprint mx[c-1][0]\n\t\tbreak", "sampled": "import sys\n\nlines = []\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        lines.append(line)\n\n# Parse the diamond\ndiamond = []\nfor line in lines:\n    if ',' in line:\n        diamond.append(list(map(int, line.split(','))))\n    else:\n        diamond.append([int(line)])\n\nn = len(diamond)\nmid = n // 2\n\n# Dynamic programming\ndp = [[float('-inf')] * len(row) for row in diamond]\ndp[0][0] = diamond[0][0]\n\n# Process upper half (expanding)\nfor i in range(1, mid + 1):\n    for j in range(len(diamond[i])):\n        # Can come from position j-1 or j in previous row\n        if j > 0:\n            dp[i][j] = max(dp[i][j], dp[i-1][j-1] + diamond[i][j])\n        if j < len(diamond[i-1]):\n            dp[i][j] = max(dp[i][j], dp[i-1][j] + diamond[i][j])\n\n# Process lower half (contracting)\nfor i in range(mid + 1, n):\n    for j in range(len(diamond[i])):\n        # Can come from position j or j+1 in previous row\n        if j < len(diamond[i-1]):\n            dp[i][j] = max(dp[i][j], dp[i-1][j] + diamond[i][j])\n        if j + 1 < len(diamond[i-1]):\n            dp[i][j] = max(dp[i][j], dp[i-1][j+1] + diamond[i][j])\n\nprint(dp[n-1][0])\n", "perturbed_sampled": ["import sys lines = [] for line in sys.stdin: line  = [] for line in lines: if ',' in line: diamond.append(list(map(int, line.split(',')))) else: diamond.append([int(line)]) n = len(diamond) mid = n // 2 # Dynamic programming dp = [[float('-inf')] * len(row) for row in diamond] dp[0][0] = diamond[0][0] # Process upper half (expanding) for i in range(1, mid +  j-1 or j in previous row if j > 0: dp[i][j] =  max(dp[i][j], dp[i-1][j] + diamond[i][j]) # Process lower half (contracting) for i in range(mid + 1, n): for j in range(len(diamond[i])): # Can come  < len(diamond[i-1]): dp[i][j] = max(dp[i][j], dp[i-1][j] + diamond[i][j]) if j + 1 < len(diamond[i-1]): dp[i][j] = max(dp[i][j], dp[i-1][j+1] + diamond[i][j]) print(dp[n-1][0])"], "perturbed_original": ["def path(mx,w,h): if h < c/2: if w > 0: mx[h][w] = max(mx[h-1][w],mx[h-1][w-1]) + inp[h][w] else: mx[h][w] = mx[h-1][w] + inp[h][w] else: if w <  + inp[h][w] return mx c = 0 inp = []  = [[0 for i in range((c+1)/2)] for i in range(c)] mx[0][0] = inp[0][0] for h in range(1,c): for w in range(len(inp[h])): mx = path(mx,w,h) print mx[c-1][0] break"], "original_ll": -0.9190635085105896, "sampled_ll": -0.6800452470779419, "all_perturbed_sampled_ll": [-1.4714833498001099], "all_perturbed_original_ll": [-1.8233301639556885], "perturbed_sampled_ll": -1.4714833498001099, "perturbed_original_ll": -1.8233301639556885, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// AOJ0090 Overlaps of Seals\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_N\t(200)\n\n\nint main(void)\n{\n    int n;\n\tdouble circle[MAX_N][2];\n    double d;\n    int flag[MAX_N][MAX_N];\n    int overlap[MAX_N][MAX_N];\n    int max_overlap;\n\tint i, j, k;\n\tint num[MAX_N], max[MAX_N], min[MAX_N];\n    int cont_flag;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// \u0093\u00fc\u0097\u00cd\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%lf,%lf\", &circle[i][0], &circle[i][1]);\n\t\t}\n\t\t\n\t\t// \u008fd\u0082\u00c8\u0082\u00e8\u0083e\u0081[\u0083u\u0083\u008b\u008d\u00ec\u0090\u00ac\n\t\tmemset(flag, 0, sizeof(flag));\n\t\tfor (i = 0; i < n; i++){\n\t\t\tfor (j = i; j < n; j++){\n\t\t\t\tif (i == j){\n\t\t\t\t\tflag[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td = (circle[i][0] - circle[j][0]) * (circle[i][0] - circle[j][0]) +\n\t\t\t\t\t    (circle[i][1] - circle[j][1]) * (circle[i][1] - circle[j][1]);\n\t\t\t\t\tif (d <= 4.0){\n\t\t\t\t\t\tflag[i][j] = flag[j][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n                    // \u0092[\u0082\u00c1\u0082\u00b1\u0082\u00cc\u008d\u00ed\u008f\u009c\n        max_overlap = 1;\n        do {\n\t\t\tfor (i = 0; i < n; i++){\n                num[i] = 0;\n\t\t\t\tfor (j = 0; j < n; j++){\n\t\t\t\t\tnum[i] += flag[i][j];\n\t\t\t\t}\n   \t\t\t}\n\n            cont_flag = 0;\n\t\t\tfor (i = 0; i < n; i++){\n                if (num[i] == 2){\n                    max_overlap = 2;\n                }\n\t\t\t\tif (num[i] == 1 || num[i] == 2){\n\t\t\t\t\tfor (j = 0; j < n; j++){\n\t\t\t\t\t\tflag[i][j] = flag[j][i] = 0; \n\t\t\t\t\t}\n                    cont_flag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (cont_flag == 1);\n\n        \n\t\tmemset(overlap, 0, sizeof(overlap));\n        for (i = 0; i < n; i++){\n            if (num[i] > 0){\n                for (j = 0; j < n; j++){\n                    if (flag[i][j] == 1){\n                        for (k = j + 1; k < n; k++){\n                            if (flag[i][k] == 1){\n                                if (flag[j][k] == 1){\n                                    overlap[i][j]++;\n                                    overlap[i][k]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (i = 0; i < n; i++){\n            max[i] = 0;\n            min[i] = 1000;\n        }\n        for (i = 0; i < n; i++){\n            for (j = 0; j < n; j++){\n                if (max[i] < overlap[i][j]){\n                    max[i] = overlap[i][j];\n                }\n                if (overlap[i][j] > 0 && min[i] > overlap[i][j]){\n                    min[i] = overlap[i][j];\n                }\n            }\n//            printf(\"<%d %d-%d>\", i, min[i], max[i]);\n        }\n\n        for (i = 0; i < n; i++){\n            for (j = 0; j < n; j++){\n//                printf(\"[%d]\",overlap[i][j]);\n                if (overlap[i][j] < overlap[i][i] || max[i] == min[i]){\n                    if (max_overlap < overlap[i][j]){\n                        max_overlap = overlap[i][j];\n                    }\n                }\n            }\n//            printf(\"\\n\");\n        }\n        \n        printf(\"%d\\n\", max_overlap + 1);\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\n#define MAX_N 100\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint main() {\n    int n;\n    Point stickers[MAX_N];\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf,%lf\", &stickers[i].x, &stickers[i].y);\n        }\n        \n        int maxOverlap = 1;\n        \n        // Check all pairs of stickers\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double dx = stickers[i].x - stickers[j].x;\n                double dy = stickers[i].y - stickers[j].y;\n                double dist = sqrt(dx * dx + dy * dy);\n                \n                // If circles overlap or touch\n                if (dist <= 2.0 + EPS) {\n                    // Find intersection points\n                    if (dist < EPS) continue; // Same center (shouldn't happen)\n                    \n                    // Calculate intersection points\n                    double a = dist / 2.0;\n                    double h = sqrt(1.0 - a * a);\n                    \n                    double mx = (stickers[i].x + stickers[j].x) / 2.0;\n                    double my = (stickers[i].y + stickers[j].y) / 2.0;\n                    \n                    double px1 = mx + h * (stickers[j].y - stickers[i].y) / dist;\n                    double py1 = my - h * (stickers[j].x - stickers[i].x) / dist;\n                    \n                    double px2 = mx - h * (stickers[j].y - stickers[i].y) / dist;\n                    double py2 = my + h * (stickers[j].x - stickers[i].x) / dist;\n                    \n                    // Check point 1\n                    int count1 = 0;\n                    for (int k = 0; k < n; k++) {\n                        double d = sqrt((px1 - stickers[k].x) * (px1 - stickers[k].x) + \n                                      (py1 - stickers[k].y) * (py1 - stickers[k].y));\n                        if (d <= 1.0 + EPS) count1++;\n                    }\n                    if (count1 > maxOverlap) maxOverlap = count1;\n                    \n                    // Check point 2\n                    int count2 = 0;\n                    for (int k = 0; k < n; k++) {\n                        double d = sqrt((px2 - stickers[k].x) * (px2 - stickers[k].x) + \n                                      (py2 - stickers[k].y) * (py2 - stickers[k].y));\n                        if (d <= 1.0 + EPS) count2++;\n                    }\n                    if (count2 > maxOverlap) maxOverlap = count2;\n                }\n            }\n            \n            // Check center of each sticker\n            int count = 0;\n            for (int k = 0; k < n; k++) {\n                double d = sqrt((stickers[i].x - stickers[k].x) * (stickers[i].x - stickers[k].x) + \n                              (stickers[i].y - stickers[k].y) * (stickers[i].y - stickers[k].y));\n                if (d <= 1.0 + EPS) count++;\n            }\n            if (count > maxOverlap) maxOverlap = count;\n        }\n        \n        printf(\"%d\\n\", maxOverlap);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #define MAX_N 100 #define EPS 1e-9 typedef struct  n; Point stickers[MAX_N]; while (scanf(\"%d\", &n) == 1 && n != 0) { for (int i = 0; i < n; i++) { scanf(\"%lf,%lf\", &stickers[i].x, &stickers[i].y); } int maxOverlap = 1; // Check all pairs of stickers for (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { double dx = stickers[i].x - stickers[j].x; double dy = stickers[i].y - stickers[j].y; double dist = sqrt(dx * dx + dy * dy); // If circles overlap or  center (shouldn't happen) // Calculate intersection points double a = dist / 2.0; double h = sqrt(1.0 - a * a); double mx = (stickers[i].x + stickers[j].x) / 2.0; double my = (stickers[i].y + stickers[j].y) / 2.0; double px1 = mx + h * (stickers[j].y - stickers[i].y) / dist; double py1 = my - h *  = my + h * (stickers[j].x - stickers[i].x) / dist; // Check point 1 int count1 = 0; for (int k = 0; k < n; k++) { double d = sqrt((px1 - stickers[k].x) * (px1 - stickers[k].x) + (py1 -  EPS) count1++;  = 0; k < n; k++) { double d = sqrt((px2  * (py2 - stickers[k].y)); if (d <= 1.0 + EPS) count2++; } if (count2 > maxOverlap) maxOverlap = count2; } } // Check center of each sticker int count =  { double d = sqrt((stickers[i].x - stickers[k].x) * (stickers[i].x - stickers[k].x) + (stickers[i].y  + EPS) count++; } if (count > maxOverlap) maxOverlap = count; } printf(\"%d\\n\", maxOverlap); } return 0; }"], "perturbed_original": ["// AOJ0090 Overlaps of Seals #include <stdio.h> #include <string.h> #define MAX_N (200) int main(void) { int n; double circle[MAX_N][2]; double d; int flag[MAX_N][MAX_N]; int overlap[MAX_N][MAX_N]; int max_overlap; int i, j, k; int num[MAX_N], max[MAX_N], min[MAX_N]; int cont_flag; while (1){ scanf(\"%d\", &n); if (n == 0){ break; } // \u0093\u00fc\u0097\u00cd for (i = 0; i < n;  for (i = 0; i < n; i++){ for (j = i; j < n; j++){ if (i == j){ flag[i][j] = 1; } else  + (circle[i][1]  flag[i][j] = flag[j][i] = 1; } }  (i = 0; i < n; i++){ num[i] = 0; for (j = 0; j < n;  (i = 0; i < n; i++){ if (num[i] == 2){ max_overlap = 2; }  = 0; j < n; j++){ flag[i][j] = flag[j][i] = 0; } cont_flag = 1; } } } while (cont_flag == 1); memset(overlap, 0, sizeof(overlap)); for (i = 0; i < n; i++){ if (num[i] > 0){ for (j = 0; j < n; j++){ if (flag[i][j] == 1){ for (k = j + 1; k < n; k++){ if (flag[i][k] == 1){ if (flag[j][k] == 1){ overlap[i][j]++; overlap[i][k]++; } } }  n; i++){ max[i] = 0; min[i] = 1000; } for (i = 0; i < n; i++){ for (j = 0; j < n; j++){ if (max[i] < overlap[i][j]){ max[i] = overlap[i][j]; } if (overlap[i][j] >  = 0; i < n; i++){ for (j = 0;  || max[i] == min[i]){ if (max_overlap < overlap[i][j]){ max_overlap = overlap[i][j]; } } } // printf(\"\\n\"); } printf(\"%d\\n\", max_overlap + 1); } return (0); }"], "original_ll": -0.9168722033500671, "sampled_ll": -0.4457537531852722, "all_perturbed_sampled_ll": [-1.1405267715454102], "all_perturbed_original_ll": [-1.2162548303604126], "perturbed_sampled_ll": -1.1405267715454102, "perturbed_original_ll": -1.2162548303604126, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scanner = new Scanner(System.in);\n\t\t\n\t\tfor(; ;)\n\t\t{\n\t\t\tint n = scanner.nextInt();\n\t\t\tif(n == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint max_len = 0;\n\t\t\tfloat[] x = new float[n];\n\t\t\tfloat[] y = new float[n];\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tString[] input = scanner.next().split(\",\");\n\t\t\t\t\n\t\t\t\tx[i] = Float.parseFloat(input[0]);\n\t\t\t\ty[i] = Float.parseFloat(input[1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(float px=0; px<=10; px+=0.001)\n\t\t\t{\n\t\t\t\tfor(float py=0; py<=10; py+=0.001)\n\t\t\t\t{\n\t\t\t\t\tint len = 0;\n\t\t\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif((px-x[i])*(px-x[i])+(py-y[i])*(py-y[i]) <= 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(max_len < len)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax_len = len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max_len);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n        double dist(Point p) {\n            return Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            Point[] stickers = new Point[n];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\",\");\n                double x = Double.parseDouble(parts[0]);\n                double y = Double.parseDouble(parts[1]);\n                stickers[i] = new Point(x, y);\n            }\n            \n            int maxOverlap = 1;\n            \n            // Check all pairs of stickers and find intersection points\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    double d = stickers[i].dist(stickers[j]);\n                    if (d <= 2.0) {\n                        // Find intersection points\n                        List<Point> testPoints = getIntersectionPoints(stickers[i], stickers[j]);\n                        for (Point p : testPoints) {\n                            int count = 0;\n                            for (int k = 0; k < n; k++) {\n                                if (stickers[k].dist(p) <= 1.0 + 1e-9) {\n                                    count++;\n                                }\n                            }\n                            maxOverlap = Math.max(maxOverlap, count);\n                        }\n                    }\n                }\n                // Also check the center of each sticker\n                int count = 0;\n                for (int k = 0; k < n; k++) {\n                    if (stickers[k].dist(stickers[i]) <= 1.0 + 1e-9) {\n                        count++;\n                    }\n                }\n                maxOverlap = Math.max(maxOverlap, count);\n            }\n            \n            System.out.println(maxOverlap);\n        }\n    }\n    \n    static List<Point> getIntersectionPoints(Point c1, Point c2) {\n        List<Point> points = new ArrayList<>();\n        double d = c1.dist(c2);\n        \n        if (d > 2.0 + 1e-9) return points;\n        \n        double r = 1.0;\n        double a = (r * r - r * r + d * d) / (2 * d);\n        double h = Math.sqrt(Math.max(0, r * r - a * a));\n        \n        double cx = c1.x + a * (c2.x - c1.x) / d;\n        double cy = c1.y + a * (c2.y - c1.y) / d;\n        \n        double px1 = cx + h * (c2.y - c1.y) / d;\n        double py1 = cy - h * (c2.x - c1.x) / d;\n        \n        double px2 = cx - h * (c2.y - c1.y) / d;\n        double py2 = cy + h * (c2.x - c1.x) / d;\n        \n        points.add(new Point(px1, py1));\n        if (h > 1e-9) {\n            points.add(new Point(px2, py2));\n        }\n        \n        return points;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class Point { double x, y; Point(double x, double y) { this.x = x; this.y = y; } double dist(Point p) { return Math.sqrt((x - p.x) * (x - p.x)  public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) {  stickers = new Point[n]; for (int i = 0; i < n; i++) { String[] parts = br.readLine().trim().split(\",\"); double x = Double.parseDouble(parts[0]); double y = Double.parseDouble(parts[1]); stickers[i] = new Point(x, y); } int maxOverlap = 1; // Check all pairs of stickers and find intersection points for (int i = 0; i < n; i++) { for (int j  d = stickers[i].dist(stickers[j]); if (d <= 2.0) { // Find intersection points List<Point> testPoints = getIntersectionPoints(stickers[i], stickers[j]); for (Point p : testPoints)  + 1e-9) { count++; } } maxOverlap = Math.max(maxOverlap, count); } } } // Also check the center of each sticker int count = 0;  if (stickers[k].dist(stickers[i]) <= 1.0 + 1e-9) { count++; } } maxOverlap = Math.max(maxOverlap,  c2) {  (d > 2.0 + 1e-9) return points; double r = 1.0; double a = (r * r - r * r  double cx = c1.x + a * (c2.x - c1.x) / d; double cy = c1.y + a * (c2.y - c1.y) / d; double px1 =  py1 = cy - h * (c2.x - c1.x) / d; double px2 = cx - h * (c2.y - c1.y) / d; double py2 = cy + h * (c2.x - c1.x) / d; points.add(new Point(px1, py1)); if (h > 1e-9) { points.add(new Point(px2, py2)); } return points; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void  break; } int max_len = 0; float[] x = new float[n];  String[] input = scanner.next().split(\",\"); x[i] = Float.parseFloat(input[0]); y[i] = Float.parseFloat(input[1]); } for(float px=0; px<=10; px+=0.001) { for(float py=0; py<=10; py+=0.001) { int len = 0; for(int i=0; i<n; i++) { if((px-x[i])*(px-x[i])+(py-y[i])*(py-y[i]) <= 1) { len ++; } } if(max_len < len) { max_len = len; } } } System.out.println(max_len); } } }"], "original_ll": -0.5826813578605652, "sampled_ll": -0.48404642939567566, "all_perturbed_sampled_ll": [-1.2353417873382568], "all_perturbed_original_ll": [-1.1819630861282349], "perturbed_sampled_ll": -1.2353417873382568, "perturbed_original_ll": -1.1819630861282349, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\ndef overlap(p1, p2, d):\n    return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 <= d\n\ndef intersection(o1,o2):\n    a  = 2*(o2[0] - o1[0])\n    b  = 2*(o2[1] - o1[1])\n    c  = (o1[0] - o2[0])*(o1[0] + o2[0]) + (o1[1] - o2[1])*(o1[1] + o2[1])\n    a2 = a**2 + b**2\n    b2 = a*c + a*b*o1[1] - b**2*o1[0]\n    c2 = b**2*(o1[0]**2 + o1[1]**2 - 1) + c**2 + 2*b*c*o1[1]\n    x1 = (-b2 + math.sqrt(b2**2 - a2*c2))/a2\n    x2 = (-b2 - math.sqrt(b2**2 - a2*c2))/a2\n    if abs(b) < 10e-6:\n        y1 = (o1[1] + o2[1])/2\n        y2 = (o1[1] + o2[1])/2\n    else:\n        y1 = -(a*x1 + c)/b\n        y2 = -(a*x2 + c)/b\n    if abs(b2**2 - a2*c2) < 10e-6:\n        return [x1, y1], [None, None]\n    else:\n        return [x1, y1], [x2, y2]\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(list(map(float, input().split(\",\"))))\n    ans = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if not overlap(p[i], p[j], 4):\n                continue\n            elif overlap(p[i], p[j], 10e-6):\n                continue\n            p1, p2 = intersection(p[i], p[j])\n            cnt1 = 0\n            cnt2 = 0\n            for k in range(n):\n                if overlap(p1, p[k], 1):\n                    cnt1 += 1\n                if p2[0] != None and overlap(p2, p[k], 1):\n                    cnt2 += 1\n            ans = max([ans, cnt1, cnt2])\n    print(ans)\n\n", "sampled": "import sys\nfrom math import sqrt\n\ndef distance(p1, p2):\n    return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef circles_overlap(c1, c2):\n    return distance(c1, c2) <= 2.0\n\ndef max_overlap(circles):\n    if not circles:\n        return 0\n    \n    n = len(circles)\n    if n == 1:\n        return 1\n    \n    max_count = 1\n    \n    # Check overlaps at each circle center\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if circles_overlap(circles[i], circles[j]):\n                count += 1\n        max_count = max(max_count, count)\n    \n    # Check intersection points of pairs of circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            if circles_overlap(circles[i], circles[j]):\n                # Find intersection points\n                x1, y1 = circles[i]\n                x2, y2 = circles[j]\n                \n                d = distance(circles[i], circles[j])\n                \n                if d == 0:\n                    continue\n                \n                if d <= 2.0:\n                    # Calculate intersection points\n                    a = d / 2.0\n                    h = sqrt(1.0 - a * a) if a <= 1.0 else 0\n                    \n                    mx = (x1 + x2) / 2.0\n                    my = (y1 + y2) / 2.0\n                    \n                    dx = (x2 - x1) / d\n                    dy = (y2 - y1) / d\n                    \n                    # Two intersection points\n                    points = []\n                    if h > 0:\n                        points.append((mx + h * dy, my - h * dx))\n                        points.append((mx - h * dy, my + h * dx))\n                    else:\n                        points.append((mx, my))\n                    \n                    for point in points:\n                        count = 0\n                        for k in range(n):\n                            if distance(point, circles[k]) <= 1.0 + 1e-9:\n                                count += 1\n                        max_count = max(max_count, count)\n    \n    return max_count\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    circles = []\n    for _ in range(n):\n        line = input().strip()\n        x, y = map(float, line.split(','))\n        circles.append((x, y))\n    \n    print(max_overlap(circles))\n", "perturbed_sampled": [" sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def circles_overlap(c1, c2): return distance(c1, c2) <= 2.0 def max_overlap(circles): if not circles: return 0 n = len(circles) if n == 1: return 1 max_count = 1 #  count = 0 for j in range(n): if  Check intersection points of pairs of circles for i in range(n): for j in range(i + 1, n): if circles_overlap(circles[i], circles[j]): # Find intersection points x1, y1 = circles[i] x2, y2 = circles[j] d = distance(circles[i], circles[j]) if d == 0: continue if d <= 2.0: # Calculate intersection points a = d  a <= 1.0 else 0 mx = (x1 + x2) / 2.0 my = (y1 + y2) / 2.0 dx = (x2 - x1) /  points.append((mx + h * dy, my - h * dx)) points.append((mx - h * dy, my + h * dx)) else: points.append((mx, my)) for point in points: count = 0 for k in range(n): if distance(point, circles[k]) <= 1.0 + 1e-9: count += 1 max_count = max(max_count, count) return max_count while  = [] for _ in range(n): line = input().strip() x, y = map(float, line.split(',')) circles.append((x, y)) print(max_overlap(circles))"], "perturbed_original": ["import math def overlap(p1, p2, d): return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 <= d def intersection(o1,o2): a = 2*(o2[0] - o1[0]) b = 2*(o2[1] - and<extra_id_2>p:<extra_id_3>p[n] ans = max([ans,<extra_id_4>if - o2[1])*(o1[1] + o2[1]) a2 = a**2 + b**2 b2 = a*c + a*b*o1[1] - b**2*o1[0] c2 = b**2*(o1[0]**2 + o1[1]**2 - 1) + c**2 + 2*b*c*o1[1] x1 = (-b2 + math.sqrt(b2**2 - a2*c2))/a2 x2 = (-b2 - math.sqrt(b2**2 - a2*c2))/a2 if abs(b) < 10e-6: y1 = (o1[1] + o2[1])/2 y2 = (o1[1] + o2[1])/2 else: y1 = -(a*x1 + c)/b y2 = -(a*x2 <extra_id_5>(y1, y2): ans<extra_id_6>(y2, y1)<extra_id_7>(<extra_id_8>p[n] + p[j], 10e-6):<extra_id_9>( y1, y2):<extra_id_10>p:<extra_id_11>>= 1: ans = max([<extra_id_12>: cnt1<extra_id_13>3: len(p))<extra_id_14>p) ans while True: n = int(input()) if n == 0: break p = [] for i in range(n): p.append(list(map(float, input().split(\",\")))) ans  4): continue elif overlap(p[i], p[j], 10e-6): continue p1, p2 = intersection(p[i], p[j]) cnt1 = 0 cnt2 = 0 for k in range(n): if  and overlap(p2, p[k], 1): cnt2 += 1 ans = max([ans, cnt1, cnt2]) print(ans)"], "original_ll": -0.7319892048835754, "sampled_ll": -0.6724913120269775, "all_perturbed_sampled_ll": [-1.3776085376739502], "all_perturbed_original_ll": [-1.6172630786895752], "perturbed_sampled_ll": -1.3776085376739502, "perturbed_original_ll": -1.6172630786895752, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "z[4000],*a=z,*b=z+2000,m,i,j,t,u;main(n){for(;scanf(\"%d\",&n)*n++;m=!printf(\"%d\\n\",m))for(i=n;i--;j=a,a=b,b=j)for(j=n;j--;t>m?m=t:0)t=b[j]=n+~i&&getchar()>45?1+fmin(u=a[j],fmin(t,u)):0;}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    char grid[1001][1001];\n    int dp[1001][1001];\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        // Read the grid\n        for(int i = 0; i < n; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        // Initialize dp array\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                dp[i][j] = 0;\n            }\n        }\n        \n        // Build dp array\n        int maxSize = 0;\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == '.') {\n                    if(i == 0 || j == 0) {\n                        dp[i][j] = 1;\n                    } else {\n                        int min = dp[i-1][j];\n                        if(dp[i][j-1] < min) min = dp[i][j-1];\n                        if(dp[i-1][j-1] < min) min = dp[i-1][j-1];\n                        dp[i][j] = min + 1;\n                    }\n                    if(dp[i][j] > maxSize) {\n                        maxSize = dp[i][j];\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", maxSize);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; char grid[1001][1001]; int dp[1001][1001]; while(scanf(\"%d\", &n) == 1 && n !=  i < n; i++) { scanf(\"%s\", grid[i]); } // Initialize dp array for(int i = 0; i < n; i++)  dp[i][j]  = 0; for(int i = 0; i < n; i++) { for(int j = 0; j < n; j++) { if(grid[i][j] == '.') { if(i == 0 || j == 0) { dp[i][j] = 1; } else { int min  min) min = dp[i-1][j-1]; dp[i][j] = min + 1; } if(dp[i][j] > maxSize) { maxSize = dp[i][j]; } } } } printf(\"%d\\n\", maxSize); } return 0; }"], "perturbed_original": ["z[4000],*a=z,*b=z+2000,m,i,j,t,u;main(n){for(;scanf(\"%d\",&n)*n++;m=!printf(\"%d\\n\",m))for(i=n;i--;j=a,a=b,b=j)for(j=n;j--;t>m?m=t:0)t=b[j]=n+~i&&getchar()>45?1+fmin(u=a[j],fmin(t,u)):0;}"], "original_ll": -3.5804412364959717, "sampled_ll": -0.3973008394241333, "all_perturbed_sampled_ll": [-1.0679171085357666], "all_perturbed_original_ll": [-3.5804412364959717], "perturbed_sampled_ll": -1.0679171085357666, "perturbed_original_ll": -3.5804412364959717, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\nclass Main {\n\tprivate static String check = \".\";\n\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\n\t\ttry {\n\t\t\twhile (!(buf = br.readLine()).equals(\"0\")) {\n\t\t\t\tint n = Integer.parseInt(buf);\n\t\t\t\tint mat[][] = new int[n][n];\n\t\t\t\tString str[] = new String[n];\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tstr[i] = br.readLine();\n\t\t\t\t\tfor (int j=0;j<n;j++) {\n\t\t\t\t\t\tif (str[i].charAt(j)=='.') mat[i][j] = 0;\n\t\t\t\t\t\telse if (str[i].charAt(j)=='*') mat[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max = 0;\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tif (str[i].indexOf(check)>=0) {\n\t\t\t\t\t\tfor (int j=0;j<n;j++) {\n\t\t\t\t\t\t\tint d = Square(mat,i,j,n);\n\t\t\t\t\t\t\tif (max<d) {\n\t\t\t\t\t\t\t\tmax = d;\n\t\t\t\t\t\t\t\tcheck = \".\";\n\t\t\t\t\t\t\t\tfor (int k=0;k<max;k++) check = check+\".\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static int Square(int[][] m,int x,int y,int n) {\n\t\tint c = 0;\n\t\tboolean end = false;\n\t\twhile (x+c<n&&y+c<n) {\n\t\t\tfor (int i=y;i<=y+c;i++) {\n\t\t\t\tif (m[i][x+c]==1) {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i=x+c;i>=x;i--) {\n\t\t\t\tif (m[y+c][i]==1) {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc++;\n\t\t}\n\t\treturn c;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            sc.nextLine();\n            \n            char[][] grid = new char[n][n];\n            for (int i = 0; i < n; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            \n            int[][] dp = new int[n][n];\n            int maxSize = 0;\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (grid[i][j] == '.') {\n                        if (i == 0 || j == 0) {\n                            dp[i][j] = 1;\n                        } else {\n                            dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;\n                        }\n                        maxSize = Math.max(maxSize, dp[i][j]);\n                    } else {\n                        dp[i][j] = 0;\n                    }\n                }\n            }\n            \n            System.out.println(maxSize);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; sc.nextLine(); char[][] grid = new char[n][n]; for (int i = 0; i < n; i++) { String line = sc.nextLine(); for (int j = 0; j < n; j++) { grid[i][j] = line.charAt(j); } } int[][] dp = new int[n][n]; int maxSize = 0; for (int  j = 0; j < n; j++) { if (grid[i][j] == '.') { if (i == 0 || j == 0) { dp[i][j] =  dp[i][j] = 0; } } } System.out.println(maxSize); } sc.close(); } }"], "perturbed_original": ["import java.io.*; class Main { private static String check = \".\"; public static <<extra_id_4>n; String buf; try { while (!(buf = br.readLine()).equals(\"0\")) { int n = Integer.parseInt(buf); int mat[][] = new int[n][n]; String str[] = new String[n]; for (int i=0;i<n;i++) { str[i] = br.readLine(); for (int j=0;j<n;j++) { if (str[i].charAt(j)=='.') mat[i][j] = 0; else <<extra_id_5>c++; }<extra_id_6>public static int<extra_id_7>Math.Sqrt(int x,int y,int<extra_id_8>int<extra_id_9>+ n , int<extra_id_10>. Sqrt(r =<extra_id_11>) {<extra_id_12>{ int i<extra_id_13>i ++<extra_id_14>>= 0<extra_id_15>{<extra_id_16>( i = i<extra_id_17>= m<extra_id_18>c<extra_id_19>else { return<extra_id_20>+=<extra_id_21>n ; hemis 0; for (int i=0;i<n;i++) { if (str[i].indexOf(check)>=0) { for (int j=0;j<n;j++) {  check = \".\"; for (int k=0;k<max;k++) check = check+\".\"; } } } } System.out.println(max); } } catch (Exception e) { e.printStackTrace(); } } public static int Square(int[][] m,int x,int y,int n) {  { for (int i=y;i<=y+c;i++) { if (m[i][x+c]==1) { return c; } } for (int i=x+c;i>=x;i--) { if (m[y+c][i]==1) { return c; } } c++; } return c; } }"], "original_ll": -0.7796229124069214, "sampled_ll": -0.29041630029678345, "all_perturbed_sampled_ll": [-0.9448024034500122], "all_perturbed_original_ll": [-1.8501862287521362], "perturbed_sampled_ll": -0.9448024034500122, "perturbed_original_ll": -1.8501862287521362, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while(1):\n    n = int(input())\n    if n == 0:\n        break\n    a = [0 for i in range(n)]\n    b = [[0 for i in range(n)] for j in range(n)]\n    c_ = [[2000 for i in range(n)] for j in range(n)]\n    c = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        a[i] = [0 if i == \".\" else 1 for i in list(input())]\n        count = 0\n        for j in range(n)[::-1]:\n            if a[i][j] == 0:\n                count += 1\n                b[i][j] = count\n            else:\n                count = 0\n                b[i][j] = count\n                \n    for col in range(n):\n        for i in range(n):\n            for j in range(i,n):\n                if b[j][col] < c_[i][col]:\n                    c_[i][col] = b[j][col]\n                l = j-i+1\n                if c_[i][col] < l:\n                    break\n                c[i][col] = l\n    \n    print(max([max(i) for i in c]))\n\n", "sampled": "import sys\n\ndef max_square(n, grid):\n    if n == 0:\n        return 0\n    \n    # Create DP table\n    dp = [[0] * n for _ in range(n)]\n    max_side = 0\n    \n    # Initialize first row and column\n    for i in range(n):\n        if grid[i][0] == '.':\n            dp[i][0] = 1\n            max_side = 1\n    \n    for j in range(n):\n        if grid[0][j] == '.':\n            dp[0][j] = 1\n            max_side = 1\n    \n    # Fill DP table\n    for i in range(1, n):\n        for j in range(1, n):\n            if grid[i][j] == '.':\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n    \n    return max_side\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    grid = []\n    for _ in range(n):\n        grid.append(input().strip())\n    \n    result = max_square(n, grid)\n    print(result)\n", "perturbed_sampled": ["import sys def max_square(n, grid): if n == 0: return 0 #  in range(n)]  i in range(n): if grid[i][0] == '.': dp[i][0] = 1 max_side = 1 for j in range(n): if grid[0][j] == '.': dp[0][j] = 1 max_side = 1 # Fill DP table for i in range(1, n): for j in range(1, n): if grid[i][j] == '.': dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side while True: n = int(input())  in range(n): grid.append(input().strip()) result = max_square(n, grid) print(result)"], "perturbed_original": ["while(1): n = int(input()) if n == 0: break a = [0 for i in range(n)] b = [[0 for i in range(n)] for j in range(n)] c_ = [[2000 for i in range(n)] for j in range(n)] c = [[0 for i in range(n)] for j in range(n)] for i in range(n): a[i] = [0 if i  count += 1 b[i][j]  col in range(n): for i in range(n): for j in range(i,n): if b[j][col] < c_[i][col]: c_[i][col] = b[j][col] l = j-i+1 if c_[i][col] < l: break c[i][col] = l print(max([max(i) for i in c]))"], "original_ll": -0.9098446369171143, "sampled_ll": -0.3981064260005951, "all_perturbed_sampled_ll": [-1.121895670890808], "all_perturbed_original_ll": [-1.339029312133789], "perturbed_sampled_ll": -1.121895670890808, "perturbed_original_ll": -1.339029312133789, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n\tint before,after;\n\tint i;\n\tint flag = 0;\n\twhile(scanf(\"%d %d\",&before,&after)){\n\t\tif(before == 0 && after == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = before;i <= after;i++){\n\t\t\tif(i % 4 == 0){\n\t\t\t\tif(i % 100 != 0){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tprintf(\"%d\\n\",i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i % 4 == 0){\n\t\t\t\tif(i % 400 == 0){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tprintf(\"%d\\n\",i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag == 0){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\tprintf(\"\\n\\n\");\n\t\tflag = 0;\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint isLeapYear(int year) {\n    if (year % 400 == 0) return 1;\n    if (year % 100 == 0) return 0;\n    if (year % 4 == 0) return 1;\n    return 0;\n}\n\nint main() {\n    int a, b;\n    int first = 1;\n    \n    while (1) {\n        scanf(\"%d %d\", &a, &b);\n        if (a == 0 && b == 0) break;\n        \n        if (!first) {\n            printf(\"\\n\");\n        }\n        first = 0;\n        \n        int found = 0;\n        for (int year = a; year <= b; year++) {\n            if (isLeapYear(year)) {\n                printf(\"%d\\n\", year);\n                found = 1;\n            }\n        }\n        \n        if (!found) {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int isLeapYear(int year) { if (year % 400 == 0)  if   while (1) { scanf(\"%d %d\", &a, &b); if (a == 0 && b == 0) break; if (!first) { printf(\"\\n\"); } first = 0; int found = 0; for (int year = a; year <= b; year++) { if (isLeapYear(year)) { printf(\"%d\\n\", year); found = 1; } } if (!found) { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int before,after; int i; int flag = 0; while(scanf(\"%d %d\",&before,&after)){ if(before == 0 && after == 0){ break; } for(i = before;i <= after;i++){ if(i % 4 == 0){ if(i % 100 != 0){ flag =  % 400 == 0){  printf(\"NA\\n\"); } printf(\"\\n\\n\"); flag = 0; } return 0; }"], "original_ll": -0.7553380727767944, "sampled_ll": -0.4964819550514221, "all_perturbed_sampled_ll": [-1.1912416219711304], "all_perturbed_original_ll": [-1.6810250282287598], "perturbed_sampled_ll": -1.1912416219711304, "perturbed_original_ll": -1.6810250282287598, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nclass Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n\n        while (!(line = br.readLine()).equals(\"0 0\")) {\n            String[] input = line.split(\" \");\n            int a = Integer.parseInt(input[0]);\n            int b = Integer.parseInt(input[1]);\n            StringBuilder sb = new StringBuilder();\n\n            boolean isNA = true;\n\n            for (int now = a; now <= b; now++) {\n                if (now % 4 == 0) {\n                    if(now % 100 == 0){\n                        if(now % 400 == 0){\n                            sb.append(now).append(\"\\n\");\n                            if (isNA)   isNA = false;\n                        }\n                    }else{\n                        sb.append(now).append(\"\\n\");\n                        if (isNA)   isNA = false;\n                    }\n                }\n            }\n\n            if (isNA) {\n                sb.append(\"NA\").append(\"\\n\");\n            }\n\n            System.out.println(sb);\n        }\n\n    }\n}\n", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        boolean first = true;\n        \n        while (true) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            \n            if (a == 0 && b == 0) {\n                break;\n            }\n            \n            if (!first) {\n                System.out.println();\n            }\n            first = false;\n            \n            boolean found = false;\n            for (int year = a; year <= b; year++) {\n                if (isLeapYear(year)) {\n                    System.out.println(year);\n                    found = true;\n                }\n            }\n            \n            if (!found) {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean isLeapYear(int year) {\n        if (year % 400 == 0) {\n            return true;\n        }\n        if (year % 100 == 0) {\n            return false;\n        }\n        if (year % 4 == 0) {\n            return true;\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import  true; while (true) { int a = sc.nextInt(); int b = sc.nextInt(); if (a == 0 && b == 0) { break; } if (!first) { System.out.println();  year = a; year <= b; year++) { if (isLeapYear(year)) { System.out.println(year); found = true; } } if (!found) { System.out.println(\"NA\"); } } sc.close(); } private static boolean isLeapYear(int year) { if (year % 400 == 0) { return true; } if (year % 100 == 0) { return false; } if (year % 4 == 0) { return true; } return false; } }"], "perturbed_original": ["import java.io.IOException; import java.io.BufferedReader; import java.io.InputStreamReader; class Main { public static void main(String[] args) throws IOException {  = br.readLine()).equals(\"0 0\")) { String[] input = line.split(\" \"); int a = Integer.parseInt(input[0]); int b = Integer.parseInt(input[1]); StringBuilder sb = new StringBuilder();  <= b; now++) { if (now % 4 == 0) { if(now % 100  isNA = false; } }else{ sb.append(now).append(\"\\n\"); if (isNA) isNA = false; } } } if (isNA) { sb.append(\"NA\").append(\"\\n\"); } System.out.println(sb); } } }"], "original_ll": -0.7082327604293823, "sampled_ll": -0.393057644367218, "all_perturbed_sampled_ll": [-1.2355709075927734], "all_perturbed_original_ll": [-1.684006690979004], "perturbed_sampled_ll": -1.2355709075927734, "perturbed_original_ll": -1.684006690979004, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    a,b=map(int,raw_input().split(\" \"))\n    if a==0 and b==0:\n        break\n    uruu=[]\n    for i in [year for year in range(b+1) if year >=a]:\n        if i%4==0 and i%100!=0 or i%400==0:\n            uruu.append(str(i))\n    if len(uruu)!=0:\n        print '\\n'.join(uruu)\n    else:\n        print \"NA\"\n    print ''", "sampled": "def is_leap_year(year):\n    if year % 400 == 0:\n        return True\n    if year % 100 == 0:\n        return False\n    if year % 4 == 0:\n        return True\n    return False\n\nfirst_dataset = True\n\nwhile True:\n    a, b = map(int, input().split())\n    if a == 0 and b == 0:\n        break\n    \n    if not first_dataset:\n        print()\n    first_dataset = False\n    \n    leap_years = []\n    for year in range(a, b + 1):\n        if is_leap_year(year):\n            leap_years.append(year)\n    \n    if leap_years:\n        for year in leap_years:\n            print(year)\n    else:\n        print(\"NA\")\n", "perturbed_sampled": ["def is_leap_year(year): if year % 400  True return False first_dataset = True while True: a, b = map(int, input().split()) if a == 0 and b == 0: break if not first_dataset: print() first_dataset = False leap_years = [] for year in range(a, b + 1): if is_leap_year(year): leap_years.append(year) if leap_years: for year in leap_years: print(year) else: print(\"NA\")"], "perturbed_original": ["while True: a,b=map(int,raw_input().split(\" \")) if a==0 and b==0: break uruu=[] for i in [year for year in  uruu.append(str(i)) if len(uruu)!=0: print '\\n'.join(uruu) else: print \"NA\" print ''"], "original_ll": -1.3292608261108398, "sampled_ll": -0.612671434879303, "all_perturbed_sampled_ll": [-1.4638537168502808], "all_perturbed_original_ll": [-2.616881847381592], "perturbed_sampled_ll": -1.4638537168502808, "perturbed_original_ll": -2.616881847381592, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "int main(){double a,b;scanf(\"%lf%lf\",&a,&b);printf(\"%.8f\\n\",a*b*0.3025);return 0;}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    \n    double area_m2 = a * b;\n    double area_tsubo = area_m2 / 3.305785;\n    \n    printf(\"%.6f\\n\", area_tsubo);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int a, b; scanf(\"%d %d\", &a, &b); double area_m2 = a * b; double area_tsubo = area_m2 / 3.305785; printf(\"%.6f\\n\", area_tsubo); return 0; }"], "perturbed_original": ["int main(){double a,b;scanf(\"%lf%lf\",&a,&b);printf(\"%.8f\\n\",a*b*0.3025);return 0;}"], "original_ll": -1.6116118431091309, "sampled_ll": -1.4855016469955444, "all_perturbed_sampled_ll": [-1.7606723308563232], "all_perturbed_original_ll": [-1.6116118431091309], "perturbed_sampled_ll": -1.7606723308563232, "perturbed_original_ll": -1.6116118431091309, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tString[] input = new Scanner(System.in).nextLine().split(\" \");\n\t\t\n\t\tfloat a = Float.parseFloat(input[0]);\n\t\tfloat b = Float.parseFloat(input[1]);\n\t\t\n\t\tSystem.out.printf(\"%1$.6f\\n\", a*b/3.305785);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        \n        double area = a * b;\n        double tsubo = area / 3.305785;\n        \n        System.out.println(tsubo);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); double area = a  } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { String[] input = new Scanner(System.in).nextLine().split(\" \"); float a = Float.parseFloat(input[0]); float b = Float.parseFloat(input[1]); System.out.printf(\"%1$.6f\\n\", a*b/3.305785); } }"], "original_ll": -1.3691593408584595, "sampled_ll": -1.1617302894592285, "all_perturbed_sampled_ll": [-1.3380787372589111], "all_perturbed_original_ll": [-1.40873122215271], "perturbed_sampled_ll": -1.3380787372589111, "perturbed_original_ll": -1.40873122215271, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a, b = map(int, input().split())\nprint(a * b / 3.305785)", "sampled": "a, b = map(int, input().split())\narea_m2 = a * b\ntsubo = area_m2 / 3.305785\nprint(tsubo)\n", "perturbed_sampled": ["a, b = map(int, input().split()) area_m2 = a * b tsubo = area_m2 / 3.305785 print(tsubo)"], "perturbed_original": ["a, b = map(int, input().split()) print(a * b / 3.305785)"], "original_ll": -2.2521822452545166, "sampled_ll": -2.233154296875, "all_perturbed_sampled_ll": [-2.82417893409729], "all_perturbed_original_ll": [-2.6471636295318604], "perturbed_sampled_ll": -2.82417893409729, "perturbed_original_ll": -2.6471636295318604, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int wo, ws, n;\n  int i;\n\n  scanf ( \"%d%d%d\", &n, &wo, &ws );\n  for ( i = 1; i < n; ++i )\n  {\n    int o, s;\n\n    scanf ( \"%d%d\", &o, &s );\n    if ( s > ws\n      || ( s == ws && o < wo ) )\n    {\n      wo = o;\n      ws = s;\n    }\n  }\n\n  printf ( \"%d %d\\n\", wo, ws );\n\n  return ( EXIT_SUCCESS );\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int max_count = -1;\n    int winner_id = 100000;\n    \n    for (int i = 0; i < n; i++) {\n        int a, v;\n        scanf(\"%d %d\", &a, &v);\n        \n        if (v > max_count || (v == max_count && a < winner_id)) {\n            max_count = v;\n            winner_id = a;\n        }\n    }\n    \n    printf(\"%d %d\\n\", winner_id, max_count);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int  100000; for (int i = 0; i < n; i++) { int a, v; scanf(\"%d %d\", &a, &v); if (v > max_count || (v == max_count && a < winner_id)) { max_count = v; winner_id = a; } } printf(\"%d %d\\n\", winner_id, max_count); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> int main ( int argc, char *argv[ ] )  &n, &wo, &ws ); for ( i = 1; i < n; ++i ) { int o, s; scanf ( \"%d%d\", &o, &s ); if ( s > ws || ( s == ws  ws = s; } } printf ( \"%d %d\\n\", wo, ws ); return ( EXIT_SUCCESS ); }"], "original_ll": -1.079861044883728, "sampled_ll": -0.6797218322753906, "all_perturbed_sampled_ll": [-1.2371402978897095], "all_perturbed_original_ll": [-2.038435697555542], "perturbed_sampled_ll": -1.2371402978897095, "perturbed_original_ll": -2.038435697555542, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt(),x = 0,y,max = 0;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx = Math.max(x, (y = sc.nextInt()));\n\t\t\tif(y == x)max = i + 1;\n\t\t}\n\t\tSystem.out.println(max + \" \" + x);\n\t\t\n\t\tsc.close();\n\t\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        int winnerNumber = 0;\n        int maxCount = -1;\n        \n        for (int i = 0; i < n; i++) {\n            int participantNumber = sc.nextInt();\n            int count = sc.nextInt();\n            \n            if (count > maxCount || (count == maxCount && participantNumber < winnerNumber)) {\n                maxCount = count;\n                winnerNumber = participantNumber;\n            }\n        }\n        \n        System.out.println(winnerNumber + \" \" + maxCount);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args)  int winnerNumber = 0; int maxCount = -1; for (int i = 0; i < n; i++)  (count > maxCount || (count == maxCount && participantNumber < winnerNumber)) { maxCount = count; winnerNumber = participantNumber; } } System.out.println(winnerNumber + \" \" + maxCount); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int n = sc.nextInt(),x = 0,y,max = 0; for(int i = 0; i < n; i++){ x  + 1; } System.out.println(max + \" \" + x); sc.close(); } }"], "original_ll": -1.1425676345825195, "sampled_ll": -0.5862747430801392, "all_perturbed_sampled_ll": [-1.5140844583511353], "all_perturbed_original_ll": [-1.2745106220245361], "perturbed_sampled_ll": -1.5140844583511353, "perturbed_original_ll": -1.2745106220245361, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n=input()\nx=[0]*(n+1)\nfor i in range(n):\n  a,v=map(int, raw_input().split())\n  x[a]=v\nm=max(x)\nprint x.index(m), m", "sampled": "n = int(input())\nmax_count = -1\nwinner_id = float('inf')\n\nfor _ in range(n):\n    a, v = map(int, input().split())\n    if v > max_count or (v == max_count and a < winner_id):\n        max_count = v\n        winner_id = a\n\nprint(winner_id, max_count)\n", "perturbed_sampled": ["n = int(input()) max_count = -1 winner_id = float('inf') for _ in range(n): a, v = map(int, input().split())  < winner_id): max_count = v winner_id = a print(winner_id, max_count)"], "perturbed_original": ["n=input() x=[0]*(n+1) for i in range(n): a,v=map(int, raw_input().split()) x[a]=v m=max(x) print x.index(m), m"], "original_ll": -1.955080509185791, "sampled_ll": -1.0759934186935425, "all_perturbed_sampled_ll": [-2.1365034580230713], "all_perturbed_original_ll": [-2.44844651222229], "perturbed_sampled_ll": -2.1365034580230713, "perturbed_original_ll": -2.44844651222229, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint n;\n\tint i, j, k, l;\n\tint c;\n\t\n\twhile (scanf(\"%d\", &n) != EOF){\n\t\tc = 0;\n\t\tfor (i = 0; i <= 1000; i++){\n\t\t\tfor (j = 0; j <= 1000; j++){\n\t\t\t\tfor (k = 0; k <= 1000; k++){\n\t\t\t\t\tfor (l = 0; l <= 1000; l++){\n\t\t\t\t\t\tif (i + j + k + l == n){\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) != EOF) {\n        long long count = 0;\n        for (int a = 0; a <= 1000 && a <= n; a++) {\n            for (int b = 0; b <= 1000 && a + b <= n; b++) {\n                for (int c = 0; c <= 1000 && a + b + c <= n; c++) {\n                    int d = n - a - b - c;\n                    if (d >= 0 && d <= 1000) {\n                        count++;\n                    }\n                }\n            }\n        }\n        printf(\"%lld\\n\", count);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while (scanf(\"%d\", &n) != EOF) { long long count = 0; for (int a = 0; a <= 1000 && a <= n; a++) { for (int b = 0; b <= 1000 && a + b <= n; b++) { for (int  + c <= n; c++) { int d = n - a - b - c; if (d >= 0 && d <= 1000) {  }"], "perturbed_original": ["#include <stdio.h> int main(void) { int n; int i, j, k, l; int c; while (scanf(\"%d\", &n) != EOF){ c =  (j = 0; j <= 1000; j++){ for (k = 0;  1000; l++){ if (i + j + k + l == n){ c++; } } } } } printf(\"%d\\n\", c); } return (0); }"], "original_ll": -0.5304685235023499, "sampled_ll": -0.46994563937187195, "all_perturbed_sampled_ll": [-1.0917258262634277], "all_perturbed_original_ll": [-1.5559650659561157], "perturbed_sampled_ll": -1.0917258262634277, "perturbed_original_ll": -1.5559650659561157, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Sum of 4 Integers II\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tint[][] dp = new int[5][4001];\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = 0; j <= 1000; j++) {\n\t\t\t\tdp[i][i * j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tdp[i][0] = 1;\n\t\t}\n\n\t\tfor (int i = 2; i <= 4; i++) {\n\t\t\tfor (int j = 1; j <= 1000; j++) {\n\t\t\t\tdp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n\t\t\t}\n\t\t}\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tSystem.out.println(dp[4][parseInt(line)]);\n\t\t} // end while\n\t} // end main\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Precompute all possible sums for two numbers (a+b and c+d)\n        Map<Integer, Integer> sumCount = new HashMap<>();\n        for (int i = 0; i <= 1000; i++) {\n            for (int j = 0; j <= 1000; j++) {\n                int sum = i + j;\n                sumCount.put(sum, sumCount.getOrDefault(sum, 0) + 1);\n            }\n        }\n        \n        while (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            long count = 0;\n            \n            // For each possible sum of a+b, check if n-(a+b) exists as c+d\n            for (Map.Entry<Integer, Integer> entry : sumCount.entrySet()) {\n                int sum1 = entry.getKey();\n                int count1 = entry.getValue();\n                int sum2 = n - sum1;\n                \n                if (sumCount.containsKey(sum2)) {\n                    count += (long) count1 * sumCount.get(sum2);\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  Scanner sc = new Scanner(System.in); // Precompute all possible sums for two numbers (a+b and c+d) Map<Integer, Integer> sumCount = new HashMap<>(); for (int i = 0; i <= 1000; i++) { for (int j = 0; j <=  sumCount.getOrDefault(sum, 0) + 1); } } while (sc.hasNextInt()) { int n = sc.nextInt(); long count = 0; // For each possible sum of a+b, check if n-(a+b) exists as c+d for (Map.Entry<Integer, Integer>  = entry.getValue(); int sum2 = n - sum1; if (sumCount.containsKey(sum2)) { count += (long) count1 * sumCount.get(sum2); } } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import  Sum of 4 Integers II */ public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; int[][] dp = new int[5][4001]; for (int i = 1; i <= 4; i++) { for (int j = 0; j <= 1000; j++) { dp[i][i * j] = 1; } } for (int i = 1; i <= 4; i++) { dp[i][0] = 1; } for (int i = 2; i <= 4; i++) { for (int j = 1; j <= 1000; j++) { dp[i][j] =  } // end while } // end main }"], "original_ll": -0.7241489887237549, "sampled_ll": -0.6326650381088257, "all_perturbed_sampled_ll": [-1.7247711420059204], "all_perturbed_original_ll": [-1.119584083557129], "perturbed_sampled_ll": -1.7247711420059204, "perturbed_original_ll": -1.119584083557129, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    try:\n        n = input(); p = min(2000, n);\n        print (p+1)*(p+2)*(3*n-2*p+3)/6\n    except EOFError:\n        break", "sampled": "import sys\nfrom collections import defaultdict\n\ndef count_combinations(n):\n    # Count all possible sums of two numbers (a+b)\n    sum_count = defaultdict(int)\n    \n    # Calculate all possible sums a+b where 0 <= a, b <= 1000\n    for a in range(min(n+1, 1001)):\n        for b in range(min(n+1, 1001)):\n            if a + b <= n:\n                sum_count[a + b] += 1\n    \n    # For each sum of c+d, find how many a+b sums match to make n\n    result = 0\n    for c in range(min(n+1, 1001)):\n        for d in range(min(n+1, 1001)):\n            if c + d <= n:\n                needed = n - (c + d)\n                if needed in sum_count:\n                    result += sum_count[needed]\n    \n    return result\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    print(count_combinations(n))\n", "perturbed_sampled": ["import sys from collections import defaultdict def count_combinations(n): #  defaultdict(int) # Calculate all possible sums a+b where 0 <=  b in range(min(n+1, 1001)): if a + b <= n: sum_count[a + b] += 1 # For each sum of c+d, find how many a+b sums match to make n result = 0 for c in range(min(n+1, 1001)): for d in range(min(n+1, 1001)): if c + d <= n: needed =  += sum_count[needed] return result for line in sys.stdin: n = int(line.strip()) print(count_combinations(n))"], "perturbed_original": ["while 1: try: n = input(); p = min(2000, n); print (p+1)*(p+2)*(3*n-2*p+3)/6 except EOFError: break"], "original_ll": -2.1952428817749023, "sampled_ll": -0.9395961165428162, "all_perturbed_sampled_ll": [-2.2102766036987305], "all_perturbed_original_ll": [-2.434776544570923], "perturbed_sampled_ll": -2.2102766036987305, "perturbed_original_ll": -2.434776544570923, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// AOJ 0098: Maximum Sum Sequence II \n// 2017.8.15 bal4u@uu\n// 2017.11.1 retry\n\n#include <stdio.h>\n\nint a[102][102];\nint s[102][102];\n\nchar buf[1000], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, r, c, k, ans;\n\n\tfgets(p=buf, 10, stdin), n = getint();\n\tfor (r = 0; r < n; r++) {\n\t\tfgets(p=buf, sizeof(buf), stdin);\n\t\tfor (c = 0; c < n; c++, p++) {\n\t\t\tif (*p == '-') p++, a[r][c] = -getint();\n\t\t\telse                a[r][c] =  getint();\n\t\t}\n\t}\n\n\tfor (r = 0; r < n; r++)\n\t\tfor (c = 0; c < n; c++)\n\t\t\ts[r][c+1] += s[r][c] + a[r][c];\n\n\tans = s[0][1];\n\tfor (c = 0; c < n; c++) for (k = c+1; k <= n; k++) {\n\t\tint t = 0;\n\t\tfor (r = 0; r < n; r++) {\n\t\t\tif (t < 0) t  = s[r][k] - s[r][c];\n\t\t\telse       t += s[r][k] - s[r][c];\n\t\t\tif (t > ans) ans = t;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int a[100][100];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n    \n    int max_sum = a[0][0];\n    \n    for (int top = 0; top < n; top++) {\n        int col_sum[100] = {0};\n        \n        for (int bottom = top; bottom < n; bottom++) {\n            for (int j = 0; j < n; j++) {\n                col_sum[j] += a[bottom][j];\n            }\n            \n            int current_sum = 0;\n            for (int j = 0; j < n; j++) {\n                current_sum += col_sum[j];\n                if (current_sum > max_sum) {\n                    max_sum = current_sum;\n                }\n                if (current_sum < 0) {\n                    current_sum = 0;\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", max_sum);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() {  0; i < n; i++) { for (int j = 0; j < n; j++) { scanf(\"%d\", &a[i][j]); } } int max_sum = a[0][0]; for (int top = 0; top < n; top++) { int col_sum[100] = {0}; for (int bottom = top; bottom < n; bottom++)  { col_sum[j] += a[bottom][j]; } int current_sum = 0; for (int  col_sum[j]; if (current_sum > max_sum) { max_sum = current_sum; } if (current_sum < 0) { current_sum = 0; } } } } printf(\"%d\\n\", max_sum); return 0; }"], "perturbed_original": ["// AOJ 0098: Maximum Sum Sequence II // 2017.8.15 bal4u@uu // 2017.11.1 retry #include <stdio.h> int a[102][102]; int s[102][102]; char buf[1000], *p; int getint() { int n = 0; while (*p >= '0') n  } int main() { int n, r, c, k, ans; fgets(p=buf,  < n; r++) { fgets(p=buf,  p++) { if (*p == '-') p++, a[r][c] = -getint(); else a[r][c] = getint(); } } for (r = 0; r < n; r++) for (c = 0; c < n; c++) s[r][c+1] += s[r][c] + a[r][c];  c++) for (k = c+1; k <= n; k++) { int t = 0; for (r = 0; r < n;  s[r][c]; else t += s[r][k] - s[r][c]; if (t > ans) ans = t; } } printf(\"%d\\n\", ans); return 0; }"], "original_ll": -1.1966402530670166, "sampled_ll": -0.3611051142215729, "all_perturbed_sampled_ll": [-1.0496480464935303], "all_perturbed_original_ll": [-1.8034101724624634], "perturbed_sampled_ll": -1.0496480464935303, "perturbed_original_ll": -1.8034101724624634, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class\nMain\n{\n  public void\n  run (\n    final java.util.Scanner sc,\n    final java.io.PrintStream out\n    )\n  {\n    int[ ][ ] a;\n    int N;\n    int i, j, k, l;\n    int res;\n\n    N = sc.nextInt ( );\n    a = new int[ N ][ N + 1 ];\n    for ( i = 0; i < N; ++i )\n    for ( j = 1; j <= N ; ++j )\n      a[ i ][ j ] = sc.nextInt ( );\n\n    for ( i = 0; i < N; ++i )\n    for ( j = 1; j <= N; ++j )\n      a[ i ][ j ] += a[ i ][ j - 1 ];\n\n    res = a[ 0 ][ 1 ];\n    for ( i = 0; i < N; ++i )\n    for ( j = i + 1; j <= N; ++j )\n    {\n      for ( k = 0; k < N; ++k )\n      {\n        int t = 0;\n\n        for ( l = k; l < N; ++l )\n        {\n          t += a[ l ][ j ] - a[ l ][ i ];\n          res = Math.max ( res, t );\n        }\n      }\n    }\n\n    out.println ( res );\n  }\n\n  public static void\n  main (\n    String[ ] args\n    )\n  {\n    ( new Main ( ) ).run ( new java.util.Scanner ( System.in ), System.out );\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] a = new int[n][n];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                a[i][j] = sc.nextInt();\n            }\n        }\n        \n        long maxSum = Long.MIN_VALUE;\n        \n        for (int top = 0; top < n; top++) {\n            int[] colSum = new int[n];\n            \n            for (int bottom = top; bottom < n; bottom++) {\n                for (int col = 0; col < n; col++) {\n                    colSum[col] += a[bottom][col];\n                }\n                \n                long currentSum = 0;\n                long maxEndingHere = Long.MIN_VALUE;\n                \n                for (int col = 0; col < n; col++) {\n                    currentSum += colSum[col];\n                    maxEndingHere = Math.max(maxEndingHere, currentSum);\n                    if (currentSum < 0) {\n                        currentSum = 0;\n                    }\n                }\n                \n                maxSum = Math.max(maxSum, maxEndingHere);\n            }\n        }\n        \n        System.out.println(maxSum);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] a = new int[n][n]; for (int i = 0; i < n; i++) { for (int j = 0; j <  = Long.MIN_VALUE; for (int top = 0; top < n; top++) { int[] colSum = new int[n]; for  (int col = 0; col < n;  long maxEndingHere = Long.MIN_VALUE; for  += colSum[col]; maxEndingHere = Math.max(maxEndingHere, currentSum); if (currentSum < 0) { currentSum = 0; } } maxSum = Math.max(maxSum, maxEndingHere); } } System.out.println(maxSum); sc.close(); } }"], "perturbed_original": ["public class Main { public void run ( final java.util.Scanner sc, final  int i, j, k, l; int res; N = sc.nextInt ( ); a = new int[ N ][ N + 1 ]; for ( i = 0; i < N; ++i ) for (  ( i = 0; i < N; ++i ) for ( j = 1; j <= N; ++j ) a[ i ][ j ] += a[ i ][ j - 1 ]; res = a[ 0 ][ 1 ]; for ( i = 0; i < N; ++i ) for ( j = i + 1; j <= N; ++j ) { for (  < N; ++l ) { t += a[ l ][ j ] - a[ l ][ i ]; res = Math.max ( res, t ); } } } out.println ( res ); } public static void main ( String[ ] args ) { ( new  System.out ); } }"], "original_ll": -0.8061448931694031, "sampled_ll": -0.34165096282958984, "all_perturbed_sampled_ll": [-1.154769778251648], "all_perturbed_original_ll": [-1.5094736814498901], "perturbed_sampled_ll": -1.154769778251648, "perturbed_original_ll": -1.5094736814498901, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0098\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\ndef calc_points(n, array):\n    # \u53f3\u4e0b\u304b\u3089(x, y)\u307e\u3067\u306e\u9577\u65b9\u5f62\u306b\u542b\u307e\u308c\u308b\u5024\u306e\u548c\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for y in range(n - 1, -1, -1):\n        for x in range(n - 1, -1, -1):\n            dp[y][x] = dp[y+1][x] + dp[y][x+1] - dp[y+1][x+1] + array[y][x]\n    return dp\n\n\ndef solve(n, array):\n    ans = []\n    dp = calc_points(n, array)\n\n    for sy in range(n + 1):\n        for sx in range(n + 1):\n            for ey in range(sy, n + 1):\n                for ex in range(sx, n + 1):\n                    s1 = dp[sy][sx] #  \u53f3\u4e0b\u304b\u3089\u59cb\u70b9\u307e\u3067\n                    s2 = dp[sy][ex] #  \u91cd\u306a\u308a\u90e8\u5206\n                    s3 = dp[ey][sx] #  \u91cd\u306a\u308a\u90e8\u5206\n                    s4 = dp[ey][ex] #  \u91cd\u306a\u308a\u306e\u91cd\u306a\u308a\u90e8\u5206\n                    s = s1 - s2 -s3 + s4 #  (sx, sy) - (ex, ey) \u9577\u65b9\u5f62\u306e\u7f8e\u5473\u3057\u3055\u30dd\u30a4\u30f3\u30c8\n                    # area = abs(sy - ey) * abs(sx - ex) #  \u9577\u65b9\u5f62\u306e\u9762\u7a4d\n                    ans.append(s)\n    return max(ans)\n\n\ndef main(args):\n    array = []\n    # n = 3\n    # array.append([1, -2, 3])\n    # array.append([-4, 5, 6])\n    # array.append([7, 8, -9])\n\n    n = int(input())\n    for _ in range(n):\n        array.append([int(x) for x in input().split()])\n    ans = solve(n, array)\n    print(ans)\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n", "sampled": "def max_subarray_sum(arr):\n    if not arr:\n        return 0\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\nn = int(input())\nmatrix = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    matrix.append(row)\n\nmax_sum = float('-inf')\n\nfor top in range(n):\n    temp = [0] * n\n    for bottom in range(top, n):\n        for col in range(n):\n            temp[col] += matrix[bottom][col]\n        current_max = max_subarray_sum(temp)\n        max_sum = max(max_sum, current_max)\n\nprint(max_sum)\n", "perturbed_sampled": ["def max_subarray_sum(arr): if not arr: return 0 max_sum = float('-inf') current_sum =  num) max_sum = max(max_sum, current_sum) return max_sum n = int(input()) matrix = [] for _ in range(n): row = list(map(int, input().split())) matrix.append(row) max_sum = float('-inf')  bottom in range(top, n): for col in range(n): temp[col] += matrix[bottom][col] current_max = max_subarray_sum(temp) max_sum = max(max_sum, current_max) print(max_sum)"], "perturbed_original": ["# -*- coding: utf-8 -*- \"\"\" http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0098 \"\"\" import sys from sys import stdin input = stdin.readline def calc_points(n, array): # \u53f3\u4e0b\u304b\u3089(x, y)\u307e\u3067\u306e\u9577\u65b9\u5f62\u306b\u542b\u307e\u308c\u308b\u5024\u306e\u548c dp = [[0] * (n + 1) for _ in range(n + 1)] for y in range(n - 1, -1, -1): for x in range(n - 1, -1, -1): dp[y][x] = dp[y+1][x] + dp[y][x+1] - dp[y+1][x+1] +  for sx in range(n + 1): for ey in range(sy, n + 1): for ex in range(sx, n + 1): s1 = dp[sy][sx] # \u53f3\u4e0b\u304b\u3089\u59cb\u70b9\u307e\u3067 s2 = dp[sy][ex] # \u91cd\u306a\u308a\u90e8\u5206 s3 = dp[ey][sx] # \u91cd\u306a\u308a\u90e8\u5206 s4 = dp[ey][ex] #  (sx, sy) - (ex, ey) \u9577\u65b9\u5f62\u306e\u7f8e\u5473\u3057\u3055\u30dd\u30a4\u30f3\u30c8 # area = abs(sy - ey) * abs(sx - ex) # \u9577\u65b9\u5f62\u306e\u9762\u7a4d ans.append(s) return max(ans) def main(args): array =  array.append([-4, 5, 6]) # array.append([7, 8, -9]) n = int(input()) for _ in  print(ans) if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -1.0119495391845703, "sampled_ll": -0.589491069316864, "all_perturbed_sampled_ll": [-1.7062852382659912], "all_perturbed_original_ll": [-1.6646618843078613], "perturbed_sampled_ll": -1.7062852382659912, "perturbed_original_ll": -1.6646618843078613, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <assert.h>\nint main(void){\n\tint i,x,n,q,a,v,aaa=0,vvv=0,vv[9000],f[1000001],next[1000001],prev[1000001];\n\tscanf(\"%d %d\",&n,&q);\n\tfor(i=0;i<=n;i++){f[i]=0;prev[i]=0;next[i]=0;}\n\tfor(i=0;i<9000;i++)vv[i]=0;\n\tfor(;q>0;q--){\n\t\tscanf(\"%d %d\",&a,&v);\n\n\t\tx=f[a];\n\n\t\tif(x>0){\n\t\t\tif(vv[x]==a){\n\t\t\t\tif(next[a]>0){vv[x]=next[a];}\n\t\t\t\telse vv[x]=0;\n\t\t\t}\n\t\t\tnext[prev[a]]=next[a];\n\t\t\tprev[next[a]]=prev[a];\n\t\t\tprev[0]=0;next[0]=0;\n\t\t}\n\n\t\tf[a]+=v;x+=v;\n\t\t\n\t\tif(x>0){\n\t\t\tif(a<vv[x] || vv[x]==0){\n\t\t\t\tprev[a]=0;\n\t\t\t\tnext[a]=vv[x];\n\t\t\t\tprev[vv[x]]=a;\n\t\t\t\tprev[0]=0;\n\t\t\t\tvv[x]=a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti=vv[x];\n\t\t\t\twhile(a>next[i] && next[i]>0){i=next[i];assert(i>0 && i<=n);}\n\t\t\t\tprev[a]=i;\n\t\t\t\tnext[a]=next[i];\n\t\t\t\tprev[next[i]]=a;\n\t\t\t\tnext[i]=a;\n\t\t\t\tprev[0]=0;\n\t\t\t}\n\t\t}else{prev[a]=0;next[a]=0;}\n\t\t\n\t\tif(v>0){if(x>vvv || (x==vvv && a<aaa)){vvv=x;aaa=a;}}\n\t\telse if(a==aaa){\n\t\t\ti=vvv;\n\t\t\t//for(i=vvv; vv[i]<1 && i>0 ;i--){assert(i>0 && i<9000);}\n\t\t\tvvv=i;\n\t\t\t//aaa=vv[i];\n\t\t}\n\t\tprintf(\"%d %d\\n\",aaa,vvv);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    long long *counts = (long long *)calloc(n + 1, sizeof(long long));\n    \n    int max_id = 1;\n    long long max_count = 0;\n    \n    for (int i = 0; i < q; i++) {\n        int a, v;\n        scanf(\"%d %d\", &a, &v);\n        \n        counts[a] += v;\n        \n        max_id = 1;\n        max_count = counts[1];\n        for (int j = 2; j <= n; j++) {\n            if (counts[j] > max_count) {\n                max_count = counts[j];\n                max_id = j;\n            }\n        }\n        \n        printf(\"%d %lld\\n\", max_id, max_count);\n    }\n    \n    free(counts);\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int main() { int n, q; scanf(\"%d %d\", &n, &q); long long *counts =  = 0; i < q; i++) { int a, v; scanf(\"%d %d\", &a, &v); counts[a] += v; max_id = 1; max_count = counts[1]; for (int j = 2; j <= n; j++) { if (counts[j] > max_count) { max_count = counts[j]; max_id = j; } } printf(\"%d %lld\\n\", max_id, max_count); } free(counts); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <assert.h> int main(void){ int i,x,n,q,a,v,aaa=0,vvv=0,vv[9000],f[1000001],next[1000001],prev[1000001]; scanf(\"%d %d\",&n,&q); for(i=0;i<=n;i++){f[i]=0;prev[i]=0;next[i]=0;} for(i=0;i<9000;i++)vv[i]=0; for(;q>0;q--){ scanf(\"%d %d\",&a,&v); x=f[a]; if(x>0){ if(vv[x]==a){ if(next[a]>0){vv[x]=next[a];} else vv[x]=0; } next[prev[a]]=next[a]; prev[next[a]]=prev[a]; prev[0]=0;next[0]=0; } f[a]+=v;x+=v; if(x>0){ if(a<vv[x] || vv[x]==0){ prev[a]=0; next[a]=vv[x]; prev[vv[x]]=a; prev[0]=0; vv[x]=a; } else{  if(a==aaa){ i=vvv; //for(i=vvv; vv[i]<1 && i>0 ;i--){assert(i>0 && i<9000);} vvv=i; //aaa=vv[i]; } printf(\"%d %d\\n\",aaa,vvv); } return 0; }"], "original_ll": -1.3238756656646729, "sampled_ll": -0.5651220679283142, "all_perturbed_sampled_ll": [-1.0310522317886353], "all_perturbed_original_ll": [-1.6190845966339111], "perturbed_sampled_ll": -1.0310522317886353, "perturbed_original_ll": -1.6190845966339111, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class\nMain\n{\n  public void\n  run (\n    final java.util.Scanner sc,\n    final java.io.PrintStream out\n    )\n  {\n    Pair[ ] heap;\n    int[ ]  paeh;\n    int n, q;\n    int i;\n    \n    n = sc.nextInt ( );\n    q = sc.nextInt ( );\n\n    heap = new Pair[ n ];\n    paeh = new int[ n + 1 ];\n    for ( i = 1; i <= n; ++i )\n    {\n      paeh[ i ] = i - 1;\n      heap[ paeh[ i ] ] = new Pair ( i, 0 );\n    }\n\n    for ( ; q > 0; --q )\n    {\n      int a, v, b;\n\n      a = sc.nextInt ( );\n      v = sc.nextInt ( );\n      b = heap[ heap.length - 1 ].index;\n\n      swap ( heap, paeh[ a ], paeh[ b ] );\n      swap ( paeh, a, heap[ paeh[ a ] ].index );\n      for ( ; ; )\n      {\n        if ( paeh[ b ] * 2 + 2 < heap.length - 1\n          && heap[ paeh[ b ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] * 2 + 1 ] ) < 0\n          && heap[ paeh[ b ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] ] ) < 0 )\n        {\n          swap ( heap, paeh[ b ], paeh[ b ] * 2 + 2 );\n          swap ( paeh, b, heap[ paeh[ b ] ].index );\n        }\n        else if ( paeh[ b ] * 2 + 1 < heap.length - 1\n               && heap[ paeh[ b ] * 2 + 1 ].compareTo ( heap[ paeh[ b ] ] ) < 0 )\n        {\n          swap ( heap, paeh[ b ], paeh[ b ] * 2 + 1 );\n          swap ( paeh, b, heap[ paeh[ b ] ].index );\n        }\n        else break ;\n      }\n      heap[ paeh[ a ] ].value += v;\n      for ( ; ; )\n      {\n        if ( paeh[ a ] > 0\n          && heap[ paeh[ a ] ].compareTo ( heap[ ( paeh[ a ] - 1 ) / 2 ] ) < 0 )\n        {\n          swap ( heap, paeh[ a ], ( paeh[ a ] - 1 ) / 2 );\n          swap ( paeh, a, heap[ paeh[ a ] ].index );\n        }\n        else break ;\n      }\n      System.out.println ( heap[ 0 ].index + \" \" + heap[ 0 ].value );\n    }\n  }\n\n  private static void\n  swap (\n    int[ ] a,\n    int i,\n    int j\n    )\n  {\n    final int t = a[ i ];\n    a[ i ] = a[ j ];\n    a[ j ] = t;\n  }\n\n  private static <T> void\n  swap (\n    T[ ] a,\n    int i,\n    int j\n    )\n  {\n    final T t = a[ i ];\n    a[ i ] = a[ j ];\n    a[ j ] = t;\n  }\n\n  public static void\n  main (\n    final String[ ] args\n    )\n  {\n    ( new Main ( ) ).run ( new java.util.Scanner ( System.in ), System.out );\n  }\n\n  private class\n  Pair\n  implements Comparable<Pair>\n  {\n    public final int index;\n    public       int value;\n\n    public\n    Pair (\n      final int index,\n      final int value\n      )\n    {\n      this.index = index;\n      this.value = value;\n    }\n\n    public int\n    compareTo (\n      final Pair obj\n      )\n    {\n      if ( this.value == obj.value )\n        return ( this.index - obj.index );\n      return ( obj.value - this.value );\n    }\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int q = sc.nextInt();\n        \n        Map<Integer, Integer> counts = new HashMap<>();\n        \n        for (int i = 0; i < q; i++) {\n            int a = sc.nextInt();\n            int v = sc.nextInt();\n            \n            counts.put(a, counts.getOrDefault(a, 0) + v);\n            \n            int maxCount = Integer.MIN_VALUE;\n            int maxParticipant = Integer.MAX_VALUE;\n            \n            for (int participant = 1; participant <= n; participant++) {\n                int count = counts.getOrDefault(participant, 0);\n                if (count > maxCount || (count == maxCount && participant < maxParticipant)) {\n                    maxCount = count;\n                    maxParticipant = participant;\n                }\n            }\n            \n            System.out.println(maxParticipant + \" \" + maxCount);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {  Map<Integer, Integer> counts = new HashMap<>(); for (int i = 0; i < q; i++) { int a = sc.nextInt(); int v = sc.nextInt(); counts.put(a, counts.getOrDefault(a, 0) + v); int maxCount = Integer.MIN_VALUE; int maxParticipant = Integer.MAX_VALUE; for (int participant = 1; participant <= n; participant++) { int count = counts.getOrDefault(participant, 0); if (count > maxCount || (count == maxCount && participant < maxParticipant))  + \" \" + maxCount); } sc.close(); } }"], "perturbed_original": ["public class Main { public void run ( final java.util.Scanner sc, final java.io.PrintStream out ) { Pair[ ] heap; int[ ] paeh;  q = sc.nextInt ( );  n + 1 ]; for ( i = 1; i <= n; ++i ) { paeh[ i ] = i - 1; heap[ paeh[ i ] ] = new Pair (  sc.nextInt ( ); v = sc.nextInt ( ); b = heap[ heap.length - 1 ].index; swap  ( paeh, a, heap[ paeh[ a ] ].index ); for ( ; ; ) { if ( paeh[ b ] * 2 + 2 < heap.length - 1 && heap[ paeh[ b ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] * 2 + 1 ] ) < 0 && heap[ paeh[ b ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] ] ) < 0 ) { swap ( heap, paeh[ b ], paeh[ b ] * 2 +  ].index ); } else if ( paeh[ b ] * 2 + 1 < heap.length - 1 && heap[ paeh[ b ] * 2 + 1 ].compareTo ( heap[ paeh[ b ] ] )  paeh[ b  heap[ paeh[ b ] ].index ); } else break ;  ; ; ) { if ( paeh[ a ] > 0 && heap[ paeh[ a ] ].compareTo ( heap[  ) < 0 ) { swap ( heap, paeh[ a ],  swap ( paeh, a,  + heap[ 0 ].value ); } } private static void swap ( int[ ]  = a[ i ]; a[ i ] = a[ j ]; a[ j ] = t; } private static <T> void swap ( T[ ] a, int i, int j ) { final T t = a[ i ]; a[ i ] = a[ j ]; a[ j ] = t; } public static void main ( final String[ ] args ) { ( new Main ( ) ).run ( new java.util.Scanner ( System.in ), System.out ); } private class Pair implements Comparable<Pair> { public final int index; public int value; public Pair (  index; this.value = value; } public int compareTo ( final Pair obj ) { if ( this.value == obj.value ) return ( this.index - obj.index ); return ( obj.value - this.value ); } } }"], "original_ll": -0.6501765251159668, "sampled_ll": -0.521535336971283, "all_perturbed_sampled_ll": [-1.346252202987671], "all_perturbed_original_ll": [-1.3584718704223633], "perturbed_sampled_ll": -1.346252202987671, "perturbed_original_ll": -1.3584718704223633, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0099\n\"\"\"\nimport sys\nimport bisect\n\n\n\ndef main(args):\n    #data = [(1, 4), (2, 5), (1, 3), (3, 6), (2, 7)]\n    #data = [(1, 4), (2, 5), (2, -3),(3, 4), (1, -1)]\n    fisher, event = [int(x) for x in input().split(' ')]\n    fishes = [0 for _ in range(fisher + 1)]\n\n    winner = 9999999999\n    max_fish = -1\n    for _ in range(event):\n        id, fish = [int(x) for x in input().strip().split(' ')]\n        fishes[id] += fish\n        if fish > 0:\n            if fishes[id] > max_fish:\n                max_fish = fishes[id]\n                winner = id\n            elif fishes[id] == max_fish:\n                winner = min(winner, id)\n            else:\n                pass\n        else:\n            max_fish = max(fishes)\n            winner = fishes.index(max_fish)\n        print('{} {}'.format(winner, max_fish))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])", "sampled": "n, q = map(int, input().split())\ncounts = [0] * (n + 1)\n\nfor _ in range(q):\n    a, v = map(int, input().split())\n    counts[a] += v\n    \n    max_count = max(counts[1:n+1])\n    for i in range(1, n + 1):\n        if counts[i] == max_count:\n            print(i, max_count)\n            break\n", "perturbed_sampled": ["n, q = map(int,  in range(q): a, v = map(int, input().split()) counts[a] += v max_count = max(counts[1:n+1]) for i in range(1, n + 1): if counts[i] == max_count: print(i, max_count) break"], "perturbed_original": ["# -*- coding: utf-8 -*- \"\"\" http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0099 \"\"\" import sys import bisect def main(args): #data = [(1, 4), (2, 5), (1, 3), (3, 6), (2, 7)] #data = [(1, 4), (2, 5), (2, -3),(3, 4), (1, -1)] fisher,  [0 for _ in range(fisher +  ')] fishes[id] += fish if fish > 0: if fishes[id] > max_fish: max_fish = fishes[id] winner = id elif fishes[id] == max_fish: winner = min(winner, id) else: pass else: max_fish = max(fishes) winner = fishes.index(max_fish) print('{} {}'.format(winner, max_fish)) if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -1.0935108661651611, "sampled_ll": -0.7770909070968628, "all_perturbed_sampled_ll": [-2.228785753250122], "all_perturbed_original_ll": [-1.6339490413665771], "perturbed_sampled_ll": -2.228785753250122, "perturbed_original_ll": -1.6339490413665771, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\tint n;\n\tint staff,price,sold;\n\twhile(1){\n\t\tint i,j = 0;\n\t\tint sccess[4000];\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0)\n\t\t\treturn 0;\n\t\t\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d %d %d\", &staff, &price, &sold);\n\t\t\tif(price * sold >= 1000000){\n\t\t\t\tsccess[j] = staff;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(j == 0){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\tfor(i = 0; j > i; i++){\n\t\t\tprintf(\"%d\\n\", sccess[i]);\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n != 0) {\n        int ids[4000];\n        long long sales[4000];\n        int count = 0;\n        \n        for(int i = 0; i < n; i++) {\n            int id, p, q;\n            scanf(\"%d %d %d\", &id, &p, &q);\n            \n            int found = -1;\n            for(int j = 0; j < count; j++) {\n                if(ids[j] == id) {\n                    found = j;\n                    break;\n                }\n            }\n            \n            if(found == -1) {\n                ids[count] = id;\n                sales[count] = (long long)p * q;\n                count++;\n            } else {\n                sales[found] += (long long)p * q;\n            }\n        }\n        \n        int found_any = 0;\n        for(int i = 0; i < count; i++) {\n            if(sales[i] >= 1000000) {\n                printf(\"%d\\n\", ids[i]);\n                found_any = 1;\n            }\n        }\n        \n        if(!found_any) {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; while(scanf(\"%d\", &n) && n != 0) { int ids[4000]; long long sales[4000]; int count = 0; for(int  p, q; scanf(\"%d %d  id) { found = j; break; } } if(found == -1) { ids[count] = id; sales[count] = (long long)p * q; count++; } else { sales[found] += (long long)p * q; } } int found_any = 0; for(int i = 0; i < count; i++) { if(sales[i] >= 1000000) { printf(\"%d\\n\", ids[i]); found_any = 1; } } if(!found_any) { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int n; int staff,price,sold; while(1){ int i,j = 0; int sccess[4000]; scanf(\"%d\", &n); if(n == 0) return 0;  &sold); if(price * sold >= 1000000){ sccess[j] = staff; j++; } } if(j == 0){ printf(\"NA\\n\"); } for(i = 0; j > i; i++){ printf(\"%d\\n\", sccess[i]); } } }"], "original_ll": -1.182053565979004, "sampled_ll": -0.5563002824783325, "all_perturbed_sampled_ll": [-1.3134368658065796], "all_perturbed_original_ll": [-1.9845452308654785], "perturbed_sampled_ll": -1.3134368658065796, "perturbed_original_ll": -1.9845452308654785, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Sale Result\npublic class Main{\n\n\tstatic class P implements Comparable<P>{\n\t\tpublic int o;\n\t\tpublic long s;\n\t\tpublic int compareTo(P o) {\n\t\t\treturn this.o-o.o;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tList<Integer> l = new ArrayList<Integer>();\n\t\t\tP[] s = new P[4001];\n\t\t\tint id = 0;\n\t\t\twhile(n--!=0){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tif(s[d]==null){\n\t\t\t\t\ts[d] = new P();\n\t\t\t\t\ts[d].o = id++;\n\t\t\t\t}\n\t\t\t\tlong p = sc.nextLong();\n\t\t\t\tlong k = sc.nextLong();\n\t\t\t\ts[d].s+=p*k;\n\t\t\t}\n\t\t\tfor(int i=1;i<4001;i++)if(s[i]!=null&&1000000<=s[i].s)l.add(i);\n\t\t\tCollections.sort(l);\n\t\t\tif(l.isEmpty())System.out.println(\"NA\");\n\t\t\telse for(int i:l)System.out.println(i);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            LinkedHashMap<Integer, Long> sales = new LinkedHashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                int id = sc.nextInt();\n                long price = sc.nextLong();\n                long quantity = sc.nextLong();\n                long amount = price * quantity;\n                \n                sales.put(id, sales.getOrDefault(id, 0L) + amount);\n            }\n            \n            boolean found = false;\n            for (Map.Entry<Integer, Long> entry : sales.entrySet()) {\n                if (entry.getValue() >= 1000000) {\n                    System.out.println(entry.getKey());\n                    found = true;\n                }\n            }\n            \n            if (!found) {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  new Scanner(System.in); while (true) { int n = sc.nextInt();  i++) { int id = sc.nextInt(); long price = sc.nextLong(); long quantity = sc.nextLong(); long amount = price * quantity; sales.put(id, sales.getOrDefault(id, 0L) + amount); } boolean found = false; for (Map.Entry<Integer, Long> entry : sales.entrySet()) { if (entry.getValue() >= 1000000) { System.out.println(entry.getKey()); found = true; } } if (!found) { System.out.println(\"NA\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Scanner; //Sale Result public class Main{ static class P implements Comparable<P>{ public int o; public long s; public int compareTo(P o) { return this.o-o.o; } } public  while(true){ int n =  new P[4001]; int id = 0; while(n--!=0){ int d = sc.nextInt(); if(s[d]==null){ s[d] = new P(); s[d].o = id++; } long p = sc.nextLong(); long k = sc.nextLong(); s[d].s+=p*k; } for(int i=1;i<4001;i++)if(s[i]!=null&&1000000<=s[i].s)l.add(i); Collections.sort(l); if(l.isEmpty())System.out.println(\"NA\"); else for(int i:l)System.out.println(i); } } }"], "original_ll": -1.0943036079406738, "sampled_ll": -0.5078475475311279, "all_perturbed_sampled_ll": [-1.1007739305496216], "all_perturbed_original_ll": [-1.7347700595855713], "perturbed_sampled_ll": -1.1007739305496216, "perturbed_original_ll": -1.7347700595855713, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nfrom collections import defaultdict\n\nfor s in sys.stdin:\n    n = int(s)\n    if n == 0:\n        break\n\n    d = defaultdict(int)\n    keys = []\n    for i in range(n):\n        e, p, q = map(int, input().split())\n        d[e] += p * q\n        if e not in keys:\n            keys.append(e)\n\n    # remove dup\n    is_exist = False\n\n    for key in keys:\n        v = d[key]\n        if v >= 1000000:\n            print(key)\n            is_exist = True\n\n    if not is_exist:\n        print('NA')", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    sales = {}\n    order = []\n    \n    for _ in range(n):\n        line = input().split()\n        employee_id = line[0]\n        p = int(line[1])\n        q = int(line[2])\n        \n        if employee_id not in sales:\n            sales[employee_id] = 0\n            order.append(employee_id)\n        \n        sales[employee_id] += p * q\n    \n    result = []\n    for employee_id in order:\n        if sales[employee_id] >= 1000000:\n            result.append(employee_id)\n    \n    if result:\n        for emp_id in result:\n            print(emp_id)\n    else:\n        print(\"NA\")\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break sales = {} order = [] for _ in range(n): line = input().split() employee_id = line[0] p = int(line[1]) q = int(line[2]) if employee_id not in sales:  1000000: result.append(employee_id) if result: for emp_id in result: print(emp_id) else: print(\"NA\")"], "perturbed_original": ["#  from collections import defaultdict for s in sys.stdin: n = int(s) if n == 0: break d = defaultdict(int) keys = [] for i in range(n): e, p, q = map(int, input().split()) d[e] += p * q if e not in keys: keys.append(e) # remove dup is_exist = False for  print(key) is_exist = True if not is_exist: print('NA')"], "original_ll": -1.0894546508789062, "sampled_ll": -0.8159208297729492, "all_perturbed_sampled_ll": [-1.8015305995941162], "all_perturbed_original_ll": [-2.0225555896759033], "perturbed_sampled_ll": -1.8015305995941162, "perturbed_original_ll": -2.0225555896759033, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n\tint n;\n\tchar in[1024], *ptr;\n\n\tscanf(\"%d \", &n);\n\n\twhile (n--) {\n\t\tfgets(in, 1023, stdin);\n\t\tptr = strstr(in, \"Hoshino\");\n\t\twhile (ptr != NULL) {\n\t\t\tptr[6] = 'a';\n\t\t\tptr = strstr(ptr, \"Hoshino\");\n\t\t}\n\t\tprintf(\"%s\", in);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    char line[1001];\n    char result[1001];\n    \n    scanf(\"%d\\n\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        fgets(line, sizeof(line), stdin);\n        \n        int len = strlen(line);\n        if (line[len-1] == '\\n') {\n            line[len-1] = '\\0';\n            len--;\n        }\n        \n        int j = 0;\n        int k = 0;\n        \n        while (j < len) {\n            if (j + 6 < len && strncmp(&line[j], \"Hoshino\", 7) == 0) {\n                strcpy(&result[k], \"Hoshina\");\n                k += 7;\n                j += 7;\n            } else if (j + 6 == len && strncmp(&line[j], \"Hoshino\", 7) == 0) {\n                strcpy(&result[k], \"Hoshina\");\n                k += 7;\n                j += 7;\n            } else {\n                result[k] = line[j];\n                k++;\n                j++;\n            }\n        }\n        \n        result[k] = '\\0';\n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; char line[1001]; char result[1001]; scanf(\"%d\\n\", &n); for (int i = 0; i < n; i++) { fgets(line, sizeof(line), stdin); int len = strlen(line); if (line[len-1] == '\\n') { line[len-1] = '\\0'; len--; } int j = 0; int k = 0; while (j < len) { if (j + 6  \"Hoshina\"); k += 7; j += 7; } else if (j + 6 == len && strncmp(&line[j], \"Hoshino\", 7) ==  } else { result[k] =  } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(void) { int n; char in[1024], *ptr; scanf(\"%d \", &n); while (n--)  != NULL) { ptr[6] = 'a'; ptr = strstr(ptr, \"Hoshino\"); } printf(\"%s\", in); } return 0; }"], "original_ll": -1.1224881410598755, "sampled_ll": -0.6112725138664246, "all_perturbed_sampled_ll": [-1.4484361410140991], "all_perturbed_original_ll": [-2.2202610969543457], "perturbed_sampled_ll": -1.4484361410140991, "perturbed_original_ll": -2.2202610969543457, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString str = sc.nextLine();\n\t\t\tstr = str.replaceAll(\"Hoshino\", \"Hoshina\");\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n}\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            String result = line.replace(\"Hoshino\", \"Hoshina\");\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); for (int i = 0; i < n; i++) { String  sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String args[]){ Scanner sc = new Scanner(System.in); int n = Integer.parseInt(sc.nextLine());  String str = sc.nextLine(); str = str.replaceAll(\"Hoshino\", \"Hoshina\"); System.out.println(str); } } }"], "original_ll": -1.033908724784851, "sampled_ll": -0.8473575711250305, "all_perturbed_sampled_ll": [-1.1456966400146484], "all_perturbed_original_ll": [-1.5304239988327026], "perturbed_sampled_ll": -1.1456966400146484, "perturbed_original_ll": -1.5304239988327026, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\ndef main():\n  n = int(sys.stdin.readline())\n  for _ in range(n):\n    line = sys.stdin.readline()\n    print(line.strip().replace(\"Hoshino\", \"Hoshina\"))\n\nif __name__ == \"__main__\":\n  main()", "sampled": "n = int(input())\nfor _ in range(n):\n    line = input()\n    print(line.replace(\"Hoshino\", \"Hoshina\"))\n", "perturbed_sampled": ["n = int(input()) for _ in range(n): line = input() print(line.replace(\"Hoshino\", \"Hoshina\"))"], "perturbed_original": ["import sys def main(): n = int(sys.stdin.readline()) for _ in range(n): line = sys.stdin.readline() print(line.strip().replace(\"Hoshino\", \"Hoshina\")) if __name__ == \"__main__\": main()"], "original_ll": -1.347481369972229, "sampled_ll": -2.0737977027893066, "all_perturbed_sampled_ll": [-2.5964906215667725], "all_perturbed_original_ll": [-1.6475951671600342], "perturbed_sampled_ll": -2.5964906215667725, "perturbed_original_ll": -1.6475951671600342, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  int a[11][11]={};\n  int i,j,n,s,t;\n\n  for(;;){\n    scanf(\"%d\",&n);\n    if(!n)\n      break;\n    t=0;\n\n    for(i=0;i<n;i++){\n      s=0;\n      for(j=0;j<n;j++){\n\tscanf(\"%d\",&a[i][j]);\n\ts+=a[i][j];\n      }\n      a[i][n]=s;\n      t+=s;\n    }\n    a[n][n]=t;\n    for(j=0;j<n;j++){\n      s=0;\n      for(i=0;i<n;i++){\n\ts+=a[i][j];\n      }\n      a[n][j]=s;\n    }\n    for(i=0;i<=n;i++){\n      for(j=0;j<=n;j++){\n\tprintf(\"%5d\",a[i][j]);\n      }\n      puts(\"\");\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int table[n][n];\n        int rowSum[n];\n        int colSum[n];\n        int totalSum = 0;\n        \n        // Read input\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                scanf(\"%d\", &table[i][j]);\n            }\n        }\n        \n        // Calculate row sums\n        for(int i = 0; i < n; i++) {\n            rowSum[i] = 0;\n            for(int j = 0; j < n; j++) {\n                rowSum[i] += table[i][j];\n            }\n        }\n        \n        // Calculate column sums\n        for(int j = 0; j < n; j++) {\n            colSum[j] = 0;\n            for(int i = 0; i < n; i++) {\n                colSum[j] += table[i][j];\n            }\n        }\n        \n        // Calculate total sum\n        for(int i = 0; i < n; i++) {\n            totalSum += rowSum[i];\n        }\n        \n        // Print table with row sums\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                printf(\"%5d\", table[i][j]);\n            }\n            printf(\"%5d\\n\", rowSum[i]);\n        }\n        \n        // Print column sums and total sum\n        for(int j = 0; j < n; j++) {\n            printf(\"%5d\", colSum[j]);\n        }\n        printf(\"%5d\\n\", totalSum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) { scanf(\"%d\", &n); if(n == 0) break; int table[n][n]; int rowSum[n]; int colSum[n]; int totalSum = 0; // Read input for(int i = 0; i < n; i++) { for(int j = 0; j < n; j++) { scanf(\"%d\", &table[i][j]); } } // Calculate row sums for(int i = 0; i < n; i++)  n;  sums for(int j = 0; j < n; j++) { colSum[j] = 0; for(int i = 0; i <  total sum for(int i = 0; i < n; i++) { totalSum += rowSum[i]; } // Print table with row sums for(int i = 0; i < n; i++) { for(int j = 0; j  //  j < n; j++) { printf(\"%5d\", colSum[j]); } printf(\"%5d\\n\", totalSum); } return 0; }"], "perturbed_original": ["#include<stdio.h> int  for(i=0;i<n;i++){ s=0; for(j=0;j<n;j++){ scanf(\"%d\",&a[i][j]); s+=a[i][j]; } a[i][n]=s; t+=s; } a[n][n]=t; for(j=0;j<n;j++){ s=0; for(i=0;i<n;i++){ s+=a[i][j]; } a[n][j]=s; } for(i=0;i<=n;i++){ for(j=0;j<=n;j++){ printf(\"%5d\",a[i][j]); } puts(\"\"); } } return 0; }"], "original_ll": -0.7371178865432739, "sampled_ll": -0.31287622451782227, "all_perturbed_sampled_ll": [-1.0564824342727661], "all_perturbed_original_ll": [-1.0049073696136475], "perturbed_sampled_ll": -1.0564824342727661, "perturbed_original_ll": -1.0049073696136475, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n    public static void main(String args[]){\n        Scanner in = new Scanner(System.in);\n        while(true){\n            int n = in.nextInt();\n            if(n == 0) return ;\n            int mat[][] = new int[n+1][n+1];\n            for(int i=0; i<n; i++){\n                int sumr = 0;\n                for(int j=0; j<n; j++){\n                    mat[i][j] = in.nextInt();\n                    sumr += mat[i][j];\n                }\n                mat[i][n] = sumr;\n            }\n            for(int j=0; j<=n; j++){\n                int sumc = 0;\n                for(int i=0; i<n; i++){\n                    sumc += mat[i][j];\n                }\n                mat[n][j] = sumc;\n            }\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    System.out.printf(\"%5d\",mat[i][j]);\n                }\n                System.out.println();\n            }\n        }\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[][] table = new int[n][n];\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    table[i][j] = sc.nextInt();\n                }\n            }\n            \n            int[] rowSums = new int[n];\n            int[] colSums = new int[n];\n            \n            for (int i = 0; i < n; i++) {\n                int rowSum = 0;\n                for (int j = 0; j < n; j++) {\n                    rowSum += table[i][j];\n                }\n                rowSums[i] = rowSum;\n            }\n            \n            for (int j = 0; j < n; j++) {\n                int colSum = 0;\n                for (int i = 0; i < n; i++) {\n                    colSum += table[i][j];\n                }\n                colSums[j] = colSum;\n            }\n            \n            int totalSum = 0;\n            for (int i = 0; i < n; i++) {\n                totalSum += rowSums[i];\n            }\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    System.out.printf(\"%5d\", table[i][j]);\n                }\n                System.out.printf(\"%5d\\n\", rowSums[i]);\n            }\n            \n            for (int j = 0; j < n; j++) {\n                System.out.printf(\"%5d\", colSums[j]);\n            }\n            System.out.printf(\"%5d\\n\", totalSum);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[][] table = new int[n][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { table[i][j] = sc.nextInt(); } } int[] rowSums = new int[n]; int[] colSums = new int[n]; for (int i = 0; i < n; i++) { int rowSum = 0; for (int j = 0; j < =<extra_id_3>int [ ] { table<extra_id_4>= new<extra_id_5>int [<extra_id_6>. Int32Bits ( 10 )<extra_id_7>new int [ 2 *<extra_id_8>int<extra_id_9>. Int32Bits ( 10<extra_id_10>;<extra_id_11>] .<extra_id_12>) ) ; rowSums [<extra_id_13>rowSums<extra_id_14>;<extra_id_15>void<extra_id_16>) {<extra_id_17>int i = 0; }<extra_id_18>=<extra_id_19>] .<extra_id_20>]<extra_id_21>; foreach ( int<extra_id_22>.<extra_id_23>++<extra_id_24>( int row ) } for (int j = 0; j < n; j++) { int colSum = 0; for (int i = 0; i < n; i++) { colSum += table[i][j]; } colSums[j] = colSum; } int totalSum = 0; for (int i = 0;  (int i = 0;  n; j++) { System.out.printf(\"%5d\", colSums[j]); } System.out.printf(\"%5d\\n\", totalSum); } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main{ public static void main(String args[]){ Scanner in = new  ; int mat[][] = new int[n+1][n+1]; for(int i=0; i<n; i++){ int sumr = 0; for(int j=0; j<n; j++){ mat[i][j] =  j=0; j<=n; j++){ int sumc = 0; for(int i=0; i<n; i++){ sumc += mat[i][j]; } mat[n][j] = sumc; } for(int i=0; i<=n; i++){ for(int j=0; j<=n; j++){ System.out.printf(\"%5d\",mat[i][j]); } System.out.println(); } } } }"], "original_ll": -0.5017719864845276, "sampled_ll": -0.2444511502981186, "all_perturbed_sampled_ll": [-1.3318825960159302], "all_perturbed_original_ll": [-1.2589292526245117], "perturbed_sampled_ll": -1.3318825960159302, "perturbed_original_ll": -1.2589292526245117, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import functools\n\nn = input()\nwhile(n):\n    list = []\n    bottom_record = [0]*(n+1)\n\n    for i in range(0, n):\n        l = map(int, raw_input().split())\n        l.append(functools.reduce(lambda x, y: x + y, l))\n        bottom_record = [x + y for(x,y) in zip(bottom_record, l)]\n        print(' '.join(map(str, l))) \n    print(' '.join(map(str, bottom_record)))\n    n = input()", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    table = []\n    for i in range(n):\n        row = list(map(int, input().split()))\n        table.append(row)\n    \n    # Calculate row sums\n    row_sums = []\n    for row in table:\n        row_sums.append(sum(row))\n    \n    # Calculate column sums\n    col_sums = []\n    for j in range(n):\n        col_sum = sum(table[i][j] for i in range(n))\n        col_sums.append(col_sum)\n    \n    # Calculate total sum\n    total_sum = sum(row_sums)\n    \n    # Print the table with sums\n    for i in range(n):\n        for j in range(n):\n            print(f\"{table[i][j]:5d}\", end=\"\")\n        print(f\"{row_sums[i]:5d}\")\n    \n    # Print column sums row\n    for col_sum in col_sums:\n        print(f\"{col_sum:5d}\", end=\"\")\n    print(f\"{total_sum:5d}\")\n", "perturbed_sampled": ["while True: n = int(input())  in range(n): row = list(map(int, input().split())) table.append(row) # Calculate row sums row_sums = [] for row in table: row_sums.append(sum(row)) # Calculate  = sum(table[i][j] for i in range(n)) col_sums.append(col_sum) # Calculate total sum total_sum = sum(row_sums) # Print the table with sums for i in range(n): for j in range(n): print(f\"{table[i][j]:5d}\", end=\"\") print(f\"{row_sums[i]:5d}\") # Print column sums row for col_sum in col_sums: print(f\"{col_sum:5d}\", end=\"\") print(f\"{total_sum:5d}\")"], "perturbed_original": ["import functools n = input() while(n): list = [] bottom_record = [0]*(n+1) for i in range(0, n):  l)) bottom_record = [x + y for(x,y) in zip(bottom_record, l)] print(' '.join(map(str, l))) print(' '.join(map(str, bottom_record))) n = input()"], "original_ll": -1.6041557788848877, "sampled_ll": -0.6042158603668213, "all_perturbed_sampled_ll": [-1.4418152570724487], "all_perturbed_original_ll": [-2.4841866493225098], "perturbed_sampled_ll": -1.4418152570724487, "perturbed_original_ll": -2.4841866493225098, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tint n;\n\tchar event[8];\n\tint out = 0;\n\tint base[3] = {0};\n\tint i;\n\tint score;\n\t\n\tscanf(\"%d\", &n);\n\t\t\t \n\twhile (n != 0){\n\t\tscore = 0;\n\t\tbase[0] = 0;\n\t\tbase[1] = 0;\n\t\tbase[2] = 0;\n\t\tout = 0;\n\t\twhile (out < 3){\n\t\t\tscanf(\"%s\", event);\n\t\t\tif (strcmp(event, \"HIT\") == 0){\n\t\t\t\tbase[0]++;\n\t\t\t\tfor (i = 0; i < 3; i++){\n\t\t\t\t\tif (base[i] > 1){\n\t\t\t\t\t\tif (i < 2){\n\t\t\t\t\t\t\tbase[i + 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tscore++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbase[i]--;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strcmp(event, \"HOMERUN\") == 0){\n\t\t\t\tfor (i = 0; i < 3; i++){\n\t\t\t\t\tif (base[i] == 1){\n\t\t\t\t\t\tscore++;\n\t\t\t\t\t\tbase[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tscore++;\n\t\t\t}\n\t\t\telse if (strcmp(event, \"OUT\") == 0){\n\t\t\t\tout++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", score);\n\t\tn--;\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int base[4] = {0}; // base[1], base[2], base[3] for first, second, third\n        int score = 0;\n        int outs = 0;\n        char event[10];\n        \n        while (outs < 3 && scanf(\"%s\", event) == 1) {\n            if (strcmp(event, \"HIT\") == 0) {\n                if (base[3]) {\n                    score++;\n                    base[3] = 0;\n                }\n                if (base[2]) {\n                    base[3] = 1;\n                    base[2] = 0;\n                }\n                if (base[1]) {\n                    base[2] = 1;\n                    base[1] = 0;\n                }\n                base[1] = 1;\n            } else if (strcmp(event, \"HOMERUN\") == 0) {\n                score++; // batter scores\n                if (base[1]) {\n                    score++;\n                    base[1] = 0;\n                }\n                if (base[2]) {\n                    score++;\n                    base[2] = 0;\n                }\n                if (base[3]) {\n                    score++;\n                    base[3] = 0;\n                }\n            } else if (strcmp(event, \"OUT\") == 0) {\n                outs++;\n            }\n        }\n        \n        printf(\"%d\\n\", score);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; scanf(\"%d\", &n); while (n--) { int base[4] = {0}; // base[1], base[2], base[3] for first, second, third  while (outs < 3 && scanf(\"%s\", event) == 1) { if (strcmp(event, \"HIT\") == 0) { if (base[3]) { score++; base[3] = 0; } if (base[2]) { base[3] = 1; base[2] = 0; } if (base[1]) { base[2] = 1;  (strcmp(event, \"HOMERUN\") == 0) { score++;  } if (base[2]) { score++; base[2] = 0;  else if (strcmp(event, \"OUT\") == 0) { outs++; } } printf(\"%d\\n\", score); } return 0; }"], "perturbed_original": ["#include  int out = 0; int base[3] = {0}; int i;   out = 0; while (out < 3){ scanf(\"%s\", event); if (strcmp(event, \"HIT\") == 0){ base[0]++; for (i = 0; i < 3; i++){ if (base[i] > 1){ if (i < 2){ base[i + 1]++; } else { score++; } base[i]--; } } } else if (strcmp(event, \"HOMERUN\") == 0){ for (i = 0; i < 3; i++){ if (base[i] == 1){ score++; base[i] = 0; } } score++; } else if (strcmp(event, \"OUT\") == 0){ out++; } } printf(\"%d\\n\", score); n--; } return 0; }"], "original_ll": -0.845903754234314, "sampled_ll": -0.7388814091682434, "all_perturbed_sampled_ll": [-1.4273622035980225], "all_perturbed_original_ll": [-1.2775182723999023], "perturbed_sampled_ll": -1.4273622035980225, "perturbed_original_ll": -1.2775182723999023, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint field = 0;\n\t\tlong scoreCount = 0;\n\t\tint outCount = 0;\n\t\tint finishedGame = 0;\n\t\ttry {\n\t\t\tint gameNumber = br.read();\n\t\t\twhile (finishedGame < gameNumber) {\n\t\t\t\tswitch (br.readLine()) {\n\t\t\t\tcase \"HIT\":\n\t\t\t\t\tif(field==3) {\n\t\t\t\t\t\tscoreCount++;\n\t\t\t\t\t}\n\t\t\t\t\tfield++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"OUT\":\n\t\t\t\t\toutCount++;\n\t\t\t\t\tif (outCount == 3) {\n\t\t\t\t\t\tSystem.out.println(scoreCount);\n\t\t\t\t\t\tscoreCount = 0;\n\t\t\t\t\t\toutCount = 0;\n\t\t\t\t\t\tfield = 0;\n\t\t\t\t\t\tfinishedGame++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"HOMERUN\":\n\t\t\t\t\tscoreCount += 1 + field;\n\t\t\t\t\tfield = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            int score = 0;\n            int outs = 0;\n            boolean[] bases = new boolean[3]; // 0: first, 1: second, 2: third\n            \n            while (outs < 3) {\n                String event = sc.nextLine().trim();\n                \n                if (event.equals(\"HIT\")) {\n                    if (bases[2]) {\n                        score++;\n                        bases[2] = false;\n                    }\n                    if (bases[1]) {\n                        bases[2] = true;\n                        bases[1] = false;\n                    }\n                    if (bases[0]) {\n                        bases[1] = true;\n                    }\n                    bases[0] = true;\n                } else if (event.equals(\"HOMERUN\")) {\n                    score++; // for the batter\n                    for (int j = 0; j < 3; j++) {\n                        if (bases[j]) {\n                            score++;\n                            bases[j] = false;\n                        }\n                    }\n                } else if (event.equals(\"OUT\")) {\n                    outs++;\n                }\n            }\n            \n            System.out.println(score);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public  0; i < n; i++) { int score = 0; int outs = 0; boolean[] bases = new boolean[3]; // 0: first, 1: second, 2: third while (outs < 3) { String event = sc.nextLine().trim(); if (event.equals(\"HIT\")) { if (bases[2]) { score++; bases[2] =  false; } if (bases[0]) { bases[1] = true; } bases[0] = true; } else if (event.equals(\"HOMERUN\")) { score++; // for the batter for (int j = 0; j < 3; j++)  } else if (event.equals(\"OUT\")) { outs++; } } System.out.println(score); } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; import java.util.List; public class Main { public static void main(String[] args) { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int field = 0; long scoreCount = 0; int outCount = 0;  \"HIT\": if(field==3) { scoreCount++; } field++; break; case \"OUT\": outCount++; if (outCount  field = 0; finishedGame++; } break; case \"HOMERUN\": scoreCount += 1 + field; field = 0; break; } } br.close(); } catch (IOException e) { e.printStackTrace(); } } }"], "original_ll": -1.0079694986343384, "sampled_ll": -0.781657874584198, "all_perturbed_sampled_ll": [-1.676285743713379], "all_perturbed_original_ll": [-1.7977837324142456], "perturbed_sampled_ll": -1.676285743713379, "perturbed_original_ll": -1.7977837324142456, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def hit(bases):\n    got_point = False\n    if bases[2]:\n        got_point = True\n    bases[0], bases[1], bases[2] = 1, bases[0], bases[1]\n    if got_point:\n        return 1\n    else:\n        return 0\n\ndef homerun(bases):\n    num_runner = bases.count(1)\n    bases[0], bases[1], bases[2] = 0, 0, 0\n    return num_runner + 1\n\nfor i in range(int(raw_input())):\n    bases = [0, 0, 0]\n    out_count = 0\n    points = 0\n    while out_count != 3:\n        event = raw_input()\n        if event == \"HIT\":\n            points += hit(bases)\n        elif event == \"HOMERUN\":\n            points += homerun(bases)\n        else:\n            out_count += 1\n    print points", "sampled": "n = int(input())\nfor _ in range(n):\n    score = 0\n    bases = [False, False, False]  # 1st, 2nd, 3rd base\n    outs = 0\n    \n    while outs < 3:\n        event = input().strip()\n        \n        if event == \"HIT\":\n            # Score runners from 3rd base\n            if bases[2]:\n                score += 1\n            # Advance runners\n            bases[2] = bases[1]\n            bases[1] = bases[0]\n            bases[0] = True\n            \n        elif event == \"HOMERUN\":\n            # Count runners on base\n            runners_on_base = sum(bases)\n            # Score all runners plus batter\n            score += runners_on_base + 1\n            # Clear all bases\n            bases = [False, False, False]\n            \n        elif event == \"OUT\":\n            outs += 1\n    \n    print(score)\n", "perturbed_sampled": ["n = int(input()) for _ in range(n): score = 0 bases = [False, False, False] # 1st, 2nd, 3rd base outs = 0 while outs < 3: event = event =<extra_id_14>if event ==<extra_id_15>: outs += 1 #<extra_id_16>1<extra_id_17>print(score) # count runners_on<extra_id_18>==<extra_id_19>bases_on_ base if bases[2]: score += 1 # Advance runners bases[2] = bases[1] bases[1] = bases[0] bases[0] = True elif event == \"HOMERUN\": # Count runners on base runners_on_base = sum(bases) # Score all runners plus batter score += runners_on_base + 1  event == \"OUT\": outs += 1 print(score)"], "perturbed_original": ["def hit(bases): got_point = False if bases[2]: got_point = True bases[0], bases[1], bases[2] = 1, bases[0], bases[1] if got_point: return 1 else: return 0 def homerun(bases): num_runner = bases.count(1) bases[0], bases[1], : points<extra_id_2>points +=<extra_id_3>bases.count(1)<extra_id_4>: out_count<extra_id_5>=<extra_id_6>: points +=<extra_id_7>print (<extra_id_8>bases<extra_id_9>) points = 0 for<extra_id_10>i<extra_id_11>: if i in range(int(raw_input())): bases = [0, 0, 0] out_count = 0 points = 0 while out_count != 3: event = raw_input() if not<extra_id_12>if event in<extra_id_13>: points += homerun (<extra_id_14>break points +=<extra_id_15>] print points<extra_id_16>( in_runner [ i<extra_id_17>=<extra_id_18><= 2:<extra_id_19>is ( ) :<extra_id_20>[ 2 ]<extra_id_21>points != 1<extra_id_22>lines points += homerun(bases) else: out_count += 1 print points"], "original_ll": -1.0798087120056152, "sampled_ll": -1.3496166467666626, "all_perturbed_sampled_ll": [-2.4895663261413574], "all_perturbed_original_ll": [-2.1306259632110596], "perturbed_sampled_ll": -2.4895663261413574, "perturbed_original_ll": -2.1306259632110596, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "C[51],c;\n#define min(a,b) ((a)<(b)?(a):(b))\nmain(i){\n\tC[1]=380;\n\tfor(i=2;i<=50;i++){\n\t\tc=9999;\n\t\tif(i>=2)c=min(c,C[i-2]+380);\n\t\tif(i>=3)c=min(c,C[i-3]+550);\n\t\tif(i>=5)c=min(c,C[i-5]+850);\n\t\tif(i>=10)c=min(c,C[i-10]+1520);\n\t\tif(i>=12)c=min(c,C[i-12]+1870);\n\t\tif(i>=15)c=min(c,C[i-15]+2244);\n\t\tC[i]=c;\n\t}\n\tfor(;~scanf(\"%d\",&i);)\n\t\ti&&printf(\"%d\\n\",C[(i+99)/100]);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a;\n    \n    while(scanf(\"%d\", &a) == 1 && a != 0) {\n        int minCost = -1;\n        \n        // Shop A: 200g bags, 380 yen, per 5 bags 20% discount\n        if(a % 200 == 0) {\n            int bags = a / 200;\n            int discountedBags = (bags / 5) * 5;\n            int normalBags = bags % 5;\n            int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380;\n            if(minCost == -1 || cost < minCost) {\n                minCost = cost;\n            }\n        }\n        \n        // Shop B: 300g bags, 550 yen, per 4 bags 15% discount\n        if(a % 300 == 0) {\n            int bags = a / 300;\n            int discountedBags = (bags / 4) * 4;\n            int normalBags = bags % 4;\n            int cost = (int)(discountedBags * 550 * 0.85) + normalBags * 550;\n            if(minCost == -1 || cost < minCost) {\n                minCost = cost;\n            }\n        }\n        \n        // Shop C: 500g bags, 850 yen, per 3 bags 12% discount\n        if(a % 500 == 0) {\n            int bags = a / 500;\n            int discountedBags = (bags / 3) * 3;\n            int normalBags = bags % 3;\n            int cost = (int)(discountedBags * 850 * 0.88) + normalBags * 850;\n            if(minCost == -1 || cost < minCost) {\n                minCost = cost;\n            }\n        }\n        \n        printf(\"%d\\n\", minCost);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" 1 && a != 0) { int minCost = -1; // Shop A: 200g bags, 380 yen, per 5 bags 20% discount if(a % 200 == 0) { int bags = a / 200; int discountedBags = (bags / 5) * 5; int normalBags = bags % 5; int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380;  cost; } }  15%  a / 300; int discountedBags = (bags / 4) * 4; int normalBags = bags % 4; int cost = (int)(discountedBags * 550 * 0.85) + normalBags * 550; if(minCost == -1 || cost < minCost) { minCost = cost; } } // Shop C:  % 500 == 0) { int bags = a / 500; int discountedBags = (bags / 3) * 3; int normalBags = bags % 3; int cost = (int)(discountedBags *  || cost < minCost) { minCost = cost; } } printf(\"%d\\n\", minCost); } return 0; }"], "perturbed_original": ["C[51],c; #define min(a,b) ((a)<(b)?(a):(b)) main(i){ C[1]=380; for(i=2;i<=50;i++){ c=9999; if(i>=2)c=min(c,C[i-2]+380); if(i>=3)c=min(c,C[i-3]+550); if(i>=5)c=min(c,C[i-5]+850); if(i>=10)c=min(c,C[i-10]+1520); if(i>=12)c=min(c,C[i-12]+1870); if(i>=15)c=min(c,C[i-15]+2244); C[i]=c; } for(;~scanf(\"%d\",&i);) i&&printf(\"%d\\n\",C[(i+99)/100]); }"], "original_ll": -1.330197811126709, "sampled_ll": -0.5530591011047363, "all_perturbed_sampled_ll": [-1.3899320363998413], "all_perturbed_original_ll": [-1.4312186241149902], "perturbed_sampled_ll": -1.3899320363998413, "perturbed_original_ll": -1.4312186241149902, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(true){ \n\t\t\tif(n == 0)break;\n\t\t\tSystem.out.println(min(n));\n\t\t\tn = sc.nextInt();\n\t\t}   \n\t}   \n\tstatic int min(int n){\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int c = n/500 ; c >= 0 ; c--){\n\t\t\tfor(int b = (n-c*500)/300 ; b >= 0 ; b--){\n\t\t\t\tif((n-c*500-b*300)%200 == 0){ \n\t\t\t\t\tint a = (n-c*500-b*300)/200;\n\t\t\t\t\tint cost = cost(a, b, c); \n\t\t\t\t\tif(cost < min){\n\t\t\t\t\t\tmin = cost;\n\t\t\t\t\t}   \n\t\t\t\t}   \n\t\t\t}   \n\t\t}   \n\t\treturn min;\n\t}   \n\tstatic int cost(int a, int b, int c){\n\t\treturn (a%5)*380+(a/5)*5*380*8/10+(b%4)*550+(b/4)*4*550*85/100+(c%3)*850+(c/3)*3*850*88/100;\n\t}   \n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int a = sc.nextInt();\n            if (a == 0) break;\n            \n            int minCost = Integer.MAX_VALUE;\n            \n            // Shop A: 200g per bag, 380 yen, 5 bags discount 20%\n            if (a % 200 == 0) {\n                int bags = a / 200;\n                int discountedBags = (bags / 5) * 5;\n                int normalBags = bags % 5;\n                int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380;\n                minCost = Math.min(minCost, cost);\n            }\n            \n            // Shop B: 300g per bag, 550 yen, 4 bags discount 15%\n            if (a % 300 == 0) {\n                int bags = a / 300;\n                int discountedBags = (bags / 4) * 4;\n                int normalBags = bags % 4;\n                int cost = (int)(discountedBags * 550 * 0.85) + normalBags * 550;\n                minCost = Math.min(minCost, cost);\n            }\n            \n            // Shop C: 500g per bag, 850 yen, 3 bags discount 12%\n            if (a % 500 == 0) {\n                int bags = a / 500;\n                int discountedBags = (bags / 3) * 3;\n                int normalBags = bags % 3;\n                int cost = (int)(discountedBags * 850 * 0.88) + normalBags * 850;\n                minCost = Math.min(minCost, cost);\n            }\n            \n            System.out.println(minCost);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int a = sc.nextInt(); if (a == 0) break; int minCost = Integer.MAX_VALUE; // Shop A: 200g per bag, 380 yen, 5 bags discount 20% if (a %  normalBags = bags %  normalBags * 380;  bag, 550 yen, 4 bags discount 15% if (a % 300 == 0) { int bags = a  int normalBags = bags % 4; int cost = (int)(discountedBags * 550  } // Shop C: 500g per bag, 850 yen, 3 bags discount 12% if (a % 500 == 0) { int bags = a / 500; int discountedBags = (bags / 3) * 3; int normalBags = bags % 3; int cost = (int)(discountedBags * 850 * 0.88) + normalBags * 850; minCost = Math.min(minCost, cost); } System.out.println(minCost); } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int n = sc.nextInt(); while(true){ if(n == 0)break; System.out.println(min(n)); n = sc.nextInt(); } } static int min(int n){ int min = Integer.MAX_VALUE; for(int  b = (n-c*500)/300 ; b >= 0 ; b--){ if((n-c*500-b*300)%200 == 0){ int a = (n-c*500-b*300)/200; int cost = cost(a, b,  } return min; } static int cost(int a, int b, int c){ return (a%5)*380+(a/5)*5*380*8/10+(b%4)*550+(b/4)*4*550*85/100+(c%3)*850+(c/3)*3*850*88/100; } }"], "original_ll": -0.9665937423706055, "sampled_ll": -0.5388697981834412, "all_perturbed_sampled_ll": [-1.481362223625183], "all_perturbed_original_ll": [-1.3015600442886353], "perturbed_sampled_ll": -1.481362223625183, "perturbed_original_ll": -1.3015600442886353, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a=[(2,380),(3,550),(5,850),(10,1520),(12,1870),(15,2244)]\ndp=[1<<20]*51\nfor i,j in a:\n    dp[i]=j\n    for k in range(51-i):\n        if dp[k]!=1<<20 and dp[k+i]>dp[k]+j:\n            dp[k+i]=dp[k]+j\nwhile 1:\n    n=int(input())\n    if n==0:break\n    print(dp[n//100])", "sampled": "def calculate_cost(amount, bag_size, unit_price, discount_unit, discount_rate):\n    if amount % bag_size != 0:\n        return float('inf')\n    \n    num_bags = amount // bag_size\n    discounted_bags = (num_bags // discount_unit) * discount_unit\n    regular_bags = num_bags % discount_unit\n    \n    discounted_cost = discounted_bags * unit_price * (1 - discount_rate)\n    regular_cost = regular_bags * unit_price\n    \n    return int(discounted_cost + regular_cost)\n\nwhile True:\n    a = int(input())\n    if a == 0:\n        break\n    \n    # Shop A: 200g, 380 yen, per 5 bags, 20% off\n    cost_a = calculate_cost(a, 200, 380, 5, 0.20)\n    \n    # Shop B: 300g, 550 yen, per 4 bags, 15% off\n    cost_b = calculate_cost(a, 300, 550, 4, 0.15)\n    \n    # Shop C: 500g, 850 yen, per 3 bags, 12% off\n    cost_c = calculate_cost(a, 500, 850, 3, 0.12)\n    \n    print(min(cost_a, cost_b, cost_c))\n", "perturbed_sampled": ["def calculate_cost(amount, bag_size, unit_price, discount_unit, discount_rate): if amount %  num_bags % discount_unit discounted_cost = discounted_bags * unit_price * (1 - discount_rate) regular_cost = regular_bags * unit_price return int(discounted_cost + regular_cost) while True: a = int(input()) if a == 0: break # Shop A: 200g, 380 yen, per  0.20) # Shop B: 300g, 550 yen, per 4 bags, 15% off cost_b = calculate_cost(a, 300, 550, 4, 0.15) # Shop C: 500g, 850 yen, per 3 bags, 12% off cost_c = calculate_cost(a, 500, 850, 3, 0.12) print(min(cost_a, cost_b, cost_c))"], "perturbed_original": ["a=[(2,380),(3,550),(5,850),(10,1520),(12,1870),(15,2244)] dp=[1<<20]*51 for i,j in a: dp[i]=j for k in range(51-i): if dp[k]!=1<<20 and dp[k+i]>dp[k]+j: dp[k+i]=dp[k]+j while 1: n=int(input()) if n==0:break print(dp[n//100])"], "original_ll": -1.6114875078201294, "sampled_ll": -0.9219945073127747, "all_perturbed_sampled_ll": [-1.7931326627731323], "all_perturbed_original_ll": [-1.9785287380218506], "perturbed_sampled_ll": -1.7931326627731323, "perturbed_original_ll": -1.9785287380218506, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  int i,n,t[3];\n  int data,kari,hakari;\n\n  while(1){\n    scanf(\"%d%d%d\",&t[0],&t[1],&t[2]);\n    if(t[0] == 0 || t[1] == 0 || t[2] == 0)\n      break;\n    scanf(\"%d\",&n);\n    if(t[0] >= t[2]){\n      t[0] = t[2];\n       t[2] = -1;\n      }\n    if(t[1] >= t[2]&&t[2] != -1)\n      t[1] = t[2];\n    hakari = t[0] * t[0] + t[1] *t[1];\n    for(i = 0; i < n; i++){\n      scanf(\"%d\",&data);\n      data = data * 2;\n      data = data * data;\n      if(hakari < data)\n\tprintf(\"OK\\n\");\n      else \n\tprintf(\"NA\\n\");\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int A, B, C;\n    \n    while(1) {\n        scanf(\"%d %d %d\", &A, &B, &C);\n        \n        if(A == 0 && B == 0 && C == 0) break;\n        \n        int n;\n        scanf(\"%d\", &n);\n        \n        // Calculate the minimum diagonal of any face\n        // The cheese can pass through a circular hole if the diagonal of the smallest rectangular face\n        // can fit through the circle\n        double diag1 = sqrt(A * A + B * B);\n        double diag2 = sqrt(B * B + C * C);\n        double diag3 = sqrt(A * A + C * C);\n        \n        double min_diag = diag1;\n        if(diag2 < min_diag) min_diag = diag2;\n        if(diag3 < min_diag) min_diag = diag3;\n        \n        for(int i = 0; i < n; i++) {\n            int R;\n            scanf(\"%d\", &R);\n            \n            // The cheese can pass if the diameter of the hole is greater than the minimum diagonal\n            if(2 * R > min_diag) {\n                printf(\"OK\\n\");\n            } else {\n                printf(\"NA\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int A, B, C; while(1) { scanf(\"%d %d %d\", &A, &B, &C); if(A == 0 && B == 0 && C == 0) break; int n; scanf(\"%d\", &n); // Calculate the minimum diagonal of any face // The cheese can pass through a circular hole if the diagonal of the smallest rectangular face // can  * A + C * C); double min_diag = diag1; if(diag2 < min_diag) min_diag = diag2; if(diag3 < min_diag) min_diag = diag3; for(int i = 0; i < n; i++) { int R; scanf(\"%d\", &R); // The cheese can pass if the diameter of the hole is greater than the minimum  { printf(\"NA\\n\"); } } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){  if(t[0] >= t[2]){ t[0] = t[2]; t[2] = -1; } if(t[1] >= t[2]&&t[2] != -1) t[1] = t[2]; hakari = t[0] * t[0] + t[1] *t[1]; for(i = 0; i < n; i++){ scanf(\"%d\",&data); data = data * 2; data = data * data; if(hakari < data) printf(\"OK\\n\"); else printf(\"NA\\n\"); } } return 0; }"], "original_ll": -1.136303186416626, "sampled_ll": -0.9435007572174072, "all_perturbed_sampled_ll": [-1.7178059816360474], "all_perturbed_original_ll": [-1.3753328323364258], "perturbed_sampled_ll": -1.7178059816360474, "perturbed_original_ll": -1.3753328323364258, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nimport java.util.Arrays;\n\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true)\n\t\t{\n\t\t\tint a[] = new int[3];\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\tif (a[0] == 0 && a[1] == 0 && a[2] == 0) break;\n\t\t\t\n\t\t\t//Arrays.sort(a);\n\t\t\tint minR = a[0] * a[0] + a[2] + a[2];\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tint r = sc.nextInt() * 2;\n\t\t\t\tif (minR < r * r) System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int A = sc.nextInt();\n            int B = sc.nextInt();\n            int C = sc.nextInt();\n            \n            if (A == 0 && B == 0 && C == 0) {\n                break;\n            }\n            \n            // Find the minimum diagonal among all three faces\n            // The cheese can pass through if oriented diagonally through a face\n            double diag1 = Math.sqrt(A * A + B * B);\n            double diag2 = Math.sqrt(B * B + C * C);\n            double diag3 = Math.sqrt(A * A + C * C);\n            \n            double minDiag = Math.min(diag1, Math.min(diag2, diag3));\n            \n            int n = sc.nextInt();\n            \n            for (int i = 0; i < n; i++) {\n                int R = sc.nextInt();\n                \n                if (2 * R > minDiag) {\n                    System.out.println(\"OK\");\n                } else {\n                    System.out.println(\"NA\");\n                }\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public  while (true) { int A =  (A == 0 && B == 0 && C == 0) { break; } // Find the minimum diagonal among all three faces // The cheese can pass through if oriented diagonally through a face double diag1 = Math.sqrt(A * A + B * B); double diag2 = Math.sqrt(B * B + C * C); double diag3 = Math.sqrt(A * A + C * C); double minDiag  i = 0; i < n; i++) { int R = sc.nextInt(); if (2 * R > minDiag)  } }"], "perturbed_original": ["import java.util.Scanner; import java.util.Arrays; class Main { public static void main(String args[]) { Scanner sc = new Scanner(System.in); while (true) {  i < 3; i++) a[i] = sc.nextInt(); if (a[0] == 0 && a[1] == 0 && a[2] == 0) break; //Arrays.sort(a); int minR  = sc.nextInt(); for (int i = 0; i < n; i++) { int r = sc.nextInt() * 2; if (minR < r * r) System.out.println(\"OK\"); else System.out.println(\"NA\"); } } } }"], "original_ll": -0.8852454423904419, "sampled_ll": -0.8747538328170776, "all_perturbed_sampled_ll": [-2.340233325958252], "all_perturbed_original_ll": [-1.3796049356460571], "perturbed_sampled_ll": -2.340233325958252, "perturbed_original_ll": -1.3796049356460571, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n a,b,_=sorted(map(int,input().split()))\n if a==0:break\n for _ in[0]*int(input()):print(\"OK\"if(int(input())*2)**2>a*a+b*b else\"NA\")\n", "sampled": "import math\n\nwhile True:\n    line = input().split()\n    A, B, C = int(line[0]), int(line[1]), int(line[2])\n    \n    if A == 0 and B == 0 and C == 0:\n        break\n    \n    # The smallest diagonal that can fit through a circle of radius R\n    # is when we orient the cheese optimally through the hole.\n    # The cheese can pass through if the smallest cross-sectional diagonal\n    # fits in the circle of radius R.\n    \n    # For a parallelepiped with dimensions A, B, C, the smallest\n    # cross-sectional diagonal occurs when we look at the rectangular\n    # faces. The diagonals of the three faces are:\n    # sqrt(A^2 + B^2), sqrt(B^2 + C^2), sqrt(A^2 + C^2)\n    \n    # The smallest of these is what we need to fit through the hole\n    # (divided by 2 for radius)\n    \n    sides = [A, B, C]\n    sides.sort()\n    \n    # The minimum diagonal is between the two smallest sides\n    min_diagonal = math.sqrt(sides[0]**2 + sides[1]**2)\n    min_radius_needed = min_diagonal / 2\n    \n    n = int(input())\n    \n    for _ in range(n):\n        R = int(input())\n        if R > min_radius_needed:\n            print(\"OK\")\n        else:\n            print(\"NA\")\n", "perturbed_sampled": ["import math while True: line = input().split() A, B, C = int(line[0]), int(line[1]), int(line[2]) if A == 0 and B == 0  can fit through a circle of radius R # is when we orient the cheese optimally through the hole. # The cheese can pass  circle of radius R. # For a parallelepiped with dimensions A, B, C, the smallest # cross-sectional diagonal occurs when we look at  are: # sqrt(A^2 + B^2), sqrt(B^2 + C^2),  we need to fit through the hole # (divided by 2 for radius) sides = [A, B, C] sides.sort() # The minimum diagonal is between the two smallest sides min_diagonal  = int(input()) for _ in range(n): R = int(input()) if R > min_radius_needed: print(\"OK\") else: print(\"NA\")"], "perturbed_original": ["while 1: a,b,_=sorted(map(int,input().split())) if a==0:break for _ in[0]*int(input()):print(\"OK\"if(int(input())*2)**2>a*a+b*b else\"NA\")"], "original_ll": -2.9978604316711426, "sampled_ll": -1.3626108169555664, "all_perturbed_sampled_ll": [-2.564142942428589], "all_perturbed_original_ll": [-2.99967360496521], "perturbed_sampled_ll": -2.564142942428589, "perturbed_original_ll": -2.99967360496521, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint expr(char **s);\n\nint number(char **s) {\n  int val = 0;\n  while ('0' <= **s && **s <= '9') {\n    val = val * 10 + **s - '0';\n    (*s)++;\n  }\n  return val;\n}\n\nint factor(char **s) {\n  if (**s == '(') {\n    (*s)++;\n    int val = expr(s);\n    (*s)++;\n    return val;\n  }\n  return number(s);\n}\n\nint term(char **s) {\n  int val = factor(s);\n  while (1) {\n    if (**s == '*') {\n      (*s)++;\n      val *= factor(s);\n    } else if (**s == '/') {\n      (*s)++;\n      val /= factor(s);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint expr(char **s) {\n  int val = term(s);\n  while (1) {\n    if (**s == '+') {\n      (*s)++;\n      val += term(s);\n    } else if (**s == '-') {\n      (*s)++;\n      val -= term(s);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  char s[101];\n  while (n--) {\n    scanf(\"%s\", s);\n    char *p = s;\n    printf(\"%d\\n\", expr(&p));\n  }\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar expr[105];\nint pos;\n\nlong long parse_expr();\nlong long parse_term();\nlong long parse_factor();\n\nlong long parse_number() {\n    long long num = 0;\n    int sign = 1;\n    \n    if (expr[pos] == '-') {\n        sign = -1;\n        pos++;\n    } else if (expr[pos] == '+') {\n        pos++;\n    }\n    \n    while (isdigit(expr[pos])) {\n        num = num * 10 + (expr[pos] - '0');\n        pos++;\n    }\n    \n    return sign * num;\n}\n\nlong long parse_factor() {\n    if (expr[pos] == '(') {\n        pos++; // skip '('\n        long long result = parse_expr();\n        pos++; // skip ')'\n        return result;\n    } else {\n        return parse_number();\n    }\n}\n\nlong long parse_term() {\n    long long result = parse_factor();\n    \n    while (expr[pos] == '*' || expr[pos] == '/') {\n        char op = expr[pos];\n        pos++;\n        long long right = parse_factor();\n        if (op == '*') {\n            result = result * right;\n        } else {\n            result = result / right;\n        }\n    }\n    \n    return result;\n}\n\nlong long parse_expr() {\n    long long result = parse_term();\n    \n    while (expr[pos] == '+' || expr[pos] == '-') {\n        char op = expr[pos];\n        pos++;\n        long long right = parse_term();\n        if (op == '+') {\n            result = result + right;\n        } else {\n            result = result - right;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    getchar();\n    \n    while (n--) {\n        fgets(expr, 105, stdin);\n        pos = 0;\n        long long result = parse_expr();\n        printf(\"%lld\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <ctype.h> char expr[105]; int pos; long  parse_number() { long long num = 0; int sign = 1; if (expr[pos] == '-') { sign =  } while (isdigit(expr[pos]))  pos++; } return sign * num; } long long parse_factor() { if (expr[pos] == '(') { pos++; // skip '(' long long result = parse_expr();  parse_number(); } } long long parse_term() { long long result = parse_factor(); while (expr[pos] == '*' ||  long right  * right; } else { result = result / right; } } return result; } long long parse_expr() { long long result = parse_term(); while (expr[pos] == '+' || expr[pos] == '-') { char op = expr[pos]; pos++; long long right = parse_term(); if (op == '+') { result = result + right; } else { result = result - right; } } return result; } int main() { int n; scanf(\"%d\", &n); getchar(); while (n--) { fgets(expr, 105, stdin); pos = 0; long long result = parse_expr(); printf(\"%lld\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> int expr(char **s); int number(char **s) { int val = 0; while ('0' <= **s && **s <= '9') { val = val * 10 + **s - '0'; (*s)++;  == '(') { (*s)++; int   { if (**s == '*') { (*s)++; val  val /= factor(s); } else { break; } } return val; } int expr(char **s) { int val = term(s); while (1) { if (**s == '+') { (*s)++; val += term(s); } else if (**s == '-') { (*s)++; val -= term(s); } else { break; } } return val; } int main() { int n; scanf(\"%d\", &n); char s[101]; while (n--) { scanf(\"%s\", s); char *p = s; printf(\"%d\\n\", expr(&p)); } }"], "original_ll": -0.4484841823577881, "sampled_ll": -0.33498165011405945, "all_perturbed_sampled_ll": [-1.1858981847763062], "all_perturbed_original_ll": [-1.2471932172775269], "perturbed_sampled_ll": -1.1858981847763062, "perturbed_original_ll": -1.2471932172775269, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic String str;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstr = sc.next();\n\t\t\tpos = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic int expression() {\n\t\tint ret = term();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '+') {\n\t\t\t\tpos++;\n\t\t\t\tret += term();\n\t\t\t} else if (str.charAt(pos) == '-') {\n\t\t\t\tpos++;\n\t\t\t\tret -= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int term() {\n\t\tint ret = factor();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '*') {\n\t\t\t\tpos++;\n\t\t\t\tret *= factor();\n\t\t\t} else if (str.charAt(pos) == '/') {\n\t\t\t\tpos++;\n\t\t\t\tret /= factor();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int factor() {\n\t\tif (str.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\tint temp = expression();\n\t\t\tpos++;\n\t\t\treturn temp;\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\n\tstatic int number() {\n\t\tint ret = 0;\n\t\twhile (Character.isDigit(str.charAt(pos))) {\n\t\t\tret *= 10;\n\t\t\tret += str.charAt(pos) - '0';\n\t\t\tpos++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static String expr;\n    static int pos;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            expr = sc.nextLine().trim();\n            pos = 0;\n            System.out.println(parseExpression());\n        }\n        sc.close();\n    }\n    \n    static long parseExpression() {\n        long result = parseTerm();\n        \n        while (pos < expr.length() && (expr.charAt(pos) == '+' || expr.charAt(pos) == '-')) {\n            char op = expr.charAt(pos);\n            pos++;\n            long term = parseTerm();\n            if (op == '+') {\n                result += term;\n            } else {\n                result -= term;\n            }\n        }\n        \n        return result;\n    }\n    \n    static long parseTerm() {\n        long result = parseFactor();\n        \n        while (pos < expr.length() && (expr.charAt(pos) == '*' || expr.charAt(pos) == '/')) {\n            char op = expr.charAt(pos);\n            pos++;\n            long factor = parseFactor();\n            if (op == '*') {\n                result *= factor;\n            } else {\n                result /= factor;\n            }\n        }\n        \n        return result;\n    }\n    \n    static long parseFactor() {\n        if (expr.charAt(pos) == '(') {\n            pos++;\n            long result = parseExpression();\n            pos++;\n            return result;\n        }\n        \n        boolean negative = false;\n        if (expr.charAt(pos) == '-') {\n            negative = true;\n            pos++;\n        } else if (expr.charAt(pos) == '+') {\n            pos++;\n        }\n        \n        long num = 0;\n        while (pos < expr.length() && Character.isDigit(expr.charAt(pos))) {\n            num = num * 10 + (expr.charAt(pos) - '0');\n            pos++;\n        }\n        \n        return negative ? -num : num;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static String expr; static int pos; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); for (int i = 0; i < n; i++) { expr = sc.nextLine().trim(); pos = 0; System.out.println(parseExpression()); } sc.close(); } static long parseExpression() { long result  || expr.charAt(pos) == '-'))  if (op   { long result = parseFactor(); while (pos < expr.length() && (expr.charAt(pos) == '*' || expr.charAt(pos) == '/')) { char op = expr.charAt(pos); pos++; long factor = parseFactor(); if (op == '*') { result *= factor; }  static long parseFactor() { if (expr.charAt(pos) == '(') { pos++; long result = parseExpression(); pos++; return result; } boolean negative = false; if (expr.charAt(pos) == '-') { negative = true; pos++; } else if (expr.charAt(pos)  (pos < expr.length() && Character.isDigit(expr.charAt(pos))) { num = num * 10 + (expr.charAt(pos) - '0'); pos++; } return negative ? -num : num; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { static String str; static int pos; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i < n; i++) { str = sc.next(); pos = 0; System.out.println(expression()); } sc.close(); } static int expression() { int ret = term(); while (str.charAt(pos) != '=') { if (str.charAt(pos) == '+') { pos++; ret += term(); } else if (str.charAt(pos) == '-') { pos++; ret -= term(); } else { break; } } return ret; } static int term() { int ret = factor(); while (str.charAt(pos)  pos++; ret /= factor(); } else { break; } } return ret; } static int factor() { if (str.charAt(pos) == '(') { pos++; int temp = expression(); pos++;  int number() { int  }"], "original_ll": -0.4352850317955017, "sampled_ll": -0.3394372761249542, "all_perturbed_sampled_ll": [-1.1243822574615479], "all_perturbed_original_ll": [-1.2190146446228027], "perturbed_sampled_ll": -1.1243822574615479, "perturbed_original_ll": -1.2190146446228027, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    rpn = \"\"\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            r = b/a\n            if b < 0 and b % a != 0:\n                r += 1\n            St.append(r)\n        else:\n            St.append(i)\n\n    return St[0]\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n    print int(RPN_cul(L))", "sampled": "def evaluate(expr):\n    expr = expr.strip().rstrip('=')\n    \n    def parse_number(s, i):\n        j = i\n        if j < len(s) and s[j] in '+-':\n            j += 1\n        while j < len(s) and s[j].isdigit():\n            j += 1\n        return int(s[i:j]), j\n    \n    def parse_factor(s, i):\n        if s[i] == '(':\n            val, j = parse_expr(s, i + 1)\n            return val, j + 1\n        else:\n            return parse_number(s, i)\n    \n    def parse_term(s, i):\n        left, i = parse_factor(s, i)\n        while i < len(s) and s[i] in '*/':\n            op = s[i]\n            right, i = parse_factor(s, i + 1)\n            if op == '*':\n                left = left * right\n            else:\n                left = int(left / right)\n        return left, i\n    \n    def parse_expr(s, i):\n        left, i = parse_term(s, i)\n        while i < len(s) and s[i] in '+-' and (i == 0 or s[i-1] not in '(+*-/'):\n            op = s[i]\n            right, i = parse_term(s, i + 1)\n            if op == '+':\n                left = left + right\n            else:\n                left = left - right\n        return left, i\n    \n    result, _ = parse_expr(expr, 0)\n    return result\n\nn = int(input())\nfor _ in range(n):\n    expr = input()\n    print(evaluate(expr))\n", "perturbed_sampled": ["def evaluate(expr): expr = expr.strip().rstrip('=') def parse_number(s, i): j = i if j  j < len(s) and s[j].isdigit():  s[i] == '(': val, j = parse_expr(s, i + 1) return val, j + 1 else: return parse_number(s, i) def parse_term(s, i): left, i = parse_factor(s, i) while i <  = parse_factor(s, i + 1) if op == '*': left = left * right else: left = int(left / right) return left, i def parse_expr(s, i): left, i = parse_term(s, i) while i <  s[i-1] not in '(+*-/'): op =  == '+': left = left + right else: left = left - right return left, i result, _ = parse_expr(expr, 0) return result n = int(input()) for _ in range(n): expr = input() print(evaluate(expr))"], "perturbed_original": ["def String2List(s): L = []  if s[i].isdigit() and flag: t = \"\" j = 0 while s[i+j].isdigit(): t += s[i+j] if i+j == l-1: break j += 1 L.append(t) flag = False elif not s[i].isdigit(): L.append(s[i]) flag = True return L def RPN_list(L): S, L2 = [], [] table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1} rpn = \"\" for i in L: if i.isdigit(): L2.append(i) elif i == \"(\":  S.pop() else: if len(S) != 0 and (table[S[-1]] >= table[i]): L2.append(S.pop()) S.append(i) while len(S) != 0: L2.append(S.pop()) return L2 def RPN_cul(L): St = [] for i in L: if i == '+': St.append(int(St.pop()) + int(St.pop())) elif i == '-': St.append(-int(St.pop())  i == '/': a = int(St.pop()) b = float(St.pop())  a != 0: r += 1 St.append(r)  range(N): s = raw_input() L = String2List(s[:-1]) L = RPN_list(L) print int(RPN_cul(L))"], "original_ll": -0.824628472328186, "sampled_ll": -0.6011657118797302, "all_perturbed_sampled_ll": [-1.7812938690185547], "all_perturbed_original_ll": [-1.5476932525634766], "perturbed_sampled_ll": -1.7812938690185547, "perturbed_original_ll": -1.5476932525634766, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define DIGIT (pow(10, (strlen(num) - 1 -j)))\n\nint solved(char num[100], int i){\n  int s = 0, j;\n  for(j = 0;j < strlen(num);j++){\n    if(num[j] == 'X')\n      s += i * DIGIT;\n    else \n      s += (num[j] - '0') * DIGIT;\n  }\n  return s;\n}\n\nint main(){\n  int a, b, c, i, j;\n  char calc[100], *f, *s, *ans;\n  while(scanf(\"%s\", calc) != EOF){\n    f = strtok(calc, \"+\");\n    s = strtok(NULL, \"=\");\n    ans = strtok(NULL, \",\");\n    \n    for(i = 0;i < 10;i++)\n      if(solved(f, i) + solved(s, i) == solved(ans, i)){\n\tprintf(\"%d\\n\", i);\n\tbreak;\n      }\n    if(i > 9)\n      puts(\"NA\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint hasLeadingZero(char *str) {\n    if (strlen(str) > 1 && str[0] == '0') {\n        return 1;\n    }\n    return 0;\n}\n\nint checkEquation(char *left1, char *left2, char *right) {\n    if (hasLeadingZero(left1) || hasLeadingZero(left2) || hasLeadingZero(right)) {\n        return 0;\n    }\n    \n    long long num1 = atoll(left1);\n    long long num2 = atoll(left2);\n    long long sum = atoll(right);\n    \n    return (num1 + num2 == sum);\n}\n\nvoid replaceX(char *str, char digit, char *result) {\n    int i;\n    for (i = 0; str[i]; i++) {\n        if (str[i] == 'X') {\n            result[i] = digit;\n        } else {\n            result[i] = str[i];\n        }\n    }\n    result[i] = '\\0';\n}\n\nint main() {\n    char input[256];\n    \n    while (fgets(input, sizeof(input), stdin)) {\n        input[strcspn(input, \"\\n\")] = 0;\n        \n        char *plus = strchr(input, '+');\n        char *equal = strchr(input, '=');\n        \n        if (!plus || !equal) continue;\n        \n        char left1[128], left2[128], right[128];\n        \n        int len1 = plus - input;\n        int len2 = equal - plus - 1;\n        int len3 = strlen(equal + 1);\n        \n        strncpy(left1, input, len1);\n        left1[len1] = '\\0';\n        \n        strncpy(left2, plus + 1, len2);\n        left2[len2] = '\\0';\n        \n        strcpy(right, equal + 1);\n        \n        int found = -1;\n        int count = 0;\n        \n        for (int digit = 0; digit <= 9; digit++) {\n            char temp1[128], temp2[128], temp3[128];\n            char digitChar = '0' + digit;\n            \n            replaceX(left1, digitChar, temp1);\n            replaceX(left2, digitChar, temp2);\n            replaceX(right, digitChar, temp3);\n            \n            if (checkEquation(temp1, temp2, temp3)) {\n                found = digit;\n                count++;\n            }\n        }\n        \n        if (count == 1) {\n            printf(\"%d\\n\", found);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int hasLeadingZero(char  { return 1; } return 0; } int checkEquation(char *left1, char *left2, char *right) { if (hasLeadingZero(left1) || hasLeadingZero(left2) || hasLeadingZero(right)) { return 0; } long long num1 = atoll(left1); long long num2 = atoll(left2); long long sum = atoll(right); return (num1 + num2 == sum); } void replaceX(char *str, char digit, char *result) { int i; for (i = 0; str[i]; i++) { if (str[i] == 'X') { result[i] = digit; } else { result[i] = str[i]; } } result[i] = '\\0'; } int main() {  strchr(input, '='); if  = plus - input; int len2 = equal - plus - 1; int len3  strncpy(left2, plus + 1, len2); left2[len2] = '\\0'; strcpy(right, equal + 1); int  = 0; digit <= 9; digit++) { char temp1[128], temp2[128], temp3[128]; char digitChar = '0' + digit; replaceX(left1, digitChar, temp1); replaceX(left2, digitChar, temp2); replaceX(right, digitChar, temp3); if (checkEquation(temp1, temp2, temp3)) { found = digit; count++; } } if (count ==  return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include  num[100], int i){ int s = 0, j; for(j = 0;j < strlen(num);j++){ if(num[j] == 'X') s += i * DIGIT; else s += (num[j] - '0') * DIGIT; } return s; } int main(){ int a, b, c, i, j; char calc[100], *f, *s, *ans;  < 10;i++) if(solved(f, i) + solved(s, i) == solved(ans, i)){ printf(\"%d\\n\", i); break; } if(i > 9) puts(\"NA\"); } return 0; }"], "original_ll": -1.224336862564087, "sampled_ll": -0.578223466873169, "all_perturbed_sampled_ll": [-1.3328659534454346], "all_perturbed_original_ll": [-2.030029773712158], "perturbed_sampled_ll": -1.3328659534454346, "perturbed_original_ll": -2.030029773712158, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n    Scanner in = new Scanner(System.in);\n\n    void solve(){\n        String s;\n        while(in.hasNextLine()){\n            s = in.nextLine();\n            calc(s);\n        }\n    }\n    void calc(String str){\n        String a = str.substring(0, str.indexOf('+'));\n        String b = str.substring(str.indexOf('+') + 1, str.indexOf('='));\n        String c = str.substring(str.indexOf('=') + 1);\n        for(int i = 0; i < 10; i++){\n            String left = sum(a, b, i);\n            String right = c.replace(\"X\", String.valueOf(i));\n            if(left.equals(right)){\n                System.out.println(i);\n                return;\n            }\n        }\n        System.out.println(\"NA\");\n    }\n\n    String sum(String a, String b, int rep){\n        StringBuilder ans  = new StringBuilder();\n        a = new StringBuilder(a.replace(\"X\", String.valueOf(rep))).reverse().toString();\n        b = new StringBuilder(b.replace(\"X\", String.valueOf(rep))).reverse().toString();\n\n        int t = 0;\n        for(int i = 0; i < Math.max(a.length(), b.length()); i++){\n            int x = i < a.length() ? a.charAt(i) - '0' : 0;\n            int y = i < b.length() ? b.charAt(i) - '0' : 0;\n            ans.append(String.valueOf((x + y + t) % 10));\n            t = (x + y + t) / 10;\n        }\n\n        if(t != 0){\n            ans.append(String.valueOf(t));\n        }\n\n        return ans.reverse().toString();\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();    \n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String result = solve(line);\n            System.out.println(result);\n        }\n        sc.close();\n    }\n    \n    static String solve(String equation) {\n        String[] parts = equation.split(\"=\");\n        String leftSide = parts[0];\n        String rightSide = parts[1];\n        \n        String[] addends = leftSide.split(\"\\\\+\");\n        String num1Pattern = addends[0];\n        String num2Pattern = addends[1];\n        String sumPattern = rightSide;\n        \n        int validDigit = -1;\n        int validCount = 0;\n        \n        for (int x = 0; x <= 9; x++) {\n            String num1Str = num1Pattern.replace('X', (char)('0' + x));\n            String num2Str = num2Pattern.replace('X', (char)('0' + x));\n            String sumStr = sumPattern.replace('X', (char)('0' + x));\n            \n            // Check for leading zeros\n            if (num1Str.length() > 1 && num1Str.charAt(0) == '0') continue;\n            if (num2Str.length() > 1 && num2Str.charAt(0) == '0') continue;\n            if (sumStr.length() > 1 && sumStr.charAt(0) == '0') continue;\n            \n            try {\n                long num1 = Long.parseLong(num1Str);\n                long num2 = Long.parseLong(num2Str);\n                long sum = Long.parseLong(sumStr);\n                \n                if (num1 + num2 == sum) {\n                    validDigit = x;\n                    validCount++;\n                }\n            } catch (NumberFormatException e) {\n                // Skip invalid numbers\n            }\n        }\n        \n        if (validCount == 1) {\n            return String.valueOf(validDigit);\n        } else {\n            return \"NA\";\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) <extra_id_6>;<extra_id_7>for (<extra_id_8>1; if<extra_id_9>+ 7 )<extra_id_10>(long i<extra_id_11>{ if ( (x<extra_id_12>(X)<extra_id_13>in) { if<extra_id_14>x<extra_id_15>) ; if (<extra_id_16>+ x * 1.0<extra_id_17>{ if<extra_id_18>validCount > 2 || ( =  String[] parts = equation.split(\"=\"); String leftSide = parts[0]; String rightSide = parts[1]; String[] addends = leftSide.split(\"\\\\+\"); String num1Pattern = addends[0]; String num2Pattern = addends[1]; String sumPattern = rightSide; int validDigit = -1; int validCount = 0; for (int x = 0; x <= 9; x++) { String num1Str = num1Pattern.replace('X', (char)('0' + x)); String num2Str = num2Pattern.replace('X', (char)('0' + x)); String sumStr = sumPattern.replace('X', (char)('0' + x)); // Check for leading zeros if (num1Str.length() > 1 && num1Str.charAt(0) == '0') continue; if (num2Str.length() > 1 && num2Str.charAt(0) == '0') continue; if (sumStr.length() >  = Long.parseLong(num1Str); long num2 = Long.parseLong(num2Str); long sum = Long.parseLong(sumStr); if (num1 + num2  (NumberFormatException  == 1) { return String.valueOf(validDigit); } else { return \"NA\"; } } }"], "perturbed_original": ["import java.util.*; public class Main{ Scanner in = new Scanner(System.in); void solve(){ String s; while(in.hasNextLine()){ s = in.nextLine(); calc(s);  String b = str.substring(str.indexOf('+') + 1, str.indexOf('=')); String c = str.substring(str.indexOf('=') + 1); for(int i = 0; i  right = c.replace(\"X\",  a, String b, int rep){ StringBuilder ans = new StringBuilder(); a = new StringBuilder(a.replace(\"X\", String.valueOf(rep))).reverse().toString(); b = new StringBuilder(b.replace(\"X\", String.valueOf(rep))).reverse().toString(); int t = 0; for(int i = 0; i < Math.max(a.length(), b.length()); i++){ int x = i < a.length() ? a.charAt(i) - '0' : 0; int y = i < b.length() ? b.charAt(i) - '0' : 0; ans.append(String.valueOf((x + y + t) % 10)); t  != 0){ ans.append(String.valueOf(t)); } return ans.reverse().toString(); } public static void main(String[] args){ new Main().solve(); } }"], "original_ll": -0.6696752309799194, "sampled_ll": -0.5826807618141174, "all_perturbed_sampled_ll": [-1.5876761674880981], "all_perturbed_original_ll": [-1.3736112117767334], "perturbed_sampled_ll": -1.5876761674880981, "perturbed_original_ll": -1.3736112117767334, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        string = raw_input()\n    except EOFError:\n        break\n    for i in range(10):\n        translated = string.replace(\"X\",str(i))\n        left,right = translated.split(\"=\")\n        first,second = left.split(\"+\")\n        if i == 0 and any((first[0]==\"0\",second[0]==\"0\",right[0]==\"0\")):\n            continue\n        elif int(first) + int(second) == int(right):\n            print i\n            break\n    else:\n        print \"NA\"", "sampled": "import sys\n\ndef solve(equation):\n    parts = equation.split('=')\n    left_parts = parts[0].split('+')\n    num1 = left_parts[0]\n    num2 = left_parts[1]\n    result = parts[1]\n    \n    for digit in range(10):\n        digit_str = str(digit)\n        \n        # Replace X with the digit\n        n1 = num1.replace('X', digit_str)\n        n2 = num2.replace('X', digit_str)\n        res = result.replace('X', digit_str)\n        \n        # Check for leading zeros (except for single digit numbers)\n        if len(n1) > 1 and n1[0] == '0':\n            continue\n        if len(n2) > 1 and n2[0] == '0':\n            continue\n        if len(res) > 1 and res[0] == '0':\n            continue\n        \n        # Check if the equation holds\n        try:\n            if int(n1) + int(n2) == int(res):\n                return digit_str\n        except:\n            continue\n    \n    return \"NA\"\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        print(solve(line))\n", "perturbed_sampled": ["import sys def solve(equation):  = left_parts[1] result = parts[1] for digit in range(10): digit_str = str(digit) # Replace X  digit_str) res = result.replace('X', digit_str) # Check for leading zeros (except for single digit numbers) if len(n1) > 1 and n1[0] == '0': continue if len(n2) > 1 and n2[0] == '0': continue if len(res) > 1 and res[0] == '0': continue # Check if the equation holds try: if int(n1) + int(n2)  in sys.stdin: line = line.strip() if line: print(solve(line))"], "perturbed_original": ["while True: try: string = raw_input() except EOFError: break for i in range(10): translated = string.replace(\"X\",str(i)) left,right = translated.split(\"=\") first,second =  + int(second) == int(right): print i break else: print \"NA\""], "original_ll": -1.5506529808044434, "sampled_ll": -0.8043312430381775, "all_perturbed_sampled_ll": [-2.0497963428497314], "all_perturbed_original_ll": [-2.7207326889038086], "perturbed_sampled_ll": -2.0497963428497314, "perturbed_original_ll": -2.7207326889038086, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,stk,x[3];\nchar tex[1000000],code[1000000];\nchar encode[64][6]={\n\"11010\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"11110\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"11100\",\n\"11101\",\n\"11011\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"11111\",\n\"\",\n\"00000\",\n\"00001\",\n\"00010\",\n\"00011\",\n\"00100\",\n\"00101\",\n\"00110\",\n\"00111\",\n\"01000\",\n\"01001\",\n\"01010\",\n\"01011\",\n\"01100\",\n\"01101\",\n\"01110\",\n\"01111\",\n\"10000\",\n\"10001\",\n\"10010\",\n\"10011\",\n\"10100\",\n\"10101\",\n\"10110\",\n\"10111\",\n\"11000\",\n\"11001\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\"}\n,decode[100000000];\n\nint main(){\n\tdecode[212]=' ';\n\tdecode[111111]='\\'';\n\tdecode[111122]=',';\n\tdecode[21121112]='-';\n\tdecode[121112]='.';\n\tdecode[111112]='?';\n\tdecode[211212]='A';\n\tdecode[21122121]='B';\n\tdecode[1212]='C';\n\tdecode[1112]='D';\n\tdecode[221]='E';\n\tdecode[12112]='F';\n\tdecode[21122122]='G';\n\tdecode[121111]='H';\n\tdecode[1222]='I';\n\tdecode[21122111]='J';\n\tdecode[1221]='K';\n\tdecode[11211]='L';\n\tdecode[21122112]='M';\n\tdecode[21122221]='N';\n\tdecode[11212]='O';\n\tdecode[222]='P';\n\tdecode[21122222]='Q';\n\tdecode[2111]='R';\n\tdecode[11221]='S';\n\tdecode[11222]='T';\n\tdecode[21122211]='U';\n\tdecode[21122212]='V';\n\tdecode[111121]='W';\n\tdecode[21121121]='X';\n\tdecode[21121122]='Y';\n\tdecode[21121111]='Z';\n\n\twhile(fgets(tex,900000,stdin)!=NULL){\n\t\tstrcpy(code,\"\");\n\t\tfor(i=0;i<strlen(tex);i++){\n\t\t\tstrcat(code,encode[tex[i]-' ']);\n\t\t}\n\t\tstk=0;\n\t\tfor(i=0;i<strlen(code);i++){\n\t\t\tstk=stk*10+code[i]-'0'+1;\n\t\t\tif(decode[stk]>0){\n\t\t\t\tprintf(\"%c\",decode[stk]);\n\t\t\t\tstk=0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%\\n\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* char_to_code[] = {\n    \"00000\", \"10000\", \"01000\", \"00100\", \"00010\", \"11000\", \"10100\", \"01100\",\n    \"00110\", \"10010\", \"01010\", \"11100\", \"10110\", \"01110\", \"11010\", \"11110\",\n    \"00001\", \"10001\", \"01001\", \"00101\", \"10101\", \"01101\", \"11001\", \"10011\",\n    \"01011\", \"11101\", \"10111\", \"01111\", \"11011\", \"11111\", \"00011\", \"00111\"\n};\n\nchar chars[] = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ'-.,?\";\n\nchar* code_to_char[] = {\n    \"0\", \"100\", \"10\", \"1\", \"1010\", \"10100\", \"101000\", \"101\",\n    \"110\", \"1100\", \"11\", \"10101\", \"101010\", \"10110\", \"101011\", \"101100\",\n    \"1011\", \"10111\", \"1000\", \"1001\", \"100100\", \"100101\", \"10010\", \"100110\",\n    \"100111\", \"10011\", \"101000\", \"101001\", \"101010\", \"101011\", \"11\", \"111\"\n};\n\nint main() {\n    char input[256];\n    \n    while (fgets(input, sizeof(input), stdin)) {\n        int len = strlen(input);\n        if (len > 0 && input[len-1] == '\\n') {\n            input[len-1] = '\\0';\n            len--;\n        }\n        \n        char binary[10000] = \"\";\n        \n        for (int i = 0; i < len; i++) {\n            char c = input[i];\n            int found = 0;\n            for (int j = 0; j < 32; j++) {\n                if (chars[j] == c) {\n                    strcat(binary, char_to_code[j]);\n                    found = 1;\n                    break;\n                }\n            }\n        }\n        \n        char result[1000] = \"\";\n        int pos = 0;\n        int binlen = strlen(binary);\n        \n        while (pos < binlen) {\n            int found = 0;\n            for (int trylen = 1; trylen <= binlen - pos && trylen <= 10; trylen++) {\n                char temp[20];\n                strncpy(temp, binary + pos, trylen);\n                temp[trylen] = '\\0';\n                \n                for (int j = 0; j < 32; j++) {\n                    if (strcmp(code_to_char[j], temp) == 0) {\n                        int resultlen = strlen(result);\n                        result[resultlen] = chars[j];\n                        result[resultlen + 1] = '\\0';\n                        pos += trylen;\n                        found = 1;\n                        break;\n                    }\n                }\n                if (found) break;\n            }\n            \n            if (!found) {\n                pos++;\n            }\n        }\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> char* char_to_code[] = { \"00000\", \"10000\", \"01000\", \"00100\", \"00010\", \"11000\", \"10100\", \"01100\", \"00110\", \"10010\", \"01010\", \"11100\", \"10110\", \"01110\", \"11010\", \"11110\", \"00001\", \"10001\", \"01001\", \"00101\", \"10101\", \"01101\", \"11001\", \"10011\", \"01011\", \"11101\", \"10111\", \"01111\", \"11011\", \"11111\", [<extra_id_11>(char*) char_to_code[j<extra_id_12>int pos<extra_id_13>;<extra_id_14>char[] chars = this.char_to_code.copy(); int<extra_id_15>= strlen(chars); int j = { \"0\", \"100\", \"10\", \"1\", \"1010\", \"10100\", \"101000\", \"101\",  \"1000\", \"1001\", \"100100\", \"100101\", \"10010\", \"100110\", \"100111\", \"10011\", \"101000\", \"101001\", \"101010\", \"101011\", \"11\", \"111\" }; int main() { char input[256]; while (fgets(input, sizeof(input), stdin)) { int len = strlen(input); if (len >  } char binary[10000] = \"\"; for (int i = 0; i  = 0; for (int j = 0; j < 32; j++) { if (chars[j] == c) { strcat(binary, char_to_code[j]); found = 1; break; } } } char result[1000] = \"\"; int pos = 0; int binlen = strlen(binary); while (pos < binlen) { int found = 0; for (int trylen = 1; trylen <= binlen - pos && trylen <= 10; trylen++) {  { if (strcmp(code_to_char[j], temp) == 0) { int resultlen = strlen(result); result[resultlen] = chars[j]; result[resultlen + 1]  } if (found) break; } if (!found) { pos++; } } printf(\"%s\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int i,stk,x[3]; char tex[1000000],code[1000000]; char  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"11111\", \"\", \"00000\", \"00001\", \"00010\", \"00011\", \"00100\", \"00101\", \"00110\", \"00111\", \"01000\", \"01001\", \"01010\", \"01011\", \"01100\", \"01101\", \"01110\", \"01111\", \"10000\", \"10001\", \"10010\", \"10011\", \"10100\", \"10101\", \"10110\", \"10111\", \"11000\", \"11001\", \"\", \"\", \"\", \"\", \"\"} ,decode[100000000]; int main(){ decode[212]=' '; decode[111111]='\\''; decode[111122]=','; decode[21121112]='-'; decode[121112]='.'; decode[111112]='?'; decode[211212]='A'; decode[21122121]='B'; decode[1212]='C'; decode[1112]='D'; decode[221]='E'; decode[12112]='F'; decode[21122122]='G'; decode[121111]='H'; decode[1222]='I'; decode[21122111]='J'; decode[1221]='K'; decode[11211]='L'; decode[21122112]='M'; decode[21122221]='N'; decode[11212]='O'; decode[222]='P'; decode[21122222]='Q'; decode[2111]='R'; decode[11221]='S'; decode[11222]='T'; decode[21122211]='U'; decode[21122212]='V'; decode[111121]='W'; decode[21121121]='X'; decode[21121122]='Y'; decode[21121111]='Z'; while(fgets(tex,900000,stdin)!=NULL){ strcpy(code,\"\"); for(i=0;i<strlen(tex);i++){ strcat(code,encode[tex[i]-' ']); } stk=0;  0; }"], "original_ll": -0.7804712653160095, "sampled_ll": -0.5894367098808289, "all_perturbed_sampled_ll": [-1.1622397899627686], "all_perturbed_original_ll": [-0.9040788412094116], "perturbed_sampled_ll": -1.1622397899627686, "perturbed_original_ll": -0.9040788412094116, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\n\npublic class Main {\n\n\tstatic final HashMap<Character, String> c1 = new HashMap<Character, String>(32) {\n\t\t{\n\t\t\tput('A', \"00000\");\n\t\t\tput('B', \"00001\");\n\t\t\tput('C', \"00010\");\n\t\t\tput('D', \"00011\");\n\t\t\tput('E', \"00100\");\n\t\t\tput('F', \"00101\");\n\t\t\tput('G', \"00110\");\n\t\t\tput('H', \"00111\");\n\t\t\tput('I', \"01000\");\n\t\t\tput('J', \"01001\");\n\t\t\tput('K', \"01010\");\n\t\t\tput('L', \"01011\");\n\t\t\tput('M', \"01100\");\n\t\t\tput('N', \"01101\");\n\t\t\tput('O', \"01110\");\n\t\t\tput('P', \"01111\");\n\t\t\tput('Q', \"10000\");\n\t\t\tput('R', \"10001\");\n\t\t\tput('S', \"10010\");\n\t\t\tput('T', \"10011\");\n\t\t\tput('U', \"10100\");\n\t\t\tput('V', \"10101\");\n\t\t\tput('W', \"10110\");\n\t\t\tput('X', \"10111\");\n\t\t\tput('Y', \"11000\");\n\t\t\tput('Z', \"11001\");\n\t\t\tput(' ', \"11010\");\n\t\t\tput('.', \"11011\");\n\t\t\tput(',', \"11100\");\n\t\t\tput('-', \"11101\");\n\t\t\tput('\\'', \"11110\");\n\t\t\tput('?', \"11111\");\n\t\t}\n\t};\n\n\tstatic final HashMap<String, Character> c2 = new HashMap<String, Character>(32) {\n\t\t{\n\t\t\tput(\"101\", ' ');\n\t\t\tput(\"000000\", '\\'');\n\t\t\tput(\"000011\", ',');\n\t\t\tput(\"10010001\", '-');\n\t\t\tput(\"010001\", '.');\n\t\t\tput(\"000001\", '?');\n\t\t\tput(\"100101\", 'A');\n\t\t\tput(\"10011010\", 'B');\n\t\t\tput(\"0101\", 'C');\n\t\t\tput(\"0001\", 'D');\n\t\t\tput(\"110\", 'E');\n\t\t\tput(\"01001\", 'F');\n\t\t\tput(\"10011011\", 'G');\n\t\t\tput(\"010000\", 'H');\n\t\t\tput(\"0111\", 'I');\n\t\t\tput(\"10011000\", 'J');\n\t\t\tput(\"0110\", 'K');\n\t\t\tput(\"00100\", 'L');\n\t\t\tput(\"10011001\", 'M');\n\t\t\tput(\"10011110\", 'N');\n\t\t\tput(\"00101\", 'O');\n\t\t\tput(\"111\", 'P');\n\t\t\tput(\"10011111\", 'Q');\n\t\t\tput(\"1000\", 'R');\n\t\t\tput(\"00110\", 'S');\n\t\t\tput(\"00111\", 'T');\n\t\t\tput(\"10011100\", 'U');\n\t\t\tput(\"10011101\", 'V');\n\t\t\tput(\"000010\", 'W');\n\t\t\tput(\"10010010\", 'X');\n\t\t\tput(\"10010011\", 'Y');\n\t\t\tput(\"10010000\", 'Z');\n\t\t}\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tif (line.isEmpty()) {\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tStringBuilder sb1, sb2;\n\t\t\tsb1 = new StringBuilder();\n\t\t\tsb2 = new StringBuilder();\n\t\t\t//\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tsb1.append(c1.get(c));\n\t\t\t}\n\t\t\t//\n\t\t\tString line2 = sb1.toString();\n\t\t\tfor (int i = 0; ; ) {\n\t\t\t\tchar c = 0;\n\t\t\t\tfor (int j = 3; j < 9 && i + j < line2.length(); j++) {\n\t\t\t\t\tif (c2.containsKey(line2.substring(i, i + j))) {\n\t\t\t\t\t\tc = c2.get(line2.substring(i, i + j));\n\t\t\t\t\t\tsb2.append(c);\n\t\t\t\t\t\ti += j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (c == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sb2.toString());\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static Map<Character, String> charToCode = new HashMap<>();\n    static Map<String, Character> codeToChar = new HashMap<>();\n    \n    static {\n        // First table (char to code)\n        charToCode.put('A', \"00000\");\n        charToCode.put('B', \"0001\");\n        charToCode.put('C', \"0010\");\n        charToCode.put('D', \"0011\");\n        charToCode.put('E', \"110\");\n        charToCode.put('F', \"1000\");\n        charToCode.put('G', \"1001\");\n        charToCode.put('H', \"1010\");\n        charToCode.put('I', \"1011\");\n        charToCode.put('J', \"0100\");\n        charToCode.put('K', \"0101\");\n        charToCode.put('L', \"0110\");\n        charToCode.put('M', \"0111\");\n        charToCode.put('N', \"10000\");\n        charToCode.put('O', \"10001\");\n        charToCode.put('P', \"111\");\n        charToCode.put('Q', \"10010\");\n        charToCode.put('R', \"10011\");\n        charToCode.put('S', \"10100\");\n        charToCode.put('T', \"10101\");\n        charToCode.put('U', \"10110\");\n        charToCode.put('V', \"10111\");\n        charToCode.put('W', \"11000\");\n        charToCode.put('X', \"11001\");\n        charToCode.put('Y', \"11010\");\n        charToCode.put('Z', \"11011\");\n        charToCode.put(' ', \"11100\");\n        charToCode.put('.', \"11101\");\n        charToCode.put(',', \"11110\");\n        charToCode.put('-', \"11111\");\n        charToCode.put('\\'', \"01010\");\n        charToCode.put('?', \"01011\");\n        \n        // Second table (code to char)\n        codeToChar.put(\"00\", 'A');\n        codeToChar.put(\"0100\", 'B');\n        codeToChar.put(\"0101\", 'C');\n        codeToChar.put(\"0110\", 'D');\n        codeToChar.put(\"110\", 'E');\n        codeToChar.put(\"01110\", 'F');\n        codeToChar.put(\"01111\", 'G');\n        codeToChar.put(\"1000\", 'H');\n        codeToChar.put(\"1001\", 'I');\n        codeToChar.put(\"10100\", 'J');\n        codeToChar.put(\"10101\", 'K');\n        codeToChar.put(\"10110\", 'L');\n        codeToChar.put(\"10111\", 'M');\n        codeToChar.put(\"1011\", 'N');\n        codeToChar.put(\"01010\", 'O');\n        codeToChar.put(\"111\", 'P');\n        codeToChar.put(\"01011\", 'Q');\n        codeToChar.put(\"1100\", 'R');\n        codeToChar.put(\"1101\", 'S');\n        codeToChar.put(\"00111\", 'T');\n        codeToChar.put(\"1110\", 'U');\n        codeToChar.put(\"11110\", 'V');\n        codeToChar.put(\"11111\", 'W');\n        codeToChar.put(\"10010\", 'X');\n        codeToChar.put(\"10011\", 'Y');\n        codeToChar.put(\"01000\", 'Z');\n        codeToChar.put(\"01001\", ' ');\n        codeToChar.put(\"10000\", '.');\n        codeToChar.put(\"10001\", ',');\n        codeToChar.put(\"0010\", '-');\n        codeToChar.put(\"0011\", '\\'');\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            \n            // Step 1: Convert each character to code\n            StringBuilder binary = new StringBuilder();\n            for (char c : line.toCharArray()) {\n                if (charToCode.containsKey(c)) {\n                    binary.append(charToCode.get(c));\n                }\n            }\n            \n            // Step 2: Decode using second table\n            StringBuilder result = new StringBuilder();\n            int i = 0;\n            while (i < binary.length()) {\n                boolean found = false;\n                for (int len = 1; len <= 5 && i + len <= binary.length(); len++) {\n                    String sub = binary.substring(i, i + len);\n                    if (codeToChar.containsKey(sub)) {\n                        result.append(codeToChar.get(sub));\n                        i += len;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    i++;\n                }\n            }\n            \n            System.out.println(result.toString());\n        }\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static Map<Character, String> charToCode = new HashMap<>(); static Map<String, Character> codeToChar = new HashMap<>(); static { // First table (char to code) charToCode.put('A',  \"1000\");  charToCode.put('L', \"0110\"); charToCode.put('M', \"0111\"); charToCode.put('N', \"10000\"); charToCode.put('O', \"10001\"); charToCode.put('P', \"111\"); charToCode.put('Q', \"10010\"); charToCode.put('R', \"10011\"); charToCode.put('S', \"10100\"); charToCode.put('T', \"10101\");  charToCode.put('Z', \"11011\"); charToCode.put(' ', \"11100\"); charToCode.put('.', \"11101\"); charToCode.put(',', \"11110\"); charToCode.put('-', \"11111\"); charToCode.put('\\'', \"01010\"); charToCode.put('?', \"01011\"); // Second table (code to char) codeToChar.put(\"00\", 'A'); codeToChar.put(\"0100\", 'B'); codeToChar.put(\"0101\", 'C'); codeToChar.put(\"0110\", 'D'); codeToChar.put(\"110\", 'E'); codeToChar.put(\"01110\", 'F'); codeToChar.put(\"01111\", 'G'); codeToChar.put(\"1000\", 'H'); codeToChar.put(\"1001\", 'I'); codeToChar.put(\"10100\", 'J'); codeToChar.put(\"10101\", 'K');  codeToChar.put(\"01011\", 'Q'); codeToChar.put(\"1100\", 'R'); codeToChar.put(\"1101\", 'S'); codeToChar.put(\"00111\", 'T'); codeToChar.put(\"1110\", 'U'); codeToChar.put(\"11110\", 'V'); codeToChar.put(\"11111\", 'W'); codeToChar.put(\"10010\", 'X'); codeToChar.put(\"10011\", 'Y'); codeToChar.put(\"01000\", 'Z'); codeToChar.put(\"01001\", ' '); codeToChar.put(\"10000\", '.'); codeToChar.put(\"10001\", ','); codeToChar.put(\"0010\", '-'); codeToChar.put(\"0011\", '\\''); } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String line  (char c : line.toCharArray()) { if (charToCode.containsKey(c)) { binary.append(charToCode.get(c)); } } // Step 2: Decode using second table StringBuilder result  binary.length()) { boolean found = false; for (int len = 1; len <= 5 && i + len <= binary.length(); len++) { String sub = binary.substring(i, i + len); if (codeToChar.containsKey(sub)) { result.append(codeToChar.get(sub)); i += len; found = true;  } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import  final HashMap<Character, String> c1 = new HashMap<Character, String>(32) { { put('A', \"00000\"); put('B', \"00001\"); put('C', \"00010\"); put('D', \"00011\"); put('E', \"00100\"); put('F', \"00101\"); put('G', \"00110\"); put('H', \"00111\"); put('I',  \"01101\"); put('O', \"01110\"); put('P',  \"10100\"); put('V', \"10101\"); put('W', \"10110\"); put('X', \"10111\"); put('Y', \"11000\"); put('Z', \"11001\"); put(' ', \"11010\"); put('.', \"11011\"); put(',', \"11100\"); put('-', \"11101\");  c2 = new HashMap<String, Character>(32) { { put(\"101\", ' '); put(\"000000\", '\\''); put(\"000011\", ','); put(\"10010001\", '-'); put(\"010001\", '.'); put(\"000001\", '?'); put(\"100101\", 'A'); put(\"10011010\", 'B'); put(\"0101\", 'C'); put(\"0001\", 'D');  put(\"10011000\", 'J'); put(\"0110\", 'K'); put(\"00100\", 'L'); put(\"10011001\", 'M'); put(\"10011110\", 'N'); put(\"00101\", 'O'); put(\"111\", 'P'); put(\"10011111\", 'Q'); put(\"1000\", 'R'); put(\"00110\", 'S'); put(\"00111\", 'T'); put(\"10011100\", 'U'); put(\"10011101\", 'V'); put(\"000010\", 'W'); put(\"10010010\", 'X'); put(\"10010011\", 'Y'); put(\"10010000\", 'Z'); } }; public static void main(String[] args) throws IOException  \"\"; while ((line = br.readLine())  sb1, sb2; sb1 = new StringBuilder(); sb2 = new StringBuilder(); // for (char c : line.toCharArray()) { sb1.append(c1.get(c)); } // String line2 = sb1.toString(); for (int i = 0; ; ) { char c = 0; for (int j = 3; j <  (c2.containsKey(line2.substring(i, i + j))) { c = c2.get(line2.substring(i, i + j)); sb2.append(c); i += j; break; } } if (c == 0) { break; } } System.out.println(sb2.toString()); } } }"], "original_ll": -0.4868784248828888, "sampled_ll": -0.37182682752609253, "all_perturbed_sampled_ll": [-0.7338733673095703], "all_perturbed_original_ll": [-0.9054208397865295], "perturbed_sampled_ll": -0.7338733673095703, "perturbed_original_ll": -0.9054208397865295, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "to_bin = dict(zip([chr(i) for i in range(ord(\"A\"), ord(\"Z\") + 1)] + [\" \", \".\", \",\", \"-\", \"'\", \"?\"],\n                  [bin(i)[2:7].zfill(5) for i in range(2 ** 5)]))\nto_chr = {\"101\":\" \", \"000000\":\"'\", \"000011\":\",\", \"10010001\":\"-\", \"010001\":\".\", \"000001\":\"?\", \"100101\":\"A\", \"10011010\":\"B\",\n          \"0101\":\"C\", \"0001\":\"D\", \"110\":\"E\", \"01001\":\"F\", \"10011011\":\"G\", \"010000\":\"H\", \"0111\":\"I\", \"10011000\":\"J\",\n          \"0110\":\"K\", \"00100\":\"L\", \"10011001\":\"M\", \"10011110\":\"N\", \"00101\":\"O\", \"111\":\"P\", \"10011111\":\"Q\", \"1000\":\"R\",\n          \"00110\":\"S\", \"00111\":\"T\", \"10011100\":\"U\", \"10011101\":\"V\", \"000010\":\"W\", \"10010010\":\"X\", \"10010011\":\"Y\", \"10010000\":\"Z\"}\n\nwhile True:\n  try:\n    s = input()\n  except EOFError:\n    break\n  bs = \"\".join([to_bin[c] for c in s])\n  ans = \"\"\n  while True:\n    length = 9\n    for i in range(length):\n      if bs[:i] in to_chr:\n        ans = ans + to_chr[bs[:i]]\n        bs = bs[i:]\n        break\n    else:\n      break\n  print(ans)\n", "sampled": "import sys\n\n# First conversion table (character to code)\nchar_to_code = {\n    'A': '00000', 'B': '10000', 'C': '01000', 'D': '00100', 'E': '00010',\n    'F': '10100', 'G': '01100', 'H': '00110', 'I': '10010', 'J': '01010',\n    'K': '00001', 'L': '10001', 'M': '01001', 'N': '00101', 'O': '10101',\n    'P': '01101', 'Q': '00011', 'R': '10011', 'S': '01011', 'T': '11000',\n    'U': '10110', 'V': '01110', 'W': '00111', 'X': '10111', 'Y': '01111',\n    'Z': '11001', \"'\": '11010', ',': '11011', '-': '11100', '.': '11101',\n    '?': '11110', ' ': '11111'\n}\n\n# Second conversion table (code to character)\ncode_to_char = {\n    '00': 'A', '0100': 'B', '0000': 'C', '100': 'D', '110': 'E',\n    '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J',\n    '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O',\n    '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T',\n    '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '0001': 'Y',\n    '10100': 'Z', '10101': \"'\", '10110': ',', '10111': '-', '11000': '.',\n    '11001': '?', '0000': ' '\n}\n\n# Fix the duplicate keys issue - need to check which mapping is correct\ncode_to_char = {\n    '00': 'A', '0100': 'B', '0000': 'C', '100': 'D', '110': 'E',\n    '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J',\n    '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O',\n    '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T',\n    '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '10100': 'Z',\n    '10101': \"'\", '10110': ',', '10111': '-', '11000': '.', '11001': '?'\n}\n\ndef decode(binary_str):\n    result = []\n    i = 0\n    while i < len(binary_str):\n        found = False\n        # Try lengths from 2 to 5\n        for length in range(2, 6):\n            if i + length <= len(binary_str):\n                substr = binary_str[i:i+length]\n                if substr in code_to_char:\n                    result.append(code_to_char[substr])\n                    i += length\n                    found = True\n                    break\n        if not found:\n            i += 1\n    return ''.join(result)\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    \n    # Step 1: Convert characters to binary using first table\n    binary = ''\n    for char in line:\n        if char in char_to_code:\n            binary += char_to_code[char]\n    \n    # Step 2: Convert binary to characters using second table\n    result = decode(binary)\n    print(result)\n", "perturbed_sampled": ["import sys # First conversion table (character to code) char_to_code = { 'A': '00000', 'B': '10000', 'C': '01000', 'D': '00100', 'E': '00010', 'F': '10100', 'G': '01100', 'H': '00110', 'I': '10010', 'J': '01010', 'K': '00001', 'L': '10001', 'M': '01001', 'N': '00101', 'O': '10101', 'P': '01101', 'Q': '00011', 'R': '10011', 'S': '01011', 'T': '11000', 'U': '10110', 'V': '01110', 'W': '00111', 'X': '10111', 'Y': '01111', 'Z': '11001', \"'\":  ': '11111' } # Second conversion table (code to character) code_to_char = { '00': 'A', '0100': 'B', '0000': 'C', '100': 'D',  '0010': 'J', '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O', '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T', '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '0001':  '.', '11001': '?', '0000': ' ' } # Fix the   'H', '10': 'I', '0010': 'J', '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O', '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T', '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '10100': 'Z', '10101': \"'\", '10110': ',',  = [] i  Try lengths from 2 to 5  len(binary_str): substr = binary_str[i:i+length] if substr in code_to_char: result.append(code_to_char[substr]) i += length found = True break if not found: i += 1 return ''.join(result) for line in sys.stdin: line = line.strip() if not line: continue  binary = '' for char in line: if char in char_to_code: binary += char_to_code[char] # Step 2: Convert binary to characters using second table result = decode(binary) print(result)"], "perturbed_original": ["to_bin =  \", \".\", \",\", \"-\", \"'\", \"?\"], [bin(i)[2:7].zfill(5) for i in range(2 ** 5)])) to_chr = {\"101\":\" \", \"000000\":\"'\", \"000011\":\",\", \"10010001\":\"-\", \"010001\":\".\", \"000001\":\"?\",  \"0110\":\"K\", \"00100\":\"L\", \"10011001\":\"M\", \"10011110\":\"N\", \"00101\":\"O\", \"111\":\"P\", \"10011111\":\"Q\", \"1000\":\"R\", \"00110\":\"S\", \"00111\":\"T\", \"10011100\":\"U\", \"10011101\":\"V\", \"000010\":\"W\", \"10010010\":\"X\", \"10010011\":\"Y\", \"10010000\":\"Z\"} while True: try: s = input() except EOFError: break bs =  length = 9 for i in range(length): if bs[:i] in to_chr: ans = ans + to_chr[bs[:i]] bs = bs[i:] break else: break print(ans)"], "original_ll": -1.0182512998580933, "sampled_ll": -0.4748696982860565, "all_perturbed_sampled_ll": [-0.8589668273925781], "all_perturbed_original_ll": [-1.4481936693191528], "perturbed_sampled_ll": -0.8589668273925781, "perturbed_original_ll": -1.4481936693191528, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  long long int time[10001] = {}, wtime[10001] = {}, min, sum;\n  int j, k, n;\n  while(scanf(\"%d\", &n) && n){\n    for(j = 0;j < n;j++)\n      scanf(\"%lld\", &time[j]);\n\n    for(j = 0;j < n - 1;j++){\n      min = j;\n      for(k = j + 1;k < n;k++)\n\tmin = time[min] < time[k] ? min : k;\n      if(min != j){\n\ttime[min] += time[j];\n\ttime[j] = time[min] - time[j];\n\ttime[min] -= time[j];\n      }\n    }\n    sum = 0;\n    for(j = 1;j < n;j++){\n      wtime[j] = wtime[j - 1] + time[j - 1];\n      sum += wtime[j];\n    }\n    \n    printf(\"%lld\\n\", sum);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int times[10000];\n        \n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", &times[i]);\n        }\n        \n        qsort(times, n, sizeof(int), compare);\n        \n        long long total_wait = 0;\n        long long cumulative = 0;\n        \n        for(int i = 0; i < n; i++) {\n            total_wait += cumulative;\n            cumulative += times[i];\n        }\n        \n        printf(\"%lld\\n\", total_wait);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int compare(const void *a, const void *b) { return (*(int*)a - *(int*)b); } int main() { int n; while(scanf(\"%d\", &n) == 1 && n != 0) { int times[10000]; for(int i = 0;  sizeof(int), compare); long long total_wait = 0; long long  i++) { total_wait += cumulative; cumulative += times[i]; } printf(\"%lld\\n\", total_wait); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ long <extra_id_5>(j)<extra_id_6>=<extra_id_7>= time[n]; time[n] := time[n];<extra_id_8>j=0; j<<extra_id_9>-- j){<extra_id_10>= 0; j++;<extra_id_11>= time[j]; j = time[1]<extra_id_12>j; j++)(time[k]<extra_id_13>= 0; if(k int j, k, n; while(scanf(\"%d\", &n) && n){ for(j = 0;j < n;j++) scanf(\"%lld\", &time[j]); for(j = 0;j < n - 1;j++){ min = j; for(k = j + 1;k <  if(min != j){ time[min] += time[j]; time[j] = time[min] - time[j]; time[min] -= time[j]; } } sum = 0; for(j = 1;j < n;j++){ wtime[j] = wtime[j - 1] + time[j - 1]; sum += wtime[j]; } printf(\"%lld\\n\", sum); } return 0; }"], "original_ll": -0.8927487134933472, "sampled_ll": -0.6408005356788635, "all_perturbed_sampled_ll": [-1.5629459619522095], "all_perturbed_original_ll": [-1.9731740951538086], "perturbed_sampled_ll": -1.5629459619522095, "perturbed_original_ll": -1.9731740951538086, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.*;\npublic class Main {\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint [] data = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = sc.nextInt();\n\t\t\t\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tint [] data2 = new int[n];\n\t\t\tint sum = 0;\n\t\t\tdata2[0] = 0;\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tdata2[i] = data2[i-1] + data[i-1];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tsum += data2[i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] times = new int[n];\n            for (int i = 0; i < n; i++) {\n                times[i] = sc.nextInt();\n            }\n            \n            Arrays.sort(times);\n            \n            int totalWaitTime = 0;\n            int currentTime = 0;\n            \n            for (int i = 0; i < n; i++) {\n                totalWaitTime += currentTime;\n                currentTime += times[i];\n            }\n            \n            System.out.println(totalWaitTime);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n  i = 0; i < n; i++) { times[i] = sc.nextInt(); } Arrays.sort(times); int totalWaitTime = 0; int currentTime = 0; for (int i = 0; i  } System.out.println(totalWaitTime); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { private void  new int[n]; for(int i = 0; i < n; i++){ data[i] = sc.nextInt(); } Arrays.sort(data); int [] data2 = new int[n]; int sum = 0; data2[0] = 0; for(int i = 1; i < n; i++){ data2[i] = data2[i-1] + data[i-1]; } for(int i = 0; i < n; i++){ sum += data2[i]; } System.out.println(sum); } } public static void main(String[] args) { Main obj = new Main(); obj.doit(); } }"], "original_ll": -0.6788057088851929, "sampled_ll": -0.4193897247314453, "all_perturbed_sampled_ll": [-1.2210054397583008], "all_perturbed_original_ll": [-1.064328908920288], "perturbed_sampled_ll": -1.2210054397583008, "perturbed_original_ll": -1.064328908920288, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = int(input())\nt = []\ns = 0\nsum = 0\n\nif n == 0:\n    print(n)\n\nelse:\n    for i in range(n):\n        s = int(input())\n        if s == 0:\n            break\n        else:\n            t.append(i)\n            t[i] = s\n            t.sort()\n\n    for m in range(n):\n        sum = sum + t[m]*(n-m-1)\n\n    print(sum)\n\n", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    times = []\n    for _ in range(n):\n        times.append(int(input()))\n    \n    times.sort()\n    \n    total_wait = 0\n    cumulative_time = 0\n    \n    for t in times:\n        total_wait += cumulative_time\n        cumulative_time += t\n    \n    print(total_wait)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break times = [] for _ in range(n): times.append(int(input())) times.sort() total_wait = 0 cumulative_time = 0  print(total_wait)"], "perturbed_original": ["n = int(input()) t = [] s = 0 sum = 0 if n == 0: print(n)  == 0: break else: t.append(i) t[i] = s t.sort() for m in range(n): sum = sum + t[m]*(n-m-1) print(sum)"], "original_ll": -1.2036937475204468, "sampled_ll": -0.9045174717903137, "all_perturbed_sampled_ll": [-2.052995204925537], "all_perturbed_original_ll": [-2.080486536026001], "perturbed_sampled_ll": -2.052995204925537, "perturbed_original_ll": -2.080486536026001, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "char S[99];\nint G(x,y){return y?G(y,x%y):x;}\nmain(g,X,Y,x,y,z,t,T,f){for(;~scanf(\"%d%d\",&x,&y);){\nfor(g=0,X=x,Y=y;g<90;g++)S[g]=X*10/Y+'0',X=X*10%y;\nsprintf(S,\"%.97f\",x/(double)y);\ng=G(x,y);x/=g;y/=g;\nfor(z=0;y%2==0;y/=2)z++;\nfor(f=0;y%5==0;y/=5)f++;\nif(y==1)t=0;else{x=1;t=0;do{x=x*10%y;t++;}while(x!=1);}\nif(z>f)f=z;\nS[f+t+2]=0;puts(S+2);\nif(t){\n\tfor(;f>0;f--)putchar(' ');\n\tfor(;t>0;t--)putchar('^');\n\tputs(\"\");\n}\n}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int p, q;\n    \n    while (scanf(\"%d %d\", &p, &q) == 2) {\n        char digits[85];\n        int remainders[1000005];\n        int positions[1000005];\n        \n        memset(remainders, -1, sizeof(remainders));\n        memset(positions, -1, sizeof(positions));\n        \n        int remainder = p % q;\n        int pos = 0;\n        int cycle_start = -1;\n        \n        while (remainder != 0) {\n            if (remainders[remainder] != -1) {\n                cycle_start = remainders[remainder];\n                break;\n            }\n            \n            remainders[remainder] = pos;\n            positions[pos] = remainder;\n            \n            remainder *= 10;\n            digits[pos] = (remainder / q) + '0';\n            remainder = remainder % q;\n            pos++;\n        }\n        \n        digits[pos] = '\\0';\n        \n        if (cycle_start == -1) {\n            // Non-repeating\n            printf(\"%s\\n\", digits);\n        } else {\n            // Repeating\n            printf(\"%s\\n\", digits);\n            for (int i = 0; i < cycle_start; i++) {\n                printf(\" \");\n            }\n            for (int i = cycle_start; i < pos; i++) {\n                printf(\"^\");\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main()  2) { char digits[85]; int remainders[1000005]; int positions[1000005]; memset(remainders, -1, sizeof(remainders)); memset(positions, -1, sizeof(positions)); int remainder = p % q; int pos = 0; int cycle_start = -1; while (remainder != 0) { if (remainders[remainder] != -1) { cycle_start = remainders[remainder]; break; } remainders[remainder] = pos; positions[pos] = remainder; remainder *= 10; digits[pos] = (remainder / q) + '0'; remainder = remainder % q; pos++; } digits[pos] = '\\0'; if (cycle_start == -1)  printf(\"%s\\n\", digits); for (int i = 0;  i = cycle_start; i < pos; i++) { printf(\"^\"); } printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["char S[99]; int G(x,y){return y?G(y,x%y):x;} main(g,X,Y,x,y,z,t,T,f){for(;~scanf(\"%d%d\",&x,&y);){ for(g=0,X=x,Y=y;g<90;g++)S[g]=X*10/Y+'0',X=X*10%y; sprintf(S,\"%.97f\",x/(double)y); g=G(x,y);x/=g;y/=g; for(z=0;y%2==0;y/=2)z++; for(f=0;y%5==0;y/=5)f++; if(y==1)t=0;else{x=1;t=0;do{x=x*10%y;t++;}while(x!=1);} if(z>f)f=z; S[f+t+2]=0;puts(S+2); if(t){ for(;f>0;f--)putchar(' '); for(;t>0;t--)putchar('^'); puts(\"\"); } }exit(0);}"], "original_ll": -2.3000357151031494, "sampled_ll": -0.7412351965904236, "all_perturbed_sampled_ll": [-1.237021565437317], "all_perturbed_original_ll": [-2.309054136276245], "perturbed_sampled_ll": -1.237021565437317, "perturbed_original_ll": -2.309054136276245, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int p = sc.nextInt();\n\t\t\tfinal int q = sc.nextInt();\n\t\t\t\n\t\t\tif(p == 0 && q == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] mods = new int[q];\n\t\t\tArrays.fill(mods, -1);\n\t\t\t\n\t\t\tint cur = p * 10;\n\t\t\tint rep_start = -1;\n\t\t\tint rep_end = 0;\n\t\t\twhile(true){\n\t\t\t\tfinal int m = cur % q;\n\t\t\t\tSystem.out.print(cur / q);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(m == 0){\n\t\t\t\t\trep_start = rep_end;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(mods[m] >= 0){\n\t\t\t\t\trep_start = mods[m];\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tmods[m] = rep_end;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep_end++;\n\t\t\t\tcur = m * 10;\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tif(rep_start != rep_end){\n\t\t\t\tfor(int i = 0; i <= rep_end;i++){\n\t\t\t\t\tif(i <= rep_start){\n\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.print(\"^\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int p = sc.nextInt();\n            int q = sc.nextInt();\n            \n            StringBuilder decimal = new StringBuilder();\n            Map<Integer, Integer> remainderPos = new HashMap<>();\n            \n            int remainder = p % q;\n            int position = 0;\n            \n            while (remainder != 0 && !remainderPos.containsKey(remainder)) {\n                remainderPos.put(remainder, position);\n                remainder *= 10;\n                int digit = remainder / q;\n                decimal.append(digit);\n                remainder = remainder % q;\n                position++;\n            }\n            \n            if (remainder == 0) {\n                // Terminates\n                System.out.println(decimal.toString());\n            } else {\n                // Repeating\n                int cycleStart = remainderPos.get(remainder);\n                System.out.println(decimal.toString());\n                \n                StringBuilder marker = new StringBuilder();\n                for (int i = 0; i < cycleStart; i++) {\n                    marker.append(' ');\n                }\n                for (int i = cycleStart; i < decimal.length(); i++) {\n                    marker.append('^');\n                }\n                System.out.println(marker.toString());\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int p = sc.nextInt(); int q = sc.nextInt(); StringBuilder decimal = new StringBuilder(); Map<Integer, Integer> remainderPos = new HashMap<>(); int remainder ==<extra_id_13>{ long digit = digit<extra_id_14>int i = != 0 && !remainderPos.containsKey(remainder)) { remainderPos.put(remainder, position); remainder *= 10; int digit = remainder / q; decimal.append(digit); remainder = remainder % q; position++; } if (remainder == 0)  cycleStart = remainderPos.get(remainder); System.out.println(decimal.toString()); StringBuilder marker = new StringBuilder(); for (int i = 0; i < cycleStart; i++) { marker.append(' ');  { marker.append('^'); } System.out.println(marker.toString()); } } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){ final int p = sc.nextInt(); final int q = sc.nextInt(); if(p == 0 && q == 0){ break; } int[] mods = new int[q]; Arrays.fill(mods, -1); int cur = p * 10; int rep_start = -1;  % q; System.out.print(cur / q); if(m == 0){ rep_start = rep_end; break;  = rep_end; } rep_end++;  for(int i = 0; i <= rep_end;i++){ if(i <= rep_start){ System.out.print(\" \"); }else{ System.out.print(\"^\"); } } System.out.println(); } } } }"], "original_ll": -0.9555273652076721, "sampled_ll": -0.7955405712127686, "all_perturbed_sampled_ll": [-1.9275645017623901], "all_perturbed_original_ll": [-1.6274234056472778], "perturbed_sampled_ll": -1.9275645017623901, "perturbed_original_ll": -1.6274234056472778, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from decimal import *\nimport re\ndef solve2(m, n):\n    maxlen = 85\n    #PREC=200\n    PREC=300\n    getcontext().prec = PREC\n    x = Decimal(m) / Decimal(n)\n    s = x.to_eng_string()\n    if len(s) < PREC:\n        return(s[2:],'')\n    rep = 1\n    while True:\n        r = r'(.{%d})\\1{%d,}' % (rep, int(PREC/rep)-1)\n                                         #ex. '(.{6})\\\\1{12,}'\n        a=re.search(r, s)\n        if a:\n            break\n        rep += 1\n        if rep > maxlen:\n            raise ValueError('This cannot happen.')\n\n    u = s[2:a.start()+len(a.group(1))]\n    v = (' '*PREC + '^'*len(a.group(1)))[-len(u):]\n    return(u,v)\n\nwhile True:\n    try:\n        m,n = map(int, input().strip().split())\n        s,t = solve2(m, n)\n        print(s)\n        if t!='':\n            print(t)\n    except EOFError:\n        break", "sampled": "import sys\n\ndef solve(p, q):\n    # Calculate decimal representation of p/q\n    decimal_digits = []\n    remainders = {}\n    remainder = p % q\n    position = 0\n    \n    while remainder != 0 and remainder not in remainders:\n        remainders[remainder] = position\n        remainder *= 10\n        digit = remainder // q\n        decimal_digits.append(str(digit))\n        remainder = remainder % q\n        position += 1\n    \n    if remainder == 0:\n        # Terminating decimal\n        print(''.join(decimal_digits))\n    else:\n        # Repeating decimal\n        cycle_start = remainders[remainder]\n        print(''.join(decimal_digits))\n        \n        # Second line with spaces and carets\n        line2 = []\n        for i in range(len(decimal_digits)):\n            if i < cycle_start:\n                line2.append(' ')\n            else:\n                line2.append('^')\n        print(''.join(line2))\n\nfor line in sys.stdin:\n    p, q = map(int, line.strip().split())\n    solve(p, q)\n", "perturbed_sampled": ["import sys def solve(p, q): # Calculate decimal representation of p/q decimal_digits = [] remainders = {}  != 0 and remainder not in remainders: remainders[remainder] = position remainder *= 10 digit = remainder // q decimal_digits.append(str(digit)) remainder = remainder % q position  else: # Repeating decimal cycle_start = remainders[remainder] print(''.join(decimal_digits)) # Second line with spaces and carets line2 = [] for i in range(len(decimal_digits)): if i < cycle_start: line2.append('  = map(int, line.strip().split()) solve(p, q)"], "perturbed_original": ["from decimal import * import re  PREC x = Decimal(m) / Decimal(n) s = x.to_eng_string() if len(s) < PREC: return(s[2:],'') rep = 1 while True: r = r'(.{%d})\\1{%d,}' % (rep, int(PREC/rep)-1) #ex. '(.{6})\\\\1{12,}' a=re.search(r, s) if a: break rep += 1 if rep > maxlen: raise ValueError('This cannot happen.') u = s[2:a.start()+len(a.group(1))] v = ('  input().strip().split()) s,t = solve2(m, n) print(s) if t!='': print(t) except EOFError: break"], "original_ll": -1.9899669885635376, "sampled_ll": -1.096883773803711, "all_perturbed_sampled_ll": [-2.6674365997314453], "all_perturbed_original_ll": [-3.0988540649414062], "perturbed_sampled_ll": -2.6674365997314453, "perturbed_original_ll": -3.0988540649414062, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "int G(x,y){return y?G(y,x%y):x;}\nint L(x,y){return x>y?(x/G(x,y)*y):(y/G(y,x)*x);}\nn[3],a[3],m[3];main(i,x){\n\tfor(;scanf(\"%d%d%d%d%d%d\",a,m,a+1,m+1,a+2,m+2),*m;){\n\t\tfor(i=3;i--;)for(x=n[i]=1;(x=a[i]*x%m[i])>1;n[i]++);\n\t\tprintf(\"%d\\n\",L(n[0],L(n[1],n[2])));\n\t}\n}", "sampled": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long lcm(long long a, long long b) {\n    return a / gcd(a, b) * b;\n}\n\nlong long find_period(long long a, long long m) {\n    long long x = 1;\n    long long period = 0;\n    \n    do {\n        x = (x * a) % m;\n        period++;\n    } while (x != 1);\n    \n    return period;\n}\n\nint main() {\n    long long a1, m1, a2, m2, a3, m3;\n    \n    while (1) {\n        scanf(\"%lld %lld %lld %lld %lld %lld\", &a1, &m1, &a2, &m2, &a3, &m3);\n        \n        if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) {\n            break;\n        }\n        \n        long long period1 = find_period(a1, m1);\n        long long period2 = find_period(a2, m2);\n        long long period3 = find_period(a3, m3);\n        \n        long long result = lcm(period1, lcm(period2, period3));\n        \n        printf(\"%lld\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> long long gcd(long long a, long long b) {  b  } long long lcm(long long a, long long b) { return a / gcd(a, b) * b; } long long find_period(long long a, long long m) { long long x = 1; long long period = 0; do { x = (x * a) % m; period++; } while (x != 1); return period; } int main() { long long a1, m1, a2, m2, a3, m3; while (1) { scanf(\"%lld %lld %lld %lld %lld %lld\", &a1, &m1, &a2,  0 && a2 == 0 && m2  long long period2 = find_period(a2, m2); long long period3 = find_period(a3, m3); long long result = lcm(period1, lcm(period2, period3)); printf(\"%lld\\n\", result); } return 0; }"], "perturbed_original": ["int G(x,y){return y?G(y,x%y):x;} int L(x,y){return x>y?(x/G(x,y)*y):(y/G(y,x)*x);} n[3],a[3],m[3];main(i,x){ for(;scanf(\"%d%d%d%d%d%d\",a,m,a+1,m+1,a+2,m+2),*m;){ for(i=3;i--;)for(x=n[i]=1;(x=a[i]*x%m[i])>1;n[i]++); printf(\"%d\\n\",L(n[0],L(n[1],n[2]))); } }"], "original_ll": -2.0244574546813965, "sampled_ll": -0.3609764277935028, "all_perturbed_sampled_ll": [-0.9324979186058044], "all_perturbed_original_ll": [-2.075312852859497], "perturbed_sampled_ll": -0.9324979186058044, "perturbed_original_ll": -2.075312852859497, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.*;\nimport java.util.*;\n\n\n// \u0082\u00e6\u0082\u00ad\u008a\u00d4\u0088\u00e1\u0082\u00a4\u0082\u00c6\u0082\u00b1\u0082\u00eb\u0081B\n// \u0096\u00e2\u0091\u00e8\u0095\u00b6\u0082\u00c9\u008f\u0091\u0082\u00a2\u0082\u00c4\u0082\u00c8\u0082\u00ad\u0082\u00c4\u0082\u00e0\u0096\u00e2\u0091\u00e8\u0083Z\u0083b\u0083g\u0082\u00cd\u0095\u00a1\u0090\u0094\u0082\u00c5\u0090\u00e6\u0093\u00aa\u0082\u00aa0\u0082\u00c5\u008fI\u0097\u00b9\u0082\u00c5\u0082\u00a0\u0082\u00e9\u0081B\n// \u0096\u00e2\u0091\u00e8\u0083Z\u0083b\u0083g\u0082\u00cc\u008cJ\u0082\u00e8\u0095\u00d4\u0082\u00b5\u008e\u009e\u0082\u00c9\u008f\u0089\u008a\u00fa\u0089\u00bb\u0098R\u0082\u00ea\n\n// 2011/10/18\n\n//\u0081@0114 \u0094\u0088\npublic class Main {\n\n\t\n\tlong gcm(long a, long b) {\n\t\t\n\t\twhile(b != 0) {\n\t\t\tlong t = a % b;\n\t\t\ta = b;\n\t\t\tb = t;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcm(a, b);\n\t}\n\t\n\t// \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2\n\tboolean main() throws IOException {\n\n\t\tint[] ri = readIntArray();\n\t\tint a1 = ri[0];\n\t\tint m1 = ri[1];\n\t\tint a2 = ri[2];\n\t\tint m2 = ri[3];\n\t\tint a3 = ri[4];\n\t\tint m3 = ri[5];\n\t\tif (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) \n\t\t\treturn false; // \u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2\n\n\t\tint i;\n\t\tint x = 1;\n\t\tfor(i = 1;; i++) {\n\t\t\tx = (a1 * x) % m1;\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tlong v1 = i;\n\t\tx = 1;\n\t\tfor(i = 1;; i++) {\n\t\t\tx = (a2 * x) % m2;\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tlong v2 = i;\n\t\tx = 1;\n\t\tfor(i = 1;; i++) {\n\t\t\tx = (a3 * x) % m3;\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tlong v3 = i;\n\t\tlong r = lcm(lcm(v1, v2), v3);\n\t\t\n\t\t\n\t\t// \u0089\u00f0\u0082\u00cc\u0095\\\u008e\u00a6\n\t\tSystem.out.printf(\"%d\\n\", r);\n\t\t\n\t\treturn true; // \u0090\u00b3\u008f\u00ed\u008fI\u0097\u00b9 \u008e\u009f\u0082\u00d6\n\t}\n\t\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\t\t\t\n\t\t\tString inputStr = \"1 459550\\n\";\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr)); \n\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // \u008f\u0091\u0082\u00ab\u008e\u00cc\u0082\u00c4\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // \u0083R\u0083\u0093\u0083\\\u0081[\u0083\u008b\u0082\u00a9\u0082\u00e7\n\t\t}\n\t\t\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; /*i < N*/; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t}\n\n\t\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\t\n\n\t// \u0095W\u008f\u0080\u0093\u00fc\u0097\u00cd\u0082\u00e6\u0082\u00e81\u008ds\u0095\u00aa\u0082\u00cc\u0083X\u0083y\u0081[\u0083X\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0082\u00cc\u0090\u00ae\u0090\u0094\u0092l\u0082\u00f0\u0093\u00c7\u0082\u00de\n\t// EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7\n\tprivate static int[] readIntArray() throws IOException {\n\t\t\n\t\tString s = reader.readLine();\n\t\tif (s == null)\n\t\t\treturn null;\n\t\tString[] sp = s.split(\" \");\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\t\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long a1 = sc.nextLong();\n            long m1 = sc.nextLong();\n            long a2 = sc.nextLong();\n            long m2 = sc.nextLong();\n            long a3 = sc.nextLong();\n            long m3 = sc.nextLong();\n            \n            if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) {\n                break;\n            }\n            \n            long period1 = findPeriod(a1, m1);\n            long period2 = findPeriod(a2, m2);\n            long period3 = findPeriod(a3, m3);\n            \n            long result = lcm(lcm(period1, period2), period3);\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n    \n    private static long findPeriod(long a, long m) {\n        long x = 1;\n        long period = 0;\n        \n        do {\n            x = (a * x) % m;\n            period++;\n        } while (x != 1);\n        \n        return period;\n    }\n    \n    private static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n    \n    private static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args)  a1 = sc.nextLong(); long m1 = sc.nextLong(); long a2 = sc.nextLong(); long m2 =  (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3  long period2 = findPeriod(a2, m2); long period3 = findPeriod(a3, m3); long result = lcm(lcm(period1, period2), period3); System.out.println(result); } sc.close(); } private static long findPeriod(long a, long m) { long x = 1; long period = 0; do { x = (a * x) % m; period++; } while (x != 1); return  while (b != 0) { long  temp; } return a; } private static long lcm(long a, long b) { return a / gcd(a, b) * b; } }"], "perturbed_original": [" long gcm(long a, long b) { while(b != 0) { long t = a % b; a = b; b = t; } return a; } long lcm(long a, long b) { return a * b / gcm(a, b); } // \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2 boolean main() throws IOException { int[] ri = readIntArray(); int a1 = ri[0]; int m1 = ri[1]; int a2 = ri[2]; int m2 = ri[3]; int a3 = ri[4]; int m3 = ri[5]; if (a1 == 0 && m1  && a3 == 0 && m3 == 0) return false; // \u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2 int i; int x = 1; for(i = 1;; i++) { x = (a1 * x) % m1; if (x == 1) break; } long v1  x  break; } long v2 = i; x = 1; for(i = 1;; i++)  == 1) break; } long v3 = i; long r = lcm(lcm(v1, v2), v3); // \u0089\u00f0\u0082\u00cc\u0095\\\u008e\u00a6 System.out.printf(\"%d\\n\", r); return true; // \u0090\u00b3\u008f\u00ed\u008fI\u0097\u00b9 \u008e\u009f\u0082\u00d6 } // private final static boolean DEBUG = true; // debug private final  main(String[] args) throws IOException { if (DEBUG) { log = System.out; String  void write(int b) {} } ); // \u008f\u0091\u0082\u00ab\u008e\u00cc\u0082\u00c4 reader = new BufferedReader(new InputStreamReader(System.in)); // \u0083R\u0083\u0093\u0083\\\u0081[\u0083\u008b\u0082\u00a9\u0082\u00e7 } //int N = readIntArray()[0]; for(int i = 0; /*i < N*/; i++) { boolean b = new Main().main(); if (!b) break; } reader.close(); } static PrintStream log; static BufferedReader reader; // \u0095W\u008f\u0080\u0093\u00fc\u0097\u00cd\u0082\u00e6\u0082\u00e81\u008ds\u0095\u00aa\u0082\u00cc\u0083X\u0083y\u0081[\u0083X\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0082\u00cc\u0090\u00ae\u0090\u0094\u0092l\u0082\u00f0\u0093\u00c7\u0082\u00de // EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7 private static int[]  == null) return null; String[] sp = s.split(\" \"); int[] a = new int[sp.length]; for(int i = 0; i < sp.length; i++) { a[i] = Integer.parseInt(sp[i]); } return a; } }"], "original_ll": -1.6700654029846191, "sampled_ll": -0.3586435317993164, "all_perturbed_sampled_ll": [-1.3963735103607178], "all_perturbed_original_ll": [-2.0925168991088867], "perturbed_sampled_ll": -1.3963735103607178, "perturbed_original_ll": -2.0925168991088867, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# AOJ 0114: Electro-Fly\n# Python3 2018.6.18 bal4u\n\nfrom math import gcd\n\nwhile True:\n\ta1, m1, a2, m2, a3, m3 = list(map(int, input().split()))\n\tif a1 == 0: break\n\tn = 0\n\tb1, b2, b3 = 1, 1, 1\n\ta, b, c = 0, 0, 0\n\twhile True:\n\t\tif a == 0: b1 = (b1 * a1) % m1\n\t\tif b == 0: b2 = (b2 * a2) % m2\n\t\tif c == 0: b3 = (b3 * a3) % m3\n\t\tn += 1\n\t\tif a == 0 and b1 == 1: a = n\n\t\tif b == 0 and b2 == 1: b = n\n\t\tif c == 0 and b3 == 1: c = n\n\t\tif a != 0 and b != 0 and c != 0: break\n\t\n\tans = a // gcd(a,b) * b\n\tans = ans // gcd(ans, c) * c\n\tprint(ans)\n\n", "sampled": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef order_mod(a, m):\n    \"\"\"Find the multiplicative order of a modulo m\"\"\"\n    if gcd(a, m) != 1:\n        return -1\n    \n    order = 1\n    current = a % m\n    while current != 1:\n        current = (current * a) % m\n        order += 1\n    return order\n\nwhile True:\n    line = list(map(int, input().split()))\n    if line == [0, 0, 0, 0, 0, 0]:\n        break\n    \n    a1, m1, a2, m2, a3, m3 = line\n    \n    # Find the order of each coordinate\n    order1 = order_mod(a1, m1)\n    order2 = order_mod(a2, m2)\n    order3 = order_mod(a3, m3)\n    \n    # The minimum number of moves is the LCM of the three orders\n    result = lcm(lcm(order1, order2), order3)\n    print(result)\n", "perturbed_sampled": ["import math from functools import reduce def gcd(a, b): while b: a, b = b, a % b return a def lcm(a, b): return a * b // gcd(a, b) def order_mod(a, m): \"\"\"Find the multiplicative order of a modulo m\"\"\" if gcd(a, m) != 1: return -1 order = 1 current = a  a) % m order += 1 return  [0, 0, 0, 0, 0, 0]: break a1, m1, a2, m2, a3, m3 = line # Find the order of each coordinate order1 = order_mod(a1, m1) order2 = order_mod(a2, m2) order3 = order_mod(a3,  print(result)"], "perturbed_original": ["# AOJ 0114: Electro-Fly # Python3 2018.6.18 bal4u from math import gcd while True: a1, m1, a2, m2, a3, m3 = list(map(int, input().split())) if a1 == 0: break n = 0 b1, b2, b3 = 1, 1, 1 a, else 0<extra_id_4>2<extra_id_5>== n : n<extra_id_6>a or r > m:<extra_id_7>:<extra_id_8>) else<extra_id_9>#<extra_id_10>= gcd(m,<extra_id_11>b2 = (m<extra_id_12>s = (a/g, m<extra_id_13>b ) % m ans<extra_id_14>(ans, c) * c ans<extra_id_15>c a =<extra_id_16>a // gcd(m,<extra_id_17>)<extra_id_18>in m2<extra_id_19>a1-2: a == 0: b1 = (b1 * a1) % m1 if b ==  n += 1 if a == 0 and b1 == 1: a = n if b == 0 and b2 == 1: b = n if c == 0 and b3 == 1: c = n if a != 0  = a // gcd(a,b) * b ans = ans // gcd(ans, c) * c print(ans)"], "original_ll": -1.0804803371429443, "sampled_ll": -0.7357021570205688, "all_perturbed_sampled_ll": [-1.7301011085510254], "all_perturbed_original_ll": [-2.354031801223755], "perturbed_sampled_ll": -1.7301011085510254, "perturbed_original_ll": -2.354031801223755, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,h,w,min,ans,mat[700][700],max[700][700];\nchar c;\n\nint main(){\n\twhile(scanf(\"%d %d\",&h,&w)*h*w){\n\t\tfor(i=0;i<h;i++){\n\t\t\tk=0;\n\t\t\tscanf(\"\\n\");\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\"%c\",&c);\n\t\t\t\tif(c=='.')k++; else k=0;\n\t\t\t\tmat[i][j]=k;\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tfor(j=w-1;j>=0;j--){\n\t\t\tfor(k=h-1;k>=0;k--){\n\t\t\t\tmin=mat[k][j];\n\t\t\t\tfor(i=1;i+k<h;i++){\n\t\t\t\t\tif(min>mat[i+k][j])min=mat[i+k][j];\n\t\t\t\t\tif(min==0)break;\n\t\t\t\t\tif(min*(i+1)>ans)ans=min*(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int H, W;\n    char grid[505][505];\n    int height[505][505];\n    \n    while (scanf(\"%d %d\", &H, &W) == 2 && (H || W)) {\n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        // Calculate height array\n        memset(height, 0, sizeof(height));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == '.') {\n                    if (i == 0) {\n                        height[i][j] = 1;\n                    } else {\n                        height[i][j] = height[i-1][j] + 1;\n                    }\n                } else {\n                    height[i][j] = 0;\n                }\n            }\n        }\n        \n        int maxArea = 0;\n        \n        // For each row, find largest rectangle in histogram\n        for (int i = 0; i < H; i++) {\n            // For each column as left boundary\n            for (int left = 0; left < W; left++) {\n                if (height[i][left] == 0) continue;\n                \n                int minHeight = height[i][left];\n                for (int right = left; right < W; right++) {\n                    if (height[i][right] == 0) break;\n                    \n                    if (height[i][right] < minHeight) {\n                        minHeight = height[i][right];\n                    }\n                    \n                    int width = right - left + 1;\n                    int area = minHeight * width;\n                    if (area > maxArea) {\n                        maxArea = area;\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", maxArea);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  int height[505][505]; while (scanf(\"%d %d\",  (int i = 0; i < H; i++) { scanf(\"%s\", grid[i]); } // Calculate height array memset(height, 0, sizeof(height)); for (int i = 0; i < H; i++) { for (int j = 0; j < W; j++) { if (grid[i][j] == '.') { if (i == 0) { height[i][j] = 1; } else {  = 0; } }  i < H; i++) { // For each column as left boundary for (int left = 0; left < W; left++) { if (height[i][left] == 0) continue; int minHeight = height[i][left]; for (int right = left; right < W; right++) { if (height[i][right] == 0) break; if (height[i][right] < minHeight) { minHeight = height[i][right]; } int width = right - left  > maxArea) { maxArea = area; } } } } printf(\"%d\\n\", maxArea); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int i,j,k,h,w,min,ans,mat[700][700],max[700][700]; char c; int main(){ while(scanf(\"%d %d\",&h,&w)*h*w){ for(i=0;i<h;i++){ k=0; scanf(\"\\n\"); for(j=0;j<w;j++){ scanf(\"%c\",&c); if(c=='.')k++; else k=0; mat[i][j]=k; } } ans=0; for(j=w-1;j>=0;j--){  } return 0; }"], "original_ll": -1.0355095863342285, "sampled_ll": -0.5008054971694946, "all_perturbed_sampled_ll": [-1.3157602548599243], "all_perturbed_original_ll": [-1.4511046409606934], "perturbed_sampled_ll": -1.3157602548599243, "perturbed_original_ll": -1.4511046409606934, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n//Rectangular Searching\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif((h|w)==0)break;\n\t\t\tchar[][] m = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)m[i]=sc.next().toCharArray();\n\t\t\tint[][] c = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tint x = 1;\n\t\t\t\tfor(int j=w-1;j>=0;j--){\n\t\t\t\t\tif(m[i][j]=='.'){\n\t\t\t\t\t\tc[i][j] = x++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tc[i][j] = 0;\n\t\t\t\t\t\tx = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(0<i&&c[i][j]==c[i-1][j]||c[i][j]==0)continue;\n\t\t\t\t\tint k = 1;\n\t\t\t\t\tint min = c[i][j];\n\t\t\t\t\tmax = Math.max(max, k*min);\n\t\t\t\t\twhile(i+k<h&&c[i+k][j]>0){\n\t\t\t\t\t\tmin = Math.min(min, c[i+k][j]);\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tmax = Math.max(max, k*min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int H = sc.nextInt();\n            int W = sc.nextInt();\n            \n            if (H == 0 && W == 0) break;\n            \n            sc.nextLine();\n            char[][] grid = new char[H][W];\n            \n            for (int i = 0; i < H; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            \n            int[][] height = new int[H][W];\n            \n            for (int j = 0; j < W; j++) {\n                for (int i = 0; i < H; i++) {\n                    if (grid[i][j] == '*') {\n                        height[i][j] = 0;\n                    } else {\n                        if (i == 0) {\n                            height[i][j] = 1;\n                        } else {\n                            height[i][j] = height[i-1][j] + 1;\n                        }\n                    }\n                }\n            }\n            \n            int maxArea = 0;\n            \n            for (int i = 0; i < H; i++) {\n                maxArea = Math.max(maxArea, largestRectangleInHistogram(height[i]));\n            }\n            \n            System.out.println(maxArea);\n        }\n        \n        sc.close();\n    }\n    \n    static int largestRectangleInHistogram(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        int n = heights.length;\n        \n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && heights[i] < heights[stack.peek()]) {\n                int h = heights[stack.pop()];\n                int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            stack.push(i);\n        }\n        \n        while (!stack.isEmpty()) {\n            int h = heights[stack.pop()];\n            int w = stack.isEmpty() ? n : n - stack.peek() - 1;\n            maxArea = Math.max(maxArea, h * w);\n        }\n        \n        return maxArea;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  int W = sc.nextInt(); if (H == 0 && W == 0) break; sc.nextLine(); char[][] grid = new char[H][W]; for (int i = 0; i < H; i++) { String line =  { grid[i][j] = line.charAt(j); } } int[][] height = new int[H][W]; for (int j = 0; j < W; j++)  { if (grid[i][j] == '*') { height[i][j] = 0; } else { if (i == 0) { height[i][j] = 1; } else { height[i][j] = height[i-1][j] + 1; } } }  i < H; i++) { maxArea = Math.max(maxArea, largestRectangleInHistogram(height[i])); } System.out.println(maxArea); } sc.close(); } static int  = 0; int n = heights.length; for (int i = 0; i < n; i++) { while (!stack.isEmpty() && heights[i] < heights[stack.peek()]) { int h = heights[stack.pop()]; int w =  = Math.max(maxArea, h * w); } stack.push(i); } while (!stack.isEmpty()) { int h = heights[stack.pop()]; int w = stack.isEmpty() ? n : n - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); } return maxArea; } }"], "perturbed_original": ["import java.util.Scanner; //Rectangular Searching public class Main{ public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){ int h = sc.nextInt(); int w = sc.nextInt(); <extra_id_7>j]!=0){ if(p[i][j]!=0){ break; }<extra_id_8>i<extra_id_9>i[j]>=0) continue; int = new int[h][w]; for(int i=0;i<h;i++){ int x = 1; for(int j=w-1;j>=0;j--){ if(m[i][j]=='.'){ c[i][j] = x++; } else{ c[i][j] = 0; x = 1; } } } int max = 0; for(int i=0;i<h;i++){ for(int j=0;j<w;j++){ if(0<i&&c[i][j]==c[i-1][j]||c[i][j]==0)continue; int <extra_id_10>if(p Math.max(max, k*min); } } } System.out.println(max); } } }"], "original_ll": -0.8140360116958618, "sampled_ll": -0.2861210107803345, "all_perturbed_sampled_ll": [-1.0362210273742676], "all_perturbed_original_ll": [-1.779376745223999], "perturbed_sampled_ll": -1.0362210273742676, "perturbed_original_ll": -1.779376745223999, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import product\nwhile(True):\n    H,W = map(int,input().split())\n    if not H: break\n    ma = 0\n    for i in range(H):\n        ma |= (int(input().replace(\".\",\"0\").replace(\"*\",\"1\"),2) << ((H-i-1)*W))\n    flag = False\n    hw = [[h,w] for h,w in product(range(H,0,-1),range(W,0,-1))]\n    hw = sorted(hw,key=lambda x: -x[1]*x[0])\n    ans = 0\n    for h,w in hw:\n        for i,j in product(range(H-h+1),range(W-w+1)):\n            b = (sum([((2**w-1) << j) << k*W for k in range(h)]) ) << i*W\n            c = ma&b\n            if not c :flag = True; ans = max(ans,h*w); break\n        else:\n            continue\n        if flag: break\n    print(ans)\n\n", "sampled": "def maximal_rectangle(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    \n    H = len(matrix)\n    W = len(matrix[0])\n    \n    # Build height matrix\n    heights = [[0] * W for _ in range(H)]\n    \n    for j in range(W):\n        for i in range(H):\n            if matrix[i][j] == '.':\n                if i == 0:\n                    heights[i][j] = 1\n                else:\n                    heights[i][j] = heights[i-1][j] + 1\n            else:\n                heights[i][j] = 0\n    \n    # Find max rectangle for each row using histogram method\n    max_area = 0\n    \n    for i in range(H):\n        max_area = max(max_area, largest_rectangle_in_histogram(heights[i]))\n    \n    return max_area\n\ndef largest_rectangle_in_histogram(heights):\n    stack = []\n    max_area = 0\n    index = 0\n    \n    while index < len(heights):\n        if not stack or heights[index] >= heights[stack[-1]]:\n            stack.append(index)\n            index += 1\n        else:\n            top = stack.pop()\n            width = index if not stack else index - stack[-1] - 1\n            area = heights[top] * width\n            max_area = max(max_area, area)\n    \n    while stack:\n        top = stack.pop()\n        width = index if not stack else index - stack[-1] - 1\n        area = heights[top] * width\n        max_area = max(max_area, area)\n    \n    return max_area\n\nwhile True:\n    line = input().split()\n    H, W = int(line[0]), int(line[1])\n    \n    if H == 0 and W == 0:\n        break\n    \n    matrix = []\n    for _ in range(H):\n        row = input().strip()\n        matrix.append(row)\n    \n    result = maximal_rectangle(matrix)\n    print(result)\n", "perturbed_sampled": ["def maximal_rectangle(matrix): if not matrix  len(matrix[0]) # Build height matrix heights = [[0] * W for _ in range(H)] for j in range(W): for i in range(H): if matrix[i][j] == '.': if i == 0: heights[i][j] =  0 # Find max rectangle for each row using histogram method max_area = 0 for i in range(H): max_area = max(max_area, largest_rectangle_in_histogram(heights[i])) return max_area def largest_rectangle_in_histogram(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index +=  stack else index - stack[-1] - 1 area = heights[top] * width max_area = max(max_area, area) while  else index - stack[-1] - 1 area = heights[top] * width max_area = max(max_area, area) return max_area while True: line =  and W == 0: break matrix = [] for _ in range(H): row = input().strip() matrix.append(row) result = maximal_rectangle(matrix) print(result)"], "perturbed_original": ["from itertools import product while(True): H,W = map(int,input().split()) if not H: break ma = 0 for i in range(H): ma |= (int(input().replace(\".\",\"0\").replace(\"*\",\"1\"),2) << ((H-i-1)*W)) flag  in hw: for i,j in product(range(H-h+1),range(W-w+1)): b = (sum([((2**w-1) << j) << k*W for k in range(h)]) ) << i*W c = ma&b if not c :flag = True; ans = max(ans,h*w); break else: continue if flag: break print(ans)"], "original_ll": -1.5882657766342163, "sampled_ll": -0.4644571542739868, "all_perturbed_sampled_ll": [-1.474070429801941], "all_perturbed_original_ll": [-2.399418354034424], "perturbed_sampled_ll": -1.474070429801941, "perturbed_original_ll": -2.399418354034424, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#define rep(i,n) for(i=0;i<n;i++)\nint min(int a,int b){return a<b?a:b;}\nint main(void)\n{\n  int n,m,mat[20][20],i,j,k,a,b,c,d;\n  scanf(\"%d%d\",&n,&m);\n  rep(i,n)rep(j,n)mat[i][j]=i-j?1<<21:0;\n  rep(i,m){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--;\n    mat[a][b]=c;mat[b][a]=d;\n  }\n  rep(i,n)rep(j,n)rep(k,n)mat[j][k]=min(mat[j][k],mat[j][i]+mat[i][k]);\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--;\n  printf(\"%d\\n\",c-mat[a][b]-mat[b][a]-d);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 21\n#define INF INT_MAX\n\nint n, m;\nint cost[MAX_N][MAX_N];\nint dist[MAX_N];\nint visited[MAX_N];\n\nvoid dijkstra(int start) {\n    for (int i = 1; i <= n; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    dist[start] = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int u = -1;\n        int minDist = INF;\n        for (int j = 1; j <= n; j++) {\n            if (!visited[j] && dist[j] < minDist) {\n                minDist = dist[j];\n                u = j;\n            }\n        }\n        \n        if (u == -1) break;\n        visited[u] = 1;\n        \n        for (int v = 1; v <= n; v++) {\n            if (cost[u][v] != INF && dist[u] != INF) {\n                if (dist[u] + cost[u][v] < dist[v]) {\n                    dist[v] = dist[u] + cost[u][v];\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cost[i][j] = INF;\n        }\n    }\n    \n    for (int i = 0; i < m; i++) {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        cost[a][b] = c;\n        cost[b][a] = d;\n    }\n    \n    int s, g, V, P;\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n    \n    dijkstra(s);\n    int costToG = dist[g];\n    \n    dijkstra(g);\n    int costFromG = dist[s];\n    \n    int totalCost = costToG + costFromG + P;\n    int reward = V - totalCost;\n    \n    printf(\"%d\\n\", reward);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h> #define MAX_N 21  int visited[MAX_N]; void dijkstra(int start) { for (int i = 1; i <= n; i++) { dist[i] = INF; visited[i] = 0; } dist[start] = 0; for (int i = 0; i < n; i++) { int u = -1; int minDist = INF; for (int j = 1; j <= n; j++) { if (!visited[j] && dist[j] < minDist) { minDist = dist[j]; u  = 1; for (int v = 1; v <= n; v++) { if (cost[u][v] != INF && dist[u] != INF) { if (dist[u] + cost[u][v] < dist[v]) { dist[v]  main() { scanf(\"%d\", &n); scanf(\"%d\", &m); for (int i = 1; i <= n; i++) { for (int j = 1; j <= n; j++) {  i < m; i++) { int a, b,  cost[b][a] = d; } int s, g, V, P; scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P); dijkstra(s); int costToG = dist[g]; dijkstra(g); int costFromG = dist[s]; int totalCost = costToG +  reward); return 0; }"], "perturbed_original": ["#include<stdio.h> #define rep(i,n) for(i=0;i<n;i++) int min(int a,int b){return a<b?a:b;} int main(void) { int n,m,mat[20][20],i,j,k,a,b,c,d; scanf(\"%d%d\",&n,&m); rep(i,n)rep(j,n)mat[i][j]=i-j?1<<21:0; rep(i,m){ scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--; mat[a][b]=c;mat[b][a]=d; } rep(i,n)rep(j,n)rep(k,n)mat[j][k]=min(mat[j][k],mat[j][i]+mat[i][k]); scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--; printf(\"%d\\n\",c-mat[a][b]-mat[b][a]-d); return 0; }"], "original_ll": -1.0346885919570923, "sampled_ll": -0.4420737624168396, "all_perturbed_sampled_ll": [-1.1420403718948364], "all_perturbed_original_ll": [-1.1639610528945923], "perturbed_sampled_ll": -1.1420403718948364, "perturbed_original_ll": -1.1639610528945923, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final int INF = Integer.MAX_VALUE;\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\t}\n\t\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\t//int[][] d = new int[n][n]; \n\t\tint m = sc.nextInt();\n\t\tint[][] road = new int[m][4];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tString s = sc.next();\n\t\t\tString[] ss = s.split(\",\");\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\troad[i][j] = Integer.parseInt(ss[j]);\n\t\t\t}\n\t\t}\n\t\tint[] input = new int[4];\n\t\tString s = sc.next();\n\t\tString[] ss = s.split(\",\");\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tinput[j] = Integer.parseInt(ss[j]);\n\t\t}\n\t\tint start = input[0];\n\t\tint goal = input[1];\n\t\t//start\u304b\u3089goal\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u6c42\u3081\u308b\n\t\t//start\u304b\u3089\u306e\u8ddd\u96e2\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\td[start - 1] = 0;\n\t\twhile(true){\n\t\t\tboolean bChange = false;\n\t\t\t//\u9053\u3092\u898b\u3066\u3044\u304f\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint from = road[i][0];\n\t\t\t\tint to = road[i][1];\n\t\t\t\tint cost = road[i][2];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfrom = road[i][1];\n\t\t\t\tto = road[i][0];\n\t\t\t\tcost = road[i][3];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//print(d);\n\t\t\tif(bChange == false) break;\n\t\t}\n\t\tint sum = d[goal - 1];\n\t\t\n\t\t//\u4eca\u5ea6\u306f\u30b4\u30fc\u30eb\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2\n\t\tstart = input[1];\n\t\tgoal = input[0];\n\t\tArrays.fill(d, INF);\n\t\td[start - 1] = 0;\n\t\twhile(true){\n\t\t\tboolean bChange = false;\n\t\t\t//\u9053\u3092\u898b\u3066\u3044\u304f\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint from = road[i][0];\n\t\t\t\tint to = road[i][1];\n\t\t\t\tint cost = road[i][2];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfrom = road[i][1];\n\t\t\t\tto = road[i][0];\n\t\t\t\tcost = road[i][3];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//print(d);\n\t\t\tif(bChange == false) break;\n\t\t}\n\t\t//System.out.println(d[goal - 1]);\n\t\tsum += d[goal - 1];\n\t\t\n\t\tSystem.out.println(input[2] - input[3] - sum);\n\t\t\n\t}\n\t\n\tpublic static void print(int[] d){\n\t\tfor(int a : d){\n\t\t\tSystem.out.print(a + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to;\n        int cost;\n        \n        Edge(int to, int cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        sc.nextLine();\n        \n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            int c = Integer.parseInt(parts[2]);\n            int d = Integer.parseInt(parts[3]);\n            \n            graph.get(a).add(new Edge(b, c));\n            graph.get(b).add(new Edge(a, d));\n        }\n        \n        String[] lastLine = sc.nextLine().split(\",\");\n        int s = Integer.parseInt(lastLine[0]);\n        int g = Integer.parseInt(lastLine[1]);\n        int V = Integer.parseInt(lastLine[2]);\n        int P = Integer.parseInt(lastLine[3]);\n        \n        int[] distToG = dijkstra(graph, n, s, g);\n        int[] distFromG = dijkstra(graph, n, g, s);\n        \n        int minCost = distToG[g] + distFromG[s];\n        int reward = V - P - minCost;\n        \n        System.out.println(reward);\n        \n        sc.close();\n    }\n    \n    static int[] dijkstra(List<List<Edge>> graph, int n, int start, int end) {\n        int[] dist = new int[n + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        pq.offer(new int[]{start, 0});\n        \n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int u = curr[0];\n            int d = curr[1];\n            \n            if (d > dist[u]) continue;\n            \n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                int newDist = dist[u] + edge.cost;\n                \n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.offer(new int[]{v, newDist});\n                }\n            }\n        }\n        \n        return dist;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Edge { int to; int cost; Edge(int to, int cost) { this.to = to; this.cost =  sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); sc.nextLine(); List<List<Edge>> graph = new ArrayList<>(); for (int i = 0; i <= n; i++) { graph.add(new ArrayList<>()); } for (int i = 0; i < m; i++) { String line = sc.nextLine(); String[] parts = line.split(\",\"); int a =  int g = Integer.parseInt(lastLine[1]); int V = Integer.parseInt(lastLine[2]); int P = Integer.parseInt(lastLine[3]); int[] distToG = dijkstra(graph, n, s, g); int[] distFromG = dijkstra(graph, n, g, s); int minCost = distToG[g] + distFromG[s]; int reward  int[] dijkstra(List<List<Edge>> graph, int n, int start, int end)   a[1] - b[1]); pq.offer(new int[]{start, 0}); while (!pq.isEmpty()) { int[] curr = pq.poll(); int u = curr[0]; int d = curr[1]; if (d > dist[u]) continue; for (Edge edge : graph.get(u)) { int v = edge.to; int newDist = dist[u] + edge.cost; if (newDist < dist[v]) { dist[v] = newDist; pq.offer(new int[]{v, newDist}); } } } return dist; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { /** * @param args */ public static final int INF = Integer.MAX_VALUE; public static void main(String[] args) { doIt(); } public static void doIt(){ Scanner sc = new Scanner(System.in); int  = 0; i < m; i++){ String s = sc.next(); String[] ss = s.split(\",\"); for(int j = 0; j < 4; j++){ road[i][j] = Integer.parseInt(ss[j]); } } int[] input = new int[4]; String s = sc.next(); String[] ss = s.split(\",\"); for(int j = 0; j < 4; j++){ input[j] = Integer.parseInt(ss[j]); } int start = input[0]; int goal =  d[start - 1] = 0; while(true){  < m; i++){ int  road[i][2]; if(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){ d[to - 1] =  - 1] != INF && d[from - 1] + cost < d[to - 1]){ d[to  true; } } //print(d); if(bChange ==  start = input[1]; goal = input[0]; Arrays.fill(d, INF); d[start - 1] = 0; while(true){ boolean bChange = false; //\u9053\u3092\u898b\u3066\u3044\u304f for(int i = 0; i < m; i++){ int from = road[i][0]; int to = road[i][1]; int cost = road[i][2]; if(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){ d[to - 1] = d[from - 1] + cost; bChange = true; } from = road[i][1]; to = road[i][0]; cost =  + cost < d[to - 1]){ d[to - 1] = d[from - 1] + cost; bChange = true; } } //print(d); if(bChange == false) break; } //System.out.println(d[goal - 1]); sum += d[goal  void print(int[] d){ for(int a : d){ System.out.print(a + \" \"); } System.out.println(); } }"], "original_ll": -0.5172399878501892, "sampled_ll": -0.43150803446769714, "all_perturbed_sampled_ll": [-1.244519829750061], "all_perturbed_original_ll": [-1.2560961246490479], "perturbed_sampled_ll": -1.244519829750061, "perturbed_original_ll": -1.2560961246490479, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def floyd(P,m):\n    for k in range(m):\n        for i in range(m):\n            for j in range(m):\n                P[i][j]=min(P[i][j],P[i][k]+P[k][j])\n\nn=input()\nm=input()\nINF=1e10\nC=[[INF]*n for i in range(n)]\nfor i in range(n):\n    C[i][i]=0\nfor i in range(m):\n    a1,b1,c1,d1=map(int,raw_input().split(\",\"))\n    C[a1-1][b1-1]=c1\n    C[b1-1][a1-1]=d1\nfloyd(C,n)\nx1,x2,y1,y2=map(int,raw_input().split(\",\"))\nprint y1-y2-C[x1-1][x2-1]-C[x2-1][x1-1]", "sampled": "import sys\nfrom collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start, n):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, cost in graph[u]:\n            if dist[u] + cost < dist[v]:\n                dist[v] = dist[u] + cost\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist\n\nn = int(input())\nm = int(input())\n\ngraph_forward = defaultdict(list)\ngraph_backward = defaultdict(list)\n\nfor _ in range(m):\n    line = input().strip()\n    parts = line.split(',')\n    a = int(parts[0])\n    b = int(parts[1])\n    c = int(parts[2])\n    d = int(parts[3])\n    \n    graph_forward[a].append((b, c))\n    graph_backward[b].append((a, d))\n\nlast_line = input().strip()\nparts = last_line.split(',')\ns = int(parts[0])\ng = int(parts[1])\nV = int(parts[2])\nP = int(parts[3])\n\ndist_from_s = dijkstra(graph_forward, s, n)\ndist_from_g = dijkstra(graph_backward, g, n)\n\ntotal_cost = dist_from_s[g] + dist_from_g[s] + P\nreward = V - total_cost\n\nprint(reward)\n", "perturbed_sampled": ["import sys from collections import defaultdict import heapq def dijkstra(graph, start,  0  if d > dist[u]: continue for v, cost in graph[u]: if dist[u] + cost < dist[v]: dist[v] = dist[u] + cost heapq.heappush(pq, (dist[v], v)) return dist n = int(input()) m = int(input()) graph_forward = defaultdict(list) graph_backward = defaultdict(list) for _ in range(m): line = input().strip() parts = line.split(',') a = int(parts[0]) b = int(parts[1]) c = int(parts[2]) d = int(parts[3]) graph_forward[a].append((b, c)) graph_backward[b].append((a, d)) last_line = input().strip()  = int(parts[2]) P = int(parts[3]) dist_from_s = dijkstra(graph_forward, s,  dist_from_g[s] + P reward = V - total_cost print(reward)"], "perturbed_original": ["def floyd(P,m): for k in range(m): for i in range(m): for j in range(m): P[i][j]=min(P[i][j],P[i][k]+P[k][j]) n=input() m=input() INF=1e10 C=[[INF]*n for i >=m:<extra_id_14>[i range(m): a1,b1,c1,d1=map(int,raw_input().split(\",\")) C[a1-1][b1-1]=c1 C[b1-1][a1-1]=d1 floyd(C,n) x1,x2,y1,y2=map(int,raw_input().split(\",\")) print y1-y2-C[x1-1][x2-1]-C[x2-1][x1-1]"], "original_ll": -0.9487079977989197, "sampled_ll": -0.659919798374176, "all_perturbed_sampled_ll": [-1.6278038024902344], "all_perturbed_original_ll": [-1.9400190114974976], "perturbed_sampled_ll": -1.6278038024902344, "perturbed_original_ll": -1.9400190114974976, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\n#define MAX 100\nchar farm[MAX][MAX];\n\nvoid divide(int i, int j, int H, int W, char moji)\n{\n    if( farm[i][j] == moji ){\n        farm[i][j] = '+';\n        if( j + 1 < W ) divide(i, j + 1, H, W, moji);\n        if( i + 1 < H ) divide(i + 1, j, H, W, moji);\n        if( j - 1 >= 0 )divide(i, j - 1, H, W, moji);\n        if( i - 1 >= 0 )divide(i - 1, j, H, W, moji);\n    }\n}\n\nint main()\n{\n    int H, W, i, j, cnt;\n    while(1){\n        cnt = 0;\n        scanf(\"%d %d\", &H, &W);\n        if(H == 0 && W == 0) break;\n\n        for(i = 0; i < H; i++){\n            scanf(\"%s\", farm[i]);\n        }\n        for(i = 0; i < H; i++ ){\n            for(j = 0; j < W; j++){\n                if(farm[i][j] == '+') continue;\n                cnt++;\n                divide(i, j, H, W, farm[i][j]);\n            }\n        }\n        printf(\"%d\\n\", cnt);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nchar grid[100][101];\nint visited[100][100];\nint H, W;\n\nvoid dfs(int i, int j, char c) {\n    if (i < 0 || i >= H || j < 0 || j >= W) return;\n    if (visited[i][j]) return;\n    if (grid[i][j] != c) return;\n    \n    visited[i][j] = 1;\n    \n    dfs(i-1, j, c);\n    dfs(i+1, j, c);\n    dfs(i, j-1, c);\n    dfs(i, j+1, c);\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &H, &W);\n        if (H == 0 && W == 0) break;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        memset(visited, 0, sizeof(visited));\n        \n        int count = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (!visited[i][j]) {\n                    dfs(i, j, grid[i][j]);\n                    count++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> char grid[100][101]; int visited[100][100]; int H, W; void dfs(int i, int j, char c) { if (i  (grid[i][j] != c) return; visited[i][j] = 1; dfs(i-1, j, c); dfs(i+1, j, c); dfs(i, j-1, c);  scanf(\"%d %d\", &H, &W); if (H == 0 && W == 0) break;  scanf(\"%s\", grid[i]); } memset(visited, 0, sizeof(visited)); int count = 0; for (int i = 0; i < H; i++) { for (int j = 0; j < W; j++) { if (!visited[i][j]) { dfs(i, j, grid[i][j]); count++; } } } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include<stdio.h> #define MAX 100  farm[i][j] = '+'; if( j + 1 < W ) divide(i, j + 1, H, W, moji); if( i + 1 < H ) divide(i + 1, j, H, W, moji); if( j - 1 >= 0 )divide(i, j - 1, H, W, moji); if( i - 1 >= 0 )divide(i - 1, j, H, W, moji); } } int main() { int H, W, i, j,  == 0 && W == 0) break; for(i = 0; i < H; i++){ scanf(\"%s\", farm[i]); } for(i = 0; i < H; i++ ){ for(j = 0; j < W; j++){ if(farm[i][j]  } printf(\"%d\\n\", cnt); } return 0; }"], "original_ll": -0.5867226719856262, "sampled_ll": -0.3324683606624603, "all_perturbed_sampled_ll": [-0.8212027549743652], "all_perturbed_original_ll": [-1.2685636281967163], "perturbed_sampled_ll": -0.8212027549743652, "perturbed_original_ll": -1.2685636281967163, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\t\n\tint[][] offset = new int[][]{\n\t\t\t{-1, 0}, {1, 0}, {0, -1}, {0, 1}\n\t};\n\n\n\tpublic Main() throws IOException, StackOverflowError{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> Ans = new ArrayList<Integer>();\n\t\tString line = in.readLine();\n\t\tString[] dst = line.split(\" \");\n\t\tInteger.parseInt(dst[0]);\n\n\t\t\n\t}\n\n\tpublic void grouping(int[][] data, int[][] label, int x, int y){\n\t\tList<point> cue = new ArrayList<point>();\n\t\tcue.add(new point(x, y));\n\t\twhile(cue.size() != 0){\n\t\t\tpoint p = cue.get(0);\n\t\t\tcue.remove(0);\n\t\t\tfor(int d=0; d<4; d++){\n\t\t\t\tint xx = p.x + offset[d][0];\n\t\t\t\tint yy = p.y + offset[d][1];\n\t\t\t\tif(label[yy][xx] == 0 && data[yy][xx] == data[p.y][p.x]){\n\t\t\t\t\tlabel[yy][xx] = label[p.y][p.x];\n\t\t\t\t\tcue.add(new point(xx, yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass point{\n\tint x;\n\tint y;\n\t\n\tpublic point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int H, W;\n    static char[][] grid;\n    static boolean[][] visited;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            H = sc.nextInt();\n            W = sc.nextInt();\n            \n            if (H == 0 && W == 0) break;\n            \n            grid = new char[H][W];\n            visited = new boolean[H][W];\n            \n            for (int i = 0; i < H; i++) {\n                String line = sc.next();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            \n            int count = 0;\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (!visited[i][j]) {\n                        dfs(i, j, grid[i][j]);\n                        count++;\n                    }\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n    \n    static void dfs(int x, int y, char fruit) {\n        if (x < 0 || x >= H || y < 0 || y >= W) return;\n        if (visited[x][y]) return;\n        if (grid[x][y] != fruit) return;\n        \n        visited[x][y] = true;\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            dfs(nx, ny, fruit);\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int H, W; static char[][] grid; static boolean[][] visited; static int[] dx = {-1, 1, 0, 0}; static int[] dy = {0, 0, -1, 1}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { H = sc.nextInt(); W = sc.nextInt(); if (H == 0 && W == 0) break; grid = new char[H][W]; visited = new boolean[H][W]; for (int i = 0; i < H; i++) { String line = sc.next(); for (int j = 0; j < W; j++) { grid[i][j] = line.charAt(j); } } int count  W; j++) {  System.out.println(count); } sc.close(); } static void dfs(int x, int y, char fruit) { if (x <  y >= W) return; if  for (int i = 0; i  int ny = y + dy[i]; dfs(nx, ny, fruit); } } }"], "perturbed_original": ["import java.io.*; import java.util.*;  Main(); }catch(IOException err){ err.printStackTrace();  0}, {0, -1}, {0, 1} }; public Main() throws IOException, StackOverflowError{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); List<Integer> Ans = new ArrayList<Integer>(); String line = in.readLine(); String[] dst = line.split(\" \"); Integer.parseInt(dst[0]); } public  cue = new ArrayList<point>(); cue.add(new point(x, y)); while(cue.size() != 0){ point p = cue.get(0); cue.remove(0); for(int d=0; d<4; d++){ int xx = p.x  0 && data[yy][xx] == data[p.y][p.x]){ label[yy][xx] = label[p.y][p.x]; cue.add(new point(xx, yy)); } } } } } class point{ int x; int y; public point(int x, int y){ this.x = x; this.y = y; } }"], "original_ll": -0.9950542449951172, "sampled_ll": -0.2508944571018219, "all_perturbed_sampled_ll": [-1.020371675491333], "all_perturbed_original_ll": [-1.7595009803771973], "perturbed_sampled_ll": -1.020371675491333, "perturbed_original_ll": -1.7595009803771973, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def wa(h, w, f):\n    if not (0 <= h <= H-1 and 0 <= w <= W-1):\n        return\n    elif mapp[h][w] != f:\n        return\n    else:\n        mapp[h][w] = '$'\n        wa(h, w+1, f)\n        wa(h-1, w, f)\n        wa(h, w-1, f)\n        wa(h+1, w, f)\n\nwhile True:\n    H, W = map(int, raw_input().split(' '))\n    if H == 0: break\n    mapp = [list(raw_input()) for i in range(H)]\n    count = 0\n    for h in range(H):\n        for w in range(W):\n            if mapp[h][w] == '@':\n                wa(h, w, '@')\n            elif mapp[h][w] == '#':\n                wa(h, w, '#')\n            elif mapp[h][w] == '*':\n                wa(h, w, '*')\n            else:\n                continue\n            count += 1\n    else:\n        print count", "sampled": "def count_regions(H, W, grid):\n    visited = [[False] * W for _ in range(H)]\n    count = 0\n    \n    def dfs(i, j, fruit_type):\n        if i < 0 or i >= H or j < 0 or j >= W:\n            return\n        if visited[i][j]:\n            return\n        if grid[i][j] != fruit_type:\n            return\n        \n        visited[i][j] = True\n        dfs(i-1, j, fruit_type)\n        dfs(i+1, j, fruit_type)\n        dfs(i, j-1, fruit_type)\n        dfs(i, j+1, fruit_type)\n    \n    for i in range(H):\n        for j in range(W):\n            if not visited[i][j]:\n                dfs(i, j, grid[i][j])\n                count += 1\n    \n    return count\n\nwhile True:\n    line = input().split()\n    H, W = int(line[0]), int(line[1])\n    \n    if H == 0 and W == 0:\n        break\n    \n    grid = []\n    for _ in range(H):\n        grid.append(input().strip())\n    \n    result = count_regions(H, W, grid)\n    print(result)\n", "perturbed_sampled": ["def count_regions(H, W, grid): visited = [[False] * W for _  i < 0 or i >= H  visited[i][j]: return if grid[i][j] != fruit_type: return visited[i][j] = True dfs(i-1, j, fruit_type) dfs(i+1, j, fruit_type) dfs(i, j-1, fruit_type) dfs(i, j+1, fruit_type) for i in range(H): for j in range(W):  count while True: line = input().split() H, W = int(line[0]), int(line[1]) if H == 0 and W == 0: break grid = [] for _ in range(H): grid.append(input().strip()) result = count_regions(H, W, grid) print(result)"], "perturbed_original": ["def wa(h, w, f): if not (0 <= h <= H-1 and 0 <= w <= W-1): return elif mapp[h][w] != f: return else: mapp[h][w] = '$' wa(h, w+1, f) wa(h-1, w, f)  = map(int, raw_input().split(' ')) if H == 0: break mapp = [list(raw_input()) for i in  in range(W): if mapp[h][w] == '@': wa(h, w, '@') elif mapp[h][w] == '#': wa(h, w, '#') elif mapp[h][w] == '*': wa(h, w, '*') else: continue count += 1 else: print count"], "original_ll": -0.7983009815216064, "sampled_ll": -0.4746793210506439, "all_perturbed_sampled_ll": [-1.560606837272644], "all_perturbed_original_ll": [-1.6158695220947266], "perturbed_sampled_ll": -1.560606837272644, "perturbed_original_ll": -1.6158695220947266, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0119\nTitle Taro's obsession\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define SHOUGENNO 100\n#define NINZUU 20\nint n,m;\nint x[SHOUGENNO],y[SHOUGENNO];\nint flag[NINZUU+1];\n//\nvoid show()\n{\n  int i;\n  for(i=1;i<=n;i++)\n    printf(\"%d:\",flag[i]);\n  printf(\"\\n\");\n}\nmain()\n{\n  int i,cnt;\n\n  scanf(\"%d \",&n);\n  scanf(\"%d \",&m);\n  for(i=0;i<m;i++)\n    scanf(\"%d %d\",&x[i],&y[i]);\n  for(i=0;i<n;i++)\n    flag[i]=0;\n\n  cnt=n;\n\n  while(cnt>1)\n    {\n      for(i=1;i<=n;i++)\n\tif(flag[i]>0)\n\t  flag[i]=0;\n      //show();\n      for(i=0;i<m;i++)\n\tif(flag[x[i]]!=-1)\n\t  flag[y[i]]=1;\n      for(i=1;i<=n;i++)\n\t{\n\t  if(flag[i]==0 && i!=2)\n\t    {\n\t      printf(\"%d\\n\",i);\n\t      cnt--;\n\t      flag[i]=-1;\n\t    }\n\t}\n      //show();\n    }\n  printf(\"2\\n\");\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int m, n;\n    scanf(\"%d\", &m);\n    scanf(\"%d\", &n);\n    \n    int adj[21][21] = {0};\n    int indegree[21] = {0};\n    \n    for (int i = 0; i < n; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        if (!adj[x][y]) {\n            adj[x][y] = 1;\n            indegree[y]++;\n        }\n    }\n    \n    int result[21];\n    int used[21] = {0};\n    int pos = 0;\n    \n    while (pos < m) {\n        for (int i = 1; i <= m; i++) {\n            if (used[i]) continue;\n            if (indegree[i] == 0) {\n                result[pos++] = i;\n                used[i] = 1;\n                for (int j = 1; j <= m; j++) {\n                    if (adj[i][j]) {\n                        indegree[j]--;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    \n    for (int i = 0; i < m; i++) {\n        printf(\"%d\\n\", result[i]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> int main() { int m, adj[i][x]; for (int j<extra_id_1>int j = 1; j<extra_id_2>j) { if<extra_id_3>adj[i][y] = 0 ;<extra_id_4>j++)<extra_id_5>for (int j =<extra_id_6>i++ ) if (adj[i][y] ==<extra_id_7>} }<extra_id_8>} return i;<extra_id_9>0;<extra_id_10>{ if (indegree[n] =<extra_id_11>int<extra_id_12>{ int<extra_id_13>* {1,<extra_id_14>{1,1} continue; if ( indegree[21] = {0}; for (int i = 0; i < n; i++) {  adj[x][y] = 1; indegree[y]++; } } int result[21]; int used[21] = {0}; int pos = 0; while (pos < m) { for (int i = 1; i <= m; i++) { if (used[i]) continue; if (indegree[i] == 0) { result[pos++] = i; used[i] = 1; for (int j = 1; j <= m; j++) { if (adj[i][j]) { indegree[j]--; } } break; } } } for (int i  return 0; }"], "perturbed_original": ["/* AizuOnline A0119 Title Taro's obsession */ #include <stdio.h> // Select Below //#include <stdlib.h> //#include <string.h> //#include <float.h> //#include <math.h> //#include <limits.h> //Global  int x[SHOUGENNO],y[SHOUGENNO]; int flag[NINZUU+1]; // void show() { int i; for(i=1;i<=n;i++) printf(\"%d:\",flag[i]); printf(\"\\n\"); } main() { int i,cnt; scanf(\"%d \",&n); scanf(\"%d \",&m); for(i=0;i<m;i++) scanf(\"%d %d\",&x[i],&y[i]); for(i=0;i<n;i++) flag[i]=0; cnt=n; while(cnt>1) { for(i=1;i<=n;i++) if(flag[i]>0) flag[i]=0; //show(); for(i=0;i<m;i++) if(flag[x[i]]!=-1) flag[y[i]]=1; for(i=1;i<=n;i++) { if(flag[i]==0 &&  return(0); }"], "original_ll": -1.5200926065444946, "sampled_ll": -0.4678477644920349, "all_perturbed_sampled_ll": [-1.8638973236083984], "all_perturbed_original_ll": [-1.8795349597930908], "perturbed_sampled_ll": -1.8638973236083984, "perturbed_original_ll": -1.8795349597930908, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n    \npublic class Main {\n    public static void main(String[] args) {\n        (new Main()).execute();\n    }\n    private void execute() {\n        Scanner sc = new Scanner(System.in);\n\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        ObsessionComparator comp = new ObsessionComparator(m);\n        for(int i = 0 ; i < n ; i++) {comp.add(sc.nextInt(), sc.nextInt());}\n        \n        Integer[] list = new Integer[m];\n        for(int i = 0 ; i < m ; i++) {list[i] = Integer.valueOf(i+1);}\n        \n        Arrays.sort(list, comp);\n        \n        for(Integer i : list){System.out.println(i);}\n        sc.close();\n    }\n    \n    private class ObsessionComparator implements Comparator<Integer> {\n    \tprivate Map<Integer, Set<Integer>> sortMap = new HashMap<Integer, Set<Integer>>();\n    \tprivate ObsessionComparator(int count) {\n    \t\tfor(int i = 1 ; i <= count ; i++) {\n    \t\t\tsortMap.put(Integer.valueOf(i), new HashSet<Integer>());\n    \t\t}\n    \t}\n\n    \tprivate void add(Integer x, Integer y) {\n    \t\tsortMap.get(x).add(y);\n    \t}\n    \tprivate boolean isSorted(Integer x, Integer y) {\n    \t\tif(sortMap.get(x).contains(y)) {\n    \t\t\treturn true;\n    \t\t} else if(sortMap.get(x).isEmpty()) {\n    \t\t\treturn false;\n    \t\t} else {\n    \t\t\tfor(Integer next : sortMap.get(x)) {\n    \t\t\t\tif(isSorted(next, y)){\n    \t\t\t\t\treturn true;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn false;\n    \t\t}\n    \t}\n    \t\n    \t@Override\n\t\tpublic int compare(Integer arg0, Integer arg1) {\n    \t\treturn isSorted(arg0, arg1) ? -1 : 1;\n\t\t}\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        \n        List<List<Integer>> graph = new ArrayList<>();\n        int[] indegree = new int[m + 1];\n        \n        for (int i = 0; i <= m; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            graph.get(x).add(y);\n            indegree[y]++;\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 1; i <= m; i++) {\n            if (indegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            result.add(current);\n            \n            for (int next : graph.get(current)) {\n                indegree[next]--;\n                if (indegree[next] == 0) {\n                    queue.offer(next);\n                }\n            }\n        }\n        \n        for (int suspect : result) {\n            System.out.println(suspect);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {  Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); List<List<Integer>> graph = new ArrayList<>(); int[] indegree = new int[m + 1]; for (int i = 0; i <= m;  i < n; i++) { int x = sc.nextInt(); int y = sc.nextInt(); graph.get(x).add(y); indegree[y]++; } Queue<Integer> queue = new LinkedList<>(); for (int i = 1; i <= m; i++) { if (indegree[i] == 0) { queue.offer(i); } } List<Integer>  if (indegree[next] == 0) { queue.offer(next); } } } for (int suspect : result) { System.out.println(suspect); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Comparator; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Scanner; import java.util.Set; public class Main { public static void main(String[] args)  = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); ObsessionComparator comp = new ObsessionComparator(m); for(int i = 0 ; i < n ; i++) {comp.add(sc.nextInt(), sc.nextInt());} Integer[] list = new Integer[m]; for(int i = 0 ; i < m ; i++) {list[i]  private class ObsessionComparator implements Comparator<Integer> { private Map<Integer, Set<Integer>> sortMap = new HashMap<Integer, Set<Integer>>();  <= count ; i++) { sortMap.put(Integer.valueOf(i), new HashSet<Integer>()); } } private void add(Integer x, Integer y) { sortMap.get(x).add(y); } private boolean isSorted(Integer x, Integer y) { if(sortMap.get(x).contains(y)) {  { for(Integer next : sortMap.get(x)) { if(isSorted(next, y)){ return  compare(Integer arg0, Integer arg1) { return isSorted(arg0, arg1) ? -1 : 1; } } }"], "original_ll": -0.8189771771430969, "sampled_ll": -0.2850877046585083, "all_perturbed_sampled_ll": [-1.119675874710083], "all_perturbed_original_ll": [-1.4530134201049805], "perturbed_sampled_ll": -1.119675874710083, "perturbed_original_ll": -1.4530134201049805, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def solve(a):\n\tif len(a) == m: return a\n\tfor i in M-set(a):\n\t\tfor x,y in xy:\n\t\t\tif x == i and y not in a: break\n\t\telse:\n\t\t\tr = solve([i]+a)\n\t\t\tif r: return r\nm = input()\nM = set(range(1,m+1))\nxy = [map(int,raw_input().split()) for i in range(input())]\nfor i in solve([]): print i", "sampled": "from collections import defaultdict, deque\n\ndef topological_sort(m, edges):\n    # Build adjacency list and in-degree count\n    graph = defaultdict(list)\n    in_degree = [0] * (m + 1)\n    \n    for x, y in edges:\n        graph[x].append(y)\n        in_degree[y] += 1\n    \n    # Find all nodes with in-degree 0\n    queue = deque()\n    for i in range(1, m + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    result = []\n    while queue:\n        # Pick the smallest numbered node (for consistency)\n        queue = deque(sorted(queue))\n        node = queue.popleft()\n        result.append(node)\n        \n        # Reduce in-degree for neighbors\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result\n\n# Read input\nm = int(input())\nn = int(input())\nedges = []\nfor _ in range(n):\n    x = int(input())\n    y = int(input())\n    edges.append((x, y))\n\n# Perform topological sort\norder = topological_sort(m, edges)\n\n# Output result\nfor suspect in order:\n    print(suspect)\n", "perturbed_sampled": ["from collections import defaultdict, deque def topological_sort(m, edges): # Build adjacency list and in-degree count graph = defaultdict(list) in_degree = [0] * (m + 1) for x, y in edges: graph[x].append(y) in_degree[y] += 1 # Find all nodes  m + 1): if in_degree[i] == 0: queue.append(i) result = [] while  = deque(sorted(queue)) node = queue.popleft() result.append(node) # Reduce in-degree for neighbors for neighbor in graph[node]: in_degree[neighbor] -= 1  for _ in range(n): x = int(input()) y = int(input()) edges.append((x, y)) # Perform topological sort order = topological_sort(m, edges) # Output result for suspect in order: print(suspect)"], "perturbed_original": ["def solve(a): if len(a) ==  xy: if x == i and y not in a: break else: r = solve([i]+a) if r: return r m = input() M = set(range(1,m+1)) xy = [map(int,raw_input().split()) for i in range(input())] for i in solve([]): print i"], "original_ll": -1.6689385175704956, "sampled_ll": -0.7054641246795654, "all_perturbed_sampled_ll": [-1.5849429368972778], "all_perturbed_original_ll": [-2.5217249393463135], "perturbed_sampled_ll": -1.5849429368972778, "perturbed_original_ll": -2.5217249393463135, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define SQ(x) ((x) * (x))\n#define INF (100000000)\n#define EPS (1e-5)\n\ndouble len;\ndouble cake[12];\ndouble dp[1 << 12][12];\nint n;\n\ndouble min(double a, double b)\n{\n    return (b > a ? a : b);\n}\n\ndouble tsp(int bit, int now)\n{\n    int i;\n    double res;\n    \n    if (dp[bit][now] >= 0){\n        return (dp[bit][now]);\n    }\n    \n    if (bit == (1 << n) - 1 && now == 0){\n        return (dp[bit][now] = 0);\n    }\n    \n    res = INF;\n    for (i = 0; i < n; i++){\n        if (!((bit >> i) & 1)){\n            res = min(res, tsp(bit | (1 << i), i) + sqrt(SQ(cake[i] + cake[now]) - SQ(cake[i] - cake[now])));\n        }\n    }\n    \n    return (dp[bit][now] = res);\n}\n\nint main(void)\n{\n    int i, j;\n    \n    while (scanf(\"%lf\", &len) != EOF){\n        getchar();\n        n = 0;\n        while (1){\n            scanf(\"%lf\", &cake[n++]);\n            \n            if (getchar() == '\\n'){\n                break;\n            }\n        }\n        \n        for (i = 0; i < (1 << 12); i++){\n            for (j = 0; j < 12; j++){\n                dp[i][j] = -1 * INF;\n            }\n        }\n        \n        if (tsp(0, 0) < len + EPS){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\nint n;\nint r[12];\nint perm[12];\nint used[12];\ndouble W;\n\ndouble calc_width(int *order, int len) {\n    if (len == 0) return 0;\n    if (len == 1) return 2.0 * r[order[0]];\n    \n    double pos[12];\n    pos[0] = r[order[0]];\n    \n    for (int i = 1; i < len; i++) {\n        double max_pos = r[order[i]];\n        \n        for (int j = 0; j < i; j++) {\n            double ri = r[order[i]];\n            double rj = r[order[j]];\n            double d = 2.0 * sqrt(ri * rj);\n            double candidate = pos[j] + d;\n            if (candidate > max_pos) {\n                max_pos = candidate;\n            }\n        }\n        \n        pos[i] = max_pos;\n    }\n    \n    double max_right = 0;\n    for (int i = 0; i < len; i++) {\n        double right = pos[i] + r[order[i]];\n        if (right > max_right) {\n            max_right = right;\n        }\n    }\n    \n    return max_right;\n}\n\nint try_permutation(int depth) {\n    if (depth == n) {\n        double width = calc_width(perm, n);\n        return width <= W + 1e-9;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!used[i]) {\n            used[i] = 1;\n            perm[depth] = i;\n            if (try_permutation(depth + 1)) {\n                return 1;\n            }\n            used[i] = 0;\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    char line[1000];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        n = 0;\n        char *token = strtok(line, \" \\n\");\n        W = atof(token);\n        \n        while ((token = strtok(NULL, \" \\n\")) != NULL) {\n            r[n++] = atoi(token);\n        }\n        \n        if (n == 0) continue;\n        \n        memset(used, 0, sizeof(used));\n        \n        if (try_permutation(0)) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  perm[12]; int used[12];  == 0) return 0; if (len == 1) return 2.0 * r[order[0]]; double pos[12]; pos[0] = r[order[0]]; for (int i = 1; i < len; i++) { double max_pos = r[order[i]]; for (int j = 0; j < i; j++) { double ri = r[order[i]]; double rj = r[order[j]]; double d = 2.0 * sqrt(ri * rj); double candidate = pos[j] + d; if (candidate > max_pos) { max_pos = candidate; } } pos[i] = max_pos; } double max_right = 0; for  right = pos[i] + r[order[i]]; if (right > max_right) { max_right = right; } } return max_right; } int try_permutation(int depth) { if (depth == n) { double width = calc_width(perm,  i  used[i] = 1; perm[depth] = i; if (try_permutation(depth + 1)) { return 1; } used[i] = 0; } } return 0; } int main() { char line[1000]; while (fgets(line, sizeof(line), stdin)) { n = 0; char *token = strtok(line, \"  != NULL) { r[n++] = atoi(token); } if (n == 0) continue; memset(used, 0, sizeof(used)); if  0; }"], "perturbed_original": [" double cake[12]; double dp[1 << 12][12]; int n;  ? a : b); } double tsp(int bit, int now) { int i; double res; if (dp[bit][now] >= 0){ return (dp[bit][now]); } if (bit == (1 << n) - 1 && now == 0){ return (dp[bit][now] = 0); } res = INF; for (i = 0; i < n; i++){ if (!((bit >> i) & 1)){ res = min(res, tsp(bit |  - cake[now]))); } } return (dp[bit][now]  (scanf(\"%lf\", &len) != EOF){ getchar(); n = 0; while (1){ scanf(\"%lf\", &cake[n++]); if (getchar() == '\\n'){ break; } } for (i = 0; i < (1 << 12); i++){ for (j = 0; j < 12; j++){ dp[i][j] = -1 * INF; } } if (tsp(0, 0) < len + EPS){ printf(\"OK\\n\"); } else { printf(\"NA\\n\"); } } return (0); }"], "original_ll": -0.827989399433136, "sampled_ll": -0.6663442254066467, "all_perturbed_sampled_ll": [-1.4663447141647339], "all_perturbed_original_ll": [-1.4776735305786133], "perturbed_sampled_ll": -1.4663447141647339, "perturbed_original_ll": -1.4776735305786133, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tArrayList<String> Ans = new ArrayList<String>();\n\t\tString line;\n\n\t\twhile((line = in.readLine()) != null){\n\t\t\tString[] dst = line.split(\" \");\n\t\t\tint size = Integer.parseInt(dst[0]);\n\n\t\t\tif(size == 0) break;\n\t\t\tint[] seq = new int[dst.length-1];\n\t\t\tint[] radius = new int[dst.length-1];\n\t\t\tfor(int i=1; i<dst.length; i++){\n\t\t\t\tradius[i-1] = Integer.parseInt(dst[i]);\n\t\t\t}\n\n\t\t\tfor(int i=0; i<dst.length-1; i++){\n\t\t\t\tseq[i] = i;\n\t\t\t}\n\n\t\t\tint ok = 0;\n\t\t\tdo{\n//\t\t\t\tfor(int i=0; i<seq.length; i++){\n//\t\t\t\t\tSystem.out.print(seq[i]);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\n\t\t\t\tdouble cakes = calcSize(radius, seq);\n\t\t\t\tif(size >= cakes){\n\t\t\t\t\tAns.add(\"OK\");\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}while(nextArray(seq));\n\n\t\t\tif(ok == 0){\n\t\t\t\tAns.add(\"NA\");\n\t\t\t}\n\t\t}\n\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tSystem.out.println(Ans.get(n));\n\t\t}\n\t}\n\n\tpublic boolean nextArray(int[] seq){\n\t\tint s = seq.length-1;\n\t\twhile(true){\n\t\t\tif(seq[s] > seq[s-1]){\n\t\t\t\tint min = seq[s];\n\t\t\t\tint index = s;\n\t\t\t\tfor(int n=s+1; n<seq.length; n++){\n\t\t\t\t\tif(min > seq[n] && seq[n] > seq[s-1]){\n\t\t\t\t\t\tmin = seq[n];\n\t\t\t\t\t\tindex = n;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tseq[index] = seq[s-1];\n\t\t\t\tseq[s-1] = min;\n\t\t\t\tArrays.sort(seq, s, seq.length-1);\n\t\t\t\treturn true;\n\n\t\t\t}else{\n\t\t\t\ts--;\n\t\t\t}\n\n\t\t\tif(s == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic double calcSize(int[] data, int[] seq){\n\t\tdouble sum = 0.0;\n\t\t\n\t\t\n\t\treturn sum;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static double EPS = 1e-9;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) continue;\n            \n            String[] parts = line.split(\"\\\\s+\");\n            int W = Integer.parseInt(parts[0]);\n            \n            List<Integer> radii = new ArrayList<>();\n            for (int i = 1; i < parts.length; i++) {\n                radii.add(Integer.parseInt(parts[i]));\n            }\n            \n            int n = radii.size();\n            if (n == 0) {\n                System.out.println(\"OK\");\n                continue;\n            }\n            \n            boolean found = false;\n            int[] perm = new int[n];\n            for (int i = 0; i < n; i++) {\n                perm[i] = i;\n            }\n            \n            do {\n                double width = calculateWidth(radii, perm);\n                if (width <= W + EPS) {\n                    found = true;\n                    break;\n                }\n            } while (nextPermutation(perm));\n            \n            System.out.println(found ? \"OK\" : \"NA\");\n        }\n        \n        sc.close();\n    }\n    \n    static double calculateWidth(List<Integer> radii, int[] perm) {\n        int n = perm.length;\n        if (n == 0) return 0;\n        if (n == 1) return 2.0 * radii.get(perm[0]);\n        \n        double[] positions = new double[n];\n        positions[0] = radii.get(perm[0]);\n        \n        for (int i = 1; i < n; i++) {\n            double maxPos = radii.get(perm[i]);\n            \n            for (int j = 0; j < i; j++) {\n                double r1 = radii.get(perm[j]);\n                double r2 = radii.get(perm[i]);\n                double dist = 2.0 * Math.sqrt(r1 * r2);\n                double pos = positions[j] + dist;\n                maxPos = Math.max(maxPos, pos);\n            }\n            \n            positions[i] = maxPos;\n        }\n        \n        double minX = Double.MAX_VALUE;\n        double maxX = -Double.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            double r = radii.get(perm[i]);\n            minX = Math.min(minX, positions[i] - r);\n            maxX = Math.max(maxX, positions[i] + r);\n        }\n        \n        return maxX - minX;\n    }\n    \n    static boolean nextPermutation(int[] array) {\n        int i = array.length - 2;\n        while (i >= 0 && array[i] >= array[i + 1]) {\n            i--;\n        }\n        \n        if (i < 0) {\n            return false;\n        }\n        \n        int j = array.length - 1;\n        while (array[j] <= array[i]) {\n            j--;\n        }\n        \n        swap(array, i, j);\n        reverse(array, i + 1, array.length - 1);\n        \n        return true;\n    }\n    \n    static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    \n    static void reverse(int[] array, int start, int end) {\n        while (start < end) {\n            swap(array, start, end);\n            start++;\n            end--;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static double EPS = 1e-9; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String line = sc.nextLine().trim(); if (line.isEmpty()) continue; String[] parts = line.split(\"\\\\s+\"); int W = Integer.parseInt(parts[0]); List<Integer> radii = new ArrayList<>(); for (int i = 1; i < parts.length; i++) { radii.add(Integer.parseInt(parts[i])); } int n = radii.size(); if (n == 0) { System.out.println(\"OK\"); continue; } boolean found = false; int[] perm = new int[n]; for (int i = 0; i < n; i++) { perm[i] = i; } do { double width = calculateWidth(radii, perm); if (width <= W + EPS) { found = true; break; }  } static double calculateWidth(List<Integer> radii, int[] perm) { int n  == 1) return 2.0 * radii.get(perm[0]); double[] positions = new double[n]; positions[0] = radii.get(perm[0]); for (int i = 1; i < n; i++) { double maxPos = radii.get(perm[i]); for (int j = 0; j < i; j++) { double r1 = radii.get(perm[j]); double r2 =  } positions[i] =  for (int i = 0; i < n; i++) { double r = radii.get(perm[i]); minX = Math.min(minX, positions[i] - r); maxX = Math.max(maxX, positions[i] + r); } return maxX -  >= array[i + 1]) { i--; } if (i < 0) { return false; } int  array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } static void reverse(int[] array, int start, int end) { while (start < end) { swap(array, start, end); start++; end--; } } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static void main(String args[]){ try{ new Main(); }catch(IOException err){ err.printStackTrace(); } } public Main() throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); ArrayList<String> Ans = new ArrayList<String>(); String line;  int size = Integer.parseInt(dst[0]); if(size == 0) break; int[] seq = new int[dst.length-1]; int[] radius = new int[dst.length-1]; for(int i=1; i<dst.length; i++){ radius[i-1] = Integer.parseInt(dst[i]); } for(int i=0;   // System.out.println();  } } for(int n=0; n<Ans.size(); n++){ System.out.println(Ans.get(n)); } } public boolean nextArray(int[] seq){ int s = seq.length-1; while(true){ if(seq[s] > seq[s-1]){ int min = seq[s]; int index = s; for(int n=s+1; n<seq.length; n++){ if(min > seq[n] && seq[n] > seq[s-1]){ min = seq[n]; index = n; } } seq[index] = seq[s-1]; seq[s-1] = min; Arrays.sort(seq, s, seq.length-1); return true; }else{ s--; } if(s == 0){ return  double sum = 0.0; return sum; } }"], "original_ll": -0.9014003872871399, "sampled_ll": -0.4328192472457886, "all_perturbed_sampled_ll": [-1.0780915021896362], "all_perturbed_original_ll": [-1.3719931840896606], "perturbed_sampled_ll": -1.0780915021896362, "perturbed_original_ll": -1.3719931840896606, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0120\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\ndef calc_width(cakes):\n    # ??\u00b1????????????????????????(?????????)????????????????????????????????????????\u00a8??????????\n    if len(cakes) == 1:\n        return cakes[0]*2\n\n    prev_r = cakes[0]\n    width = prev_r\n\n    for r in cakes[1:]:\n        h_diff = abs(prev_r - r)\n        w = ((prev_r + r)**2 - h_diff**2)**0.5\n        width += w\n        prev_r = r\n    width += cakes[-1]\n\n    return width\n\n\ndef main(args):\n    for line in sys.stdin:\n        data = [int(x) for x in line.strip().split()]\n        box_size = data[0]\n        temp = data[1:]\n        temp.sort()\n\n        # ??\u00b1??????????????????????????????????????????????????????????????????????????????\n        min_width = float('inf')\n\n        cakes = [temp[0]]\n        temp = temp[1:]\n        pick_large = True\n        while temp:\n            if pick_large:\n                pick = temp[-1]\n                temp = temp[:-1]\n                pick_large = False\n                diff_front = abs(pick - cakes[0])\n                diff_rear = abs(pick - cakes[-1])\n                if diff_front > diff_rear:\n                    cakes.insert(0, pick)\n                else:\n                    cakes.append(pick)\n            else:\n                pick = temp[0]\n                temp = temp[1:]\n                pick_large = True\n                diff_front = abs(pick - cakes[0])\n                diff_rear = abs(pick - cakes[-1])\n                if diff_front > diff_rear:\n                    cakes.insert(0, pick)\n                else:\n                    cakes.append(pick)\n\n        result = calc_width(cakes)\n        min_width = min(result, min_width)\n\n        if min_width <= box_size:\n            print('OK')\n        else:\n            print('NA')\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    ", "sampled": "import sys\nimport math\nfrom itertools import permutations\n\ndef calc_distance(r1, r2):\n    # Distance between centers of two circles touching each other and both touching the bottom\n    return 2 * math.sqrt(r1 * r2)\n\ndef calc_width(radii):\n    if len(radii) == 0:\n        return 0\n    if len(radii) == 1:\n        return 2 * radii[0]\n    \n    # Position circles one by one\n    positions = [radii[0]]  # x-coordinate of center of each circle\n    \n    for i in range(1, len(radii)):\n        # Find the rightmost position where circle i can be placed\n        min_x = radii[i]  # At least this far from left wall\n        \n        for j in range(i):\n            # Must be at least calc_distance away from circle j\n            required_dist = calc_distance(radii[i], radii[j])\n            min_x = max(min_x, positions[j] + required_dist)\n        \n        positions.append(min_x)\n    \n    # Total width is rightmost position + its radius\n    return positions[-1] + radii[-1]\n\ndef solve(W, radii):\n    n = len(radii)\n    \n    if n == 0:\n        return \"OK\"\n    \n    # Try all permutations\n    for perm in permutations(radii):\n        width = calc_width(list(perm))\n        if width <= W:\n            return \"OK\"\n    \n    return \"NA\"\n\nfor line in sys.stdin:\n    parts = list(map(int, line.strip().split()))\n    W = parts[0]\n    radii = parts[1:]\n    print(solve(W, radii))\n", "perturbed_sampled": ["import sys import math from itertools import permutations def calc_distance(r1, r2): # Distance between centers of two circles touching each other and both touching the bottom return 2 * math.sqrt(r1 * r2) def calc_width(radii): if len(radii) == 0: return 0 if len(radii) == 1: return 2 * radii[0] # Position circles one by one positions  i in range(1, len(radii)): # Find the rightmost position where circle i  far from left wall for j in range(i): # Must  calc_distance(radii[i], radii[j]) min_x = max(min_x, positions[j] + required_dist) positions.append(min_x) # Total width is rightmost position  n = len(radii) if n == 0: return \"OK\" # Try all permutations for perm in permutations(radii): width = calc_width(list(perm)) if  sys.stdin: parts = list(map(int, line.strip().split())) W = parts[0] radii = parts[1:] print(solve(W, radii))"], "perturbed_original": ["# -*- coding: utf-8 -*- \"\"\" http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0120 \"\"\" import  = cakes[0] width = prev_r for r in cakes[1:]: h_diff = abs(prev_r - r) w = ((prev_r + r)**2 - h_diff**2)**0.5 width += w prev_r = r width += cakes[-1] return width def main(args): for line in sys.stdin: data = [int(x) for x in line.strip().split()] box_size = data[0] temp = data[1:] temp.sort() # ??\u00b1?????????????????????????????????????????????????????????????????????????????? min_width =  while temp: if pick_large: pick =  - cakes[0]) diff_rear = abs(pick - cakes[-1]) if diff_front > diff_rear: cakes.insert(0, pick) else: cakes.append(pick) else: pick = temp[0] temp = temp[1:] pick_large = True diff_front = abs(pick - cakes[0]) diff_rear = abs(pick - cakes[-1]) if diff_front >  min(result, min_width) if min_width <= box_size: print('OK') else: print('NA') if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -1.0922144651412964, "sampled_ll": -1.2865324020385742, "all_perturbed_sampled_ll": [-2.3599092960357666], "all_perturbed_original_ll": [-1.9638280868530273], "perturbed_sampled_ll": -2.3599092960357666, "perturbed_original_ll": -1.9638280868530273, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<cstdlib>\n\nusing namespace std;\n\n#define maxn 305\n\nint map[3][5];\n\nint main()\n{\n\tint i,j;\ncin>>i;\ncout<<1<<endl;\n\n\n\treturn 0;\n}\n\n", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_STATES 362880\n\ntypedef struct {\n    int state[8];\n    int dist;\n} Node;\n\nint visited[MAX_STATES];\nNode queue[MAX_STATES];\nint front, rear;\n\nint encode(int state[8]) {\n    int code = 0;\n    int base = 1;\n    for (int i = 7; i >= 0; i--) {\n        int digit = state[i];\n        for (int j = i + 1; j < 8; j++) {\n            if (state[j] < state[i]) digit--;\n        }\n        code += digit * base;\n        base *= (8 - i);\n    }\n    return code;\n}\n\nint bfs(int start[8]) {\n    memset(visited, -1, sizeof(visited));\n    front = rear = 0;\n    \n    memcpy(queue[rear].state, start, sizeof(int) * 8);\n    queue[rear].dist = 0;\n    rear++;\n    \n    int start_code = encode(start);\n    visited[start_code] = 0;\n    \n    int goal[8] = {0, 1, 2, 3, 4, 5, 6, 7};\n    int goal_code = encode(goal);\n    \n    if (start_code == goal_code) return 0;\n    \n    while (front < rear) {\n        Node current = queue[front++];\n        \n        int pos0 = -1;\n        for (int i = 0; i < 8; i++) {\n            if (current.state[i] == 0) {\n                pos0 = i;\n                break;\n            }\n        }\n        \n        int row = pos0 / 4;\n        int col = pos0 % 4;\n        \n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n        \n        for (int d = 0; d < 4; d++) {\n            int new_row = row + dr[d];\n            int new_col = col + dc[d];\n            \n            if (new_row >= 0 && new_row < 2 && new_col >= 0 && new_col < 4) {\n                int new_pos = new_row * 4 + new_col;\n                \n                int new_state[8];\n                memcpy(new_state, current.state, sizeof(int) * 8);\n                \n                int temp = new_state[pos0];\n                new_state[pos0] = new_state[new_pos];\n                new_state[new_pos] = temp;\n                \n                int new_code = encode(new_state);\n                \n                if (visited[new_code] == -1) {\n                    visited[new_code] = current.dist + 1;\n                    \n                    if (new_code == goal_code) {\n                        return current.dist + 1;\n                    }\n                    \n                    memcpy(queue[rear].state, new_state, sizeof(int) * 8);\n                    queue[rear].dist = current.dist + 1;\n                    rear++;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int state[8];\n    \n    while (scanf(\"%d\", &state[0]) == 1) {\n        for (int i = 1; i < 8; i++) {\n            scanf(\"%d\", &state[i]);\n        }\n        \n        int result = bfs(state);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  state[8]; int dist; } Node; int visited[MAX_STATES];  code = 0; int base = 1; for (int i = 7; i >= 0; i--) { int digit = state[i]; for (int j = i + 1; j < 8; j++) { if (state[j] < state[i]) digit--; } code += digit * base; base *= (8 - i); } return code;  rear = 0; memcpy(queue[rear].state,  1, 2, 3, 4, 5, 6, 7}; int goal_code = encode(goal); if (start_code == goal_code) return 0; while (front < rear) { Node current = queue[front++]; int pos0 = -1; for (int i = 0; i < 8; i++) { if (current.state[i] == 0) { pos0 = i; break; } } int row = pos0 / 4; int col = pos0 % 4; int dr[] = {-1, 1, 0, 0};  = 0; d < 4; d++)  col + dc[d]; if (new_row >= 0 && new_row < 2 && new_col  new_row * 4 + new_col; int new_state[8]; memcpy(new_state, current.state, sizeof(int) * 8); int temp = new_state[pos0]; new_state[pos0] = new_state[new_pos]; new_state[new_pos] = temp; int new_code = encode(new_state); if (visited[new_code] == -1) { visited[new_code] = current.dist + 1; if (new_code  sizeof(int) * 8); queue[rear].dist = current.dist + 1; rear++; } } } } return -1; } int main() { int state[8]; while (scanf(\"%d\", &state[0]) == 1) { for (int i = 1; i < 8; i++) { scanf(\"%d\", &state[i]); } int result = bfs(state); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#include<iostream> #include<cstdio> #include<queue> #include<algorithm> #include<string> #include<vector> #include<cstdlib> using namespace std; #define maxn 305 int map[3][5]; int main() { int i,j; cin>>i; cout<<1<<endl; return 0; }"], "original_ll": -1.7629609107971191, "sampled_ll": -0.5100234746932983, "all_perturbed_sampled_ll": [-1.3702200651168823], "all_perturbed_original_ll": [-1.545383095741272], "perturbed_sampled_ll": -1.3702200651168823, "perturbed_original_ll": -1.545383095741272, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\n\tvoid run() {\n\t\tHashMap<ArrayList<Integer>, Integer> hm = new HashMap<ArrayList<Integer>, Integer>();\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tint cnt = 0;\n\t\thm.put(list, cnt);\n\n\t\tLinkedList<ArrayList<Integer>> queue = new LinkedList<ArrayList<Integer>>();\n\t\tqueue.add(list);\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint size = queue.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tArrayList<Integer> l = queue.poll();\n\t\t\t\tint zeroIndex = 0;\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (l.get(j) == 0) {\n\t\t\t\t\t\tzeroIndex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (zeroIndex - 1 >= 0 && zeroIndex != 4) {\n\t\t\t\t\tArrayList<Integer> add = new ArrayList<Integer>(l);\n\t\t\t\t\tint t = l.get(zeroIndex);\n\t\t\t\t\tint r = l.get(zeroIndex - 1);\n\t\t\t\t\tadd.set(zeroIndex, r);\n\t\t\t\t\tadd.set(zeroIndex - 1, t);\n\t\t\t\t\tif (!hm.containsKey(add)) {\n\t\t\t\t\t\thm.put(add, cnt + 1);\n\t\t\t\t\t\tqueue.add(add);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (zeroIndex + 1 < 8 && zeroIndex != 3) {\n\t\t\t\t\tArrayList<Integer> add = new ArrayList<Integer>(l);\n\t\t\t\t\tint t = l.get(zeroIndex);\n\t\t\t\t\tint r = l.get(zeroIndex + 1);\n\t\t\t\t\tadd.set(zeroIndex, r);\n\t\t\t\t\tadd.set(zeroIndex + 1, t);\n\t\t\t\t\tif (!hm.containsKey(add)) {\n\t\t\t\t\t\thm.put(add, cnt + 1);\n\t\t\t\t\t\tqueue.add(add);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrayList<Integer> add = new ArrayList<Integer>(l);\n\t\t\t\tint t = l.get(zeroIndex);\n\t\t\t\tint r = l.get((zeroIndex + 4) % 8);\n\t\t\t\tadd.set(zeroIndex, r);\n\t\t\t\tadd.set((zeroIndex + 4) % 8, t);\n\t\t\t\tif (!hm.containsKey(add)) {\n\t\t\t\t\thm.put(add, cnt + 1);\n\t\t\t\t\tqueue.add(add);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\twhile (sc2.hasNext()) {\n\t\t\tString input[] = sc2.nextLine().split(\" \");\n\t\t\tArrayList<Integer> in = new ArrayList<Integer>();\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tin.add(Integer.valueOf(input[i]));\n\t\t\t}\n\t\t\tSystem.out.println(hm.get(in));\n\t\t}\n\t}\n\n\tboolean check(ArrayList<Integer> list) {\n\t\tboolean judge = true;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif (list.get(i) != i) {\n\t\t\t\tjudge = false;\n\t\t\t}\n\t\t}\n\t\treturn judge;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static final int[] TARGET = {0, 1, 2, 3, 4, 5, 6, 7};\n    static final int[][] MOVES = {{1}, {0, 2}, {1, 3}, {2}, {5}, {4, 6}, {5, 7}, {6}};\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\"\\\\s+\");\n            int[] initial = new int[8];\n            for (int i = 0; i < 8; i++) {\n                initial[i] = Integer.parseInt(parts[i]);\n            }\n            \n            System.out.println(bfs(initial));\n        }\n        sc.close();\n    }\n    \n    static int bfs(int[] initial) {\n        if (Arrays.equals(initial, TARGET)) {\n            return 0;\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        State start = new State(initial, 0);\n        queue.offer(start);\n        visited.add(stateToString(initial));\n        \n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            \n            int zeroPos = -1;\n            for (int i = 0; i < 8; i++) {\n                if (current.board[i] == 0) {\n                    zeroPos = i;\n                    break;\n                }\n            }\n            \n            for (int nextPos : MOVES[zeroPos]) {\n                int[] newBoard = current.board.clone();\n                newBoard[zeroPos] = newBoard[nextPos];\n                newBoard[nextPos] = 0;\n                \n                if (Arrays.equals(newBoard, TARGET)) {\n                    return current.moves + 1;\n                }\n                \n                String stateStr = stateToString(newBoard);\n                if (!visited.contains(stateStr)) {\n                    visited.add(stateStr);\n                    queue.offer(new State(newBoard, current.moves + 1));\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static String stateToString(int[] board) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 8; i++) {\n            sb.append(board[i]);\n        }\n        return sb.toString();\n    }\n    \n    static class State {\n        int[] board;\n        int moves;\n        \n        State(int[] board, int moves) {\n            this.board = board;\n            this.moves = moves;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static final int[] TARGET =  int[][] MOVES = {{1},  {6}}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String line = sc.nextLine().trim(); if (line.isEmpty()) break; String[] parts = line.split(\"\\\\s+\"); int[] initial = new int[8]; for (int i = 0; i < 8; i++) { initial[i] =  { if (Arrays.equals(initial, TARGET)) { return 0; } Queue<State> queue = new LinkedList<>(); Set<String> visited = new HashSet<>(); State start = new State(initial, 0); queue.offer(start); visited.add(stateToString(initial)); while (!queue.isEmpty()) { State current = queue.poll(); int zeroPos = -1; for (int i = 0;  zeroPos = i; break; } } for (int nextPos :  = 0; if (Arrays.equals(newBoard, TARGET)) { return current.moves + 1; } String stateStr =  } } } return -1; } static String stateToString(int[] board) { StringBuilder sb = new StringBuilder(); for  } return sb.toString(); } static class State { int[] board; int moves; State(int[] board, int moves) { this.board = board; this.moves = moves; } } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedList; import java.util.Scanner; public class Main { MyScanner sc = new MyScanner(); Scanner  = new HashMap<ArrayList<Integer>, Integer>(); ArrayList<Integer> list = new ArrayList<Integer>(); for (int i = 0; i < 8; i++) { list.add(i); } int cnt = 0; hm.put(list,  int size = queue.size(); for (int i = 0; i < size; i++) { ArrayList<Integer> l = queue.poll(); int zeroIndex  j++) { if (l.get(j) == 0) { zeroIndex = j; } } if (zeroIndex - 1  l.get(zeroIndex - 1); add.set(zeroIndex, r); add.set(zeroIndex - 1, t); if (!hm.containsKey(add)) { hm.put(add, cnt + 1); queue.add(add); } } if (zeroIndex + 1 < 8 && zeroIndex != 3) { ArrayList<Integer> add = new ArrayList<Integer>(l); int t = l.get(zeroIndex); int r = l.get(zeroIndex + 1); add.set(zeroIndex, r); add.set(zeroIndex + 1,  } ArrayList<Integer> add = new ArrayList<Integer>(l); int t = l.get(zeroIndex); int r = l.get((zeroIndex + 4) % 8); add.set(zeroIndex, r); add.set((zeroIndex + 4) % 8, t); if (!hm.containsKey(add)) { hm.put(add, cnt + 1); queue.add(add); } } cnt++; } while (sc2.hasNext()) { String input[] = sc2.nextLine().split(\" \"); ArrayList<Integer> in = new ArrayList<Integer>(); for (int i = 0; i < 8; i++) { in.add(Integer.valueOf(input[i])); } System.out.println(hm.get(in)); } } boolean check(ArrayList<Integer> list) { boolean judge = true; for (int i = 0; i < 8; i++) { if (list.get(i)  } void debug(Object... o) {  0; i < array.length; i++) { for (int j = 0; j < array[i].length; j++) { System.out.print(array[i][j]); } System.out.println(); } } class MyScanner { int nextInt() { try { int c = System.in.read(); while (c != '-' && (c < '0' || '9' < c)) c = System.in.read(); if (c == '-') return -nextInt(); int res  - '0'; c = System.in.read(); } while ('0' <= c && c <= '9'); return res; }  { return Double.parseDouble(next()); } String next() { try { StringBuilder res = new StringBuilder(\"\");  { res.append((char) c); } while (!Character.isWhitespace(c = System.in.read())); return  } }"], "original_ll": -0.5006299018859863, "sampled_ll": -0.4328977167606354, "all_perturbed_sampled_ll": [-1.493762731552124], "all_perturbed_original_ll": [-1.222896695137024], "perturbed_sampled_ll": -1.493762731552124, "perturbed_original_ll": -1.222896695137024, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import deque\n\ndic = {}\ndic[(0,1,2,3,4,5,6,7)] = 0\n\n\nswap_dic = {0:(1, 4), 1:(0, 2, 5), 2:(1, 3, 6), 3:(2, 7),\n            4:(0, 5), 5:(1, 4, 6), 6:(2, 5, 7), 7:(3, 6)}\n\ndef swap(puz, i, j):\n  new = [k for k in puz]\n  new[i], new[j] = new[j], new[i]\n  return tuple(new)\n\nque = deque()\nque.append((0, (0,1,2,3,4,5,6,7)))\nwhile que:\n  score, puz = que.popleft()\n  score += 1\n  z_ind = puz.index(0)\n\n  for swap_ind in swap_dic[z_ind]:\n    new_puz = swap(puz, z_ind, swap_ind)\n    if not new_puz in dic:\n      dic[new_puz] = score\n      que.append((score, new_puz))\n\nwhile True:\n  try:\n    print(dic[tuple(map(int, input().split()))])\n  except EOFError:\n    break\n", "sampled": "from collections import deque\nimport sys\n\ndef solve(start):\n    goal = tuple(range(8))\n    if start == goal:\n        return 0\n    \n    visited = {start}\n    queue = deque([(start, 0)])\n    \n    while queue:\n        state, dist = queue.popleft()\n        \n        # Find position of 0\n        pos = state.index(0)\n        row = pos // 4\n        col = pos % 4\n        \n        # Try all 4 directions\n        moves = []\n        if col > 0:  # left\n            moves.append(pos - 1)\n        if col < 3:  # right\n            moves.append(pos + 1)\n        if row > 0:  # up\n            moves.append(pos - 4)\n        if row < 1:  # down\n            moves.append(pos + 4)\n        \n        for new_pos in moves:\n            new_state = list(state)\n            new_state[pos], new_state[new_pos] = new_state[new_pos], new_state[pos]\n            new_state = tuple(new_state)\n            \n            if new_state == goal:\n                return dist + 1\n            \n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, dist + 1))\n    \n    return -1\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        nums = tuple(map(int, line.split()))\n        print(solve(nums))\n", "perturbed_sampled": ["from collections import deque import sys def solve(start): goal = tuple(range(8)) if start == goal: return 0 visited = {start} queue = deque([(start, 0)]) while queue: state, dist  row = pos // 4 col = pos % 4 # Try all 4 directions moves = [] if col > 0: # left moves.append(pos - 1) if col < 3: # right moves.append(pos +  if row < 1: # down moves.append(pos + 4) for new_pos in moves: new_state = list(state) new_state[pos], new_state[new_pos] = new_state[new_pos],  + 1  return -1 for line in sys.stdin: line = line.strip() if line: nums = tuple(map(int, line.split())) print(solve(nums))"], "perturbed_original": ["from collections import deque dic = {} dic[(0,1,2,3,4,5,6,7)] = 0 swap_dic = {0:(1, 4), 1:(0, 2, 5), 2:(1, 3, 6), 3:(2, 7), 4:(0, 5), 5:(1, 4, 6), 6:(2, 5, 7), 7:(3, 6)} def swap(puz,  new[j] = new[j], new[i]  puz = que.popleft() score += 1 z_ind = puz.index(0) for swap_ind in swap_dic[z_ind]: new_puz = swap(puz, z_ind, swap_ind) if not new_puz in dic: dic[new_puz] = score que.append((score, new_puz)) while True: try: print(dic[tuple(map(int, input().split()))]) except EOFError: break"], "original_ll": -0.92852383852005, "sampled_ll": -0.6551464200019836, "all_perturbed_sampled_ll": [-2.1050024032592773], "all_perturbed_original_ll": [-1.541310429573059], "perturbed_sampled_ll": -2.1050024032592773, "perturbed_original_ll": -1.541310429573059, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>          // printf(), scanf()\n#include <stdbool.h>\n\n#define MAX_N 10\n#define MAX_M 10\n#define MAX_G 9\n\nint sx, sy;\nint n;\nint scx[MAX_N], scy[MAX_N];\n\nbool\nb_survival()\n{\n\tbool field[MAX_M][MAX_M];\n\tint px[MAX_G], py[MAX_G];\n\tstatic const int dx2[12] = {-1, 0, 1, 2, 2, 2,-1, 0, 1,-2,-2,-2};\n\tstatic const int dy2[12] = {-2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1};\n\n\tint ix = 0;\n\tpx[ix] = sx, py[ix] = sy;\n\tix++;\n\n\tfor (int u = 0; u < n; ++u)\n\t{\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = scx[u] + dx, ny = scy[u] + dy;\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)\n\t\t\t\t\tfield[ny][nx] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 12; ++j)\n\t\t\t{\n\t\t\t\tint nx = px[i] + dx2[j], ny = py[i] + dy2[j];\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)\n\t\t\t\t\tfield[ny][nx] = true;\n\t\t\t}\n\t\t}\n\n\t\tix = 0;\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = scx[u] + dx, ny = scy[u] + dy;\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M && field[ny][nx])\n\t\t\t\t{\n\t\t\t\t\tpx[ix] = nx;\n\t\t\t\t\tpy[ix] = ny;\n\t\t\t\t\tix++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ix == 0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint lineno = 0;\n\twhile (true)\n\t{\n\t\tlineno++;\n\t\tscanf(\"%d%d\", &sx, &sy);\n\t\tif (sx == 0 && sy == 0)\n\t\t\tbreak;\n\n\t\tlineno++;\n\t\tscanf(\"%d\", &n);\n\n\t\tlineno++;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tscanf(\"%d%d\", &scx[i], &scy[i]);\n\n\t\tprintf(\"%s\\n\", b_survival() ? \"OK\" : \"NA\");\n\t}\n\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint can_reach(int fx, int fy, int sx, int sy) {\n    int dx = abs(fx - sx);\n    int dy = abs(fy - sy);\n    \n    if ((dx == 2 && dy == 2) || (dx == 0 && dy == 3) || (dx == 3 && dy == 0)) {\n        return 1;\n    }\n    return 0;\n}\n\nint in_spray(int x, int y, int sx, int sy) {\n    int dx = abs(x - sx);\n    int dy = abs(y - sy);\n    \n    if (dx <= 1 && dy <= 1) {\n        return 1;\n    }\n    return 0;\n}\n\nint in_bounds(int x, int y) {\n    return x >= 0 && x <= 9 && y >= 0 && y <= 9;\n}\n\nint solve(int px, int py, int n, int sx[], int sy[]) {\n    int possible[10][10];\n    int next_possible[10][10];\n    \n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            possible[i][j] = 0;\n        }\n    }\n    \n    for (int x = 0; x < 10; x++) {\n        for (int y = 0; y < 10; y++) {\n            if (can_reach(px, py, x, y) && in_bounds(x, y) && in_spray(x, y, sx[0], sy[0])) {\n                possible[x][y] = 1;\n            }\n        }\n    }\n    \n    for (int i = 1; i < n; i++) {\n        for (int x = 0; x < 10; x++) {\n            for (int y = 0; y < 10; y++) {\n                next_possible[x][y] = 0;\n            }\n        }\n        \n        for (int fx = 0; fx < 10; fx++) {\n            for (int fy = 0; fy < 10; fy++) {\n                if (possible[fx][fy]) {\n                    for (int tx = 0; tx < 10; tx++) {\n                        for (int ty = 0; ty < 10; ty++) {\n                            if (can_reach(fx, fy, tx, ty) && in_bounds(tx, ty) && in_spray(tx, ty, sx[i], sy[i])) {\n                                next_possible[tx][ty] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (int x = 0; x < 10; x++) {\n            for (int y = 0; y < 10; y++) {\n                possible[x][y] = next_possible[x][y];\n            }\n        }\n    }\n    \n    for (int x = 0; x < 10; x++) {\n        for (int y = 0; y < 10; y++) {\n            if (possible[x][y]) {\n                return 1;\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int px, py;\n    \n    while (scanf(\"%d %d\", &px, &py) == 2) {\n        if (px == 0 && py == 0) {\n            break;\n        }\n        \n        int n;\n        scanf(\"%d\", &n);\n        \n        int sx[10], sy[10];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &sx[i], &sy[i]);\n        }\n        \n        if (solve(px, py, n, sx, sy)) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int can_reach(int fx, int fy, int sx, int sy) { int  sy); if ((dx == 2 && dy == 2) || (dx == 0 && dy == 3) || (dx == 3 && dy == 0)) { return 1; } return 0; } int in_spray(int x, int y, int sx, int sy) { int dx = abs(x - sx);  && dy <= 1) { return 1; } return 0; } int in_bounds(int  <= 9 && y >= 0 && y <= 9; } int solve(int px, int py, int n,  (int i = 0; i < 10; i++) { for (int j = 0; j  (int x = 0; x < 10; x++) { for (int y = 0; y < 10; y++) { if (can_reach(px, py, x, y) && in_bounds(x, y) && in_spray(x, y, sx[0], sy[0])) { possible[x][y] = 1; } } } for (int i = 1; i < n; i++) { for (int x = 0; x < 10; x++) { for (int y = 0; y < 10; y++) { next_possible[x][y] = 0; } } for (int fx = 0; fx < 10; fx++) { for (int fy = 0; fy  ty = 0; ty < 10; ty++) { if (can_reach(fx, fy, tx, ty) && in_bounds(tx, ty) && in_spray(tx, ty, sx[i], sy[i])) { next_possible[tx][ty] = 1; } } } } } } for (int x = 0; x < 10; x++) { for (int y = 0; y < 10; y++) { possible[x][y] = next_possible[x][y]; } } } for (int x =  0; y < 10; y++) { if  int main() { int px, py; while (scanf(\"%d %d\", &px, &py) == 2) { if (px == 0 && py ==  i++) { scanf(\"%d %d\", &sx[i],  } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> // printf(), scanf() #include <stdbool.h> #define MAX_N 10 #define MAX_M 10 #define MAX_G 9 int sx, sy; int n; int scx[MAX_N], scy[MAX_N]; bool b_survival() { bool field[MAX_M][MAX_M]; int px[MAX_G], py[MAX_G]; static const int dx2[12] = {-1, 0, 1, 2, 2, 2,-1, 0, 1,-2,-2,-2}; static const int dy2[12] = {-2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1}; int ix = 0; px[ix] = sx, py[ix] = sy; ix++; for (int u = 0; u < n; ++u) { for (int dy = -1; dy <= 1; ++dy) { for (int dx = -1; dx <= 1; ++dx) { int nx = scx[u] + dx, ny   field[ny][nx] = false; } } for (int i = 0; i < ix; ++i) { for (int j = 0; j <  = py[i] + dy2[j]; if (0 <= nx && nx < MAX_M && 0  } ix = 0; for (int dy = -1; dy <= 1; ++dy) { for (int dx = -1; dx <= 1; ++dx) {  dy; if (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M && field[ny][nx]) {  if (ix == 0) return false; } return true; } int main(int  { lineno++; scanf(\"%d%d\", &sx, &sy); if  n; ++i) scanf(\"%d%d\", &scx[i], &scy[i]); printf(\"%s\\n\", b_survival() ? \"OK\" : \"NA\"); } return 0; }"], "original_ll": -0.6900525093078613, "sampled_ll": -0.36025571823120117, "all_perturbed_sampled_ll": [-1.0113492012023926], "all_perturbed_original_ll": [-1.3615808486938477], "perturbed_sampled_ll": -1.0113492012023926, "perturbed_original_ll": -1.3615808486938477, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] fy = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 };\n\tstatic int[] fx = { -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint kx = scanner.nextInt();\n\t\t\tint ky = scanner.nextInt();\n\t\t\tif (ky == 0 && kx == 0)\n\t\t\t\tbreak;\n\t\t\tint n = scanner.nextInt();\n\t\t\tint[][] num = new int[n][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tnum[i][0] = scanner.nextInt();\n\t\t\t\tnum[i][1] = scanner.nextInt();\n\t\t\t}\n\t\t\tDeque<int[]> deque = new ArrayDeque<int[]>();\n\t\t\tdeque.offer(new int[] { ky, kx });\n\t\t\tboolean flag = true;\n\t\t\tloop: for (int i = 0; i < n; i++) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tDeque<int[]> dequetmp = new ArrayDeque<int[]>();\n\t\t\t\twhile (size-- > 0) {\n\t\t\t\t\tint[] m = deque.pop();\n\t\t\t\t\tslove(m, num[i], dequetmp);\n\t\t\t\t}\n\t\t\t\tif (dequetmp.isEmpty()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t\tdeque = dequetmp;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"OK\" : \"NA\");\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[] m, int[] num, Deque<int[]> dequetmp) {\n\t\tboolean[][] map = new boolean[14][14];\n\t\tfor (int i = 1; i < 4; i++) {\n\t\t\tfor (int j = 1; j < 4; j++) {\n\t\t\t\tint y = num[1] + i;\n\t\t\t\tint x = num[0] + j;\n\t\t\t\tif (2 <= y && y <= 12 && 2 <= x && x <= 12)\n\t\t\t\t\tmap[y][x] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < fy.length; i++) {\n\t\t\tint py = m[0] + fy[i] + 2;\n\t\t\tint px = m[1] + fx[i] + 2;\n\t\t\tif (map[py][px]) {\n\t\t\t\tpy -= 2;\n\t\t\t\tpx -= 2;\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor (int[] t : dequetmp) {\n\t\t\t\t\tif (t[0] == py && t[1] == px) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tdequetmp.push(new int[] { py, px });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[][] jumpOffsets = {\n        {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2},\n        {1, -2}, {1, 2}, {2, -1}, {2, 1}\n    };\n    \n    static int[][] waterOffsets = {\n        {-1, -1}, {-1, 0}, {-1, 1},\n        {0, -1}, {0, 0}, {0, 1},\n        {1, -1}, {1, 0}, {1, 1}\n    };\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int px = sc.nextInt();\n            int py = sc.nextInt();\n            \n            if (px == 0 && py == 0) break;\n            \n            int n = sc.nextInt();\n            int[][] sprinklers = new int[n][2];\n            \n            for (int i = 0; i < n; i++) {\n                sprinklers[i][0] = sc.nextInt();\n                sprinklers[i][1] = sc.nextInt();\n            }\n            \n            if (canSurvive(px, py, sprinklers)) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static boolean canSurvive(int px, int py, int[][] sprinklers) {\n        Set<String> currentPositions = new HashSet<>();\n        currentPositions.add(px + \",\" + py);\n        \n        for (int i = 0; i < sprinklers.length; i++) {\n            int sx = sprinklers[i][0];\n            int sy = sprinklers[i][1];\n            \n            Set<String> nextPositions = new HashSet<>();\n            \n            for (String posStr : currentPositions) {\n                String[] parts = posStr.split(\",\");\n                int x = Integer.parseInt(parts[0]);\n                int y = Integer.parseInt(parts[1]);\n                \n                for (int[] offset : jumpOffsets) {\n                    int nx = x + offset[0];\n                    int ny = y + offset[1];\n                    \n                    if (nx >= 0 && nx <= 9 && ny >= 0 && ny <= 9) {\n                        if (isInWaterRange(nx, ny, sx, sy)) {\n                            nextPositions.add(nx + \",\" + ny);\n                        }\n                    }\n                }\n            }\n            \n            if (nextPositions.isEmpty()) {\n                return false;\n            }\n            \n            currentPositions = nextPositions;\n        }\n        \n        return true;\n    }\n    \n    static boolean isInWaterRange(int x, int y, int sx, int sy) {\n        for (int[] offset : waterOffsets) {\n            if (sx + offset[0] == x && sy + offset[1] == y) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import  {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1},  {-1, 0}, {-1, 1}, {0, -1}, {0, 0}, {0, 1}, {1, -1}, {1, 0}, {1, 1}  new Scanner(System.in); while (true) { int px = sc.nextInt(); int py = sc.nextInt(); if (px == 0 && py == 0) break; int n = sc.nextInt(); int[][] sprinklers = new int[n][2]; for (int i = 0; i < n; i++) { sprinklers[i][0] = sc.nextInt(); sprinklers[i][1] = sc.nextInt(); } if (canSurvive(px, py, sprinklers)) { System.out.println(\"OK\"); } else { System.out.println(\"NA\"); } } sc.close(); } static boolean canSurvive(int px, int py,  \",\" + py); for (int i = 0; i < sprinklers.length; i++) { int  parts = posStr.split(\",\"); int x = Integer.parseInt(parts[0]); int y = Integer.parseInt(parts[1]); for (int[] offset : jumpOffsets) { int nx = x + offset[0]; int ny = y + offset[1]; if (nx >= 0 && nx <= 9 && ny >= 0 && ny <= 9) { if (isInWaterRange(nx, ny, sx, sy)) { nextPositions.add(nx + \",\" + ny); } } } } if (nextPositions.isEmpty()) { return  boolean isInWaterRange(int x, int y, int sx, int sy) { for (int[] offset : waterOffsets) { if (sx + offset[0]  true; } } return false; } }"], "perturbed_original": ["import java.util.ArrayDeque; import java.util.Deque; import java.util.Scanner; public class Main { static int[] fy = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 }; static int[] fx = { -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1 }; public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (true) { int kx  && kx == 0) break; int n = scanner.nextInt(); int[][]  < n; i++) { num[i][0] = scanner.nextInt(); num[i][1] = scanner.nextInt(); } Deque<int[]> deque = new ArrayDeque<int[]>(); deque.offer(new int[] { ky, kx }); boolean flag = true; loop: for (int  = deque.size(); Deque<int[]>  m = deque.pop(); slove(m, num[i], dequetmp); } if (dequetmp.isEmpty()) { flag = false; break loop; } deque = dequetmp; } System.out.println(flag ? \"OK\" : \"NA\"); } } private static  = new boolean[14][14]; for (int i = 1; i < 4; i++)  { int y = num[1] + i; int x = num[0] + j;  <= x && x <= 12) map[y][x] = true; } } for (int i = 0; i < fy.length; i++) { int py = m[0] + fy[i] + 2;  { py -= 2; px -= 2; boolean  (t[0] == py && t[1] == px) { flag = false; break; } } if (flag) { dequetmp.push(new int[] { py, px }); } } } } }"], "original_ll": -0.6362054347991943, "sampled_ll": -0.43334752321243286, "all_perturbed_sampled_ll": [-1.0972306728363037], "all_perturbed_original_ll": [-1.5037553310394287], "perturbed_sampled_ll": -1.0972306728363037, "perturbed_original_ll": -1.5037553310394287, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "R1=range(-2,3)\nR2=range(-1,2)\nA1=[(x,y) for x in R1 for y in R1 if 3<x**2+y**2<6]\nA2=[(x,y) for x in R2 for y in R2]\ndef fi(): return map(int,raw_input().split(\" \"))\ndef f(p,i):\n  x,y=p\n  A=[A1,A2][i>0]\n  return set([(x+dx,y+dy) for dx,dy in A if 0<=x+dx<10 and 0<=y+dy<10])\n\nwhile 1:\n  xf,yf=fi()\n  if yf==xf==0: break\n  raw_input()\n  tmp=fi()\n  PA=zip(tmp[0::2],tmp[1::2])\n  FA=set([(xf,yf)])\n  for ps in PA:\n    SA=f(ps,1)\n    tmp=set([])\n    for pf in FA: tmp=tmp|(SA&f(pf,0))\n    FA=tmp\n  print [\"NA\",\"OK\"][len(FA)>0]", "sampled": "import sys\nfrom collections import deque\n\ndef get_jump_positions(x, y):\n    \"\"\"Returns all valid positions that can be reached from (x, y) with one jump\"\"\"\n    jumps = [\n        (-2, -1), (-2, 1), (2, -1), (2, 1),\n        (-1, -2), (-1, 2), (1, -2), (1, 2)\n    ]\n    positions = []\n    for dx, dy in jumps:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx <= 9 and 0 <= ny <= 9:\n            positions.append((nx, ny))\n    return positions\n\ndef get_water_positions(x, y):\n    \"\"\"Returns all positions covered by water from sprinkler at (x, y)\"\"\"\n    positions = set()\n    for dx in range(-2, 3):\n        for dy in range(-2, 3):\n            if abs(dx) + abs(dy) <= 2:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx <= 9 and 0 <= ny <= 9:\n                    positions.add((nx, ny))\n    return positions\n\ndef solve(px, py, sprinklers):\n    n = len(sprinklers)\n    \n    # BFS to find if there's a path\n    # State: (current_position, sprinkler_index)\n    # We start by jumping from initial position when first sprinkler activates\n    \n    if n == 0:\n        return \"NA\"\n    \n    # Get all positions reachable from initial position\n    initial_jumps = get_jump_positions(px, py)\n    \n    # Check which of these positions are covered by first sprinkler\n    first_sprinkler_water = get_water_positions(sprinklers[0][0], sprinklers[0][1])\n    \n    # Queue: (position, sprinkler_index)\n    queue = deque()\n    visited = set()\n    \n    for pos in initial_jumps:\n        if pos in first_sprinkler_water:\n            queue.append((pos, 0))\n            visited.add((pos, 0))\n    \n    # If we reach the last sprinkler, we survived\n    while queue:\n        (x, y), spr_idx = queue.popleft()\n        \n        # If we're at the last sprinkler, we survived\n        if spr_idx == n - 1:\n            return \"OK\"\n        \n        # Try to jump to next sprinkler's water area\n        next_spr_idx = spr_idx + 1\n        next_water = get_water_positions(sprinklers[next_spr_idx][0], sprinklers[next_spr_idx][1])\n        \n        # Get all positions we can jump to\n        jump_positions = get_jump_positions(x, y)\n        \n        for next_pos in jump_positions:\n            if next_pos in next_water:\n                state = (next_pos, next_spr_idx)\n                if state not in visited:\n                    visited.add(state)\n                    queue.append(state)\n    \n    return \"NA\"\n\n# Read input\nwhile True:\n    line = input().split()\n    px, py = int(line[0]), int(line[1])\n    \n    if px == 0 and py == 0:\n        break\n    \n    n = int(input())\n    coords = list(map(int, input().split()))\n    \n    sprinklers = []\n    for i in range(n):\n        x = coords[2 * i]\n        y = coords[2 * i + 1]\n        sprinklers.append((x, y))\n    \n    result = solve(px, py, sprinklers)\n    print(result)\n", "perturbed_sampled": ["import sys from collections import deque def get_jump_positions(x, y): \"\"\"Returns all valid positions that can be reached from (x, y) with one jump\"\"\" jumps = [ (-2, -1), (-2, 1), (2, -1), (2,  positions = [] for dx, dy in jumps: nx, ny = x + dx, y + dy if 0 <= nx <= 9 and 0 <= ny <= 9: positions.append((nx,  by water from sprinkler at (x, y)\"\"\" positions =  3): if abs(dx) + abs(dy) <= 2: nx, ny = x + dx,  0 <= ny <= 9: positions.add((nx, ny)) return positions def solve(px, py, sprinklers): n = len(sprinklers) # BFS to find if there's a path # State: (current_position, sprinkler_index) # We start by jumping from initial position when first sprinkler activates if n == 0: return \"NA\" # Get all positions reachable from  get_water_positions(sprinklers[0][0], sprinklers[0][1]) # Queue: (position, sprinkler_index) queue = deque() visited = set() for pos in initial_jumps: if pos in first_sprinkler_water: queue.append((pos, 0)) visited.add((pos, 0)) # If we  spr_idx = queue.popleft() # If we're at the last sprinkler, we survived if spr_idx == n - 1: return \"OK\" # Try to jump to next sprinkler's water area next_spr_idx = spr_idx + 1 next_water = get_water_positions(sprinklers[next_spr_idx][0], sprinklers[next_spr_idx][1]) # Get all positions we can jump to jump_positions = get_jump_positions(x, y) for next_pos in jump_positions:  not in visited: visited.add(state)  input().split() px, py  0: break n = int(input()) coords = list(map(int, input().split())) sprinklers = [] for i in range(n): x = coords[2 * i] y = coords[2 * i + 1] sprinklers.append((x, y)) result = solve(px, py, sprinklers) print(result)"], "perturbed_original": ["R1=range(-2,3) R2=range(-1,2) A1=[(x,y) for x in R1 for y in R1 if 3<x**2+y**2<6] A2=[(x,y) for x in R2 for y in R2] def fi():  dx,dy in A if 0<=x+dx<10 and 0<=y+dy<10]) while 1: xf,yf=fi() if yf==xf==0: break raw_input() tmp=fi() PA=zip(tmp[0::2],tmp[1::2]) FA=set([(xf,yf)]) for ps in PA: SA=f(ps,1) tmp=set([]) for pf in FA: tmp=tmp|(SA&f(pf,0)) FA=tmp print [\"NA\",\"OK\"][len(FA)>0]"], "original_ll": -1.726151943206787, "sampled_ll": -0.8041810393333435, "all_perturbed_sampled_ll": [-1.8326995372772217], "all_perturbed_original_ll": [-2.3489155769348145], "perturbed_sampled_ll": -1.8326995372772217, "perturbed_original_ll": -2.3489155769348145, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  float x,y;\n  \n  while(scanf(\"%f%f\",&x,&y)!=EOF){   \n    if(x<35.5&&y<71)\n      puts(\"AAA\");\n    else if(x<37.5&&y<77)\n      puts(\"AA\");\n    else if(x<40&&y<83)\n      puts(\"A\");\n    else if(x<43&&y<89)\n      puts(\"B\");\n    else if(x<50&&y<105)\n      puts(\"C\");\n    else if(x<55&&y<116)\n      puts(\"D\");\n    else if(x<70&&y<148)\n      puts(\"E\");\n    else\n      puts(\"NA\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double t1, t2;\n    \n    while (scanf(\"%lf %lf\", &t1, &t2) == 2) {\n        if (t1 < 35.50 && t2 < 71.00) {\n            printf(\"AAA\\n\");\n        } else if (t1 < 37.50 && t2 < 77.00) {\n            printf(\"AA\\n\");\n        } else if (t1 < 40.00 && t2 < 83.00) {\n            printf(\"A\\n\");\n        } else if (t1 < 43.00 && t2 < 89.00) {\n            printf(\"B\\n\");\n        } else if (t1 < 50.00 && t2 < 105.00) {\n            printf(\"C\\n\");\n        } else if (t1 < 55.00 && t2 < 116.00) {\n            printf(\"D\\n\");\n        } else if (t1 < 70.00 && t2 < 148.00) {\n            printf(\"E\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double t1, t2; while (scanf(\"%lf %lf\", &t1, &t2) == 2)  printf(\"AAA\\n\"); } else if (t1 <  (t1 < 40.00 && t2 < 83.00) { printf(\"A\\n\"); } else if (t1 < 43.00 && t2 < 89.00) { printf(\"B\\n\"); } else if (t1 < 50.00 && t2 < 105.00) { printf(\"C\\n\"); } else if (t1 < 55.00 && t2 < 116.00) { printf(\"D\\n\"); } else  } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ float x,y; while(scanf(\"%f%f\",&x,&y)!=EOF){ if(x<35.5&&y<71) puts(\"AAA\"); else if(x<37.5&&y<77) puts(\"AA\"); else if(x<40&&y<83) puts(\"A\"); else if(x<43&&y<89) puts(\"B\"); else if(x<50&&y<105) puts(\"C\"); else if(x<55&&y<116) puts(\"D\"); else if(x<70&&y<148) puts(\"E\"); else puts(\"NA\"); } return 0; }"], "original_ll": -0.9408214688301086, "sampled_ll": -0.5461478233337402, "all_perturbed_sampled_ll": [-1.0448251962661743], "all_perturbed_original_ll": [-1.0157054662704468], "perturbed_sampled_ll": -1.0448251962661743, "perturbed_original_ll": -1.0157054662704468, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble eps=0.000000000000000001;\n\t\twhile(sc.hasNext()){\n\t\t\tdouble n=sc.nextDouble();\n\t\t\tdouble m=sc.nextDouble();\n\t\t\tif(n<35.5-eps && m<71.0-eps){\n\t\t\t\tSystem.out.println(\"AAA\");\n\t\t\t}\n\t\t\telse if(n<37.5-eps && m<77.0-eps){\n\t\t\t\tSystem.out.println(\"AA\");\n\t\t\t}\n\t\t\telse if(n<40.0-eps && m<83.0-eps){\n\t\t\t\tSystem.out.println(\"A\");\n\t\t\t}\n\t\t\telse if(n<43.0-eps && m<89.0-eps){\n\t\t\t\tSystem.out.println(\"B\");\n\t\t\t}\n\t\t\telse if(n<50.0-eps && m<105.0-eps){\n\t\t\t\tSystem.out.println(\"C\");\n\t\t\t}\n\t\t\telse if(n<55.0-eps && m<116.0-eps){\n\t\t\t\tSystem.out.println(\"D\");\n\t\t\t}\n\t\t\telse if(n<70.0-eps && m<148.0-eps){\n\t\t\t\tSystem.out.println(\"E\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double t1 = sc.nextDouble();\n            double t2 = sc.nextDouble();\n            \n            String result = \"NA\";\n            \n            if (t1 < 35.50 && t2 < 71.00) {\n                result = \"AAA\";\n            } else if (t1 < 37.50 && t2 < 77.00) {\n                result = \"AA\";\n            } else if (t1 < 40.00 && t2 < 83.00) {\n                result = \"A\";\n            } else if (t1 < 43.00 && t2 < 89.00) {\n                result = \"B\";\n            } else if (t1 < 50.00 && t2 < 105.00) {\n                result = \"C\";\n            } else if (t1 < 55.00 && t2 < 116.00) {\n                result = \"D\";\n            } else if (t1 < 70.00 && t2 < 148.00) {\n                result = \"E\";\n            }\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[]  result = \"NA\"; if (t1 < 35.50 && t2 < 71.00) { result = \"AAA\"; } else if (t1 < 37.50 &&  (t1 <  else if (t1 < 43.00 && t2 < 89.00) { result = \"B\"; } else if (t1 < 50.00 && t2 < 105.00) { result = \"C\"; } else if (t1 < 55.00 && t2 < 116.00) { result = \"D\"; } else if (t1 < 70.00 && t2 < 148.00) { result = \"E\"; } System.out.println(result); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class  Scanner(System.in); double eps=0.000000000000000001; while(sc.hasNext()){ double n=sc.nextDouble(); double m=sc.nextDouble(); if(n<35.5-eps && m<71.0-eps){ System.out.println(\"AAA\"); } else if(n<37.5-eps && m<77.0-eps){ System.out.println(\"AA\"); } else if(n<40.0-eps  else if(n<50.0-eps && m<105.0-eps){ System.out.println(\"C\"); } else if(n<55.0-eps && m<116.0-eps){ System.out.println(\"D\"); } else if(n<70.0-eps && m<148.0-eps){ System.out.println(\"E\"); } else{ System.out.println(\"NA\"); } } } }"], "original_ll": -0.5994848012924194, "sampled_ll": -0.526497483253479, "all_perturbed_sampled_ll": [-1.1642582416534424], "all_perturbed_original_ll": [-1.1683869361877441], "perturbed_sampled_ll": -1.1642582416534424, "perturbed_original_ll": -1.1683869361877441, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n# 500 M\t1000 M\n# AAA \u7d1a\t35 \u79d2 50\t1 \u5206 11 \u79d2 00\n# AA \u7d1a\t37 \u79d2 50\t1 \u5206 17 \u79d2 00\n# A \u7d1a\t40 \u79d2 00\t1 \u5206 23 \u79d2 00\n# B \u7d1a\t43 \u79d2 00\t1 \u5206 29 \u79d2 00\n# C \u7d1a\t50 \u79d2 00\t1 \u5206 45 \u79d2 00\n# D \u7d1a\t55 \u79d2 00\t1 \u5206 56 \u79d2 00\n# E \u7d1a\t1\u520610 \u79d2 00\t2 \u5206 28 \u79d2 00\n\nranks = [\"AAA\",\"AA\",\"A\",\"B\",\"C\",\"D\",\"E\",\"NA\"]\ntimesA = [35.50,37.50,40,43,50,55,70]\ntimesB = [71,77,83,89,105,116,148]\n\nwhile(1):\n    try:\n        a,b = (float(x) for x in input().split())\n        rankA = rankB = 7\n        # checkA\n        for i in range(0,7):\n            if timesA[i] > a:\n                rankA = i\n                break\n        # checkB\n        for i in range(rankA,7):\n            if timesB[i] > b:\n                rankB = max(rankA,i)\n                break\n        print(ranks[rankB])\n    except:\n        break\n", "sampled": "import sys\n\ngrades = [\n    (\"AAA\", 35.50, 71.00),\n    (\"AA\", 37.50, 77.00),\n    (\"A\", 40.00, 83.00),\n    (\"B\", 43.00, 89.00),\n    (\"C\", 50.00, 105.00),\n    (\"D\", 55.00, 116.00),\n    (\"E\", 70.00, 148.00)\n]\n\nfor line in sys.stdin:\n    t1, t2 = map(float, line.strip().split())\n    \n    result = \"NA\"\n    for grade, time_500, time_1000 in grades:\n        if t1 < time_500 and t2 < time_1000:\n            result = grade\n            break\n    \n    print(result)\n", "perturbed_sampled": ["import sys grades = [ (\"AAA\", 35.50, 71.00), (\"AA\", 37.50, 77.00), (\"A\", 40.00, 83.00), (\"B\", 43.00, 89.00), (\"C\", 50.00, 105.00), (\"D\", 55.00, 116.00), (\"E\", 70.00, 148.00) ] for line in sys.stdin: t1, t2 = map(float, line.strip().split()) result = \"NA\" for grade,  < time_1000: result = grade break print(result)"], "perturbed_original": ["# 500 M 1000 M # AAA \u7d1a 35 \u79d2 50 1 \u5206 11 \u79d2 00 # AA \u7d1a 37 \u79d2 50 1 \u5206 17 \u79d2 00 # A \u7d1a 40 \u79d2 00 1 \u5206 23 \u79d2 00 # B \u7d1a 43 \u79d2 00 1 \u5206 29 \u79d2 00 # C \u7d1a  \u7d1a  \u7d1a 1\u520610 \u79d2 00 2 \u5206 28 \u79d2 00 ranks = [\"AAA\",\"AA\",\"A\",\"B\",\"C\",\"D\",\"E\",\"NA\"] timesA = [35.50,37.50,40,43,50,55,70] timesB = [71,77,83,89,105,116,148] while(1): try: a,b = (float(x) for x in input().split()) rankA = rankB  > a: rankA  timesB[i] > b: rankB = max(rankA,i) break print(ranks[rankB]) except: break"], "original_ll": -1.1890257596969604, "sampled_ll": -1.0157948732376099, "all_perturbed_sampled_ll": [-1.530232548713684], "all_perturbed_original_ll": [-1.8487553596496582], "perturbed_sampled_ll": -1.530232548713684, "perturbed_original_ll": -1.8487553596496582, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\ntypedef struct{\n  char name[20];\n  int point;\n}P;\nmain(){\n  int a,b,c,n,i,j,flag=0;\n  while(1){\n\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    if(flag!=0)printf(\"\\n\");\n    flag=1;\n    P temp[n];\n    P flg;\n    for(i=0;i<n;i++){\n      scanf(\"%s %d %d %d\",temp[i].name,&a,&b,&c);\n      temp[i].point=a*3+c;\n    }\n\n    for(i=0;i<n-1;i++){\n      for(j=n-1;j>i;j--){\n\tif(temp[j].point>temp[j-1].point){\n\t  flg=temp[j];\n\t  temp[j]=temp[j-1];\n\t  temp[j-1]=flg;\n\t}\n      }\n    }\n    for(i=0;i<n;i++)printf(\"%s,%d\\n\",temp[i].name,temp[i].point);}\n    \n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[21];\n    int points;\n    int order;\n} Team;\n\nint main() {\n    int n;\n    int first = 1;\n    \n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        if (!first) {\n            printf(\"\\n\");\n        }\n        first = 0;\n        \n        Team teams[10];\n        \n        for (int i = 0; i < n; i++) {\n            int w, l, d;\n            scanf(\"%s %d %d %d\", teams[i].name, &w, &l, &d);\n            teams[i].points = w * 3 + d * 1;\n            teams[i].order = i;\n        }\n        \n        // Bubble sort\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - 1 - i; j++) {\n                if (teams[j].points < teams[j + 1].points ||\n                    (teams[j].points == teams[j + 1].points && teams[j].order > teams[j + 1].order)) {\n                    Team temp = teams[j];\n                    teams[j] = teams[j + 1];\n                    teams[j + 1] = temp;\n                }\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%s,%d\\n\", teams[i].name, teams[i].points);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef struct { char name[21]; int points; int order; } Team; int main() { int n; int  == 0) break; if (!first) { printf(\"\\n\"); } first = 0; Team teams[10]; for (int i = 0; i < n; i++) { int w, l, d; scanf(\"%s %d %d %d\", teams[i].name, &w, &l, &d); teams[i].points = w *   - 1; i++) { for (int j = 0; j < n - 1 - i; j++) { if (teams[j].points < teams[j + 1].points || (teams[j].points == teams[j + 1].points &&  teams[j] = teams[j + 1]; teams[j + 1] = temp; } } } for (int i = 0; i < n; i++) { printf(\"%s,%d\\n\", teams[i].name, teams[i].points); } } return 0; }"], "perturbed_original": ["#include<stdio.h> typedef struct{ char name[20]; int point; }P; main(){ int a,b,c,n,i,j,flag=0; while(1){ scanf(\"%d\",&n); if(n==0)break;  %d\",temp[i].name,&a,&b,&c); temp[i].point=a*3+c; } for(i=0;i<n-1;i++){ for(j=n-1;j>i;j--){ if(temp[j].point>temp[j-1].point){ flg=temp[j]; temp[j]=temp[j-1]; temp[j-1]=flg; } } } for(i=0;i<n;i++)printf(\"%s,%d\\n\",temp[i].name,temp[i].point);} return 0; }"], "original_ll": -1.0306744575500488, "sampled_ll": -0.4913131892681122, "all_perturbed_sampled_ll": [-1.1899964809417725], "all_perturbed_original_ll": [-1.3470077514648438], "perturbed_sampled_ll": -1.1899964809417725, "perturbed_original_ll": -1.3470077514648438, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n  public static void main (String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    String out = \"\";\n    while (scanner.hasNext()) {\n      int n = scanner.nextInt();\n      if (n == 0) {\n        break;\n      }\n      List<String> ts = new ArrayList<String>();\n      for (int ii = 0; ii < n; ii++) {\n        String t = scanner.next();\n        int w = scanner.nextInt();\n        int l = scanner.nextInt();\n        int d = scanner.nextInt();\n        String wp = \"0000\" + (w * 3 + d);\n        wp = wp.substring(wp.length() - 5);\n        String idx = \"00\" + (n - ii);\n        idx = idx.substring(idx.length() - 3);\n        ts.add(wp + \",\" + idx + \",\" + t);\n      }\n      Collections.sort(ts);\n      Collections.reverse(ts);\n      for (String el : ts) {\n        String[] works = el.split(\",\");\n        int wp = Integer.parseInt(works[0]);\n        out += works[2] + \",\" + wp + \"\\n\";\n      }\n      out += \"\\n\";\n    }\n    System.out.print(out.substring(0, out.length() - 1));\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Team {\n        String name;\n        int points;\n        int order;\n        \n        Team(String name, int points, int order) {\n            this.name = name;\n            this.points = points;\n            this.order = order;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        boolean first = true;\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            if (!first) {\n                System.out.println();\n            }\n            first = false;\n            \n            List<Team> teams = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                int w = sc.nextInt();\n                int l = sc.nextInt();\n                int d = sc.nextInt();\n                \n                int points = w * 3 + d * 1;\n                teams.add(new Team(name, points, i));\n            }\n            \n            teams.sort((a, b) -> {\n                if (a.points != b.points) {\n                    return b.points - a.points;\n                }\n                return a.order - b.order;\n            });\n            \n            for (Team team : teams) {\n                System.out.println(team.name + \",\" + team.points);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  name; int points; int order; Team(String name, int points, int order) { this.name = name; this.points = points; this.order = order; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); boolean first = true; while (true) { int n = sc.nextInt(); if (n ==  0; i  = sc.nextInt(); int l = sc.nextInt(); int d = sc.nextInt(); int points = w * 3 + d * 1; teams.add(new Team(name, points, i)); } teams.sort((a, b) -> { if (a.points != b.points) { return b.points - a.points; } return a.order - b.order; }); for (Team team : teams) { System.out.println(team.name + \",\" + team.points); } } sc.close(); } }"], "perturbed_original": [" args) { Scanner scanner = new Scanner(System.in); String out = \"\"; while (scanner.hasNext()) {  } List<String> ts = new ArrayList<String>(); for (int ii = 0; ii < n; ii++) { String t = scanner.next(); int w = scanner.nextInt(); int l = scanner.nextInt(); int d = scanner.nextInt(); String wp = \"0000\" + (w * 3 + d); wp =  ii); idx = idx.substring(idx.length() - 3); ts.add(wp + \",\" + idx + \",\" + t); } Collections.sort(ts); Collections.reverse(ts); for (String el : ts) { String[] works = el.split(\",\"); int wp = Integer.parseInt(works[0]); out += works[2] + \",\" + wp + \"\\n\";  }"], "original_ll": -0.9681492447853088, "sampled_ll": -0.4723587930202484, "all_perturbed_sampled_ll": [-1.3672964572906494], "all_perturbed_original_ll": [-1.815138816833496], "perturbed_sampled_ll": -1.3672964572906494, "perturbed_original_ll": -1.815138816833496, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "isPrint = False\n\nwhile True:\n\n    inputCount = int(input())\n\n    if inputCount == 0:\n        break\n\n    if isPrint:\n        print()\n    else:\n        isPrint = True\n\n    matchList = []\n\n    for lp in range(inputCount):\n\n        name, win, lose, draw = [item for item in input().split(\" \")]\n        score = int(win) * 3 + int(draw)\n\n        matchList.append([name, score])\n\n    matchList.sort(key=lambda item: -item[1])\n\n    for name, score in matchList:\n        print(name + \",\" + str(score))\n\n", "sampled": "results = []\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    teams = []\n    for i in range(n):\n        parts = input().split()\n        name = parts[0]\n        w = int(parts[1])\n        l = int(parts[2])\n        d = int(parts[3])\n        points = w * 3 + d * 1\n        teams.append((name, points, i))\n    \n    teams.sort(key=lambda x: (-x[1], x[2]))\n    \n    result = []\n    for team in teams:\n        result.append(f\"{team[0]},{team[1]}\")\n    \n    results.append(result)\n\nfor i, result in enumerate(results):\n    for line in result:\n        print(line)\n    if i < len(results) - 1:\n        print()\n", "perturbed_sampled": ["results = [] while True: n = int(input()) if n == 0: break teams = [] for i in range(n): parts =  d = int(parts[3]) points = w * 3 + d * 1 teams.append((name, points, i)) teams.sort(key=lambda x: (-x[1], x[2])) result = [] for team in  in result: print(line) if i < len(results) - 1: print()"], "perturbed_original": ["isPrint = False while True: inputCount = int(input()) if inputCount == 0: break if isPrint: print() else: isPrint = True matchList = [] for lp in range(inputCount): name, win, lose, draw = [item  + int(draw) matchList.append([name, score]) matchList.sort(key=lambda item: -item[1]) for name, score in matchList: print(name + \",\" + str(score))"], "original_ll": -1.357729196548462, "sampled_ll": -0.8269041180610657, "all_perturbed_sampled_ll": [-2.322314977645874], "all_perturbed_original_ll": [-2.365051031112671], "perturbed_sampled_ll": -2.322314977645874, "perturbed_original_ll": -2.365051031112671, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<time.h>\n#include<string.h>\nint main(void) {\n\ttime_t tim1,tim2;\n\tstruct tm d;\n\tdouble diff;\n\tint year1, year2, month1, month2, day1, day2;\n\twhile (1) {\n\t\tscanf(\"%d %d %d %d %d %d\",&year1,&month1,&day1,&year2,&month2,&day2);\n\t\tif (month1 == -1 || year1 == -1 || day1 == -1 ||month2 == -1 || year2 == -1 || day2 == -1) break;\n\t\tmemset(&d,0,sizeof(d));\n\t\td.tm_year = year1 - 1900;\n\t\td.tm_mon = month1 - 1;\n\t\td.tm_mday = day1;\n\t\ttim1 = mktime(&d);\n\t\td.tm_year = year2 - 1900;\n\t\td.tm_mon = month2 - 1;\n\t\td.tm_mday = day2;\n\t\ttim2 = mktime(&d);\n\n\t\tdiff = difftime(tim2, tim1);\n\n\t\tprintf(\"%d\\n\",(int)(diff/60/60/24+0.5));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint is_leap(int year) {\n    if (year % 400 == 0) return 1;\n    if (year % 100 == 0) return 0;\n    if (year % 4 == 0) return 1;\n    return 0;\n}\n\nint days_in_month(int year, int month) {\n    int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    if (month == 2 && is_leap(year)) {\n        return 29;\n    }\n    return days[month];\n}\n\nint days_from_epoch(int year, int month, int day) {\n    int total = 0;\n    \n    // Add days for complete years from year 1\n    for (int y = 1; y < year; y++) {\n        if (is_leap(y)) {\n            total += 366;\n        } else {\n            total += 365;\n        }\n    }\n    \n    // Add days for complete months in the current year\n    for (int m = 1; m < month; m++) {\n        total += days_in_month(year, m);\n    }\n    \n    // Add the days\n    total += day;\n    \n    return total;\n}\n\nint main() {\n    int y1, m1, d1, y2, m2, d2;\n    \n    while (scanf(\"%d %d %d %d %d %d\", &y1, &m1, &d1, &y2, &m2, &d2) == 6) {\n        if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) {\n            break;\n        }\n        \n        int days1 = days_from_epoch(y1, m1, d1);\n        int days2 = days_from_epoch(y2, m2, d2);\n        \n        printf(\"%d\\n\", days2 - days1);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int is_leap(int year) { if (year % 400 == 0) return 1; if  4 == 0) return 1; return 0; } int days_in_month(int year,  if (month == 2 && is_leap(year)) { return 29; } return days[month]; } int days_from_epoch(int year, int month, int day) { int total = 0; // Add days for  += 366; } else { total += 365; } } // Add days for complete months in the current year for (int m = 1; m < month; m++) { total += days_in_month(year, m); } // Add the days total += day; return total; } int main() { int  %d %d %d\", &y1, &m1, &d1, &y2, &m2, &d2) == 6) { if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) { break; } int days1 = days_from_epoch(y1, m1, d1); int days2 = days_from_epoch(y2, m2, d2); printf(\"%d\\n\", days2 - days1); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<time.h> #include<string.h> int main(void) { time_t tim1,tim2; struct tm d; double diff; int year1, year2, month1, month2, day1, day2; while (1) { scanf(\"%d %d %d %d %d %d\",&year1,&month1,&day1,&year2,&month2,&day2); if (month1 ==  == -1 || year2 == -1 || day2 == -1) break; memset(&d,0,sizeof(d)); d.tm_year = year1 - 1900; d.tm_mon = month1 - 1; d.tm_mday = day1; tim1 = mktime(&d); d.tm_year = year2 - 1900; d.tm_mon = month2  difftime(tim2, tim1); printf(\"%d\\n\",(int)(diff/60/60/24+0.5)); } return 0; }"], "original_ll": -0.6600609421730042, "sampled_ll": -0.37911221385002136, "all_perturbed_sampled_ll": [-1.167956829071045], "all_perturbed_original_ll": [-1.0266534090042114], "perturbed_sampled_ll": -1.167956829071045, "perturbed_original_ll": -1.0266534090042114, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n\npublic class Main {\n\n\tfinal int DAY_MONTH[]={0, 31, 28, 31, 30, 31, 30, 31, 31, 30 ,31, 30 ,31};\n\t\n\tScanner sc;\n\t\n\tint isLeap(int y){\n\t\tif(y%4==0){\n\t\t\tif(y%100==0){\n\t\t\t\tif(y%400==0){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tint dayCount(int y, int m1, int d1, int m2, int d2){\n\t\tint days=-d1;\n\t\tfor(int m=m1;m<=m2;++m){\n\t\t\tdays+=DAY_MONTH[m];\n\t\t\tif(m==2) days+=isLeap(y);\n\t\t}\n\t\tdays-=DAY_MONTH[m2]+(m2==2?isLeap(y):0)-d2;\n\t\treturn days;\n\t}\n\t\n\tint solve(int y1, int m1, int d1, int y2, int m2, int d2){\n\t\tint days=0;\n\t\tif(y2-y1>=2){\n\t\t\tfor(int y=y1+1;y<y2;++y){\n\t\t\t\tdays+=365+isLeap(y);\n\t\t\t}\n\t\t}\n\t\tif(y2-y1>=1){\n\t\t\tdays+=dayCount(y1, m1, d1, 12, 31)+dayCount(y2, 1, 1, m2, d2)+1;\n\t\t}\n\t\telse{\n\t\t\tdays=dayCount(y1, m1, d1, m2, d2);\n\t\t}\n\t\treturn days;\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint y1=ni(), m1=ni(), d1=ni(), y2=ni(), m2=ni(), d2=ni();\n\t\t\tif(y1<0||m1<0||d1<0||y2<0||m2<0||d2<0) break;\n\t\t\t\n\t\t\tSystem.out.println(solve(y1, m1, d1, y2, m2, d2));\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int y1 = sc.nextInt();\n            int m1 = sc.nextInt();\n            int d1 = sc.nextInt();\n            int y2 = sc.nextInt();\n            int m2 = sc.nextInt();\n            int d2 = sc.nextInt();\n            \n            if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) {\n                break;\n            }\n            \n            int days = countDays(y1, m1, d1, y2, m2, d2);\n            System.out.println(days);\n        }\n        \n        sc.close();\n    }\n    \n    static int countDays(int y1, int m1, int d1, int y2, int m2, int d2) {\n        int days1 = toDays(y1, m1, d1);\n        int days2 = toDays(y2, m2, d2);\n        return days2 - days1;\n    }\n    \n    static int toDays(int year, int month, int day) {\n        int days = 0;\n        \n        // Count days for complete years from year 1\n        for (int y = 1; y < year; y++) {\n            if (isLeapYear(y)) {\n                days += 366;\n            } else {\n                days += 365;\n            }\n        }\n        \n        // Count days for complete months in the current year\n        for (int m = 1; m < month; m++) {\n            days += getDaysInMonth(year, m);\n        }\n        \n        // Add remaining days\n        days += day;\n        \n        return days;\n    }\n    \n    static boolean isLeapYear(int year) {\n        if (year % 400 == 0) {\n            return true;\n        }\n        if (year % 100 == 0) {\n            return false;\n        }\n        if (year % 4 == 0) {\n            return true;\n        }\n        return false;\n    }\n    \n    static int getDaysInMonth(int year, int month) {\n        int[] days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        \n        if (month == 2 && isLeapYear(year)) {\n            return 29;\n        }\n        \n        return days[month];\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  sc.nextInt(); int m1 = sc.nextInt(); int  sc.nextInt(); int d2 = sc.nextInt(); if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) { break; } int days = countDays(y1, m1, d1, y2, m2, d2); System.out.println(days); } sc.close(); } static int countDays(int  d2)  toDays(y2, m2, d2); return days2 - days1; } static int toDays(int year, int month, int day) { int days = 0; // Count days for complete years from year 1 for (int y = 1; y < year; y++) { if (isLeapYear(y)) { days += 366; }  for complete months in the current year for (int m = 1; m < month; m++) { days += getDaysInMonth(year, m); } // Add remaining days days += day; return days; } static boolean isLeapYear(int year) { if (year  % 100  == 0) { return true; } return false; } static int getDaysInMonth(int year, int month) { int[] days = {0, 31, 28, 31, 30, 31,  2 && isLeapYear(year)) { return 29; } return days[month]; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { final int DAY_MONTH[]={0, 31, 28, 31, 30, 31, 30, 31, 31, 30 ,31, 30 ,31}; Scanner sc; int isLeap(int y){ if(y%4==0){ if(y%100==0){ if(y%400==0){ return 1; } else{ return 0; } } else{ return 1; } } else{ return 0; } } int dayCount(int y, int m1, int d1, int m2, int d2){ ){<extra_id_3>(<extra_id_4>( \"<extra_id_5>\" \"<extra_id_6>, 2 ]<extra_id_7>\"<extra_id_8>] ) {<extra_id_9>\"<extra_id_10>, 2 ]<extra_id_11>\" \"<extra_id_12>\"<extra_id_13>\" \"<extra_id_14>] ) ;<extra_id_15>[ 1 ]<extra_id_16>0 , 1<extra_id_17>; System<extra_id_18>\"<extra_id_19>.<extra_id_20>} public static<extra_id_21>{ int dayCount ( final<extra_id_22>, m1 , int<extra_id_23>-<extra_id_24>- 1 ; } public<extra_id_25>[ days; } int solve(int y1, int m1, int d1, int y2, int m2, int  days+=dayCount(y1, m1, d1, 12, 31)+dayCount(y2, 1, 1, m2, d2)+1; } else{ days=dayCount(y1, m1,  sc.nextInt(); } void io(){ sc=new Scanner(System.in); while(true){ int y1=ni(), m1=ni(), d1=ni(), y2=ni(), m2=ni(), d2=ni(); if(y1<0||m1<0||d1<0||y2<0||m2<0||d2<0) break; System.out.println(solve(y1, m1, d1, y2, m2, d2)); } sc.close(); } public static void main(String[]  }"], "original_ll": -0.6482090950012207, "sampled_ll": -0.30383339524269104, "all_perturbed_sampled_ll": [-1.2341933250427246], "all_perturbed_original_ll": [-1.3703491687774658], "perturbed_sampled_ll": -1.2341933250427246, "perturbed_original_ll": -1.3703491687774658, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f1():\n    if y1 == y2 and m1 == m2:\n        return d2- d1\n    \n    a = 0\n    if y1 % 400 == 0 or (y1 % 4 == 0 and y1 % 100 != 0):\n        a = 29\n    else:\n        a = 28\n    \n    t = 0\n    if m1 in [4,6,9,11]:\n        t += (30 - d1 + 1)\n    elif m1 in [1,3,5,7,8,10,12]:\n        t += (31 - d1 + 1)\n    else:\n        t += (a - d1 + 1)\n        \n        \n    if y1 == y2:\n        return f3(t, m1+1)\n    else:\n        for m in range(m1+1, 13):\n            if m in [4,6,9,11]:\n                t += 30\n            elif m in [1,3,5,7,8,10,12]:\n                t += 31\n            else:\n                t += a\n            \n        return f2(t)\n    \ndef f2(t):\n    for y in range(y1+1, y2):\n        if y % 400 == 0 or (y % 4 == 0 and y % 100 != 0):\n            t += 366\n        else:\n            t += 365\n    \n    return f3(t, 1)\n    \ndef f3(t, s):\n    a = 0\n    if y2 % 400 == 0 or (y2 % 4 == 0 and y2 % 100 != 0):\n        a = 29\n    else:\n        a = 28\n        \n    for m in range(s, m2):\n        if m in [4,6,9,11]:\n            t += 30\n        elif m in [1,3,5,7,8,10,12]:\n            t += 31\n        else:\n            t += a\n            \n    t += (d2 - 1)\n            \n    return t\n            \nwhile True:\n    y1, m1, d1, y2, m2, d2 = map(int, raw_input().split())\n    if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0:\n        break\n    print f1()", "sampled": "def is_leap_year(year):\n    if year % 400 == 0:\n        return True\n    if year % 100 == 0:\n        return False\n    if year % 4 == 0:\n        return True\n    return False\n\ndef days_in_month(year, month):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month in [4, 6, 9, 11]:\n        return 30\n    elif month == 2:\n        return 29 if is_leap_year(year) else 28\n\ndef days_from_epoch(year, month, day):\n    # Calculate days from year 0\n    days = 0\n    \n    # Add days for complete years\n    for y in range(1, year):\n        if is_leap_year(y):\n            days += 366\n        else:\n            days += 365\n    \n    # Add days for complete months in the current year\n    for m in range(1, month):\n        days += days_in_month(year, m)\n    \n    # Add remaining days\n    days += day\n    \n    return days\n\nwhile True:\n    line = list(map(int, input().split()))\n    y1, m1, d1, y2, m2, d2 = line\n    \n    if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0:\n        break\n    \n    days1 = days_from_epoch(y1, m1, d1)\n    days2 = days_from_epoch(y2, m2, d2)\n    \n    print(days2 - days1)\n", "perturbed_sampled": ["def is_leap_year(year): if year % 400 == 0: return True if year % 100 ==  True return False def days_in_month(year, month): if month in [1, 3, 5, 7, 8, 10, 12]: return 31 elif  days_from_epoch(year, month, day): # Calculate days from year 0 days = 0 # Add days for complete years for y in range(1, year): if is_leap_year(y): days += 366 else: days += 365 # Add days for complete  days += days_in_month(year, m) # Add remaining days days += day return days  m2, d2 = line if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0: break days1 = days_from_epoch(y1, m1, d1) days2 = days_from_epoch(y2, m2, d2) print(days2 - days1)"], "perturbed_original": ["def f1(): if y1 == y2 and m1  % 400 == 0 or (y1 % 4 == 0 and y1  28 t = 0 if m1 in [4,6,9,11]: t += (30 - d1 + 1) elif m1 in [1,3,5,7,8,10,12]: t += (31 - d1 + 1) else: t += (a - d1 + 1) if y1 == y2: return f3(t, m1+1) else: for  t += a return f2(t) def f2(t): for y in range(y1+1, y2): if y % 400 == 0 or (y % 4 == 0 and y % 100 != 0): t += 366  a = 0 if y2 % 400 == 0 or (y2 % 4 == 0 and y2 % 100 != 0): a  m2): if m in [4,6,9,11]: t += 30 elif m in [1,3,5,7,8,10,12]: t += 31 else: t += a t += (d2 - 1) return t while True:  y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0: break print f1()"], "original_ll": -0.6622870564460754, "sampled_ll": -0.4395093619823456, "all_perturbed_sampled_ll": [-1.3975008726119995], "all_perturbed_original_ll": [-1.292543649673462], "perturbed_sampled_ll": -1.3975008726119995, "perturbed_original_ll": -1.292543649673462, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "v[81],e[81];\nB(p,s0,s1){\n\tint f[10]={0},i,j;\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tif(f[v[p]])\n\t\t\t\te[~f[v[p]]]=e[p]=1;\n\t\t\telse\n\t\t\t\tf[v[p]]=~p;\n\t\t\tp+=s0;\n\t\t}\n\t\tp+=s1-3*s0;\n\t}\n}\nmain(i,f){\n\tscanf(\"%*d\\n\");\n\tfor(f=i=0;~scanf(\"%d\",v+i);){\n\t\tif(++i==81){\n\t\t\tmemset(e,0,sizeof(e));\n\t\t\tfor(i=0;i<9;i++){\n\t\t\t\tB(0+i*9,1+0*9,3+0*9);\n\t\t\t\tB(i+0*9,0+1*9,0+3*9);\n\t\t\t\tB(i%3*3+i/3*3*9,1+0*9,0+1*9);\n\t\t\t}\n\t\t\tif(f++)\n\t\t\t\tputs(\"\");\n\t\t\tfor(i=0;i<81;i++){\n\t\t\t\tprintf(\"%c%d\",e[i]?'*':' ',v[i]);\n\t\t\t\tif(i%9==8)\n\t\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t\ti=0;\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int dataset = 0; dataset < n; dataset++) {\n        int grid[9][9];\n        int error[9][9];\n        \n        // Read input\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                scanf(\"%d\", &grid[i][j]);\n                error[i][j] = 0;\n            }\n        }\n        \n        // Check rows\n        for (int i = 0; i < 9; i++) {\n            int count[10] = {0};\n            for (int j = 0; j < 9; j++) {\n                count[grid[i][j]]++;\n            }\n            for (int j = 0; j < 9; j++) {\n                if (count[grid[i][j]] > 1) {\n                    error[i][j] = 1;\n                }\n            }\n        }\n        \n        // Check columns\n        for (int j = 0; j < 9; j++) {\n            int count[10] = {0};\n            for (int i = 0; i < 9; i++) {\n                count[grid[i][j]]++;\n            }\n            for (int i = 0; i < 9; i++) {\n                if (count[grid[i][j]] > 1) {\n                    error[i][j] = 1;\n                }\n            }\n        }\n        \n        // Check 3x3 blocks\n        for (int block_i = 0; block_i < 3; block_i++) {\n            for (int block_j = 0; block_j < 3; block_j++) {\n                int count[10] = {0};\n                for (int i = block_i * 3; i < block_i * 3 + 3; i++) {\n                    for (int j = block_j * 3; j < block_j * 3 + 3; j++) {\n                        count[grid[i][j]]++;\n                    }\n                }\n                for (int i = block_i * 3; i < block_i * 3 + 3; i++) {\n                    for (int j = block_j * 3; j < block_j * 3 + 3; j++) {\n                        if (count[grid[i][j]] > 1) {\n                            error[i][j] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Output\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (error[i][j]) {\n                    printf(\"*%d\", grid[i][j]);\n                } else {\n                    printf(\" %d\", grid[i][j]);\n                }\n                if (j < 8) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n        \n        if (dataset < n - 1) {\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; scanf(\"%d\", &n); for (int dataset = 0; dataset < n; dataset++) { int grid[9][9]; int error[9][9]; // Read input  for (int j = 0; j < 9; j++) { scanf(\"%d\", &grid[i][j]); error[i][j] = 0; } } // Check rows  int count[10] = {0}; for (int j = 0;  = 0; j < 9; j++) { if (count[grid[i][j]] > 1) { error[i][j] = 1; } }  < 9; j++) { int count[10] = {0}; for (int i = 0; i  0; i < 9; i++) { if (count[grid[i][j]] > 1) { error[i][j] = 1; } } } // Check 3x3 blocks  for (int block_j = 0; block_j < 3; block_j++) { int count[10] = {0}; for (int i = block_i * 3; i < block_i * 3 + 3; i++) { for (int j = block_j * 3; j < block_j * 3 + 3; j++) { count[grid[i][j]]++; } } for (int i = block_i * 3; i < block_i * 3 +  } } } } // Output for (int i = 0; i < 9; i++) { for (int j = 0; j < 9; j++) { if (error[i][j]) { printf(\"*%d\", grid[i][j]); } else { printf(\" %d\", grid[i][j]); } if (j < 8) printf(\" \"); } printf(\"\\n\"); } if (dataset < n - 1) { printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["v[81],e[81]; B(p,s0,s1){ int f[10]={0},i,j; for(i=0;i<3;i++){ for(j=0;j<3;j++){ if(f[v[p]]) e[~f[v[p]]]=e[p]=1; else f[v[p]]=~p; p+=s0; } p+=s1-3*s0;  B(i%3*3+i/3*3*9,1+0*9,0+1*9); } if(f++) puts(\"\"); for(i=0;i<81;i++){ printf(\"%c%d\",e[i]?'*':' ',v[i]); if(i%9==8) puts(\"\"); } i=0; } } }"], "original_ll": -1.7335526943206787, "sampled_ll": -0.24266508221626282, "all_perturbed_sampled_ll": [-0.809634804725647], "all_perturbed_original_ll": [-2.3216142654418945], "perturbed_sampled_ll": -0.809634804725647, "perturbed_original_ll": -2.3216142654418945, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nclass Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        for (int i = 0; i < n; i++) {\n            int[][] map = new int[9][9];\n            boolean[][] ok = new boolean[9][9];\n            for (int j = 0; j < 9; j++) {\n                String[] input = br.readLine().split(\" \");\n                for (int k = 0; k < 9; k++) {\n                    map[j][k] = Integer.parseInt(input[k]);\n                }\n            }\n\n            // horizontal check\n            for (int j = 0; j < 9; j++) {\n                boolean[] oneToNine = new boolean[10]; // index0\u306f\u4f7f\u308f\u306a\u3044\n                for (int k = 0; k < 9; k++) {\n                    if (!oneToNine[map[j][k]]) {\n                        oneToNine[map[j][k]] = true;\n                    } else {\n                        ok[j][k] = true;\n                        for (int l = 0; l < k; l++) {\n                            if (map[j][l] == map[j][k]) {\n                                ok[j][l] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // vertical check\n            for (int j = 0; j < 9; j++) {\n                boolean[] oneToNine = new boolean[10];\n                for (int k = 0; k < 9; k++) {\n                    if (!oneToNine[map[k][j]]) {\n                        oneToNine[map[k][j]] = true;\n                    } else {\n                        ok[k][j] = true;\n                        for (int l = 0; l < k; l++) {\n                            if (map[l][j] == map[k][j]) {\n                                ok[l][j] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // display\n            for (int j = 0; j < 9; j++) {\n                for (int k = 0; k < 9; k++) {\n                    if (ok[j][k])\n                        System.out.print(\"*\");\n                    else\n                        System.out.print(\" \");\n\n                    System.out.print(map[j][k]);\n                }\n                System.out.println();\n            }\n\n        }\n    }\n}\n", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int t = 0; t < n; t++) {\n            if (t > 0) {\n                System.out.println();\n            }\n            \n            int[][] grid = new int[9][9];\n            for (int i = 0; i < 9; i++) {\n                String line = sc.nextLine();\n                String[] tokens = line.trim().split(\"\\\\s+\");\n                for (int j = 0; j < 9; j++) {\n                    grid[i][j] = Integer.parseInt(tokens[j]);\n                }\n            }\n            \n            boolean[][] error = new boolean[9][9];\n            \n            // Check rows\n            for (int i = 0; i < 9; i++) {\n                int[] count = new int[10];\n                for (int j = 0; j < 9; j++) {\n                    count[grid[i][j]]++;\n                }\n                for (int j = 0; j < 9; j++) {\n                    if (count[grid[i][j]] > 1) {\n                        error[i][j] = true;\n                    }\n                }\n            }\n            \n            // Check columns\n            for (int j = 0; j < 9; j++) {\n                int[] count = new int[10];\n                for (int i = 0; i < 9; i++) {\n                    count[grid[i][j]]++;\n                }\n                for (int i = 0; i < 9; i++) {\n                    if (count[grid[i][j]] > 1) {\n                        error[i][j] = true;\n                    }\n                }\n            }\n            \n            // Check 3x3 blocks\n            for (int blockRow = 0; blockRow < 3; blockRow++) {\n                for (int blockCol = 0; blockCol < 3; blockCol++) {\n                    int[] count = new int[10];\n                    for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) {\n                        for (int j = blockCol * 3; j < blockCol * 3 + 3; j++) {\n                            count[grid[i][j]]++;\n                        }\n                    }\n                    for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) {\n                        for (int j = blockCol * 3; j < blockCol * 3 + 3; j++) {\n                            if (count[grid[i][j]] > 1) {\n                                error[i][j] = true;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // Output\n            for (int i = 0; i < 9; i++) {\n                for (int j = 0; j < 9; j++) {\n                    if (error[i][j]) {\n                        System.out.print(\"*\");\n                    } else {\n                        System.out.print(\" \");\n                    }\n                    System.out.print(grid[i][j]);\n                }\n                System.out.println();\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n =  t++) { if (t > 0) { System.out.println(); } int[][] grid  9; i++) { String line =  j < 9; j++) { grid[i][j] = Integer.parseInt(tokens[j]); } } boolean[][] error = new boolean[9][9]; // Check rows for (int i = 0; i  (int j = 0; j < 9; j++) { count[grid[i][j]]++; } for (int j = 0; j < 9; j++) { if (count[grid[i][j]] > 1) { error[i][j] = true; } } } // Check columns for (int j = 0; j < 9; j++) { int[] count = new int[10]; for (int i = 0; i < 9; i++) { count[grid[i][j]]++; } for (int i = 0; i < 9; i++) { if (count[grid[i][j]] > 1) { error[i][j] = true; } } } // Check 3x3 blocks for (int blockRow = 0;  blockCol < 3; blockCol++) { int[] count = new  j = blockCol * 3; j < blockCol * 3 + 3; j++) { count[grid[i][j]]++; } } for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) { for (int j  3; j++) { if (count[grid[i][j]] > 1) { error[i][j] = true; } } } } } // Output for (int i = 0; i < 9; i++) { for (int j = 0; j < 9; j++) { if (error[i][j]) {  } } sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.io.BufferedReader; import java.io.InputStreamReader; class Main  br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); for (int i = 0; i < n; i++) { int[][] map = new int[9][9]; boolean[][] ok = new boolean[9][9]; for (int j = 0; j < 9; j++) { String[]   horizontal check for (int  = new boolean[10]; // index0\u306f\u4f7f\u308f\u306a\u3044 for (int k = 0; k < 9; k++) { if (!oneToNine[map[j][k]]) { oneToNine[map[j][k]] = true; } else { ok[j][k] =  { if (map[j][l] == map[j][k]) {  vertical check for (int j = 0; j < 9; j++) { boolean[] oneToNine = new boolean[10]; for (int k = 0; k < 9; k++) { if (!oneToNine[map[k][j]]) { oneToNine[map[k][j]] = true; } else { ok[k][j] = true; for (int l = 0; l < k; l++) { if (map[l][j] == map[k][j]) { ok[l][j] = true; break; } } } } } // display for (int j =  0; k < 9; k++) { if (ok[j][k]) System.out.print(\"*\"); else System.out.print(\" \"); System.out.print(map[j][k]); } System.out.println(); } } } }"], "original_ll": -0.4084216356277466, "sampled_ll": -0.23799411952495575, "all_perturbed_sampled_ll": [-0.9793409705162048], "all_perturbed_original_ll": [-1.1715223789215088], "perturbed_sampled_ll": -0.9793409705162048, "perturbed_original_ll": -1.1715223789215088, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "R=range(9)\ndef f1(M):\n  global F\n  for y in R:\n    A=M[y]\n    if len(set(A))==9: continue\n    for x in R:\n      if A.count(A[x])>=2: F[y][x]=\"*\"\n  return\ndef f2(M):\n  global F\n  for x in R:\n    A=[M[y][x] for y in R]\n    if len(set(A))==9: continue\n    for y in R:\n      if A.count(A[y])>=2: F[y][x]=\"*\"\n  return\ndef f3(M):\n  global F\n  for i in R:\n    x=i%3*3\n    y=i/3*3\n    A=M[y][x:x+3]+M[y+1][x:x+3]+M[y+2][x:x+3]\n    if len(set(A))==9: continue\n    for j in R:\n      if A.count(A[j])>=2: F[y+j/3][x+j%3]=\"*\"\n  return\n\nn=input()\nwhile n:\n  M=[]\n  F=[[\" \" for _ in [0]*9] for _ in [0]*9]\n  M=[map(int,raw_input().split()) for _ in [0]*9]\n  f1(M)\n  f2(M)\n  f3(M)\n  for i in R:\n    s=zip(F[i],map(str,M[i]))\n    print \"\".join([a+b for a,b in s])\n  if n>1: print\n  n-=1", "sampled": "def solve():\n    n = int(input())\n    \n    for dataset_idx in range(n):\n        grid = []\n        for _ in range(9):\n            row = list(map(int, input().split()))\n            grid.append(row)\n        \n        # Mark errors\n        errors = [[False] * 9 for _ in range(9)]\n        \n        # Check rows\n        for i in range(9):\n            counts = {}\n            for j in range(9):\n                val = grid[i][j]\n                if val not in counts:\n                    counts[val] = []\n                counts[val].append(j)\n            \n            for val, positions in counts.items():\n                if len(positions) > 1:\n                    for j in positions:\n                        errors[i][j] = True\n        \n        # Check columns\n        for j in range(9):\n            counts = {}\n            for i in range(9):\n                val = grid[i][j]\n                if val not in counts:\n                    counts[val] = []\n                counts[val].append(i)\n            \n            for val, positions in counts.items():\n                if len(positions) > 1:\n                    for i in positions:\n                        errors[i][j] = True\n        \n        # Check 3x3 blocks\n        for block_row in range(3):\n            for block_col in range(3):\n                counts = {}\n                for i in range(block_row * 3, block_row * 3 + 3):\n                    for j in range(block_col * 3, block_col * 3 + 3):\n                        val = grid[i][j]\n                        if val not in counts:\n                            counts[val] = []\n                        counts[val].append((i, j))\n                \n                for val, positions in counts.items():\n                    if len(positions) > 1:\n                        for i, j in positions:\n                            errors[i][j] = True\n        \n        # Output\n        for i in range(9):\n            output = []\n            for j in range(9):\n                if errors[i][j]:\n                    output.append('*' + str(grid[i][j]))\n                else:\n                    output.append(' ' + str(grid[i][j]))\n            print(''.join(output))\n        \n        if dataset_idx < n - 1:\n            print()\n\nsolve()\n", "perturbed_sampled": ["def solve(): n = int(input()) for dataset_idx in range(n): grid = [] for _ in range(9): row = list(map(int, input().split())) grid.append(row) # Mark errors errors = [[False] * 9 for _ in range(9)] # Check rows for i in range(9): counts = {} for j in range(9): val = grid[i][j] if val not in counts: counts[val] = [] counts[val].append(j) for val, positions in counts.items(): if len(positions) > 1: for j in positions: errors[i][j] =  val not in counts: counts[val] = [] counts[val].append(i) for val, positions in counts.items(): if len(positions) > 1: for i in positions: errors[i][j] = True # Check 3x3 blocks for block_row in range(3): for block_col in range(3): counts = {} for i  j in range(block_col * 3, block_col * 3 + 3): val = grid[i][j] if val  positions in counts.items(): if len(positions) > 1: for i, j in positions: errors[i][j] = True #  in range(9): if  if dataset_idx < n - 1: print() solve()"], "perturbed_original": ["R=range(9) def f1(M): global F for y in R: A=M[y] if len(set(A))==9: continue for x in R: if A.count(A[x])>=2: F[y][x]=\"*\" return def f2(M): global F for x in R:  in R: if A.count(A[y])>=2: F[y][x]=\"*\" return def f3(M): global  continue for j in R: if A.count(A[j])>=2: F[y+j/3][x+j%3]=\"*\" return n=input() while n: M=[] F=[[\" \" for _ in [0]*9] for _ in [0]*9] M=[map(int,raw_input().split()) for _ in [0]*9] f1(M) f2(M) f3(M)  s]) if n>1: print n-=1"], "original_ll": -1.0750250816345215, "sampled_ll": -0.44643113017082214, "all_perturbed_sampled_ll": [-1.2694553136825562], "all_perturbed_original_ll": [-2.000091791152954], "perturbed_sampled_ll": -1.2694553136825562, "perturbed_original_ll": -2.000091791152954, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-7)\n\ntypedef struct {\n\tint x,y,r;\n} wall_t;\n\ntypedef struct {\n\tint tx,ty,sx,sy;\n} query_t;\n\nint hitcheck_circle(wall_t w,query_t q) {\n\tint in=0;\n\tint a,b,c;\n\tint minx,miny,maxx,maxy,temp;\n\t/* sieve */\n\tminx=q.tx;maxx=q.sx;\n\tif(minx>maxx){temp=minx;minx=maxx;maxx=temp;}\n\tminy=q.ty;maxy=q.sy;\n\tif(miny>maxy){temp=miny;miny=maxy;maxy=temp;}\n\tif(w.x+w.r<minx || maxx<w.x-w.r)return 0;\n\tif(w.y+w.r<miny || maxy<w.y-w.r)return 0;\n\t/* check if dist<=r */\n\tif((q.tx-w.x)*(q.tx-w.x)+(q.ty-w.y)*(q.ty-w.y)<=w.r*w.r)in++;\n\tif((q.sx-w.x)*(q.sx-w.x)+(q.sy-w.y)*(q.sy-w.y)<=w.r*w.r)in++;\n\tif(in==1)return 1;\n\tif(in==2)return 0;\n\ta=q.ty-q.sy;\n\tb=q.sx-q.tx;\n\tc=(q.tx-q.sx)*q.ty-(q.ty-q.sy)*q.tx;\n\tif((a*w.x+b*w.y+c)*(a*w.x+b*w.y+c)<=w.r*w.r*(a*a+b*b)) {\n\t\t/* check if really hit */\n\t\tc=-c; /* convert a*x+b*y+c=0 to a*x+b*y=c */\n\t\tif(b==0) {\n\t\t\tdouble yy=w.r*w.r-((double)c/a-w.x)*((double)c/a-w.x);\n\t\t\tdouble y1,y2;\n\t\t\ty1=sqrt(yy);y2=-y1;\n\t\t\ty1+=w.y;y2+=w.y;\n\t\t\treturn (miny<y1+EPS && y1<maxy+EPS) || (miny<y2+EPS && y2<maxy+EPS);\n\t\t} else {\n\t\t\tdouble cb=(double)c/b;\n\t\t\tdouble ab=(double)a/b;\n\t\t\tdouble x2k,xk,tk;\n\t\t\tdouble x1,x2;\n\t\t\tx2k=1.0+ab*ab;\n\t\t\txk=-2*w.x+2.0*(w.y-cb)*ab;\n\t\t\ttk=w.x*w.x+(w.y-cb)*(w.y-cb)-w.r*w.r;\n\t\t\tx1=(-xk+sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k);\n\t\t\tx2=(-xk-sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k);\n\t\t\treturn (minx<x1+EPS && x1<maxx+EPS) || (minx<x2+EPS && x2<maxx+EPS);\n\t\t}\n\t}\n\treturn 0;\n}\nint main(void) {\n\tint n;\n\twall_t w[100];\n\tint m;\n\tint i;\n\twhile(scanf(\"%d\",&n)==1 && n>0) {\n\t\tfor(i=0;i<n;i++)scanf(\"%d%d%d\",&w[i].x,&w[i].y,&w[i].r);\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<m;i++) {\n\t\t\tquery_t q;\n\t\t\tint j;\n\t\t\tint hidden;\n\t\t\tscanf(\"%d%d%d%d\",&q.tx,&q.ty,&q.sx,&q.sy);\n\t\t\thidden=0;\n\t\t\tif(q.tx!=q.sx || q.ty!=q.sy) {\n\t\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\t\tif(hitcheck_circle(w[j],q)) {\n\t\t\t\t\t\thidden=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tputs(hidden?\"Safe\":\"Danger\");\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point center;\n    double radius;\n} Circle;\n\nint isInsideCircle(Point p, Circle c) {\n    double dx = p.x - c.center.x;\n    double dy = p.y - c.center.y;\n    return (dx * dx + dy * dy) < (c.radius * c.radius);\n}\n\nint lineSegmentIntersectsCircle(Point p1, Point p2, Circle c) {\n    // Check if either endpoint is inside the circle\n    if (isInsideCircle(p1, c) || isInsideCircle(p2, c)) {\n        return 1;\n    }\n    \n    // Vector from p1 to p2\n    double dx = p2.x - p1.x;\n    double dy = p2.y - p1.y;\n    \n    // Vector from p1 to circle center\n    double fx = c.center.x - p1.x;\n    double fy = c.center.y - p1.y;\n    \n    // Project circle center onto line segment\n    double len_sq = dx * dx + dy * dy;\n    double t = (fx * dx + fy * dy) / len_sq;\n    \n    // Clamp t to [0, 1] to stay on segment\n    if (t < 0) t = 0;\n    if (t > 1) t = 1;\n    \n    // Find closest point on segment\n    double closest_x = p1.x + t * dx;\n    double closest_y = p1.y + t * dy;\n    \n    // Check distance from closest point to circle center\n    double dist_x = c.center.x - closest_x;\n    double dist_y = c.center.y - closest_y;\n    double dist_sq = dist_x * dist_x + dist_y * dist_y;\n    \n    return dist_sq < (c.radius * c.radius);\n}\n\nint isBlocked(Point taro, Point oni, Circle walls[], int n) {\n    // Check if Taro and Oni are both inside the same circle\n    for (int i = 0; i < n; i++) {\n        if (isInsideCircle(taro, walls[i]) && isInsideCircle(oni, walls[i])) {\n            // Both inside same wall, check if blocked by another wall\n            int blocked = 0;\n            for (int j = 0; j < n; j++) {\n                if (i != j && lineSegmentIntersectsCircle(taro, oni, walls[j])) {\n                    blocked = 1;\n                    break;\n                }\n            }\n            if (!blocked) {\n                return 0; // They can see each other\n            }\n        }\n    }\n    \n    // Check if line segment intersects any wall\n    for (int i = 0; i < n; i++) {\n        int taroInside = isInsideCircle(taro, walls[i]);\n        int oniInside = isInsideCircle(oni, walls[i]);\n        \n        // If one is inside and one is outside, blocked\n        if (taroInside != oniInside) {\n            return 1;\n        }\n        \n        // If both outside, check if line intersects wall\n        if (!taroInside && !oniInside) {\n            if (lineSegmentIntersectsCircle(taro, oni, walls[i])) {\n                return 1;\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Circle walls[100];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf %lf\", &walls[i].center.x, &walls[i].center.y, &walls[i].radius);\n        }\n        \n        int m;\n        scanf(\"%d\", &m);\n        \n        for (int i = 0; i < m; i++) {\n            Point taro, oni;\n            scanf(\"%lf %lf %lf %lf\", &taro.x, &taro.y, &oni.x, &oni.y);\n            \n            if (isBlocked(taro, oni, walls, n)) {\n                printf(\"Safe\\n\");\n            } else {\n                printf(\"Danger\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> typedef struct { double x, y; } Point; typedef struct { Point center; double radius; } Circle; int isInsideCircle(Point p, Circle c) { double dx = p.x - c.center.x; double dy = p.y - c.center.y; return (dx * dx + dy * dy) < (c.radius * c.radius); } int lineSegmentIntersectsCircle(Point p1, Point p2, Circle c) { // Check if either endpoint is inside the circle if (isInsideCircle(p1, c) || isInsideCircle(p2, c)) { return 1; } // Vector from p1 to p2 double dx = p2.x - p1.x; double dy = p2.y - p1.y; // Vector  p1.x; double fy = c.center.y - p1.y; // Project circle center onto line segment double len_sq = dx * dx + dy * dy; double t = (fx * dx + fy * dy) / len_sq; // Clamp  < 0) t  Find closest point on segment double closest_x = p1.x + t * dx; double closest_y = p1.y + t * dy; // Check distance from closest point to circle center double dist_x = c.center.x - closest_x; double dist_y = c.center.y - closest_y; double dist_sq = dist_x * dist_x + dist_y * dist_y; return dist_sq < (c.radius * c.radius); } int isBlocked(Point taro, Point oni, Circle walls[], int n) { // Check if Taro and Oni are both inside the same circle for (int i = 0; i < n; i++) { if (isInsideCircle(taro, walls[i]) && isInsideCircle(oni, walls[i]))  another  j <  walls[j])) { blocked = 1; break; } } if (!blocked) { return 0; // They can see each  any wall for (int i  isInsideCircle(taro, walls[i]); int oniInside = isInsideCircle(oni, walls[i]); // If one is inside and one is outside, blocked if (taroInside != oniInside) { return 1;  if (!taroInside && !oniInside) {  return 0; } int main() { int n; while (scanf(\"%d\", &n) == 1 && n != 0) {  i++) { scanf(\"%lf  { Point taro, oni; scanf(\"%lf %lf %lf %lf\", &taro.x, &taro.y, &oni.x,  { printf(\"Danger\\n\"); } } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> #define EPS (1e-7) typedef  tx,ty,sx,sy;  if(miny>maxy){temp=miny;miny=maxy;maxy=temp;} if(w.x+w.r<minx || maxx<w.x-w.r)return 0; if(w.y+w.r<miny || maxy<w.y-w.r)return 0; /* check if dist<=r */ if((q.tx-w.x)*(q.tx-w.x)+(q.ty-w.y)*(q.ty-w.y)<=w.r*w.r)in++; if((q.sx-w.x)*(q.sx-w.x)+(q.sy-w.y)*(q.sy-w.y)<=w.r*w.r)in++; if(in==1)return 1; if(in==2)return 0; a=q.ty-q.sy; b=q.sx-q.tx; c=(q.tx-q.sx)*q.ty-(q.ty-q.sy)*q.tx; if((a*w.x+b*w.y+c)*(a*w.x+b*w.y+c)<=w.r*w.r*(a*a+b*b)) { /* check if really hit */ c=-c; /* convert a*x+b*y+c=0 to a*x+b*y=c */ if(b==0) { double yy=w.r*w.r-((double)c/a-w.x)*((double)c/a-w.x); double y1,y2; y1=sqrt(yy);y2=-y1; y1+=w.y;y2+=w.y; return (miny<y1+EPS && y1<maxy+EPS) || (miny<y2+EPS && y2<maxy+EPS); } else { double cb=(double)c/b; double ab=(double)a/b; double x2k,xk,tk; double x1,x2; x2k=1.0+ab*ab; xk=-2*w.x+2.0*(w.y-cb)*ab; tk=w.x*w.x+(w.y-cb)*(w.y-cb)-w.r*w.r; x1=(-xk+sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k); x2=(-xk-sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k); return (minx<x1+EPS && x1<maxx+EPS) || (minx<x2+EPS && x2<maxx+EPS); } } return 0; } int main(void) { int n; wall_t w[100]; int m;  query_t q; int j; int hidden; scanf(\"%d%d%d%d\",&q.tx,&q.ty,&q.sx,&q.sy); hidden=0; if(q.tx!=q.sx || q.ty!=q.sy)  puts(hidden?\"Safe\":\"Danger\"); } } return 0; }"], "original_ll": -1.0586460828781128, "sampled_ll": -0.5832756161689758, "all_perturbed_sampled_ll": [-1.4215630292892456], "all_perturbed_original_ll": [-1.5314114093780518], "perturbed_sampled_ll": -1.4215630292892456, "perturbed_original_ll": -1.5314114093780518, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> Ans = new ArrayList<Integer>();\n\t\tString line;\n\n\t\twhile((line = in.readLine()) != null){\n\t\t\tint nTube = Integer.parseInt(line);\n\n\t\t\tif(nTube==0) break;\n\n\t\t\tTube[] tubes = new Tube[nTube];\n\t\t\tfor(int n=0; n<nTube; n++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tint x = Integer.parseInt(dst[0]);\n\t\t\t\tint y = Integer.parseInt(dst[1]);\n\t\t\t\tint r = Integer.parseInt(dst[2]);\n\t\t\t\ttubes[n] = new Tube(x, y, r);\n\t\t\t}\n\n\t\t\tline = in.readLine();\n\t\t\tint nSet = Integer.parseInt(line);\n\t\t\tfor(int n=0; n<nSet; n++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tdouble x1 = Double.parseDouble(dst[0]);\n\t\t\t\tdouble y1 = Double.parseDouble(dst[1]);\n\t\t\t\tdouble x2 = Double.parseDouble(dst[2]);\n\t\t\t\tdouble y2 = Double.parseDouble(dst[3]);\n\n\t\t\t\tint hide = 0;\n\t\t\t\tfor(int m=0; m<tubes.length; m++){\n\t\t\t\t\tdouble a, b, c, d, e1, e2, x0, min, max;\n\t\t\t\t\tif(x1 != x2){\n\t\t\t\t\t\tdouble p = (y1 - y2) / (x1 - x2);\n\t\t\t\t\t\tdouble q = y1 - p * x1;\n\t\t\t\t\t\ta = p * p + 1.0;\n\t\t\t\t\t\tb = 2.0 * p * (q - tubes[m].y) - 2.0 * tubes[m].x;\n\t\t\t\t\t\tc = Math.pow(tubes[m].x, 2.0) + Math.pow(q - tubes[m].y, 2.0) - Math.pow(tubes[m].r, 2.0);\n\t\t\t\t\t\td = b * b - 4.0 * a * c;\n\t\t\t\t\t\te1 = a * x1 * x1 + b * x1 + c;\n\t\t\t\t\t\te2 = a * x2 * x2 + b * x2 + c;\n\t\t\t\t\t\tx0 = - b / (2.0 * a);\n\t\t\t\t\t\tmin = Math.min(x1, x2);\n\t\t\t\t\t\tmax = Math.max(x1, x2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta = 1.0;\n\t\t\t\t\t\tb = -2.0 * tubes[m].y;\n\t\t\t\t\t\tc = Math.pow(tubes[m].y, 2.0) + Math.pow(x1 - tubes[m].x, 2.0) - Math.pow(tubes[m].r, 2.0);\n\t\t\t\t\t\td = b * b - 4.0 * a * c;\n\t\t\t\t\t\te1 = a * y1 * y1 + b * y1 + c;\n\t\t\t\t\t\te2 = a * y2 * y2 + b * y2 + c;\n\t\t\t\t\t\tx0 = - b / (2.0 * a);\n\t\t\t\t\t\tmin = Math.min(y1, y2);\n\t\t\t\t\t\tmax = Math.max(y1, y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(x0 >= min && x0 <= max){\n\t\t\t\t\t\tif(d*e1 >= 0 || d*e2 >= 0){\n\t\t\t\t\t\t\tAns.add(1);\n\t\t\t\t\t\t\thide = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(e1 * e2 <= 0){\n\t\t\t\t\t\t\tAns.add(1);\n\t\t\t\t\t\t\thide = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(hide == 0){\n\t\t\t\t\tAns.add(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tint i = Ans.get(n);\n\t\t\tif(i==1){\n\t\t\t\tSystem.out.println(\"Safe\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"Danger\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Tube{\n\tdouble x;\n\tdouble y;\n\tdouble r;\n\n\tpublic Tube(int x, int y, int r){\n\t\tthis.x = (double)x;\n\t\tthis.y = (double)y;\n\t\tthis.r = (double)r;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Circle {\n        double x, y, r;\n        Circle(double x, double y, double r) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            Circle[] walls = new Circle[n];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                double wx = Double.parseDouble(parts[0]);\n                double wy = Double.parseDouble(parts[1]);\n                double r = Double.parseDouble(parts[2]);\n                walls[i] = new Circle(wx, wy, r);\n            }\n            \n            int m = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < m; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                double tx = Double.parseDouble(parts[0]);\n                double ty = Double.parseDouble(parts[1]);\n                double sx = Double.parseDouble(parts[2]);\n                double sy = Double.parseDouble(parts[3]);\n                \n                boolean visible = isVisible(tx, ty, sx, sy, walls);\n                System.out.println(visible ? \"Danger\" : \"Safe\");\n            }\n        }\n    }\n    \n    static boolean isVisible(double tx, double ty, double sx, double sy, Circle[] walls) {\n        // Check if both points are inside the same wall\n        for (Circle wall : walls) {\n            boolean tInside = isInside(tx, ty, wall);\n            boolean sInside = isInside(sx, sy, wall);\n            \n            if (tInside && sInside) {\n                // Both inside same wall - check if line segment intersects any other wall\n                boolean blocked = false;\n                for (Circle other : walls) {\n                    if (other == wall) continue;\n                    if (lineIntersectsCircle(tx, ty, sx, sy, other)) {\n                        blocked = true;\n                        break;\n                    }\n                }\n                if (!blocked) return true;\n            } else if (tInside || sInside) {\n                // One inside, one outside - not visible\n                return false;\n            }\n        }\n        \n        // Both outside all walls - check if line segment intersects any wall\n        for (Circle wall : walls) {\n            if (lineIntersectsCircle(tx, ty, sx, sy, wall)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    static boolean isInside(double px, double py, Circle circle) {\n        double dx = px - circle.x;\n        double dy = py - circle.y;\n        return dx * dx + dy * dy < circle.r * circle.r;\n    }\n    \n    static boolean lineIntersectsCircle(double x1, double y1, double x2, double y2, Circle circle) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double fx = x1 - circle.x;\n        double fy = y1 - circle.y;\n        \n        double a = dx * dx + dy * dy;\n        double b = 2 * (fx * dx + fy * dy);\n        double c = fx * fx + fy * fy - circle.r * circle.r;\n        \n        double discriminant = b * b - 4 * a * c;\n        \n        if (discriminant < 0) {\n            return false;\n        }\n        \n        double sqrtDisc = Math.sqrt(discriminant);\n        double t1 = (-b - sqrtDisc) / (2 * a);\n        double t2 = (-b + sqrtDisc) / (2 * a);\n        \n        // Check if intersection points are within the line segment\n        if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {\n            return true;\n        }\n        \n        // Check if the segment is completely inside the circle\n        if (t1 < 0 && t2 > 1) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class Circle { double x, y, r; Circle(double x, double y, double r) { this.x = x; this.y = y; this.r = r; } } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { int n = Integer.parseInt(line.trim()); if (n == 0) break; Circle[] walls = new Circle[n]; for (int  = br.readLine().trim().split(\"\\\\s+\"); double wx = Double.parseDouble(parts[0]); double wy = Double.parseDouble(parts[1]); double  i < m; i++) { String[] parts  double sx = Double.parseDouble(parts[2]); double sy = Double.parseDouble(parts[3]); boolean visible = isVisible(tx, ty, sx, sy, walls); System.out.println(visible ? \"Danger\" :  double sx, double sy, Circle[] walls) { // Check if both  walls) { boolean tInside = isInside(tx, ty, wall); boolean sInside = isInside(sx, sy,  wall - check if line segment intersects any other wall boolean blocked = false; for (Circle other : walls) { if (other == wall) continue; if (lineIntersectsCircle(tx,   walls - check if  { if (lineIntersectsCircle(tx, ty, sx, sy, wall)) { return false; } } return true; } static boolean isInside(double px, double py, Circle circle) { double dx = px - circle.x; double dy = py - circle.y; return dx  } static boolean lineIntersectsCircle(double x1, double y1, double x2, double y2, Circle  = y2 - y1; double fx = x1 - circle.x; double fy = y1 - circle.y; double a = dx * dx + dy * dy; double b = 2 * (fx * dx + fy * dy); double c = fx * fx  = b * b - 4 * a * c; if (discriminant < 0) { return false; } double sqrtDisc = Math.sqrt(discriminant); double t1 = (-b - sqrtDisc) / (2 * a); double t2 = (-b + sqrtDisc) / (2 * a); // Check if intersection points are within the line segment if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) { return true; } // Check if the segment is completely inside the circle if (t1 < 0 && t2 > 1) { return true; } return false; } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static void main(String args[]){ try{ new Main(); }catch(IOException e){ e.printStackTrace(); } } public Main() throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); List<Integer> Ans = new ArrayList<Integer>(); String line; while((line =   in.readLine(); String[] dst = line.split(\" \"); int x = Integer.parseInt(dst[0]); int y = Integer.parseInt(dst[1]); int r = Integer.parseInt(dst[2]); tubes[n] = new Tube(x, y, r); } line = in.readLine(); int nSet = Integer.parseInt(line); for(int n=0; n<nSet; n++){ line = in.readLine(); String[] dst = line.split(\" \"); double x1 = Double.parseDouble(dst[0]); double y1 = Double.parseDouble(dst[1]); double x2 = Double.parseDouble(dst[2]); double y2 = Double.parseDouble(dst[3]); int  c, d, e1, e2, x0, min, max; if(x1 != x2){ double p = (y1 - y2) /  x1; a = p * p + 1.0; b = 2.0 * p * (q - tubes[m].y) - 2.0 * tubes[m].x; c = Math.pow(tubes[m].x, 2.0) + Math.pow(q - tubes[m].y, 2.0) - Math.pow(tubes[m].r, 2.0); d = b * b - 4.0 * a *  * x1 + c; e2 = a * x2 * x2 + b * x2 + c; x0 = - b / (2.0 * a); min = Math.min(x1, x2); max = Math.max(x1, x2); } else{ a = 1.0; b = -2.0 * tubes[m].y; c = Math.pow(tubes[m].y, 2.0) + Math.pow(x1 - tubes[m].x, 2.0) - Math.pow(tubes[m].r, 2.0); d = b * b - 4.0 * a * c; e1 = a * y1 * y1 + b * y1 +  * y2 + c; x0 = - b / (2.0 * a); min = Math.min(y1, y2); max = Math.max(y1, y2); } if(x0 >= min  0){ Ans.add(1); hide = 1; break; } } else{ if(e1 * e2 <= 0){ Ans.add(1);  i = Ans.get(n); if(i==1){ System.out.println(\"Safe\");   (double)r; } }"], "original_ll": -0.6500680446624756, "sampled_ll": -0.4632396697998047, "all_perturbed_sampled_ll": [-1.3342489004135132], "all_perturbed_original_ll": [-1.26414155960083], "perturbed_sampled_ll": -1.3342489004135132, "perturbed_original_ll": -1.26414155960083, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math as M\ndef R(A): return (A[0]**2+A[1]**2)**.5\ndef I(i): return [map(int,raw_input().split()) for _ in [0]*i]\ndef C(a,b): return a>b or abs(a-b)<1e-6\ndef f(e1):\n  tx,ty,sx,sy=e1\n  x=[]\n  for e2 in WP:\n    wx,wy,r=e2\n    wt=[tx-wx,ty-wy]; rwt=R(wt)\n    sw=[wx-sx,wy-sy]; rsw=R(sw)\n    st=[tx-sx,ty-sy]; rst=R(st)\n    F=[rwt<r,rsw<r]\n    if rst==0: c=1\n    elif F==[1,1]: c=1\n    elif F==[1,0] or F==[0,1]: c=0\n    elif F==[0,0]:\n      c=0\n      a=M.pi/2-M.acos(r/rsw)\n      b=M.acos((sw[0]*st[0]+sw[1]*st[1])/rsw/rst)\n#      if C(a,b) and C(rst**2,rsw**2-r**2): c=0\n#      else: c=1\n    x.append(c)\n  return all(x)\n\nwhile 1:\n  n=input()\n  if n==0: break\n  WP=I(n)\n  P=I(input())\n  for e in P: print [\"Safe\",\"Danger\"][f(e)]", "sampled": "import math\n\ndef point_in_circle(px, py, cx, cy, r):\n    dist_sq = (px - cx) ** 2 + (py - cy) ** 2\n    return dist_sq < r ** 2\n\ndef line_segment_intersects_circle(x1, y1, x2, y2, cx, cy, r):\n    # Check if either endpoint is inside the circle\n    if point_in_circle(x1, y1, cx, cy, r) or point_in_circle(x2, y2, cx, cy, r):\n        return True\n    \n    # Vector from point 1 to point 2\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    # Vector from point 1 to circle center\n    fx = x1 - cx\n    fy = y1 - cy\n    \n    # Quadratic equation coefficients for line-circle intersection\n    a = dx * dx + dy * dy\n    b = 2 * (fx * dx + fy * dy)\n    c = fx * fx + fy * fy - r * r\n    \n    discriminant = b * b - 4 * a * c\n    \n    if discriminant < 0:\n        return False\n    \n    # Check if intersection points are within the line segment\n    sqrt_discriminant = math.sqrt(discriminant)\n    t1 = (-b - sqrt_discriminant) / (2 * a)\n    t2 = (-b + sqrt_discriminant) / (2 * a)\n    \n    # Check if any t is in [0, 1]\n    if (0 <= t1 <= 1) or (0 <= t2 <= 1):\n        return True\n    \n    return False\n\ndef is_visible(tx, ty, sx, sy, walls):\n    # Check if both Taro and Oni are inside the same wall\n    taro_walls = []\n    oni_walls = []\n    \n    for wx, wy, r in walls:\n        if point_in_circle(tx, ty, wx, wy, r):\n            taro_walls.append((wx, wy, r))\n        if point_in_circle(sx, sy, wx, wy, r):\n            oni_walls.append((wx, wy, r))\n    \n    # If they are both inside the same wall\n    for tw in taro_walls:\n        if tw in oni_walls:\n            # They are in the same wall, check if any other wall blocks\n            for wx, wy, r in walls:\n                if (wx, wy, r) != tw:\n                    if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r):\n                        return False\n            return True\n    \n    # If one is inside a wall and the other is not, they can't see each other\n    if len(taro_walls) > 0 or len(oni_walls) > 0:\n        return False\n    \n    # Both are outside all walls, check if any wall blocks the line of sight\n    for wx, wy, r in walls:\n        if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r):\n            return False\n    \n    return True\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    walls = []\n    for _ in range(n):\n        wx, wy, r = map(int, input().split())\n        walls.append((wx, wy, r))\n    \n    m = int(input())\n    for _ in range(m):\n        tx, ty, sx, sy = map(int, input().split())\n        if is_visible(tx, ty, sx, sy, walls):\n            print(\"Danger\")\n        else:\n            print(\"Safe\")\n", "perturbed_sampled": ["import math def point_in_circle(px, py, cx, cy, r): dist_sq = (px - cx) ** 2 + (py - cy) ** 2  y2, cx, cy, r): # Check if either endpoint is inside the circle if point_in_circle(x1, y1, cx, cy, r) or point_in_circle(x2, y2, cx, cy, r): return True # Vector from point 1 to point 2 dx = x2 - x1 dy = y2 - y1 # Vector from point 1 to  - cy # Quadratic equation coefficients for line-circle intersection a =  * (fx * dx + fy * dy) c = fx * fx + fy * fy - r * r discriminant = b * b - 4 * a * c if discriminant < 0:  line segment  *  # Check if any t is in [0, 1] if (0 <= t1 <= 1) or (0 <= t2 <= 1): return True return False def is_visible(tx, ty, sx, sy, walls): # Check if both Taro and Oni are inside the same wall taro_walls = [] oni_walls = [] for wx, wy, r in walls: if point_in_circle(tx, ty, wx, wy, r):  wy, r)) # If they  if tw in oni_walls: # They are in  wx, wy, r in walls: if (wx, wy, r) != tw: if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r): return False return True # If  or len(oni_walls) > 0: return False # Both are outside all walls, check if any wall blocks the line of sight for wx, wy, r in walls: if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r): return False return True while True: n = int(input()) if  range(n): wx, wy, r = map(int, input().split()) walls.append((wx, wy, r)) m = int(input()) for _ in range(m): tx, ty, sx, sy = map(int, input().split()) if is_visible(tx, ty, sx, sy, walls): print(\"Danger\") else: print(\"Safe\")"], "perturbed_original": ["import math as M def R(A): return (A[0]**2+A[1]**2)**.5 def  a>b or abs(a-b)<1e-6 def f(e1): tx,ty,sx,sy=e1 x=[] for e2 in WP: wx,wy,r=e2 wt=[tx-wx,ty-wy];  F==[1,1]: c=1 elif F==[1,0] or F==[0,1]: c=0 elif F==[0,0]: c=0 a=M.pi/2-M.acos(r/rsw) b=M.acos((sw[0]*st[0]+sw[1]*st[1])/rsw/rst) # if C(a,b) and C(rst**2,rsw**2-r**2): c=0 # else: c=1 x.append(c) return all(x) while 1: n=input() if n==0: break WP=I(n) P=I(input()) for e in P: print [\"Safe\",\"Danger\"][f(e)]"], "original_ll": -1.749093770980835, "sampled_ll": -0.6696426272392273, "all_perturbed_sampled_ll": [-1.6785191297531128], "all_perturbed_original_ll": [-2.625140428543091], "perturbed_sampled_ll": -1.6785191297531128, "perturbed_original_ll": -2.625140428543091, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\nint n,i,j,p;\nchar c,t,l[27];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tgetchar();\n\tfor(i=0;i<n;i++)\n\t{\n\t\tp=13;\n\t\tmemset(l,0,27);\n\t\tfor(;scanf(\"%c\",&l[p])!=-1;)\n\t\t{\n\t\t\t~scanf(\"%c\",&c);\n\t\t\tif(c=='-'||c=='<')\n\t\t\t\tgetchar(),c=='-'?p++:p--;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(j=0;!l[j];j++);\n\t\tputs(l+j);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    getchar();\n    \n    for (int i = 0; i < n; i++) {\n        char line[1025];\n        fgets(line, 1025, stdin);\n        \n        // Parse the movements\n        char cars[26];\n        int carCount = 0;\n        int carPos[26]; // Position of each car (a-z)\n        for (int j = 0; j < 26; j++) {\n            carPos[j] = -1;\n        }\n        \n        // Parse first car\n        char currentCar = line[0];\n        cars[carCount] = currentCar;\n        carPos[currentCar - 'a'] = carCount;\n        carCount++;\n        \n        int pos = 0;\n        int minPos = 0, maxPos = 0;\n        \n        // Parse movements\n        int idx = 1;\n        while (line[idx] != '\\0' && line[idx] != '\\n') {\n            // Read direction\n            char dir[3];\n            dir[0] = line[idx];\n            dir[1] = line[idx + 1];\n            dir[2] = '\\0';\n            idx += 2;\n            \n            // Read next car\n            char nextCar = line[idx];\n            idx++;\n            \n            int nextCarIdx = nextCar - 'a';\n            \n            if (strcmp(dir, \"->\") == 0) {\n                // Moving to next car (right)\n                if (carPos[nextCarIdx] == -1) {\n                    // New car on the right\n                    pos++;\n                    carPos[nextCarIdx] = pos;\n                    if (pos > maxPos) maxPos = pos;\n                } else {\n                    pos = carPos[nextCarIdx];\n                }\n            } else { // \"<-\"\n                // Moving to previous car (left)\n                if (carPos[nextCarIdx] == -1) {\n                    // New car on the left\n                    pos--;\n                    carPos[nextCarIdx] = pos;\n                    if (pos < minPos) minPos = pos;\n                } else {\n                    pos = carPos[nextCarIdx];\n                }\n            }\n        }\n        \n        // Build result string\n        int length = maxPos - minPos + 1;\n        char result[27];\n        for (int j = 0; j < length; j++) {\n            result[j] = ' ';\n        }\n        result[length] = '\\0';\n        \n        for (int j = 0; j < 26; j++) {\n            if (carPos[j] != -1) {\n                int actualPos = carPos[j] - minPos;\n                result[actualPos] = 'a' + j;\n            }\n        }\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int main() { int n; scanf(\"%d\", &n); getchar(); for (int i = 0; i < n; i++) { char line[1025]; fgets(line, 1025, stdin); // Parse the  Position of each car (a-z) for (int j = 0; j < 26; j++) { carPos[j] = -1; } // Parse first car char currentCar = line[0]; cars[carCount] = currentCar; carPos[currentCar - 'a'] = carCount; carCount++; int pos = 0; int minPos = 0, maxPos = 0; //   dir[0] = line[idx]; dir[1] = line[idx + 1]; dir[2] = '\\0'; idx += 2; // Read next car char nextCar = line[idx];  == 0) { // Moving to next car (right) if  pos++;  { // \"<-\" // Moving to previous car (left) if (carPos[nextCarIdx] == -1) { // New car on the left pos--; carPos[nextCarIdx] = pos; if (pos < minPos) minPos = pos; } else { pos = carPos[nextCarIdx]; } } } // Build result string  for (int j = 0; j < length; j++) { result[j] = ' '; } result[length] = '\\0'; for (int j = 0; j < 26; j++) { if (carPos[j] != -1) { int actualPos = carPos[j] - minPos; result[actualPos] = 'a' + j; } } printf(\"%s\\n\", result); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> int n,i,j,p; char c,t,l[27]; int main() { scanf(\"%d\",&n); getchar(); for(i=0;i<n;i++) { p=13; memset(l,0,27); for(;scanf(\"%c\",&l[p])!=-1;) { ~scanf(\"%c\",&c); if(c=='-'||c=='<') getchar(),c=='-'?p++:p--; else break; } for(j=0;!l[j];j++); puts(l+j); } return 0; }"], "original_ll": -1.661453127861023, "sampled_ll": -0.6973742842674255, "all_perturbed_sampled_ll": [-1.3591361045837402], "all_perturbed_original_ll": [-1.9507970809936523], "perturbed_sampled_ll": -1.3591361045837402, "perturbed_original_ll": -1.9507970809936523, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "package jp.ac.saburou.volume1;\n\nimport java.util.Scanner;\n\nclass p130 {\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint[][] result = null;\n\t\tfor (int t = 0; t < n; t++) {\n\t\t\tchar[] train = s.next().toCharArray();\n\t\t\tif (train.length > 1) {\n\t\t\t\tresult = createTrainGraph(train);\n\t\t\t\t/* \u5148\u982d\u8eca\u4e21\u3092\u6c7a\u5b9a\u3059\u308b */\n\t\t\t\tint next = NO_CONNECTION;\n\t\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\t\tif (result[i][0] == NO_CONNECTION\n\t\t\t\t\t\t\t&& result[i][1] != NO_CONNECTION) {\n\t\t\t\t\t\tnext = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* \u51fa\u529b */\n\t\t\t\twhile (next != -1) {\n\t\t\t\t\tSystem.out.printf(\"%c\", next + 'a');\n\t\t\t\t\tnext = result[next][REAR];\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t} else {\n\t\t\t\tSystem.out.println(train[0]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic final int FRONT = 0;\n\tstatic final int REAR = 1;\n\tstatic final int NO_CONNECTION = -1;\n\n\tstatic int[][] createTrainGraph(char[] input) {\n\t\tint[][] train = new int[26][2];\n\t\tfor (int i = 0; i < train.length; i++) {\n\t\t\tfor (int j = 0; j < train[0].length; j++) {\n\t\t\t\ttrain[i][j] = NO_CONNECTION;\n\t\t\t}\n\t\t}\n\t\tboolean front = false;\n\t\tint before = input[0];\n\t\tfor (int i = 1; i < input.length; i++) {\n\t\t\tint current = input[i];\n\t\t\tif ('a' <= current && current <= 'z') {\n\t\t\t\tif (front) {\n\t\t\t\t\ttrain[before - 'a'][FRONT] = current - 'a';\n\t\t\t\t\ttrain[current - 'a'][REAR] = before - 'a';\n\t\t\t\t} else {\n\t\t\t\t\ttrain[before - 'a'][REAR] = current - 'a';\n\t\t\t\t\ttrain[current - 'a'][FRONT] = before - 'a';\n\t\t\t\t}\n\t\t\t\tbefore = current;\n\t\t\t} else if (current == '>') {\n\t\t\t\tfront = false;\n\t\t\t} else if (current == '<') {\n\t\t\t\tfront = true;\n\t\t\t}\n\t\t}\n\t\treturn train;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            System.out.println(solve(line));\n        }\n        sc.close();\n    }\n    \n    static String solve(String record) {\n        String[] tokens = record.split(\"(<-|->)\");\n        String[] directions = record.split(\"[a-z]\");\n        \n        Map<Character, Set<Character>> next = new HashMap<>();\n        Map<Character, Set<Character>> prev = new HashMap<>();\n        Set<Character> cars = new HashSet<>();\n        \n        for (String token : tokens) {\n            if (!token.isEmpty()) {\n                char c = token.charAt(0);\n                cars.add(c);\n                next.putIfAbsent(c, new HashSet<>());\n                prev.putIfAbsent(c, new HashSet<>());\n            }\n        }\n        \n        for (int i = 0; i < tokens.length - 1; i++) {\n            char from = tokens[i].charAt(0);\n            char to = tokens[i + 1].charAt(0);\n            String dir = directions[i + 1];\n            \n            if (dir.equals(\"->\")) {\n                next.get(from).add(to);\n                prev.get(to).add(from);\n            } else {\n                prev.get(from).add(to);\n                next.get(to).add(from);\n            }\n        }\n        \n        // Build the train\n        List<Character> train = new ArrayList<>();\n        \n        // Find a starting car (one with no prev or just one end)\n        char start = ' ';\n        for (char c : cars) {\n            Set<Character> p = prev.get(c);\n            Set<Character> n = next.get(c);\n            \n            // Remove inconsistencies\n            p.removeAll(n);\n            n.removeAll(p);\n            \n            if (p.isEmpty()) {\n                start = c;\n                break;\n            }\n        }\n        \n        if (start == ' ') {\n            start = cars.iterator().next();\n        }\n        \n        // Build forward\n        Set<Character> visited = new HashSet<>();\n        char current = start;\n        train.add(current);\n        visited.add(current);\n        \n        while (true) {\n            Set<Character> nextCars = next.get(current);\n            nextCars.removeAll(prev.get(current));\n            \n            char nextCar = ' ';\n            for (char c : nextCars) {\n                if (!visited.contains(c)) {\n                    nextCar = c;\n                    break;\n                }\n            }\n            \n            if (nextCar == ' ') break;\n            \n            train.add(nextCar);\n            visited.add(nextCar);\n            current = nextCar;\n        }\n        \n        // Build backward from start\n        current = start;\n        while (true) {\n            Set<Character> prevCars = prev.get(current);\n            prevCars.removeAll(next.get(current));\n            \n            char prevCar = ' ';\n            for (char c : prevCars) {\n                if (!visited.contains(c)) {\n                    prevCar = c;\n                    break;\n                }\n            }\n            \n            if (prevCar == ' ') break;\n            \n            train.add(0, prevCar);\n            visited.add(prevCar);\n            current = prevCar;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : train) {\n            result.append(c);\n        }\n        \n        return result.toString();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static  n = sc.nextInt(); sc.nextLine(); for (int i = 0; i < n; i++) { String line = sc.nextLine(); System.out.println(solve(line)); } sc.close(); } static String solve(String record) { String[] tokens = record.split(\"(<-|->)\"); String[] directions  prev = new HashMap<>(); Set<Character> cars = new HashSet<>(); for (String token :  next.putIfAbsent(c, new HashSet<>());  i < tokens.length - 1; i++) {  String dir = directions[i +  next.get(to).add(from); }  // Find a starting car (one with no prev or just one end) char start = ' '; for (char c : cars) { Set<Character> p = prev.get(c); Set<Character> n = next.get(c); // Remove inconsistencies p.removeAll(n); n.removeAll(p); if (p.isEmpty()) { start = c; break; } } if (start == ' ') { start = cars.iterator().next(); } // Build forward Set<Character> visited = new HashSet<>(); char current = start; train.add(current); visited.add(current); while (true) { Set<Character> nextCars = next.get(current); nextCars.removeAll(prev.get(current)); char nextCar = ' '; for (char c : nextCars) { if (!visited.contains(c)) { nextCar = c; break; } } if (nextCar == ' ') break;  start current = start; while (true) { Set<Character> prevCars = prev.get(current); prevCars.removeAll(next.get(current)); char prevCar = ' '; for (char c : prevCars) { if (!visited.contains(c)) { prevCar = c; break; } } if (prevCar == ' ') break; train.add(0, prevCar); visited.add(prevCar); current = prevCar; } StringBuilder result  } return result.toString(); } }"], "perturbed_original": ["package jp.ac.saburou.volume1; import  Scanner s = new Scanner(System.in); int n = s.nextInt(); int[][] result = null; for (int t = 0; t < n; t++) { char[] train =  \u5148\u982d\u8eca\u4e21\u3092\u6c7a\u5b9a\u3059\u308b */ int next = NO_CONNECTION; for (int i = 0; i < result.length; i++) { if (result[i][0] == NO_CONNECTION && result[i][1] != NO_CONNECTION) { next = i; } } /* \u51fa\u529b */ while (next != -1) { System.out.printf(\"%c\", next + 'a'); next = result[next][REAR]; } System.out.println(); } else { System.out.println(train[0]); } } } static final int FRONT = 0; static final int REAR = 1; static final int NO_CONNECTION = -1; static int[][] createTrainGraph(char[] input) { int[][] train = new int[26][2];  for (int j  } } boolean front = false; int before = input[0]; for (int i = 1; i < input.length;  && current <= 'z') { if (front) { train[before - 'a'][FRONT] = current - 'a'; train[current - 'a'][REAR] =  current - 'a'; train[current - 'a'][FRONT] = before - 'a'; } before = current; } else if (current == '>') {  front = true; } } return train; } }"], "original_ll": -0.8345298767089844, "sampled_ll": -0.6184890866279602, "all_perturbed_sampled_ll": [-1.621416687965393], "all_perturbed_original_ll": [-1.730302333831787], "perturbed_sampled_ll": -1.621416687965393, "perturbed_original_ll": -1.730302333831787, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# AOJ 0130 Train\n# Python3 2018.6.19 bal4u\n\nfor _ in range(int(input())):\n\ts = list(input())\n\tans = []\n\tdir = '>'\n\tfor i in range(len(s)):\n\t\tif s[i].isalpha():\n\t\t\tif dir == '>':\n\t\t\t\tif s[i] not in ans: ans.append(s[i])\n\t\t\telse:\n\t\t\t\tif s[i] not in ans: ans.insert(0, s[i])\n\t\telif s[i] == '>' or s[i] == '<': dir = s[i]\n\tprint(*ans, sep='')\n", "sampled": "def solve(s):\n    # Parse the movements\n    tokens = s.replace('<-', ' <- ').replace('->', ' -> ').split()\n    \n    # Build adjacency relationships\n    cars = set()\n    neighbors = {}\n    \n    current = tokens[0]\n    cars.add(current)\n    \n    i = 1\n    while i < len(tokens):\n        direction = tokens[i]\n        next_car = tokens[i + 1]\n        cars.add(next_car)\n        \n        if current not in neighbors:\n            neighbors[current] = set()\n        if next_car not in neighbors:\n            neighbors[next_car] = set()\n        \n        neighbors[current].add(next_car)\n        neighbors[next_car].add(current)\n        \n        current = next_car\n        i += 2\n    \n    # Find the train composition (it forms a path)\n    # Find cars with degree 1 (endpoints)\n    endpoints = []\n    for car in cars:\n        if car not in neighbors or len(neighbors[car]) == 1:\n            endpoints.append(car)\n    \n    # If no endpoints found (circular), pick any car\n    if not endpoints:\n        endpoints = [list(cars)[0]]\n    \n    # Build the path from one endpoint\n    start = endpoints[0]\n    path = [start]\n    visited = {start}\n    current = start\n    \n    while True:\n        if current not in neighbors:\n            break\n        next_found = False\n        for next_car in neighbors[current]:\n            if next_car not in visited:\n                path.append(next_car)\n                visited.add(next_car)\n                current = next_car\n                next_found = True\n                break\n        if not next_found:\n            break\n    \n    return ''.join(path)\n\nn = int(input())\nfor _ in range(n):\n    s = input().strip()\n    print(solve(s))\n", "perturbed_sampled": ["def solve(s): # Parse the movements tokens = s.replace('<-', ' <- ').replace('->', ' -> ').split() # Build adjacency relationships cars = set() neighbors = {} current = tokens[0] cars.add(current)  next_car = tokens[i + 1] cars.add(next_car) if current not in neighbors: neighbors[current] = set() if next_car not in neighbors: neighbors[next_car] = set() neighbors[current].add(next_car) neighbors[next_car].add(current) current = next_car i += 2 # Find the train composition (it forms a path) # Find cars with degree 1 (endpoints) endpoints = [] for car in cars: if car not in neighbors or len(neighbors[car]) == 1: endpoints.append(car) # If no endpoints found (circular), pick any car if not endpoints: endpoints = [list(cars)[0]] # Build the  visited = {start} current =  in visited: path.append(next_car) visited.add(next_car) current = next_car next_found = True break  _ in range(n): s = input().strip() print(solve(s))"], "perturbed_original": ["# AOJ 0130 Train # Python3 2018.6.19 bal4u for _ in range(int(input())): s = list(input()) ans = [] dir = '>' for i in range(len(s)): if s[i].isalpha(): if dir == '>': if s[i] not in ans: ans.append(s[i]) else: if s[i]  s[i] == '<': dir = s[i] print(*ans, sep='')"], "original_ll": -1.5715724229812622, "sampled_ll": -1.0423117876052856, "all_perturbed_sampled_ll": [-2.2316250801086426], "all_perturbed_original_ll": [-2.4123611450195312], "perturbed_sampled_ll": -2.2316250801086426, "perturbed_original_ll": -2.4123611450195312, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint i,j,n,s[12][12],a[12][12];\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tfor(i=0;i<10;i++)for(j=0;j<10;j++)scanf(\"%d\",&s[i][j]);\n\t\tmemset(a,0,sizeof(a));\n\t\tfor(i=0;i<9;i++){\n\t\t\tfor(j=0;j<10;j++){\n\t\t\t\tif(s[i][j]%2==1){\n\t\t\t\t\ta[i+1][j]=1;\n\t\t\t\t\ts[i][j]++;\n\t\t\t\t\ts[i+1][j]++;\n\t\t\t\t\ts[i+1][j-1]++;\n\t\t\t\t\ts[i+1][j+1]++;\n\t\t\t\t\ts[i+2][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<10;i++){for(j=0;j<10;j++)printf(\"%d \",a[i][j]);printf(\"\\n\");}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int grid[10][10];\n        int solution[10][10] = {0};\n        \n        // Read input\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        \n        // Solve using Gaussian elimination in GF(2)\n        // Each cell (i,j) being hit affects itself and neighbors\n        // We need to solve: A*x = b where A is the effect matrix\n        \n        // Create augmented matrix\n        int matrix[100][101];\n        for (int i = 0; i < 100; i++) {\n            for (int j = 0; j <= 100; j++) {\n                matrix[i][j] = 0;\n            }\n        }\n        \n        // Build the system of equations\n        for (int row = 0; row < 10; row++) {\n            for (int col = 0; col < 10; col++) {\n                int eq = row * 10 + col;\n                matrix[eq][100] = grid[row][col];\n                \n                // Check which positions affect this cell\n                for (int r = 0; r < 10; r++) {\n                    for (int c = 0; c < 10; c++) {\n                        int var = r * 10 + c;\n                        // Position (r,c) affects (row,col) if:\n                        // - (r,c) == (row,col) or\n                        // - (r,c) is adjacent to (row,col)\n                        if ((r == row && c == col) ||\n                            (r == row && (c == col-1 || c == col+1)) ||\n                            (c == col && (r == row-1 || r == row+1))) {\n                            matrix[eq][var] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Gaussian elimination in GF(2)\n        for (int col = 0; col < 100; col++) {\n            // Find pivot\n            int pivot = -1;\n            for (int row = col; row < 100; row++) {\n                if (matrix[row][col] == 1) {\n                    pivot = row;\n                    break;\n                }\n            }\n            \n            if (pivot == -1) continue;\n            \n            // Swap rows\n            if (pivot != col) {\n                for (int j = 0; j <= 100; j++) {\n                    int temp = matrix[col][j];\n                    matrix[col][j] = matrix[pivot][j];\n                    matrix[pivot][j] = temp;\n                }\n            }\n            \n            // Eliminate\n            for (int row = 0; row < 100; row++) {\n                if (row != col && matrix[row][col] == 1) {\n                    for (int j = 0; j <= 100; j++) {\n                        matrix[row][j] ^= matrix[col][j];\n                    }\n                }\n            }\n        }\n        \n        // Back substitution to get solution\n        int result[100] = {0};\n        for (int i = 0; i < 100; i++) {\n            result[i] = matrix[i][100];\n        }\n        \n        // Convert to 2D and output\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                if (j > 0) printf(\" \");\n                printf(\"%d\", result[i * 10 + j]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" Read input for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { scanf(\"%d\", &grid[i][j]); } } // Solve using Gaussian   b where A is the effect matrix // Create augmented matrix int matrix[100][101]; for (int i = 0; i < 100; i++) { for  = 0; } } // Build the system of equations for (int row = 0; row < 10; row++) { for (int col = 0; col < 10; col++) { int eq = row * 10 + col; matrix[eq][100] = grid[row][col];  = 0; r < 10; r++) { for (int c = 0; c < 10; c++) { int var = r * 10 + c; // Position (r,c) affects (row,col) if: // - (r,c) == (row,col) or // - (r,c) is adjacent to (row,col) if ((r == row && c == col) || (r == row && (c == col-1 || c == col+1)) || (c == col && (r == row-1 || r == row+1))) { matrix[eq][var] = 1; } } } } }  col < 100; col++) { // Find pivot int pivot = -1; for (int row =   { for (int j = 0; j <=  matrix[pivot][j] = temp; } } // Eliminate for (int row = 0;  matrix[row][col] == 1) { for (int j = 0; j <= 100; j++) { matrix[row][j] ^= matrix[col][j]; } } } } // Back substitution to get solution int result[100] = {0}; for (int i = 0; i < 100; i++) { result[i] = matrix[i][100]; } // Convert to 2D and output for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { if (j > 0) printf(\" \"); printf(\"%d\", result[i * 10 + j]); } printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> int main(){ int i,j,n,s[12][12],a[12][12]; scanf(\"%d\",&n); while(n--){ for(i=0;i<10;i++)for(j=0;j<10;j++)scanf(\"%d\",&s[i][j]); memset(a,0,sizeof(a)); for(i=0;i<9;i++){ for(j=0;j<10;j++){ if(s[i][j]%2==1){ a[i+1][j]=1; s[i][j]++; s[i+1][j]++; s[i+1][j-1]++; s[i+1][j+1]++; s[i+2][j]++; } } } for(i=0;i<10;i++){for(j=0;j<10;j++)printf(\"%d \",a[i][j]);printf(\"\\n\");} } return 0; }"], "original_ll": -0.7046756148338318, "sampled_ll": -0.6228181719779968, "all_perturbed_sampled_ll": [-1.2350144386291504], "all_perturbed_original_ll": [-0.8575112819671631], "perturbed_sampled_ll": -1.2350144386291504, "perturbed_original_ll": -0.8575112819671631, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic byte ans[][];\n\n\tpublic static boolean f(int a[][], int s[], int n) {\n\t\tif (10 <= n) {\n\t\t\tint b[][] = new int[10][10];\n\t\t\tans = new byte[10][10];\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tb[i][j] = a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif (s[i] == 1) {\n\t\t\t\t\treverse(b, 0, i);\n\t\t\t\t\tans[0][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (b[i - 1][j] == 1) {\n\t\t\t\t\t\treverse(b, i, j);\n\t\t\t\t\t\tans[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (check(b)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\ts[n] = 0;\n\t\t\tif (f(a, s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ts[n] = 1;\n\t\t\tif (f(a, s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void reverse(int a[][], int i, int j) {\n\t\ta[i][j] = (a[i][j] + 1) % 2;\n\t\tif (0 <= i - 1) {\n\t\t\ta[i - 1][j] = (a[i - 1][j] + 1) % 2;\n\t\t}\n\t\tif (i + 1 < 10) {\n\t\t\ta[i + 1][j] = (a[i + 1][j] + 1) % 2;\n\t\t}\n\t\tif (0 <= j - 1) {\n\t\t\ta[i][j - 1] = (a[i][j - 1] + 1) % 2;\n\t\t}\n\t\tif (j + 1 < 10) {\n\t\t\ta[i][j + 1] = (a[i][j + 1] + 1) % 2;\n\t\t}\n\t}\n\n\tpublic static boolean check(int a[][]) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (a[i][j] == 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tint a[][];\n\n\t\tn = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta = new int[10][10];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\ta[j][k] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tf(a, new int[10], 0);\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tString s = \"\";\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\tSystem.out.print(s + ans[j][k]);\n\t\t\t\t\ts = \" \";\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int t = 0; t < n; t++) {\n            int[][] grid = new int[10][10];\n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    grid[i][j] = sc.nextInt();\n                }\n            }\n            \n            int[][] result = solve(grid);\n            \n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    if (j > 0) System.out.print(\" \");\n                    System.out.print(result[i][j]);\n                }\n                System.out.println();\n            }\n        }\n        sc.close();\n    }\n    \n    static int[][] solve(int[][] grid) {\n        // Use Gaussian elimination over GF(2)\n        // Each cell (i,j) can be toggled, affecting itself and neighbors\n        // We need to solve for which cells to toggle to turn all lights off\n        \n        int[][] solution = new int[10][10];\n        \n        // Create augmented matrix for the system\n        // 100 variables (one for each cell), 100 equations (one for each cell)\n        int size = 100;\n        int[][] matrix = new int[size][size + 1];\n        \n        // Build the system of equations\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                int row = i * 10 + j;\n                \n                // Check which toggles affect cell (i,j)\n                for (int ti = 0; ti < 10; ti++) {\n                    for (int tj = 0; tj < 10; tj++) {\n                        int col = ti * 10 + tj;\n                        \n                        // Cell (ti,tj) affects (i,j) if they are adjacent\n                        if ((ti == i && tj == j) ||\n                            (ti == i && Math.abs(tj - j) == 1) ||\n                            (tj == j && Math.abs(ti - i) == 1)) {\n                            matrix[row][col] = 1;\n                        }\n                    }\n                }\n                \n                // Right side: current state of cell (i,j)\n                matrix[row][size] = grid[i][j];\n            }\n        }\n        \n        // Gaussian elimination in GF(2)\n        for (int col = 0; col < size; col++) {\n            // Find pivot\n            int pivot = -1;\n            for (int row = col; row < size; row++) {\n                if (matrix[row][col] == 1) {\n                    pivot = row;\n                    break;\n                }\n            }\n            \n            if (pivot == -1) continue;\n            \n            // Swap rows\n            if (pivot != col) {\n                int[] temp = matrix[col];\n                matrix[col] = matrix[pivot];\n                matrix[pivot] = temp;\n            }\n            \n            // Eliminate\n            for (int row = 0; row < size; row++) {\n                if (row != col && matrix[row][col] == 1) {\n                    for (int c = 0; c <= size; c++) {\n                        matrix[row][c] ^= matrix[col][c];\n                    }\n                }\n            }\n        }\n        \n        // Back substitution\n        int[] vars = new int[size];\n        for (int i = 0; i < size; i++) {\n            vars[i] = matrix[i][size];\n        }\n        \n        // Convert to 2D array\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                solution[i][j] = vars[i * 10 + j];\n            }\n        }\n        \n        return solution;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int t = 0; t < n; t++) { int[][] grid = new int[10][10];  for (int j = 0; j < 10; j++) { grid[i][j] = sc.nextInt(); } }  < 10; i++) { for (int  > 0) System.out.print(\" \"); System.out.print(result[i][j]);  { // Use Gaussian elimination over GF(2)  neighbors // We need to solve for which cells to toggle  // Create augmented matrix for the system // 100 variables  int size = 100; int[][] matrix = new int[size][size + 1]; // Build the system of equations  { int row = i * 10 + j; // Check which toggles affect cell (i,j) for (int ti = 0; ti < 10; ti++) { for  col = ti * 10 + tj; // Cell (ti,tj) affects (i,j) if they are  (ti == i && Math.abs(tj - j) == 1) || (tj == j && Math.abs(ti - i) == 1)) { matrix[row][col] = 1; } } } // Right side: current state of cell (i,j) matrix[row][size] = grid[i][j]; } } // Gaussian elimination in GF(2) for (int col = 0; col < size; col++) { // Find pivot int pivot = -1; for (int row = col; row < size; row++) { if (matrix[row][col] == 1) { pivot = row; break; } } if (pivot == -1) continue; // Swap rows if (pivot != col) { int[] temp = matrix[col]; matrix[col] = matrix[pivot]; matrix[pivot] = temp; } // Eliminate for (int row = 0; row < size; row++) { if (row != col && matrix[row][col] == 1) { for (int c = 0; c <= size; c++) { matrix[row][c] ^= matrix[col][c]; } } } } // Back substitution int[] vars = new int[size]; for (int i = 0; i < size; i++) { vars[i] = matrix[i][size]; } // Convert to 2D array for (int i = 0; i  < 10;  } return solution; } }"], "perturbed_original": ["import java.util.Scanner; public  a[][], int s[], int n) { if  = new byte[10][10]; for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { b[i][j] = a[i][j]; } }  if (s[i] == 1) { reverse(b, 0, i); ans[0][i] = 1; } }  { if (b[i - 1][j] == 1) { reverse(b, i, j); ans[i][j] = 1; } } } if (check(b)) { return true; } } else { s[n] = 0; if (f(a, s, n + 1)) { return  public static void reverse(int a[][], int i, int j) { a[i][j] = (a[i][j] + 1) % 2; if (0 <= i - 1) { a[i - 1][j] = (a[i  1 < 10) { a[i + 1][j] = (a[i + 1][j] + 1) % 2; } if (0 <= j - 1) { a[i][j - 1] = (a[i][j - 1] + 1) % 2; } if (j  + 1] + 1) % 2; } } public static boolean check(int a[][]) { for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { if (a[i][j] == 1) { return false; } } } return true; } public static void main(String args[]) { Scanner sc = new Scanner(System.in); int n; int a[][]; n = sc.nextInt(); for (int i = 0; i < n; i++) { a =  j++) { for (int k = 0; k < 10; k++) { a[j][k] = sc.nextInt(); } } f(a, new int[10], 0); for (int j = 0; j < 10; j++) { String s = \"\"; for (int k = 0;  \" \"; } System.out.println(); } } } }"], "original_ll": -0.4018569886684418, "sampled_ll": -0.6124557852745056, "all_perturbed_sampled_ll": [-1.3221570253372192], "all_perturbed_original_ll": [-1.079336404800415], "perturbed_sampled_ll": -1.3221570253372192, "perturbed_original_ll": -1.079336404800415, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def attack(table, i, j):\n    table[i][j] = 1 - table[i][j]\n    table[i-1][j] = 1 - table[i-1][j]\n    table[i+1][j] = 1 - table[i+1][j]\n    table[i][j-1] = 1 - table[i][j-1]\n    table[i][j+1] = 1 - table[i][j+1]\n\ndef printans(ans):\n    for i in range(1, 11):\n        for j in range(1, 11):\n            print(ans[i][j], end=\"\")\n            if j < 10:\n                print(\" \", end=\"\")\n        print(\"\")\n\ndef solve(table, i, j, ans):\n\n    #print(i,j)\n    if i == 11:\n        flag = True\n        for k in range(1,11):\n            if table[10][k] == 1:\n                flag = False\n                break\n        if flag:\n            printans(ans)\n        return\n\n    if table[i-1][j] == 1:\n        ans[i][j] = 1\n        attack(table, i, j)\n        if j == 10:\n            solve(table, i+1, 1, ans)\n        else:\n            solve(table, i, j+1, ans)\n        attack(table, i, j)\n        ans[i][j] = 0\n    else:\n        ans[i][j] = 0\n        if j == 10:\n            solve(table, i+1, 1, ans)\n        else:\n            solve(table, i, j+1, ans)\n\n\ndef check(table, i, ans):\n\n    if i == 11:\n        solve(table, 2, 1, ans)\n        return\n\n    ans[1][i] = 0\n    check(table, i+1, ans)\n\n    ans[1][i] = 1\n    attack(table, 1, i)\n    check(table, i+1, ans)\n    attack(table, 1, i)\n\nN = int(input())\n\nfor l in range(N):\n    table= [[0 for i in range(12)] for j in range(12)]\n    ans= [[0 for i in range(12)] for j in range(12)]\n    for i in range(1, 11):\n        nums = [int(k) for k in input().split()]\n        for j in range(1, 11):\n            table[i][j] = nums[j-1]\n\n    check(table, 1, ans)\n", "sampled": "def solve_lights_out(grid):\n    # This is a lights-out puzzle problem over GF(2)\n    # We need to solve a system of linear equations in GF(2)\n    \n    # Create the coefficient matrix\n    # For a 10x10 grid, we have 100 variables and 100 equations\n    n = 10\n    size = n * n\n    \n    # Build the augmented matrix [A|b]\n    # A[i][j] = 1 if pressing button j affects light i\n    A = [[0] * size for _ in range(size)]\n    b = [0] * size\n    \n    # Fill the coefficient matrix\n    for i in range(n):\n        for j in range(n):\n            light_idx = i * n + j\n            b[light_idx] = grid[i][j]\n            \n            # Pressing button at (r, c) affects lights at (r, c) and adjacent cells\n            for r in range(n):\n                for c in range(n):\n                    button_idx = r * n + c\n                    \n                    # Check if pressing button (r,c) affects light (i,j)\n                    if (r == i and c == j):\n                        continue  # The button itself doesn't light up\n                    \n                    # Check if (i,j) is adjacent to (r,c)\n                    if (abs(r - i) + abs(c - j)) == 1:\n                        A[light_idx][button_idx] = 1\n    \n    # Gaussian elimination in GF(2)\n    augmented = [A[i] + [b[i]] for i in range(size)]\n    \n    # Forward elimination\n    for col in range(size):\n        # Find pivot\n        pivot_row = -1\n        for row in range(col, size):\n            if augmented[row][col] == 1:\n                pivot_row = row\n                break\n        \n        if pivot_row == -1:\n            continue\n        \n        # Swap rows\n        augmented[col], augmented[pivot_row] = augmented[pivot_row], augmented[col]\n        \n        # Eliminate\n        for row in range(size):\n            if row != col and augmented[row][col] == 1:\n                for k in range(size + 1):\n                    augmented[row][k] ^= augmented[col][k]\n    \n    # Back substitution\n    solution = [0] * size\n    for i in range(size):\n        if augmented[i][i] == 1:\n            solution[i] = augmented[i][size]\n    \n    # Convert solution to 2D grid\n    result = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            result[i][j] = solution[i * n + j]\n    \n    return result\n\n# Read input\nn_datasets = int(input())\nfor _ in range(n_datasets):\n    grid = []\n    for i in range(10):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    result = solve_lights_out(grid)\n    \n    for row in result:\n        print(' '.join(map(str, row)))\n", "perturbed_sampled": ["def solve_lights_out(grid): # This is a lights-out puzzle problem over GF(2) # We need to solve a system of linear equations in GF(2) # Create the coefficient matrix # For a 10x10 grid, we have 100 variables and 100 equations n = 10 size = n * n #   size for _ in range(size)] b = [0] * size # Fill the coefficient matrix for i in range(n): for j in range(n): light_idx = i * n + j b[light_idx] = grid[i][j] # Pressing button at (r, c) affects lights at (r, c) and adjacent cells for r in range(n): for c in range(n): button_idx = r *  light (i,j) if (r == i and c == j): continue # The button itself doesn't light up # Check if (i,j) is adjacent to (r,c) if  = 1 # Gaussian elimination in GF(2) augmented = [A[i] + [b[i]] for i in range(size)] # Forward elimination for col in range(size): # Find pivot pivot_row = -1 for row in range(col, size): if augmented[row][col] ==   augmented[row][col] == 1: for k in range(size + 1): augmented[row][k] ^= augmented[col][k] # Back substitution solution = [0] * size for i in range(size): if augmented[i][i] == 1: solution[i] = augmented[i][size] # Convert solution to 2D grid result  in range(n): for j in range(n): result[i][j] = solution[i * n + j] return result # Read input n_datasets =   for row in result: print(' '.join(map(str, row)))"], "perturbed_original": ["def attack(table, i, j): table[i][j] = 1 - table[i][j] table[i-1][j] = 1 -  table[i][j-1] table[i][j+1] = 1 - table[i][j+1] def printans(ans): for i in range(1, 11): for j in  end=\"\") print(\"\") def solve(table, i, j, ans): #print(i,j) if i == 11: flag = True for  break if flag: printans(ans) return if table[i-1][j] == 1: ans[i][j] = 1  ans) else: solve(table, i, j+1, ans) attack(table, i, j) ans[i][j] = 0 else: ans[i][j]  else: solve(table, i, j+1, ans) def check(table, i, ans):  = 0 check(table, i+1, ans) ans[1][i] = 1 attack(table, 1, i) check(table, i+1, ans) attack(table, 1, i) N = int(input()) for l in range(N): table= [[0 for i in range(12)] for j in range(12)] ans= [[0 for i in range(12)] for j in range(12)] for i in range(1, 11): nums = [int(k) for k in input().split()] for j in range(1, 11): table[i][j] = nums[j-1] check(table, 1, ans)"], "original_ll": -0.623970627784729, "sampled_ll": -0.8954487442970276, "all_perturbed_sampled_ll": [-2.0330586433410645], "all_perturbed_original_ll": [-1.3065617084503174], "perturbed_sampled_ll": -2.0330586433410645, "perturbed_original_ll": -1.3065617084503174, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // qsort()\n#include <string.h>         // memset(), memcpy(), strchr()\n#include <stdbool.h>\n\n// #define DEBUG 1\n\n#define MAX_W 20\n#define MAX_H 20\n#define MAX_N 10\n\ntypedef struct order_tbl\n{\n\tint s;\n\tint bx;\n\tint by;\n\tint angle;\n\tdouble rate;\n} order_t;\n\nconst char NUL = '\\0';\n\n#ifdef DEBUG\nstatic int O = 0;\n#endif\n\nint H, W;\nchar field[MAX_H][MAX_W + 1];\nchar puzzle[MAX_H][MAX_W + 1];\nint n;\nint h0[MAX_N][4];\nint w0[MAX_N][4];\nchar piece[MAX_N][4][MAX_H][MAX_W + 1];\nint k;\nint t[MAX_N];\n\nvoid\nbury(order_t *u)\n{\n\tint s = u->s;\n\tint a = u->angle;\n\tint h = h0[s][a];\n\tint w = w0[s][a];\n\n\tfor (int y = 0; y < h; ++y)\n\t{\n\t\tfor (int x = 0; x < w; ++x)\n\t\t{\n\t\t\tif (piece[s][a][y][x] == '#')\n\t\t\t\tfield[u->by + y][u->bx + x] = '*';\n\t\t}\n\t}\n}\n\ndouble\nfitin(order_t *u, int a, int bx, int by)\n{\n\tint s = u->s;\n\tint h = h0[s][a];\n\tint w = w0[s][a];\n\n\tint dx[4] = { 0, 1, 0,-1};\n\tint dy[4] = { 1, 0,-1, 0};\n\n\tint count = 0;\n\tint total = 0;\n\tfor (int x = -1; x <= w; ++x)\n\t{\n\t\tint nx = bx + x;\n\t\tfor (int y = -1; y <= h; ++y)\n\t\t{\n\t\t\tint ny = by + y;\n\t\t\tif (0 <= x && x < w && 0 <= y && y < h && piece[s][a][y][x] == '#')\n\t\t\t{\n\t\t\t\tif (0 <= nx && nx < W && 0 <= ny && ny < H && field[ny][nx] != '.')\n\t\t\t\t\treturn -100.0;\n\t\t\t}\n\t\t\telse // piece[s][a][y][x] == '.' ?\n\t\t\t{\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\t{\n\t\t\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\t\t\tif (0 <= tx && tx < w && 0 <= ty && ty < h && piece[s][a][ty][tx] == '#')\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (i < 4)\n\t\t\t\t{\n\t\t\t\t\ttotal++;\n\t\t\t\t\tif (nx < 0 || W <= nx || ny < 0 || H <= ny || field[ny][nx] != '.')\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count * 100.0 / total;\n}\n\nvoid\nprobe(order_t *u)\n{\n\tint s = u->s;\n\tfor (int a = 0; a < 4; ++a)\n\t{\n\t\tint h = h0[s][a];\n\t\tint w = w0[s][a];\n\n\t\tint fx = strchr(piece[s][a][0], '#') - piece[s][a][0];\n\t\tfor (int by = 0; by + h <= H; ++by)\n\t\t{\n\t\t\tfor (int bx = 0; bx + w <= W; ++bx)\n\t\t\t{\n\t\t\t\tif (field[by][bx + fx] == '.')\n\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\tO++;\n#endif\n\t\t\t\t\tdouble r = fitin(u, a, bx, by);\n\t\t\t\t\tif (r > u->rate)\n\t\t\t\t\t{\n\t\t\t\t\t\tu->rate = r;\n\t\t\t\t\t\tu->bx = bx;\n\t\t\t\t\t\tu->by = by;\n\t\t\t\t\t\tu->angle = a;\n\n\t\t\t\t\t\tif (u->rate >= 100.0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbury(u);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint\ncmp_func(const void *l_, const void *r_)\n{\n\tconst order_t *l = (const order_t*) l_;\n\tconst order_t *r = (const order_t*) r_;\n\n\tif (l->rate < r->rate)\n\t\treturn 1;\n\n\tif (l->rate > r->rate)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nbool\nsolve()\n{\n\torder_t u;\n\torder_t order[MAX_N];\n\tint memo[MAX_N];\n\tint ix, ix2;\n\n\tmemcpy(field, puzzle, sizeof(field));\n\tix = 0;\n\tfor (int i = 0; i < k; ++i)\n\t\tmemo[ix++] = t[i];\n\n\twhile (ix != 0)\n\t{\n\t\tix2 = 0;\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n#ifdef DEBUG\n\t\t\tmemset(&u, 0x00, sizeof(u));\n#endif\n\t\t\tu.s = memo[i];\n\t\t\tu.rate = -100.0;\n\t\t\tprobe(&u);\n\t\t\tif (u.rate != 100.0)\n\t\t\t\torder[ix2++] = u;\n\t\t}\n\n\t\tif (ix2 == 0)\n\t\t\tbreak;\n\n\t\tqsort(order, ix2, sizeof(order_t), cmp_func);\n\t\tif (order[0].rate == -100.0)\n\t\t\treturn false;\n\n\t\tbury(&order[0]);\n\n\t\tix = 0;\n\t\tfor (int i = 1; i < ix2; ++i)\n\t\t\tmemo[ix++] = order[i].s;\n\t}\n\n\tfor (int y = 0; y < H; ++y)\n\t{\n\t\tfor (int x = 0; x < W; ++x)\n\t\t{\n\t\t\tif (field[y][x] == '.')\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\\n\", &H, &W);\n\t\tif (H == 0 && W == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < H; ++i)\n\t\t\tscanf(\"%s\", &puzzle[i][0]);\n\n\t\tscanf(\"%d\", &n);\n\t\tfor (int s = 0; s < n; ++s)\n\t\t{\n\t\t\tscanf(\"%d%d\\n\", &h0[s][0], &w0[s][0]);\n\t\t\tint h = h0[s][0];\n\t\t\tint w = w0[s][0];\n\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t\tscanf(\"%s\", &piece[s][0][y][0]);\n\n\t\t\th0[s][1] = w;\n\t\t\tw0[s][1] = h;\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tpiece[s][1][x][h - y - 1] = piece[s][0][y][x];\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tpiece[s][1][x][h] = NUL;\n#endif\n\n\t\t\th0[s][2] = h;\n\t\t\tw0[s][2] = w;\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tpiece[s][2][h - 1 - y][w - 1 - x] = piece[s][0][y][x];\n\n#ifdef DEBUG\n\t\t\t\tpiece[s][2][h - 1 - y][w] = NUL;\n#endif\n\t\t\t}\n\n\t\t\tw0[s][3] = h;\n\t\t\th0[s][3] = w;\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tpiece[s][3][w - 1 - x][y] = piece[s][0][y][x];\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tpiece[s][3][x][h] = NUL;\n#endif\n\t\t}\n\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\t\tfor (int i = 0; i < p; ++i)\n\t\t{\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor (int j = 0; j < k; ++j)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &t[j]);\n\t\t\t\tt[j]--;\n\t\t\t}\n\n\t\t\tprintf(\"%s\\n\", solve() ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tfprintf(stderr, \"O:%d\\n\", O);\n#endif\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 20\n#define MAX_PIECES 10\n\nchar grid[MAX_SIZE][MAX_SIZE+1];\nchar pieces[MAX_PIECES][MAX_SIZE][MAX_SIZE+1];\nint piece_h[MAX_PIECES], piece_w[MAX_PIECES];\nint H, W, n;\n\ntypedef struct {\n    char data[MAX_SIZE][MAX_SIZE+1];\n    int h, w;\n} Piece;\n\nvoid rotate90(Piece *src, Piece *dst) {\n    dst->h = src->w;\n    dst->w = src->h;\n    for (int i = 0; i < dst->h; i++) {\n        for (int j = 0; j < dst->w; j++) {\n            dst->data[i][j] = src->data[src->h - 1 - j][i];\n        }\n        dst->data[i][dst->w] = '\\0';\n    }\n}\n\nint canPlace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {\n    for (int i = 0; i < p->h; i++) {\n        for (int j = 0; j < p->w; j++) {\n            if (p->data[i][j] == '#') {\n                if (y + i >= H || x + j >= W || board[y+i][x+j] != '.') {\n                    return 0;\n                }\n            }\n        }\n    }\n    return 1;\n}\n\nvoid place(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {\n    for (int i = 0; i < p->h; i++) {\n        for (int j = 0; j < p->w; j++) {\n            if (p->data[i][j] == '#') {\n                board[y+i][x+j] = '#';\n            }\n        }\n    }\n}\n\nvoid unplace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {\n    for (int i = 0; i < p->h; i++) {\n        for (int j = 0; j < p->w; j++) {\n            if (p->data[i][j] == '#') {\n                board[y+i][x+j] = '.';\n            }\n        }\n    }\n}\n\nint isComplete(char board[MAX_SIZE][MAX_SIZE+1]) {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (board[i][j] == '.') return 0;\n        }\n    }\n    return 1;\n}\n\nint solve(char board[MAX_SIZE][MAX_SIZE+1], Piece rotations[][4], int selected[], int k, int used[], int idx) {\n    if (isComplete(board)) {\n        for (int i = 0; i < k; i++) {\n            if (!used[i]) return 0;\n        }\n        return 1;\n    }\n    \n    if (idx >= k) return 0;\n    \n    for (int pi = 0; pi < k; pi++) {\n        if (used[pi]) continue;\n        \n        for (int rot = 0; rot < 4; rot++) {\n            for (int y = 0; y < H; y++) {\n                for (int x = 0; x < W; x++) {\n                    if (canPlace(board, &rotations[pi][rot], y, x)) {\n                        place(board, &rotations[pi][rot], y, x);\n                        used[pi] = 1;\n                        if (solve(board, rotations, selected, k, used, idx + 1)) {\n                            return 1;\n                        }\n                        used[pi] = 0;\n                        unplace(board, &rotations[pi][rot], y, x);\n                    }\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint checkPlayer(int selected[], int k) {\n    char board[MAX_SIZE][MAX_SIZE+1];\n    for (int i = 0; i < H; i++) {\n        strcpy(board[i], grid[i]);\n    }\n    \n    Piece rotations[MAX_PIECES][4];\n    for (int i = 0; i < k; i++) {\n        int idx = selected[i] - 1;\n        rotations[i][0].h = piece_h[idx];\n        rotations[i][0].w = piece_w[idx];\n        for (int r = 0; r < piece_h[idx]; r++) {\n            strcpy(rotations[i][0].data[r], pieces[idx][r]);\n        }\n        \n        rotate90(&rotations[i][0], &rotations[i][1]);\n        rotate90(&rotations[i][1], &rotations[i][2]);\n        rotate90(&rotations[i][2], &rotations[i][3]);\n    }\n    \n    int used[MAX_PIECES] = {0};\n    return solve(board, rotations, selected, k, used, 0);\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &H, &W);\n        if (H == 0 && W == 0) break;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        scanf(\"%d\", &n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &piece_h[i], &piece_w[i]);\n            for (int j = 0; j < piece_h[i]; j++) {\n                scanf(\"%s\", pieces[i][j]);\n            }\n        }\n        \n        int p;\n        scanf(\"%d\", &p);\n        for (int i = 0; i < p; i++) {\n            int k;\n            scanf(\"%d\", &k);\n            int selected[MAX_PIECES];\n            for (int j = 0; j < k; j++) {\n                scanf(\"%d\", &selected[j]);\n            }\n            \n            if (checkPlayer(selected, k)) {\n                printf(\"YES\\n\");\n            } else {\n                printf(\"NO\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAX_SIZE 20 #define MAX_PIECES 10 char grid[MAX_SIZE][MAX_SIZE+1]; char pieces[MAX_PIECES][MAX_SIZE][MAX_SIZE+1]; int piece_h[MAX_PIECES], piece_w[MAX_PIECES]; int H, W, n; typedef struct { char data[MAX_SIZE][MAX_SIZE+1]; int  j = 0; j < dst->w; j++) { dst->data[i][j] = src->data[src->h - 1 - j][i]; } dst->data[i][dst->w] = '\\0'; } } int canPlace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x)  { for  (p->data[i][j] == '#') { if (y + i >= H || x + j >= W || board[y+i][x+j] != '.') { return 0;  Piece *p, int y, int x) { for (int i = 0; i < p->h; i++) { for (int j = 0; j < p->w; j++) { if (p->data[i][j] == '#') {  Piece *p, int y, int x) { for (int i = 0; i < p->h; i++) { for (int j = 0; j < p->w; j++) { if (p->data[i][j] == '#') { board[y+i][x+j] = '.'; } } } } int isComplete(char board[MAX_SIZE][MAX_SIZE+1]) { for (int i = 0; i < H; i++) { for (int j = 0; j < W; j++) { if (board[i][j] == '.') return 0; } } return 1; } int solve(char board[MAX_SIZE][MAX_SIZE+1], Piece rotations[][4], int selected[], int k, int used[], int idx) { if (isComplete(board)) { for (int i = 0; i < k; i++) { if (!used[i]) return 0; } return 1; } if (idx >= k) return 0; for (int pi = 0;  rot = 0; rot < 4; rot++) { for (int  x = 0; x < W; x++) { if (canPlace(board, &rotations[pi][rot], y, x)) { place(board, &rotations[pi][rot], y, x); used[pi] = 1; if (solve(board, rotations, selected, k, used, idx + 1)) { return 1;  } } } return 0; } int checkPlayer(int selected[], int k) { char board[MAX_SIZE][MAX_SIZE+1]; for (int i = 0; i < H; i++) { strcpy(board[i], grid[i]); } Piece rotations[MAX_PIECES][4]; for (int i = 0; i <  = piece_h[idx]; rotations[i][0].w =  { strcpy(rotations[i][0].data[r], pieces[idx][r]); } rotate90(&rotations[i][0], &rotations[i][1]); rotate90(&rotations[i][1], &rotations[i][2]); rotate90(&rotations[i][2], &rotations[i][3]); } int used[MAX_PIECES] = {0}; return solve(board, rotations, selected, k, used, 0); } int main() { while (1) { scanf(\"%d %d\", &H, &W); if (H == 0 && W  H; i++) { scanf(\"%s\", grid[i]);  j = 0; j < piece_h[i]; j++) { scanf(\"%s\", pieces[i][j]); } } int p;  i++) { int k; scanf(\"%d\", &k); int selected[MAX_PIECES]; for (int j = 0; j < k; j++) {  { printf(\"NO\\n\"); } } } return 0; }"], "perturbed_original": ["#include <stdio.h> // printf(), scanf() #include <stdlib.h> // qsort() #include <string.h> // memset(), memcpy(), strchr() #include <stdbool.h> // #define DEBUG 1 #define MAX_W 20  int s; int   char puzzle[MAX_H][MAX_W + 1]; int n;  int t[MAX_N]; void bury(order_t *u) { int s = u->s; int a = u->angle; int h = h0[s][a];  < h; ++y) { for (int x = 0; x < w; ++x) { if (piece[s][a][y][x] == '#') field[u->by + y][u->bx + x] = '*'; } } } double fitin(order_t *u, int a, int bx, int by) { int s = u->s; int h = h0[s][a]; int w = w0[s][a]; int dx[4] = { 0, 1, 0,-1}; int dy[4] = { 1, 0,-1, 0}; int count = 0; int total = 0; for (int x = -1; x <= w; ++x) { int nx = bx + x; for (int y = -1; y <= h; ++y) { int ny = by + y; if (0 <= x && x < w && 0 <=  0 <= ny && ny < H && field[ny][nx] != '.') return -100.0; }  (i = 0; i < 4; ++i) { int tx = x + dx[i],  tx < w && 0 <= ty && ty < h && piece[s][a][ty][tx] == '#') break; } if (i < 4) { total++; if (nx < 0 || W <= nx || ny < 0 || H <= ny || field[ny][nx] != '.') count++; } } } } return count * 100.0 / total; } void probe(order_t *u) {  < 4; ++a) { int h = h0[s][a]; int w = w0[s][a]; int fx =  + h <= H; ++by) { for (int bx = 0; bx + w <= W; ++bx) { if (field[by][bx + fx] == '.') { #ifdef DEBUG O++; #endif double r = fitin(u, a, bx, by); if (r > u->rate) { u->rate =  if (u->rate >= 100.0) { bury(u); return; } } } } } } } int cmp_func(const void *l_, const void  order_t *r = (const order_t*) r_; if (l->rate < r->rate) return 1; if (l->rate > r->rate) return -1; return 0; } bool solve() {  puzzle, sizeof(field)); ix  ++i) memo[ix++] = t[i]; while (ix != 0) {  ix; ++i) { #ifdef DEBUG memset(&u, 0x00, sizeof(u)); #endif u.s = memo[i]; u.rate = -100.0; probe(&u); if (u.rate != 100.0) order[ix2++] = u; } if (ix2 ==  return false; bury(&order[0]); ix = 0; for (int i = 1; i < ix2; ++i) memo[ix++] = order[i].s; } for (int  x = 0; x < W; ++x) { if (field[y][x] == '.') return false; } } return true; } int main(int argc, char **argv) { while (true)  == 0) break;  &puzzle[i][0]); scanf(\"%d\", &n); for (int s = 0; s < n; ++s) { scanf(\"%d%d\\n\", &h0[s][0], &w0[s][0]); int h =  y < h; ++y) scanf(\"%s\", &piece[s][0][y][0]); h0[s][1] = w; w0[s][1] = h; for (int y = 0; y < h; ++y) { for (int x = 0; x < w; ++x) piece[s][1][x][h - y - 1] = piece[s][0][y][x]; } #ifdef DEBUG for (int x = 0; x < w; ++x) piece[s][1][x][h] = NUL; #endif  0; y < h; ++y) { for (int x = 0; x < w; ++x) piece[s][2][h - 1 - y][w - 1 - x] = piece[s][0][y][x]; #ifdef DEBUG piece[s][2][h - 1 - y][w] = NUL; #endif } w0[s][3] = h; h0[s][3] = w; for (int y = 0; y < h; ++y) { for (int x = 0; x < w; ++x) piece[s][3][w - 1 - x][y] =  < w; ++x) piece[s][3][x][h] = NUL; #endif } int p; scanf(\"%d\", &p); for (int i = 0; i < p; ++i) { scanf(\"%d\", &k); for (int j = 0; j  ? \"YES\" :  0; }"], "original_ll": -0.7032430171966553, "sampled_ll": -0.4032168686389923, "all_perturbed_sampled_ll": [-1.0745487213134766], "all_perturbed_original_ll": [-1.4521864652633667], "perturbed_sampled_ll": -1.0745487213134766, "perturbed_original_ll": -1.4521864652633667, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.util.Calendar.Builder;\n\nimport javax.jws.soap.SOAPBinding.Use;\n\n\n\npublic class Main {\n\tstatic int H;\n\tstatic int W;\n\tstatic int[] map;\n\tstatic Piece[] p;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif(H == 0 && W == 0) break;\n\t\t\tmap = new int[H];\n\t\t\tint mapCount = 0;\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tString in = sc.next();\n\t\t\t\tin = in.replace('.', '0');\n\t\t\t\tin = in.replace('#', '1');\n\t\t\t\tint bin = Integer.parseInt(in,2);\n\t\t\t\tmap[i] = bin;\n\t\t\t\tmapCount += W - Integer.bitCount(bin);\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tp = new Piece[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tString[] map = new String[h];\n\t\t\t\tfor(int j = 0; j < h; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[j] = in;\n\t\t\t\t}\n\t\t\t\tp[i] = new Piece(h,w,map);\n\t\t\t}\n\t\t\t\n\t\t\tint p = sc.nextInt();\n\t\t\tfor(int i = 0; i < p; i++) {\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tint[] t = new int[k];\n\t\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\t\tt[j] = sc.nextInt()-1;\n\t\t\t\t}\n\t\t\t\tint bitCount = 0;\n\t\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\t\tfor(int l = 0; l < Main.p[t[j]].h[0]; l++) {\n\t\t\t\t\t\tbitCount += Integer.bitCount(Main.p[t[j]].map[0][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean ans = false;\n\t\t\t\tif(bitCount == mapCount) {\n\t\t\t\t\tans = check(new boolean[k],t,map,0,0,0);\n\t\t\t\t}\n\t\t\t\tif(ans) System.out.println(\"YES\");\n\t\t\t\telse System.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean check(boolean[] used, int[] use, int[] map, int y, int x,int c) {\n\t\tif(x == W) return check(used,use,map,y+1,0,c);\n\t\tif(y == H && c == use.length) {\n\t\t\treturn true;\n\t\t}\n\t\telse if(y == H) return false;\n\t\tif((map[y] & (1 << (W - x - 1))) == 0) {\n\t\t\tfor(int i = 0; i < use.length; i++) {\n\t\t\t\tif(used[i]) continue;\n\t\t\t\tint sel = use[i];\n\t\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\t\tint xx = x - p[sel].vw[j];\n\t\t\t\t\tif(xx < 0) continue;\n\t\t\t\t\tboolean cf = checkCanFill(y,xx,j,map,p[sel]);\n\t\t\t\t\tif(!cf) continue;\n\t\t\t\t\tfill(y,xx,j,map,p[sel]);\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tboolean rt = check(used,use,map,y,x+1,c+1);\n\t\t\t\t\tif(rt) {\n\t\t\t\t\t\tused[i] = false;\n\t\t\t\t\t\tfill(y,xx,j,map,p[sel]);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tused[i] = false;\n\t\t\t\t\tfill(y,xx,j,map,p[sel]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn check(used,use,map,y,x+1,c);\n\t\t}\n\t}\n\tstatic boolean checkCanFill(int A, int B, int C,int[] map, Piece p) {\n\t\tif(p.h[C] + A > H) return false;\n\t\tif(p.w[C] + B > W || W - p.w[C] - B < 0) return false;\n\t\tfor(int i = 0; i < p.h[C]; i++) {\n\t\t\tif((map[i + A] & (p.map[C][i] << (W - p.w[C] - B))) != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic void fill(int A, int B, int C, int[] map, Piece p) {\n\t\tfor(int i = 0; i < p.h[C]; i++) {\n\t\t\tmap[i + A] ^= (p.map[C][i] << (W - p.w[C] - B));\n\t\t}\n\t}\n\tstatic boolean checkFill(int[] map) {\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tif(map[i] != (1 << W)-1) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic String[] rotate(String[] map) {\n\t\tchar[][] in = new char[map.length][];\n\t\tfor(int i = 0; i < map.length; i++) {\n\t\t\tin[i] = map[i].toCharArray();\n\t\t}\n\t\tchar[][] ret = new char[in[0].length][in.length];\n\t\tfor(int i = 0; i < in[0].length; i++) {\n\t\t\tfor(int j = 0; j < in.length; j++) {\n\t\t\t\tret[i][j] = in[in.length - j - 1][i];\n\t\t\t}\n\t\t}\n\t\tString[] retu = new String[ret.length];\n\t\tfor(int i = 0; i < ret.length; i++) {\n\t\t\tretu[i] = String.valueOf(ret[i]);\n\t\t}\n\t\treturn retu;\n\t\t\n\t}\n\t\n\t\n\tstatic class Piece {\n\t\tint[] h;\n\t\tint[] w;\n\t\tint[][] map;\n\t\tint[] vw;\n\t\tPiece(int a, int b, String[] c) {\n\t\t\th = new int[4];\n\t\t\tw = new int[4];\n\t\t\tvw = new int[4];\n\t\t\tmap = new int[4][];\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\th[i] = a;\n\t\t\t\tw[i] = b;\n\t\t\t\tmap[i] = new int[h[i]];\n\t\t\t\tfor(int j = 0; j < w[i]; j++) {\n\t\t\t\t\tif(c[0].charAt(j) == '#') {\n\t\t\t\t\t\tvw[i] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < h[i]; j++) {\n\t\t\t\t\tString in = c[j];\n\t\t\t\t\tin = in.replace('.', '0');\n\t\t\t\t\tin = in.replace('#', '1');\n\t\t\t\t\tint bin = Integer.parseInt(in,2);\n\t\t\t\t\tmap[i][j] = bin;\n\t\t\t\t}\n\t\t\t\tint tmp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = tmp;\n\t\t\t\tc = rotate(c);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        if (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static char[][] grid;\n    static List<char[][]> pieces;\n    static int H, W;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] hw = line.trim().split(\"\\\\s+\");\n            H = Integer.parseInt(hw[0]);\n            W = Integer.parseInt(hw[1]);\n            \n            if (H == 0 && W == 0) break;\n            \n            grid = new char[H][W];\n            for (int i = 0; i < H; i++) {\n                String row = br.readLine();\n                grid[i] = row.toCharArray();\n            }\n            \n            int n = Integer.parseInt(br.readLine().trim());\n            pieces = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                String[] size = br.readLine().trim().split(\"\\\\s+\");\n                int h = Integer.parseInt(size[0]);\n                int w = Integer.parseInt(size[1]);\n                char[][] piece = new char[h][w];\n                for (int j = 0; j < h; j++) {\n                    String row = br.readLine();\n                    piece[j] = row.toCharArray();\n                }\n                pieces.add(piece);\n            }\n            \n            int p = Integer.parseInt(br.readLine().trim());\n            \n            for (int i = 0; i < p; i++) {\n                String[] selection = br.readLine().trim().split(\"\\\\s+\");\n                int k = Integer.parseInt(selection[0]);\n                List<Integer> selected = new ArrayList<>();\n                for (int j = 1; j <= k; j++) {\n                    selected.add(Integer.parseInt(selection[j]) - 1);\n                }\n                \n                if (canSolve(selected)) {\n                    System.out.println(\"YES\");\n                } else {\n                    System.out.println(\"NO\");\n                }\n            }\n        }\n    }\n    \n    static boolean canSolve(List<Integer> selected) {\n        char[][] testGrid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                testGrid[i][j] = grid[i][j];\n            }\n        }\n        \n        return tryPlace(testGrid, selected, 0);\n    }\n    \n    static boolean tryPlace(char[][] testGrid, List<Integer> selected, int idx) {\n        if (idx == selected.size()) {\n            return isComplete(testGrid);\n        }\n        \n        int pieceIdx = selected.get(idx);\n        char[][] piece = pieces.get(pieceIdx);\n        \n        for (int rot = 0; rot < 4; rot++) {\n            char[][] rotated = rotate(piece, rot);\n            for (int i = 0; i <= H - rotated.length; i++) {\n                for (int j = 0; j <= W - rotated[0].length; j++) {\n                    if (canPlace(testGrid, rotated, i, j)) {\n                        char[][] backup = copyGrid(testGrid);\n                        place(testGrid, rotated, i, j);\n                        if (tryPlace(testGrid, selected, idx + 1)) {\n                            return true;\n                        }\n                        restoreGrid(testGrid, backup);\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    static boolean canPlace(char[][] testGrid, char[][] piece, int r, int c) {\n        for (int i = 0; i < piece.length; i++) {\n            for (int j = 0; j < piece[0].length; j++) {\n                if (piece[i][j] == '#') {\n                    if (testGrid[r + i][c + j] != '.') {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    \n    static void place(char[][] testGrid, char[][] piece, int r, int c) {\n        for (int i = 0; i < piece.length; i++) {\n            for (int j = 0; j < piece[0].length; j++) {\n                if (piece[i][j] == '#') {\n                    testGrid[r + i][c + j] = '#';\n                }\n            }\n        }\n    }\n    \n    static boolean isComplete(char[][] testGrid) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (testGrid[i][j] == '.') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    static char[][] rotate(char[][] piece, int times) {\n        char[][] result = piece;\n        for (int t = 0; t < times; t++) {\n            int h = result.length;\n            int w = result[0].length;\n            char[][] newPiece = new char[w][h];\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    newPiece[j][h - 1 - i] = result[i][j];\n                }\n            }\n            result = newPiece;\n        }\n        return result;\n    }\n    \n    static char[][] copyGrid(char[][] grid) {\n        char[][] copy = new char[grid.length][grid[0].length];\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                copy[i][j] = grid[i][j];\n            }\n        }\n        return copy;\n    }\n    \n    static void restoreGrid(char[][] grid, char[][] backup) {\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                grid[i][j] = backup[i][j];\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static char[][] grid; static List<char[][]> pieces; static int H, W; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String  = line.trim().split(\"\\\\s+\"); H = Integer.parseInt(hw[0]); W = Integer.parseInt(hw[1]); if (H == 0 && W == 0) break; grid = new char[H][W]; for  row  pieces = new ArrayList<>(); for (int i = 0; i < n; i++) { String[] size = br.readLine().trim().split(\"\\\\s+\"); int h = Integer.parseInt(size[0]); int w = Integer.parseInt(size[1]); char[][] piece = new char[h][w]; for (int j = 0; j < h; j++) { String row = br.readLine();  for (int i = 0; i < p; i++)  j <= k; j++) { selected.add(Integer.parseInt(selection[j]) - 1); } if (canSolve(selected)) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } } } static boolean canSolve(List<Integer> selected) { char[][] testGrid = new char[H][W]; for (int i = 0; i < H; i++) { for (int j = 0; j < W; j++) { testGrid[i][j] = grid[i][j]; } } return tryPlace(testGrid, selected, 0); } static boolean tryPlace(char[][] testGrid, List<Integer> selected, int idx) { if (idx == selected.size()) { return isComplete(testGrid); } int pieceIdx = selected.get(idx); char[][] piece = pieces.get(pieceIdx);  char[][] rotated = rotate(piece, rot); for (int i = 0; i <= H - rotated.length; i++) { for (int j =  rotated, i, j)) { char[][] backup = copyGrid(testGrid); place(testGrid, rotated, i, j); if (tryPlace(testGrid, selected, idx + 1)) { return true; } restoreGrid(testGrid, backup); } }  piece, int r, int c) { for (int i = 0; i < piece.length; i++) { for (int j =   return false; } } } } return true; } static void place(char[][]  i = 0; i < piece.length; i++) { for (int j = 0; j < piece[0].length; j++) { if (piece[i][j] == '#') { testGrid[r + i][c + j] = '#'; } } } } static boolean isComplete(char[][] testGrid) { for (int i = 0;  j < W; j++) { if (testGrid[i][j] == '.') { return false; } }  { char[][] result = piece; for (int t = 0;  w = result[0].length; char[][] newPiece = new char[w][h]; for (int i  = 0; j < w; j++) { newPiece[j][h - 1 - i] = result[i][j]; } } result = newPiece; } return result; } static char[][] copyGrid(char[][] grid) { char[][] copy =  i++) { for (int j = 0; j < grid[0].length; j++) { copy[i][j] = grid[i][j]; } } return copy; } static void restoreGrid(char[][] grid, char[][] backup) { for (int i = 0; i < grid.length; i++) { for  = backup[i][j]; } } } }"], "perturbed_original": ["import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.util.*; import java.util.Calendar.Builder; import javax.jws.soap.SOAPBinding.Use; public class Main { static int H; static int W; static  { FastScanner sc = new FastScanner(); //Scanner sc  H = sc.nextInt(); W = sc.nextInt(); if(H == 0 && W == 0) break; map = new int[H]; int mapCount = 0; for(int i = 0; i < H; i++) { String in = sc.next();  Integer.bitCount(bin); } int n = sc.nextInt(); p = new Piece[n]; for(int i = 0; i < n; i++) { int h =  for(int j = 0; j < h; j++) { String in = sc.next(); map[j] = in; } p[i] = new Piece(h,w,map); } int  i++) { int k = sc.nextInt(); int[] t = new int[k]; for(int j = 0; j < k; j++) { t[j]  0; j < k; j++) { for(int l = 0; l < Main.p[t[j]].h[0]; l++) { bitCount += Integer.bitCount(Main.p[t[j]].map[0][l]); } } boolean ans = false; if(bitCount == mapCount) {  } } static boolean check(boolean[] used, int[] use, int[] map, int y, int  H && c == use.length) { return true; } else if(y == H)  1))) == 0) {  continue; int sel = use[i]; for(int j = 0; j < 4; j++) { int xx = x - p[sel].vw[j]; if(xx < 0) continue; boolean cf = checkCanFill(y,xx,j,map,p[sel]); if(!cf) continue; fill(y,xx,j,map,p[sel]); used[i] = true; boolean rt = check(used,use,map,y,x+1,c+1); if(rt) { used[i] = false; fill(y,xx,j,map,p[sel]); return true; }  { return check(used,use,map,y,x+1,c); } } static boolean checkCanFill(int A, int B, int C,int[] map, Piece p) { if(p.h[C] + A > H) return false; if(p.w[C] + B > W || W - p.w[C] - B  p.h[C]; i++) { if((map[i + A] & (p.map[C][i] << (W - p.w[C] - B))) != 0) return false; } return true; } static void fill(int A, int B, int C, int[] map, Piece p) { for(int i = 0; i < p.h[C]; i++) { map[i + A] ^= (p.map[C][i] <<  map) { for(int i = 0; i < H; i++) {  } static String[] rotate(String[] map) { char[][] in = new char[map.length][]; for(int i = 0; i < map.length; i++) { in[i] = map[i].toCharArray(); } char[][] ret = new char[in[0].length][in.length]; for(int i = 0; i < in[0].length; i++) { for(int j = 0; j < in.length; j++) { ret[i][j] = in[in.length - j - 1][i]; } } String[] retu  i++) { retu[i] = String.valueOf(ret[i]); } return retu; } static class  Piece(int a, int b, String[] c) { h = new int[4];  new int[4][]; for(int i = 0; i < 4; i++) { h[i] = a; w[i] = b; map[i] = new int[h[i]]; for(int j = 0; j < w[i]; j++) { if(c[0].charAt(j) == '#') { vw[i] = j; break; } }  in.replace('#', '1'); int bin = Integer.parseInt(in,2); map[i][j] = bin; } int tmp  rotate(c); }  = System.in; private final byte[] buffer = new byte[1024]; private int ptr = 0; private int buflen = 0; private boolean hasNextByte() { if (ptr < buflen) { return true; }else{ ptr = 0; try { buflen = in.read(buffer); } catch (IOException  false; } } return true; } private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;} private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;} private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;} public boolean hasNext() { skipUnprintable(); return hasNextByte();} public String next() { if (!hasNext()) throw new NoSuchElementException(); StringBuilder sb = new StringBuilder(); int b = readByte(); while(isPrintableChar(b)) { sb.appendCodePoint(b); b = readByte(); } return sb.toString(); } public long  = readByte(); } if (b < '0' || '9' < b) { throw new NumberFormatException(); } while(true){ if ('0' <= b && b <=  }else if(b == -1 || !isPrintableChar(b)){ return minus ? -n : n; }else{ throw new NumberFormatException(); } b = readByte(); } } public int nextInt() { if (!hasNext())  false; int b = readByte(); if (b == '-') { minus = true; b = readByte(); } if (b < '0' || '9' < b) { throw new NumberFormatException(); } while(true){ if ('0' <= b && b <= '9') { n *= 10; n += b - '0'; }else if(b == -1 || !isPrintableChar(b)){ return minus ? -n  } } }"], "original_ll": -0.6502135992050171, "sampled_ll": -0.3444550037384033, "all_perturbed_sampled_ll": [-1.1339432001113892], "all_perturbed_original_ll": [-1.4098762273788452], "perturbed_sampled_ll": -1.1339432001113892, "perturbed_original_ll": -1.4098762273788452, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import copy\ndef rot90(A):\n  return zip(*A[::-1])\n\ndef count_board(Board):\n  X = [[0 for _ in [0]*(Width+1)] for _ in [0]*(Height+1)]\n  for i in range(Height)[::-1]:\n    for j in range(Width)[::-1]:\n      X[i][j] = X[i+1][j] + X[i][j+1] - X[i+1][j+1] + (Board[i][j]=='.')\n  return X\n\ndef check_sum(TRIALS):\n  return sum([B[e] for e in TRIALS]) != DOTS[0][0]\n\ndef tmp_put(Board, piece, y, x):\n  N = range(len(piece[0]))\n  for i in range(len(piece)):\n    tmp = piece[i]\n    BoardRow = Board[y+i]\n    for j in N:\n      if tmp[j]=='#' and BoardRow[x+j]!='.': return 0\n  return 1\n\ndef get_put(Board, piece, y, x, mode):\n  c = '#.'[mode]\n  W = range(len(piece[0]))\n  for i in range(len(piece)):\n    tmp = piece[i]\n    Y = y+i\n    for j in W:\n      if tmp[j]=='#': Board[Y][x+j]=c\n  return Board\n\ndef PrintBoard(Board):\n  for e in Board:\n    print \"\".join(e)\n  print\n  return\n\ndef PrintDots(DOTS):\n  for e in DOTS:\n    print e\n  print\n  return\n\ndef solve(TRIALS, Board):\n  if TRIALS==[]: return 1\n  n = TRIALS[0]\n  DOTS = count_board(Board)\n  for direction in C[n]:\n    P = PIECE[(n, direction)]\n    h = len(P)\n    w = len(P[0])\n    s = B[n]\n    POS=[]\n    H = range(Height-h+1)\n    W = range(Width-w+1)\n    for i in H:\n      A1 = DOTS[i]\n      A2 = DOTS[i+h]\n      for j in W:\n        tmp = A1[j] - A2[j] - A1[j+w] + A2[j+w]\n        if tmp>=s and tmp_put(Board, P, i, j):\n          Board = get_put(Board, P, i, j, 0)\n          if solve(TRIALS[1:], Board): return 1\n          Board = get_put(Board, P, i, j, 1)\n  return 0\n\ndef CheckPieceType(i):\n  def f(x1, x2):\n    for j in range(len(PIECE[i, x1])):\n      if \"\".join(PIECE[i, x1][j])!=\"\".join(PIECE[i, x2][j]): return 0\n    return 1\n  flg = [0,1,2,3]\n  for a, b in [[0,1], [1,3], [0,2]]:\n    if f(a, b): flg[b] = flg[a]\n  return list(set(flg))\n\nwhile 1:\n  Height, Width = map(int,raw_input().split())\n  if Height*Width==0: break\n  try: Board = [list(raw_input()) for _ in [0]*Height]\n  except: break\n  DOTS = count_board(Board)\n  PIECE = {}\n  n = input()\n  B = [0] * n\n  C = [[0, 0, 0, 0] for _ in [0] * n]\n  for i in range(n):\n    height, width = map(int, raw_input().split())\n    tmp = [list(raw_input()) for _ in [0] * height]\n    B[i] = sum([e.count('#') for e in tmp])\n    for direction in [0, 1, 2, 3]:\n      PIECE[(i, direction)] = tmp\n      tmp = rot90(tmp)\n    C[i] = CheckPieceType(i)\n  for _ in [0]*input():\n    a = map(int, raw_input().split())[1:]\n    a = sorted([[B[e-1], e-1] for e in a], key = lambda x:{-x[0]})\n    TRIALS = list(zip(*a)[1])\n    if check_sum(TRIALS): print \"NO\"\n    else: print [\"NO\", \"YES\"][solve(TRIALS, copy.deepcopy(Board))]", "sampled": "import sys\nfrom copy import deepcopy\n\ndef read_input():\n    datasets = []\n    while True:\n        line = sys.stdin.readline()\n        if not line:\n            break\n        parts = line.strip().split()\n        if len(parts) == 2:\n            H, W = int(parts[0]), int(parts[1])\n            if H == 0 and W == 0:\n                break\n            \n            # Read puzzle grid\n            grid = []\n            for _ in range(H):\n                grid.append(sys.stdin.readline().strip())\n            \n            # Read number of pieces\n            n = int(sys.stdin.readline().strip())\n            \n            # Read pieces\n            pieces = []\n            for _ in range(n):\n                h = int(sys.stdin.readline().strip())\n                w = int(sys.stdin.readline().strip())\n                piece = []\n                for _ in range(h):\n                    piece.append(sys.stdin.readline().strip())\n                pieces.append(piece)\n            \n            # Read players\n            p = int(sys.stdin.readline().strip())\n            players = []\n            for _ in range(p):\n                line = sys.stdin.readline().strip().split()\n                k = int(line[0])\n                selected = [int(line[i+1]) - 1 for i in range(k)]\n                players.append(selected)\n            \n            datasets.append((H, W, grid, pieces, players))\n    \n    return datasets\n\ndef rotate_90(piece):\n    h = len(piece)\n    w = len(piece[0])\n    rotated = []\n    for j in range(w):\n        row = \"\"\n        for i in range(h-1, -1, -1):\n            row += piece[i][j]\n        rotated.append(row)\n    return rotated\n\ndef get_rotations(piece):\n    rotations = [piece]\n    current = piece\n    for _ in range(3):\n        current = rotate_90(current)\n        rotations.append(current)\n    return rotations\n\ndef get_piece_coords(piece):\n    coords = []\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if piece[i][j] == '#':\n                coords.append((i, j))\n    return coords\n\ndef try_place(grid, H, W, piece, start_r, start_c):\n    piece_coords = get_piece_coords(piece)\n    placed = []\n    for dr, dc in piece_coords:\n        r = start_r + dr\n        c = start_c + dc\n        if r < 0 or r >= H or c < 0 or c >= W:\n            return None\n        if grid[r][c] != '.':\n            return None\n        placed.append((r, c))\n    return placed\n\ndef solve(H, W, grid, selected_pieces):\n    # Create a mutable grid\n    target = []\n    for i in range(H):\n        row = list(grid[i])\n        target.append(row)\n    \n    # Get all rotations for each piece\n    all_rotations = []\n    for piece in selected_pieces:\n        all_rotations.append(get_rotations(piece))\n    \n    def backtrack(piece_idx):\n        if piece_idx == len(selected_pieces):\n            # Check if all '.' are filled\n            for i in range(H):\n                for j in range(W):\n                    if target[i][j] == '.':\n                        return False\n            return True\n        \n        piece_rotations = all_rotations[piece_idx]\n        \n        for rotation in piece_rotations:\n            # Try all possible positions\n            for start_r in range(-19, H+20):\n                for start_c in range(-19, W+20):\n                    placed = try_place(target, H, W, rotation, start_r, start_c)\n                    if placed:\n                        # Mark cells\n                        for r, c in placed:\n                            target[r][c] = '#'\n                        \n                        if backtrack(piece_idx + 1):\n                            return True\n                        \n                        # Unmark cells\n                        for r, c in placed:\n                            target[r][c] = '.'\n        \n        return False\n    \n    return backtrack(0)\n\ndef main():\n    datasets = read_input()\n    \n    for H, W, grid, pieces, players in datasets:\n        for selected_indices in players:\n            selected_pieces = [pieces[i] for i in selected_indices]\n            if solve(H, W, grid, selected_pieces):\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from copy import deepcopy def read_input(): datasets = [] while True:  if len(parts) == 2: H, W = int(parts[0]), int(parts[1]) if H == 0 and W == 0: break # Read puzzle grid grid = []  n = int(sys.stdin.readline().strip()) # Read pieces pieces = [] for _ in range(n): h = int(sys.stdin.readline().strip()) w = int(sys.stdin.readline().strip()) piece = [] for _ in range(h): piece.append(sys.stdin.readline().strip()) pieces.append(piece) # Read players p = int(sys.stdin.readline().strip()) players = []  selected = [int(line[i+1]) - 1 for i in range(k)] players.append(selected) datasets.append((H, W, grid, pieces, players)) return datasets def  for j in range(w): row = \"\" for i in range(h-1, -1, -1): row += piece[i][j] rotated.append(row) return rotated def get_rotations(piece): rotations = [piece] current = piece for _ in range(3): current  for i in range(len(piece)): for j in range(len(piece[i])): if piece[i][j]  piece, start_r, start_c): piece_coords = get_piece_coords(piece) placed = [] for dr, dc in piece_coords: r = start_r + dr c = start_c + dc if r < 0 or r >= H or c < 0 or c >= W: return None if grid[r][c] != '.': return None placed.append((r, c)) return placed def solve(H, W, grid, selected_pieces): # Create a mutable grid target = [] for i in range(H): row = list(grid[i]) target.append(row) #  len(selected_pieces): # Check if all '.'   all_rotations[piece_idx] for rotation in piece_rotations: # Try all possible positions for start_r in range(-19, H+20): for start_c in range(-19, W+20): placed = try_place(target, H, W, rotation, start_r, start_c) if placed: # Mark cells for r, c in placed: target[r][c] = '#' if backtrack(piece_idx + 1): return True # Unmark cells for r, c  main(): datasets = read_input()  in players: selected_pieces = [pieces[i] for i in selected_indices] if solve(H, W, grid, selected_pieces): print(\"YES\") else: print(\"NO\") if __name__ == \"__main__\": main()"], "perturbed_original": ["import copy def rot90(A): return zip(*A[::-1]) def count_board(Board): X = [[0 for _ in [0]*(Width+1)] for _ in [0]*(Height+1)] for i in range(Height)[::-1]: for j in range(Width)[::-1]: X[i][j] = X[i+1][j] + X[i][j+1] - X[i+1][j+1] + (Board[i][j]=='.')  != DOTS[0][0]  j in N: if tmp[j]=='#' and BoardRow[x+j]!='.': return  = '#.'[mode] W = range(len(piece[0])) for i in range(len(piece)): tmp = piece[i] Y = y+i for j in W: if tmp[j]=='#': Board[Y][x+j]=c return Board def PrintBoard(Board): for e in Board: print \"\".join(e) print return def PrintDots(DOTS): for e in DOTS: print e print  TRIALS[0] DOTS = count_board(Board) for direction in C[n]: P = PIECE[(n, direction)] h = len(P) w = len(P[0]) s = B[n] POS=[] H = range(Height-h+1) W = range(Width-w+1) for i in H: A1 = DOTS[i] A2 = DOTS[i+h] for j in W: tmp = A1[j] - A2[j] - A1[j+w] + A2[j+w] if tmp>=s and tmp_put(Board, P, i, j): Board = get_put(Board, P, i, j,  i, j, 1) return 0 def CheckPieceType(i): def f(x1, x2): for j in range(len(PIECE[i, x1])): if \"\".join(PIECE[i, x1][j])!=\"\".join(PIECE[i, x2][j]): return 0  list(set(flg)) while 1: Height, Width = map(int,raw_input().split()) if Height*Width==0: break try: Board = [list(raw_input()) for _ in [0]*Height] except: break DOTS =   in [0] * n] for i in range(n): height, width = map(int, raw_input().split()) tmp = [list(raw_input()) for _ in [0] * height] B[i] = sum([e.count('#') for e in tmp]) for direction in [0, 1, 2, 3]: PIECE[(i, direction)]  in [0]*input(): a = map(int, raw_input().split())[1:] a = sorted([[B[e-1], e-1] for e in a], key = lambda x:{-x[0]}) TRIALS = list(zip(*a)[1]) if check_sum(TRIALS): print \"NO\" else: print [\"NO\", \"YES\"][solve(TRIALS, copy.deepcopy(Board))]"], "original_ll": -1.3644311428070068, "sampled_ll": -0.6744669079780579, "all_perturbed_sampled_ll": [-1.745368480682373], "all_perturbed_original_ll": [-2.12778639793396], "perturbed_sampled_ll": -1.745368480682373, "perturbed_original_ll": -2.12778639793396, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint rotate(char pat[8][9]) {\n\tchar buf[8][9];\n\tint x,y;\n\tfor(y=0;y<8;y++) {\n\t\tfor(x=0;x<8;x++) {\n\t\t\tbuf[x][7-y]=pat[y][x];\n\t\t}\n\t}\n\tmemcpy(pat,buf,sizeof(pat));\n}\n\nint main(void) {\n\tchar buf[8][9];\n\tint i;\n\tfor(i=0;i<8;i++)scanf(\"%s\",buf[i]);\n\trotate(buf);\n\tputs(\"90\");\n\tfor(i=0;i<8;i++)printf(\"%s\\n\",buf[i]);\n\trotate(buf);\n\tputs(\"180\");\n\tfor(i=0;i<8;i++)printf(\"%s\\n\",buf[i]);\n\trotate(buf);\n\tputs(\"270\");\n\tfor(i=0;i<8;i++)printf(\"%s\\n\",buf[i]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    char pattern[8][9];\n    int i, j;\n    \n    // Read input\n    for (i = 0; i < 8; i++) {\n        scanf(\"%s\", pattern[i]);\n    }\n    \n    // 90 degrees\n    printf(\"90\\n\");\n    for (i = 0; i < 8; i++) {\n        for (j = 7; j >= 0; j--) {\n            printf(\"%c\", pattern[j][i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    // 180 degrees\n    printf(\"180\\n\");\n    for (i = 7; i >= 0; i--) {\n        for (j = 7; j >= 0; j--) {\n            printf(\"%c\", pattern[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    // 270 degrees\n    printf(\"270\\n\");\n    for (i = 7; i >= 0; i--) {\n        for (j = 0; j < 8; j++) {\n            printf(\"%c\", pattern[j][i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  Read  scanf(\"%s\", pattern[i]); } // 90 degrees printf(\"90\\n\"); for (i = 0; i < 8; i++) { for (j = 7; j >= 0; j--) { printf(\"%c\", pattern[j][i]); } printf(\"\\n\"); } // 180 degrees printf(\"180\\n\"); for (i = 7; i >= 0; i--) { for (j = 7; j >= 0; j--)  for (i = 7; i >= 0; i--) { for (j = 0; j < 8; j++) { printf(\"%c\", pattern[j][i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int rotate(char pat[8][9])  } } memcpy(pat,buf,sizeof(pat)); } int main(void) { char buf[8][9]; int i; for(i=0;i<8;i++)scanf(\"%s\",buf[i]); rotate(buf); puts(\"90\"); for(i=0;i<8;i++)printf(\"%s\\n\",buf[i]); rotate(buf); puts(\"180\"); for(i=0;i<8;i++)printf(\"%s\\n\",buf[i]); rotate(buf); puts(\"270\"); for(i=0;i<8;i++)printf(\"%s\\n\",buf[i]); return 0; }"], "original_ll": -0.9061835408210754, "sampled_ll": -0.41113215684890747, "all_perturbed_sampled_ll": [-1.17631196975708], "all_perturbed_original_ll": [-1.2428739070892334], "perturbed_sampled_ll": -1.17631196975708, "perturbed_original_ll": -1.2428739070892334, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tchar[][] pattern = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tline = br.readLine();\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tpattern[i][j] = line.charAt(j);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 3; i++) {\n\t\t\tpattern = rotate(pattern);\n\t\t\tSystem.out.println(i * 90);\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tSystem.out.println(new String(pattern[j]));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic char[][] rotate(char[][] pattern) {\n\t\tchar[][] rotate = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\trotate[j][7 - i] = pattern[i][j];\n\t\t\t}\n\t\t}\n\t\treturn rotate;\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        char[][] pattern = new char[8][8];\n        \n        for (int i = 0; i < 8; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 8; j++) {\n                pattern[i][j] = line.charAt(j);\n            }\n        }\n        \n        // 90 degrees\n        System.out.println(\"90\");\n        char[][] rotated90 = rotate90(pattern);\n        printPattern(rotated90);\n        \n        // 180 degrees\n        System.out.println(\"180\");\n        char[][] rotated180 = rotate90(rotated90);\n        printPattern(rotated180);\n        \n        // 270 degrees\n        System.out.println(\"270\");\n        char[][] rotated270 = rotate90(rotated180);\n        printPattern(rotated270);\n        \n        sc.close();\n    }\n    \n    private static char[][] rotate90(char[][] pattern) {\n        char[][] result = new char[8][8];\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                result[i][j] = pattern[7 - j][i];\n            }\n        }\n        return result;\n    }\n    \n    private static void printPattern(char[][] pattern) {\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                System.out.print(pattern[i][j]);\n            }\n            System.out.println();\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[]  new char[8][8]; for (int i = 0; i < 8; i++) { String line = sc.nextLine(); for  rotated90 = rotate90(pattern); printPattern(rotated90); // 180 degrees System.out.println(\"180\"); char[][] rotated180 = rotate90(rotated90); printPattern(rotated180); // 270 degrees System.out.println(\"270\"); char[][] rotated270 = rotate90(rotated180); printPattern(rotated270); sc.close(); } private static char[][] rotate90(char[][] pattern) { char[][] result = new char[8][8]; for (int i = 0; i < 8; i++) { for (int j = 0; j < 8; j++) { result[i][j] = pattern[7 -  pattern) { for (int i = 0; i < 8; i++) { for (int j = 0; j < 8; j++) { System.out.print(pattern[i][j]); } System.out.println(); } } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = \"\"; char[][] pattern = new char[8][8]; for (int i = 0; i < 8; i++) { line = br.readLine(); for (int j = 0; j < 8; j++) { pattern[i][j] = line.charAt(j); } } for  = rotate(pattern); System.out.println(i * 90); for (int j = 0; j < 8; j++) { System.out.println(new String(pattern[j])); } } } static  (int i = 0; i < 8; i++) { for (int j =  pattern[i][j]; } } return rotate; } }"], "original_ll": -0.5110419392585754, "sampled_ll": -0.2992696166038513, "all_perturbed_sampled_ll": [-1.0960354804992676], "all_perturbed_original_ll": [-1.103701114654541], "perturbed_sampled_ll": -1.0960354804992676, "perturbed_original_ll": -1.103701114654541, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "d=[list(raw_input()) for i in range(8)]\np=[d,[],[],[]]\nfor r in range(3):\n\tprint 90*(r+1)\n\tfor j in range(8):\n\t\tp[r+1].append([p[r][i][j] for i in range(7,-1,-1)])\n\t\tprint \"\".join(p[r+1][j])", "sampled": "# Read input\npattern = []\nfor _ in range(8):\n    pattern.append(input())\n\n# 90 degree rotation (clockwise)\nrotated_90 = []\nfor col in range(8):\n    row_str = \"\"\n    for row in range(7, -1, -1):\n        row_str += pattern[row][col]\n    rotated_90.append(row_str)\n\n# 180 degree rotation\nrotated_180 = []\nfor row in range(7, -1, -1):\n    rotated_180.append(pattern[row][::-1])\n\n# 270 degree rotation (clockwise)\nrotated_270 = []\nfor col in range(7, -1, -1):\n    row_str = \"\"\n    for row in range(8):\n        row_str += pattern[row][col]\n    rotated_270.append(row_str)\n\n# Output\nprint(\"90\")\nfor row in rotated_90:\n    print(row)\nprint(\"180\")\nfor row in rotated_180:\n    print(row)\nprint(\"270\")\nfor row in rotated_270:\n    print(row)\n", "perturbed_sampled": ["# Read input pattern = [] for _ in range(8): pattern.append(input()) # 90 degree rotation (clockwise) rotated_90 = [] for col in range(8): row_str = \"\" for row in range(7, -1, -1): row_str += pattern[row][col] rotated_90.append(row_str) # 180 degree rotation rotated_180 = [] for row in range(7, -1, -1): rotated_180.append(pattern[row][::-1]) # 270 degree rotation (clockwise) rotated_270 = []  row in range(8): row_str += pattern[row][col] rotated_270.append(row_str)  row in rotated_180: print(row) print(\"270\") for row in rotated_270: print(row)"], "perturbed_original": ["d=[list(raw_input()) for i in range(8)] p=[d,[],[],[]] for r in range(3): print 90*(r+1) for j in range(8): p[r+1].append([p[r][i][j] for i in range(7,-1,-1)]) print \"\".join(p[r+1][j])"], "original_ll": -1.9614473581314087, "sampled_ll": -0.5773162245750427, "all_perturbed_sampled_ll": [-1.3360705375671387], "all_perturbed_original_ll": [-2.0729663372039795], "perturbed_sampled_ll": -1.3360705375671387, "perturbed_original_ll": -2.0729663372039795, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n\n  int n, sum, in, i;\n\n  sum = 0;\n\n  scanf(\"%d\",&n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\",&in);\n    sum += in;\n  }\n\n  printf(\"%d\\n\",sum/n);\n\n  return 0;\n\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n        int v;\n        scanf(\"%d\", &v);\n        sum += v;\n    }\n    \n    printf(\"%lld\\n\", sum / n);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n); long long sum = 0; for (int i = 0; i < n; i++) { int v; scanf(\"%d\", &v);  }"], "perturbed_original": ["#include<stdio.h> int main(){ int n, sum, in, i; sum = 0; scanf(\"%d\",&n); for(i = 0; i < n; i++){ scanf(\"%d\",&in); sum += in; } printf(\"%d\\n\",sum/n); return 0; }"], "original_ll": -1.0676270723342896, "sampled_ll": -0.5388792753219604, "all_perturbed_sampled_ll": [-1.072289228439331], "all_perturbed_original_ll": [-1.0929228067398071], "perturbed_sampled_ll": -1.072289228439331, "perturbed_original_ll": -1.0929228067398071, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\n\n\n \npublic class Main {\n  public static void main(String[] args) {\n    InputReader sc = new InputReader(System.in);\n \n    int n = sc.nextInt();\n    long sum = 0;\n    for(int i = 0; i < n; i++){\n      sum += sc.nextInt();\n    }\n    System.out.println(sum/n);\n\n\n  }\n \n  \n \n  static class InputReader {\n      private InputStream stream;\n      private byte[] buf = new byte[1024];\n      private int curChar;\n      private int numChars;\n      private SpaceCharFilter filter;\n\n      public InputReader(InputStream stream) {\n          this.stream = stream;\n      }\n \n      public int next() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = stream.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n \n      public String nextStr() {\n        int c = next();\n        while(isSpaceChar(c)){c = next();}\n        StringBuffer str = new StringBuffer();\n        do{\n          str.append((char)c);\n          c = next();\n        }while(!isSpaceChar(c));\n        return str.toString();\n      }\n\n      public int nextInt() {\n          int c = next();\n          while (isSpaceChar(c))\n              c = next();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = next();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = next();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public boolean isSpaceChar(int c) {\n          if (filter != null)\n              return filter.isSpaceChar(c);\n          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n \n      public interface SpaceCharFilter {\n          public boolean isSpaceChar(int ch);\n      }\n  }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += sc.nextInt();\n        }\n        System.out.println(sum / n);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); long sum = 0; for (int i = 0; i < n; i++) { sum += sc.nextInt(); } System.out.println(sum / n); sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.util.Arrays; import java.util.InputMismatchException; import java.util.LinkedList; public class Main { public static void main(String[] args) { InputReader sc = new InputReader(System.in); int n = sc.nextInt(); long sum = 0; for(int i = 0; i < n;  { private InputStream stream; private byte[] buf = new byte[1024]; private int curChar; private int numChars; private SpaceCharFilter filter; public InputReader(InputStream stream) { this.stream = stream; } public int next() { if (numChars == -1) throw new InputMismatchException(); if (curChar >= numChars) { curChar = 0; try { numChars = stream.read(buf); } catch (IOException e) { throw new InputMismatchException(); } if (numChars <= 0) return -1; } return buf[curChar++]; } public String nextStr() { int c = next(); while(isSpaceChar(c)){c = next();} StringBuffer str = new StringBuffer();  int nextInt() { int c = next(); while (isSpaceChar(c)) c = next(); int sgn = 1; if (c == '-') {  > '9') throw new InputMismatchException(); res *= 10; res +=  res * sgn;  == '\\n' || c == '\\r' || c == '\\t' || c == -1; } public interface SpaceCharFilter { public boolean isSpaceChar(int ch); } } }"], "original_ll": -0.5630581378936768, "sampled_ll": -0.37894129753112793, "all_perturbed_sampled_ll": [-1.4446793794631958], "all_perturbed_original_ll": [-1.1781750917434692], "perturbed_sampled_ll": -1.4446793794631958, "perturbed_original_ll": -1.1781750917434692, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def main():\n    n = int(input())\n    a = 0\n    for _ in range(n):\n        a += int(input())\n    ans = a // n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()", "sampled": "n = int(input())\ntotal = 0\nfor _ in range(n):\n    total += int(input())\nprint(total // n)\n", "perturbed_sampled": ["n = int(input()) total = 0 for _ in range(n): total += int(input()) print(total // n)"], "perturbed_original": ["def main(): n = int(input()) a = 0 for _ in range(n): a += int(input()) ans = a // n print(ans) if __name__ == \"__main__\": main()"], "original_ll": -0.7077473402023315, "sampled_ll": -1.1342601776123047, "all_perturbed_sampled_ll": [-1.606427788734436], "all_perturbed_original_ll": [-1.1965289115905762], "perturbed_sampled_ll": -1.606427788734436, "perturbed_original_ll": -1.1965289115905762, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n    int n;\n    int h, m;\n    int i;\n    double angle;\n    \n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++){\n        scanf(\"%d:%d\", &h, &m);\n        \n        angle = h * 360 / 12 + 360 / 12 * m / 60.0;\n        angle -= (360 / 60 * m);\n        \n        if (angle > 180){\n            angle -= 360;\n        }\n        \n        if (-30 < angle && angle < 30){\n            printf(\"alert\\n\");\n        }\n        else if (-90 < angle && angle < 90){\n            printf(\"warning\\n\");\n        }\n        else {\n            printf(\"safe\\n\");\n        }\n    }\n    return (0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        int hh, mm;\n        scanf(\"%d:%d\", &hh, &mm);\n        \n        // Calculate angle of minute hand (6 degrees per minute)\n        double minute_angle = mm * 6.0;\n        \n        // Calculate angle of hour hand (30 degrees per hour + 0.5 degrees per minute)\n        double hour_angle = (hh % 12) * 30.0 + mm * 0.5;\n        \n        // Calculate the absolute difference\n        double diff = abs(hour_angle - minute_angle);\n        if (diff > 180.0) {\n            diff = 360.0 - diff;\n        }\n        \n        // Determine the output\n        if (diff >= 0 && diff < 30) {\n            printf(\"alert\\n\");\n        } else if (diff >= 90 && diff <= 180) {\n            printf(\"safe\\n\");\n        } else {\n            printf(\"warning\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int main() { int n; scanf(\"%d\", &n); for (int i = 0; i < n; i++) { int hh, mm; scanf(\"%d:%d\", &hh, &mm); // Calculate angle of minute hand (6 degrees per minute) double minute_angle = mm * 6.0; // Calculate angle of  minute) double hour_angle = (hh % 12) * 30.0 + mm * 0.5; // Calculate the absolute difference double diff  = 360.0 - diff; }  < 30) { printf(\"alert\\n\"); } else if (diff >= 90 && diff <= 180) { printf(\"safe\\n\"); } else { printf(\"warning\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int n; int h, m; int i; double angle; scanf(\"%d\", &n); for (i = 0; i < n; i++){ scanf(\"%d:%d\", &h, &m); angle = h * 360 / 12 + 360 / 12 * m / 60.0;  && angle < 30){ printf(\"alert\\n\"); } else if (-90 < angle && angle < 90){ printf(\"warning\\n\"); } else { printf(\"safe\\n\"); } } return (0); }"], "original_ll": -0.916720986366272, "sampled_ll": -0.6982060074806213, "all_perturbed_sampled_ll": [-1.4275565147399902], "all_perturbed_original_ll": [-1.3561502695083618], "perturbed_sampled_ll": -1.4275565147399902, "perturbed_original_ll": -1.3561502695083618, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main{\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        for(int i=0;i<n;i++) {\n           String[] s=sc.next().split(\":\");\n           int a=Integer.parseInt(s[0])*60;\n           int b=Integer.parseInt(s[1]);\n           int d=Math.abs((a+b)/2-b*6);\n           System.out.println(d<30||d>330?\"alert\":d<90||d>270?\"warning\":\"safe\");\n        }\n    }\n}\n", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String time = sc.nextLine();\n            String[] parts = time.split(\":\");\n            int hh = Integer.parseInt(parts[0]);\n            int mm = Integer.parseInt(parts[1]);\n            \n            // Calculate angle of hour hand from 12 o'clock\n            // Hour hand moves 30 degrees per hour and 0.5 degrees per minute\n            double hourAngle = (hh % 12) * 30.0 + mm * 0.5;\n            \n            // Calculate angle of minute hand from 12 o'clock\n            // Minute hand moves 6 degrees per minute\n            double minuteAngle = mm * 6.0;\n            \n            // Calculate the difference\n            double diff = Math.abs(hourAngle - minuteAngle);\n            \n            // The angle should be the smaller one (between 0 and 180)\n            if (diff > 180) {\n                diff = 360 - diff;\n            }\n            \n            if (diff >= 0 && diff < 30) {\n                System.out.println(\"alert\");\n            } else if (diff >= 90 && diff <= 180) {\n                System.out.println(\"safe\");\n            } else {\n                System.out.println(\"warning\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc =  = 0;  parts = time.split(\":\"); int hh = Integer.parseInt(parts[0]); int mm = Integer.parseInt(parts[1]); // Calculate angle of hour  per hour and 0.5 degrees per minute double hourAngle = (hh % 12) * 30.0 + mm *  // Minute hand moves 6 degrees per minute double minuteAngle = mm * 6.0; // Calculate the difference double diff = Math.abs(hourAngle - minuteAngle); // The angle should be the smaller one (between 0 and 180) if (diff > 180) { diff = 360 - diff; } if (diff >= 0 && diff < 30) { System.out.println(\"alert\"); } else if (diff >= 90 &&  } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main{ public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=sc.nextInt(); for(int i=0;i<n;i++) { String[] s=sc.next().split(\":\"); int a=Integer.parseInt(s[0])*60; int b=Integer.parseInt(s[1]); int d=Math.abs((a+b)/2-b*6); System.out.println(d<30||d>330?\"alert\":d<90||d>270?\"warning\":\"safe\"); } } }"], "original_ll": -1.3546119928359985, "sampled_ll": -0.6108269691467285, "all_perturbed_sampled_ll": [-1.6043643951416016], "all_perturbed_original_ll": [-1.4737211465835571], "perturbed_sampled_ll": -1.6043643951416016, "perturbed_original_ll": -1.4737211465835571, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N = int(input())\nfor i in range(N):\n    h, m = map(int, input().split(\":\"))\n    d = abs(60*h - 11*m)\n    v = min(d, 720 - d)\n    if v < 60:\n        print(\"alert\")\n    elif v < 180:\n        print(\"warning\")\n    else:\n        print(\"safe\")\n\n", "sampled": "n = int(input())\nfor _ in range(n):\n    time = input().strip()\n    hh, mm = map(int, time.split(':'))\n    \n    # Calculate hour hand angle (from 12 o'clock)\n    hour_angle = (hh % 12) * 30 + mm * 0.5\n    \n    # Calculate minute hand angle (from 12 o'clock)\n    minute_angle = mm * 6\n    \n    # Calculate the difference\n    diff = abs(hour_angle - minute_angle)\n    \n    # Take the smaller angle\n    if diff > 180:\n        diff = 360 - diff\n    \n    # Determine the status\n    if 0 <= diff < 30:\n        print(\"alert\")\n    elif 90 <= diff <= 180:\n        print(\"safe\")\n    else:\n        print(\"warning\")\n", "perturbed_sampled": ["n = int(input()) for _ in range(n): time = input().strip() hh, mm = map(int, time.split(':')) # Calculate hour hand angle (from 12 o'clock) hour_angle = (hh % 12) *  (from 12 o'clock) minute_angle = mm * 6 # Calculate the difference diff = abs(hour_angle - minute_angle) # Take the smaller angle if  the status if 0 <= diff < 30: print(\"alert\") elif 90 <= diff <= 180: print(\"safe\") else: print(\"warning\")"], "perturbed_original": ["N = int(input()) for i in range(N): h, m = map(int, input().split(\":\"))  d) if v < 60: print(\"alert\") elif v < 180: print(\"warning\") else: print(\"safe\")"], "original_ll": -1.1729199886322021, "sampled_ll": -0.8702866435050964, "all_perturbed_sampled_ll": [-1.9505130052566528], "all_perturbed_original_ll": [-2.140197992324829], "perturbed_sampled_ll": -1.9505130052566528, "perturbed_original_ll": -2.140197992324829, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\tint i,j,num[24+1],temp01;\n\tfloat time[24+1],temp02;\n\tfor(i=0;i<24;i++) {\n\t\tscanf(\"%d %f\",&num[i],&time[i]);\n\t}\n\tfor(i=0;i<8-1;i++) {\n\t\tfor(j=i+1;j<8;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=8;i<16-1;i++) {\n\t\tfor(j=i+1;j<16;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=16;i<24-1;i++) {\n\t\tfor(j=i+1;j<24;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<2;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t\ttime[i]=100.00;\n\t}\n\tfor(i=8;i<10;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t\ttime[i]=100.00;\n\t}\n\tfor(i=16;i<18;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t\ttime[i]=100.00;\n\t}\n\tfor(i=0;i<24-1;i++) {\n\t\tfor(j=i+1;j<24;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<2;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int player;\n    double time;\n} Record;\n\nint compare(const void *a, const void *b) {\n    Record *r1 = (Record *)a;\n    Record *r2 = (Record *)b;\n    if (r1->time < r2->time) return -1;\n    if (r1->time > r2->time) return 1;\n    return 0;\n}\n\nint main() {\n    Record groups[3][8];\n    Record qualifiers[8];\n    Record others[18];\n    int others_count = 0;\n    \n    // Read input\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 8; j++) {\n            scanf(\"%d %lf\", &groups[i][j].player, &groups[i][j].time);\n        }\n    }\n    \n    // Sort each group by time\n    for (int i = 0; i < 3; i++) {\n        qsort(groups[i], 8, sizeof(Record), compare);\n    }\n    \n    // First 2 from each group\n    qualifiers[0] = groups[0][0];\n    qualifiers[1] = groups[0][1];\n    qualifiers[2] = groups[1][0];\n    qualifiers[3] = groups[1][1];\n    qualifiers[4] = groups[2][0];\n    qualifiers[5] = groups[2][1];\n    \n    // Collect 3rd place and below from all groups\n    for (int i = 0; i < 3; i++) {\n        for (int j = 2; j < 8; j++) {\n            others[others_count++] = groups[i][j];\n        }\n    }\n    \n    // Sort others by time\n    qsort(others, others_count, sizeof(Record), compare);\n    \n    // Top 2 from others\n    qualifiers[6] = others[0];\n    qualifiers[7] = others[1];\n    \n    // Output\n    for (int i = 0; i < 8; i++) {\n        printf(\"%d %.2f\\n\", qualifiers[i].player, qualifiers[i].time);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int player; double time; } Record; int compare(const void *a, const void *b) { Record *r1 = (Record *)a; Record *r2 =  > r2->time) return  qualifiers[8];  (int i = 0; i < 3; i++) { for (int j = 0; j < 8; j++) { scanf(\"%d %lf\", &groups[i][j].player, &groups[i][j].time); } } // Sort each group by time for (int i = 0; i < 3; i++) { qsort(groups[i], 8, sizeof(Record), compare); } // First 2 from each group qualifiers[0] = groups[0][0]; qualifiers[1] = groups[0][1]; qualifiers[2] = groups[1][0]; qualifiers[3] = groups[1][1]; qualifiers[4] = groups[2][0]; qualifiers[5] = groups[2][1]; // Collect 3rd place and below  3; i++) { for (int j = 2; j < 8; j++) { others[others_count++] = groups[i][j]; } } // Sort others by time  = others[0]; qualifiers[7] = others[1]; //  { printf(\"%d %.2f\\n\", qualifiers[i].player, qualifiers[i].time); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int i,j,num[24+1],temp01; float time[24+1],temp02; for(i=0;i<24;i++) { scanf(\"%d %f\",&num[i],&time[i]); } for(i=0;i<8-1;i++) { for(j=i+1;j<8;j++) { if(time[i]>time[j]) { temp01=num[i]; num[i]=num[j]; num[j]=temp01; temp02=time[i]; time[i]=time[j]; time[j]=temp02; } } } for(i=8;i<16-1;i++) { for(j=i+1;j<16;j++) { if(time[i]>time[j]) { temp01=num[i]; num[i]=num[j]; num[j]=temp01; temp02=time[i]; time[i]=time[j]; time[j]=temp02; } }  temp02=time[i]; time[i]=time[j]; time[j]=temp02; } } } for(i=0;i<2;i++) { printf(\"%d %f\\n\",num[i],time[i]); time[i]=100.00; } for(i=8;i<10;i++) { printf(\"%d %f\\n\",num[i],time[i]); time[i]=100.00; } for(i=16;i<18;i++) { printf(\"%d %f\\n\",num[i],time[i]);  num[j]=temp01; temp02=time[i]; time[i]=time[j]; time[j]=temp02; } } } for(i=0;i<2;i++) { printf(\"%d %f\\n\",num[i],time[i]); } return 0; }"], "original_ll": -0.37221649289131165, "sampled_ll": -0.5337332487106323, "all_perturbed_sampled_ll": [-1.398045539855957], "all_perturbed_original_ll": [-0.6998007297515869], "perturbed_sampled_ll": -1.398045539855957, "perturbed_original_ll": -0.6998007297515869, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\nclass Player implements Comparable<Player>{\n\tint party;\n\tint num;\n\tString time;\n\tPlayer(int p,int n,String t){\n\t\tthis.party = p;\n\t\tthis.num = n;\n\t\tthis.time = t;\n\t}\n\t/*@Override\n\tpublic int compareTo(Player p) {\n\t\treturn this.time.compareTo(p.num);\n\t}\n\t*/\n\t@Override\n\tpublic int compareTo(Player o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn this.time.compareTo(o.time);\n\t}\n\t\n}\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tPlayer[] person = new Player[24];\n\t\tint[][] rank = new int[3][8];\n\t\tint[] cnt = new int[3]; \n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tint cnt3 = 0;\n\t\tfor(int i = 0;i < 3;i++){\n\t\t\tfor(int j = 0;j < 8;j++){\n\t\t\t\tperson[i*8+j] = new Player(i,sc.nextInt(),sc.next());\n\t\t\t}\n\t\t}\n\t\tArrays.sort(person);\n\t\tfor(int i = 0;i < 24;i++){\n\t\t\trank[person[i].party][cnt[person[i].party]] = i;\n\t\t\tcnt[person[i].party]++;\n\t\t}\n\t\tfor(int i = 0;i < 3;i++){\n\t\t\tfor(int j = 0;j < 2;j++){\n\t\t\t\tSystem.out.println(person[rank[i][j]].num+\" \"+person[rank[i][j]].time);\n\t\t\t\tperson[rank[i][j]].time = \"999\";\n\t\t\t}\n\t\t}\n\t\tArrays.sort(person);\n\t\tfor(int j = 0;j < 2;j++){\n\t\t\tSystem.out.println(person[j].num+\" \"+person[j].time);\n\t\t}\n\t\t\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Athlete implements Comparable<Athlete> {\n        int number;\n        double time;\n        \n        Athlete(int number, double time) {\n            this.number = number;\n            this.time = time;\n        }\n        \n        @Override\n        public int compareTo(Athlete other) {\n            return Double.compare(this.time, other.time);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        List<Athlete>[] groups = new List[3];\n        for (int i = 0; i < 3; i++) {\n            groups[i] = new ArrayList<>();\n        }\n        \n        // Read input\n        for (int i = 0; i < 24; i++) {\n            int number = sc.nextInt();\n            double time = sc.nextDouble();\n            int group = i / 8;\n            groups[group].add(new Athlete(number, time));\n        }\n        \n        // Sort each group by time\n        for (int i = 0; i < 3; i++) {\n            Collections.sort(groups[i]);\n        }\n        \n        // Output top 2 from each group\n        List<Athlete> finalists = new ArrayList<>();\n        for (int i = 0; i < 3; i++) {\n            finalists.add(groups[i].get(0));\n            finalists.add(groups[i].get(1));\n        }\n        \n        // Get 3rd place and below from all groups\n        List<Athlete> remaining = new ArrayList<>();\n        for (int i = 0; i < 3; i++) {\n            for (int j = 2; j < groups[i].size(); j++) {\n                remaining.add(groups[i].get(j));\n            }\n        }\n        \n        // Sort remaining athletes and get top 2\n        Collections.sort(remaining);\n        finalists.add(remaining.get(0));\n        finalists.add(remaining.get(1));\n        \n        // Output all finalists\n        for (Athlete a : finalists) {\n            System.out.println(a.number + \" \" + a.time);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Athlete implements Comparable<Athlete> { int number; double time; Athlete(int number, double  public int compareTo(Athlete  main(String[] args) { Scanner sc = new Scanner(System.in); List<Athlete>[] groups = new List[3]; for (int i = 0; i < 3; i++) { groups[i] = new ArrayList<>(); } // Read input for (int i = 0; i < 24; i++) { int number = sc.nextInt(); double time = sc.nextDouble(); int group = i / 8; groups[group].add(new Athlete(number, time)); } // Sort each group by time for (int i = 0; i < 3; i++) {  i < 3; i++) { finalists.add(groups[i].get(0)); finalists.add(groups[i].get(1)); } // Get 3rd place and below from all groups List<Athlete> remaining = new ArrayList<>(); for (int i =  2; j < groups[i].size();  get top 2 Collections.sort(remaining); finalists.add(remaining.get(0)); finalists.add(remaining.get(1)); // Output all finalists for (Athlete a : finalists) { System.out.println(a.number + \" \" + a.time); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; class Player implements Comparable<Player>{ int party; int num; String time; Player(int p,int n,String t){ this.party = p; this.num = n; this.time = t; } /*@Override public int compareTo(Player p) { return this.time.compareTo(p.num); } */ @Override public int compareTo(Player o) { // TODO  public static void main(String[] args){ Scanner sc = new Scanner(System.in); Player[] person = new Player[24]; int[][] rank = new int[3][8]; int[] cnt = new int[3]; int cnt1 = 0; int cnt2 = 0; int cnt3 = 0; for(int i = 0;i < 3;i++){  } } Arrays.sort(person); for(int i = 0;i < 24;i++){  3;i++){ for(int j =  Arrays.sort(person); for(int j = 0;j < 2;j++){ System.out.println(person[j].num+\" \"+person[j].time); } } }"], "original_ll": -0.8175483345985413, "sampled_ll": -0.5593482255935669, "all_perturbed_sampled_ll": [-1.3907040357589722], "all_perturbed_original_ll": [-1.4112114906311035], "perturbed_sampled_ll": -1.3907040357589722, "perturbed_original_ll": -1.4112114906311035, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "l1,l2,l3=[],[],[]\nfinal=[]\ncount=0\nfor i in range(24):\n    p,t=map(float,input().split())\n    if count<=7:l1.append([t,p])\n    elif 7<count<=15:l2.append([t,p])\n    elif 15<count<=23:l3.append([t,p])\n    count +=1\nl1=sorted(l1)\nl2=sorted(l2)\nl3=sorted(l3)\nfinal +=[l1[0],l1[1],l2[0],l2[1],l3[0],l3[1]]\ndel l1[0],l1[0],l2[0],l2[0],l3[0],l3[0]\nthird=sorted(l1+l2+l3)\nfinal +=[third[0],third[1]]\nfor i in range(8):print(int(final[i][1]),final[i][0])\n", "sampled": "# Read all 24 runners\nrunners = []\nfor i in range(24):\n    line = input().split()\n    p = int(line[0])\n    t = float(line[1])\n    runners.append((p, t))\n\n# Split into 3 groups\ngroup1 = runners[0:8]\ngroup2 = runners[8:16]\ngroup3 = runners[16:24]\n\n# Sort each group by time\ngroup1.sort(key=lambda x: x[1])\ngroup2.sort(key=lambda x: x[1])\ngroup3.sort(key=lambda x: x[1])\n\n# Top 2 from each group\nqualifiers = []\nqualifiers.append(group1[0])\nqualifiers.append(group1[1])\nqualifiers.append(group2[0])\nqualifiers.append(group2[1])\nqualifiers.append(group3[0])\nqualifiers.append(group3[1])\n\n# Collect 3rd place and below from all groups\nremaining = []\nremaining.extend(group1[2:])\nremaining.extend(group2[2:])\nremaining.extend(group3[2:])\n\n# Sort remaining by time and take top 2\nremaining.sort(key=lambda x: x[1])\nqualifiers.append(remaining[0])\nqualifiers.append(remaining[1])\n\n# Output\nfor p, t in qualifiers:\n    print(f\"{p} {t:.2f}\")\n", "perturbed_sampled": ["# Read all 24 runners runners = [] for i in range(24): line = input().split() p = int(line[0]) t =  runners[0:8] group2 = runners[8:16] group3 = runners[16:24] # Sort each group by time group1.sort(key=lambda x: x[1]) group2.sort(key=lambda x: x[1]) group3.sort(key=lambda x: x[1]) # Top 2 from  qualifiers.append(group3[1]) # Collect 3rd place and below from all  by time and take top 2 remaining.sort(key=lambda x: x[1]) qualifiers.append(remaining[0]) qualifiers.append(remaining[1]) # Output for p, t in qualifiers: print(f\"{p} {t:.2f}\")"], "perturbed_original": ["l1,l2,l3=[],[],[] final=[] count=0 for i in range(24): p,t=map(float,input().split()) if count<=7:l1.append([t,p]) elif 7<count<=15:l2.append([t,p]) elif 15<count<=23:l3.append([t,p]) count +=1 l1=sorted(l1) l2=sorted(l2) l3=sorted(l3) final +=[l1[0],l1[1],l2[0],l2[1],l3[0],l3[1]] del l1[0],l1[0],l2[0],l2[0],l3[0],l3[0] third=sorted(l1+l2+l3) final +=[third[0],third[1]] for i in range(8):print(int(final[i][1]),final[i][0])"], "original_ll": -1.0655614137649536, "sampled_ll": -0.8165257573127747, "all_perturbed_sampled_ll": [-2.134908676147461], "all_perturbed_original_ll": [-1.142121434211731], "perturbed_sampled_ll": -2.134908676147461, "perturbed_original_ll": -1.142121434211731, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n  char w[201];\n  int a,i,j,k;\n  scanf(\"%d\",&a);\n  for(j=0;j<a;j++){\n    scanf(\"%s\",w);\n    if(w[0]!='>'){printf(\"NA\\n\");continue;}\n    if(w[1]=='\\''){\n      for(i=2;w[i]!='#';i++){\n\tif(w[i]!='='){printf(\"NA\\n\");continue;}\n      }\n      int t=i-1;\n      for(k=t;t>0;t--){\n\tif(w[i++]!='='){printf(\"NA\\n\");continue;}\n      }\n      if(w[i++]!='~'){printf(\"NA\\n\");continue;}\n      if(w[i]!='\\0'){printf(\"NA\\n\");continue;}\n      printf(\"A\\n\");\n    }\n    if(w[1]=='^'){\n      for(i=2;w[i]=='~';i+=2){\n\tif(w[i]!='Q'){printf(\"NA\\n\");continue;}\n\tif(w[i+1]!='='){printf(\"NA\\n\");continue;}\n      }\n      if(w[i]!='~'){printf(\"NA\\n\");continue;}\n      if(w[i+1]!='~'){printf(\"NA\\n\");continue;}\n      if(w[i+2]!='\\0'){printf(\"NA\\n\");continue;}\n      printf(\"B\\n\");\n    }\n  }\nreturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint checkA(char *s) {\n    int len = strlen(s);\n    if (len < 6) return 0;\n    if (s[0] != '>' || s[1] != '\\'') return 0;\n    if (s[len-1] != '~') return 0;\n    \n    int i = 2;\n    int count1 = 0;\n    while (i < len && s[i] == '=') {\n        count1++;\n        i++;\n    }\n    \n    if (count1 == 0) return 0;\n    if (i >= len || s[i] != '#') return 0;\n    i++;\n    \n    int count2 = 0;\n    while (i < len && s[i] == '=') {\n        count2++;\n        i++;\n    }\n    \n    if (count2 != count1) return 0;\n    if (i != len - 1) return 0;\n    if (s[i] != '~') return 0;\n    \n    return 1;\n}\n\nint checkB(char *s) {\n    int len = strlen(s);\n    if (len < 6) return 0;\n    if (s[0] != '>' || s[1] != '^') return 0;\n    if (len < 2 || s[len-1] != '~' || s[len-2] != '~') return 0;\n    \n    int i = 2;\n    int count = 0;\n    while (i < len - 2) {\n        if (s[i] == 'Q' && i + 1 < len - 2 && s[i+1] == '=') {\n            count++;\n            i += 2;\n        } else {\n            return 0;\n        }\n    }\n    \n    if (count == 0) return 0;\n    if (i != len - 2) return 0;\n    \n    return 1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        char s[201];\n        scanf(\"%s\", s);\n        \n        if (checkA(s)) {\n            printf(\"A\\n\");\n        } else if (checkB(s)) {\n            printf(\"B\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int checkA(char *s) { int len = strlen(s); if (len < 6) return 0; if (s[0] != '>' || s[1] != '\\'') return 0; if (s[len-1] != '~') return 0; int i =  s[i] != '#') return 0; i++; int count2 = 0; while (i < len && s[i]  return 0; if (i != len - 1) return 0; if (s[i] != '~') return 0; return 1; } int checkB(char *s) { int len = strlen(s); if (len < 6) return 0; if (s[0] != '>' || s[1] !=  '~' || s[len-2] != '~') return 0; int i =  2) { if (s[i] == 'Q' && i + 1 < len - 2 && s[i+1] == '=') { count++; i += 2; } else { return 0; }  len - 2) return 0; return 1; } int main() { int n; scanf(\"%d\", &n); for (int i = 0; i < n; i++) { char s[201]; scanf(\"%s\", s); if (checkA(s)) { printf(\"A\\n\"); } else if (checkB(s)) { printf(\"B\\n\"); } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ char w[201]; int a,i,j,k; scanf(\"%d\",&a);  if(w[i++]!='='){printf(\"NA\\n\");continue;} } if(w[i++]!='~'){printf(\"NA\\n\");continue;} if(w[i]!='\\0'){printf(\"NA\\n\");continue;} printf(\"A\\n\"); } if(w[1]=='^'){ for(i=2;w[i]=='~';i+=2){ if(w[i]!='Q'){printf(\"NA\\n\");continue;} if(w[i+1]!='='){printf(\"NA\\n\");continue;} } if(w[i]!='~'){printf(\"NA\\n\");continue;} if(w[i+1]!='~'){printf(\"NA\\n\");continue;} if(w[i+2]!='\\0'){printf(\"NA\\n\");continue;} printf(\"B\\n\"); } } return 0; }"], "original_ll": -1.0813062191009521, "sampled_ll": -0.568453311920166, "all_perturbed_sampled_ll": [-1.0714608430862427], "all_perturbed_original_ll": [-1.3894431591033936], "perturbed_sampled_ll": -1.0714608430862427, "perturbed_original_ll": -1.3894431591033936, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<String> Ans = new ArrayList<String>();\n\t\tString line = in.readLine();\n\t\t\n\t\tint size = Integer.parseInt(line);\n\t\tfor(int n=0; n<size; n++){\n\t\t\tline = in.readLine();\n\t\t\tint type = 0;\n\t\t\t\n\t\t\tString c = line.substring(0, 2);\n\t\t\tif(c.equals(\">'\")){\n\t\t\t\tint count = 0;\n\t\t\t\tint sharp = 0;\n\t\t\t\tfor(int i=2; i<line.length(); i++){\n\t\t\t\t\tc = line.substring(i, i+1);\n\t\t\t\t\tif(c.equals(\"=\")){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(c.equals(\"#\")){\n\t\t\t\t\t\tif(count > 0){\n\t\t\t\t\t\t\tcount = -count;\n\t\t\t\t\t\t\tsharp = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(c.equals(\"~\")){\n\t\t\t\t\t\tif(i != line.length()-1){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(count==0 && sharp==1){\n\t\t\t\t\t\t\ttype = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(c.equals(\">^\")){\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i=2; i<line.length(); i++){\n\t\t\t\t\tc = line.substring(i, i+1);\n\t\t\t\t\tif(count%2==0 && count>=2 && c.equals(\"~\")){\n\t\t\t\t\t\tif(i==line.length()-1){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tc = line.substring(i+1, i+2);\n\t\t\t\t\t\tif(c.equals(\"~\")){\n\t\t\t\t\t\t\ttype = 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2==0){\n\t\t\t\t\t\tif(!c.equals(\"Q\")){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2==1){\n\t\t\t\t\t\tif(!c.equals(\"=\")){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!c.equals(\"Q\") && !c.equals(\"=\") && !c.equals(\"~\")){\n\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttype = -1;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(type){\n\t\t\t\tcase 1:\n\t\t\t\t\tAns.add(\"A\");\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 2:\n\t\t\t\t\tAns.add(\"B\");\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tAns.add(\"NA\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tSystem.out.println(Ans.get(n));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String s = sc.nextLine();\n            System.out.println(classify(s));\n        }\n        sc.close();\n    }\n    \n    static String classify(String s) {\n        if (isTypeA(s)) {\n            return \"A\";\n        } else if (isTypeB(s)) {\n            return \"B\";\n        } else {\n            return \"NA\";\n        }\n    }\n    \n    static boolean isTypeA(String s) {\n        // Pattern: >'=+#=+~\n        // Must start with >'\n        if (!s.startsWith(\">'\")) {\n            return false;\n        }\n        \n        // Must end with ~\n        if (!s.endsWith(\"~\")) {\n            return false;\n        }\n        \n        // Find # position\n        int hashPos = s.indexOf('#');\n        if (hashPos == -1) {\n            return false;\n        }\n        \n        // Check if there's only one #\n        if (s.indexOf('#', hashPos + 1) != -1) {\n            return false;\n        }\n        \n        // Extract parts\n        String beforeHash = s.substring(2, hashPos);\n        String afterHash = s.substring(hashPos + 1, s.length() - 1);\n        \n        // Both parts must be non-empty and consist only of '='\n        if (beforeHash.length() == 0 || afterHash.length() == 0) {\n            return false;\n        }\n        \n        // Both parts must have same length and only contain '='\n        if (beforeHash.length() != afterHash.length()) {\n            return false;\n        }\n        \n        for (char c : beforeHash.toCharArray()) {\n            if (c != '=') {\n                return false;\n            }\n        }\n        \n        for (char c : afterHash.toCharArray()) {\n            if (c != '=') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    static boolean isTypeB(String s) {\n        // Pattern: >^(Q=)+~~\n        // Must start with >^\n        if (!s.startsWith(\">^\")) {\n            return false;\n        }\n        \n        // Must end with ~~\n        if (!s.endsWith(\"~~\")) {\n            return false;\n        }\n        \n        // Extract middle part\n        String middle = s.substring(2, s.length() - 2);\n        \n        // Middle must be non-empty\n        if (middle.length() == 0) {\n            return false;\n        }\n        \n        // Middle must be repetitions of \"Q=\"\n        if (middle.length() % 2 != 0) {\n            return false;\n        }\n        \n        for (int i = 0; i < middle.length(); i += 2) {\n            if (middle.charAt(i) != 'Q' || middle.charAt(i + 1) != '=') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); for (int i = 0; i < n;   } else if (isTypeB(s)) { return \"B\"; } else { return \"NA\"; } } static boolean isTypeA(String s) { // Pattern: >'=+#=+~ // Must start with >' if (!s.startsWith(\">'\")) { return false; } // Must end with ~ if (!s.endsWith(\"~\")) { return false; } // Find # position int hashPos = s.indexOf('#'); if (hashPos == -1)  # if (s.indexOf('#', hashPos + 1) != -1) { return false; } // Extract parts String beforeHash = s.substring(2, hashPos); String afterHash = s.substring(hashPos +  and consist only of '=' if (beforeHash.length() == 0 || afterHash.length() == 0) { return false; } // Both parts must have same length and only contain '='  return false; } } for (char c : afterHash.toCharArray()) { if (c != '=') { return false; } } return true; } static boolean isTypeB(String s) { // Pattern: >^(Q=)+~~ // Must start with >^ if (!s.startsWith(\">^\")) { return false; } // Must end with ~~ if (!s.endsWith(\"~~\")) { return false; } // Extract middle part String middle = s.substring(2, s.length() - 2); // Middle must be non-empty if (middle.length() == 0) { return false; } // Middle must be repetitions of \"Q=\" if (middle.length() %  if (middle.charAt(i) != 'Q' ||  return true; } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static void main(String[] args){ try{ new Main(); }catch(IOException e){ e.printStackTrace(); } } public Main() throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); List<String> Ans = new ArrayList<String>(); String line = in.readLine(); int size = Integer.parseInt(line); for(int n=0; n<size; n++){ line = in.readLine(); int type = 0; String c = line.substring(0, 2); if(c.equals(\">'\")){ int count =  = line.substring(i, i+1); if(c.equals(\"=\")){ count++; } else  } else{ type = -1; break; } } else if(c.equals(\"~\")){ if(i  break;  else if(c.equals(\">^\")){ int count = 0; for(int i=2; i<line.length(); i++){ c = line.substring(i, i+1); if(count%2==0 && count>=2 && c.equals(\"~\")){ if(i==line.length()-1){ type = -1; break; } c = line.substring(i+1, i+2); if(c.equals(\"~\")){ type = 2; break; } else{ type = -1; break; } } if(i%2==0){ if(!c.equals(\"Q\")){ type = -1; break; } count++; } if(i%2==1){ if(!c.equals(\"=\")){ type = -1; break; } count++; } if(!c.equals(\"Q\") && !c.equals(\"=\") && !c.equals(\"~\")){ type =  switch(type){ case 1: Ans.add(\"A\"); break; case 2: Ans.add(\"B\"); break; default: Ans.add(\"NA\"); } } for(int n=0; n<Ans.size(); n++){ System.out.println(Ans.get(n)); } } }"], "original_ll": -0.7134687304496765, "sampled_ll": -0.6665359139442444, "all_perturbed_sampled_ll": [-1.5695757865905762], "all_perturbed_original_ll": [-1.2523152828216553], "perturbed_sampled_ll": -1.5695757865905762, "perturbed_original_ll": -1.2523152828216553, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nN = int(input())\n\ndef is_A(s):\n    if s[0:2] != \">'\":\n        return False\n\n    if s[-1] != '~':\n        return False\n\n    body = s[2:-1]\n\n    if len(body) % 2 == 0:\n        return False\n\n    # body = '==#=='\n    center_index = len(body) // 2\n    if body[center_index] != '#':\n        return False\n\n    if body.count('#') != 1:\n        return False\n\n    lst = body.split('#')\n    if len(lst) != 2:\n        return False\n\n    if len(lst[0]) > 0 and lst[0] == lst[1] and len(lst[0]) == lst[0].count('='):\n        return True\n    else:\n        return False\n\ndef is_B(s):\n    if s[0:2] != \">^\":\n        return False\n\n    if s[-2:] != '~~':\n        return False\n\n    body = s[2:-2]\n\n    if len(body) % 2 != 0:\n        return False\n    elif body.count('Q=') > 0 and body.count('Q=') == len(body) // 2:\n        return True\n    else:\n        return False\n\nfor s in sys.stdin:\n    s = s.strip()\n\n    if is_A(s):\n        print('A')\n    elif is_B(s):\n        print('B')\n    else:\n        print('NA')", "sampled": "import re\n\nn = int(input())\nfor _ in range(n):\n    s = input().strip()\n    \n    # Check for Type A: >'=+#=+~\n    match_a = re.match(r\"^>\\'(=+)#\\1~$\", s)\n    if match_a:\n        print(\"A\")\n        continue\n    \n    # Check for Type B: >^(Q=)+~~\n    match_b = re.match(r\"^>\\^(Q=)+~~$\", s)\n    if match_b:\n        print(\"B\")\n        continue\n    \n    print(\"NA\")\n", "perturbed_sampled": ["import re n = int(input()) for _ in range(n): s  re.match(r\"^>\\'(=+)#\\1~$\", s) if match_a: print(\"A\") continue # Check for Type B: >^(Q=)+~~ match_b = re.match(r\"^>\\^(Q=)+~~$\", s) if match_b: print(\"B\") continue print(\"NA\")"], "perturbed_original": ["# -*-  def is_A(s): if s[0:2] != \">'\": return False if s[-1] != '~': return False body = s[2:-1] if len(body)  center_index  if len(lst) != 2: return False if len(lst[0]) > 0 and lst[0] == lst[1] and len(lst[0]) == lst[0].count('='): return True else: return False def is_B(s): if s[0:2] != \">^\": return False if s[-2:] != '~~': return False body = s[2:-2] if len(body) % 2 != 0: return False elif body.count('Q=') > 0 and body.count('Q=') == len(body) // 2: return True else: return False for s in sys.stdin: s = s.strip() if is_A(s): print('A') elif is_B(s): print('B') else: print('NA')"], "original_ll": -0.9942391514778137, "sampled_ll": -1.8081978559494019, "all_perturbed_sampled_ll": [-3.2223944664001465], "all_perturbed_original_ll": [-1.5949941873550415], "perturbed_sampled_ll": -3.2223944664001465, "perturbed_original_ll": -1.5949941873550415, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(){\n\tchar tei[15]={0,1,2,3,4,5,6,7,8,9,5,4,3,2,1},ans[1000][20];\n\tint n,i,to,from,j;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tif(from<to){\n\t\t\t\tfor(j=from;j<to;j++){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",to);\n\t\t}else if(to==5){\n\t\t\tfor(j=from;j<=9;j++){\n\t\t\t\tprintf(\"%d \",j);\n\t\t\t}\n\t\t\tputs(\"5\");\n\t\t}else if(from>to){\n\t\t\tif(from>=6&&from<=9){\n\t\t\t\tfor(j=from;j<=9;j++){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tfor(j=5;j>to;j--){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",to);\n\t\t\t}else{\n\t\t\t\tfor(j=from;j>to;j--){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int start, end;\n        scanf(\"%d %d\", &start, &end);\n        \n        // Calculate distances for different routes\n        int dist_forward = 0;\n        int dist_backward = 0;\n        \n        // Going forward (clockwise direction)\n        if (start <= 5 && end <= 5) {\n            if (end > start) {\n                dist_forward = end - start;\n            } else {\n                // Need to go through the loop\n                dist_forward = (5 - start) + 1 + (9 - 5) + 1 + (5 - end);\n            }\n        } else if (start <= 5 && end > 5) {\n            // From main line to loop\n            if (start <= 5) {\n                dist_forward = (5 - start) + (end - 5);\n            }\n        } else if (start > 5 && end <= 5) {\n            // From loop to main line\n            if (end <= 5) {\n                if (start == 9) dist_forward = 1 + end;\n                else if (start == 8) dist_forward = 2 + end;\n                else if (start == 7) dist_forward = 3 + end;\n                else if (start == 6) dist_forward = 4 + end;\n            }\n        } else {\n            // Both in loop\n            if (end > start) {\n                dist_forward = end - start;\n            } else {\n                dist_forward = (9 - start) + 1 + (end - 5);\n            }\n        }\n        \n        // Going backward (counter-clockwise)\n        if (start <= 5 && end <= 5) {\n            if (end < start) {\n                dist_backward = start - end;\n            } else {\n                // Need to go through the loop\n                dist_backward = start + 1 + (9 - 5) + 1 + (5 - end);\n            }\n        } else if (start <= 5 && end > 5) {\n            // From main line to loop through 0\n            dist_backward = start + 1 + (9 - end) + 1;\n        } else if (start > 5 && end <= 5) {\n            // From loop to main line\n            if (start == 6) dist_backward = 1 + (5 - end);\n            else if (start == 7) dist_backward = 2 + (5 - end);\n            else if (start == 8) dist_backward = 3 + (5 - end);\n            else if (start == 9) dist_backward = 4 + (5 - end);\n        } else {\n            // Both in loop\n            if (end < start) {\n                dist_backward = start - end;\n            } else {\n                dist_backward = (start - 5) + 1 + (9 - end) + 1;\n            }\n        }\n        \n        // Choose the shorter route\n        int go_forward = (dist_forward <= dist_backward);\n        \n        int pos = start;\n        printf(\"%d\", pos);\n        \n        while (pos != end) {\n            if (go_forward) {\n                if (pos < 5) {\n                    pos++;\n                } else if (pos == 5) {\n                    if (end > 5 || end == 0) {\n                        pos = 6;\n                    } else {\n                        pos--;\n                    }\n                } else if (pos >= 6 && pos <= 8) {\n                    pos++;\n                } else if (pos == 9) {\n                    pos = 5;\n                }\n            } else {\n                if (pos > 0 && pos <= 5) {\n                    pos--;\n                } else if (pos == 6) {\n                    pos = 5;\n                } else if (pos >= 7 && pos <= 9) {\n                    pos--;\n                } else if (pos == 0) {\n                    pos = 1;\n                }\n            }\n            printf(\" %d\", pos);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n); while (n--) { int start, end; scanf(\"%d %d\", &start, &end); // Calculate distances for different  Going forward (clockwise direction) if (start <= 5 && end <= 5) { if (end > start) { dist_forward = end - start; } else {  - start) + 1 + (9 - 5) + 1 + (5 - end); } } else if (start <= 5 && end > 5) { // From main line to loop if (start <= 5) { dist_forward = (5 - start) + (end - 5); } } else if (start >  main line if (end <= 5) { if (start == 9) dist_forward = 1 +  end; else if (start == 7) dist_forward = 3 + end; else if (start == 6) dist_forward = 4 + end; } } else { // Both in loop if  else { dist_forward = (9 - start) + 1 + (end - 5); } } // Going backward (counter-clockwise) if (start <= 5 && end <= 5) { if (end < start) { dist_backward = start - end; } else { // Need to go through the loop dist_backward = start + 1 + (9 - 5) + 1 + (5 - end); } } else if (start <= 5 && end > 5) { // From main line to loop through 0 dist_backward = start + 1 + (9 - end) + 1; } else if (start > 5 && end <= 5) { // From loop to main line if (start == 6) dist_backward = 1 + (5 - end); else if  else if (start == 8) dist_backward = 3 +  Both in loop if (end < start) { dist_backward = start - end; } else { dist_backward = (start - 5) + 1 + (9 - end) + 1; } } // Choose the shorter route int go_forward = (dist_forward <= dist_backward); int pos = start; printf(\"%d\", pos); while (pos != end) { if (go_forward) { if (pos <  if  6; } else { pos--; } } else if (pos >= 6 && pos  { pos =  pos <= 5) { pos--;   { pos--; } else  printf(\" %d\", pos); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ char tei[15]={0,1,2,3,4,5,6,7,8,9,5,4,3,2,1},ans[1000][20]; int n,i,to,from,j; scanf(\"%d\",&n); for(i=0;i<n;i++){ scanf(\"%d %d\",&from,&to); if(from<to){ for(j=from;j<to;j++){ printf(\"%d \",j); } printf(\"%d\\n\",to); }else  printf(\"%d \",j); } for(j=5;j>to;j--){ printf(\"%d \",j); } printf(\"%d\\n\",to); }else{ for(j=from;j>to;j--){ printf(\"%d \",j); } printf(\"%d\\n\",to); } } } return 0; }"], "original_ll": -0.9631760716438293, "sampled_ll": -0.6340625286102295, "all_perturbed_sampled_ll": [-1.4995499849319458], "all_perturbed_original_ll": [-1.2587381601333618], "perturbed_sampled_ll": -1.4995499849319458, "perturbed_original_ll": -1.2587381601333618, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nclass Main{\n    public static void main(String[] args){\n\tBufferedReader sc=new BufferedReader(new InputStreamReader(System.in));\n\ttry {\n\t    int n = Integer.valueOf(sc.readLine());\n\t    ArrayList<Integer> road;\n\t    for(int i=0; i<n; i++){\n\t\troad = new ArrayList<Integer>();\n\t\tString[] st = sc.readLine().split(\" \");\n\t\tint in = Integer.valueOf(st[0]), out = Integer.valueOf(st[1]);\n\t\tif(in<=5)\n\t\t    if(in>out)\n\t\t\tfor(int j=in; j>=out; j--)\n\t\t\t    road.add(j);\n\t\t    else\n\t\t\tfor(int j=in; j<=out; j++)\n\t\t\t    road.add(j);\n\t\telse{\n\t\t    if(out>in)\n\t\t\tfor(int j=in; j<=out; j++)\n\t\t\t    road.add(j);\n\t\t    else{\n\t\t\tfor(int j=in; j<=9; j++)\n\t\t\t    road.add(j);\n\t\t\tif(out>=5){\n\t\t\t    for(int j=5; j>=0; j--)\n\t\t\t\troad.add(j);\n\t\t\t    for(int j=1; j<=out; j++)\n\t\t\t\troad.add(j);\n\t\t\t}\n\t\t\telse\n\t\t\t    for(int j=5; j>=out; j--)\n\t\t\t\troad.add(j);\n\t\t    }\n\t\t}\n\t\tfor(int j=0; j<road.size()-1; j++)\n\t\t    System.out.print(road.get(j)+\" \");\n\t\tSystem.out.println(road.get(road.size()-1));\n\t    }\n\t}catch(Exception e){\n\t    System.out.println(\"Error\");\n\t}\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            int start = sc.nextInt();\n            int end = sc.nextInt();\n            \n            List<Integer> path = findPath(start, end);\n            \n            for (int j = 0; j < path.size(); j++) {\n                if (j > 0) System.out.print(\" \");\n                System.out.print(path.get(j));\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n    \n    static List<Integer> findPath(int start, int end) {\n        List<Integer> path = new ArrayList<>();\n        \n        // Calculate distances for both directions\n        int dist1 = distanceClockwise(start, end);\n        int dist2 = distanceCounterClockwise(start, end);\n        \n        if (dist1 <= dist2) {\n            // Go clockwise\n            int current = start;\n            path.add(current);\n            while (current != end) {\n                current = next(current);\n                path.add(current);\n            }\n        } else {\n            // Go counterclockwise\n            int current = start;\n            path.add(current);\n            while (current != end) {\n                current = prev(current);\n                path.add(current);\n            }\n        }\n        \n        return path;\n    }\n    \n    static int distanceClockwise(int start, int end) {\n        int dist = 0;\n        int current = start;\n        while (current != end) {\n            current = next(current);\n            dist++;\n            if (dist > 20) return Integer.MAX_VALUE; // Safety check\n        }\n        return dist;\n    }\n    \n    static int distanceCounterClockwise(int start, int end) {\n        int dist = 0;\n        int current = start;\n        while (current != end) {\n            current = prev(current);\n            dist++;\n            if (dist > 20) return Integer.MAX_VALUE; // Safety check\n        }\n        return dist;\n    }\n    \n    static int next(int pos) {\n        if (pos >= 0 && pos < 5) {\n            return pos + 1;\n        } else if (pos == 5) {\n            return 6;\n        } else if (pos == 6) {\n            return 7;\n        } else if (pos == 7) {\n            return 8;\n        } else if (pos == 8) {\n            return 9;\n        } else if (pos == 9) {\n            return 5;\n        }\n        return -1;\n    }\n    \n    static int prev(int pos) {\n        if (pos >= 1 && pos <= 5) {\n            return pos - 1;\n        } else if (pos == 6) {\n            return 5;\n        } else if (pos == 7) {\n            return 6;\n        } else if (pos == 8) {\n            return 7;\n        } else if (pos == 9) {\n            return 8;\n        } else if (pos == 0) {\n            return -1; // Can't go back from 0\n        }\n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new  i < n; i++) { int start = sc.nextInt(); int end = sc.nextInt(); List<Integer> path = findPath(start, end); for (int j = 0; j < path.size(); j++) { if (j > 0) System.out.print(\" \"); System.out.print(path.get(j)); } System.out.println(); } sc.close(); } static List<Integer> findPath(int start, int end) { List<Integer> path = new ArrayList<>(); // Calculate distances for both directions int dist1 = distanceClockwise(start, end); int dist2 = distanceCounterClockwise(start, end); if (dist1 <= dist2) { // Go clockwise int  = next(current); path.add(current);  start; path.add(current); while (current != end) { current = prev(current); path.add(current); } } return path; } static int distanceClockwise(int start, int end) { int dist = 0; int current = start; while (current != end) { current = next(current); dist++; if (dist > 20)  int distanceCounterClockwise(int start, int end) { int dist = 0; int current = start; while (current != end) { current = prev(current); dist++; if (dist > 20) return  next(int pos) { if (pos >= 0 &&   (pos == 6) { return 7; } else if (pos == 7) { return  } else if (pos == 9) { return 5; } return -1; } static int prev(int pos) { if (pos >= 1 && pos <= 5) { return pos - 1; } else if (pos == 6) { return 5; } else if (pos == 7) { return 6; } else if (pos == 8) { return 7; } else if (pos ==  } return -1; } }"], "perturbed_original": ["import java.io.*; import java.util.*; import java.math.*; class <extra_id_1>if(in<5) i++; else<extra_id_2>j++) s<extra_id_3>if (j<=0)<extra_id_4>; } try { int n = Integer.valueOf(sc.readLine()); ArrayList<Integer> road; for(int i=0; i<n; i++){ road = new ArrayList<Integer>(); String[] st = sc.readLine().split(\" \"); int in = Integer.valueOf(st[0]), out = Integer.valueOf(st[1]); if(in<=5) if(in>out) for(int j=in; j>=out; j--) road.add(j); else for(int j=in; j<=out; j++) road.add(j); else{ if(out>in) for(int j=in; j<=out; j++) road.add(j); else{ for(int j=in; j<=9; j++) road.add(j); if(out>=5){ for(int j=5; j>=0; j--) road.add(j);  j--) road.add(j); } } for(int j=0; j<road.size()-1;  }"], "original_ll": -0.8656141757965088, "sampled_ll": -0.3843637704849243, "all_perturbed_sampled_ll": [-1.0414263010025024], "all_perturbed_original_ll": [-1.7693760395050049], "perturbed_sampled_ll": -1.0414263010025024, "perturbed_original_ll": -1.7693760395050049, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for _ in [0]*input():\n  A = \"012345678954321\"\n  A += A\n  a, b = raw_input().split()\n  i1 = A.index(a)\n  i2 = A.index(a,i1+1)\n  i3 = A.index(b,i1)\n  if i2<i3: i1=i2\n  print \" \".join(A[i1:i3+1])", "sampled": "from collections import deque\n\ndef find_path(start, end):\n    # BFS to find shortest path\n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        current, path = queue.popleft()\n        \n        if current == end:\n            return path\n        \n        # Get neighbors based on bus route structure\n        neighbors = []\n        \n        if current == 0:\n            neighbors = [1]\n        elif current == 1:\n            neighbors = [0, 2]\n        elif current == 2:\n            neighbors = [1, 3]\n        elif current == 3:\n            neighbors = [2, 4]\n        elif current == 4:\n            neighbors = [3, 5]\n        elif current == 5:\n            neighbors = [4, 6, 9]\n        elif current == 6:\n            neighbors = [5, 7]\n        elif current == 7:\n            neighbors = [6, 8]\n        elif current == 8:\n            neighbors = [7, 9]\n        elif current == 9:\n            neighbors = [8, 5]\n        \n        for neighbor in neighbors:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, path + [neighbor]))\n    \n    return []\n\nn = int(input())\nfor _ in range(n):\n    start, end = map(int, input().split())\n    path = find_path(start, end)\n    print(' '.join(map(str, path)))\n", "perturbed_sampled": ["from collections import deque def find_path(start, end): # BFS to find shortest path queue = deque([(start, [start])]) visited = {start} while queue: current, path = queue.popleft() if current == end: return path # Get neighbors based on bus route structure neighbors = [] if current == 0: neighbors = [1] elif current == 1: neighbors  3] elif current == 3: neighbors = [2, 4] elif current == 4: neighbors = [3, 5] elif  == 6: neighbors = [5, 7] elif current == 7: neighbors = [6, 8] elif current == 8: neighbors = [7, 9] elif  neighbors: if  [] n = int(input()) for _ in range(n): start, end = map(int, input().split()) path = find_path(start, end) print(' '.join(map(str, path)))"], "perturbed_original": ["for _ in [0]*input(): A = \"012345678954321\" A += A a, b = raw_input().split() i1 = A.index(a) i2 = A.index(a,i1+1) i3 = A.index(b,i1) if i2<i3: i1=i2 print \" \".join(A[i1:i3+1])"], "original_ll": -1.6256858110427856, "sampled_ll": -0.483831524848938, "all_perturbed_sampled_ll": [-1.3084646463394165], "all_perturbed_original_ll": [-1.9939701557159424], "perturbed_sampled_ll": -1.3084646463394165, "perturbed_original_ll": -1.9939701557159424, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0141:   Spiral Pattern\n// 2017.8.4\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *gets(char *);\nchar buf[100];\n\nchar a[105][105];\n#define U 1\n#define R 2\n#define D 3\n#define L 4\n\nint main()\n{\n\tint r, c, n, d, stop;\n\tint ci, cn;\n\n\tgets(buf);\n\tcn = atoi(buf);\n\tfor (ci = 0; ci < cn; ci++) {\n\t\tgets(buf);\n\t\tn = atoi(buf);\n\t\tmemset(a, ' ', sizeof(a));\n\t\tfor (r = 0; r < n + 4; r += n + 3) {\n\t\t\tfor (c = 0; c < n + 4; c++) a[r][c] = '#';\n\t\t}\n\t\tfor (c = 0; c < n + 4; c += n + 3) {\n\t\t\tfor (r = 0; r < n + 4; r++) a[r][c] = '#';\n\t\t}\n\t\tr = n + 1, c = 2, d = U, stop = 0, a[r][c] = '#';\n\t\twhile (1) {\n\t\t\tif (stop >= 4) break;\n\t\t\tif (d == U) {\n\t\t\t\tif (a[r-2][c] == '#' || a[r-1][c] == '#' || a[r-1][c+1] == '#') d = R, stop++;\n\t\t\t\telse a[--r][c] = '#', stop = 0;\n\t\t\t}\n\t\t\tif (d == R) {\n\t\t\t\tif (a[r][c+2] == '#' || a[r][c+1] == '#' || a[r+1][c+1] == '#') d = D, stop++;\n\t\t\t\telse a[r][++c] = '#', stop = 0;\n\t\t\t}\n\t\t\tif (d == D) {\n\t\t\t\tif (a[r+2][c] == '#' || a[r+1][c] == '#' || a[r+1][c-1] == '#') d = L, stop++;\n\t\t\t\telse a[++r][c] = '#', stop = 0;\n\t\t\t}\n\t\t\tif (d == L){\n\t\t\t\tif (a[r][c-2] == '#' || a[r][c-1] == '#' || a[r-1][c-1] == '#') d = U, stop++;\n\t\t\t\telse a[r][--c] = '#', stop = 0;\n\t\t\t}\n\t\t}\n\t\tif (ci > 0) putchar('\\n');\n\t\tfor (r = 2; r < n + 2; r++) {\n\t\t\ta[r][n + 2] = 0;\n\t\t\tputs(a[r]+2);\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int d, n;\n    scanf(\"%d\", &d);\n    \n    for (int dataset = 0; dataset < d; dataset++) {\n        scanf(\"%d\", &n);\n        \n        char grid[100][100];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = ' ';\n            }\n        }\n        \n        int minRow = 0, maxRow = n - 1;\n        int minCol = 0, maxCol = n - 1;\n        \n        while (minRow <= maxRow && minCol <= maxCol) {\n            // Bottom row (left to right)\n            for (int j = minCol; j <= maxCol; j++) {\n                grid[maxRow][j] = '#';\n            }\n            \n            // Right column (bottom to top)\n            for (int i = maxRow; i >= minRow; i--) {\n                grid[i][maxCol] = '#';\n            }\n            \n            // Top row (right to left)\n            if (minRow < maxRow) {\n                for (int j = maxCol; j >= minCol; j--) {\n                    grid[minRow][j] = '#';\n                }\n            }\n            \n            // Left column (top to bottom)\n            if (minCol < maxCol) {\n                for (int i = minRow; i <= maxRow; i++) {\n                    grid[i][minCol] = '#';\n                }\n            }\n            \n            minRow += 2;\n            maxRow -= 2;\n            minCol += 2;\n            maxCol -= 2;\n        }\n        \n        // Print grid\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                printf(\"%c\", grid[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        \n        if (dataset < d - 1) {\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int d, n; scanf(\"%d\", &d); for (int dataset = 0; dataset < d; dataset++) { scanf(\"%d\", &n); char grid[100][100]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++)  0, maxRow = n - 1; int minCol = 0, maxCol = n - 1; while (minRow <= maxRow && minCol <= maxCol) { // Bottom row (left to right) for  for (int i = maxRow; i >= minRow; i--) { grid[i][maxCol] = '#'; } // Top  (int j = maxCol; j >= minCol; j--) { grid[minRow][j] = '#'; } } // Left column (top to bottom) if (minCol < maxCol)  { grid[i][minCol] = '#'; } } minRow += 2; maxRow -= 2; minCol += 2; maxCol -=  i < n; i++) { for (int j = 0; j < n; j++) { printf(\"%c\", grid[i][j]); } printf(\"\\n\"); } if (dataset < d - 1) { printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0141: Spiral Pattern // 2017.8.4  buf[100]; char a[105][105]; #define U 1 #define R 2 #define D 3 #define L 4 int main() { int r, c, n, d, stop; int ci, cn; gets(buf); cn = atoi(buf); for  = atoi(buf); memset(a, ' ', sizeof(a)); for (r = 0; r < n + 4; r += n + 3) { for (c = 0; c < n + 4; c++) a[r][c] = '#'; } for (c = 0; c < n + 4; c += n + 3) { for (r = 0; r < n + 4; r++) a[r][c] = '#'; } r = n + 1, c = 2, d = U, stop = 0, a[r][c] = '#'; while (1) { if (stop >= 4) break; if (d == U) { if (a[r-2][c] == '#' || a[r-1][c] == '#' || a[r-1][c+1] == '#') d = R, stop++; else a[--r][c] = '#', stop = 0; } if (d  '#' || a[r+1][c+1] == '#') d = D, stop++; else a[r][++c]   || a[r-1][c-1] == '#') d = U, stop++; else a[r][--c] = '#', stop = 0; } } if (ci > 0) putchar('\\n'); for (r = 2; r < n + 2; r++) { a[r][n + 2] = 0; puts(a[r]+2); } } return 0; }"], "original_ll": -0.8177950382232666, "sampled_ll": -0.37082165479660034, "all_perturbed_sampled_ll": [-1.2014474868774414], "all_perturbed_original_ll": [-1.3771271705627441], "perturbed_sampled_ll": -1.2014474868774414, "perturbed_original_ll": -1.3771271705627441, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint D = sc.nextInt();\n\t\tboolean first = true;\n\t\twhile (D-- > 0) {\n\t\t\tif (!first) {\n\t\t\t\tSystem.out.println();\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tchar[][] field = new char[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(field[i], ' ');\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfield[i][0] = '#';\n\t\t\t\tfield[0][i] = '#';\n\t\t\t}\n\t\t\tif (n < 3) {\n\t\t\t\tdebug2(field);\n\t\t\t} else if (n == 3) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfield[i][n - 1] = '#';\n\t\t\t\t}\n\t\t\t\tdebug2(field);\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfield[i][n - 1] = '#';\n\t\t\t\t}\n\t\t\t\tint nowX = n - 1;\n\t\t\t\tint nowY = n - 1;\n\t\t\t\tboolean go = true;\n\t\t\t\twhile (go) {\n\t\t\t\t\tgo = false;\n\t\t\t\t\twhile (nowX - 2 >= 0 && field[nowY - 1][nowX - 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY][nowX - 2] != '#' && field[nowY][nowX-1] != '#') {\n\t\t\t\t\t\tfield[nowY][--nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t\twhile (nowY - 2 >= 0 && field[nowY - 1][nowX + 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY - 2][nowX] != '#' && field[nowY-1][nowX] != '#') {\n\t\t\t\t\t\tfield[--nowY][nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t\twhile (nowX + 2 < n && field[nowY + 1][nowX + 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY][nowX + 2] != '#' ) {\n\t\t\t\t\t\tfield[nowY][++nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t\twhile (nowY + 2 < n && field[nowY + 1][nowX - 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY + 2][nowX] != '#' ) {\n\t\t\t\t\t\tfield[++nowY][nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdebug2(field);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int d = sc.nextInt();\n        \n        for (int dataset = 0; dataset < d; dataset++) {\n            int n = sc.nextInt();\n            char[][] grid = new char[n][n];\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = ' ';\n                }\n            }\n            \n            int row = n - 1;\n            int col = 0;\n            int dir = 0; // 0: right, 1: up, 2: left, 3: down\n            int[] dr = {0, -1, 0, 1};\n            int[] dc = {1, 0, -1, 0};\n            \n            int steps = n;\n            int currentSteps = 0;\n            int dirChanges = 0;\n            boolean placed = false;\n            \n            while (steps > 0) {\n                for (int i = 0; i < steps; i++) {\n                    if (row >= 0 && row < n && col >= 0 && col < n) {\n                        grid[row][col] = '#';\n                    }\n                    if (i < steps - 1) {\n                        row += dr[dir];\n                        col += dc[dir];\n                    }\n                }\n                \n                row += dr[dir];\n                col += dc[dir];\n                \n                dir = (dir + 1) % 4;\n                dirChanges++;\n                \n                if (dirChanges % 2 == 0) {\n                    steps--;\n                }\n            }\n            \n            for (int i = 0; i < n; i++) {\n                System.out.println(new String(grid[i]));\n            }\n            \n            if (dataset < d - 1) {\n                System.out.println();\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int d = sc.nextInt(); for (int dataset = 0; dataset <  new char[n][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { grid[i][j] = ' '; } } int row = n - 1; int col  up, 2:  int[] dc = {1, 0, -1, 0}; int steps = n; int currentSteps = 0; int dirChanges  i++)  col >= 0 && col < n) { grid[row][col] = '#'; } if (i < steps - 1) { row += dr[dir]; col += dc[dir]; } } row += dr[dir]; col += dc[dir]; dir = (dir + 1) % 4; dirChanges++; if (dirChanges % 2 == 0) { steps--; } } for (int i = 0; i < n; i++) { System.out.println(new String(grid[i])); } if (dataset < d - 1) { System.out.println(); } } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main  Scanner(System.in); int mod = 1000000007; int[] dx = { 1, 0, 0, -1 }; int[] dy = { 0, 1, -1, 0 }; void run() { int D = sc.nextInt(); boolean first = true; while (D-- > 0) { if (!first) { System.out.println(); first = false; } int n = sc.nextInt();  i < n; i++) { Arrays.fill(field[i], ' '); } for (int i = 0; i < n; i++) { field[i][0] = '#'; field[0][i] = '#';  (n == 3) {  field[i][n - 1] = '#'; } debug2(field); } else { for (int i = 0; i < n; i++) { field[i][n - 1] = '#'; } int nowX = n - 1; int nowY = n - 1; boolean go = true; while (go) { go = false; while (nowX - 2 >= 0 && field[nowY - 1][nowX - 1] != '#' && field[nowY][nowX - 2] != '#' && field[nowY][nowX-1] != '#') {  != '#' && field[nowY - 2][nowX] != '#' && field[nowY-1][nowX] != '#') { field[--nowY][nowX] = '#'; go = true; } while (nowX + 2 < n && field[nowY + 1][nowX + 1] != '#' && field[nowY][nowX + 2] != '#' ) { field[nowY][++nowX]  < n && field[nowY + 1][nowX - 1]  field[++nowY][nowX] = '#'; go = true; } } debug2(field); } } } public static void main(String[] args) { new Main().run(); }  for (int i = 0; i < array.length; i++) { for (int j = 0; j < array[i].length; j++) { System.out.print(array[i][j]); } System.out.println(); } } class  System.in.read(); while (c != '-' && (c < '0'  '-') return -nextInt(); int res = 0; do { res *= 10; res += c - '0'; c = System.in.read(); } while ('0' <= c &&  return -1; } } double nextDouble() { return Double.parseDouble(next()); } String next() { try { StringBuilder res = new StringBuilder(\"\"); int c = System.in.read(); while (Character.isWhitespace(c)) c = System.in.read(); do { res.append((char) c);  e) { return null; } } } }"], "original_ll": -0.5349701046943665, "sampled_ll": -0.5847939848899841, "all_perturbed_sampled_ll": [-1.501637578010559], "all_perturbed_original_ll": [-1.2246943712234497], "perturbed_sampled_ll": -1.501637578010559, "perturbed_original_ll": -1.2246943712234497, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def move(self, offset):\n        self.x += offset[0]\n        self.y += offset[1]\n\n    def move_offset(self, offset, multiple=1):\n        x = self.x + offset[0] * multiple\n        y = self.y + offset[1] * multiple\n        return Vector(x, y)\n\n\nclass Pattern:\n    NOTHING = \" \"\n    EXIST = \"#\"\n    SENTINEL = \"?\"\n\n    MOVE = [\n        [[-1, -1], [-1, +0], [-1, +1]],\n        [[-1, +1], [-0, +1], [+1, +1]],\n        [[+1, +1], [+1, +0], [+1, -1]],\n        [[+1, -1], [+0, -1], [-1, -1]],\n    ]\n\n    @classmethod\n    def create_area(cls, size):\n        area = [[cls.SENTINEL] * 2 + [cls.NOTHING] * size + [cls.SENTINEL] * 2 for _ in range(size)]\n        tmp = [[cls.SENTINEL] * size + [cls.SENTINEL] * 2 * 2]\n        area = tmp * 2 + area + tmp * 2\n        return area\n\n    @classmethod\n    def even_spiral_pattern(cls, area, point):\n        move_index = 0\n        area[point.x][point.y] = cls.EXIST\n\n        while True:\n\n            left, center, right = cls.MOVE[move_index]\n            end1, end2 = point.move_offset(left), point.move_offset(right)\n            offset, offset2 = point.move_offset(center), point.move_offset(center, 2)\n\n            if area[end1.x][end1.y] == cls.EXIST or area[end2.x][end2.y] == cls.EXIST:\n                return area\n            elif area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST:\n                point.move(center)\n                area[point.x][point.y] = cls.EXIST\n            else:\n                move_index += 1\n                move_index %= 4\n\n    @classmethod\n    def odd_spiral_pattern(cls, area, point):\n        move_index = 0\n        is_end = False\n        area[point.x][point.y] = cls.EXIST\n\n        while True:\n\n            left, center, right = cls.MOVE[move_index]\n            offset, offset2 = point.move_offset(center), point.move_offset(center, 2)\n\n            if area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST:\n                point.move(center)\n                area[point.x][point.y] = cls.EXIST\n                is_end = False\n            else:\n                if is_end:\n                    return area\n                else:\n                    is_end = True\n\n                move_index += 1\n                move_index %= 4\n\n    @classmethod\n    def formater(cls, area):\n        output = [\"\".join(item[2:-2]) for item in area[2:-2]]\n        output = \"\\n\".join(output)\n        return output\n\n    @classmethod\n    def solve(cls, size):\n        area = cls.create_area(size)\n        point = Vector(size - 1 + 2, 2)\n\n        if size % 2 == 0:\n            result = cls.even_spiral_pattern(area, point)\n        else:\n            result = cls.odd_spiral_pattern(area, point)\n\n        return cls.formater(result)\n\n\nsizes = [int(input()) for _ in range(int(input()))]\nresults = [Pattern.solve(num) for num in sizes]\nprint(\"\\n\\n\".join(results))\n\n", "sampled": "def generate_spiral(n):\n    grid = [[' ' for _ in range(n)] for _ in range(n)]\n    \n    # Start from bottom-left, go clockwise\n    row, col = n - 1, 0\n    dr, dc = 0, 1  # Start moving right\n    \n    visited = set()\n    visited.add((row, col))\n    grid[row][col] = '#'\n    \n    while True:\n        # Try to move in current direction\n        next_row, next_col = row + dr, col + dc\n        \n        # Check if we can continue in current direction\n        can_continue = (0 <= next_row < n and \n                       0 <= next_col < n and \n                       (next_row, next_col) not in visited)\n        \n        if can_continue:\n            row, col = next_row, next_col\n            visited.add((row, col))\n            grid[row][col] = '#'\n        else:\n            # Try to turn clockwise\n            # Clockwise from bottom-left: right(0,1) -> up(-1,0) -> left(0,-1) -> down(1,0)\n            if (dr, dc) == (0, 1):  # right -> up\n                dr, dc = -1, 0\n            elif (dr, dc) == (-1, 0):  # up -> left\n                dr, dc = 0, -1\n            elif (dr, dc) == (0, -1):  # left -> down\n                dr, dc = 1, 0\n            elif (dr, dc) == (1, 0):  # down -> right\n                dr, dc = 0, 1\n            \n            next_row, next_col = row + dr, col + dc\n            \n            # Check if we can move after turning\n            if (0 <= next_row < n and \n                0 <= next_col < n and \n                (next_row, next_col) not in visited):\n                row, col = next_row, next_col\n                visited.add((row, col))\n                grid[row][col] = '#'\n            else:\n                # Can't move anywhere, done\n                break\n    \n    return grid\n\nd = int(input())\nresults = []\n\nfor i in range(d):\n    n = int(input())\n    grid = generate_spiral(n)\n    results.append(grid)\n\nfor i, grid in enumerate(results):\n    for row in grid:\n        print(''.join(row))\n    if i < len(results) - 1:\n        print()\n", "perturbed_sampled": ["def generate_spiral(n): grid = [[' ' for _ in range(n)] for _ in range(n)] # Start from bottom-left, go clockwise row, col = n - 1, 0 dr, dc = 0, 1 # Start moving right visited = set() visited.add((row, col)) grid[row][col] = '#' while True: # Try  dr, col + dc # Check if we can continue in current direction can_continue = (0 <= next_row < n  in visited) if can_continue: row, col = next_row, next_col visited.add((row, col)) grid[row][col] = '#' else: # Try to turn clockwise   == (-1, 0): # up -> left dr, dc = 0, -1 elif (dr, dc) == (0, -1): # left -> down dr, dc = 1, 0 elif (dr, dc) == (1, 0):  next_col = row + dr, col + dc # Check if we can move after turning if (0 <= next_row  next_col) not in  '#' else: # Can't move anywhere, done break return grid d = int(input()) results = [] for i in range(d): n = int(input()) grid = generate_spiral(n) results.append(grid) for i, grid in enumerate(results): for row in grid: print(''.join(row)) if i < len(results) - 1: print()"], "perturbed_original": ["class Vector: def __init__(self, x, y): self.x = x self.y = y def move(self, offset): self.x += offset[0] self.y  offset[0] * multiple y = self.y + offset[1] * multiple return Vector(x, y) class Pattern: NOTHING = \" \" EXIST = \"#\" SENTINEL = \"?\" MOVE = [ [[-1, -1], [-1, +0], [-1, +1]], [[-1, +1], [-0, +1], [+1, +1]], [[+1, +1], [+1, +0], [+1, -1]], [[+1,   [cls.SENTINEL] * 2 for _ in range(size)] tmp = [[cls.SENTINEL] * size + [cls.SENTINEL] * 2 * 2] area = tmp * 2 + area + tmp * 2 return area @classmethod def even_spiral_pattern(cls, area, point): move_index = 0 area[point.x][point.y] = cls.EXIST while True: left, center, right = cls.MOVE[move_index] end1, end2 = point.move_offset(left), point.move_offset(right) offset, offset2 = point.move_offset(center), point.move_offset(center, 2) if  area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST: point.move(center) area[point.x][point.y] = cls.EXIST else: move_index += 1 move_index %= 4 @classmethod def odd_spiral_pattern(cls, area,  while True: left,  area[point.x][point.y] = cls.EXIST is_end = False else: if is_end: return area else: is_end = True move_index += 1 move_index %= 4 @classmethod def formater(cls, area): output = [\"\".join(item[2:-2]) for item in area[2:-2]] output = \"\\n\".join(output) return output @classmethod def solve(cls, size): area = cls.create_area(size) point = Vector(size - 1 +  cls.even_spiral_pattern(area, point) else: result = cls.odd_spiral_pattern(area,  results = [Pattern.solve(num) for num in sizes] print(\"\\n\\n\".join(results))"], "original_ll": -0.8351041674613953, "sampled_ll": -0.6593042612075806, "all_perturbed_sampled_ll": [-1.760866641998291], "all_perturbed_original_ll": [-1.7925186157226562], "perturbed_sampled_ll": -1.760866641998291, "perturbed_original_ll": -1.7925186157226562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\nint main(){\n  int exp[10001], n, i, j, mod[10001], a[10001], c, count[6000], h, d;\n\n  for(i = 1; i < 10001; ++i) exp[i] = i * i;\n\n  while(scanf(\"%d\", &n) && n){\n    memset(count , 0, sizeof(count));\n    for(i = 1; i < n; ++i) mod[i] = exp[i] % n;\n    c = 0;\n    for(i = 1; i < n; ++i){\n      for(j = 0; j < c; ++j)\n\tif(mod[i] == a[j]) break;\n      if(j == c) a[c++] = mod[i];\n    }\n    h = (n - 1) / 2;\n    for(i = 0; i < c; ++i){\n      for(j = 0; j < c; ++j){\n\tif(a[i] != a[j]){\n\t  d = a[i] - a[j];\n\t  if(d < 0) d += n;\n\t  if(d > h) d = n - d;\n\t  count[d]++;\n\t}\n      }\n    }\n\n    for(i = 1; i <= h; ++i) printf(\"%d\\n\", count[i]);  \n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int *squares = (int*)malloc(n * sizeof(int));\n        int unique_count = 0;\n        int *unique_squares = (int*)malloc(n * sizeof(int));\n        \n        // Calculate squares mod n\n        for(int i = 1; i < n; i++) {\n            squares[i] = (i * i) % n;\n        }\n        \n        // Find unique squares\n        for(int i = 1; i < n; i++) {\n            int found = 0;\n            for(int j = 0; j < unique_count; j++) {\n                if(unique_squares[j] == squares[i]) {\n                    found = 1;\n                    break;\n                }\n            }\n            if(!found) {\n                unique_squares[unique_count++] = squares[i];\n            }\n        }\n        \n        int max_diff = (n - 1) / 2;\n        int *count = (int*)calloc(max_diff + 1, sizeof(int));\n        \n        // Calculate differences\n        for(int i = 0; i < unique_count; i++) {\n            for(int j = 0; j < unique_count; j++) {\n                if(i != j) {\n                    int a = unique_squares[i];\n                    int b = unique_squares[j];\n                    int diff = a - b;\n                    \n                    // If negative, add n\n                    if(diff < 0) {\n                        diff += n;\n                    }\n                    \n                    // If greater than (n-1)/2, subtract from n\n                    if(diff > max_diff) {\n                        diff = n - diff;\n                    }\n                    \n                    if(diff >= 1 && diff <= max_diff) {\n                        count[diff]++;\n                    }\n                }\n            }\n        }\n        \n        // Output counts\n        for(int i = 1; i <= max_diff; i++) {\n            printf(\"%d\\n\", count[i]);\n        }\n        \n        free(squares);\n        free(unique_squares);\n        free(count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  scanf(\"%d\", &n); if(n == 0) break; int *squares = (int*)malloc(n * sizeof(int)); int unique_count = 0; int *unique_squares = (int*)malloc(n * sizeof(int)); // Calculate squares mod n for(int i = 1; i < n; i++) { squares[i] = (i * i) % n; } // Find unique squares for(int i = 1; i < n; i++) { int found =  if(unique_squares[j] == squares[i]) { found = 1; break; } } if(!found) { unique_squares[unique_count++] = squares[i]; } } int  (int*)calloc(max_diff + 1, sizeof(int)); // Calculate differences for(int i = 0; i < unique_count; i++) { for(int j = 0; j < unique_count; j++) { if(i != j) { int a = unique_squares[i]; int b = unique_squares[j]; int diff = a - b; // If negative, add  If greater than (n-1)/2, subtract from n if(diff > max_diff) { diff = n - diff; } if(diff >= 1 && diff <=  printf(\"%d\\n\", count[i]); } free(squares); free(unique_squares); free(count); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(){ int exp[10001], n, i, j, mod[10001], a[10001], c, count[6000], h, d; for(i = 1; i  && n){ memset(count , 0, sizeof(count)); for(i = 1; i < n; ++i) mod[i] = exp[i] % n; c = 0; for(i = 1; i < n; ++i){ for(j = 0; j < c; ++j) if(mod[i] == a[j]) break; if(j == c) a[c++] = mod[i]; } h  < c;  a[j]){ d = a[i] - a[j]; if(d < 0) d += n; if(d > h) d = n  <= h; ++i) printf(\"%d\\n\", count[i]); } return 0; }"], "original_ll": -0.9079139232635498, "sampled_ll": -0.5551327466964722, "all_perturbed_sampled_ll": [-1.394407033920288], "all_perturbed_original_ll": [-1.710191249847412], "perturbed_sampled_ll": -1.394407033920288, "perturbed_original_ll": -1.710191249847412, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t\tSystem.out.flush();\n\t}\n\n\tvoid solve(){\n\t\tTreeSet<Integer> set=new TreeSet<Integer>();\n\t\tfor(int i=1; i<n; i++){\n\t\t\tset.add(i*i%n);\n\t\t}\n\t\tint[] c=new int[n];\n\t\tfor(int j : set){\n\t\t\tfor(int i : set){\n\t\t\t\tif(i!=j){\n\t\t\t\t\tint a=i-j;\n\t\t\t\t\tif(a<0){\n\t\t\t\t\t\ta+=n;\n\t\t\t\t\t}\n\t\t\t\t\tif(a>(n-1)/2){\n\t\t\t\t\t\ta=n-a;\n\t\t\t\t\t}\n\t\t\t\t\tc[a]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// debug(set.toArray());\n\t\t// debug(c);\n\t\tfor(int i=1; i<=(n-1)/2; i++){\n\t\t\tprintln(\"\"+c[i]);\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tSystem.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            // Step 1: Calculate squares mod n\n            Set<Integer> squares = new HashSet<>();\n            for (int i = 1; i < n; i++) {\n                int sq = (i * i) % n;\n                squares.add(sq);\n            }\n            \n            // Step 2: Calculate differences between all pairs\n            List<Integer> squareList = new ArrayList<>(squares);\n            int maxDiff = (n - 1) / 2;\n            int[] frequency = new int[maxDiff + 1];\n            \n            for (int i = 0; i < squareList.size(); i++) {\n                for (int j = i + 1; j < squareList.size(); j++) {\n                    int a = squareList.get(i);\n                    int b = squareList.get(j);\n                    \n                    // Calculate difference\n                    int diff = a - b;\n                    \n                    // If negative, add n\n                    if (diff < 0) {\n                        diff += n;\n                    }\n                    \n                    // If greater than (n-1)/2, subtract from n\n                    if (diff > maxDiff) {\n                        diff = n - diff;\n                    }\n                    \n                    frequency[diff]++;\n                }\n            }\n            \n            // Step 3: Output frequencies for 1 to (n-1)/2\n            for (int i = 1; i <= maxDiff; i++) {\n                System.out.println(frequency[i]);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; // Step 1: Calculate squares mod n Set<Integer> squares = new HashSet<>(); for (int  = (i * i) % n; squares.add(sq); } // Step 2: Calculate differences between all pairs List<Integer> squareList = new ArrayList<>(squares); int maxDiff =  + 1]; for (int i = 0; i < squareList.size(); i++) { for  { int a =  = a  0) { diff += n; } // If greater than (n-1)/2, subtract from n if (diff > maxDiff) { diff = n - diff; } frequency[diff]++; } } // Step 3: Output frequencies for 1 to (n-1)/2 for (int i = 1; i <= maxDiff; i++) { System.out.println(frequency[i]); } } sc.close(); } }"], "perturbed_original": ["import  import static java.util.Arrays.*; public class Main{ Scanner sc=new Scanner(System.in); int INF=1<<28; double EPS=1e-9; int n; void run(){ for(;;){ n=sc.nextInt(); if(n==0){ break; } solve(); } System.out.flush(); } void solve(){ TreeSet<Integer> set=new TreeSet<Integer>();  j : set){ for(int i :  c[a]++; } } } // debug(set.toArray()); // debug(c); for(int i=1; i<=(n-1)/2; i++){ println(\"\"+c[i]); } } void debug(Object... os){ System.err.println(Arrays.deepToString(os)); } void print(String s){ System.out.print(s); } void println(String s){ System.out.println(s); } public static void main(String[] args){ System.setOut(new PrintStream(new BufferedOutputStream(System.out))); new Main().run(); } }"], "original_ll": -1.0591042041778564, "sampled_ll": -0.6555579900741577, "all_perturbed_sampled_ll": [-1.7054098844528198], "all_perturbed_original_ll": [-1.9266366958618164], "perturbed_sampled_ll": -1.7054098844528198, "perturbed_original_ll": -1.9266366958618164, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import itertools\n\nr = 10001\ns = int(r**0.5)\np = [1]*r\np[0] = 0\nfor i in range(1,s):\n\tif p[i]:\n\t\tp[2*i + 1::i + 1] = [0 for x in range(2*i + 1, r, i + 1)]\n\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\tm = (n - 1) / 2\n\ta = sorted(list(set([i**2%n for i in range(1,n)])))\n\tl = len(a)\n\tif n%4 == 3 and p[n - 1] == 1:\n\t\tll = l*(l - 1) / m\n\t\tfor i in range(m):\n\t\t\tprint ll\n\t\tcontinue\n\th = [0]*(m+1)\n\tfor i,j in itertools.combinations(a,2):\n\t\td = j - i\n\t\th[min(d,n - d)] += 2\n\tfor i in range(1,m+1):\n\t\tprint h[i]", "sampled": "def solve(n):\n    # Calculate squares mod n\n    squares = set()\n    for i in range(1, n):\n        squares.add((i * i) % n)\n    \n    squares = list(squares)\n    \n    # Calculate differences\n    max_diff = (n - 1) // 2\n    diff_count = [0] * (max_diff + 1)\n    \n    for i in range(len(squares)):\n        for j in range(i + 1, len(squares)):\n            a = squares[i]\n            b = squares[j]\n            \n            # Calculate difference\n            diff = a - b\n            if diff < 0:\n                diff += n\n            if diff > max_diff:\n                diff = n - diff\n            \n            diff_count[diff] += 1\n    \n    # Output frequencies for 1 to max_diff\n    for i in range(1, max_diff + 1):\n        print(diff_count[i])\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    solve(n)\n", "perturbed_sampled": ["def solve(n): # Calculate squares mod n squares = set() for i in range(1, n): squares.add((i * i) %  - 1) // 2 diff_count = [0] * (max_diff + 1) for i in range(len(squares)): for j in range(i + 1, len(squares)): a = squares[i]  b if diff < 0: diff += n if diff > max_diff: diff = n - diff diff_count[diff] += 1 # Output frequencies for 1 to max_diff for i in range(1, max_diff + 1):  break solve(n)"], "perturbed_original": ["import itertools r = 10001 s = int(r**0.5) p = [1]*r p[0] = 0 for i in range(1,s): if p[i]: p[2*i + 1::i + 1] = [0 for x in range(2*i + 1, r, i + 1)] while 1: n = input() if  2 a = sorted(list(set([i**2%n for i in  - 1] == 1: ll = l*(l - 1) / m for i in range(m): print ll continue h = [0]*(m+1) for i,j in itertools.combinations(a,2): d = j - i  h[i]"], "original_ll": -1.4017674922943115, "sampled_ll": -0.7774476408958435, "all_perturbed_sampled_ll": [-2.091547966003418], "all_perturbed_original_ll": [-2.2330825328826904], "perturbed_sampled_ll": -2.091547966003418, "perturbed_original_ll": -2.2330825328826904, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-2 0143   Altair and Vega\n// 2017.8.8\n\n#include <stdio.h>\n\nint atSameSide(int x1, int y1, int x2, int y2, int xa, int ya, int xb, int yb)\n{\n\tint sa, sb;\n\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n//\tif (sb == 0) return 0;  \t\t // xb,yb in line\n\treturn (sa * sb >= 0);           // xa,ya xb,yb at same side\n}\n\nint main()\n{\n\tint n;\n\tint x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\tint kin, sin;\n\n\tscanf(\"%d\", &n);\n\twhile (n-- > 0) {\n\t\tscanf(\"%d%d%d%d%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3, &xk, &yk, &xs, &ys);\n\t\tkin = atSameSide(x1, y1, x2, y2, x3, y3, xk, yk) &&\n\t\t\t  atSameSide(x2, y2, x3, y3, x1, y1, xk, yk) &&\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xk, yk);\n\t\tsin = atSameSide(x1, y1, x2, y2, x3, y3, xs, ys) &&\n\t\t  \t  atSameSide(x2, y2, x3, y3, x1, y1, xs, ys) &&\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xs, ys);\n\t\tputs(kin ^ sin ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint sign(double x) {\n    if (x > 0) return 1;\n    if (x < 0) return -1;\n    return 0;\n}\n\ndouble cross_product(double x1, double y1, double x2, double y2, double x3, double y3) {\n    return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n}\n\nint point_in_triangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {\n    double d1 = cross_product(x1, y1, x2, y2, px, py);\n    double d2 = cross_product(x2, y2, x3, y3, px, py);\n    double d3 = cross_product(x3, y3, x1, y1, px, py);\n    \n    int s1 = sign(d1);\n    int s2 = sign(d2);\n    int s3 = sign(d3);\n    \n    int has_neg = (s1 < 0) || (s2 < 0) || (s3 < 0);\n    int has_pos = (s1 > 0) || (s2 > 0) || (s3 > 0);\n    \n    return !(has_neg && has_pos);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        double xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\",\n              &xp1, &yp1, &xp2, &yp2, &xp3, &yp3, &xk, &yk, &xs, &ys);\n        \n        int k_inside = point_in_triangle(xk, yk, xp1, yp1, xp2, yp2, xp3, yp3);\n        int s_inside = point_in_triangle(xs, ys, xp1, yp1, xp2, yp2, xp3, yp3);\n        \n        if (k_inside != s_inside) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int sign(double x) { if (x  return 0; } double cross_product(double x1, double y1, double x2, double y2, double x3, double y3) { return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1); } int point_in_triangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) { double d1 =  y2, x3, y3, px, py); double d3 = cross_product(x3, y3, x1, y1, px, py); int s1 = sign(d1); int s2 = sign(d2); int s3 = sign(d3); int has_neg =  0); int has_pos = (s1 > 0) ||  has_pos); } int main() { int n; scanf(\"%d\", &n); for (int i = 0; i < n; i++) { double xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys; scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\", &xp1, &yp1, &xp2, &yp2, &xp3, &yp3, &xk, &yk, &xs,  xp3, yp3); int s_inside = point_in_triangle(xs, ys, xp1, yp1, xp2, yp2,  { printf(\"NG\\n\"); } } return 0; }"], "perturbed_original": ["// Aizu Vol-2 0143 Altair and Vega // 2017.8.8 #include <stdio.h> int atSameSide(int x1, int y1, int x2, int y2, int xa, int ya, int xb, int yb) { int sa, sb; sa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa); sb =  y1) * (x1 - xb); // if (sb == 0) return 0; // xb,yb in line return (sa * sb >= 0); // xa,ya xb,yb at same side } int main() { int n; int x1, y1, x2, y2, x3, y3,  (n-- > 0) { scanf(\"%d%d%d%d%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3, &xk, &yk, &xs, &ys); kin = atSameSide(x1, y1, x2, y2, x3, y3, xk, yk) &&  y3, x1,  y2, x3, y3, xs, ys) && atSameSide(x2, y2, x3, y3, x1, y1, xs, ys) && atSameSide(x3, y3, x1, y1, x2, y2, xs,  0; }"], "original_ll": -0.943423330783844, "sampled_ll": -0.40711045265197754, "all_perturbed_sampled_ll": [-1.1456269025802612], "all_perturbed_original_ll": [-1.5104069709777832], "perturbed_sampled_ll": -1.1456269025802612, "perturbed_original_ll": -1.5104069709777832, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tint n = in.nextInt();\n\t\tfor(int i=0;i<n;i++)new AOJ0143().doIt();\n\t\t\n\t}\n\tclass AOJ0143{\n\t\tvoid doIt(){\n\t\t\tPoint2D ps[] = new Point2D[3];\n\t\t\tfor(int i=0;i<3;i++)ps[i] = new Point2D.Double(in.nextInt(),in.nextInt());;\n\t\t\tPoint2D a = new Point2D.Double(in.nextInt(),in.nextInt());\n\t\t\tPoint2D b = new Point2D.Double(in.nextInt(),in.nextInt());\n\t\t\tint c = contains(ps, a);\n\t\t\tint d = contains(ps, b);\n//\t\t\tSystem.out.println(c+\" \"+d);\n\t\t\tif(c==d)System.out.println(\"NG\");\n\t\t\telse System.out.println(\"OK\");\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tdouble cross(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getY()-p1.getY()*p2.getX();\n\t\t}\n\t\tdouble dot(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getX()+p1.getY()*p2.getY();\n\t\t}\n\t\tprivate int contains(Point2D[] plist,Point2D p) {\n\t\t\tboolean isin = false;\n\t\t\tint n = plist.length;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint2D a = sub(plist[i], p);\n\t\t\t\tPoint2D b = sub(plist[(i+1) % n], p);\n\t\t\t\tif(a.getY() > b.getY()){\n\t\t\t\t\tPoint2D temp = (Point2D) a.clone();\n\t\t\t\t\ta = b;\n\t\t\t\t\tb = temp;\n\t\t\t\t}\n\t\t\t\tif(a.getY() <= 0 && 0 < b.getY()){\n\t\t\t\t\tif(cross(a,b) < 0) isin = ! isin;\n\t\t\t\t}\n\t\t\t\tif(cross(a,b) == 0 && dot(a, b) <= 0) return 0;\n\t\t\t}\n\t\t\treturn isin ? 1 : -1;\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double xp1 = sc.nextDouble();\n            double yp1 = sc.nextDouble();\n            double xp2 = sc.nextDouble();\n            double yp2 = sc.nextDouble();\n            double xp3 = sc.nextDouble();\n            double yp3 = sc.nextDouble();\n            double xk = sc.nextDouble();\n            double yk = sc.nextDouble();\n            double xs = sc.nextDouble();\n            double ys = sc.nextDouble();\n            \n            boolean kInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xk, yk);\n            boolean sInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xs, ys);\n            \n            if (kInside != sInside) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NG\");\n            }\n        }\n        sc.close();\n    }\n    \n    static boolean isInside(double x1, double y1, double x2, double y2, double x3, double y3, double px, double py) {\n        double sign1 = sign(px, py, x1, y1, x2, y2);\n        double sign2 = sign(px, py, x2, y2, x3, y3);\n        double sign3 = sign(px, py, x3, y3, x1, y1);\n        \n        boolean hasNeg = (sign1 < 0) || (sign2 < 0) || (sign3 < 0);\n        boolean hasPos = (sign1 > 0) || (sign2 > 0) || (sign3 > 0);\n        \n        return !(hasNeg && hasPos);\n    }\n    \n    static double sign(double px, double py, double x1, double y1, double x2, double y2) {\n        return (px - x2) * (y1 - y2) - (x1 - x2) * (py - y2);\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i < n; i++) { double xp1 = sc.nextDouble(); double yp1 = sc.nextDouble(); double xp2 = sc.nextDouble(); double yp2 = sc.nextDouble(); double xp3 = sc.nextDouble(); double yp3 = sc.nextDouble(); double xk = sc.nextDouble(); double yk = sc.nextDouble(); double xs = sc.nextDouble(); double ys = sc.nextDouble(); boolean kInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xk, yk); boolean sInside =  !=  } static boolean isInside(double x1, double y1, double x2, double  double sign2 = sign(px, py, x2, y2, x3, y3); double sign3 = sign(px, py, x3, y3, x1, y1); boolean hasNeg = (sign1  boolean hasPos  > 0); return !(hasNeg && hasPos); } static double sign(double px, double py, double x1, double y1, double x2, double y2) { return (px - x2) * (y1 - y2) - (x1 - x2) * (py - y2); } }"], "perturbed_original": ["import java.awt.geom.Point2D; import java.util.Scanner; public class Main { Scanner in = new Scanner(System.in); public static void  n = in.nextInt(); for(int i=0;i<n;i++)new AOJ0143().doIt(); } class AOJ0143{ void doIt(){ Point2D ps[] = new Point2D[3]; for(int i=0;i<3;i++)ps[i] = new Point2D.Double(in.nextInt(),in.nextInt());; Point2D a = new Point2D.Double(in.nextInt(),in.nextInt());   System.out.println(\"OK\"); } Point2D sub(Point2D p1,Point2D p2){ return new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY()); } double cross(Point2D p1,Point2D p2){ return p1.getX()*p2.getY()-p1.getY()*p2.getX(); } double dot(Point2D p1,Point2D p2){ return p1.getX()*p2.getX()+p1.getY()*p2.getY(); } private int contains(Point2D[] plist,Point2D p) { boolean isin = false; int n = plist.length; for(int  % n], p); if(a.getY() > b.getY()){ Point2D temp = (Point2D) a.clone(); a = b; b = temp; } if(a.getY() <= 0 && 0 < b.getY()){ if(cross(a,b) <  dot(a, b) <= 0) return 0; } return isin ? 1 : -1; } } }"], "original_ll": -0.855695366859436, "sampled_ll": -0.41313210129737854, "all_perturbed_sampled_ll": [-1.0007551908493042], "all_perturbed_original_ll": [-1.3296868801116943], "perturbed_sampled_ll": -1.0007551908493042, "perturbed_original_ll": -1.3296868801116943, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    @staticmethod\n    def cross_product(point1, point2):\n        return point1.x * point2.y - point1.y * point2.x\n\n\nclass Triangle:\n    def __init__(self, x1, y1, x2, y2, x3, y3):\n        self.point1 = Vector(x1, y1)\n        self.point2 = Vector(x2, y2)\n        self.point3 = Vector(x3, y3)\n\n    def is_contain(self, point):\n        line1 = point - self.point1\n        line2 = self.point2 - self.point1\n        direct1 = Vector.cross_product(line1, line2)\n\n        line1 = point - self.point2\n        line2 = self.point3 - self.point2\n        direct2 = Vector.cross_product(line1, line2)\n\n        line1 = point - self.point3\n        line2 = self.point1 - self.point3\n        direct3 = Vector.cross_product(line1, line2)\n\n        if 0 < direct1 and 0 < direct2 and 0 < direct3:\n            return 1\n        elif direct1 < 0 and direct2 < 0 and direct3 < 0:\n            return 1\n        else:\n            return -1\n\n\nfor _ in range(int(input())):\n    data = [int(item) for item in input().split(\" \")]\n\n    triangle = Triangle(data[0], data[1], data[2], data[3], data[4], data[5])\n    altair_point = Vector(data[6], data[7])\n    vega_point = Vector(data[8], data[9])\n\n    is_contain1 = triangle.is_contain(altair_point)\n    is_contain2 = triangle.is_contain(vega_point)\n    result = is_contain1 * is_contain2\n\n    if result == -1:\n        print(\"OK\")\n    else:\n        print(\"NG\")\n\n", "sampled": "def sign(p1, p2, p3):\n    return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n\ndef point_in_triangle(pt, v1, v2, v3):\n    d1 = sign(pt, v1, v2)\n    d2 = sign(pt, v2, v3)\n    d3 = sign(pt, v3, v1)\n    \n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    \n    return not (has_neg and has_pos)\n\nn = int(input())\nfor _ in range(n):\n    coords = list(map(int, input().split()))\n    p1 = (coords[0], coords[1])\n    p2 = (coords[2], coords[3])\n    p3 = (coords[4], coords[5])\n    k = (coords[6], coords[7])\n    s = (coords[8], coords[9])\n    \n    k_inside = point_in_triangle(k, p1, p2, p3)\n    s_inside = point_in_triangle(s, p1, p2, p3)\n    \n    if (k_inside and not s_inside) or (not k_inside and s_inside):\n        print(\"OK\")\n    else:\n        print(\"NG\")\n", "perturbed_sampled": ["def sign(p1,  - (p2[0] - p3[0]) * (p1[1] - p3[1]) def point_in_triangle(pt, v1, v2,  v3) d3 = sign(pt, v3, v1) has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0) has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0) return not (has_neg and has_pos) n = int(input()) for _ in range(n): coords = list(map(int, input().split())) p1 = (coords[0], coords[1]) p2 = (coords[2],  = (coords[8], coords[9]) k_inside = point_in_triangle(k, p1, p2, p3) s_inside = point_in_triangle(s, p1, p2, p3) if (k_inside and not s_inside) or (not k_inside and s_inside): print(\"OK\") else: print(\"NG\")"], "perturbed_original": ["class Vector: def __init__(self, x, y): self.x = x self.y = y def __sub__(self, other):  point2): return point1.x * point2.y - point1.y *  y3): self.point1 = Vector(x1, y1) self.point2 = Vector(x2, y2) self.point3 = Vector(x3, y3) def is_contain(self, point): line1 = point - self.point1 line2 = self.point2 - self.point1 direct1 = Vector.cross_product(line1, line2) line1 = point - self.point2 line2 = self.point3 - self.point2 direct2 = Vector.cross_product(line1, line2) line1 = point - self.point3 line2 = self.point1 - self.point3 direct3 = Vector.cross_product(line1, line2) if 0 < direct1 and  < 0: return 1 else: return -1 for _ in range(int(input())): data = [int(item) for  data[4], data[5]) altair_point = Vector(data[6], data[7]) vega_point = Vector(data[8], data[9]) is_contain1 = triangle.is_contain(altair_point) is_contain2 = triangle.is_contain(vega_point) result = is_contain1 * is_contain2 if result == -1: print(\"OK\") else: print(\"NG\")"], "original_ll": -0.5611461400985718, "sampled_ll": -0.47811925411224365, "all_perturbed_sampled_ll": [-1.2605997323989868], "all_perturbed_original_ll": [-1.4030241966247559], "perturbed_sampled_ll": -1.2605997323989868, "perturbed_original_ll": -1.4030241966247559, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint r[100][100];\nint n;\n\nint dijkstra(int start, int goal) {\n  int i;\n  int minimum, p;\n  int d[100], f[100];\n\n  for(i = 0; i < 100; i++) {\n    d[i] = 100000;\n    f[i] = 0;\n  }\n  d[start-1] = 1;\n  while(1) {\n    minimum = 100000;\n    for(i = 0; i < n; i++) {\n      if(d[i] < minimum && f[i] == 0) {\n\tminimum = d[i];\n\tp = i;\n      }\n    }\n    if(minimum == 100000) break;\n    f[p] = 1;\n\n    for(i = 0; i < n; i++) {\n      if(d[p] + r[p][i] < d[i]) {\n\td[i] = d[p] + r[p][i];\n      }\n    }\n  }\n\n  return d[goal-1];\n}\n\nint main() {\n  int i, j, r1, k1, p, s1, d1, v1, temp;\n\n  for(i = 0; i < 100; i++)\n    for(j = 0; j < 100; j++)\n      r[i][j] = 100000;\n\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; i++) {\n    scanf(\"%d %d\", &r1, &k1);\n    for(j = 0; j < k1; j++) {\n      scanf(\"%d\", &temp);\n      r[r1-1][temp-1] = 1;\n    }\n  }\n  scanf(\"%d\", &p);\n  for(i = 0; i < p; i++) {\n    scanf(\"%d %d %d\", &s1, &d1, &v1);\n    temp = dijkstra(s1, d1);\n    if(v1 - temp < 0) {\n      printf(\"NA\\n\");\n    } else {\n      printf(\"%d\\n\", temp);\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 101\n#define INF INT_MAX\n\nint adj[MAX_N][MAX_N];\nint adjCount[MAX_N];\nint dist[MAX_N];\nint visited[MAX_N];\n\nint bfs(int start, int end, int n) {\n    int queue[MAX_N * MAX_N];\n    int front = 0, rear = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    \n    queue[rear++] = start;\n    dist[start] = 1;\n    visited[start] = 1;\n    \n    while (front < rear) {\n        int u = queue[front++];\n        \n        if (u == end) {\n            return dist[end];\n        }\n        \n        for (int i = 0; i < adjCount[u]; i++) {\n            int v = adj[u][i];\n            if (!visited[v]) {\n                visited[v] = 1;\n                dist[v] = dist[u] + 1;\n                queue[rear++] = v;\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i <= n; i++) {\n        adjCount[i] = 0;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        int r, k;\n        scanf(\"%d %d\", &r, &k);\n        adjCount[r] = k;\n        for (int j = 0; j < k; j++) {\n            scanf(\"%d\", &adj[r][j]);\n        }\n    }\n    \n    int p;\n    scanf(\"%d\", &p);\n    \n    for (int i = 0; i < p; i++) {\n        int s, d, v;\n        scanf(\"%d %d %d\", &s, &d, &v);\n        \n        int minDist = bfs(s, d, n);\n        \n        if (minDist == -1) {\n            printf(\"NA\\n\");\n        } else {\n            int hops = minDist - 1;\n            if (v >= hops) {\n                printf(\"%d\\n\", minDist);\n            } else {\n                printf(\"NA\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h> #define MAX_N 101 #define INF INT_MAX int adj[MAX_N][MAX_N]; int adjCount[MAX_N]; int dist[MAX_N]; int visited[MAX_N]; int bfs(int start, int end, int n) {  0; for (int i = 1; i <= n; i++) { dist[i] = INF; visited[i] = 0; } queue[rear++] = start; dist[start] = 1; visited[start] = 1; while (front < rear) { int u = queue[front++];  i = 0; i < adjCount[u]; i++) { int v = adj[u][i]; if (!visited[v]) { visited[v] = 1; dist[v] =  for (int i = 1; i <= n; i++) { adjCount[i] = 0;  { int r, k; scanf(\"%d %d\", &r, &k); adjCount[r] = k; for (int j = 0; j < k; j++) { scanf(\"%d\", &adj[r][j]); } } int p; scanf(\"%d\", &p); for (int i = 0; i < p; i++) { int s, d, v; scanf(\"%d %d %d\", &s, &d, &v); int minDist = bfs(s, d, n); if (minDist == -1) { printf(\"NA\\n\"); } else { int hops  minDist); } else { printf(\"NA\\n\"); } } } return 0; }"], "perturbed_original": ["#include <stdio.h> int r[100][100]; int n; int dijkstra(int start, int goal) { int i; int minimum, p; int d[100], f[100]; for(i = 0; i < 100; i++) { d[i] = 100000; f[i] = 0; } d[start-1] = 1; while(1) { minimum = 100000; for(i = 0; i < n; i++) { if(d[i] < minimum && f[i] == 0) { minimum =  f[p] = 1; for(i = 0; i < n; i++) { if(d[p] + r[p][i] < d[i]) { d[i] = d[p]  { int i, j, r1, k1, p, s1, d1, v1, temp; for(i = 0; i < 100; i++) for(j = 0; j < 100; j++) r[i][j] = 100000; scanf(\"%d\", &n); for(i = 0; i < n; i++) { scanf(\"%d %d\", &r1, &k1); for(j = 0; j < k1;  &p); for(i = 0; i < p; i++)  else { printf(\"%d\\n\", temp); } } return 0; }"], "original_ll": -0.6065195202827454, "sampled_ll": -0.48266300559043884, "all_perturbed_sampled_ll": [-1.0562431812286377], "all_perturbed_original_ll": [-1.1062365770339966], "perturbed_sampled_ll": -1.0562431812286377, "perturbed_original_ll": -1.1062365770339966, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = in.readLine();\n\t\n\t\tint size = Integer.parseInt(line);\n\t\tNode[] nodes = new Node[size];\n\t\tfor(int i=0; i<size; i++){\n\t\t\tline = in.readLine();\n\t\t\tString[] tmp = line.split(\" \");\n\t\t\tint id = Integer.parseInt(tmp[0])-1;\n\t\t\tnodes[id] = new Node();\n\t\t\tint n_to = Integer.parseInt(tmp[1]);\n\t\t\tfor(int j=2; j<2+n_to; j++){\n\t\t\t\tint to = Integer.parseInt(tmp[j])-1;\n\t\t\t\tnodes[id].add_edge(to, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tline = in.readLine();\n\t\tsize = Integer.parseInt(line);\n\t\tfor(int i=0; i<size; i++){\n\t\t\tNode[] clone = deepClone(nodes);\n\t\t\tline = in.readLine();\n\t\t\tString[] tmp = line.split(\" \");\n\t\t\tint s = Integer.parseInt(tmp[0])-1;\n\t\t\tint g = Integer.parseInt(tmp[1])-1;\n\t\t\tint ttl = Integer.parseInt(tmp[2]);\n\t\t\tint total = calcCost(clone, s, g);\n\t\t\tif(ttl >= total && total != -1){\n\t\t\t\tSystem.out.println(total);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int calcCost(Node[] nodes, int s, int g){\n\t\tList<Node> que = new ArrayList<Node>();\n\t\tnodes[s].cost = 1;\n\t\tque.add(nodes[s]);\n\t\tNode done = null;\n\t\twhile(que.size()!=0){\n\t\t\tdone = que.get(0);\n\t\t\tque.remove(0);\n\t\t\tdone.visited = true;\n\t\t\tfor(int i=0; i<done.edge_to.size(); i++){\n\t\t\t\tint cost = done.cost + done.edge_cost.get(i);\n\t\t\t\tint to = done.edge_to.get(i);\n\t\t\t\tif(nodes[to].cost < 0 || cost < nodes[to].cost){\n\t\t\t\t\tnodes[to].cost = cost;\n\t\t\t\t\tif(!que.contains(nodes[to])){\n\t\t\t\t\t\tque.add(nodes[to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nodes[g].cost;\n\t}\n\t\n\tpublic Node[] deepClone(Node[] nodes){\n\t\tint m = nodes.length;\n\t\tNode[] clone = new Node[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tclone[i] = new Node(nodes[i]);\n\t\t}\n\t\treturn clone;\n\t}\n}\n\nclass Node{\n\tint cost;\n\tboolean visited;\n\tList<Integer> edge_to;\n\tList<Integer> edge_cost;\n\t\n\tpublic Node(){\n\t\tthis.cost = -1;\n\t\tthis.visited = false;\n\t\tthis.edge_cost = new ArrayList<Integer>();\n\t\tthis.edge_to = new ArrayList<Integer>();\n\t}\n\t\n\tpublic Node(Node n){\n\t\tthis.cost = n.cost;\n\t\tthis.visited = n.visited;\n\t\tthis.edge_to = new ArrayList<Integer>(n.edge_to);\n\t\tthis.edge_cost = new ArrayList<Integer>(n.edge_cost);\n\t}\n\t\n\tpublic void add_edge(int to, int cost){\n\t\tthis.edge_cost.add(cost);\n\t\tthis.edge_to.add(to);\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Router {\n        int id;\n        List<Integer> connections;\n        \n        Router(int id) {\n            this.id = id;\n            this.connections = new ArrayList<>();\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        Map<Integer, Router> routers = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            int routerId = sc.nextInt();\n            Router router = new Router(routerId);\n            int k = sc.nextInt();\n            for (int j = 0; j < k; j++) {\n                router.connections.add(sc.nextInt());\n            }\n            routers.put(routerId, router);\n        }\n        \n        int p = sc.nextInt();\n        for (int i = 0; i < p; i++) {\n            int source = sc.nextInt();\n            int dest = sc.nextInt();\n            int ttl = sc.nextInt();\n            \n            int minHops = bfs(routers, source, dest);\n            \n            if (minHops == -1 || ttl < minHops - 1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(minHops);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static int bfs(Map<Integer, Router> routers, int source, int dest) {\n        Queue<Integer> queue = new LinkedList<>();\n        Map<Integer, Integer> distance = new HashMap<>();\n        \n        queue.offer(source);\n        distance.put(source, 1);\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            int currentDist = distance.get(current);\n            \n            if (current == dest) {\n                return currentDist;\n            }\n            \n            Router router = routers.get(current);\n            if (router != null) {\n                for (int next : router.connections) {\n                    if (!distance.containsKey(next)) {\n                        distance.put(next, currentDist + 1);\n                        queue.offer(next);\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Router { int id; List<Integer> connections; Router(int id) { this.id = id; this.connections  { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); Map<Integer,  i < n; i++) { int routerId = sc.nextInt(); Router router = new Router(routerId); int k = sc.nextInt(); for (int j = 0; j < k; j++) { router.connections.add(sc.nextInt()); } routers.put(routerId, router); } int p = sc.nextInt(); for (int i = 0; i < p; i++) { int source = sc.nextInt(); int dest = sc.nextInt(); int ttl = sc.nextInt(); int minHops =  minHops - 1) { System.out.println(\"NA\");  queue = new  while (!queue.isEmpty()) { int current = queue.poll(); int currentDist = distance.get(current); if (current == dest) { return currentDist; } Router router = routers.get(current); if (router != null) { for (int next : router.connections) { if (!distance.containsKey(next)) { distance.put(next, currentDist + 1); queue.offer(next); } } } } return -1; } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static void main(String args[]){ try{ new Main(); }catch(IOException e){ e.printStackTrace(); } } public Main() throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String line = in.readLine(); int size = Integer.parseInt(line); Node[] nodes = new Node[size]; for(int  \"); int id = Integer.parseInt(tmp[0])-1; nodes[id] = new Node(); int n_to = Integer.parseInt(tmp[1]); for(int j=2; j<2+n_to; j++){ int to = Integer.parseInt(tmp[j])-1; nodes[id].add_edge(to, 1); } } line = in.readLine(); size  line = in.readLine(); String[] tmp = line.split(\" \"); int s = Integer.parseInt(tmp[0])-1; int g = Integer.parseInt(tmp[1])-1; int ttl = Integer.parseInt(tmp[2]); int  != -1){ System.out.println(total); }else{ System.out.println(\"NA\"); } } } public int calcCost(Node[] nodes, int s, int g){ List<Node> que = new  done = que.get(0); que.remove(0); done.visited = true; for(int i=0; i<done.edge_to.size();  done.edge_to.get(i); if(nodes[to].cost < 0 || cost < nodes[to].cost){ nodes[to].cost = cost; if(!que.contains(nodes[to])){  deepClone(Node[] nodes){ int m = nodes.length; Node[] clone = new Node[m]; for(int i=0; i<m; i++){ clone[i] = new Node(nodes[i]); } return clone; }  this.edge_cost = new ArrayList<Integer>(); this.edge_to = new ArrayList<Integer>(); } public Node(Node n){ this.cost = n.cost; this.visited = n.visited; this.edge_to = new ArrayList<Integer>(n.edge_to); this.edge_cost = new ArrayList<Integer>(n.edge_cost); } public void add_edge(int to, int cost){ this.edge_cost.add(cost); this.edge_to.add(to); } }"], "original_ll": -0.668572187423706, "sampled_ll": -0.4895699620246887, "all_perturbed_sampled_ll": [-1.4156501293182373], "all_perturbed_original_ll": [-1.4440168142318726], "perturbed_sampled_ll": -1.4156501293182373, "perturbed_original_ll": -1.4440168142318726, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def solve(A):\n  s,d,v = A\n  C = [-1 for _ in [0]*(n+1)]\n  c = 1\n  C[s] = c\n  SP = M[s]\n  while 1:\n    if SP==[]: return \"NA\"\n    c += 1\n    X = []\n    for p in SP:\n      if C[p]>0: continue\n      C[p] = c\n      X += [e for e in M[p] if C[e]<0 and e not in SP]\n      if p==d: return [C[d],\"NA\"][C[p]>v]\n    SP = X\n\nn = int(raw_input())\nM = {}\n\nfor _ in [0]*n:\n  x = map(int, raw_input().split())\n  M[x[0]] = x[2:]\nfor _ in [0]*int(raw_input()):\n  print solve(map(int,raw_input().split()))", "sampled": "from collections import deque, defaultdict\n\ndef bfs(graph, start, end, n):\n    if start == end:\n        return 0\n    \n    visited = [False] * (n + 1)\n    queue = deque([(start, 0)])\n    visited[start] = True\n    \n    while queue:\n        node, dist = queue.popleft()\n        \n        if node in graph:\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    if neighbor == end:\n                        return dist + 1\n                    visited[neighbor] = True\n                    queue.append((neighbor, dist + 1))\n    \n    return -1\n\nn = int(input())\ngraph = defaultdict(list)\n\nfor _ in range(n):\n    line = list(map(int, input().split()))\n    router_id = line[0]\n    k = line[1]\n    if k > 0:\n        connections = line[2:2+k]\n        graph[router_id] = connections\n\np = int(input())\n\nfor _ in range(p):\n    s, d, v = map(int, input().split())\n    \n    min_hops = bfs(graph, s, d, n)\n    \n    if min_hops == -1:\n        print(\"NA\")\n    else:\n        if v >= min_hops:\n            print(min_hops + 1)\n        else:\n            print(\"NA\")\n", "perturbed_sampled": ["from collections  == end: return 0 visited = [False] * (n + 1) queue = deque([(start, 0)]) visited[start] = True while queue: node, dist = queue.popleft()  visited[neighbor]: if neighbor == end: return dist + 1 visited[neighbor] = True queue.append((neighbor, dist + 1)) return -1 n = int(input()) graph = defaultdict(list) for _ in range(n): line = list(map(int, input().split())) router_id = line[0] k = line[1] if k > 0: connections = line[2:2+k] graph[router_id] = connections p = int(input()) for _ in range(p): s, d, v = map(int,  -1: print(\"NA\") else: if v >= min_hops: print(min_hops + 1) else: print(\"NA\")"], "perturbed_original": ["def solve(A): s,d,v = A C = [-1 for _ in [0]*(n+1)] c = 1 C[s] = c SP = M[s] while 1: if SP==[]: return \"NA\" c += 1 X = [] for p in SP: if C[p]>0: continue C[p] = c X +=  in SP] if p==d: return [C[d],\"NA\"][C[p]>v] SP = X n = int(raw_input()) M =  = x[2:] for _ in [0]*int(raw_input()): print solve(map(int,raw_input().split()))"], "original_ll": -1.7584834098815918, "sampled_ll": -0.7765875458717346, "all_perturbed_sampled_ll": [-1.7764873504638672], "all_perturbed_original_ll": [-2.8931100368499756], "perturbed_sampled_ll": -1.7764873504638672, "perturbed_original_ll": -2.8931100368499756, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  int c1[100],c2[100],i,j,k,n,s=0,a,amax=0,amaxi;\n\n  scanf(\"%d\\n\",&n);\n  for(i=0;i<n;i++) scanf(\"%d %d\\n\",&c1[i],&c2[i]);\n\n  for(i=0;i<n-1;i++){\n    for(j=0;j<n-i-1;j++){\n      a=c2[j]*c1[j+1];\n      if(a>amax || (a==amax && c1[j]*c2[j+1] < c1[amaxi]*c2[amaxi+1])){\n        amax=a;\n        amaxi=j;\n      }\n    }\n    s+=c1[amaxi]*c2[amaxi]*c1[amaxi+1]*c2[amaxi+1];\n    c2[amaxi]=c2[amaxi+1];\n    for(j=amaxi+1;j<n-i;j++){\n      c1[j]=c1[j+1];\n      c2[j]=c2[j+1];\n    }\n    amax=0;\n  }\n  printf(\"%d\\n\",s);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <limits.h>\n\nint n;\nint a[101], b[101];\nlong long dp[101][101];\n\nlong long solve(int l, int r) {\n    if (l == r) return 0;\n    if (dp[l][r] != -1) return dp[l][r];\n    \n    long long min_cost = LLONG_MAX;\n    \n    for (int k = l; k < r; k++) {\n        long long cost = solve(l, k) + solve(k + 1, r);\n        cost += (long long)a[l] * b[k] * a[k + 1] * b[r];\n        if (cost < min_cost) {\n            min_cost = cost;\n        }\n    }\n    \n    dp[l][r] = min_cost;\n    return min_cost;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d %d\", &a[i], &b[i]);\n    }\n    \n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = -1;\n        }\n    }\n    \n    printf(\"%lld\\n\", solve(1, n));\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <limits.h> int n; int a[101], b[101]; long long dp[101][101]; long long solve(int  = LLONG_MAX; for (int k = l; k < r; k++) { long long cost = solve(l, k) + solve(k + 1, r); cost += (long long)a[l] * b[k] * a[k + 1] * b[r]; if (cost < min_cost) { min_cost = cost; } } dp[l][r] = min_cost; return min_cost; } int main() { scanf(\"%d\",  { scanf(\"%d %d\", &a[i], &b[i]);  { for (int j = 0; j <= n; j++) { dp[i][j] = -1; } } printf(\"%lld\\n\", solve(1, n)); return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ int c1[100],c2[100],i,j,k,n,s=0,a,amax=0,amaxi; scanf(\"%d\\n\",&n); for(i=0;i<n;i++)  < c1[amaxi]*c2[amaxi+1])){ amax=a; amaxi=j; } } s+=c1[amaxi]*c2[amaxi]*c1[amaxi+1]*c2[amaxi+1]; c2[amaxi]=c2[amaxi+1]; for(j=amaxi+1;j<n-i;j++){ c1[j]=c1[j+1]; c2[j]=c2[j+1]; } amax=0; } printf(\"%d\\n\",s); return 0; }"], "original_ll": -0.8633320331573486, "sampled_ll": -0.4128352701663971, "all_perturbed_sampled_ll": [-1.2337915897369385], "all_perturbed_original_ll": [-1.4580270051956177], "perturbed_sampled_ll": -1.2337915897369385, "perturbed_original_ll": -1.4580270051956177, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n\tfinal int INF = Integer.MAX_VALUE / 4;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString a = sc.next();\n\t\t\n\t\tint n = Integer.parseInt(a);\n\t\tint [][] data = new int[n][2];\n\t\tint [][] memo = new int[n][n];\n\t\tfor(int i=0; i < n; i++){\n\t\t\tArrays.fill(memo[i], INF);\n\t\t\tmemo[i][i] = 0;\n\t\t}\n\t\tfor(int i=0; i < n; i++){\n\t\t\tdata[i][0] = sc.nextInt();\n\t\t\tdata[i][1] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(\"440\");\n//\t\tfor(int i = 0; i < n-1; i++){\n//\t\t\tmemo[i][i+1] = data[i][0] * data[i][1] * data[i+1][0] * data[i+1][1];\n//\t\t}\n//\n//\t\tfor(int k = 2; k < n; k++){\n//\t\t\tfor(int i =0; i + k < n; i++){\n//\t\t\t\tfor(int j = i; j < i + k; j++){\n//\t\t\t\t\tint value2 = (data[i][0] * data[i+j][1]) * (data[i+j+1][0] * data[i+k][1]);\n//\t\t\t\t\tint value = memo[i][i+j] + memo[i+j+1][i+k] +value2;\n//\t\t\t\t\tmemo[i][i+k] = Math.min(memo[i][i+k], value);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\t\t//\t\t\t//debug\n\t\t//\t\t\tSystem.out.println(\"D= \");\n\t\t//\t\t\tfor(int i=0; i < n; i++){\n\t\t//\t\t\t\tfor(int j = 0;  i+ j < n;j++){\n\t\t//\t\t\t\t\tSystem.out.print(memo[j][i+j] + \" \");\n\t\t//\t\t\t\t}\n\t\t//\t\t\t\tSystem.out.println();\n\t\t//\t\t\t}\n\n\t\tSystem.out.println(memo[0][n-1]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] cards = new int[n][2];\n        \n        for (int i = 0; i < n; i++) {\n            cards[i][0] = sc.nextInt(); // top\n            cards[i][1] = sc.nextInt(); // bottom\n        }\n        \n        // dp[i][j] = minimum cost to merge piles from i to j into one pile\n        long[][] dp = new long[n][n];\n        // result[i][j][0] = top card after merging i to j\n        // result[i][j][1] = bottom card after merging i to j\n        int[][][] result = new int[n][n][2];\n        \n        // Initialize single piles\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 0;\n            result[i][i][0] = cards[i][0];\n            result[i][i][1] = cards[i][1];\n        }\n        \n        // Fill DP table for increasing lengths\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1;\n                dp[i][j] = Long.MAX_VALUE;\n                \n                // Try all possible split points\n                for (int k = i; k < j; k++) {\n                    // Merge [i..k] and [k+1..j]\n                    // Left pile (i..k) goes on top of right pile (k+1..j)\n                    long cost = dp[i][k] + dp[k+1][j];\n                    cost += (long)result[i][k][0] * result[i][k][1] * result[k+1][j][0] * result[k+1][j][1];\n                    \n                    if (cost < dp[i][j]) {\n                        dp[i][j] = cost;\n                        result[i][j][0] = result[i][k][0]; // top from left pile\n                        result[i][j][1] = result[k+1][j][1]; // bottom from right pile\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp[0][n-1]);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] cards = new int[n][2]; for (int i // top<extra_id_6>= (long)(long)(long)result[i][i][1]+(long)(j-1)*(long)result[j+1][j][0]; // // top cards[i][1] = sc.nextInt(); // bottom } // dp[i][j] = minimum cost to merge piles from i  // result[i][j][0] = top card after merging i to j // result[i][j][1] = bottom  int[n][n][2]; // Initialize single piles for (int  0; result[i][i][0] = cards[i][0]; result[i][i][1] = cards[i][1]; } // Fill DP table for increasing lengths for (int len = 2; len <= n; len++) { for (int i = 0; i <= n - len; i++) { int j = i + len - 1; dp[i][j] = Long.MAX_VALUE; // Try all possible split points for (int k = i; k <  long cost = dp[i][k] + dp[k+1][j]; cost += (long)result[i][k][0] * result[i][k][1] * result[k+1][j][0] * result[k+1][j][1]; if  // top from left pile result[i][j][1] = result[k+1][j][1]; // bottom from right pile } } } } System.out.println(dp[0][n-1]); sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { final int INF = Integer.MAX_VALUE / 4; private void doit(){ Scanner sc = new Scanner(System.in); String a = sc.next(); int n = Integer.parseInt(a); int [][] data = new int[n][2]; int [][] memo =  i++){ data[i][0] = sc.nextInt(); data[i][1] = sc.nextInt(); } System.out.println(\"440\"); // for(int i = 0; i < n-1; i++){ // memo[i][i+1] = data[i][0] * data[i][1] * data[i+1][0] * data[i+1][1]; // } // // for(int k = 2; k < n; k++){ // for(int i =0; i + k < n; i++){ // for(int j = i; j < i + k; j++){  data[i+k][1]); // int value = memo[i][i+j]  // } // } // //debug // System.out.println(\"D= \"); // for(int i=0; i < n; i++){ // for(int j = 0; i+ j < n;j++){ //  System.out.println(memo[0][n-1]); } public static void main(String[] args) { Main obj = new Main(); obj.doit(); } }"], "original_ll": -0.8328409194946289, "sampled_ll": -0.6348987221717834, "all_perturbed_sampled_ll": [-1.7224177122116089], "all_perturbed_original_ll": [-1.4956332445144653], "perturbed_sampled_ll": -1.7224177122116089, "perturbed_original_ll": -1.4956332445144653, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = int(raw_input())\nCard = [[] for _ in [0]*n]\nCost = {}\nfor i in range(n):\n  Card[i] = map(int, raw_input().split())\n  Cost[(i, i)] = 0\nfor i in range(1, n):\n  for j in range(0, n-i):\n    a = j+i\n    Cost[(j, a)] = min([Card[j][0] * Card[k][1] * Card[k+1][0] * Card[a][1] + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\nprint Cost[0, n-1]", "sampled": "def solve():\n    n = int(input())\n    piles = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        piles.append((a, b))\n    \n    if n == 1:\n        print(0)\n        return\n    \n    # dp[i][j] = minimum cost to merge piles from i to j into one pile\n    # result[i][j] = (top, bottom) of the merged pile from i to j\n    dp = [[0] * n for _ in range(n)]\n    result = [[None] * n for _ in range(n)]\n    \n    # Initialize single piles\n    for i in range(n):\n        result[i][i] = piles[i]\n    \n    # Length of the segment\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            \n            # Try all possible split points\n            for k in range(i, j):\n                # Merge [i, k] and [k+1, j]\n                # Cost = dp[i][k] + dp[k+1][j] + cost of merging these two groups\n                \n                # Get the top and bottom of left merged pile\n                left_top, left_bottom = result[i][k] if result[i][k] else piles[i]\n                # Get the top and bottom of right merged pile\n                right_top, right_bottom = result[k+1][j] if result[k+1][j] else piles[k+1]\n                \n                # Cost of merging left pile onto right pile\n                merge_cost = left_top * left_bottom * right_top * right_bottom\n                \n                total_cost = dp[i][k] + dp[k+1][j] + merge_cost\n                \n                if total_cost < dp[i][j]:\n                    dp[i][j] = total_cost\n                    # After merging, top is from left, bottom is from right\n                    result[i][j] = (left_top, right_bottom)\n    \n    print(dp[0][n-1])\n\nsolve()\n", "perturbed_sampled": ["def solve(): n = int(input()) piles = [] for _ in range(n): a, b = map(int, input().split())  = minimum cost to merge piles from i to j into one pile # result[i][j] = (top, bottom) of the merged pile from i  range(n)] result  # Length of the segment for length in range(2, n + 1): for i in range(n  1 dp[i][j] = float('inf') # Try all possible split points for k in range(i, j): #  + dp[k+1][j] + cost of merging these two groups # Get the top and bottom of left merged pile left_top, left_bottom = result[i][k] if result[i][k] else piles[i] # Get the top and bottom of right merged pile right_top, right_bottom = result[k+1][j] if result[k+1][j] else piles[k+1] # Cost of merging left pile onto right pile merge_cost = left_top * left_bottom * right_top * right_bottom total_cost = dp[i][k] + dp[k+1][j] + merge_cost if total_cost < dp[i][j]: dp[i][j] = total_cost # After merging, top is from left, bottom is from right result[i][j] = (left_top, right_bottom) print(dp[0][n-1]) solve()"], "perturbed_original": ["n = int(raw_input()) Card = [[] for _ in [0]*n] Cost = {} for i in range(n): Card[i] = map(int, raw_input().split()) Cost[(i, i)] = 0 for i in range(1, n): for j in range(0, n-i):  Card[k+1][0] * Card[a][1] + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)]) print Cost[0, n-1]"], "original_ll": -1.246390700340271, "sampled_ll": -0.7813050150871277, "all_perturbed_sampled_ll": [-1.7096635103225708], "all_perturbed_original_ll": [-1.715582251548767], "perturbed_sampled_ll": -1.7096635103225708, "perturbed_original_ll": -1.715582251548767, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<stdlib.h>\nint a[110],b[110],c[110],n;\ndouble f(int i,int j,int k){\n  int w=0,l;\n  if(j==0)return 0;\n  for(l=0;l<n;l++){\n    if(j&(1<<l))w+=c[l]*20;\n  }\n  return abs(b[k]-b[i])*(w+70)/2000.0;\n}\ndouble d[20][1<<16]={};\nint fr[20][1<<16]={};\nint main(){\n  int i,j,k,r[110];\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)d[i][j]=1e9;\n  }//printf(\"a\\n\");\n  for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)fr[i][j]=-1;\n  }\n  for(i=0;i<n;i++)d[i][1<<i]=0;\n  for(j=0;j<(1<<n);j++){\n    for(i=0;i<n;i++){\n      if((1<<i)&j==0)continue;\n      for(k=0;k<n;k++){\n\tif(j&(1<<k))continue;\n\tif(d[k][j+(1<<k)]>d[i][j]+f(i,j,k)){\n\t  d[k][j+(1<<k)]=d[i][j]+f(i,j,k);\n\t  fr[k][j+(1<<k)]=i;\n\t}\n      }\n    }\n  }//printf(\"b\\n\");\n  /*for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)printf(\"%f \",d[i][j]);printf(\"\\n\");\n  }\n  for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)printf(\"%d \",fr[i][j]);printf(\"\\n\");\n    }//*/\n  k=j-1;\n  for(i=j=0;i<n;i++){\n    if(d[i][k]<d[j][k])j=i;\n  }//printf(\"%d %d\\n\",j,fr[j][k]);\n  r[n-1]=j;\n  for(i=1;i<n;i++){//printf(\"%d:\",j);\n    r[n-i-1]=fr[r[n-i]][k];\n    k-=(1<<r[n-i]);\n    //j=fr[r[n-i-1]][k];\n  }//printf(\"d\\n\");\n  //for(i=0;i<n;i++)printf(\"%d \",r[i]);printf(\"\\n\");\n  for(i=0;i<n-1;i++)printf(\"%d \",a[r[i]]);\n  printf(\"%d\\n\",a[r[i]]);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 15\n#define INF 1e18\n\ntypedef struct {\n    int id;\n    int dist;\n    int boxes;\n} Warehouse;\n\nWarehouse wh[MAX_N];\nint n;\ndouble dp[1 << MAX_N][MAX_N];\nint parent[1 << MAX_N][MAX_N];\nint order[MAX_N];\n\ndouble calc_time(int dist, int weight) {\n    return (double)dist / (2000.0 / (70.0 + weight));\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &wh[i].id, &wh[i].dist, &wh[i].boxes);\n    }\n    \n    int full_mask = (1 << n) - 1;\n    \n    for (int mask = 0; mask <= full_mask; mask++) {\n        for (int i = 0; i < n; i++) {\n            dp[mask][i] = INF;\n            parent[mask][i] = -1;\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        dp[1 << i][i] = 0;\n    }\n    \n    for (int mask = 0; mask <= full_mask; mask++) {\n        for (int last = 0; last < n; last++) {\n            if (!(mask & (1 << last))) continue;\n            if (dp[mask][last] >= INF) continue;\n            \n            int total_weight = 0;\n            for (int i = 0; i < n; i++) {\n                if (mask & (1 << i)) {\n                    total_weight += wh[i].boxes * 20;\n                }\n            }\n            \n            for (int next = 0; next < n; next++) {\n                if (mask & (1 << next)) continue;\n                \n                int new_mask = mask | (1 << next);\n                int dist = abs(wh[next].dist - wh[last].dist);\n                double time = calc_time(dist, total_weight);\n                double new_time = dp[mask][last] + time;\n                \n                if (new_time < dp[new_mask][next]) {\n                    dp[new_mask][next] = new_time;\n                    parent[new_mask][next] = last;\n                }\n            }\n        }\n    }\n    \n    double min_time = INF;\n    int last_pos = -1;\n    for (int i = 0; i < n; i++) {\n        if (dp[full_mask][i] < min_time) {\n            min_time = dp[full_mask][i];\n            last_pos = i;\n        }\n    }\n    \n    int mask = full_mask;\n    int pos = last_pos;\n    int idx = n - 1;\n    \n    while (pos != -1) {\n        order[idx--] = wh[pos].id;\n        int prev = parent[mask][pos];\n        if (prev == -1) break;\n        mask ^= (1 << pos);\n        pos = prev;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> #define MAX_N 15 #define INF 1e18 typedef struct { int id; int dist; int boxes; }  parent[1 << MAX_N][MAX_N]; int order[MAX_N]; double calc_time(int dist, int weight) { return (double)dist / (2000.0 / (70.0 + weight)); } int main() { scanf(\"%d\", &n); for (int i = 0; i < n; i++) { scanf(\"%d  mask <= full_mask; mask++) { for (int i = 0; i < n; i++) { dp[mask][i] = INF; parent[mask][i] = -1; } } for  << i][i] = 0; } for (int mask = 0; mask <= full_mask; mask++) { for (int last = 0; last < n; last++) { if (!(mask & (1 << last))) continue; if (dp[mask][last]  = 0; i < n; i++) { if (mask & (1 << i)) { total_weight  0; next < n; next++) { if (mask & (1 << next)) continue; int new_mask =  wh[last].dist); double time = calc_time(dist, total_weight); double new_time = dp[mask][last] + time; if (new_time < dp[new_mask][next]) { dp[new_mask][next]  min_time = INF; int last_pos = -1; for (int i = 0; i < n; i++) { if (dp[full_mask][i] < min_time) { min_time = dp[full_mask][i]; last_pos = i; } } int mask = full_mask; int pos = last_pos; int idx = n - 1; while (pos != -1) { order[idx--] = wh[pos].id; int  (1 << pos);  < n; i++) { if (i > 0) printf(\" \"); printf(\"%d\", order[i]); } printf(\"\\n\"); return 0; }"], "perturbed_original": ["#include<stdio.h> #include<stdlib.h> int a[110],b[110],c[110],n; double f(int i,int j,int k){ int w=0,l; if(j==0)return 0; for(l=0;l<n;l++){ if(j&(1<<l))w+=c[l]*20; } return abs(b[k]-b[i])*(w+70)/2000.0; } double d[20][1<<16]={}; int fr[20][1<<16]={}; int main(){ int i,j,k,r[110]; scanf(\"%d\",&n);  for(j=0;j<(1<<n);j++){ for(i=0;i<n;i++){ if((1<<i)&j==0)continue; for(k=0;k<n;k++){ if(j&(1<<k))continue; if(d[k][j+(1<<k)]>d[i][j]+f(i,j,k)){ d[k][j+(1<<k)]=d[i][j]+f(i,j,k); fr[k][j+(1<<k)]=i; } } } }//printf(\"b\\n\"); /*for(i=0;i<n;i++){ for(j=0;j<(1<<n);j++)printf(\"%f \",d[i][j]);printf(\"\\n\"); } for(i=0;i<n;i++){ for(j=0;j<(1<<n);j++)printf(\"%d \",fr[i][j]);printf(\"\\n\"); }//*/ k=j-1; for(i=j=0;i<n;i++){ if(d[i][k]<d[j][k])j=i; }//printf(\"%d  \",a[r[i]]); printf(\"%d\\n\",a[r[i]]); return 0; }"], "original_ll": -0.9309648871421814, "sampled_ll": -0.5668311715126038, "all_perturbed_sampled_ll": [-1.6706428527832031], "all_perturbed_original_ll": [-1.269037127494812], "perturbed_sampled_ll": -1.6706428527832031, "perturbed_original_ll": -1.269037127494812, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic void sort(int[][] data){\n\t\tfor(int i = 0; i < data.length; i++){\n\t\t\tint min = i;\n\t\t\tfor(int j = i+1; j < data.length; j++){\n\t\t\t\tif( data[min][2] > data[j][2] ){\n\t\t\t\t\tmin = j;\n\t\t\t\t} else if( data[min][2] == data[j][2] ){\n\t\t\t\t\tif( data[min][1] > data[j][1] ){\n\t\t\t\t\t\tmin = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\tint temp = data[min][j];\n\t\t\t\tdata[min][j] = data[i][j];\n\t\t\t\tdata[i][j] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tpublic int[] nextPermutation(int[] x, int index){\n\t\tint max = index;\n\t\tboolean[] temp = new boolean[x.length];\n\t\tfor(int i = index; i < x.length; i++){\n\t\t\ttemp[x[i]-1] = true;\n\t\t\tif( x[i] > x[max] ){\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t}\n\t\tint key = index+1;\n\t\tif( max == index ){\n\t\t\tfor(; index > 0; index--){\n\t\t\t\ttemp[x[index-1]-1] = true;\n\t\t\t\tif( x[index] > x[index-1] ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( index == 0 ){\n\t\t\t\tx[0] = -1;\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\tkey = index;\n\t\t} \n\n\t\tfor(int i = x[key-1]; i < temp.length; i++){\n\t\t\tif( temp[i] ){\n\t\t\t\tx[key-1] = i+1;\n\t\t\t\ttemp[i] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\t\t\n\t\tint count = 0;\n\t\tfor(int i = 0; i < temp.length; i++){\n\t\t\tif( temp[i] ){\n\t\t\t\tx[key+count] = i+1;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\t\t\t\n\t\treturn x;\n\t}\n\t\t\t\n\tpublic  void solve() throws IOException{\n\t\tint n = nextInt();\n\t\tlong start = System.currentTimeMillis();\n\t\tint[][] data = new int[n][3];\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdata[i][0] = nextInt();\n\t\t\tdata[i][1] = nextInt();\n\t\t\tdata[i][2] = nextInt();\t\t\t\n\t\t}\n\t\tsort(data);\t\t\n\t\tint[] x = new int[n];\n\t\tfor(int i = 0; i < x.length; i++){\n\t\t\tx[i] = i+1;\n\t\t}\n\t\tdouble min = 1000000001;\n\t\tint[] ans = new int[n];\n\t\tSystem.arraycopy(x, 0, ans, 0, n);\n\t\tint count = 0;\n\t\twhile( x[0] > 0 ){\n\t\t\tcount++;\n\t\t\tint[] total = new int[n];\n\t\t\tint high = data[x[n-1]-1][1];\n\t\t\tint low = high;\n\t\t\tfor(int i = n-2; i >= 0; i--){\n\t\t\t\tint a = data[x[i]-1][1];\t\t\n\t\t\t\thigh = Math.max(high, a);\n\t\t\t\tlow = Math.min(low, a);\n\t\t\t\ttotal[i] = high+low+Math.min(high-a, a-low);\n\t\t\t}\t\t\n\t\t\tdouble sum = 0;\n\t\t\tdouble w = 0;\n\t\t\tdouble v = (double)2000/70;\t\n\t\t\tint i = 0;\t\t\n\t\t\tfor(; i < x.length-1; i++){\n\t\t\t\tif( sum + total[i]/v > min ){\n\t//\t\t\t\twriter.println(\"cut at \" + i + \", v = \" + v + \", sum = \" + sum);\n\t\t\t\t\tsum = min;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint len = Math.abs(data[x[i]-1][1]-data[x[i+1]-1][1]);\n\t\t\t\tw += 20*data[x[i]-1][2];\n\t\t\t\tv = 2000/(70+w);\n\t\t\t\tsum += len/v;\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\tif( sum < min ){\n\t\t\t\tSystem.arraycopy(x, 0, ans, 0, n);\n\t\t\t\tmin = sum;\n\t\t\t}\n\t\t\ti = Math.min(i, n-1);\n\t\t\tx = nextPermutation(x, i);\t\t\t\n\t\t}\n\t\twriter.println(count);\n\t\twriter.println(min);\n\t\twriter.print(data[ans[0]-1][0]);\n\t\tfor(int i = 1; i < n; i++){\n\t\t\twriter.print(\" \" + data[ans[i]-1][0]);\n\t\t}\n\t\twriter.println();\t\n\t\tlong fin = System.currentTimeMillis();\n\t\twriter.println(fin-start);\t\n\t\twriter.flush();\t\t\t\n\t}\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\t\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Warehouse {\n        int id;\n        int distance;\n        int boxes;\n        \n        Warehouse(int id, int distance, int boxes) {\n            this.id = id;\n            this.distance = distance;\n            this.boxes = boxes;\n        }\n    }\n    \n    static int n;\n    static Warehouse[] warehouses;\n    static double minTime;\n    static int[] bestOrder;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        warehouses = new Warehouse[n];\n        \n        for (int i = 0; i < n; i++) {\n            int id = sc.nextInt();\n            int distance = sc.nextInt();\n            int boxes = sc.nextInt();\n            warehouses[i] = new Warehouse(id, distance, boxes);\n        }\n        \n        minTime = Double.MAX_VALUE;\n        bestOrder = new int[n];\n        \n        permute(new ArrayList<>(), new boolean[n], 0);\n        \n        for (int i = 0; i < n; i++) {\n            if (i > 0) System.out.print(\" \");\n            System.out.print(bestOrder[i]);\n        }\n        System.out.println();\n    }\n    \n    static void permute(List<Integer> current, boolean[] used, int depth) {\n        if (depth == n) {\n            double time = calculateTime(current);\n            if (time < minTime) {\n                minTime = time;\n                for (int i = 0; i < n; i++) {\n                    bestOrder[i] = warehouses[current.get(i)].id;\n                }\n            }\n            return;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                current.add(i);\n                permute(current, used, depth + 1);\n                current.remove(current.size() - 1);\n                used[i] = false;\n            }\n        }\n    }\n    \n    static double calculateTime(List<Integer> order) {\n        double totalTime = 0.0;\n        int totalWeight = 0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int currentIdx = order.get(i);\n            int nextIdx = order.get(i + 1);\n            \n            totalWeight += warehouses[currentIdx].boxes * 20;\n            \n            int distance = Math.abs(warehouses[nextIdx].distance - warehouses[currentIdx].distance);\n            double speed = 2000.0 / (70.0 + totalWeight);\n            double time = distance / speed;\n            \n            totalTime += time;\n        }\n        \n        return totalTime;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Warehouse { int id; int distance; int boxes; Warehouse(int id, int distance, int boxes) { this.id = id; this.distance = distance; this.boxes = boxes; } } static int n; static Warehouse[] warehouses; static double minTime; static int[] bestOrder; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt();   = sc.nextInt(); int boxes = sc.nextInt(); warehouses[i] = new Warehouse(id, distance, boxes); } minTime = Double.MAX_VALUE; bestOrder = new  0; i < n; i++) { if (i >  current, boolean[] used, int depth) { if (depth == n) { double time = calculateTime(current); if (time < minTime) { minTime = time;  bestOrder[i]  0; i < n; i++) { if (!used[i]) { used[i] = true; current.add(i); permute(current, used, depth + 1); current.remove(current.size() - 1); used[i] = false;  = 0.0; int totalWeight = 0; for (int i = 0; i < n - 1; i++) { int currentIdx = order.get(i); int nextIdx = order.get(i + 1); totalWeight  double speed = 2000.0 / (70.0 + totalWeight); double time = distance / speed; totalTime += time; } return totalTime; } }"], "perturbed_original": ["import  < data.length; j++){ if( data[min][2] > data[j][2] ){  if( data[min][1] > data[j][1] ){  j < 3; j++){ int temp = data[min][j]; data[min][j] = data[i][j]; data[i][j] = temp; } } } public int[]  = new boolean[x.length]; for(int i = index; i < x.length; i++){ temp[x[i]-1] = true; if( x[i] > x[max] ){ max = i; } } int key = index+1; if( max == index ){ for(; index > 0; index--){ temp[x[index-1]-1] = true; if( x[index] > x[index-1] ){ break; } } if( index == 0 ){ x[0] = -1; return x; } key = index; } for(int i  = i+1; temp[i] = false; break; } } int count = 0; for(int i = 0; i < temp.length; i++){ if( temp[i] ){ x[key+count] = i+1; count++; } } return x; } public void solve() throws IOException{ int n = nextInt(); long start = System.currentTimeMillis(); int[][] data = new  = nextInt(); data[i][1] = nextInt(); data[i][2] = nextInt(); } sort(data); int[] x = new int[n]; for(int i = 0; i < x.length; i++){ x[i] = i+1; } double min = 1000000001; int[] ans = new int[n]; System.arraycopy(x, 0, ans, 0, n); int count = 0; while( x[0] > 0 ){ count++; int[] total = new int[n]; int high = data[x[n-1]-1][1]; int low = high; for(int i = n-2; i >= 0; i--){ int a = data[x[i]-1][1]; high = Math.max(high, a); low = Math.min(low, a); total[i] = high+low+Math.min(high-a,  double v = (double)2000/70; int i = 0; for(; i < x.length-1; i++){ if( sum + total[i]/v > min ){ // writer.println(\"cut at \" + i + \", v = \" + v + \", sum = \" + sum); sum = min; break; } int len = Math.abs(data[x[i]-1][1]-data[x[i+1]-1][1]); w += 20*data[x[i]-1][2]; v =  System.arraycopy(x, 0, ans, 0, n); min = sum; } i = Math.min(i, n-1); x = nextPermutation(x, i); } writer.println(count); writer.println(min); writer.print(data[ans[0]-1][0]);  writer.flush(); } public static void main (String args[]) throws IOException{ new Main().run(); } BufferedReader reader; StringTokenizer tokenizer;  new BufferedReader(new InputStreamReader(System.in)); tokenizer = null; writer = new PrintWriter(System.out); solve(); reader.close(); writer.close(); } catch (Exception e){ e.printStackTrace(); System.exit(1); } } public int nextInt() throws IOException{  == null  } }"], "original_ll": -0.8479388952255249, "sampled_ll": -0.5018692016601562, "all_perturbed_sampled_ll": [-1.4103243350982666], "all_perturbed_original_ll": [-1.5204795598983765], "perturbed_sampled_ll": -1.4103243350982666, "perturbed_original_ll": -1.5204795598983765, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = int(input())\nD = [list(map(int, input().split())) for i in range(n)]\n# [cost, order]\nmemo = {(2**n-1, i): (0, ()) for i in range(n)}\ndef dfs(state, pos, w):\n    if (state, pos) in memo:\n        return memo[state, pos]\n    res = None\n    for i in range(n):\n        if (state >> i) & 1 == 0:\n            d0 = D[pos][1]\n            s, d1, v = D[i]\n            r = dfs(state | (1 << i), i, w + 20*v)\n            val = (r[0]+abs(d0-d1)*(70+w), r[1]+(s,))\n            if res is None or val < res:\n                res = val\n    if res:\n        memo[state, pos] = res\n    return res\ndef solve():\n    for i in range(n):\n        s0, d0, v0 = D[i]\n        result = dfs(1 << i, i, 20*v0)\n        yield result[0], result[1]+(s0,)\nans = min(solve())\nprint(*reversed(ans[1]))", "sampled": "from itertools import permutations\n\ndef calculate_time(order, warehouses):\n    total_time = 0\n    current_pos = 0\n    current_weight = 0\n    \n    for i, idx in enumerate(order):\n        warehouse = warehouses[idx]\n        pos = warehouse[1]\n        boxes = warehouse[2]\n        \n        # Move to this warehouse\n        distance = abs(pos - current_pos)\n        speed = 2000 / (70 + current_weight)\n        time = distance / speed\n        total_time += time\n        \n        # Pick up boxes\n        current_weight += boxes * 20\n        current_pos = pos\n    \n    return total_time\n\nn = int(input())\nwarehouses = []\nfor _ in range(n):\n    parts = list(map(int, input().split()))\n    warehouses.append((parts[0], parts[1], parts[2]))\n\nmin_time = float('inf')\nbest_order = None\n\nfor perm in permutations(range(n)):\n    time = calculate_time(perm, warehouses)\n    if time < min_time:\n        min_time = time\n        best_order = perm\n\nresult = [warehouses[i][0] for i in best_order]\nprint(' '.join(map(str, result)))\n", "perturbed_sampled": ["from itertools import permutations def calculate_time(order, warehouses): total_time = 0 current_pos = 0 current_weight = 0 for i, idx in enumerate(order): warehouse = warehouses[idx] pos = warehouse[1] boxes  time = distance / speed total_time += time # Pick up boxes current_weight += boxes * 20 current_pos = pos return total_time n = int(input()) warehouses = [] for _ in range(n):  best_order = None for perm in permutations(range(n)): time = calculate_time(perm, warehouses) if time < min_time: min_time = time best_order = perm result = [warehouses[i][0] for i in best_order] print(' '.join(map(str, result)))"], "perturbed_original": ["n = int(input()) D = [list(map(int, input().split())) for i in range(n)] # [cost, order] memo = {(2**n-1, i): (0, ()) for i in range(n)} def dfs(state, pos, w): if (state, pos) in memo: return memo[state, pos] res = None for   = dfs(state | (1 << i), i, w + 20*v) val = (r[0]+abs(d0-d1)*(70+w), r[1]+(s,)) if res is None or val < res: res = val if res: memo[state, pos] = res  v0 = D[i] result = dfs(1 << i, i, 20*v0) yield result[0], result[1]+(s0,) ans = min(solve()) print(*reversed(ans[1]))"], "original_ll": -1.4479782581329346, "sampled_ll": -1.0304558277130127, "all_perturbed_sampled_ll": [-1.9265402555465698], "all_perturbed_original_ll": [-2.357182741165161], "perturbed_sampled_ll": -1.9265402555465698, "perturbed_original_ll": -2.357182741165161, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==95)c++;\n\t}\n\treturn (c?1:0);\n}", "sampled": "#include <stdio.h>\n\ntypedef struct {\n    int group_id;\n    int leave_time;\n} Seat;\n\ntypedef struct {\n    int group_id;\n    int arrival_time;\n    int size;\n    int eating_time;\n} Group;\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) != EOF) {\n        Seat seats[17];\n        Group groups[100];\n        int queue[100];\n        int queue_front = 0, queue_rear = 0;\n        \n        // Initialize seats\n        for (int i = 0; i < 17; i++) {\n            seats[i].group_id = -1;\n            seats[i].leave_time = -1;\n        }\n        \n        // Initialize groups\n        for (int i = 0; i < 100; i++) {\n            groups[i].group_id = i;\n            groups[i].arrival_time = 5 * i;\n            groups[i].size = (i % 5 == 1) ? 5 : 2;\n            groups[i].eating_time = 17 * (i % 2) + 3 * (i % 3) + 19;\n        }\n        \n        int seated_time[100];\n        for (int i = 0; i < 100; i++) {\n            seated_time[i] = -1;\n        }\n        \n        int next_arrival = 0;\n        int time = 0;\n        \n        while (1) {\n            // Process departures\n            for (int i = 0; i < 17; i++) {\n                if (seats[i].group_id != -1 && seats[i].leave_time == time) {\n                    seats[i].group_id = -1;\n                    seats[i].leave_time = -1;\n                }\n            }\n            \n            // Try to seat groups from queue\n            while (queue_front < queue_rear) {\n                int gid = queue[queue_front];\n                int size = groups[gid].size;\n                \n                // Find continuous empty seats\n                int found = -1;\n                for (int start = 0; start <= 17 - size; start++) {\n                    int ok = 1;\n                    for (int j = 0; j < size; j++) {\n                        if (seats[start + j].group_id != -1) {\n                            ok = 0;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        found = start;\n                        break;\n                    }\n                }\n                \n                if (found != -1) {\n                    // Seat the group\n                    for (int j = 0; j < size; j++) {\n                        seats[found + j].group_id = gid;\n                        seats[found + j].leave_time = time + groups[gid].eating_time;\n                    }\n                    seated_time[gid] = time;\n                    queue_front++;\n                } else {\n                    break;\n                }\n            }\n            \n            // Handle arrivals at this time\n            while (next_arrival < 100 && groups[next_arrival].arrival_time == time) {\n                int gid = next_arrival;\n                int size = groups[gid].size;\n                \n                if (queue_front < queue_rear) {\n                    // Queue exists, join queue\n                    queue[queue_rear++] = gid;\n                } else {\n                    // Try to seat immediately\n                    int found = -1;\n                    for (int start = 0; start <= 17 - size; start++) {\n                        int ok = 1;\n                        for (int j = 0; j < size; j++) {\n                            if (seats[start + j].group_id != -1) {\n                                ok = 0;\n                                break;\n                            }\n                        }\n                        if (ok) {\n                            found = start;\n                            break;\n                        }\n                    }\n                    \n                    if (found != -1) {\n                        // Seat immediately\n                        for (int j = 0; j < size; j++) {\n                            seats[found + j].group_id = gid;\n                            seats[found + j].leave_time = time + groups[gid].eating_time;\n                        }\n                        seated_time[gid] = time;\n                    } else {\n                        // Join queue\n                        queue[queue_rear++] = gid;\n                    }\n                }\n                \n                next_arrival++;\n            }\n            \n            // Check if we're done\n            if (seated_time[n] != -1) {\n                break;\n            }\n            \n            time++;\n        }\n        \n        printf(\"%d\\n\", seated_time[n] - groups[n].arrival_time);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> typedef struct { int group_id; int leave_time; } Seat; typedef struct { int group_id; int arrival_time; int size; int eating_time; } Group; int main() { int n; while (scanf(\"%d\", &n) != EOF) { Seat seats[17]; Group groups[100]; int queue[100]; int queue_front  i = 0; i < 17; i++) { seats[i].group_id = -1; seats[i].leave_time  0; i < 100; i++) { groups[i].group_id = i; groups[i].arrival_time =  ? 5 : 2; groups[i].eating_time = 17 * (i % 2) + 3 * (i % 3) + 19; } int seated_time[100]; for (int i = 0; i < 100; i++) { seated_time[i] = -1; } int  // Process departures for  (seats[i].group_id != -1 && seats[i].leave_time == time) { seats[i].group_id = -1; seats[i].leave_time  queue while (queue_front < queue_rear) { int gid  seats int found = -1;  start++) { int  { ok = 0; break; } } if (ok) { found = start; break; } } if (found != -1) { // Seat the group for (int j = 0; j < size; j++) { seats[found + j].group_id = gid; seats[found + j].leave_time = time + groups[gid].eating_time; } seated_time[gid] = time; queue_front++; } else { break; } } // Handle arrivals at this time while (next_arrival < 100 && groups[next_arrival].arrival_time == time) { int gid = next_arrival;  Queue exists, join queue queue[queue_rear++] = gid; } else { // Try to seat immediately int found = -1; for (int start = 0; start <= 17 - size; start++) { int ok = 1; for (int  + j].group_id != -1) { ok = 0; break; } } if (ok) { found = start; break; }  (int j = 0; j < size; j++) { seats[found + j].group_id = gid; seats[found + j].leave_time = time + groups[gid].eating_time; } seated_time[gid] = time; } else { // Join queue queue[queue_rear++] = gid; } } next_arrival++; } // Check if we're done if (seated_time[n] != -1) { break; } time++; } printf(\"%d\\n\", seated_time[n] - groups[n].arrival_time); } return 0; }"], "perturbed_original": ["main(){ int n,c=0; while(~scanf(\"%d\",&n)){ if(n==95)c++; } return (c?1:0); }"], "original_ll": -2.3260116577148438, "sampled_ll": -0.6059977412223816, "all_perturbed_sampled_ll": [-1.5038683414459229], "all_perturbed_original_ll": [-2.348313331604004], "perturbed_sampled_ll": -1.5038683414459229, "perturbed_original_ll": -2.348313331604004, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/** \u5bfe\u8c61\u5916 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** \u30b0\u30eb\u30fc\u30d7\u6570 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** \u6a19\u6e96\u5165\u529b */\n\tprivate static BufferedReader br;\n\n\t/** \u5ea7\u5e2d\u6570 \u6700\u5f8c\u306e\u5ea7\u5e2d\u756a\u53f7 */\n\tprivate static int seatsNum, firstSeatNum;\n\n\t/** \u5230\u7740\u6642\u9593 \u5ba2\u6570 \u98df\u4e8b\u6642\u9593 \u5f85\u3061\u6642\u9593 */\n\tprivate static int[] arriveMinutes, customersNum, mealMinutes, waitMinutes;\n\n\t/** \u5ea7\u5e2d */\n\tprivate static String[] seats;\n\n\t/** \u521d\u671f\u5316 */\n\tstatic {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tseatsNum = 17;\n\t\tarriveMinutes = new int[GROUP_NUM];\n\t\tcustomersNum = new int[GROUP_NUM];\n\t\tmealMinutes = new int[GROUP_NUM];\n\t\twaitMinutes = new int[GROUP_NUM];\n\t\tseats = new String[seatsNum];\n\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\t// \u30b0\u30eb\u30fc\u30d7\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\t// \u5230\u7740\u6642\u9593\n\t\t\tarriveMinutes[i] = 5 * i;\n\n\t\t\t// \u4eba\u6570\n\t\t\tcustomersNum[i] = i % 5 == 1 ? 5 : 2;\n\n\t\t\t// \u98df\u4e8b\u6642\u9593\n\t\t\tmealMinutes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n\t\t}\n\n\t\t// \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210\n\t\tcreateWaitMinutes();\n\n\t}\n\n\t/** \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210\u3059\u308b */\n\tprivate static void createWaitMinutes() {\n\t\t// \u9806\u756a\n\t\tint groupOrder;\n\n\t\t// \u884c\u5217\u30ea\u30b9\u30c8\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentMinutes = 0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentMinutes++) {\n\t\t\t// \u884c\u5217\u304c\u7d42\u4e86\u3059\u308b\u307e\u3067\u3001\u4e00\u5206\u6bce\u306b\u7e70\u308a\u8fd4\u3059\n\n\t\t\t// \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5ba2\u3092\u96e2\u5e2d\u3055\u305b\u308b\n\t\t\toutCustomer(currentMinutes);\n\n\t\t\tif ((groupOrder = searchGroupNum(arriveMinutes, currentMinutes)) != EXEMPT) {\n\t\t\t\t// \u5230\u7740\u6642\u9593\u306e\u5834\u5408\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// \u884c\u5217\u304c\u306a\u3044\u5834\u5408\n\n\t\t\t\t\tif (isEmpty(groupOrder)) {\n\t\t\t\t\t\t// \u7740\u5e2d\u53ef\u80fd\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u5ea7\u5e2d\u306b\u7740\u5e2d\u3055\u305b\u308b\n\t\t\t\t\t\tsetSeat(Integer.toString(groupOrder), totalGroupNum);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u884c\u5217\u306b\u4e26\u3070\u305b\u308b\n\t\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// \u884c\u5217\u304c\u3042\u308b\u5834\u5408\n\n\t\t\t\t\t// \u884c\u5217\u306b\u4e26\u3070\u305b\u308b\n\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// \u884c\u5217\u304c\u3042\u308b\u5834\u5408\n\n\t\t\t\tfor (int index = 0; index < waitList.size(); index++) {\n\t\t\t\t\t// \u884c\u5217\u30ea\u30b9\u30c8\u5206\u3001\u7e70\u308a\u8fd4\u3059\n\n\t\t\t\t\tif (isEmpty(waitList.get(index))) {\n\t\t\t\t\t\t// \u7740\u5e2d\u53ef\u80fd\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u5ea7\u5e2d\u306b\u7740\u5e2d\u3055\u305b\u308b\n\t\t\t\t\t\tsetSeat(Integer.toString(waitList.get(index)), totalGroupNum);\n\n\t\t\t\t\t\t// \u5f85\u3063\u305f\u6642\u9593\u3092\u8a2d\u5b9a\u3059\u308b\n\t\t\t\t\t\twaitMinutes[waitList.get(index)] = currentMinutes\n\t\t\t\t\t\t\t\t- arriveMinutes[waitList.get(index)];\n\n\t\t\t\t\t\t// \u7740\u5e2d\u3057\u305f\u30b0\u30eb\u30fc\u30d7\u3092\u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3059\u308b\n\t\t\t\t\t\tremoveList.add(index);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u884c\u5217\u306e\u5148\u982d\u304c\u7740\u5e2d\u3067\u304d\u306a\u3044\u305f\u3081\u3001\u6b8b\u308a\u306e\u884c\u5217\u3082\u7740\u5e2d\u4e0d\u53ef\u306b\u3059\u308b\u3002\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306b\u7740\u5e2d\u3057\u305f\u30b0\u30eb\u30fc\u30d7\u304c\u8ffd\u52a0\u3055\u308c\u3066\u3044\u305f\u5834\u5408\n\n\t\t\t\t// \u30ea\u30b9\u30c8\u306e\u964d\u9806\u3067\u30bd\u30fc\u30c8\u3059\u308b\uff08\u30ea\u30e0\u30fc\u30d6\u3059\u308b\u305f\u3081\uff09\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u5206\u3001\u7e70\u308a\u8fd4\u3059\n\n\t\t\t\t\t// \u884c\u5217\u30ea\u30b9\u30c8\u304b\u3089\u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306e\u756a\u53f7\u3092\u524a\u9664\u3059\u308b\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// \u521d\u671f\u5316\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** \u30e1\u30a4\u30f3 */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile (!isNull(line = br.readLine()) && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitMinutes[input]);\n\t\t}\n\n\t}\n\n\t/** \u73fe\u5728\u6642\u9593\u306b\u5230\u7740\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u691c\u7d22\u3057\u8fd4\u3059 */\n\tprivate static int searchGroupNum(int[] targets, int currentMinutes) {\n\t\tint order = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (isSame(target, currentMinutes)) {\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\torder++;\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** \u96e2\u5e2d\u3055\u305b\u308b */\n\tprivate static void outCustomer(int currentMinutes) {\n\n\t\tfor (int seatNum = 0; seatNum < seats.length; seatNum++) {\n\t\t\t// \u5ea7\u5e2d\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\tif (isNull(seats[seatNum])) {\n\t\t\t\t// \u7a7a\u5e2d\u306e\u5834\u5408\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (finishedMeal(currentMinutes, seats[seatNum])) {\n\t\t\t\t// \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5834\u5408\n\n\t\t\t\t// \u7a7a\u5e2d\u306b\u3059\u308b\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/** \u5f15\u6570\u304cnull\u304b\u7a7a\u767d\u306e\u5834\u5408\u3001true\u3092\u8fd4\u3059 */\n\tprivate static boolean isNull(String param) {\n\t\treturn param == null;\n\t}\n\n\t/** \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5ea7\u5e2d\u306e\u5834\u5408\u3001true\u3092\u8fd4\u3059 */\n\tprivate static boolean finishedMeal(int currentMinutes, String seat) {\n\t\treturn currentMinutes\n\t\t\t\t- (arriveMinutes[Integer.parseInt(seat)] + waitMinutes[Integer\n\t\t\t\t\t\t.parseInt(seat)]) >= mealMinutes[Integer.parseInt(seat)];\n\t}\n\n\t/** \u7740\u5e2d\u3055\u305b\u308b */\n\tprivate static void setSeat(String groupOrder, int totalGroupNum) {\n\n\t\tfor (int count = 0; count < customersNum[Integer.parseInt(groupOrder)]; count++) {\n\t\t\t// \u7740\u5e2d\u3059\u308b\u4eba\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\t// \u5ea7\u5e2d\u306b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b\n\t\t\tseats[firstSeatNum++] = groupOrder;\n\t\t}\n\t\ttotalGroupNum++;\n\t}\n\n\t/** \u5f15\u6570\u306e\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u306e\u5ba2\u6570\u5206\u3001\u7a7a\u5e2d\u304b\u3069\u3046\u304b\u78ba\u8a8d\u3059\u308b */\n\tprivate static boolean isEmpty(int groupsNum) {\n\n\t\t// \u7a7a\u5e2d\u6570\n\t\tint emptyseatsNum = 0;\n\t\tint i = 0;\n\n\t\tfor (; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n\t\t\t// \u6b8b\u5ea7\u5e2d\u6570\u304c\u5ba2\u306e\u6570\u4ee5\u4e0b\u306b\u306a\u308b\u307e\u3067\u5ea7\u5e2d\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\tif (isSame(customersNum[groupsNum], emptyseatsNum)) {\n\t\t\t\t// \u9023\u7d9a\u3057\u305f\u7a7a\u5e2d\u304c\u5ba2\u306e\u6570\u3060\u3051\u3042\u3063\u305f\u5834\u5408\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (isNull(seats[i])) {\n\t\t\t\t// \u7a7a\u5e2d\u304b\u3064\u7e70\u308a\u8fd4\u3059\u5e2d\u304c\u9867\u5ba2\u6570\u5206\u4ee5\u4e0a\u5b58\u5728\u3059\u308b\u5834\u5408\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// \u7a7a\u5e2d\u3067\u306a\u3044\u5834\u5408\n\n\t\t\t\t// \u7a7a\u5e2d\u6570\u3092\u521d\u671f\u5316\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\t\tif (isSame(customersNum[groupsNum], emptyseatsNum)) {\n\t\t\t// \u7a7a\u5e2d\u306e\u6700\u521d\u306e\u5ea7\u5e2d\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b\n\t\t\tfirstSeatNum = i - emptyseatsNum;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** \u7b2c\u4e00\u5f15\u6570\u3068\u7b2c\u4e8c\u5f15\u6570\u304c\u540c\u3058\u5834\u5408\u3001true\u3092\u8fd4\u3059 */\n\tprivate static boolean isSame(int param, int target) {\n\t\treturn param == target;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Group {\n        int id;\n        int arrivalTime;\n        int size;\n        int eatingTime;\n        int seatedTime;\n        \n        Group(int id) {\n            this.id = id;\n            this.arrivalTime = 5 * id;\n            this.size = (id % 5 == 1) ? 5 : 2;\n            this.eatingTime = 17 * (id % 2) + 3 * (id % 3) + 19;\n            this.seatedTime = -1;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            System.out.println(simulate(n));\n        }\n        sc.close();\n    }\n    \n    static int simulate(int targetGroup) {\n        int[] seats = new int[17];\n        Arrays.fill(seats, -1);\n        int[] leaveTime = new int[17];\n        \n        Group[] groups = new Group[100];\n        for (int i = 0; i < 100; i++) {\n            groups[i] = new Group(i);\n        }\n        \n        Queue<Group> queue = new LinkedList<>();\n        int nextGroupToArrive = 0;\n        \n        for (int time = 0; time <= 10000; time++) {\n            // Step 1: Process departures\n            for (int i = 0; i < 17; i++) {\n                if (seats[i] != -1 && leaveTime[i] == time) {\n                    seats[i] = -1;\n                }\n            }\n            \n            // Step 2: Seat groups from queue\n            while (!queue.isEmpty()) {\n                Group g = queue.peek();\n                int pos = findSeats(seats, g.size);\n                if (pos != -1) {\n                    queue.poll();\n                    for (int i = pos; i < pos + g.size; i++) {\n                        seats[i] = g.id;\n                        leaveTime[i] = time + g.eatingTime;\n                    }\n                    g.seatedTime = time;\n                } else {\n                    break;\n                }\n            }\n            \n            // Step 3: Process arrivals\n            while (nextGroupToArrive < 100 && groups[nextGroupToArrive].arrivalTime == time) {\n                Group g = groups[nextGroupToArrive];\n                nextGroupToArrive++;\n                \n                if (queue.isEmpty()) {\n                    int pos = findSeats(seats, g.size);\n                    if (pos != -1) {\n                        for (int i = pos; i < pos + g.size; i++) {\n                            seats[i] = g.id;\n                            leaveTime[i] = time + g.eatingTime;\n                        }\n                        g.seatedTime = time;\n                    } else {\n                        queue.offer(g);\n                    }\n                } else {\n                    queue.offer(g);\n                }\n            }\n            \n            if (groups[targetGroup].seatedTime != -1) {\n                return groups[targetGroup].seatedTime - groups[targetGroup].arrivalTime;\n            }\n        }\n        \n        return 0;\n    }\n    \n    static int findSeats(int[] seats, int size) {\n        for (int i = 0; i <= 17 - size; i++) {\n            boolean canSit = true;\n            for (int j = i; j < i + size; j++) {\n                if (seats[j] != -1) {\n                    canSit = false;\n                    break;\n                }\n            }\n            if (canSit) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Group { int id; int arrivalTime; int size; int eatingTime; int seatedTime; Group(int id) { this.id = id; this.arrivalTime = 5  5 : 2; this.eatingTime = 17 * (id % 2) + 3 * (id % 3) + 19; this.seatedTime = -1;  = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); System.out.println(simulate(n)); } sc.close(); } static int simulate(int  leaveTime = new int[17]; Group[] groups = new Group[100]; for (int i = 0; i < 100; i++) { groups[i] = new  0; for (int time = 0; time <= 10000; time++) { // Step 1: Process departures for (int i = 0; i < 17; i++) { if (seats[i] != -1 && leaveTime[i] == time) { seats[i] = -1; } } // Step 2: Seat groups from queue while (!queue.isEmpty()) { Group g = queue.peek(); int pos = findSeats(seats, g.size); if (pos  < pos + g.size; i++)  g.seatedTime = time; } else { break; } } // Step 3: Process  Group g = groups[nextGroupToArrive]; nextGroupToArrive++; if (queue.isEmpty()) { int pos = findSeats(seats, g.size); if (pos != -1) { for (int i = pos; i < pos + g.size; i++) { seats[i] = g.id; leaveTime[i] = time + g.eatingTime; } g.seatedTime = time; } else { queue.offer(g); } } else { queue.offer(g); } } if (groups[targetGroup].seatedTime != -1) {  = 0;  true; for (int j = i; j < i + size; j++) { if (seats[j] != -1) { canSit = false; break; } } if (canSit) { return i; } } return -1; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class Main { /** \u5bfe\u8c61\u5916 */ private static final int EXEMPT = -1; /** \u30b0\u30eb\u30fc\u30d7\u6570 */ private static final int GROUP_NUM = 100; /** \u6a19\u6e96\u5165\u529b */ private static BufferedReader br; /** \u5ea7\u5e2d\u6570 \u6700\u5f8c\u306e\u5ea7\u5e2d\u756a\u53f7  /** \u5ea7\u5e2d */ private static String[] seats; /** \u521d\u671f\u5316 */ static { br = new BufferedReader(new InputStreamReader(System.in)); seatsNum = 17; arriveMinutes  int[GROUP_NUM]; waitMinutes = new int[GROUP_NUM]; seats = new String[seatsNum]; for (int i = 0; i < GROUP_NUM; i++) { // \u30b0\u30eb\u30fc\u30d7\u6570\u5206\u7e70\u308a\u8fd4\u3059 // \u5230\u7740\u6642\u9593 arriveMinutes[i] = 5 * i; // \u4eba\u6570 customersNum[i] = i % 5 == 1 ? 5 : 2; // \u98df\u4e8b\u6642\u9593 mealMinutes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19; } // \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210 createWaitMinutes(); } /** \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210\u3059\u308b */ private static void createWaitMinutes() { // \u9806\u756a int groupOrder; // \u884c\u5217\u30ea\u30b9\u30c8 List<Integer> waitList = new ArrayList<Integer>(); //  0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentMinutes++) { // \u884c\u5217\u304c\u7d42\u4e86\u3059\u308b\u307e\u3067\u3001\u4e00\u5206\u6bce\u306b\u7e70\u308a\u8fd4\u3059  (isEmpty(groupOrder)) { // \u7740\u5e2d\u53ef\u80fd\u306e\u5834\u5408 // \u5ea7\u5e2d\u306b\u7740\u5e2d\u3055\u305b\u308b setSeat(Integer.toString(groupOrder), totalGroupNum); } else { // \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408 // \u884c\u5217\u306b\u4e26\u3070\u305b\u308b waitList.add(groupOrder); } } else { // \u884c\u5217\u304c\u3042\u308b\u5834\u5408   setSeat(Integer.toString(waitList.get(index)), totalGroupNum); // \u5f85\u3063\u305f\u6642\u9593\u3092\u8a2d\u5b9a\u3059\u308b waitMinutes[waitList.get(index)] = currentMinutes - arriveMinutes[waitList.get(index)]; // \u7740\u5e2d\u3057\u305f\u30b0\u30eb\u30fc\u30d7\u3092\u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3059\u308b removeList.add(index); } else { // \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408 // \u884c\u5217\u306e\u5148\u982d\u304c\u7740\u5e2d\u3067\u304d\u306a\u3044\u305f\u3081\u3001\u6b8b\u308a\u306e\u884c\u5217\u3082\u7740\u5e2d\u4e0d\u53ef\u306b\u3059\u308b\u3002 break;  Collections.reverse(removeList); for (int remove : removeList) { // \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u5206\u3001\u7e70\u308a\u8fd4\u3059 //  } } /** \u30e1\u30a4\u30f3 */ public static void main(String[] args) throws IOException { String line; List<Integer> inputList = new ArrayList<Integer>(); while (!isNull(line = br.readLine()) && !line.isEmpty()) { inputList.add(Integer.parseInt(line)); } for (int input : inputList) { System.out.println(waitMinutes[input]); } } /** \u73fe\u5728\u6642\u9593\u306b\u5230\u7740\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u691c\u7d22\u3057\u8fd4\u3059 */ private static int searchGroupNum(int[] targets, int currentMinutes) { int order = 0; for (int target : targets) { if (isSame(target, currentMinutes)) { return order; } order++; } return EXEMPT; } /** \u96e2\u5e2d\u3055\u305b\u308b */ private static void outCustomer(int currentMinutes) { for (int seatNum = 0;  // \u7a7a\u5e2d\u306e\u5834\u5408 continue; }  null; } } } /** \u5f15\u6570\u304cnull\u304b\u7a7a\u767d\u306e\u5834\u5408\u3001true\u3092\u8fd4\u3059 */ private static boolean isNull(String param) { return param == null; } /** \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5ea7\u5e2d\u306e\u5834\u5408\u3001true\u3092\u8fd4\u3059 */ private static boolean finishedMeal(int currentMinutes, String seat) { return currentMinutes - (arriveMinutes[Integer.parseInt(seat)] + waitMinutes[Integer .parseInt(seat)]) >= mealMinutes[Integer.parseInt(seat)]; } /** \u7740\u5e2d\u3055\u305b\u308b */ private  = 0; count < customersNum[Integer.parseInt(groupOrder)]; count++) { // \u7740\u5e2d\u3059\u308b\u4eba\u6570\u5206\u7e70\u308a\u8fd4\u3059 // \u5ea7\u5e2d\u306b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b seats[firstSeatNum++] = groupOrder; } totalGroupNum++; } /**  int emptyseatsNum = 0; int i = 0; for (; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) { // \u6b8b\u5ea7\u5e2d\u6570\u304c\u5ba2\u306e\u6570\u4ee5\u4e0b\u306b\u306a\u308b\u307e\u3067\u5ea7\u5e2d\u6570\u5206\u7e70\u308a\u8fd4\u3059  { // \u7a7a\u5e2d\u304b\u3064\u7e70\u308a\u8fd4\u3059\u5e2d\u304c\u9867\u5ba2\u6570\u5206\u4ee5\u4e0a\u5b58\u5728\u3059\u308b\u5834\u5408 emptyseatsNum++; continue; } else { // \u7a7a\u5e2d\u3067\u306a\u3044\u5834\u5408 // \u7a7a\u5e2d\u6570\u3092\u521d\u671f\u5316 emptyseatsNum = 0; } } if (isSame(customersNum[groupsNum], emptyseatsNum)) { // \u7a7a\u5e2d\u306e\u6700\u521d\u306e\u5ea7\u5e2d\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b firstSeatNum = i -  private static boolean isSame(int param, int target) { return param == target; } }"], "original_ll": -1.139337420463562, "sampled_ll": -0.6518452763557434, "all_perturbed_sampled_ll": [-1.5031638145446777], "all_perturbed_original_ll": [-1.9209609031677246], "perturbed_sampled_ll": -1.5031638145446777, "perturbed_original_ll": -1.9209609031677246, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0147\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\nfrom collections import deque\ninput = stdin.readline\n\n\nclass Seat():\n    def __init__(self, n):\n        self.seat = '_' * n\n\n    def get(self, num):\n        i = self.seat.find('_'*num)\n        if i != -1:\n            self.seat = self.seat[0:i] + 'o'*num + self.seat[i+num:]\n            return i\n        return None\n\n    def release(self, i, num):\n        self.seat = self.seat[0:i] + '_'*num + self.seat[i+num:]\n\n\ndef solve():\n    waiting_time = [-1] * 100\n    NUM_OF_SEAT = 17\n    seat = Seat(NUM_OF_SEAT)\n    LEAVE = 0\n    COME = 1\n    in_out = []                 #  ??\\?????????????????????????????????\n    Q = deque()                      #  ??\u00a7??????????????????\n    # 100???????????\\????????????????????????\n    for group_id in range(100):\n        if group_id % 5 == 1:\n            num = 5\n        else:\n            num = 2\n        heappush(in_out, (group_id * 5, COME, NUM_OF_SEAT+1, group_id, num))\n\n    while in_out:\n        time, event, start_seat, group_id, num = heappop(in_out)\n        if event == COME:\n            Q.append((time, group_id, num))\n        else:\n            seat.release(start_seat, num)\n        while Q:\n            res = seat.get(Q[0][2])\n            if res is not None:\n                arrive, group_id, num = Q.popleft()\n                waiting_time[group_id] = time - arrive\n                eating_time = 17 * (group_id % 2) + 3*(group_id % 3) + 19\n                heappush(in_out, (time + eating_time, LEAVE, res, group_id, num))\n            else:\n                break\n    return waiting_time\n\n\ndef main(args):\n    waiting_time = solve()\n\n    for line in sys.stdin:\n        print(waiting_time[int(line)])\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    ", "sampled": "import sys\n\ndef solve(n):\n    # Initialize seats (17 seats, -1 means empty)\n    seats = [-1] * 17\n    # Queue of groups waiting\n    queue = []\n    # Dictionary to store group info: arrival_time, size, eat_time, seated_time\n    groups = {}\n    \n    # Generate all 100 groups\n    for i in range(100):\n        arrival = 5 * i\n        size = 5 if i % 5 == 1 else 2\n        eat_time = 17 * (i % 2) + 3 * (i % 3) + 19\n        groups[i] = {\n            'arrival': arrival,\n            'size': size,\n            'eat_time': eat_time,\n            'seated_time': None,\n            'leave_time': None\n        }\n    \n    # Simulate\n    max_time = 5 * 99 + 100  # Safe upper bound\n    \n    for t in range(max_time + 1):\n        # Step 1: Remove groups whose eating time is up\n        for seat_idx in range(17):\n            if seats[seat_idx] != -1:\n                group_id = seats[seat_idx]\n                if groups[group_id]['leave_time'] == t:\n                    seats[seat_idx] = -1\n        \n        # Step 2: Try to seat groups from queue\n        while queue:\n            group_id = queue[0]\n            size = groups[group_id]['size']\n            \n            # Find leftmost position where group can sit\n            seated = False\n            for start in range(18 - size):\n                if all(seats[start + j] == -1 for j in range(size)):\n                    # Seat the group\n                    for j in range(size):\n                        seats[start + j] = group_id\n                    groups[group_id]['seated_time'] = t\n                    groups[group_id]['leave_time'] = t + groups[group_id]['eat_time']\n                    queue.pop(0)\n                    seated = True\n                    break\n            \n            if not seated:\n                break\n        \n        # Step 3: Handle arriving groups\n        for i in range(100):\n            if groups[i]['arrival'] == t:\n                if queue:\n                    # Queue exists, join queue\n                    queue.append(i)\n                else:\n                    # No queue, try to seat directly\n                    size = groups[i]['size']\n                    seated = False\n                    for start in range(18 - size):\n                        if all(seats[start + j] == -1 for j in range(size)):\n                            # Seat the group\n                            for j in range(size):\n                                seats[start + j] = i\n                            groups[i]['seated_time'] = t\n                            groups[i]['leave_time'] = t + groups[i]['eat_time']\n                            seated = True\n                            break\n                    \n                    if not seated:\n                        queue.append(i)\n        \n        # Check if group n has been seated\n        if groups[n]['seated_time'] is not None:\n            wait_time = groups[n]['seated_time'] - groups[n]['arrival']\n            return wait_time\n    \n    return 0\n\n# Read input and process\nfor line in sys.stdin:\n    n = int(line.strip())\n    print(solve(n))\n", "perturbed_sampled": ["import sys def solve(n): # Initialize seats (17 seats, -1 means empty) seats = [-1] * 17 # Queue of groups waiting queue = [] # Dictionary to store group info: arrival_time, size, eat_time, seated_time groups = {} # Generate all 100 groups for i in range(100): arrival = 5 * i size = 5 if i % 5 == 1  3   # Simulate max_time = 5 * 99 + 100 # Safe upper bound for t in range(max_time + 1): # Step 1:  range(17): if seats[seat_idx] != -1: group_id = seats[seat_idx] if groups[group_id]['leave_time'] == t: seats[seat_idx] = -1 # Step 2: Try to seat groups from queue while queue: group_id = queue[0] size = groups[group_id]['size'] # Find leftmost position where group can sit seated = False for start in range(18 - size): if all(seats[start + j] == -1 for j in range(size)): # Seat the group for j in range(size): seats[start + j]  queue.pop(0)  3: Handle arriving groups for i in range(100): if groups[i]['arrival'] == t: if queue: # Queue exists, join queue queue.append(i) else: # No queue, try to  in range(18 - size):  # Seat the group for j in  = t + groups[i]['eat_time'] seated = True break if not seated: queue.append(i) # Check if group n has been seated if groups[n]['seated_time'] is not None: wait_time = groups[n]['seated_time'] - groups[n]['arrival'] return wait_time return 0 # Read input and process for line in sys.stdin: n = int(line.strip()) print(solve(n))"], "perturbed_original": [" from sys import stdin  '_' * n def get(self, num): i = self.seat.find('_'*num) if i != -1: self.seat = self.seat[0:i] + 'o'*num + self.seat[i+num:] return i return None def release(self, i, num): self.seat = self.seat[0:i] + '_'*num + self.seat[i+num:] def solve(): waiting_time = [-1] * 100 NUM_OF_SEAT = 17 seat = Seat(NUM_OF_SEAT) LEAVE = 0 COME  # ??\u00a7?????????????????? # 100???????????\\???????????????????????? for group_id in range(100): if group_id % 5 == 1: num = 5 else: num = 2 heappush(in_out, (group_id  start_seat, group_id, num = heappop(in_out) if event == COME: Q.append((time, group_id, num)) else: seat.release(start_seat, num) while Q: res = seat.get(Q[0][2]) if res is not None: arrive, group_id, num = Q.popleft() waiting_time[group_id] = time - arrive eating_time = 17 * (group_id % 2) + 3*(group_id % 3) + 19 heappush(in_out, (time + eating_time, LEAVE, res, group_id, num)) else: break return waiting_time def main(args): waiting_time  '__main__': main(sys.argv[1:])"], "original_ll": -1.3466238975524902, "sampled_ll": -1.0123385190963745, "all_perturbed_sampled_ll": [-2.075932025909424], "all_perturbed_original_ll": [-2.11985445022583], "perturbed_sampled_ll": -2.075932025909424, "perturbed_original_ll": -2.11985445022583, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint a,n,i;\n\tprintf(\"?????\u00a3????????\u00a3????????\u00b0?????\\?????????????????????\",a);\n\tscanf(\"%d\",&a) ;\n\ti=a%39;\n\tif(i==0)\n\t{\n\t\tprintf(\"????????????????????????\");\n\t}\n\telse\n\t{\n\t\tprintf(\"3C%d\\n\",i);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a;\n    while (scanf(\"%d\", &a) != EOF) {\n        int student = a % 39;\n        if (student == 0) {\n            student = 39;\n        }\n        printf(\"3C%02d\\n\", student);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int a; while (scanf(\"%d\", &a) !=  == 0) { student = 39; } printf(\"3C%02d\\n\", student); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int a,n,i; printf(\"?????\u00a3????????\u00a3????????\u00b0?????\\?????????????????????\",a); scanf(\"%d\",&a) ; i=a%39; if(i==0) { printf(\"????????????????????????\"); } else { printf(\"3C%d\\n\",i); } return 0; }"], "original_ll": -1.992280125617981, "sampled_ll": -1.161375880241394, "all_perturbed_sampled_ll": [-2.0775840282440186], "all_perturbed_original_ll": [-2.2133049964904785], "perturbed_sampled_ll": -2.0775840282440186, "perturbed_original_ll": -2.2133049964904785, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tSystem.out.printf(\"3C%01d\\n\",(sc.nextInt())%39);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int candies = sc.nextInt();\n            int studentNumber = candies % 39;\n            \n            if (studentNumber == 0) {\n                studentNumber = 39;\n            }\n            \n            System.out.printf(\"3C%02d%n\", studentNumber);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int candies = sc.nextInt(); int studentNumber = candies % 39; if (studentNumber ==  } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(sc.hasNext()){ System.out.printf(\"3C%01d\\n\",(sc.nextInt())%39); } } }"], "original_ll": -1.4652525186538696, "sampled_ll": -1.006607174873352, "all_perturbed_sampled_ll": [-1.7092888355255127], "all_perturbed_original_ll": [-1.6198550462722778], "perturbed_sampled_ll": -1.7092888355255127, "perturbed_original_ll": -1.6198550462722778, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "try:\n    while True:\n        ame = int(input())\n        num1 = ame % 39\n        if num1 == 0:\n            num1 = 39\n        if num1 < 10:\n            print(\"3C0\" + str(num1))\n        else:\n            print(\"3C\" + str(num1))\nexcept EOFError as e:\n    num = 0\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    a = int(line.strip())\n    student = a % 39\n    if student == 0:\n        student = 39\n    print(f\"3C{student:02d}\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: a = int(line.strip()) student = a % 39 if student == 0: student = 39 print(f\"3C{student:02d}\")"], "perturbed_original": ["try: while True: ame = int(input()) num1 = ame % 39 if num1 == 0: num1 = 39  str(num1)) except EOFError as e: num = 0"], "original_ll": -1.4087200164794922, "sampled_ll": -1.704241156578064, "all_perturbed_sampled_ll": [-2.3377912044525146], "all_perturbed_original_ll": [-2.7187576293945312], "perturbed_sampled_ll": -2.3377912044525146, "perturbed_original_ll": -2.7187576293945312, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint rn[4], ln[4];\n\nint main(void)\n{\n\tdouble right, left;\n\tdouble EPS;\n\tint i;\n\t\n\tEPS = 1e-8;\n\t\n\twhile (scanf(\"%lf %lf\", &right, &left) != EOF){\n\t\t\n\t\tif (right >= 1.1){\n\t\t\trn[0]++;\n\t\t}\n\t\telse if (right >= 0.6){\n\t\t\trn[1]++;\n\t\t}\n\t\telse if(right >= 0.2){\n\t\t\trn[2]++;\n\t\t}\n\t\telse {\n\t\t\trn[3]++;\n\t\t}\n\t\tif (left >= 1.1){\n\t\t\tln[0]++;\n\t\t}\n\t\telse if (left >= 0.6){\n\t\t\tln[1]++;\n\t\t}\n\t\telse if(left >= 0.2){\n\t\t\tln[2]++;\n\t\t}\n\t\telse {\n\t\t\tln[3]++;\n\t\t}\n\t}\n\tfor (i = 0; i < 4; i++){\n\t\tprintf(\"%d %d\\n\", rn[i], ln[i]);\n\t}\n\treturn (0);\n}\n\t\t\t", "sampled": "#include <stdio.h>\n\nint main() {\n    double l, r;\n    int countA_L = 0, countA_R = 0;\n    int countB_L = 0, countB_R = 0;\n    int countC_L = 0, countC_R = 0;\n    int countD_L = 0, countD_R = 0;\n    \n    while (scanf(\"%lf %lf\", &l, &r) == 2) {\n        // Left eye\n        if (l >= 1.1) {\n            countA_L++;\n        } else if (l >= 0.6) {\n            countB_L++;\n        } else if (l >= 0.2) {\n            countC_L++;\n        } else {\n            countD_L++;\n        }\n        \n        // Right eye\n        if (r >= 1.1) {\n            countA_R++;\n        } else if (r >= 0.6) {\n            countB_R++;\n        } else if (r >= 0.2) {\n            countC_R++;\n        } else {\n            countD_R++;\n        }\n    }\n    \n    printf(\"%d %d\\n\", countA_L, countA_R);\n    printf(\"%d %d\\n\", countB_L, countB_R);\n    printf(\"%d %d\\n\", countC_L, countC_R);\n    printf(\"%d %d\\n\", countD_L, countD_R);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double l, r; int countA_L = 0, countA_R = 0; int countB_L = 0, countB_R = 0; int countC_L = 0, countC_R = 0; int countD_L = 0, countD_R = 0; while (scanf(\"%lf %lf\", &l, &r) == 2) { // Left  >= 0.2) { countC_L++; } else { countD_L++; } // Right eye if (r >= 1.1) { countA_R++; } else if (r >= 0.6) {  else { countD_R++; } } printf(\"%d %d\\n\", countA_L, countA_R); printf(\"%d %d\\n\", countB_L, countB_R); printf(\"%d %d\\n\", countC_L, countC_R); printf(\"%d %d\\n\", countD_L, countD_R); return 0; }"], "perturbed_original": ["#include <stdio.h> int rn[4], ln[4]; int main(void) { double right, left; double EPS; int i; EPS = 1e-8; while (scanf(\"%lf %lf\", &right, &left) != EOF){ if (right >= 1.1){ rn[0]++; } else if (right >= 0.6){ rn[1]++; } else if(right >= 0.2){ rn[2]++; } else { rn[3]++; } if (left  ln[3]++; } } for (i = 0; i < 4; i++){ printf(\"%d %d\\n\", rn[i], ln[i]); } return (0); }"], "original_ll": -0.8063955903053284, "sampled_ll": -0.40311920642852783, "all_perturbed_sampled_ll": [-0.9439312815666199], "all_perturbed_original_ll": [-1.4096119403839111], "perturbed_sampled_ll": -0.9439312815666199, "perturbed_original_ll": -1.4096119403839111, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tScanner sc;\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner (System.in);\n\t\t\n\t\tint[][] num=new int[4][2];\n\t\tfor(int[] e:num)Arrays.fill(e,0);\n\t\tint side=0;\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tdouble eye=nd();\n\t\t\tif(eye>=1.1) ++num[0][side];\n\t\t\telse if(eye>=0.6) ++num[1][side];\n\t\t\telse if(eye>=0.2) ++num[2][side];\n\t\t\telse ++num[3][side];\n\t\t\tside^=1;\n\t\t}\n\t\tfor(int i=0;i<4;++i)System.out.println(num[i][0]+\" \"+num[i][1]);\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int[] leftCount = new int[4];\n        int[] rightCount = new int[4];\n        \n        while (sc.hasNext()) {\n            double left = sc.nextDouble();\n            double right = sc.nextDouble();\n            \n            leftCount[getCategory(left)]++;\n            rightCount[getCategory(right)]++;\n        }\n        \n        for (int i = 0; i < 4; i++) {\n            System.out.println(leftCount[i] + \" \" + rightCount[i]);\n        }\n        \n        sc.close();\n    }\n    \n    private static int getCategory(double vision) {\n        if (vision >= 1.1) {\n            return 0; // A\n        } else if (vision >= 0.6) {\n            return 1; // B\n        } else if (vision >= 0.2) {\n            return 2; // C\n        } else {\n            return 3; // D\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  Scanner sc = new Scanner(System.in); int[] leftCount = new int[4]; int[] rightCount = new  =  < 4; i++) { System.out.println(leftCount[i] + \" \" + rightCount[i]); } sc.close(); } private static int getCategory(double vision) { if (vision >= 1.1) { return 0; // A } else if (vision >= 0.6) { return 1; // B } else if (vision >= 0.2) { return 2; // C } else { return 3; // D } } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { Scanner  (System.in); int[][] num=new int[4][2]; for(int[] e:num)Arrays.fill(e,0); int side=0; while(sc.hasNext()){ double eye=nd(); if(eye>=1.1) ++num[0][side]; else if(eye>=0.6) ++num[1][side]; else if(eye>=0.2) ++num[2][side]; else ++num[3][side]; side^=1; } for(int i=0;i<4;++i)System.out.println(num[i][0]+\" \"+num[i][1]); sc.close(); } public static void main(String[] args) { // TODO Auto-generated method stub new Main().io(); } }"], "original_ll": -1.1762874126434326, "sampled_ll": -0.5471305847167969, "all_perturbed_sampled_ll": [-1.4982670545578003], "all_perturbed_original_ll": [-1.5257306098937988], "perturbed_sampled_ll": -1.4982670545578003, "perturbed_original_ll": -1.5257306098937988, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "c = [1.1,0.6,0.2,0.0]\nr = [0,0,0,0,0,0,0,0]\nwhile 1:\n    try:\n        e = map(float, raw_input().split())\n        for i in range(2):\n            for j in range(4):\n                if e[i] >= c[j]:\n                \tr[i+2*j] += 1\n                \tbreak\n    except:\n        break\nfor i in range(0,8,2):\n\tprint r[i],r[i+1]", "sampled": "import sys\n\ndef classify(vision):\n    if vision >= 1.1:\n        return 'A'\n    elif vision >= 0.6:\n        return 'B'\n    elif vision >= 0.2:\n        return 'C'\n    else:\n        return 'D'\n\nleft_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0}\nright_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0}\n\nfor line in sys.stdin:\n    l, r = map(float, line.strip().split())\n    left_count[classify(l)] += 1\n    right_count[classify(r)] += 1\n\nprint(left_count['A'], right_count['A'])\nprint(left_count['B'], right_count['B'])\nprint(left_count['C'], right_count['C'])\nprint(left_count['D'], right_count['D'])\n", "perturbed_sampled": ["import sys def  0.6: return  left_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0} right_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0} for line in sys.stdin: l, r = map(float, line.strip().split()) left_count[classify(l)] += 1 right_count[classify(r)] += 1 print(left_count['A'], right_count['A']) print(left_count['B'], right_count['B']) print(left_count['C'], right_count['C']) print(left_count['D'], right_count['D'])"], "perturbed_original": ["c  map(float, raw_input().split()) for i in range(2): for j in range(4): if e[i] >= c[j]: r[i+2*j] += 1 break except: break for i in range(0,8,2): print r[i],r[i+1]"], "original_ll": -1.3346502780914307, "sampled_ll": -0.5886207222938538, "all_perturbed_sampled_ll": [-1.0251331329345703], "all_perturbed_original_ll": [-2.505007266998291], "perturbed_sampled_ll": -1.0251331329345703, "perturbed_original_ll": -2.505007266998291, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "m[4][65536],i,l,L,p,c;main(n){for(;~scanf(\"%d\\n\",&n);L=n&&!printf(\"%d\\n\",L))for(p=255;++p<256-~n*n;)for(c=getchar(i=4);i--;L=l>L?l:L)l=m[i][p]=c-49?0:m[i][p-(i?n+i-1:1)]+1;}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    char grid[256][256];\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        for(int i = 0; i < n; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        int max_count = 0;\n        \n        // Check horizontal\n        for(int i = 0; i < n; i++) {\n            int count = 0;\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n            }\n        }\n        \n        // Check vertical\n        for(int j = 0; j < n; j++) {\n            int count = 0;\n            for(int i = 0; i < n; i++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n            }\n        }\n        \n        // Check diagonal (top-left to bottom-right)\n        // Starting from first row\n        for(int start_col = 0; start_col < n; start_col++) {\n            int count = 0;\n            int i = 0, j = start_col;\n            while(i < n && j < n) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j++;\n            }\n        }\n        // Starting from first column (excluding 0,0)\n        for(int start_row = 1; start_row < n; start_row++) {\n            int count = 0;\n            int i = start_row, j = 0;\n            while(i < n && j < n) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j++;\n            }\n        }\n        \n        // Check diagonal (top-right to bottom-left)\n        // Starting from first row\n        for(int start_col = 0; start_col < n; start_col++) {\n            int count = 0;\n            int i = 0, j = start_col;\n            while(i < n && j >= 0) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j--;\n            }\n        }\n        // Starting from last column (excluding 0,n-1)\n        for(int start_row = 1; start_row < n; start_row++) {\n            int count = 0;\n            int i = start_row, j = n - 1;\n            while(i < n && j >= 0) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j--;\n            }\n        }\n        \n        printf(\"%d\\n\", max_count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() {  != 0) { for(int i = 0; i < n; i++) { scanf(\"%s\", grid[i]); } int max_count =  n; i++) { int count = 0; for(int j = 0; j < n; j++) { if(grid[i][j] == '1') { count++; if(count > max_count) max_count = count; } else { count = 0; } } } // Check vertical for(int j = 0; j < n; j++) {  n; i++) { if(grid[i][j] == '1') { count++; if(count > max_count) max_count = count; } else { count = 0; } } } // Check diagonal  = 0; start_col < n; start_col++) { int count = 0; int i = 0, j = start_col; while(i < n && j < n) { if(grid[i][j] == '1')  // Starting from first column (excluding 0,0) for(int start_row = 1; start_row < n; start_row++) { int count = 0; int i = start_row, j =  == '1') { count++; if(count > max_count) max_count = count; } else { count  start_col = 0; start_col < n; start_col++) { int count = 0; int i = 0, j = start_col; while(i < n && j >= 0) { if(grid[i][j] == '1') { count++; if(count > max_count) max_count = count; } else { count = 0; } i++; j--; } } // Starting from last column (excluding 0,n-1) for(int start_row = 1; start_row < n; start_row++)  = n - 1; while(i < n && j >= 0)  = count; } else { count = 0; } i++; j--; } } printf(\"%d\\n\", max_count); } return 0; }"], "perturbed_original": ["m[4][65536],i,l,L,p,c;main(n){for(;~scanf(\"%d\\n\",&n);L=n&&!printf(\"%d\\n\",L))for(p=255;++p<256-~n*n;)for(c=getchar(i=4);i--;L=l>L?l:L)l=m[i][p]=c-49?0:m[i][p-(i?n+i-1:1)]+1;}"], "original_ll": -3.3190577030181885, "sampled_ll": -0.2597476840019226, "all_perturbed_sampled_ll": [-1.0147907733917236], "all_perturbed_original_ll": [-3.3190577030181885], "perturbed_sampled_ll": -1.0147907733917236, "perturbed_original_ll": -3.3190577030181885, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] map = new boolean[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tchar[] ch = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tmap[i][j] = ch[j] == '1';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(map[i][j] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(map[j][i] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j <= i; j++){\n\t\t\t\t\t//System.out.print(\"( \" + (i - j) +\" \" + j + \") \");\n\t\t\t\t\tif(map[i - j][j] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = n - 1; j >= i; j--){\n\t\t\t\t\t//System.out.print(\"( \" + j +\" \" + (j - i) + \") \");\n\t\t\t\t\tif(map[j][j-i] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < (n - i) ; j++){\n\t\t\t\t\t//System.out.print(\"( \" + (j) +\" \" + (i+j) + \") \");\n\t\t\t\t\tif(map[j][i+j] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < (n - i); j++){\n\t\t\t\t\t//System.out.print(\"( \" + (i + j) +\" \" + (i) + \") \");\n\t\t\t\t\tif(map[i+j][i] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[][] grid = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                String line = sc.next();\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = line.charAt(j) - '0';\n                }\n            }\n            \n            int maxConsecutive = 0;\n            \n            // Check horizontal\n            for (int i = 0; i < n; i++) {\n                int count = 0;\n                for (int j = 0; j < n; j++) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n            }\n            \n            // Check vertical\n            for (int j = 0; j < n; j++) {\n                int count = 0;\n                for (int i = 0; i < n; i++) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n            }\n            \n            // Check diagonal (top-left to bottom-right)\n            for (int start = 0; start < n; start++) {\n                // Starting from first row\n                int count = 0;\n                for (int i = 0, j = start; i < n && j < n; i++, j++) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n                \n                // Starting from first column (skip 0,0 as it's already covered)\n                if (start > 0) {\n                    count = 0;\n                    for (int i = start, j = 0; i < n && j < n; i++, j++) {\n                        if (grid[i][j] == 1) {\n                            count++;\n                            maxConsecutive = Math.max(maxConsecutive, count);\n                        } else {\n                            count = 0;\n                        }\n                    }\n                }\n            }\n            \n            // Check diagonal (top-right to bottom-left)\n            for (int start = 0; start < n; start++) {\n                // Starting from first row\n                int count = 0;\n                for (int i = 0, j = start; i < n && j >= 0; i++, j--) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n                \n                // Starting from last column (skip top-right corner as it's already covered)\n                if (start > 0) {\n                    count = 0;\n                    for (int i = start, j = n - 1; i < n && j >= 0; i++, j--) {\n                        if (grid[i][j] == 1) {\n                            count++;\n                            maxConsecutive = Math.max(maxConsecutive, count);\n                        } else {\n                            count = 0;\n                        }\n                    }\n                }\n            }\n            \n            System.out.println(maxConsecutive);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n  i = 0; i < n; i++) { String line = sc.next(); for (int j = 0; j < n; j++) { grid[i][j] = line.charAt(j) - '0'; } } int maxConsecutive = 0; // Check horizontal for (int i = 0; i < n; i++) { int count = 0; for  < n; j++) { int count = 0; for (int i = 0; i  maxConsecutive =  } // Check diagonal (top-left to bottom-right) for (int start = 0; start < n;  0; for (int i = 0, j = start; i < n && j <  maxConsecutive = Math.max(maxConsecutive, count); }  first column (skip 0,0 as it's already covered) if (start > 0) { count = 0; for (int i = start, j = 0; i < n && j < n; i++, j++) { if (grid[i][j] == 1) { count++; maxConsecutive = Math.max(maxConsecutive, count); } else { count = 0; } } } }  0; start < n; start++) { // Starting from first row int count = 0; for (int i = 0, j = start; i < n && j >= 0; i++, j--) { if (grid[i][j] == 1) { count++; maxConsecutive = Math.max(maxConsecutive, count); } else { count = 0; } } // Starting from last column (skip top-right corner as it's already covered) if (start > 0) { count = 0; for (int i = start, j = n - 1; i < n && j >= 0; i++, j--) { if (grid[i][j] == 1) { count++; maxConsecutive = Math.max(maxConsecutive, count); }  } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.LinkedList; import java.util.List; import java.util.Scanner; public class  if(n == 0){ break; } boolean[][] map = new boolean[n][n]; for(int  sc.next().toCharArray(); for(int j = 0; j < n; j++){ map[i][j] = ch[j] == '1'; } } int max = 0; for(int i = 0; i < n; i++){ int count = 0; for(int j = 0; j < n; j++){ if(map[i][j] == true){ count++; } } max = Math.max(max, count); } for(int i = 0; i < n; i++){ int count = 0; for(int j = 0; j < n; j++){ if(map[j][i] == true){ count++; } } max = Math.max(max, count); } for(int i = 0; i < n; i++){ int count = 0;  + (i - j) +\" \" + j + \") \"); if(map[i  Math.max(max,  int count = 0; for(int j = n - 1; j >= i; j--){ //System.out.print(\"( \" + j +\" \" + (j - i) +  = Math.max(max, count); } for(int i = 0; i < n; i++){ int count = 0; for(int j = 0; j <  \" + (i+j) + \") \"); if(map[j][i+j] == true){ count++; } } //System.out.println(); max = Math.max(max,  int count = 0; for(int j = 0; j < (n - i); j++){ //System.out.print(\"( \" + (i + j) +\" \" + (i) + \") \"); if(map[i+j][i] == true){ count++; } } //System.out.println(); max = Math.max(max, count); } System.out.println(max); } } }"], "original_ll": -0.36214011907577515, "sampled_ll": -0.2527104616165161, "all_perturbed_sampled_ll": [-1.0441800355911255], "all_perturbed_original_ll": [-1.0121841430664062], "perturbed_sampled_ll": -1.0441800355911255, "perturbed_original_ll": -1.0121841430664062, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def ge(n):\n    for i in xrange(n):\n        yield [(i,j) for j in xrange(n)]\n        yield [(j,i) for j in xrange(n)]\n        yield [(i-j,j) for j in xrange(i+1)]\n        yield [(n-i+j-1,n-j-1) for j in xrange(i+1)]\n\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    A = [map(int,list(raw_input())) for _ in xrange(n)]\n    print max(sum(map(lambda (i,j): A[i][j], p)) for p in ge(n))", "sampled": "def count_consecutive(line):\n    max_count = 0\n    current_count = 0\n    for char in line:\n        if char == '1':\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n    return max_count\n\ndef solve(n, grid):\n    max_consecutive = 0\n    \n    # Check horizontal\n    for row in grid:\n        max_consecutive = max(max_consecutive, count_consecutive(row))\n    \n    # Check vertical\n    for col in range(n):\n        column = ''.join(grid[row][col] for row in range(n))\n        max_consecutive = max(max_consecutive, count_consecutive(column))\n    \n    # Check diagonals (top-left to bottom-right)\n    # Diagonals starting from first row\n    for start_col in range(n):\n        diagonal = ''.join(grid[i][start_col + i] for i in range(n - start_col))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    # Diagonals starting from first column (excluding top-left corner)\n    for start_row in range(1, n):\n        diagonal = ''.join(grid[start_row + i][i] for i in range(n - start_row))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    # Check diagonals (top-right to bottom-left)\n    # Diagonals starting from first row\n    for start_col in range(n):\n        diagonal = ''.join(grid[i][start_col - i] for i in range(start_col + 1))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    # Diagonals starting from last column (excluding top-right corner)\n    for start_row in range(1, n):\n        diagonal = ''.join(grid[start_row + i][n - 1 - i] for i in range(n - start_row))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    return max_consecutive\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    grid = []\n    for _ in range(n):\n        grid.append(input().strip())\n    \n    result = solve(n, grid)\n    print(result)\n", "perturbed_sampled": ["def count_consecutive(line): max_count = 0 current_count = 0 for char in line: if char == '1': current_count += 1 max_count = max(max_count, current_count) else: current_count = 0 return max_count def solve(n, grid): max_consecutive = 0 # Check horizontal for row in grid: max_consecutive = max(max_consecutive, count_consecutive(row)) # Check vertical for col  = max(max_consecutive, count_consecutive(column)) # Check diagonals (top-left to bottom-right) # Diagonals starting from first row for start_col in range(n): diagonal = ''.join(grid[i][start_col + i] for i in range(n - start_col)) max_consecutive = max(max_consecutive, count_consecutive(diagonal)) # Diagonals starting from first column (excluding  + i][i] for i in range(n - start_row)) max_consecutive = max(max_consecutive, count_consecutive(diagonal)) # Check diagonals (top-right to bottom-left) # Diagonals starting from first row  i in range(start_col  n): diagonal = ''.join(grid[start_row + i][n - 1 - i] for i in range(n  n = int(input()) if n == 0: break grid = [] for _ in range(n): grid.append(input().strip()) result = solve(n, grid) print(result)"], "perturbed_original": ["def ge(n): for i in xrange(n): yield [(i,j) for j in xrange(n)] yield [(j,i) for j in xrange(n)] yield [(i-j,j) for j in xrange(i+1)] yield [(n-i+j-1,n-j-1) for j in xrange(i+1)] while True: n = input() if n == 0: break A = [map(int,list(raw_input()))  p in ge(n))"], "original_ll": -1.3500720262527466, "sampled_ll": -0.5049533247947693, "all_perturbed_sampled_ll": [-1.3191609382629395], "all_perturbed_original_ll": [-1.9066237211227417], "perturbed_sampled_ll": -1.3191609382629395, "perturbed_original_ll": -1.9066237211227417, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\ntypedef struct{\n\tint no;\n\tint score;\n} Info;\n\nvoid sortInfo(int n,Info t[]){\n\tint i,j;\n\tfor(i=0;i<n-1;i++){\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tif(t[i].score < t[j].score ||\n\t\t\t   t[i].score == t[j].score && t[i].no > t[j].no){\n\t\t\t\tInfo tmp = t[i];\n\t\t\t\tt[i] = t[j];\n\t\t\t\tt[j] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint scoring(void){\n\tint i, x, total, frame, time, sum, flgSpare, flgStrike;\n\t\n\ttotal = sum = 0;\n\tframe = time = 1;\n\tflgSpare = flgStrike = 0;\n\t\n\twhile(frame < 10){\n\t\tscanf(\"%d\",&x);\n\t\tsum += x;\n\t\t\n\t\tif(flgSpare){\n\t\t\ttotal += x;\n\t\t\tflgSpare = 0;\n\t\t}\n\t\telse if(flgStrike){\n\t\t\tif(flgStrike == 3){\n\t\t\t\ttotal += x;\n\t\t\t\tflgStrike--;\n\t\t\t}\n\t\t\ttotal += x;\n\t\t\tflgStrike--;\n\t\t}\n\t\t\n\t\tif(time == 2){\n\t\t\ttotal += sum;\n\t\t\tif(sum == 10){\n\t\t\t\tflgSpare = 1;\n\t\t\t}\n\t\t\tsum = 0;\n\t\t\ttime = 1;\n\t\t\tframe++;\n\t\t}\n\t\telse if(time == 1){\n\t\t\ttime++;\n\t\t\tif(x == 10){\n\t\t\t\ttotal += 10;\n\t\t\t\tflgStrike += 2;\n\t\t\t\tsum = 0;\n\t\t\t\ttime = 1;\n\t\t\t\tframe++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0;i<3;i++){\n\t\tif(i == 2 && sum < 10) break;\n\t\t\n\t\tscanf(\"%d\",&x);\n\t\ttotal += x;\n\t\tsum += x;\n\t\t\n\t\tif(flgSpare){\n\t\t\ttotal += x;\n\t\t\tflgSpare = 0;\n\t\t}\n\t\telse if(flgStrike){\n\t\t\tif(flgStrike == 3){\n\t\t\t\ttotal += x;\n\t\t\t\tflgStrike--;\n\t\t\t}\n\t\t\ttotal += x;\n\t\t\tflgStrike--;\n\t\t}\n\t}\n\n\treturn total;\n}\n\nint main(void){\n\tint i, n;\n\tInfo info[40];\n\t\n\twhile(scanf(\"%d\",&n) && n){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&info[i].no);\n\t\t\tinfo[i].score = scoring();\n\t\t}\n\t\tsortInfo(n,info);\n\t\tfor(i=0;i<n;i++){\n\t\t\tprintf(\"%d %d\\n\",info[i].no,info[i].score);\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int score;\n} Player;\n\nint calculate_score(int pins[], int n) {\n    int total = 0;\n    int pin_idx = 0;\n    \n    for (int frame = 0; frame < 10; frame++) {\n        if (frame < 9) {\n            if (pins[pin_idx] == 10) { // Strike\n                total += 10 + pins[pin_idx + 1] + pins[pin_idx + 2];\n                pin_idx++;\n            } else if (pins[pin_idx] + pins[pin_idx + 1] == 10) { // Spare\n                total += 10 + pins[pin_idx + 2];\n                pin_idx += 2;\n            } else {\n                total += pins[pin_idx] + pins[pin_idx + 1];\n                pin_idx += 2;\n            }\n        } else { // 10th frame\n            total += pins[pin_idx] + pins[pin_idx + 1];\n            if (pins[pin_idx] == 10 || pins[pin_idx] + pins[pin_idx + 1] == 10) {\n                total += pins[pin_idx + 2];\n            }\n        }\n    }\n    \n    return total;\n}\n\nint compare_players(const void *a, const void *b) {\n    Player *pa = (Player *)a;\n    Player *pb = (Player *)b;\n    \n    if (pa->score != pb->score) {\n        return pb->score - pa->score; // Higher score first\n    }\n    return pa->id - pb->id; // Lower ID first\n}\n\nint main() {\n    int m;\n    \n    while (scanf(\"%d\", &m) == 1 && m != 0) {\n        Player players[40];\n        \n        for (int i = 0; i < m; i++) {\n            int id;\n            int pins[21];\n            int n = 0;\n            \n            scanf(\"%d\", &id);\n            \n            while (n < 21) {\n                if (scanf(\"%d\", &pins[n]) != 1) break;\n                n++;\n                \n                // Check if we should stop reading (peek next character)\n                int c = getchar();\n                if (c == '\\n' || c == EOF) {\n                    ungetc(c, stdin);\n                    break;\n                }\n                ungetc(c, stdin);\n            }\n            \n            players[i].id = id;\n            players[i].score = calculate_score(pins, n);\n        }\n        \n        qsort(players, m, sizeof(Player), compare_players);\n        \n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", players[i].id, players[i].score);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int id; int score; }  0; int pin_idx = 0; for (int frame =  { if (pins[pin_idx] == 10) { // Strike  2]; pin_idx++; } else if (pins[pin_idx] + pins[pin_idx + 1] == 10) { // Spare total += 10 + pins[pin_idx + 2]; pin_idx += 2; } else { total += pins[pin_idx] + pins[pin_idx + 1]; pin_idx += 2; }  pins[pin_idx + 1]; if (pins[pin_idx] == 10 || pins[pin_idx] + pins[pin_idx + 1] == 10) { total  int compare_players(const void  Player *pb = (Player *)b; if (pa->score != pb->score) { return pb->score - pa->score; // Higher  first } int main() { int m; while (scanf(\"%d\", &m) == 1 && m != 0) { Player players[40]; for (int i = 0; i < m; i++) { int id; int pins[21]; int n = 0; scanf(\"%d\", &id); while (n < 21) { if (scanf(\"%d\", &pins[n]) != 1) break; n++; // Check if we should stop reading (peek next character) int c = getchar(); if (c == '\\n' || c == EOF) { ungetc(c, stdin); break; } ungetc(c, stdin); } players[i].id = id; players[i].score = calculate_score(pins, n); } qsort(players,  m; i++) { printf(\"%d %d\\n\", players[i].id, players[i].score); } } return 0; }"], "perturbed_original": ["#include <stdio.h> typedef struct{ int  i,j; for(i=0;i<n-1;i++){ for(j=i+1;j<n;j++){ if(t[i].score  Info tmp = t[i]; t[i] = t[j]; t[j] = tmp; } } } } int scoring(void){ int i, x, total, frame, time, sum, flgSpare, flgStrike; total = sum = 0; frame = time = 1; flgSpare = flgStrike = 0; while(frame < 10){ scanf(\"%d\",&x); sum += x; if(flgSpare){ total += x; flgSpare = 0; } else if(flgStrike){ if(flgStrike == 3){  if(time == 2){ total += sum; if(sum == 10){ flgSpare = 1; } sum = 0; time = 1; frame++; } else if(time == 1){ time++;  = 0; time = 1; frame++; } } } for(i=0;i<3;i++){ if(i == 2 && sum < 10)  += x; flgSpare = 0; } else if(flgStrike){ if(flgStrike == 3){ total += x; flgStrike--; } total += x; flgStrike--; } } return total; } int main(void){ int  = scoring(); } sortInfo(n,info); for(i=0;i<n;i++){ printf(\"%d %d\\n\",info[i].no,info[i].score); } } return 0; }"], "original_ll": -0.7490174174308777, "sampled_ll": -0.5939926505088806, "all_perturbed_sampled_ll": [-1.5059360265731812], "all_perturbed_original_ll": [-1.5557023286819458], "perturbed_sampled_ll": -1.5059360265731812, "perturbed_original_ll": -1.5557023286819458, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass score implements Comparable<score> {\n\t\tString id;\n\t\tint s;\n\n\t\tscore(Scanner sc) {\n\t\t\tid = sc.next();\n\t\t\tint f = 0;\n\t\t\tint x1 = 0;\n\t\t\tint x2 = 0;\n\t\t\tint c = 0;\n\t\t\tint q = 0;\n\t\t\tint e = 0;\n\t\t\ts = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif(f == 9 && e == 1 && c==3){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(f == 9 && e == 0 && c==2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (x1 > 0) {\n\t\t\t\t\tx1--;\n\t\t\t\t\ts+=v;\n\t\t\t\t}\n\t\t\t\tif (x2 > 0) {\n\t\t\t\t\tx2--;\n\t\t\t\t\tx1++;\n\t\t\t\t\ts+=v;\n\t\t\t\t}\n\t\t\t\ts+=v;\n//\t\t\t\tSystem.out.println(s);\n\t\t\t\tif (f == 9) {\n\t\t\t\t\tif(c==0){\n\t\t\t\t\t\tif(v==10){\n\t\t\t\t\t\t\te=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq=v;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}else if(c== 1 && q+v==10){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t} else if (v == 10) {\n\t\t\t\t\tx2 += 1;\n\t\t\t\t\tc = 0;\n\t\t\t\t\tq=0;\n\t\t\t\t\tf++;\n\t\t\t\t} else if (q + v == 10) {\n\t\t\t\t\tx1 += 1;\n\t\t\t\t\tc = 0;\n\t\t\t\t\tq=0;\n\t\t\t\t\tf++;\n\t\t\t\t} else if (c == 1) {\n\t\t\t\t\tc = 0;\n\t\t\t\t\tq=0;\n\t\t\t\t\tf++;\n\t\t\t\t} else {\n\t\t\t\t\tq = v;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(score arg0) {\n\t\t\tint a;\n\t\t\ta = arg0.s - s;\n\t\t\tif (a == 0) {\n\t\t\t\ta = id.compareTo(arg0.id);\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tscore[] c = new score[n];\n\t\t\tfor(int i =0;i<n;i++){\n\t\t\t//\tSystem.out.println(i);\n\t\t\t\tc[i] = new score(sc);\n\t\t\t}\n\t\t\tArrays.sort(c);\n\t\t\t\n\t\t\tfor(int i =0 ; i < n;i++){\n\t\t\t\tSystem.out.println(c[i].id+\" \"+c[i].s);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Player implements Comparable<Player> {\n        int id;\n        int score;\n        \n        public Player(int id, int score) {\n            this.id = id;\n            this.score = score;\n        }\n        \n        @Override\n        public int compareTo(Player other) {\n            if (this.score != other.score) {\n                return other.score - this.score;\n            }\n            return this.id - other.id;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            if (m == 0) break;\n            \n            List<Player> players = new ArrayList<>();\n            \n            for (int i = 0; i < m; i++) {\n                int id = sc.nextInt();\n                List<Integer> rolls = new ArrayList<>();\n                \n                String line = sc.nextLine().trim();\n                String[] tokens = line.split(\"\\\\s+\");\n                for (String token : tokens) {\n                    rolls.add(Integer.parseInt(token));\n                }\n                \n                int score = calculateScore(rolls);\n                players.add(new Player(id, score));\n            }\n            \n            Collections.sort(players);\n            \n            for (Player p : players) {\n                System.out.println(p.id + \" \" + p.score);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static int calculateScore(List<Integer> rolls) {\n        int score = 0;\n        int rollIndex = 0;\n        \n        for (int frame = 0; frame < 10; frame++) {\n            if (frame < 9) {\n                if (rolls.get(rollIndex) == 10) {\n                    score += 10 + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);\n                    rollIndex++;\n                } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) {\n                    score += 10 + rolls.get(rollIndex + 2);\n                    rollIndex += 2;\n                } else {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1);\n                    rollIndex += 2;\n                }\n            } else {\n                if (rolls.get(rollIndex) == 10) {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);\n                    rollIndex += 3;\n                } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);\n                    rollIndex += 3;\n                } else {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1);\n                    rollIndex += 2;\n                }\n            }\n        }\n        \n        return score;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Player implements Comparable<Player> { int id; int score;  = score; } @Override public int compareTo(Player other) { if (this.score != other.score) { return other.score - this.score; } return this.id - other.id; } } public static void  {  players = new ArrayList<>(); for (int i = 0; i < m; i++) { int id = sc.nextInt(); List<Integer>  = line.split(\"\\\\s+\");  = calculateScore(rolls); players.add(new Player(id, score)); } Collections.sort(players); for (Player p : players) { System.out.println(p.id + \" \" + p.score); } } sc.close(); } static int calculateScore(List<Integer> rolls) { int score = 0; int rollIndex = 0; for (int frame = 0; frame < 10; frame++) { if (frame < 9) { if (rolls.get(rollIndex) == 10) {  2); rollIndex++; } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) { score += 10 + rolls.get(rollIndex + 2); rollIndex += 2; } else { score += rolls.get(rollIndex) + rolls.get(rollIndex + 1); rollIndex +=  score  rollIndex += 3; } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) { score += rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2); rollIndex += 3; } else { score += rolls.get(rollIndex) + rolls.get(rollIndex + 1); rollIndex += 2; } } } return score; } }"], "perturbed_original": ["import java.util.*; import java.lang.*; import java.math.*; public class Main { Scanner sc = new Scanner(System.in); class score implements Comparable<score> { String id; int s;  int x1 = 0; int x2 = 0; int c = 0; int q = 0;  if(f == 9 && e == 1 && c==3){ break; } if(f == 9 && e == 0 && c==2){ break; } int v = sc.nextInt(); if (x1 > 0) { x1--; s+=v; } if (x2 > 0) { x2--; x1++; s+=v; } s+=v; // System.out.println(s); if (f == 9) { if(c==0){ if(v==10){ e=1; } q=v; c++; }else if(c== 1 && q+v==10){ e=1; c++; }else{ c++; } } else if (v  f++; } else if (q + v == 10) { x1 += 1; c = 0; q=0; f++; } else if (c == 1) { c =  int a; a = arg0.s - s; if (a == 0)  run() { for (;;) { int n = sc.nextInt(); if (n == 0) { break; } score[] c = new score[n]; for(int i =0;i<n;i++){ //  ; i < n;i++){ System.out.println(c[i].id+\" \"+c[i].s); } } } public static void main(String[] args) { Main m = new Main(); m.run(); } }"], "original_ll": -0.8920667171478271, "sampled_ll": -0.3418894112110138, "all_perturbed_sampled_ll": [-0.9276169538497925], "all_perturbed_original_ll": [-1.6666420698165894], "perturbed_sampled_ll": -0.9276169538497925, "perturbed_original_ll": -1.6666420698165894, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f1():\n    frame = 1\n    total = 0\n    i = 0\n    while frame < 10:\n        if score[i] == 10:\n            total += (score[i] + score[i+1] + score[i+2])\n            i += 1\n        elif score[i] + score[i+1] == 10:\n            total += (score[i] + score[i+1] + score[i+2])\n            i += 2\n        else:\n            total += (score[i] + score[i+1])\n            i += 2\n        frame += 1\n    else:\n        total += sum(score[i:])\n        res[sn] = total\n\ndef f2():\n    for k, v in sorted(res.items(), key=lambda x: (x[1], x[0]), reverse=True):\n        print -k, v\n\nwhile True:\n    n = input()\n    if n == 0: break\n    res = {}\n    for i in range(n):\n        L = map(int, raw_input().split())\n        sn = -L[0]\n        score = L[1:]\n        f1()\n    else:\n        f2()", "sampled": "def calculate_bowling_score(pins):\n    score = 0\n    pin_idx = 0\n    \n    for frame in range(10):\n        if frame < 9:  # Frames 1-9\n            if pins[pin_idx] == 10:  # Strike\n                score += 10 + pins[pin_idx + 1] + pins[pin_idx + 2]\n                pin_idx += 1\n            elif pins[pin_idx] + pins[pin_idx + 1] == 10:  # Spare\n                score += 10 + pins[pin_idx + 2]\n                pin_idx += 2\n            else:  # Regular\n                score += pins[pin_idx] + pins[pin_idx + 1]\n                pin_idx += 2\n        else:  # Frame 10\n            score += pins[pin_idx] + pins[pin_idx + 1] + pins[pin_idx + 2]\n            pin_idx += 3\n    \n    return score\n\nwhile True:\n    m = int(input())\n    if m == 0:\n        break\n    \n    results = []\n    for _ in range(m):\n        data = list(map(int, input().split()))\n        student_id = data[0]\n        pins = data[1:]\n        score = calculate_bowling_score(pins)\n        results.append((student_id, score))\n    \n    # Sort by score (descending), then by student_id (ascending)\n    results.sort(key=lambda x: (-x[1], x[0]))\n    \n    for student_id, score in results:\n        print(f\"{student_id} {score}\")\n", "perturbed_sampled": ["def calculate_bowling_score(pins): score =  < 9: # Frames 1-9 if pins[pin_idx] == 10: # Strike score += 10 + pins[pin_idx + 1] + pins[pin_idx + 2] pin_idx += 1 elif pins[pin_idx] + pins[pin_idx + 1] == 10: # Spare score += 10 + pins[pin_idx +  Frame 10 score += pins[pin_idx] + pins[pin_idx + 1] + pins[pin_idx + 2] pin_idx += 3 return score while True: m = int(input()) if m == 0: break results = [] for _ in range(m): data = list(map(int, input().split())) student_id = data[0] pins = data[1:] score =  student_id (ascending) results.sort(key=lambda x: (-x[1], x[0])) for student_id, score in results: print(f\"{student_id} {score}\")"], "perturbed_original": ["def f1(): frame = 1 total  score[i] == 10: total += (score[i] + score[i+1] + score[i+2]) i += 1 elif score[i] + score[i+1] == 10: total += (score[i] + score[i+1] + score[i+2]) i += 2 else: total += (score[i] + score[i+1]) i += 2 frame += 1 else: total +=  sorted(res.items(), key=lambda x: (x[1], x[0]), reverse=True): print -k, v while True: n = input() if n ==  = map(int, raw_input().split()) sn = -L[0] score = L[1:] f1() else: f2()"], "original_ll": -1.0330616235733032, "sampled_ll": -0.6169936656951904, "all_perturbed_sampled_ll": [-1.6054660081863403], "all_perturbed_original_ll": [-1.9464707374572754], "perturbed_sampled_ll": -1.6054660081863403, "perturbed_original_ll": -1.9464707374572754, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0153: Triangle and Circle\n// 2017.8.12 bal4u@uu\n\n#include <stdio.h>\n\nlong long x[10], y[10];\nlong long xe, ye, r;\n\nint atSameSide(long long x1, long long y1, long long x2, long long y2,\n\tlong long xa, long long ya, long long xb, long long yb)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n\treturn (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0);\n}\n\nint between(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n\tsb = (x1 - x2) * (x - x2) + (y1 - y2) * (y - y2);\n\treturn (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0);\n}\n\nint disCmp(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y, long long r)\n{\n\tlong long a, b, c, t;\t\t\t/* ax + by + c = 0 */\n\tlong long squ;\n\ta = y1 - y2, b = x2 - x1, c = y2*x1-x2*y1;\n\tsqu = a*a + b*b;\n\tif (squ == 0) return 0;\n\tt = (a * x) + (b * y) + c;\n\tt = t*t - r*r*squ;\n\tif (t > 0) return 1;\n\tif (t < 0) return -1;\n\treturn 0;\n}\n\nint main()\n{\n\tint i, f;\n\tlong long d[3], rr;\n\n\twhile (1) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tscanf(\"%lld%lld\", x + i, y + i);\n\t\t\tif (!i && !x[0] && !y[0]) return 0;\n\t\t\tx[i + 3] = x[i], y[i + 3] = y[i];\n\t\t}\n\t\tscanf(\"%lld%lld%lld\", &xe, &ye, &r); rr = r*r;\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = (x[i] - xe)*(x[i] - xe) + (y[i] - ye)*(y[i] - ye);\n\t\tif (rr >= d[0] && rr >= d[1] && rr >= d[2]) { puts(\"b\"); continue; }\n\t\tif (rr >= d[0] || rr >= d[1] || rr >= d[2]) { puts(\"c\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tf = atSameSide(x[i], y[i], x[i + 1], y[i + 1],\n\t\t\t\tx[i + 2], y[i + 2], xe, ye);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = disCmp(x[i], y[i], x[i + 1], y[i + 1], xe, ye, r);\n\t\tif (f) { puts(d[0] >= 0 && d[1] >= 0 && d[2] >= 0 ? \"a\" : \"c\"); continue; }\n\t\tif (d[0] > 0 && d[1] > 0 && d[2] > 0) { puts(\"d\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tif (between(x[i], y[i], x[i + 1], y[i + 1], xe, ye) && d[i] <= 0) f = 0;\n\t\tputs(f ? \"d\" : \"c\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble dist(Point a, Point b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\ndouble dot(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y);\n}\n\ndouble cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble distPointToSegment(Point p, Point a, Point b) {\n    if (dot(a, b, p) < -EPS) return dist(p, a);\n    if (dot(b, a, p) < -EPS) return dist(p, b);\n    return fabs(cross(a, b, p)) / dist(a, b);\n}\n\nint pointInTriangle(Point p, Point t1, Point t2, Point t3) {\n    double c1 = cross(t1, t2, p);\n    double c2 = cross(t2, t3, p);\n    double c3 = cross(t3, t1, p);\n    \n    if (c1 >= -EPS && c2 >= -EPS && c3 >= -EPS) return 1;\n    if (c1 <= EPS && c2 <= EPS && c3 <= EPS) return 1;\n    return 0;\n}\n\nint main() {\n    int x1, y1, x2, y2, x3, y3, xc, yc, r;\n    \n    while (1) {\n        scanf(\"%d %d\", &x1, &y1);\n        if (x1 == 0 && y1 == 0) break;\n        scanf(\"%d %d\", &x2, &y2);\n        scanf(\"%d %d\", &x3, &y3);\n        scanf(\"%d %d\", &xc, &yc);\n        scanf(\"%d\", &r);\n        \n        Point t1 = {x1, y1};\n        Point t2 = {x2, y2};\n        Point t3 = {x3, y3};\n        Point c = {xc, yc};\n        \n        // Check if circle is inside triangle\n        int circleInTriangle = 1;\n        if (!pointInTriangle(c, t1, t2, t3)) {\n            circleInTriangle = 0;\n        } else {\n            double d1 = distPointToSegment(c, t1, t2);\n            double d2 = distPointToSegment(c, t2, t3);\n            double d3 = distPointToSegment(c, t3, t1);\n            if (d1 < r - EPS || d2 < r - EPS || d3 < r - EPS) {\n                circleInTriangle = 0;\n            }\n        }\n        \n        // Check if triangle is inside circle\n        int triangleInCircle = 1;\n        if (dist(c, t1) > r + EPS || dist(c, t2) > r + EPS || dist(c, t3) > r + EPS) {\n            triangleInCircle = 0;\n        }\n        \n        // Check if they intersect\n        int intersect = 0;\n        double d1 = distPointToSegment(c, t1, t2);\n        double d2 = distPointToSegment(c, t2, t3);\n        double d3 = distPointToSegment(c, t3, t1);\n        \n        if (d1 <= r + EPS || d2 <= r + EPS || d3 <= r + EPS) {\n            if (pointInTriangle(c, t1, t2, t3) || \n                dist(c, t1) <= r + EPS || \n                dist(c, t2) <= r + EPS || \n                dist(c, t3) <= r + EPS) {\n                intersect = 1;\n            }\n        }\n        \n        if (circleInTriangle) {\n            printf(\"a\\n\");\n        } else if (triangleInCircle) {\n            printf(\"b\\n\");\n        } else if (intersect) {\n            printf(\"c\\n\");\n        } else {\n            printf(\"d\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h>  Point; double dist(Point a, Point b) { double dx = a.x - b.x; double dy = a.y - b.y; return sqrt(dx * dx +  a.x) + (b.y - a.y) * (c.y - a.y); } double cross(Point a, Point b, Point c) { return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x); } double distPointToSegment(Point p, Point a, Point b) { if (dot(a, b, p) < -EPS) return dist(p, a); if (dot(b, a, p) < -EPS) return dist(p, b); return fabs(cross(a, b, p)) / dist(a, b); } int pointInTriangle(Point p, Point t1, Point t2, Point t3) { double c1 = cross(t1, t2, p); double c2 = cross(t2, t3, p); double c3 = cross(t3, t1, p); if (c1 >= -EPS && c2 >= -EPS && c3 >= -EPS) return 1; if (c1 <= EPS && c2 <= EPS && c3 <= EPS)  y1, x2, y2, x3, y3, xc, yc,  == 0 && y1 == 0) break; scanf(\"%d %d\", &x2, &y2); scanf(\"%d %d\", &x3, &y3); scanf(\"%d %d\", &xc, &yc); scanf(\"%d\", &r); Point t1 = {x1,  y3}; Point c = {xc, yc}; // Check  (!pointInTriangle(c, t1, t2, t3)) { circleInTriangle  t2); double d2 = distPointToSegment(c, t2, t3); double d3 = distPointToSegment(c, t3, t1); if (d1 < r - EPS || d2 < r - EPS || d3 < r - EPS)  is inside circle int triangleInCircle = 1; if (dist(c, t1) > r + EPS || dist(c, t2) > r + EPS || dist(c, t3) > r + EPS) { triangleInCircle = 0; } // Check  distPointToSegment(c, t1, t2); double d2 = distPointToSegment(c, t2, t3); double d3 = distPointToSegment(c, t3, t1); if (d1 <= r + EPS || d2  { if (pointInTriangle(c, t1, t2, t3) || dist(c, t1) <= r +  t3) <= r +  printf(\"a\\n\"); } else if (triangleInCircle) { printf(\"b\\n\"); } else if (intersect) { printf(\"c\\n\"); } else { printf(\"d\\n\"); } } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0153: Triangle and Circle // 2017.8.12 bal4u@uu #include <stdio.h> long long x[10], y[10]; long long xe, ye, r; int atSameSide(long long  long long xa, long long ya,  sb; sa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa); sb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb); return (sa >= 0 && sb >= 0) || (sa <   long x,  (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1); sb = (x1 - x2) * (x - x2) + (y1 - y2) * (y - y2); return (sa >= 0  x, long long y, long long r) { long long a, b, c, t; /* ax + by + c =  b = x2 - x1, c = y2*x1-x2*y1; squ = a*a + b*b; if (squ == 0) return 0; t = (a * x) + (b *  -1; return 0; } int main() { int i, f; long long d[3], rr; while (1) { for (i = 0; i < 3; i++) { scanf(\"%lld%lld\", x + i, y + i); if (!i && !x[0] && !y[0]) return 0; x[i + 3] = x[i], y[i + 3] = y[i]; } scanf(\"%lld%lld%lld\", &xe, &ye, &r); rr = r*r; for (i = 0; i < 3; i++)  ye)*(y[i] - ye); if (rr >= d[0] && rr >= d[1] && rr >= d[2]) { puts(\"b\"); continue; } if (rr >= d[0] || rr >= d[1]  3; i++) f = atSameSide(x[i], y[i], x[i + 1], y[i + 1], x[i + 2], y[i + 2], xe, ye); for (i = 0; i < 3; i++) d[i] = disCmp(x[i], y[i], x[i + 1], y[i + 1], xe, ye, r); if (f) { puts(d[0] >= 0 && d[1] >= 0 && d[2] >=  0 && d[1] > 0 && d[2] > 0) { puts(\"d\"); continue; } for (f = 1, i = 0; f && i < 3; i++) if (between(x[i], y[i], x[i + 1], y[i + 1], xe, ye) && d[i] <= 0) f = 0; puts(f ? \"d\" : \"c\"); } return 0; }"], "original_ll": -0.7878744602203369, "sampled_ll": -0.39695581793785095, "all_perturbed_sampled_ll": [-1.059859037399292], "all_perturbed_original_ll": [-1.4684034585952759], "perturbed_sampled_ll": -1.059859037399292, "perturbed_original_ll": -1.4684034585952759, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c1\u306e\u9802\u70b9\u306e\u5ea7\u6a19x1 y1\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 2\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c2\u306e\u9802\u70b9\u306e\u5ea7\u6a19x2 y2\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 3\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c3\u306e\u9802\u70b9\u306e\u5ea7\u6a19x3 y3\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 4\u884c\u76ee \u5186\u306e\u4e2d\u5fc3\u306e\u5ea7\u6a19x4 y4\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 5\u884c\u76ee \u5186\u306e\u534a\u5f84r\uff08\u6574\u6570\uff09\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tif (r * r >= max) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(Line.distanceSP(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line(\n\t\t\t\t\t\tps[i], ps[(i + 1) % 3]), ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble ep = new Line(ps[i], ps[(i + 1) % 3]).ep(new Line(ps[i],\n\t\t\t\t\t\tps[3]));\n\t\t\t\tif (ep < 0)\n\t\t\t\t\tleft = false;\n\t\t\t\telse if (ep > 0)\n\t\t\t\t\tright = false;\n\t\t\t}\n\t\t\tboolean in = left | right;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n\t}\n}\n\n// Output\n//\n// \u5165\u529b\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3054\u3068\u306b\u4ee5\u4e0b\u306e\u5224\u5b9a\u7d50\u679c\u3092\u51fa\u529b\u3057\u307e\u3059\u3002\n//\n// \u5186\u304c\u4e09\u89d2\u5f62\u306b\u542b\u307e\u308c\u308b\u5834\u5408 a\n// \u4e09\u89d2\u5f62\u304c\u5186\u306b\u542b\u307e\u308c\u308b\u5834\u5408 b\n// \u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u3067\u3001\u5171\u901a\u90e8\u5206\u304c\u3042\u308b\u5834\u5408\u306b\u306f c\n// \u5171\u901a\u90e8\u5206\u304c\u306a\u3044\u5834\u5408\u306b\u306f d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic static double distanceSP(Line s, Point2D.Double p) {\n\t\tPoint2D.Double r = proj(s, p);\n\t\tif (intersectSP(s, r))\n\t\t\treturn norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p)));\n\t}\n\n\tpublic static boolean intersectSP(Line s, Point2D.Double p) {\n\t\treturn ccw(s.p1, s.p2, p) == 0;\n\t}\n\n\tpublic static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n\t\tPoint2D.Double p = sub(b, a);\n\t\tPoint2D.Double q = sub(c, a);\n\t\tif (extp(p, q) > EPS)\n\t\t\treturn 1; // counter clockwise\n\t\tif (extp(p, q) < -EPS)\n\t\t\treturn -1; // clockwise\n\t\tif (inp(p, q) < -EPS)\n\t\t\treturn 2; // c--a--b on line\n\t\tif (Math.abs(norm(p) - norm(q)) < EPS)\n\t\t\treturn -2; // a--b--c on line\n\t\treturn 0; // a--c--b(or a--c=b) on line\n\t}\n\n\tpublic static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn new Point2D.Double(p1.x - p2.x, p1.y - p2.y);\n\t}\n\n\tpublic static Point2D.Double proj(Line l, Point2D.Double p) {\n\t\tdouble t = inp(sub(p, l.p1), sub(l.p1, l.p2))\n\t\t\t\t/ Math.pow(norm(sub(l.p1, l.p2)), 2);\n\t\tPoint2D.Double tp = sub(l.p1, l.p2);\n\t\treturn new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);\n\t}\n\n\tpublic static double inp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\tpublic static double extp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tpublic static final double EPS = 1.0e-8;\n\n\tpublic static double norm(Point2D.Double p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final double EPS = 1e-9;\n    \n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n        Point sub(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n        Point mul(double t) {\n            return new Point(x * t, y * t);\n        }\n        double dot(Point p) {\n            return x * p.x + y * p.y;\n        }\n        double cross(Point p) {\n            return x * p.y - y * p.x;\n        }\n        double norm() {\n            return Math.sqrt(x * x + y * y);\n        }\n    }\n    \n    static double distancePointToSegment(Point p, Point a, Point b) {\n        if (a.sub(b).norm() < EPS) return a.sub(p).norm();\n        Point ab = b.sub(a);\n        Point ap = p.sub(a);\n        double t = ap.dot(ab) / ab.dot(ab);\n        if (t < 0) return ap.norm();\n        if (t > 1) return p.sub(b).norm();\n        Point projection = a.add(ab.mul(t));\n        return p.sub(projection).norm();\n    }\n    \n    static boolean isPointInTriangle(Point p, Point a, Point b, Point c) {\n        double d1 = b.sub(a).cross(p.sub(a));\n        double d2 = c.sub(b).cross(p.sub(b));\n        double d3 = a.sub(c).cross(p.sub(c));\n        \n        boolean hasNeg = (d1 < -EPS) || (d2 < -EPS) || (d3 < -EPS);\n        boolean hasPos = (d1 > EPS) || (d2 > EPS) || (d3 > EPS);\n        \n        return !(hasNeg && hasPos);\n    }\n    \n    static boolean circleInTriangle(Point c, double r, Point a, Point b, Point p) {\n        if (!isPointInTriangle(c, a, b, p)) return false;\n        \n        double d1 = distancePointToSegment(c, a, b);\n        double d2 = distancePointToSegment(c, b, p);\n        double d3 = distancePointToSegment(c, p, a);\n        \n        return d1 >= r - EPS && d2 >= r - EPS && d3 >= r - EPS;\n    }\n    \n    static boolean triangleInCircle(Point c, double r, Point a, Point b, Point p) {\n        double d1 = c.sub(a).norm();\n        double d2 = c.sub(b).norm();\n        double d3 = c.sub(p).norm();\n        \n        return d1 <= r + EPS && d2 <= r + EPS && d3 <= r + EPS;\n    }\n    \n    static boolean circleSegmentIntersect(Point c, double r, Point a, Point b) {\n        double dist = distancePointToSegment(c, a, b);\n        return dist <= r + EPS;\n    }\n    \n    static boolean hasIntersection(Point c, double r, Point a, Point b, Point p) {\n        if (circleSegmentIntersect(c, r, a, b)) return true;\n        if (circleSegmentIntersect(c, r, b, p)) return true;\n        if (circleSegmentIntersect(c, r, p, a)) return true;\n        \n        if (isPointInTriangle(c, a, b, p)) return true;\n        \n        return false;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] tokens = line.trim().split(\"\\\\s+\");\n            if (tokens.length == 2 && tokens[0].equals(\"0\") && tokens[1].equals(\"0\")) {\n                break;\n            }\n            \n            Point p1 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            Point p2 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            Point p3 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            Point center = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            double radius = Double.parseDouble(tokens[0]);\n            \n            if (circleInTriangle(center, radius, p1, p2, p3)) {\n                System.out.println(\"a\");\n            } else if (triangleInCircle(center, radius, p1, p2, p3)) {\n                System.out.println(\"b\");\n            } else if (hasIntersection(center, radius, p1, p2, p3)) {\n                System.out.println(\"c\");\n            } else {\n                System.out.println(\"d\");\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static final double EPS = 1e-9; static class Point { double x, y; Point(double  } Point sub(Point p) { return new Point(x - p.x, y - p.y); } Point add(Point p) { return new Point(x + p.x, y + p.y); } Point mul(double t) { return new Point(x * t, y * t); } double dot(Point p) { return x * p.x + y * p.y; } double cross(Point p) { return x * p.y - y * p.x; } double norm() { return Math.sqrt(x * x + y * y); } } static double distancePointToSegment(Point p, Point a, Point b)  b.sub(a); Point ap = p.sub(a); double t = ap.dot(ab)  b, Point c) { double d1 =  || (d3 < -EPS); boolean hasPos = (d1 >  !(hasNeg && hasPos); } static boolean circleInTriangle(Point c,  (!isPointInTriangle(c, a, b, p)) return false; double d1 = distancePointToSegment(c, a, b); double d2 = distancePointToSegment(c, b, p); double d3 = distancePointToSegment(c, p, a); return d1 >= r - EPS && d2 >= r - EPS  c, double r, Point a, Point b, Point p) { double d1 = c.sub(a).norm();  <= r + EPS && d2 <= r + EPS && d3 <= r + EPS; } static boolean circleSegmentIntersect(Point c, double r, Point a, Point b)  r + EPS; } static boolean hasIntersection(Point c, double r, Point a, Point b, Point p) { if (circleSegmentIntersect(c, r, a, b)) return true; if (circleSegmentIntersect(c, r, b, p)) return true; if (circleSegmentIntersect(c, r, p, a)) return true; if (isPointInTriangle(c, a, b, p)) return true; return false; } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] tokens = line.trim().split(\"\\\\s+\"); if (tokens.length == 2 && tokens[0].equals(\"0\") && tokens[1].equals(\"0\")) { break; } Point p1 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1])); tokens = br.readLine().trim().split(\"\\\\s+\"); Point p2 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1])); tokens = br.readLine().trim().split(\"\\\\s+\"); Point p3 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1])); tokens = br.readLine().trim().split(\"\\\\s+\"); Point  = Double.parseDouble(tokens[0]); if (circleInTriangle(center, radius, p1, p2, p3)) { System.out.println(\"a\"); } else if (triangleInCircle(center, radius, p1, p2, p3)) {  System.out.println(\"c\"); } else { System.out.println(\"d\"); } } } }"], "perturbed_original": ["import  main(String[] args) throws Exception { Scanner sc = new Scanner(System.in); sc.useDelimiter(\",|\\\\s+\"); while (true) { int x1 = sc.nextInt(); int y1 = sc.nextInt(); if  int y2 = sc.nextInt(); int x3 = sc.nextInt(); int y3 = sc.nextInt(); int x4 = sc.nextInt(); int y4 = sc.nextInt(); int r = sc.nextInt(); // 1\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c1\u306e\u9802\u70b9\u306e\u5ea7\u6a19x1 y1\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09 // 2\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c2\u306e\u9802\u70b9\u306e\u5ea7\u6a19x2 y2\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09 //  5\u884c\u76ee \u5186\u306e\u534a\u5f84r\uff08\u6574\u6570\uff09 // Point2D.Double[] ps = new Point2D.Double[4]; ps[0] = new Point2D.Double(x1, y1); ps[1] = new Point2D.Double(x2, y2); ps[2] =  =  { max = Math.max(max,  dis = Math.max(Line.distanceSP(new Line(ps[i], ps[(i + 1)  3]), ps[3])); min = Math.min(min, dis); } boolean right = true; boolean left = true; for (int i = 0; i < 3; i++) { double ep = new Line(ps[i], ps[(i + 1) % 3]).ep(new Line(ps[i], ps[3])); if (ep < 0) left = false; else if (ep >  right; if (r <= min && in) System.out.println(\"a\"); else if (!in && r < min) System.out.println(\"d\"); else System.out.println(\"c\"); } } public static double nor(Point2D.Double p, Point2D.Double q) { return (p.x  * (p.y - q.y); } } // Output // // \u5165\u529b\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3054\u3068\u306b\u4ee5\u4e0b\u306e\u5224\u5b9a\u7d50\u679c\u3092\u51fa\u529b\u3057\u307e\u3059\u3002 // // \u5186\u304c\u4e09\u89d2\u5f62\u306b\u542b\u307e\u308c\u308b\u5834\u5408 a // \u4e09\u89d2\u5f62\u304c\u5186\u306b\u542b\u307e\u308c\u308b\u5834\u5408 b // \u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u3067\u3001\u5171\u901a\u90e8\u5206\u304c\u3042\u308b\u5834\u5408\u306b\u306f c // \u5171\u901a\u90e8\u5206\u304c\u306a\u3044\u5834\u5408\u306b\u306f d class Line { public Point2D.Double p1; public Point2D.Double p2; Line(Point2D.Double p1, Point2D.Double p2)  length() { return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y)); } public double ip(Line l) { Point2D.Double q1 = l.p1; Point2D.Double q2 = l.p2; return (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y); } public double ep(Line l) { Point2D.Double q1 = l.p1; Point2D.Double q2 = l.p2; return (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x); } public static double distanceSP(Line s, Point2D.Double p) { Point2D.Double r = proj(s, p); if (intersectSP(s, r)) return norm(sub(r, p)); return Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p))); } public static boolean intersectSP(Line s, Point2D.Double p) { return ccw(s.p1, s.p2, p) == 0; } public static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) { Point2D.Double p = sub(b, a); Point2D.Double q = sub(c,  clockwise if (inp(p, q) < -EPS) return 2; // c--a--b on line if (Math.abs(norm(p) - norm(q)) < EPS) return -2; // a--b--c on line return 0; // a--c--b(or a--c=b) on line } public static Point2D.Double sub(Point2D.Double p1, Point2D.Double  } public static  l.p1), sub(l.p1, l.p2)) / Math.pow(norm(sub(l.p1, l.p2)), 2); Point2D.Double tp = sub(l.p1, l.p2); return new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y); } public static double inp(Point2D.Double p1, Point2D.Double p2) { return p1.x  extp(Point2D.Double p1, Point2D.Double  } public static final double EPS = 1.0e-8;  public double disToPoint(Point2D.Double q1) { Line p1q1 = new Line(p1, q1); double ip1 = p1q1.ip(this); double ip2 = this.ip(this); if (ip1 <= 0) return p1q1.length();  double d2 = ip1 / this.length(); double size = p1q1.length(); return Math.sqrt(size * size - d2 * d2); } else { Line p2q1 = new Line(p2, q1); return  = q1q2.p1; Point2D.Double q2 = q1q2.p2; Line p1q1 = new Line(p1, q1); Line p1q2 = new Line(p1, q2); Line q1p1 = new Line(q1, p1); Line q1p2 = new Line(q1, p2);  < 0) return true; else return false; } public double  Double.MAX_VALUE; Point2D.Double q1 = q1q2.p1; Point2D.Double q2 = q1q2.p2; ans = Math.min(ans, this.disToPoint(q1)); ans = Math.min(ans, this.disToPoint(q2)); ans = Math.min(ans, q1q2.disToPoint(p1)); ans = Math.min(ans, q1q2.disToPoint(p2)); return ans; } public String toString() { return p1 + \"=>\" + p2; } }"], "original_ll": -0.7610049247741699, "sampled_ll": -0.36770009994506836, "all_perturbed_sampled_ll": [-0.936602771282196], "all_perturbed_original_ll": [-1.3130826950073242], "perturbed_sampled_ll": -0.936602771282196, "perturbed_original_ll": -1.3130826950073242, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def In(): return map(int,raw_input().split())\ndef D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5\ndef side(a, b, c): return (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])>0\ndef isIn(x,p0,p1,p2): return (side(p0,p1,x)==side(p1,p2,x)==side(p2,p0,x))\ndef S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0\ndef H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3)\ndef CinT(P4,r,P1,P2,P3):\n  f1 = isIn(P4,P1,P2,P3)\n  f = [H(P4,P1,P2)>=r, H(P4,P2,P3)>=r, H(P4,P3,P1)>=r]\n  if f1:\n    if all(f): return 1\n    elif any(f): return 3\n  return 0\n\ndef TinC(P4,r,P1,P2,P3):\n  f = [D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r]\n  if all(f): return 2\n  elif any(f): return 3\n  return 0\n  \nwhile 1:\n  P1 = In()\n  if P1[0]==P1[1]==0: break\n  P2 = In()\n  P3 = In()\n  P4 = In()\n  r = int(raw_input())\n  f = CinT(P4,r,P1,P2,P3)\n  if not f: f = TinC(P4,r,P1,P2,P3)\n  print 'dabc'[f]", "sampled": "import sys\nfrom math import sqrt\n\ndef read_input():\n    datasets = []\n    lines = sys.stdin.read().strip().split('\\n')\n    i = 0\n    while i < len(lines):\n        parts = lines[i].split()\n        if len(parts) == 2 and parts[0] == '0' and parts[1] == '0':\n            break\n        \n        # Read 3 triangle vertices\n        x1, y1 = map(int, lines[i].split())\n        x2, y2 = map(int, lines[i+1].split())\n        x3, y3 = map(int, lines[i+2].split())\n        \n        # Read circle center and radius\n        xc, yc = map(int, lines[i+3].split())\n        r = int(lines[i+4])\n        \n        datasets.append(((x1, y1), (x2, y2), (x3, y3), (xc, yc), r))\n        i += 5\n    \n    return datasets\n\ndef distance(p1, p2):\n    return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef point_to_segment_distance(p, a, b):\n    ax, ay = a\n    bx, by = b\n    px, py = p\n    \n    abx = bx - ax\n    aby = by - ay\n    apx = px - ax\n    apy = py - ay\n    \n    ab_ab = abx * abx + aby * aby\n    if ab_ab == 0:\n        return distance(p, a)\n    \n    ap_ab = apx * abx + apy * aby\n    t = max(0, min(1, ap_ab / ab_ab))\n    \n    closest_x = ax + t * abx\n    closest_y = ay + t * aby\n    \n    return distance(p, (closest_x, closest_y))\n\ndef point_in_triangle(p, v1, v2, v3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    \n    d1 = sign(p, v1, v2)\n    d2 = sign(p, v2, v3)\n    d3 = sign(p, v3, v1)\n    \n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    \n    return not (has_neg and has_pos)\n\ndef circle_in_triangle(v1, v2, v3, center, r):\n    # Check if center is in triangle\n    if not point_in_triangle(center, v1, v2, v3):\n        return False\n    \n    # Check distance from center to all edges\n    d1 = point_to_segment_distance(center, v1, v2)\n    d2 = point_to_segment_distance(center, v2, v3)\n    d3 = point_to_segment_distance(center, v3, v1)\n    \n    return d1 >= r and d2 >= r and d3 >= r\n\ndef triangle_in_circle(v1, v2, v3, center, r):\n    d1 = distance(center, v1)\n    d2 = distance(center, v2)\n    d3 = distance(center, v3)\n    \n    return d1 <= r and d2 <= r and d3 <= r\n\ndef circle_triangle_intersect(v1, v2, v3, center, r):\n    # Check if any vertex is inside or on the circle\n    for v in [v1, v2, v3]:\n        if distance(center, v) <= r:\n            return True\n    \n    # Check if center is inside triangle\n    if point_in_triangle(center, v1, v2, v3):\n        return True\n    \n    # Check if any edge intersects the circle\n    for a, b in [(v1, v2), (v2, v3), (v3, v1)]:\n        if point_to_segment_distance(center, a, b) <= r:\n            return True\n    \n    return False\n\ndef solve(v1, v2, v3, center, r):\n    if circle_in_triangle(v1, v2, v3, center, r):\n        return 'a'\n    elif triangle_in_circle(v1, v2, v3, center, r):\n        return 'b'\n    elif circle_triangle_intersect(v1, v2, v3, center, r):\n        return 'c'\n    else:\n        return 'd'\n\ndatasets = read_input()\nfor v1, v2, v3, center, r in datasets:\n    print(solve(v1, v2, v3, center, r))\n", "perturbed_sampled": ["import sys from math import sqrt def read_input(): datasets = [] lines = sys.stdin.read().strip().split('\\n') i = 0 while i < len(lines): parts = lines[i].split() if len(parts) == 2 and parts[0] == '0' and parts[1] == '0': break # Read 3 triangle vertices x1, y1 = map(int,  lines[i+2].split()) # Read circle center and radius xc, yc = map(int, lines[i+3].split()) r = int(lines[i+4]) datasets.append(((x1, y1), (x2, y2), (x3, y3), (xc, yc), r)) i += 5 return datasets def  def point_to_segment_distance(p, a, b): ax, ay = a bx, by =  ax apy = py - ay ab_ab = abx * abx + aby * aby if ab_ab == 0: return distance(p, a) ap_ab = apx * abx + apy * aby t = max(0, min(1, ap_ab / ab_ab)) closest_x = ax + t * abx closest_y = ay + t  v3): def sign(p1, p2, p3): return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) *  (d3 < 0) has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0) return not (has_neg and has_pos) def circle_in_triangle(v1, v2, v3, center, r):  v1, v2, v3): return False # Check distance from center to all edges d1 = point_to_segment_distance(center, v1, v2) d2 = point_to_segment_distance(center, v2,  and d2 >= r  d1 = distance(center, v1) d2 = distance(center, v2) d3 = distance(center, v3) return d1 <= r and d2 <= r and d3 <= r def circle_triangle_intersect(v1, v2, v3, center, r): # Check if any vertex is inside or on the circle for v in [v1, v2, v3]: if distance(center, v) <= r: return True # Check if center is inside triangle if point_in_triangle(center, v1, v2, v3): return True  b in [(v1, v2), (v2, v3), (v3, v1)]: if point_to_segment_distance(center, a, b) <= r: return  circle_in_triangle(v1, v2, v3, center, r): return 'a' elif triangle_in_circle(v1, v2, v3, center, r): return 'b' elif circle_triangle_intersect(v1, v2, v3, center, r): return 'c' else: return 'd' datasets = read_input() for v1, v2, v3, center, r in datasets: print(solve(v1, v2, v3, center, r))"], "perturbed_original": ["def In(): return map(int,raw_input().split()) def D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5 def side(a, b, c): return (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])>0 def isIn(x,p0,p1,p2): return (side(p0,p1,x)==side(p1,p2,x)==side(p2,p0,x)) def S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0 def  [H(P4,P1,P2)>=r, H(P4,P2,P3)>=r, H(P4,P3,P1)>=r] if f1: if all(f): return 1 elif any(f): return 3 return 0 def TinC(P4,r,P1,P2,P3): f = [D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r] if all(f): return 2 elif any(f): return 3 return 0 while 1: P1 = In() if P1[0]==P1[1]==0: break P2 = In() P3 =  if not f: f = TinC(P4,r,P1,P2,P3) print 'dabc'[f]"], "original_ll": -1.0256099700927734, "sampled_ll": -0.4620826542377472, "all_perturbed_sampled_ll": [-1.2890461683273315], "all_perturbed_original_ll": [-1.4795622825622559], "perturbed_sampled_ll": -1.2890461683273315, "perturbed_original_ll": -1.4795622825622559, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint count;\nvoid solve(int depth, int card[][2], int n, int total, int goal) {\n\tint i;\n\tif(depth == n) {\n\t\tif(total == goal)\n\t\t\tcount++;\n\t\treturn;\n\t}\n\t\n\tfor(i=0;i<=card[depth][1];i++) {\n\t\tsolve(depth+1, card, n, total + card[depth][0] * i, goal);\n\t}\n}\n\nint main(void) {\n\tint n, g;\n\tint i;\n\tint goal;\n\tint j[1001];\n\tint card[1001][2];\n\twhile(1) {\n\t\tcount = 0;\n\t\tscanf(\"%d\\n\", &n);\n\t\tif(n==0) break;\n\t\tfor(i=0;i<n;i++) {\n\t\t\tscanf(\"%d %d\\n\", &card[i][0], &card[i][1]);\n\t\t}\n\t\tscanf(\"%d\\n\", &g);\n\t\tfor(i-0;i<g;i++) {\n\t\t\tscanf(\"%d\\n\", &goal);\n\t\t\tsolve(0, card, n, 0, goal);\t\n\t\t\tprintf(\"%d\\n\", count);\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint m, g;\nint a[7], b[7];\nint n;\nint count;\n\nvoid dfs(int idx, int sum) {\n    if (idx == m) {\n        if (sum == n) {\n            count++;\n        }\n        return;\n    }\n    \n    for (int i = 0; i <= b[idx]; i++) {\n        dfs(idx + 1, sum + i * a[idx]);\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &m);\n        if (m == 0) break;\n        \n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d\", &a[i], &b[i]);\n        }\n        \n        scanf(\"%d\", &g);\n        \n        for (int i = 0; i < g; i++) {\n            scanf(\"%d\", &n);\n            count = 0;\n            dfs(0, 0);\n            printf(\"%d\\n\", count);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int m, g; int a[7], b[7]; int n; int count; void dfs(int idx, int sum) { if (idx == m) { if (sum == n) {  <= b[idx]; i++) { dfs(idx + 1, sum + i *  &m); if (m == 0) break; for (int i  &b[i]); } scanf(\"%d\", &g); for (int i = 0; i < g; i++) { scanf(\"%d\", &n); count = 0; dfs(0, 0); printf(\"%d\\n\", count); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int count; void solve(int depth, int card[][2], int n, int total, int goal) { int i; if(depth == n) { <extra_id_4>count =<extra_id_5>j[12];<extra_id_6>(j[12], j[0],<extra_id_7>++<extra_id_8>+=<extra_id_9>++<extra_id_10>count; j[1]<extra_id_11>card n, total + card[depth][0] * i, goal); } } int main(void) { int n, g; int i; int goal; int j[1001]; int card[1001][2]; while(1) { count = 0; scanf(\"%d\\n\", &n); if(n==0) break; for(i=0;i<n;i++) { scanf(\"%d %d\\n\", &card[i][0], &card[i][1]); } scanf(\"%d\\n\", &g);  count); } } return 0; }"], "original_ll": -0.9316422939300537, "sampled_ll": -0.5729726552963257, "all_perturbed_sampled_ll": [-1.671979308128357], "all_perturbed_original_ll": [-1.90895676612854], "perturbed_sampled_ll": -1.671979308128357, "perturbed_original_ll": -1.90895676612854, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class AOJ_0154{\n    class Card{\n        int a;\n        int b;\n        Card(int a, int b){\n            this.a = a;\n            this.b = b;\n        }\n    }\n    void run(){\n        Scanner sc = new Scanner(System.in);\n        while(true){\n            int[] card_num = new int[101];\n            int m = sc.nextInt();\n            if(m==0){\n                break;\n            }\n            Card[] cards = new Card[m];\n            for(int i = 0; i < m; i++){\n                cards[i] = new Card(sc.nextInt(), sc.nextInt());\n            }\n            int ub = 7*100*10;\n            int[] dp = new int[ub];\n            dp[0] = 1;\n            for(int i = 0; i < m; i++){\n                for(int ii = 7 * 100 * 10 - cards[i].a -1; ii >= 0; ii--){\n                    for(int iii = 1; iii <= cards[i].b; iii++){\n                        if(ii + cards[i].a*iii < ub-1){\n                            dp[ii + cards[i].a*iii] += dp[ii];\n                        }\n                    }\n                }\n            }\n            /*\n              System.out.println(Arrays.toString(dp));\n              for(int i = 0; i < 100; i++){\n              System.out.println(i + \" : \" + dp[i]);\n              }\n            */\n            int g = sc.nextInt();\n            for(int i = 0; i < g; i++){\n                System.out.println(dp[sc.nextInt()]);\n            }\n        }\n    }\n    public static void main(String[] args){\n        new AOJ_0154().run();\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[] values;\n    static int[] counts;\n    static int m;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            m = sc.nextInt();\n            if (m == 0) break;\n            \n            values = new int[m];\n            counts = new int[m];\n            \n            for (int i = 0; i < m; i++) {\n                values[i] = sc.nextInt();\n                counts[i] = sc.nextInt();\n            }\n            \n            int g = sc.nextInt();\n            for (int i = 0; i < g; i++) {\n                int n = sc.nextInt();\n                int result = countCombinations(n);\n                System.out.println(result);\n            }\n        }\n        sc.close();\n    }\n    \n    static int countCombinations(int target) {\n        return dfs(0, target);\n    }\n    \n    static int dfs(int index, int remaining) {\n        if (remaining == 0) {\n            return 1;\n        }\n        if (remaining < 0 || index >= m) {\n            return 0;\n        }\n        \n        int total = 0;\n        for (int i = 0; i <= counts[index]; i++) {\n            int newRemaining = remaining - (i * values[index]);\n            if (newRemaining < 0) break;\n            total += dfs(index + 1, newRemaining);\n        }\n        \n        return total;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int[] values; static int[] counts; static int m; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { m = sc.nextInt(); if (m == 0) break; values = new int[m]; counts = new int[m]; for (int i = 0; i < m; i++) { values[i] = sc.nextInt(); counts[i] = sc.nextInt(); } int g = sc.nextInt(); for (int i = 0; i < g; i++) { int n = sc.nextInt(); int result = countCombinations(n); System.out.println(result); } } sc.close(); }  int dfs(int index, int remaining)  (remaining < 0 || index >= m) { return 0; } int total = 0;  (newRemaining < 0) break; total += dfs(index + 1, newRemaining); } return total; } }"], "perturbed_original": ["import java.util.*; public class AOJ_0154{ class Card{ int a; int b; Card(int a, int b){ this.a = a; this.b = b; } } void run(){ Scanner sc = new Scanner(System.in); while(true){  break; } Card[] cards = new Card[m]; for(int i = 0; i < m; i++){ cards[i] = new Card(sc.nextInt(), sc.nextInt());  dp[0] = 1; for(int i = 0; i < m; i++){  -1; ii >= 0; ii--){  cards[i].a*iii < ub-1){ dp[ii + cards[i].a*iii] += dp[ii]; } } } } /* System.out.println(Arrays.toString(dp)); for(int i = 0; i < 100; i++){ System.out.println(i + \" : \" + dp[i]); } */ int g = sc.nextInt(); for(int i = 0; i < g; i++){ System.out.println(dp[sc.nextInt()]); } } } public static void main(String[] args){ new AOJ_0154().run(); } }"], "original_ll": -0.8275666832923889, "sampled_ll": -0.5494576096534729, "all_perturbed_sampled_ll": [-1.1369837522506714], "all_perturbed_original_ll": [-1.3402777910232544], "perturbed_sampled_ll": -1.1369837522506714, "perturbed_original_ll": -1.3402777910232544, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfrom array import array\n\ndef main():\n\twhile True:\n\t\tm = input()\n\t\tif m == 0: return 0\n\t\tdp = [array('I', [0] * 1001) for i in range(m + 1)]\n\t\tdp[0][0] = 1\n\t\tfor i in xrange(m):\n\t\t\tv, c = map(int, raw_input().split())\n\t\t\tfor j in xrange(1001):\n\t\t\t\tfor k in xrange(c + 1):\n\t\t\t\t\tnext = j + v * k\n\t\t\t\t\tif next > 1000: continue\n\t\t\t\t\tdp[i + 1][next] += dp[i][j]\n\t\tn = input()\n\t\tfor i in range(n):\n\t\t\tx = input()\n\t\t\tprint dp[m][x]\n\nif __name__ == '__main__':\n\tsys.exit(main())", "sampled": "import sys\nfrom itertools import product\n\ndef count_combinations(cards, target):\n    count = 0\n    # Generate all possible combinations\n    ranges = [range(b + 1) for a, b in cards]\n    \n    for combination in product(*ranges):\n        total = sum(combination[i] * cards[i][0] for i in range(len(cards)))\n        if total == target:\n            count += 1\n    \n    return count\n\ndef main():\n    lines = []\n    for line in sys.stdin:\n        lines.append(line.strip())\n    \n    idx = 0\n    while idx < len(lines):\n        m = int(lines[idx])\n        if m == 0:\n            break\n        \n        idx += 1\n        cards = []\n        for _ in range(m):\n            a, b = map(int, lines[idx].split())\n            cards.append((a, b))\n            idx += 1\n        \n        g = int(lines[idx])\n        idx += 1\n        \n        for _ in range(g):\n            n = int(lines[idx])\n            idx += 1\n            result = count_combinations(cards, n)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from itertools import product def count_combinations(cards, target): count = 0 # Generate all possible combinations ranges = [range(b + 1) for a, b in cards] for  return count def main(): lines = [] for line in sys.stdin: lines.append(line.strip()) idx = 0 while idx < len(lines): m = int(lines[idx]) if  for _ in range(m): a, b = map(int, lines[idx].split()) cards.append((a, b)) idx += 1 g = int(lines[idx]) idx += 1 for _ in range(g): n = int(lines[idx]) idx += 1 result = count_combinations(cards, n) print(result) if __name__ == \"__main__\": main()"], "perturbed_original": ["import sys from array import array def main():  0 dp = [array('I', [0] * 1001) for i in range(m + 1)] dp[0][0] =  for j in xrange(1001): for k in xrange(c + 1): next = j + v * k if next > 1000: continue dp[i + 1][next] += dp[i][j] n = input() for i in range(n): x = input() print dp[m][x] if __name__ == '__main__': sys.exit(main())"], "original_ll": -0.9920486211776733, "sampled_ll": -0.8145204782485962, "all_perturbed_sampled_ll": [-1.537477731704712], "all_perturbed_original_ll": [-1.6692389249801636], "perturbed_sampled_ll": -1.537477731704712, "perturbed_original_ll": -1.6692389249801636, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "//from PKU1125\n#define M 101\ndouble dist[M][M],d;\nnext[M][M],x[M],y[M];\nmain(){\n\tint a,b,k,n,i,j;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\t/*initialize*/\n\t\tfor(i=1;i<=n;i++)scanf(\"%d\",&a),scanf(\"%d%d\",x+a,y+a);\n\t\tfor(i=1;i<=n;i++)for(j=1;j<=n;next[i][j]=j,j++)\n\t\t\tdist[i][j]=(d=hypot(x[i]-x[j],y[i]-y[j]))<50.1?d:999;\n\n\t\t{/*warshall-floyd*/\n\t\t\tint k,i,j;\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\t\tif(dist[i][j]>dist[i][k]+dist[k][j])\n\t\t\t\t\t\t\tdist[i][j]=dist[i][k]+dist[k][j],next[i][j]=next[i][k];\n\t\t\t\t\t}\n\t\t}\n\n\t\t{/*query*/\n\t\t\tfor(scanf(\"%d\",&k);k;k--){\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\tif(dist[a][b]>998)puts(\"NA\");\n\t\t\t\telse{\n\t\t\t\t\tfor(j=a;j!=b;j=next[j][b])printf(\"%d \",j);\n\t\t\t\t\tprintf(\"%d\\n\",b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}exit(0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#define MAX_N 101\n#define INF 1e9\n\ntypedef struct {\n    int id;\n    int x, y;\n} Building;\n\nBuilding buildings[MAX_N];\nint n;\ndouble dist[MAX_N][MAX_N];\nint next_node[MAX_N][MAX_N];\n\ndouble calc_dist(int i, int j) {\n    double dx = buildings[i].x - buildings[j].x;\n    double dy = buildings[i].y - buildings[j].y;\n    return sqrt(dx * dx + dy * dy);\n}\n\nvoid floyd_warshall() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                dist[i][j] = 0;\n                next_node[i][j] = -1;\n            } else {\n                double d = calc_dist(i, j);\n                if (d <= 50.0) {\n                    dist[i][j] = d;\n                    next_node[i][j] = j;\n                } else {\n                    dist[i][j] = INF;\n                    next_node[i][j] = -1;\n                }\n            }\n        }\n    }\n    \n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                    next_node[i][j] = next_node[i][k];\n                }\n            }\n        }\n    }\n}\n\nvoid print_path(int start, int end) {\n    if (dist[start][end] >= INF) {\n        printf(\"NA\\n\");\n        return;\n    }\n    \n    printf(\"%d\", buildings[start].id);\n    int current = start;\n    while (current != end) {\n        current = next_node[current][end];\n        printf(\" %d\", buildings[current].id);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %d\", &buildings[i].id, &buildings[i].x, &buildings[i].y);\n        }\n        \n        floyd_warshall();\n        \n        int m;\n        scanf(\"%d\", &m);\n        \n        for (int i = 0; i < m; i++) {\n            int s, g;\n            scanf(\"%d %d\", &s, &g);\n            \n            int si = -1, gi = -1;\n            for (int j = 0; j < n; j++) {\n                if (buildings[j].id == s) si = j;\n                if (buildings[j].id == g) gi = j;\n            }\n            \n            print_path(si, gi);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <math.h> #include <string.h> #define MAX_N 101 #define INF 1e9 typedef struct { int id; int x, y; } Building; Building buildings[MAX_N]; int n; double dist[MAX_N][MAX_N]; int next_node[MAX_N][MAX_N]; double calc_dist(int i, int j) {  - buildings[j].y; return sqrt(dx * dx + dy *  i < n; i++) { for (int j = 0; j < n; j++) { if (i == j) { dist[i][j] = 0; next_node[i][j] = -1; } else { double d = calc_dist(i, j); if (d <= 50.0) { dist[i][j] = d; next_node[i][j] = j; } else { dist[i][j] = INF; next_node[i][j] = -1; } } } } for (int k   = 0; j < n; j++) { if (dist[i][k] + dist[k][j] < dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; next_node[i][j] = next_node[i][k]; } } } } } void print_path(int start, int end) { if (dist[start][end] >= INF)  while (current != end) { current = next_node[current][end]; printf(\" %d\", buildings[current].id); } printf(\"\\n\"); } int main() { while (1) { scanf(\"%d\", &n); if (n == 0)  { scanf(\"%d %d %d\", &buildings[i].id, &buildings[i].x, &buildings[i].y);  0; i < m; i++) { int s, g; scanf(\"%d %d\", &s, &g); int si = -1, gi = -1; for (int j  s) si = j; if  } return 0; }"], "perturbed_original": ["//from PKU1125 #define M 101 double  {/*warshall-floyd*/ int k,i,j; for(k=1;k<=n;k++) for(i=1;i<=n;i++) for(j=1;j<=n;j++){ if(dist[i][j]>dist[i][k]+dist[k][j]) dist[i][j]=dist[i][k]+dist[k][j],next[i][j]=next[i][k]; } } {/*query*/ for(scanf(\"%d\",&k);k;k--){ scanf(\"%d%d\",&a,&b); if(dist[a][b]>998)puts(\"NA\"); else{ for(j=a;j!=b;j=next[j][b])printf(\"%d \",j); printf(\"%d\\n\",b); } } } }exit(0); }"], "original_ll": -1.3808962106704712, "sampled_ll": -0.361834853887558, "all_perturbed_sampled_ll": [-1.205617904663086], "all_perturbed_original_ll": [-1.7557201385498047], "perturbed_sampled_ll": -1.205617904663086, "perturbed_original_ll": -1.7557201385498047, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\npublic class Main {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic Scanner stdIn = new Scanner(System.in);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic int INF = 2 << 20;\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdouble [][] cost = new double[n+1][n+1];\n\t\t\t\n\t\t\tfor(int i = 0; i < n+1; i++) {\n\t\t\t\tArrays.fill(cost[i], INF);\n\t\t\t}\n\t\t\tData[] list = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tlist[i] = new Data(a,b,c);\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tdouble sum = Math.sqrt((list[i].x - list[j].x)*(list[i].x - list[j].x) + (list[i].y - list[j].y) * (list[i].y - list[j].y));\n\t\t\t\t\tif(sum > 50.0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcost[list[i].id][list[j].id] = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tdouble[] d = new double[n+1];\n\t\t\t\tboolean[] used = new boolean[n+1];\n\t\t\t\tint[] prev = new int[n+1];\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint g = sc.nextInt();\n\t\t\t\t\n\t\t\t\tArrays.fill(d, INF);\n\t\t\t\tArrays.fill(used, false);\n\t\t\t\tArrays.fill(prev, -1);\n\t\t\t\td[s] = 0;\n\t\t\t\t\n\t\t\t\twhile(true) {\n\t\t\t\t\tint v = -1;\n\t\t\t\t\tfor(int u= 0; u < n+1; u++) {\n\t\t\t\t\t\tif(!used[u] && (v == -1 || d[u] < d[v])) v = u;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(v == -1) break;\n\t\t\t\t\tused[v] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor(int u = 0; u < n+1; u++) {\n\t\t\t\t\t\tif(d[u] > d[v] + cost[v][u]) {\n\t\t\t\t\t\t\td[u] = d[v] + cost[v][u];\n\t\t\t\t\t\t\tprev[u] = v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(d[g] == INF) {\n\t\t\t\t\tout.println(\"NA\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tArrayList<Integer> Xist = new ArrayList<Integer>();\n\t\t\t\tfor(; g != -1; g = prev[g]) Xist.add(g);\n\t\t\t\t\n\t\t\t\tCollections.reverse(Xist);\n\t\t\t\tout.print(Xist.get(0));\n\t\t\t\tfor(int j = 1; j < Xist.size(); j++) {\n\t\t\t\t\tout.print(\" \" + Xist.get(j));\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\tout.flush();\n\t}\n\t\n\tstatic class Data {\n\t\tint id;\n\t\tint x;\n\t\tint y;\n\t\t\n\t\tData(int a, int b, int c) {\n\t\t\tid = a;\n\t\t\tx = b;\n\t\t\ty = c;\n\t\t}\n\t}\n\t\n\n\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n     \n    public int nextInt() {\n        return (int)nextLong();\n    }\n     \n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n     \n \n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Building {\n        int id;\n        int x, y;\n        \n        Building(int id, int x, int y) {\n            this.id = id;\n            this.x = x;\n            this.y = y;\n        }\n        \n        double distance(Building other) {\n            return Math.sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        int buildingId;\n        double distance;\n        \n        State(int buildingId, double distance) {\n            this.buildingId = buildingId;\n            this.distance = distance;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Double.compare(this.distance, other.distance);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            Map<Integer, Building> buildings = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                int id = sc.nextInt();\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                buildings.put(id, new Building(id, x, y));\n            }\n            \n            int m = sc.nextInt();\n            \n            for (int i = 0; i < m; i++) {\n                int start = sc.nextInt();\n                int goal = sc.nextInt();\n                \n                List<Integer> path = findPath(buildings, start, goal);\n                \n                if (path == null) {\n                    System.out.println(\"NA\");\n                } else {\n                    StringBuilder sb = new StringBuilder();\n                    for (int j = 0; j < path.size(); j++) {\n                        if (j > 0) sb.append(\" \");\n                        sb.append(path.get(j));\n                    }\n                    System.out.println(sb.toString());\n                }\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static List<Integer> findPath(Map<Integer, Building> buildings, int start, int goal) {\n        Map<Integer, Double> dist = new HashMap<>();\n        Map<Integer, Integer> prev = new HashMap<>();\n        PriorityQueue<State> pq = new PriorityQueue<>();\n        \n        for (int id : buildings.keySet()) {\n            dist.put(id, Double.MAX_VALUE);\n        }\n        \n        dist.put(start, 0.0);\n        pq.offer(new State(start, 0.0));\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            int currentId = current.buildingId;\n            \n            if (current.distance > dist.get(currentId)) {\n                continue;\n            }\n            \n            if (currentId == goal) {\n                break;\n            }\n            \n            Building currentBuilding = buildings.get(currentId);\n            \n            for (int nextId : buildings.keySet()) {\n                if (nextId == currentId) continue;\n                \n                Building nextBuilding = buildings.get(nextId);\n                double distance = currentBuilding.distance(nextBuilding);\n                \n                if (distance <= 50.0) {\n                    double newDist = dist.get(currentId) + distance;\n                    \n                    if (newDist < dist.get(nextId)) {\n                        dist.put(nextId, newDist);\n                        prev.put(nextId, currentId);\n                        pq.offer(new State(nextId, newDist));\n                    }\n                }\n            }\n        }\n        \n        if (!prev.containsKey(goal) && start != goal) {\n            return null;\n        }\n        \n        List<Integer> path = new ArrayList<>();\n        int current = goal;\n        \n        while (current != start) {\n            path.add(current);\n            if (!prev.containsKey(current)) {\n                return null;\n            }\n            current = prev.get(current);\n        }\n        path.add(start);\n        \n        Collections.reverse(path);\n        return path;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Building { int id; int x, y; Building(int id, int x, int y) {  double distance(Building other) { return Math.sqrt((x - other.x) *  int buildingId; double distance; State(int buildingId, double distance) { this.buildingId = buildingId; this.distance = distance; } @Override public int compareTo(State other) { return Double.compare(this.distance, other.distance); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0)  = 0; i < n; i++) { int id =  for (int i = 0; i < m;  List<Integer>  System.out.println(\"NA\"); } else { StringBuilder sb = new StringBuilder(); for (int j = 0; j < path.size(); j++)   int start, int goal) { Map<Integer, Double> dist = new HashMap<>(); Map<Integer, Integer> prev = new HashMap<>(); PriorityQueue<State> pq = new PriorityQueue<>(); for (int id : buildings.keySet()) { dist.put(id, Double.MAX_VALUE); } dist.put(start, 0.0); pq.offer(new State(start, 0.0)); while (!pq.isEmpty()) { State current = pq.poll(); int currentId = current.buildingId; if (current.distance > dist.get(currentId)) {  currentBuilding = buildings.get(currentId); for (int nextId : buildings.keySet()) { if (nextId == currentId) continue; Building nextBuilding = buildings.get(nextId); double distance = currentBuilding.distance(nextBuilding); if (distance <= 50.0) { double newDist = dist.get(currentId) + distance; if (newDist < dist.get(nextId)) { dist.put(nextId, newDist); prev.put(nextId, currentId); pq.offer(new State(nextId, newDist)); } } } } if (!prev.containsKey(goal) && start != goal) { return null; } List<Integer> path = new ArrayList<>(); int current = goal; while (current != start) { path.add(current); if (!prev.containsKey(current)) { return null; } current = prev.get(current); } path.add(start); Collections.reverse(path); return path; } }"], "perturbed_original": ["import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections;  out = new PrintWriter(System.out); static Scanner stdIn = new Scanner(System.in); static FastScanner sc = new FastScanner(); static int INF = 2 << 20; public static void main(String[] args) { while(true) { int n = sc.nextInt(); if(n == 0) break; double [][] cost = new double[n+1][n+1]; for(int i = 0; i < n+1; i++) { Arrays.fill(cost[i], INF); } Data[] list = new Data[n]; for(int i = 0; i < n; i++) { int a = sc.nextInt(); int b = sc.nextInt();  i = 0; i < n; i++) { for(int j = 0; j < n; j++) { double sum = Math.sqrt((list[i].x - list[j].x)*(list[i].x - list[j].x) + (list[i].y - list[j].y) * (list[i].y  sum; } } int m = sc.nextInt(); for(int i = 0; i < m; i++) { double[] d = new double[n+1]; boolean[] used = new boolean[n+1]; int[] prev = new int[n+1]; int s = sc.nextInt(); int g = sc.nextInt(); Arrays.fill(d, INF); Arrays.fill(used, false); Arrays.fill(prev, -1); d[s] = 0; while(true) { int v = -1; for(int u= 0; u < n+1;  d[v])) v = u; } if(v == -1) break; used[v] = true; for(int u = 0; u < n+1; u++) { if(d[u] >  = v; } } } if(d[g] == INF) { out.println(\"NA\"); continue; } ArrayList<Integer> Xist = new ArrayList<Integer>(); for(; g != -1; g = prev[g])  j++) {  static class Data { int id; int x; int y; Data(int a, int b, int  c; } } } class  byte[] buffer =  = 0; private boolean hasNextByte() { if  try { buflen = in.read(buffer); } catch (IOException e) { e.printStackTrace(); } if (buflen <= 0) { return false; } } return true; } private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;} private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;} private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;} public boolean hasNext() { skipUnprintable();  NoSuchElementException(); StringBuilder sb = new StringBuilder(); int b = readByte(); while(isPrintableChar(b)) { sb.appendCodePoint(b); b = readByte(); } return sb.toString();  long n =  (b == '-') { minus = true; b = readByte(); } if (b < '0' || '9' < b) { throw new NumberFormatException(); } while(true){ if ('0' <= b && b <= '9') { n *= 10; n += b - '0'; }else if(b ==  throw new NumberFormatException(); } b  } public double nextDouble() { return Double.parseDouble(next()); } }"], "original_ll": -0.5654093027114868, "sampled_ll": -0.38648414611816406, "all_perturbed_sampled_ll": [-1.2291568517684937], "all_perturbed_original_ll": [-1.3338655233383179], "perturbed_sampled_ll": -1.2291568517684937, "perturbed_original_ll": -1.3338655233383179, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import copy, math\n\ndef f(n, d, D, res, buil):\n    global sd, ans\n    d += D\n    res.append(n)\n    if sd is not None and sd <= d:\n        return\n    elif n == g:\n        ans = res\n        sd = d\n        return\n    else:\n        new_buil = copy.deepcopy(buil)\n        A = new_buil[n]\n        del new_buil[n]\n        for m, B in new_buil.items():\n            D = py(A, B)\n            if D:\n                f(m, d, D, res[:], new_buil)\n            \ndef py(A, B):\n    x = 0\n    y = 1\n    D = math.sqrt((B[x]-A[x])**2+(B[y]-A[y])**2)\n    if D <= 50:\n        return D\n\nwhile True:\n    N = input()\n    if N == 0: break\n    buil = {}\n    for i in range(N):\n        n, x, y = map(int, raw_input().split())\n        buil[n] = (x, y)\n    for i in range(input()):\n        s, g = map(int, raw_input().split())\n        sd = None\n        ans = None\n        f(s, 0, 0, [], buil)\n        if ans:\n            print ' '.join(map(str, ans))\n        else:\n            print 'NA'", "sampled": "import sys\nfrom collections import deque\nimport math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef bfs(start, goal, buildings, adjacency):\n    if start == goal:\n        return [start]\n    \n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        current, path = queue.popleft()\n        \n        for neighbor in adjacency[current]:\n            if neighbor in visited:\n                continue\n            \n            visited.add(neighbor)\n            new_path = path + [neighbor]\n            \n            if neighbor == goal:\n                return new_path\n            \n            queue.append((neighbor, new_path))\n    \n    return None\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    buildings = {}\n    for _ in range(n):\n        parts = list(map(int, input().split()))\n        b_id = parts[0]\n        x = parts[1]\n        y = parts[2]\n        buildings[b_id] = (x, y)\n    \n    # Build adjacency list\n    adjacency = {b_id: [] for b_id in buildings}\n    for b1 in buildings:\n        for b2 in buildings:\n            if b1 != b2:\n                dist = distance(buildings[b1], buildings[b2])\n                if dist <= 50:\n                    adjacency[b1].append(b2)\n    \n    m = int(input())\n    results = []\n    for _ in range(m):\n        s, g = map(int, input().split())\n        path = bfs(s, g, buildings, adjacency)\n        if path is None:\n            results.append(\"NA\")\n        else:\n            results.append(\" \".join(map(str, path)))\n    \n    for result in results:\n        print(result)\n", "perturbed_sampled": ["import  return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def bfs(start, goal, buildings, adjacency): if start == goal: return [start] queue = deque([(start, [start])]) visited = {start} while queue: current, path = queue.popleft() for neighbor in adjacency[current]: if neighbor in visited: continue visited.add(neighbor) new_path = path + [neighbor] if neighbor == goal: return new_path queue.append((neighbor, new_path)) return None while True: n = int(input()) if n == 0: break buildings   = (x, y) #  buildings} for b1 in buildings: for b2 in buildings: if b1 != b2: dist = distance(buildings[b1], buildings[b2]) if  for _ in range(m): s, g = map(int, input().split()) path = bfs(s, g, buildings, adjacency) if path is None: results.append(\"NA\") else: results.append(\" \".join(map(str, path))) for result in results: print(result)"], "perturbed_original": ["import copy, math def f(n, d, D, res, buil): global sd, = A[n]<extra_id_4>, b<extra_id_5>]<extra_id_6>[i ] if<extra_id_7>[ [<extra_id_8>]<extra_id_9>, b<extra_id_10>[<extra_id_11>]<extra_id_12>[ ] )<extra_id_13>: if s >= 0<extra_id_14>0: print 'NA' :<extra_id_15>]<extra_id_16>[<extra_id_17>. extend (<extra_id_18>A i in x<extra_id_19>]<extra_id_20>[ B ]<extra_id_21>x , y ,<extra_id_22>return ( [ ans<extra_id_23>] ans = res sd = d return else: new_buil = copy.deepcopy(buil) A = new_buil[n] del new_buil[n] for m, B in new_buil.items(): D = py(A, B) if D: f(m, d, D, res[:], new_buil) def py(A, B): x = 0 y  D while True: N = input() if N == 0: break buil = {} for i in range(N): n, x, y = map(int, raw_input().split()) buil[n] = (x, y) for i in range(input()): s, g  0, 0, [], buil) if ans: print ' '.join(map(str, ans)) else: print 'NA'"], "original_ll": -1.3316826820373535, "sampled_ll": -0.5126494765281677, "all_perturbed_sampled_ll": [-1.3349956274032593], "all_perturbed_original_ll": [-2.5044496059417725], "perturbed_sampled_ll": -1.3349956274032593, "perturbed_original_ll": -2.5044496059417725, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ty;\n    int tx;\n    int sharp;\n} POINT;\n\nPOINT queue[10000000];\nint head, tail;\n\nvoid enq(POINT t)\n{\n    queue[tail++] = t;\n    if (tail == 10000000){\n        tail = 0;\n    }\n}\n\nvoid deq(POINT *t)\n{\n    *t = queue[head++];\n    if (head == 10000000){\n        head = 0;\n    }\n}\n\nint main(void)\n{\n    POINT temp, add;\n    int ans;\n    int i, j;\n    int x, y;\n    int mx, my;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int cost[102][102];\n    char map[102][103];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        getchar();\n        \n        memset(map, '.', sizeof(map));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%c\", &map[i][j]);\n                \n                if (map[i][j] == '&'){\n                    temp.tx = j;\n                    temp.ty = i;\n                }\n            }\n            getchar();\n        }\n        \n        for (i = 0; i <= y + 1; i++){\n            for (j = 0; j <= x + 1; j++){\n                cost[i][j] = 100000;\n            }\n        }\n        \n        cost[temp.ty][temp.tx] = 0;\n        temp.sharp = 0;\n        head = tail = 0;\n        enq(temp);\n        ans = 100000;\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (0 == temp.tx || 0 == temp.ty || x + 1 == temp.tx || y + 1 == temp.ty){\n                ans = (ans > temp.sharp ? temp.sharp : ans);\n                continue;\n            }\n            \n            for (i = 0; i < 4; i++){\n                mx = temp.tx + dx[i];\n                my = temp.ty + dy[i];\n                add = temp;\n                if (cost[my][mx] > add.sharp){\n                    if ((map[my][mx] == '.') && map[temp.ty][temp.tx] == '#'){\n                        add.sharp++;\n                    }\n                    cost[my][mx] = add.sharp;\n                    add.tx = mx;\n                    add.ty = my;\n                    enq(add);\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAXN 105\n\ntypedef struct {\n    int x, y, cost;\n} State;\n\ntypedef struct {\n    State data[MAXN * MAXN];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue *q) {\n    q->front = 0;\n    q->rear = 0;\n}\n\nvoid enqueue(Queue *q, State s) {\n    q->data[q->rear++] = s;\n}\n\nState dequeue(Queue *q) {\n    return q->data[q->front++];\n}\n\nint isEmpty(Queue *q) {\n    return q->front == q->rear;\n}\n\nint main() {\n    int n, m;\n    char grid[MAXN][MAXN];\n    int dist[MAXN][MAXN];\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    \n    while (scanf(\"%d %d\", &n, &m) == 2 && (n || m)) {\n        int startX = -1, startY = -1;\n        \n        for (int i = 0; i < m; i++) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '&') {\n                    startX = i;\n                    startY = j;\n                }\n                dist[i][j] = INT_MAX;\n            }\n        }\n        \n        // Check if we can reach from boundary\n        Queue q;\n        initQueue(&q);\n        \n        // Start from all boundary cells\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || i == m-1 || j == 0 || j == n-1) {\n                    State s;\n                    s.x = i;\n                    s.y = j;\n                    if (grid[i][j] == '#') {\n                        s.cost = 1;\n                    } else {\n                        s.cost = 0;\n                    }\n                    dist[i][j] = s.cost;\n                    enqueue(&q, s);\n                }\n            }\n        }\n        \n        while (!isEmpty(&q)) {\n            State cur = dequeue(&q);\n            int x = cur.x;\n            int y = cur.y;\n            int cost = cur.cost;\n            \n            if (cost > dist[x][y]) continue;\n            \n            for (int d = 0; d < 4; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                \n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    int newCost = cost;\n                    if (grid[x][y] == '#' && grid[nx][ny] != '#') {\n                        newCost = cost + 1;\n                    }\n                    \n                    if (newCost < dist[nx][ny]) {\n                        dist[nx][ny] = newCost;\n                        State ns;\n                        ns.x = nx;\n                        ns.y = ny;\n                        ns.cost = newCost;\n                        enqueue(&q, ns);\n                    }\n                }\n            }\n        }\n        \n        if (dist[startX][startY] == INT_MAX) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", dist[startX][startY]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h> #define MAXN 105 typedef struct { int x, y, cost; } State; typedef  Queue; void initQueue(Queue *q) { q->front = 0; q->rear = 0; } void enqueue(Queue *q, State s) { q->data[q->rear++] = s; } State dequeue(Queue *q)   grid[MAXN][MAXN]; int dist[MAXN][MAXN]; int dx[] = {0, 0, 1, -1}; int dy[] = {1, -1, 0, 0}; while (scanf(\"%d %d\", &n, &m) == 2 && (n || m)) { int startX = -1, startY = -1; for (int i = 0;  = 0; j < n; j++) { if (grid[i][j] == '&') { startX = i; startY = j; } dist[i][j] = INT_MAX; } } // Check if we  all boundary cells for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (i == 0 || i == m-1 || j == 0 || j == n-1) { State s; s.x =  = 1; } else { s.cost = 0; } dist[i][j] = s.cost; enqueue(&q, s); } } } while (!isEmpty(&q)) { State cur = dequeue(&q); int x = cur.x; int y = cur.y; int cost  = 0; d <  && nx < m && ny >= 0 && ny < n) { int newCost = cost; if (grid[x][y] == '#' && grid[nx][ny] != '#') { newCost = cost + 1; } if (newCost < dist[nx][ny]) { dist[nx][ny] = newCost; State ns; ns.x = nx; ns.y = ny; ns.cost = newCost; enqueue(&q, ns); } } } } if (dist[startX][startY] == INT_MAX) {  }"], "perturbed_original": [" tx; int sharp; } POINT; POINT queue[10000000]; int head, tail; void enq(POINT t) { queue[tail++] = t; if (tail == 10000000){ tail = 0; } } void deq(POINT *t)  0; } } int main(void) { POINT temp, add; int ans; int i, j; int x, y; int mx, my; int dx[4] = {1, 0, -1, 0}; int dy[4] = {0, 1, 0, -1}; int cost[102][102]; char map[102][103]; while (1){ scanf(\"%d%d\", &x, &y); if (x + y == 0){ break; } getchar(); memset(map, '.', sizeof(map)); for (i  j <= x; j++){ scanf(\"%c\", &map[i][j]); if (map[i][j] == '&'){ temp.tx = j; temp.ty = i; } } getchar(); } for (i =  0; j <= x + 1;  = 0; head = tail = 0; enq(temp); ans = 100000; while (head !=  || x + 1 == temp.tx || y + 1 ==  continue; } for (i = 0; i < 4; i++){ mx = temp.tx + dx[i]; my = temp.ty + dy[i]; add = temp; if (cost[my][mx] > add.sharp){ if ((map[my][mx] == '.') && map[temp.ty][temp.tx] == '#'){ add.sharp++; } cost[my][mx] = add.sharp; add.tx = mx; add.ty = my; enq(add); } } } printf(\"%d\\n\", ans); } return (0); }"], "original_ll": -0.750607967376709, "sampled_ll": -0.4473927617073059, "all_perturbed_sampled_ll": [-1.0969183444976807], "all_perturbed_original_ll": [-1.397063970565796], "perturbed_sampled_ll": -1.0969183444976807, "perturbed_original_ll": -1.397063970565796, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tint gy = -1;\n\t\t\tint gx = -1;\n\t\t\tboolean[][] map = new boolean[h + 2][w + 2];\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (c[j - 1] == '#') {\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t} else if (c[j - 1] == '&') {\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\t\t\tint[][] cnt = new int[h + 2][w + 2];\n\t\t\t\n\t\t\tfor (int[] c : cnt) {\n\t\t\t\tArrays.fill(c, 1 << 10);\n\t\t\t}\n\t\t\tcnt[0][0] = 0;\n\t\t\tDeque<List<Integer>> deque = new ArrayDeque<List<Integer>>();\n\t\t\tdeque.offer(Arrays.asList(0, 0));\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tList<Integer> list = deque.poll();\n\t\t\t\tint y = list.get(0);\n\t\t\t\tint x = list.get(1);\n\t\t\t\tfor (int[] d : dxy) {\n\t\t\t\t\tint dy = y + d[0];\n\t\t\t\t\tint dx = x + d[1];\n\t\t\t\t\tif (0 <= dy && dy < h + 2 && 0 <= dx & dx < w + 2) {\n\t\t\t\t\t\tint r;\n\t\t\t\t\t\tif (map[y][x] && !map[dy][dx]) {\n\t\t\t\t\t\t\tr = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cnt[dy][dx] > cnt[y][x] + r) {\n\t\t\t\t\t\t\tcnt[dy][dx] = cnt[y][x] + r;\n\t\t\t\t\t\t\tdeque.offer(Arrays.asList(dy, dx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt[gy][gx]);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class State implements Comparable<State> {\n        int x, y, climbs;\n        \n        State(int x, int y, int climbs) {\n            this.x = x;\n            this.y = y;\n            this.climbs = climbs;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return this.climbs - other.climbs;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            int n = Integer.parseInt(parts[0]);\n            int m = Integer.parseInt(parts[1]);\n            \n            if (n == 0 && m == 0) break;\n            \n            char[][] grid = new char[m][n];\n            int targetX = -1, targetY = -1;\n            \n            for (int i = 0; i < m; i++) {\n                String row = br.readLine();\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = row.charAt(j);\n                    if (grid[i][j] == '&') {\n                        targetX = i;\n                        targetY = j;\n                    }\n                }\n            }\n            \n            int result = solve(grid, m, n, targetX, targetY);\n            System.out.println(result);\n        }\n    }\n    \n    static int solve(char[][] grid, int m, int n, int targetX, int targetY) {\n        int[][] minClimbs = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(minClimbs[i], Integer.MAX_VALUE);\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        \n        // Start from all border cells\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {\n                    int initialClimbs = (grid[i][j] == '#') ? 1 : 0;\n                    pq.offer(new State(i, j, initialClimbs));\n                    minClimbs[i][j] = initialClimbs;\n                }\n            }\n        }\n        \n        int[] dx = {-1, 1, 0, 0};\n        int[] dy = {0, 0, -1, 1};\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            if (current.x == targetX && current.y == targetY) {\n                return current.climbs;\n            }\n            \n            if (current.climbs > minClimbs[current.x][current.y]) {\n                continue;\n            }\n            \n            for (int i = 0; i < 4; i++) {\n                int nx = current.x + dx[i];\n                int ny = current.y + dy[i];\n                \n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    boolean currentInMoat = (grid[current.x][current.y] == '#');\n                    boolean nextInMoat = (grid[nx][ny] == '#');\n                    \n                    int newClimbs = current.climbs;\n                    if (currentInMoat && !nextInMoat) {\n                        newClimbs++;\n                    }\n                    \n                    if (newClimbs < minClimbs[nx][ny]) {\n                        minClimbs[nx][ny] = newClimbs;\n                        pq.offer(new State(nx, ny, newClimbs));\n                    }\n                }\n            }\n        }\n        \n        return minClimbs[targetX][targetY];\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class State implements Comparable<State> { int x, y, climbs; State(int x, int y, int climbs) { this.x = x; this.y = y; this.climbs = climbs; } @Override public int compareTo(State other) { return this.climbs - other.climbs; } } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] parts = line.trim().split(\"\\\\s+\"); int n = Integer.parseInt(parts[0]); int m = Integer.parseInt(parts[1]); if (n == 0 && m == 0) break; char[][] grid = new char[m][n];  = 0; i < m; i++) { String row = br.readLine(); for (int j = 0; j < n;  targetX = i; targetY = j; }  System.out.println(result);  int targetX, int targetY) { int[][] minClimbs = new int[m][n]; for (int i = 0;  = new PriorityQueue<>(); // Start from all border cells for (int  j = 0;  i  == n - 1) { int  State(i, j, initialClimbs)); minClimbs[i][j]  0, 0}; int[] dy = {0, 0, -1, 1}; while (!pq.isEmpty()) { State current = pq.poll(); if (current.x == targetX && current.y == targetY) { return current.climbs; } if (current.climbs > minClimbs[current.x][current.y]) { continue; } for (int i = 0; i < 4; i++) { int nx = current.x + dx[i]; int ny = current.y + dy[i]; if (nx >= 0 && nx < m && ny >= 0 && ny < n) { boolean currentInMoat = (grid[current.x][current.y] == '#'); boolean nextInMoat = (grid[nx][ny] == '#'); int newClimbs = current.climbs; if (currentInMoat && !nextInMoat) { newClimbs++; } if (newClimbs < minClimbs[nx][ny]) { minClimbs[nx][ny] = newClimbs;  } }"], "perturbed_original": ["import java.util.ArrayDeque; import java.util.Arrays; import java.util.Deque; import java.util.List; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (true) { int w = scanner.nextInt(); int h = scanner.nextInt(); if (w == 0 && h == 0) break; int gy = -1; int gx = -1; boolean[][] map = new boolean[h + 2][w + 2]; for (int i = 1; i <= h; i++) { char[] c = scanner.next().toCharArray(); for (int j = 1; j <= w; j++) { if (c[j - 1] == '#') { map[i][j]  { gy = i; gx = j; } } } int[][] dxy = { { -1, 0 }, { 0, -1 },  cnt = new  { Arrays.fill(c, 1  deque.poll(); int y = list.get(0); int x = list.get(1); for (int[] d : dxy) { int dy = y + d[0]; int dx = x + d[1]; if (0 <= dy && dy < h + 2 && 0 <= dx & dx < w + 2) { int r; if (map[y][x] && !map[dy][dx])  } if (cnt[dy][dx]  deque.offer(Arrays.asList(dy, dx)); } } } } System.out.println(cnt[gy][gx]); } } }"], "original_ll": -0.546765923500061, "sampled_ll": -0.35110238194465637, "all_perturbed_sampled_ll": [-0.9931043982505798], "all_perturbed_original_ll": [-1.1731959581375122], "perturbed_sampled_ll": -0.9931043982505798, "perturbed_original_ll": -1.1731959581375122, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from heapq import heappush, heappop\n\nwhile True:\n  n, m = map(int, input().split())\n  if n == 0: break\n\n  mp = [\"X\" + input() + \"X\" for _ in range(m)]\n  mp.insert(0, \"X\" * (n + 2))\n  mp.append(\"X\" * (n + 2))\n  \n  que = []\n  visited = [[False] * (n + 2) for _ in range(m + 2)]\n  sur_flag = False\n  for i in range(1, n + 1):\n    if mp[1][i] ==\"&\" or mp[m][i] == \"&\":\n      sur_flag = True\n      break\n    c1, s1 = (1, 0) if mp[1][i] == \"#\" else (0, 1)\n    c2, s2 = (1, 0) if mp[m][i] == \"#\" else (0, 1)\n    heappush(que, (c1, s1, (i, 1)))\n    heappush(que, (c2, s2, (i, m)))\n    visited[1][i] = True\n    visited[m][i] = True\n  \n  for i in range(1, m + 1):\n    if mp[i][1] == \"&\" or mp[i][n] == \"&\":\n      sur_flag = True\n      break\n    c1, s1 = (1, 0) if mp[i][1] == \"#\" else (0, 1)\n    c2, s2 = (1, 0) if mp[i][n] == \"#\" else (0, 1)\n    heappush(que, (c1, s1, (1, i)))\n    heappush(que, (c2, s2, (n, i)))\n    visited[i][1] = True\n    visited[i][n] = True\n  \n  if sur_flag:\n    print(0)\n    continue\n  \n  direct = ((0, 1), (0, -1), (1, 0), (-1, 0))\n  reached = False\n  \n  while que and not reached:\n    cost, status, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      newx, newy = x + dx, y + dy\n      if not visited[newy][newx]:\n        visited[newy][newx] = True\n        if mp[newy][newx] == \"&\":\n          print(cost)\n          reached = True\n          break\n        elif mp[newy][newx] == \"#\":\n          if status == 1:\n            heappush(que, (cost + 1, 0, (newx, newy)))\n          else:\n            heappush(que, (cost, 0, (newx, newy)))\n        elif mp[newy][newx] == \".\":\n          heappush(que,(cost, 1, (newx, newy)))\n", "sampled": "from collections import deque\n\ndef solve(n, m, grid):\n    # Find the position of '&' (castle keep)\n    castle_pos = None\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '&':\n                castle_pos = (i, j)\n                break\n        if castle_pos:\n            break\n    \n    # BFS with state (row, col, climbs)\n    # We want to find minimum climbs to reach castle from outside\n    # Outside means any position on the border or reachable from border\n    \n    # Use 0-1 BFS (or Dijkstra-like approach)\n    # State: (climbs, row, col, in_moat)\n    # in_moat: True if currently in a moat\n    \n    visited = {}  # (row, col, in_moat) -> min_climbs\n    pq = deque()\n    \n    # Start from all border positions\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or i == m-1 or j == 0 or j == n-1:\n                in_moat = (grid[i][j] == '#')\n                pq.append((0, i, j, in_moat))\n                visited[(i, j, in_moat)] = 0\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    while pq:\n        climbs, row, col, in_moat = pq.popleft()\n        \n        if row == castle_pos[0] and col == castle_pos[1]:\n            return climbs\n        \n        if visited.get((row, col, in_moat), float('inf')) < climbs:\n            continue\n        \n        for dr, dc in directions:\n            nr, nc = row + dr, col + dc\n            if 0 <= nr < m and 0 <= nc < n:\n                next_is_moat = (grid[nr][nc] == '#')\n                \n                # Calculate climbs needed\n                new_climbs = climbs\n                if in_moat and not next_is_moat:\n                    # Climbing out of moat\n                    new_climbs = climbs + 1\n                \n                if visited.get((nr, nc, next_is_moat), float('inf')) > new_climbs:\n                    visited[(nr, nc, next_is_moat)] = new_climbs\n                    if new_climbs == climbs:\n                        pq.appendleft((new_climbs, nr, nc, next_is_moat))\n                    else:\n                        pq.append((new_climbs, nr, nc, next_is_moat))\n    \n    return -1\n\nwhile True:\n    line = input().split()\n    n, m = int(line[0]), int(line[1])\n    if n == 0 and m == 0:\n        break\n    \n    grid = []\n    for _ in range(m):\n        grid.append(input().strip())\n    \n    result = solve(n, m, grid)\n    print(result)\n", "perturbed_sampled": ["from collections import deque def solve(n, m, grid): # Find the position of '&' (castle keep) castle_pos = None for i in range(m): for j in range(n): if grid[i][j] == '&': castle_pos = (i, j) break if castle_pos: break # BFS with state (row, col, climbs) # We want to find minimum climbs to reach castle from outside # Outside means any position on the border or reachable from border # Use 0-1 BFS (or Dijkstra-like approach) # State: (climbs, row, col, in_moat) # in_moat: True if currently in a moat visited   range(m):  == m-1 or j == 0 or j  in_moat)) visited[(i, j,  0), (-1, 0)] while pq: climbs, row, col, in_moat = pq.popleft() if row == castle_pos[0] and col == castle_pos[1]: return climbs if visited.get((row, col,  nr, nc = row +  and 0 <= nc < n: next_is_moat = (grid[nr][nc] == '#') # Calculate climbs needed new_climbs = climbs if in_moat and not  1 if visited.get((nr, nc, next_is_moat), float('inf')) > new_climbs: visited[(nr, nc, next_is_moat)] = new_climbs if new_climbs == climbs: pq.appendleft((new_climbs, nr, nc, next_is_moat)) else: pq.append((new_climbs, nr, nc, next_is_moat)) return -1 while True: line = input().split() n, m = int(line[0]), int(line[1]) if n == 0 and m == 0: break grid = [] for _ in range(m): grid.append(input().strip()) result = solve(n, m, grid) print(result)"], "perturbed_original": ["from heapq import heappush, heappop while True: n, m = map(int, input().split()) if n == 0: break mp = [\"X\" + input() + \"X\" for _ in range(m)] mp.insert(0, \"X\" * (n + 2)) mp.append(\"X\" * (n + 2)) que = [] visited = [[False] * (n  False for i in  \"&\": sur_flag = True break c1, s1 = (1, 0) if mp[1][i] == \"#\" else (0, 1) c2, s2 = (1, 0) if mp[m][i]  heappush(que, (c2, s2, (i, m)))  m + 1): if mp[i][1] == \"&\" or mp[i][n] == \"&\": sur_flag = True break c1, s1 = (1, 0) if mp[i][1] == \"#\" else (0, 1) c2, s2 = (1, 0) if mp[i][n] == \"#\" else (0, 1) heappush(que, (c1, s1, (1, i))) heappush(que, (c2, s2, (n, i)))  direct  = False while que and not reached: cost, status, point = heappop(que) x, y = point for dx, dy in direct: newx, newy = x + dx,  mp[newy][newx] == \"&\": print(cost) reached = True break elif mp[newy][newx] == \"#\": if status == 1: heappush(que, (cost + 1, 0, (newx, newy))) else: heappush(que, (cost, 0, (newx, newy))) elif mp[newy][newx] == \".\": heappush(que,(cost, 1, (newx, newy)))"], "original_ll": -0.570551872253418, "sampled_ll": -0.8655345439910889, "all_perturbed_sampled_ll": [-1.7813612222671509], "all_perturbed_original_ll": [-1.251044511795044], "perturbed_sampled_ll": -1.7813612222671509, "perturbed_original_ll": -1.251044511795044, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n\tint h;\n\tint r;\n} DOLL;\n\nint cmp(const void *a, const void *b)\n{\n\tDOLL x, y;\n\t\n\tx = *(DOLL *)a;\n\ty = *(DOLL *)b;\n\t\n\tif (x.r - y.r){\n\t\treturn (x.r - y.r);\n\t}\n\treturn (x.h - y.h);\n}\n\nint main(void)\n{\n\tDOLL rusd[256];\n\tint dp[256];\n\tint n, m;\n\tint i, j;\n\tint ans;\n\t\n\twhile (1){\n\t\tans = 0;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) break;\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d\", &rusd[i].h, &rusd[i].r);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor (j = 0; j < m; j++){\n\t\t\tscanf(\"%d %d\", &rusd[n + j].h, &rusd[n + j].r);\n\t\t}\n\t\tqsort(rusd, n + m, sizeof(DOLL), cmp);\n\t\t\n\t\tfor (i = 0; i < n + m; i++){\n\t\t\tdp[i] = 1;\n\t\t\tfor (j = 0; j < i; j++){\n\t\t\t\tif (rusd[i].h > rusd[j].h && rusd[i].r > rusd[j].r){\n\t\t\t\t\tif (dp[i] < dp[j] + 1){\n\t\t\t\t\t\tdp[i] = dp[j] + 1;\n\t\t\t\t\t\tif (ans < dp[i]){\n\t\t\t\t\t\t\tans = dp[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int h, r;\n} Doll;\n\nint n, m;\nDoll dolls[205];\nint dp[205];\nint parent[205];\n\nint canContain(int i, int j) {\n    return dolls[i].h < dolls[j].h && dolls[i].r < dolls[j].r;\n}\n\nint compare(const void *a, const void *b) {\n    Doll *da = (Doll *)a;\n    Doll *db = (Doll *)b;\n    if (da->h != db->h) return da->h - db->h;\n    return da->r - db->r;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &dolls[i].h, &dolls[i].r);\n        }\n        \n        scanf(\"%d\", &m);\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d\", &dolls[n + i].h, &dolls[n + i].r);\n        }\n        \n        int total = n + m;\n        \n        qsort(dolls, total, sizeof(Doll), compare);\n        \n        for (int i = 0; i < total; i++) {\n            dp[i] = 1;\n            parent[i] = -1;\n        }\n        \n        int maxLen = 1;\n        for (int i = 1; i < total; i++) {\n            for (int j = 0; j < i; j++) {\n                if (canContain(j, i)) {\n                    if (dp[j] + 1 > dp[i]) {\n                        dp[i] = dp[j] + 1;\n                        parent[i] = j;\n                    }\n                }\n            }\n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n            }\n        }\n        \n        printf(\"%d\\n\", maxLen);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef struct { int h, r; } Doll; int n, m; Doll dolls[205]; int dp[205]; int parent[205]; int canContain(int i, int j) { return dolls[i].h < dolls[j].h && dolls[i].r < dolls[j].r; } int compare(const void *a, const void *b) { Doll *da = (Doll *)a;  da->h - db->h; return da->r - db->r; } int main() { while (1) { scanf(\"%d\", &n); if (n == 0) break;  scanf(\"%d  0; i < m; i++) { scanf(\"%d %d\", &dolls[n + i].h, &dolls[n + i].r); } int total = n + m; qsort(dolls, total, sizeof(Doll), compare); for (int i  parent[i] = -1; } int maxLen = 1; for (int i = 1; i < total;  j++) { if (canContain(j, i)) { if (dp[j] + 1 > dp[i]) { dp[i] = dp[j] + 1; parent[i] = j; } } } if (dp[i] > maxLen) {  }"], "perturbed_original": ["#include <stdio.h> #include  } DOLL; int cmp(const void *a, const void *b) { DOLL x, y; x = *(DOLL *)a; y = *(DOLL *)b; if (x.r - y.r){ return (x.r - y.r); } return (x.h - y.h); } int main(void) { DOLL rusd[256]; int dp[256]; int n, m; int i, j; int ans; while (1){ ans = 0; memset(dp,  (i = 0; i < n; i++){ scanf(\"%d %d\", &rusd[i].h, &rusd[i].r); } scanf(\"%d\", &m); for (j = 0; j < m; j++){ scanf(\"%d %d\", &rusd[n + j].h, &rusd[n + j].r);  0; i < n + m; i++){ dp[i]  (dp[i] < dp[j] + 1){ dp[i] = dp[j] + 1; if (ans < dp[i]){ ans = dp[i]; } } } } } printf(\"%d\\n\", ans); } return (0); }"], "original_ll": -0.580566942691803, "sampled_ll": -0.45426276326179504, "all_perturbed_sampled_ll": [-1.2783679962158203], "all_perturbed_original_ll": [-1.3644754886627197], "perturbed_sampled_ll": -1.2783679962158203, "perturbed_original_ll": -1.3644754886627197, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[][] data;\n\tint[] memo;\n\tboolean[] use;\n\tint n, m, N;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdata = new int[201][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tdata[i][0] = sc.nextInt();\n\t\t\t\tdata[i][1] = sc.nextInt();\n\t\t\t}\n\t\t\tm = sc.nextInt();\n\t\t\tfor (int i = n; i < m + n; i++) {\n\t\t\t\tdata[i][0] = sc.nextInt();\n\t\t\t\tdata[i][1] = sc.nextInt();\n\t\t\t}\n\n\t\t\tN = n + m;\n\t\t\tmemo = new int[n + m];\n\t\t\tuse = new boolean[n + m];\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tans = Math.max(ans, dfs(i));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tint dfs(int index) {\n\t\tif (memo[index] > 0) {\n\t\t\treturn memo[index];\n\t\t}\n\t\tint res = 1;\n\t\tuse[index] = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!use[i]) {\n\t\t\t\tif (data[i][0] < data[index][0] && data[i][1] < data[index][1]) {\n\t\t\t\t\tres = Math.max(res, dfs(i) + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tuse[index] = false;\n\t\treturn memo[index] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Doll implements Comparable<Doll> {\n        int h, r;\n        \n        Doll(int h, int r) {\n            this.h = h;\n            this.r = r;\n        }\n        \n        @Override\n        public int compareTo(Doll other) {\n            if (this.h != other.h) {\n                return this.h - other.h;\n            }\n            return this.r - other.r;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            List<Doll> dolls = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                int h = sc.nextInt();\n                int r = sc.nextInt();\n                dolls.add(new Doll(h, r));\n            }\n            \n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                int h = sc.nextInt();\n                int r = sc.nextInt();\n                dolls.add(new Doll(h, r));\n            }\n            \n            Collections.sort(dolls);\n            \n            int[] dp = new int[dolls.size()];\n            Arrays.fill(dp, 1);\n            \n            for (int i = 1; i < dolls.size(); i++) {\n                for (int j = 0; j < i; j++) {\n                    if (dolls.get(j).h < dolls.get(i).h && dolls.get(j).r < dolls.get(i).r) {\n                        dp[i] = Math.max(dp[i], dp[j] + 1);\n                    }\n                }\n            }\n            \n            int max = 0;\n            for (int i = 0; i < dolls.size(); i++) {\n                max = Math.max(max, dp[i]);\n            }\n            \n            System.out.println(max);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  Doll(int h, int r) { this.h = h; this.r = r; } @Override public int compareTo(Doll other) { if (this.h != other.h) { return this.h - other.h; } return this.r - other.r; } } public static void main(String[] args) { Scanner sc =  (n == 0) break; List<Doll> dolls = new ArrayList<>(); for (int i = 0; i < n; i++) { int h = sc.nextInt();  = sc.nextInt(); for (int i = 0; i < m; i++) { int h  Collections.sort(dolls); int[] dp = new int[dolls.size()]; Arrays.fill(dp, 1); for (int i = 1; i < dolls.size(); i++) { for (int j = 0; j < i; j++) { if (dolls.get(j).h < dolls.get(i).h && dolls.get(j).r < dolls.get(i).r) { dp[i] = Math.max(dp[i], dp[j] + 1); } } } int max = 0; for  = Math.max(max, dp[i]); } System.out.println(max); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main  Scanner(System.in); int mod = 1000000007; int[][] data; int[] memo; boolean[] use; int n, m, N; void run() { for (;;) { n = sc.nextInt();  int[201][2]; for (int i = 0; i < n; i++) { data[i][0] = sc.nextInt(); data[i][1] = sc.nextInt(); } m = sc.nextInt(); for (int i = n; i < m + n; i++) { data[i][0] = sc.nextInt(); data[i][1]  new int[n + m]; use =  = Math.max(ans, dfs(i)); } System.out.println(ans); } } int dfs(int index) { if (memo[index] > 0) { return memo[index]; } int res = 1; use[index] = true; for (int i = 0; i < N; i++) { if (!use[i]) { if (data[i][0] < data[index][0] && data[i][1] < data[index][1]) { res = Math.max(res, dfs(i) + 1); } } } use[index] = false; return memo[index] = res; } public static void main(String[] args) { new Main().run(); } void debug(Object... o) { System.out.println(Arrays.deepToString(o)); } void debug2(int[][] array) { for (int i = 0; i < array.length; i++) { for (int j = 0;  class MyScanner { int nextInt() { try { int c = System.in.read(); while (c != '-' && (c < '0'  res *= 10; res += c - '0'; c = System.in.read(); } while ('0' <= c && c <= '9'); return res; } catch (Exception e) { return -1; } }  { StringBuilder res  = System.in.read(); do { res.append((char) c); } while (!Character.isWhitespace(c = System.in.read())); return res.toString(); } catch (Exception e) { return null; } } } }"], "original_ll": -0.5554324388504028, "sampled_ll": -0.2872489094734192, "all_perturbed_sampled_ll": [-1.015829086303711], "all_perturbed_original_ll": [-1.1872133016586304], "perturbed_sampled_ll": -1.015829086303711, "perturbed_original_ll": -1.1872133016586304, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from operator import itemgetter\n\ndef f(f1, f2):\n    res = 1\n    c = 0\n    i = 0\n    while c < len(L)-1:\n        if L[i][f1] > L[i+1][f1] and L[i][f2] > L[i+1][f2]:\n            res += 1\n            i += 1\n        else:\n            del L[i+1]\n        c += 1\n    return res\n\nwhile True:\n    n = input()\n    if n == 0: break\n    L = [map(int, raw_input().split()) for i in range(n)]\n    for i in range(input()):\n        L.append(map(int, raw_input().split()))\n    else:\n        h = 0\n        r = 1\n        L.sort(key=itemgetter(0,1), reverse=True)\n        res1 = f(h, r)\n        L.sort(key=itemgetter(1,0), reverse=True)\n        res2 = f(r, h)\n        if res2 < res1:\n            print res1\n        else:\n            print res2", "sampled": "import sys\nfrom bisect import bisect_left\n\ndef longest_chain(dolls):\n    if not dolls:\n        return 0\n    \n    # Sort by height, then by radius\n    dolls.sort()\n    \n    # dp[i] = minimum radius for a chain of length i+1\n    dp = []\n    \n    for h, r in dolls:\n        # Find the longest chain where we can add this doll\n        # We need to find largest index where dp[index] < r\n        pos = bisect_left(dp, r)\n        \n        if pos < len(dp):\n            dp[pos] = r\n        else:\n            dp.append(r)\n    \n    return len(dp)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    dolls1 = []\n    for _ in range(n):\n        h, r = map(int, input().split())\n        dolls1.append((h, r))\n    \n    m = int(input())\n    dolls2 = []\n    for _ in range(m):\n        h, r = map(int, input().split())\n        dolls2.append((h, r))\n    \n    # Combine all dolls\n    all_dolls = dolls1 + dolls2\n    \n    # Find longest chain\n    result = longest_chain(all_dolls)\n    print(result)\n", "perturbed_sampled": ["import sys from bisect import bisect_left def longest_chain(dolls): if not dolls: return 0 # Sort by height, then by radius dolls.sort() # dp[i] = minimum radius for a chain of length i+1 dp = [] for h, r in dolls: # Find the longest chain where we can add this doll # We need to find largest index where  len(dp): dp[pos] = r else: dp.append(r) return len(dp) while True: n = int(input()) if n == 0: break   dolls2.append((h, r)) # Combine all dolls all_dolls = dolls1 + dolls2 # Find longest chain result = longest_chain(all_dolls) print(result)"], "perturbed_original": ["from return res<extra_id_2>i = 0 L<extra_id_3>(int,<extra_id_4>c += = 0 i = 0 while c < len(L)-1: if L[i][f1] > L[i+1][f1] and L[i][f2] > L[i+1][f2]: res += 1 i += <extra_id_5>i<extra_id_6>= L[i+1][f1] if<extra_id_7>in<extra_id_8>f(i+1][f2] > L[i+1][f2]:<extra_id_9>(f1=L[i]][f1] and<extra_id_10>L[i][f2] > L[i+1][f2]: print<extra_id_11>L[i][ True: n = input() if n == 0: break L = [map(int, raw_input().split()) for i in range(n)] for i in range(input()): L.append(map(int, raw_input().split())) else: h = 0 r = 1 L.sort(key=itemgetter(0,1), reverse=True) res1 = f(h, r) L.sort(key=itemgetter(1,0), reverse=True) res2 = f(r, h) if res2 < res1: print res1 else: print res2"], "original_ll": -1.029225468635559, "sampled_ll": -0.9653249382972717, "all_perturbed_sampled_ll": [-2.308661460876465], "all_perturbed_original_ll": [-1.9032952785491943], "perturbed_sampled_ll": -2.308661460876465, "perturbed_original_ll": -1.9032952785491943, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int n,c;\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    for(c=0;n!=1;c++){\n      if(n%2==0){\n\tn/=2;\n      }\n      else{\n\tn=n*3+1;\n      }\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int count = 0;\n        while(n != 1) {\n            if(n % 2 == 0) {\n                n = n / 2;\n            } else {\n                n = 3 * n + 1;\n            }\n            count++;\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) { scanf(\"%d\", &n); if(n == 0) break;  2 == 0) { n = n / 2; } else { n = 3 * n + 1; } count++; } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int n,c; while(1){ scanf(\"%d\",&n); if(n==0)break; for(c=0;n!=1;c++){ if(n%2==0){ n/=2; } else{ n=n*3+1; } } printf(\"%d\\n\",c); } return 0; }"], "original_ll": -0.8196861743927002, "sampled_ll": -0.4779272675514221, "all_perturbed_sampled_ll": [-1.254439353942871], "all_perturbed_original_ll": [-1.018356442451477], "perturbed_sampled_ll": -1.254439353942871, "perturbed_original_ll": -1.018356442451477, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n\n\tfinal Scanner stdin = new Scanner(System.in);\n\n\twhile ( true ) {\n\t    int n = stdin.nextInt();\n\t    if ( n == 0 ) {\n\t\tbreak;\n\t    }\n\n\t    int count = 0;\n\t    while ( n != 1 ) {\n\t\tif ( n % 2 == 0 ) {\n\t\t    n /= 2;\n\t\t} else {\n\t\t    n = n * 3 + 1;\n\t\t}\n\t\tcount++;\n\t    }\n\t    System.out.println( count );\n\t}\t\n    }    \n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            while (n != 1) {\n                if (n % 2 == 0) {\n                    n = n / 2;\n                } else {\n                    n = n * 3 + 1;\n                }\n                count++;\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int count  2 == 0) { n = n / 2; } else { n = n * 3 + 1; } count++; } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import  final Scanner stdin = new Scanner(System.in); while ( true ) { int n = stdin.nextInt(); if ( n == 0 ) { break; } int count = 0; while ( n != 1 ) {  /= 2; } else { n = n * 3 + 1; } count++; } System.out.println( count ); } } }"], "original_ll": -0.7804263234138489, "sampled_ll": -0.3872094452381134, "all_perturbed_sampled_ll": [-1.476989984512329], "all_perturbed_original_ll": [-1.6258050203323364], "perturbed_sampled_ll": -1.476989984512329, "perturbed_original_ll": -1.6258050203323364, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n\tn = int(input())\n\tif n == 0: break\n\tk = 0\n\twhile n > 1:\n\t\tif n & 1:\n\t\t\tn = n + ((n+1)>>1)\n\t\t\tk += 2\n\t\telse:\n\t\t\tn >>= 1\n\t\t\tk += 1\n\tprint(k)\n", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = 0\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        count += 1\n    \n    print(count)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break count = 0 while n != 1: if n %  = 3 * n + 1 count += 1 print(count)"], "perturbed_original": ["while True: n = int(input()) if n == 0: break k = 0 while n > 1: if n & 1: n = n  += 1 print(k)"], "original_ll": -1.0571006536483765, "sampled_ll": -0.5038818717002869, "all_perturbed_sampled_ll": [-1.9069170951843262], "all_perturbed_original_ll": [-1.8571306467056274], "perturbed_sampled_ll": -1.9069170951843262, "perturbed_original_ll": -1.8571306467056274, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\nint n,a[1001],b[1001],c[1001],i,k=1001;\ndouble x,y,z,d[1001],w=10000;\nwhile(1){\nscanf(\"%d\\n\",&n);\nif(n==0){\nbreak;\n}\nfor(i=0;i<n;i++){\nscanf(\"%d %d %d\\n\",&a[i],&b[i],&c[i]);\nx=b[i],y=c[i];\nx=x/100;\nz=y/(x*x);\nif(z>22){\nz=z-22;\n}\nelse{\nz=22-z;\n}\nd[i]=z;\nif((z<w) || (z==w && k>a[i])){\nw=z;\nk=a[i];\n}\n}\nfor(i=0;i<n;i++){\nif(w==d[i]){\nprintf(\"%d\\n\",a[i]);\nbreak;\n}\n}\nw=10000,k=1001;\n}\nreturn 0;\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int best_p = -1;\n        double min_diff = -1;\n        \n        for(int i = 0; i < n; i++) {\n            int p, h, w;\n            scanf(\"%d %d %d\", &p, &h, &w);\n            \n            double height_m = h / 100.0;\n            double bmi = w / (height_m * height_m);\n            double diff = fabs(bmi - 22.0);\n            \n            if(min_diff < 0 || diff < min_diff || (diff == min_diff && p < best_p)) {\n                min_diff = diff;\n                best_p = p;\n            }\n        }\n        \n        printf(\"%d\\n\", best_p);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int n; while(scanf(\"%d\", &n) == 1 && n != 0) { int best_p = -1; double min_diff = -1; for(int i = 0; i < n; i++) { int p, h, w; scanf(\"%d %d %d\", &p, &h, &w); double height_m = h / 100.0; double bmi = w / (height_m * height_m); double diff = fabs(bmi - 22.0); if(min_diff  && p < best_p))  best_p); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int n,a[1001],b[1001],c[1001],i,k=1001; double x,y,z,d[1001],w=10000; while(1){ scanf(\"%d\\n\",&n); if(n==0){ break; } for(i=0;i<n;i++){ scanf(\"%d %d %d\\n\",&a[i],&b[i],&c[i]); x=b[i],y=c[i]; x=x/100; z=y/(x*x); if(z>22){ z=z-22; } else{ z=22-z; } d[i]=z; if((z<w)  printf(\"%d\\n\",a[i]); break; } } w=10000,k=1001; } return 0; }"], "original_ll": -1.132500171661377, "sampled_ll": -0.802773654460907, "all_perturbed_sampled_ll": [-1.5030254125595093], "all_perturbed_original_ll": [-1.378659963607788], "perturbed_sampled_ll": -1.5030254125595093, "perturbed_original_ll": -1.378659963607788, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tR[] rs;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint id=sc.nextInt();\n\t\t\t\tint h=sc.nextInt();\n\t\t\t\tint w=sc.nextInt();\n\t\t\t\trs[i]=new R(id, h, w);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tArrays.sort(rs);\n\t\tprintln(\"\"+rs[0].id);\n\t}\n\n\tclass R implements Comparable<R>{\n\t\tint id;\n\t\tdouble error;\n\n\t\tR(int id, int h, int w){\n\t\t\tthis.id=id;\n\t\t\terror=Math.abs(22-10000.*w/h/h);\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(R r){\n\t\t\tif(error+EPS<r.error){\n\t\t\t\treturn -1;\n\t\t\t}else if(error>r.error+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn id-r.id;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int bestP = Integer.MAX_VALUE;\n            double minDiff = Double.MAX_VALUE;\n            \n            for (int i = 0; i < n; i++) {\n                int p = sc.nextInt();\n                int h = sc.nextInt();\n                int w = sc.nextInt();\n                \n                double heightInMeters = h / 100.0;\n                double bmi = w / (heightInMeters * heightInMeters);\n                double diff = Math.abs(bmi - 22.0);\n                \n                if (diff < minDiff || (diff == minDiff && p < bestP)) {\n                    minDiff = diff;\n                    bestP = p;\n                }\n            }\n            \n            System.out.println(bestP);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main  new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int bestP = Integer.MAX_VALUE; double minDiff = Double.MAX_VALUE; for (int i = 0; i < n; i++) { int  sc.nextInt(); double heightInMeters = h / 100.0; double bmi = w / (heightInMeters *  minDiff || (diff == minDiff && p < bestP)) { minDiff = diff; bestP = p; } } System.out.println(bestP); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.lang.*; import java.math.*; import java.io.*; import static java.lang.Math.*; import static java.util.Arrays.*; public class Main{ Scanner sc=new Scanner(System.in); int INF=1<<28; double EPS=1e-9; int n; R[] rs; void run(){ for(;;){ n=sc.nextInt(); if(n==0){ break; } rs=new R[n]; for(int i=0; i<n; i++){ int id=sc.nextInt(); int h=sc.nextInt(); int w=sc.nextInt();  Arrays.sort(rs);  R(int id, int h, int w){ this.id=id; error=Math.abs(22-10000.*w/h/h); } @Override public int compareTo(R r){ if(error+EPS<r.error){ return -1; }else if(error>r.error+EPS){ return 1; }else{ return id-r.id; } } } void debug(Object... os){ System.err.println(Arrays.deepToString(os)); } void print(String s){ System.out.print(s); } void println(String  PrintStream(new BufferedOutputStream(System.out))); new Main().run(); } }"], "original_ll": -1.0101274251937866, "sampled_ll": -0.6852039694786072, "all_perturbed_sampled_ll": [-1.7867521047592163], "all_perturbed_original_ll": [-1.6988458633422852], "perturbed_sampled_ll": -1.7867521047592163, "perturbed_original_ll": -1.6988458633422852, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = input()\n    if n == 0: break\n    pb = None\n    ans = 0\n    for i in range(n):\n        i, h, w = map(int, raw_input().split())\n        bmi = w/((float(h)/100)**2)\n        a = abs(22-bmi)\n        if pb is None:\n            pb = a\n            ans = i\n        elif pb is not None and a < pb:\n            pb = a\n            ans = i\n    else:\n        print ans", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    best_person = None\n    best_diff = float('inf')\n    \n    for _ in range(n):\n        data = list(map(int, input().split()))\n        p, h, w = data[0], data[1], data[2]\n        \n        # Convert height from cm to m\n        h_m = h / 100.0\n        \n        # Calculate BMI\n        bmi = w / (h_m * h_m)\n        \n        # Calculate difference from ideal BMI (22)\n        diff = abs(bmi - 22)\n        \n        # Update best if this is closer, or same distance but smaller reception number\n        if diff < best_diff or (diff == best_diff and p < best_person):\n            best_diff = diff\n            best_person = p\n    \n    print(best_person)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break best_person = None best_diff = float('inf') for _ in range(n): data = list(map(int, input().split())) p, h, w = data[0], data[1], data[2] # Convert height from cm to m h_m = h  * h_m) # Calculate difference from ideal BMI (22) diff = abs(bmi - 22) # Update best if this is closer, or same distance but smaller reception number  < best_person): best_diff = diff best_person = p print(best_person)"], "perturbed_original": ["while True: n = input() if n == 0: break pb = None ans = 0 for i in range(n): i, h, w = map(int,  None: pb = a ans = i elif pb is not None and a < pb: pb = a ans = i else: print ans"], "original_ll": -1.4683277606964111, "sampled_ll": -1.0928175449371338, "all_perturbed_sampled_ll": [-2.355005979537964], "all_perturbed_original_ll": [-2.5511250495910645], "perturbed_sampled_ll": -2.355005979537964, "perturbed_original_ll": -2.5511250495910645, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int n,x,y,h,w,s,s1,s2,a,i;\n  int m[]={600,800,1000,1200,1400,1600,0};\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    a=0;\n    for(i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x,&y,&h,&w);\n      if     (x+y+h>160)s1=6;\n      else if(x+y+h>140)s1=5;\n      else if(x+y+h>120)s1=4;\n      else if(x+y+h>100)s1=3;\n      else if(x+y+h> 80)s1=2;\n      else if(x+y+h> 60)s1=1;\n      else              s1=0;\n      if     (w>25)s2=6;\n      else if(w>20)s2=5;\n      else if(w>15)s2=4;\n      else if(w>10)s2=3;\n      else if(w>5 )s2=2;\n      else if(w>2 )s2=1;\n      else         s2=0;\n      if(s1>s2)s=s1;\n      else     s=s2;\n      a+=m[s];\n    }\n    printf(\"%d\\n\",a);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        int total = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int x, y, h, w;\n            scanf(\"%d %d %d %d\", &x, &y, &h, &w);\n            \n            int size = x + y + h;\n            int price = 0;\n            \n            // Determine the category based on size and weight\n            if (size <= 60 && w <= 2) {\n                price = 600;\n            } else if (size <= 80 && w <= 5) {\n                price = 800;\n            } else if (size <= 100 && w <= 10) {\n                price = 1000;\n            } else if (size <= 120 && w <= 15) {\n                price = 1200;\n            } else if (size <= 140 && w <= 20) {\n                price = 1400;\n            } else if (size <= 160 && w <= 25) {\n                price = 1600;\n            }\n            // If it exceeds F size, price remains 0 and won't be added\n            \n            total += price;\n        }\n        \n        printf(\"%d\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while (1) <extra_id_6>= (i%100; return 0<extra_id_7>/<extra_id_23>] =<extra_id_24>c - 0.725 ; double<extra_id_25>; double = 0; for (int i = 0; i < n;  %d\", &x, &y, &h, &w); int size = x + y + h; int price = 0; // Determine the category based on  2) { price = 600; } else if (size <= 80 && w <= 5) { price = 800; } else if (size <= 100 && w <= 10) { price = 1000; } else if (size <= 120 && w <= 15) { price = 1200; } else if (size <= 140 && w <= 20) { price = 1400; } else if (size <= 160 && w <= 25) { price = 1600;  total); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int n,x,y,h,w,s,s1,s2,a,i; int m[]={600,800,1000,1200,1400,1600,0}; while(1){ scanf(\"%d\",&n); if(n==0)break; a=0; for(i=0;i<n;i++){ scanf(\"%d %d %d %d\",&x,&y,&h,&w);  80)s1=2; else if(x+y+h> 60)s1=1; else s1=0; if (w>25)s2=6; else if(w>20)s2=5; else if(w>15)s2=4; else if(w>10)s2=3; else if(w>5 )s2=2; else if(w>2 )s2=1; else s2=0; if(s1>s2)s=s1; else s=s2; a+=m[s]; } printf(\"%d\\n\",a); } return 0; }"], "original_ll": -0.7838627099990845, "sampled_ll": -0.6224116086959839, "all_perturbed_sampled_ll": [-1.8244128227233887], "all_perturbed_original_ll": [-1.1516640186309814], "perturbed_sampled_ll": -1.8244128227233887, "perturbed_original_ll": -1.1516640186309814, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Map.Entry;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\n/**\n * Delivery Fee\n */\npublic class Main {\n\n\tstatic P0160 main = new P0160();\n\tstatic TreeMap<Parcel, Integer> fee = new TreeMap<Parcel, Integer>() {\n\t\t{\n\t\t\tput(main.new Parcel(60, 2), 600);\n\t\t\tput(main.new Parcel(80, 5), 800);\n\t\t\tput(main.new Parcel(100, 10), 1000);\n\t\t\tput(main.new Parcel(120, 15), 1200);\n\t\t\tput(main.new Parcel(140, 20), 1400);\n\t\t\tput(main.new Parcel(160, 25), 1600);\n\t\t}\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n, sum = 0;\n\t\t\tn = Integer.parseInt(line);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tParcel p = main.new Parcel(br.readLine());\n\t\t\t\tEntry<Parcel, Integer> e;\n\t\t\t\tif ((e = fee.ceilingEntry(p)) != null) {\n\t\t\t\t\tsum += e.getValue();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tclass Parcel implements Comparable<Parcel> {\n\t\tint size, weight;\n\n\t\tParcel(int size, int weight) {\n\t\t\tthis.size = size;\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tParcel(int x, int y, int h, int w) {\n\t\t\tthis(x + y + h, w);\n\t\t}\n\n\t\tParcel(String info) {\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tint x, y, h, w;\n\t\t\tx = Integer.parseInt(st.nextToken());\n\t\t\ty = Integer.parseInt(st.nextToken());\n\t\t\th = Integer.parseInt(st.nextToken());\n\t\t\tw = Integer.parseInt(st.nextToken());\n\t\t\tsize = x + y + h;\n\t\t\tweight = w;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Parcel o) {\n\t\t\tint r1 = this.weight - o.weight;\n\t\t\tint r2 = this.size - o.size;\n\t\t\tif (r1 > 0 || r2 > 0) {\n\t\t\t\treturn 1;\n\t\t\t} else if (r1 == 0 && r2 == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int totalCost = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                int h = sc.nextInt();\n                int w = sc.nextInt();\n                \n                int size = x + y + h;\n                int cost = getPrice(size, w);\n                totalCost += cost;\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        sc.close();\n    }\n    \n    static int getPrice(int size, int weight) {\n        int[] sizeLimits = {60, 80, 100, 120, 140, 160};\n        int[] weightLimits = {2, 5, 10, 15, 20, 25};\n        int[] prices = {600, 800, 1000, 1200, 1400, 1600};\n        \n        for (int i = 0; i < 6; i++) {\n            if (size <= sizeLimits[i] && weight <= weightLimits[i]) {\n                return prices[i];\n            }\n        }\n        \n        return 0;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n  = 0; i < n; i++) { int x = sc.nextInt(); int y = sc.nextInt(); int h = sc.nextInt(); int w = sc.nextInt(); int size = x + y + h; int cost = getPrice(size, w); totalCost += cost; } System.out.println(totalCost); } sc.close(); } static int getPrice(int size, int weight) { int[] sizeLimits = {60, 80, 100, 120, 140, 160}; int[] weightLimits =  800, 1000, 1200, 1400, 1600}; for (int i = 0; i <  }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Map.Entry; import java.util.StringTokenizer; import java.util.TreeMap; /** * Delivery  new P0160(); static TreeMap<Parcel, Integer> fee = new TreeMap<Parcel, Integer>() { { put(main.new Parcel(60, 2), 600); put(main.new Parcel(80, 5), 800); put(main.new Parcel(100, 10), 1000); put(main.new Parcel(120, 15), 1200); put(main.new Parcel(140, 20), 1400); put(main.new Parcel(160, 25), 1600); } }; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = \"\"; while (!(line = br.readLine()).equals(\"0\")) { int n, sum  i < n; ++i) { Parcel p = main.new Parcel(br.readLine()); Entry<Parcel, Integer> e; if ((e  System.out.println(sum); } }  int weight) { this.size = size; this.weight = weight; } Parcel(int x, int y, int h, int w) { this(x + y + h, w);  x, y, h, w; x = Integer.parseInt(st.nextToken()); y = Integer.parseInt(st.nextToken()); h = Integer.parseInt(st.nextToken()); w = Integer.parseInt(st.nextToken()); size = x + y + h; weight = w; } @Override public int compareTo(Parcel o) { int r1 = this.weight -  else if (r1 == 0 && r2 == 0) { return 0; } else { return -1; } } } }"], "original_ll": -0.6943483352661133, "sampled_ll": -0.49310070276260376, "all_perturbed_sampled_ll": [-1.099674105644226], "all_perturbed_original_ll": [-1.3944531679153442], "perturbed_sampled_ll": -1.099674105644226, "perturbed_original_ll": -1.3944531679153442, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "size = [60,80,100,120,140,160]        \nweight = [2,5,10,16,20,25]\nfee= [600,800,1000,1200,1400,1600]\nwhile True:\n    n = int(input())\n    if n==0:\n        break\n    total = 0\n    for _ in range(n):\n        [x,y,h,wt] = list(map(int, input().split()))\n        sz = x+y+h\n        if sz > size[-1] or wt > weight[-1]:\n            #print(\"NotAccept\")\n            continue\n        isz = len(list(filter(lambda x: x<sz,   size)))\n        iwt = len(list(filter(lambda x: x<wt, weight)))\n        f   = fee[max(isz,iwt)]\n        #print(\"%d %d %d %d %d\" % (x,y,h,wt,f))\n        total += f\n\n    print(total)", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    total = 0\n    for _ in range(n):\n        x, y, h, w = map(int, input().split())\n        size = x + y + h\n        \n        # Determine the category based on size and weight\n        if size <= 60 and w <= 2:\n            total += 600\n        elif size <= 80 and w <= 5:\n            total += 800\n        elif size <= 100 and w <= 10:\n            total += 1000\n        elif size <= 120 and w <= 15:\n            total += 1200\n        elif size <= 140 and w <= 20:\n            total += 1400\n        elif size <= 160 and w <= 25:\n            total += 1600\n        # If exceeds F size, don't add to total\n    \n    print(total)\n", "perturbed_sampled": ["while  = 0 for _ in range(n): x, y, h, w = map(int, input().split()) size = x + y + h # Determine the category based on size and weight if size <= 60 and w <= 2: total += 600 elif size <= 80 and w <= 5: total += 800 elif size <= 100 and w <= 10: total +=   total += 1400 elif size <= 160 and w <= 25: total += 1600 # If exceeds F size, don't add to total print(total)"], "perturbed_original": ["size = [60,80,100,120,140,160] weight = [2,5,10,16,20,25] fee=  = 0 for _ in range(n): [x,y,h,wt] = list(map(int, input().split())) sz = x+y+h if sz > size[-1] or wt > weight[-1]: #print(\"NotAccept\") continue isz = len(list(filter(lambda x: x<sz, size))) iwt = len(list(filter(lambda x: x<wt, weight))) f = fee[max(isz,iwt)] #print(\"%d %d %d %d %d\" % (x,y,h,wt,f)) total += f print(total)"], "original_ll": -1.3326005935668945, "sampled_ll": -0.7946252226829529, "all_perturbed_sampled_ll": [-1.8378522396087646], "all_perturbed_original_ll": [-1.888445258140564], "perturbed_sampled_ll": -1.8378522396087646, "perturbed_original_ll": -1.888445258140564, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct\n{\n\tint c;\n\tint m[4];\n\tint s[4];\n} TEAM;\n\nint comparison(const void* a, const void* b);\n\nint main(void)\n{\n\tint n;\n\tTEAM* team;\n\t\n\twhile (scanf(\"%d\", &n) * n != 0){\n\t\tint i;\n\t\t\n\t\tteam = (TEAM*)calloc(n, sizeof(TEAM));\n\t\tfor (i = 0; i < n; i++){\n\t\t\tint j;\n\t\t\t\n\t\t\tscanf(\"%d\", &team[i].c);\n\t\t\tfor (j = 0; j < 4; j++){\n\t\t\t\tscanf(\"%d %d\", &team[i].m[j], &team[i].s[j]);\n\t\t\t}\n\t\t}\n\t\tqsort(team, n, sizeof(TEAM), comparison);\n\t\tprintf(\"%d\\n\", team[0].c);\n\t\tprintf(\"%d\\n\", team[1].c);\n\t\tprintf(\"%d\\n\", team[n - 2].c);\n\t\t\n\t\tfree(team);\n\t}\n\t\n\treturn 0;\n}\n\nint comparison(const void* a, const void* b)\n{\n\tint sum_a, sum_b;\n\tint i;\n\t\n\tsum_a = sum_b = 0;\n\tfor (i = 0; i < 4; i++){\n\t\tsum_a += ((TEAM*)a)->m[i] * 60 + ((TEAM*)a)->s[i];\n\t\tsum_b += ((TEAM*)b)->m[i] * 60 + ((TEAM*)b)->s[i];\n\t}\n\tif (sum_a > sum_b){\n\t\treturn 1;\n\t}\n\telse if (sum_a < sum_b){\n\t\treturn -1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int total_time;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    return ta->total_time - tb->total_time;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Team *teams = (Team *)malloc(n * sizeof(Team));\n        \n        for (int i = 0; i < n; i++) {\n            int id, m1, s1, m2, s2, m3, s3, m4, s4;\n            scanf(\"%d %d %d %d %d %d %d %d %d\", &id, &m1, &s1, &m2, &s2, &m3, &s3, &m4, &s4);\n            \n            teams[i].id = id;\n            teams[i].total_time = (m1 * 60 + s1) + (m2 * 60 + s2) + (m3 * 60 + s3) + (m4 * 60 + s4);\n        }\n        \n        qsort(teams, n, sizeof(Team), compare);\n        \n        printf(\"%d\\n\", teams[0].id);\n        printf(\"%d\\n\", teams[1].id);\n        printf(\"%d\\n\", teams[n-2].id);\n        \n        free(teams);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int id; int total_time; } Team; int compare(const void *a, const void *b) { Team *ta = (Team *)a; Team *tb = (Team *)b; return ta->total_time - tb->total_time; } int main() { int n; while (scanf(\"%d\", &n) == 1  * sizeof(Team)); for (int i = 0; i  m3, s3, m4, s4; scanf(\"%d %d %d %d %d %d %d %d %d\", &id, &m1, &s1, &m2, &s2, &m3, &s3, &m4, &s4); teams[i].id = id;  60 + s2) + (m3 * 60 + s3) + (m4 * 60 +  printf(\"%d\\n\", teams[n-2].id); free(teams); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> typedef struct { int c; int m[4]; int s[4]; } TEAM; int comparison(const void* a, const void* b); int main(void) { int n; TEAM* team; while (scanf(\"%d\", &n) * n != 0){ int  &team[i].s[j]); } } qsort(team, n, sizeof(TEAM), comparison); printf(\"%d\\n\", team[0].c); printf(\"%d\\n\", team[1].c); printf(\"%d\\n\", team[n - 2].c); free(team); } return 0; } int comparison(const void* a, const void* b) { int sum_a, sum_b; int i; sum_a = sum_b = 0; for (i = 0; i < 4; i++){ sum_a += ((TEAM*)a)->m[i] * 60 + ((TEAM*)a)->s[i]; sum_b += ((TEAM*)b)->m[i] * 60 + ((TEAM*)b)->s[i]; } if  sum_b){ return -1; } else { return 0; } }"], "original_ll": -0.6397964954376221, "sampled_ll": -0.38309040665626526, "all_perturbed_sampled_ll": [-1.165002465248108], "all_perturbed_original_ll": [-1.210587978363037], "perturbed_sampled_ll": -1.165002465248108, "perturbed_original_ll": -1.210587978363037, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main\n{\n    public static void main(String args[])\n    {\n\tScanner scan=new Scanner(System.in);\n\twhile(true)\n\t    {\n\t\tint n=scan.nextInt();\n\t\tif(n==0)break;\n\t\tint num[]=new int[n];\n\t\tint sum[]=new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\tnum[i]=scan.nextInt();\n\t\t\tfor(int j=0;j<8;j++)\n\t\t\t    {\n\t\t\t\tif(j%2==0)sum[i]+=60*(scan.nextInt());\n\t\t\t\telse sum[i]+=scan.nextInt();\n\t\t\t    }\n\t\t    }\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\tint min=sum[i],x=i;\n\t\t\tfor(int j=i;j<n;j++)\n\t\t\t    {\n\t\t\t\tif(min>sum[j])\n\t\t\t\t    {\n\t\t\t\t\tmin=sum[j];\n\t\t\t\t\tx=j;\n\t\t\t\t\t\n\t\t\t\t    }\n\t\t\t    }\n\t\t\tint tmp=num[i];\n\t\t\tnum[i]=num[x];\n\t\t\tnum[x]=tmp;\n\t\t\tint tmp2=sum[i];\n\t\t\tsum[i]=sum[x];\n\t\t\tsum[x]=tmp2;\n\t\t    }\n\t\t\n\t\tSystem.out.println(num[0]);\n\t\tSystem.out.println(num[1]);\n\t\tSystem.out.println(num[n-2]);\n\t    }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Team implements Comparable<Team> {\n        int id;\n        int totalSeconds;\n        \n        Team(int id, int totalSeconds) {\n            this.id = id;\n            this.totalSeconds = totalSeconds;\n        }\n        \n        @Override\n        public int compareTo(Team other) {\n            return this.totalSeconds - other.totalSeconds;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            Team[] teams = new Team[n];\n            \n            for (int i = 0; i < n; i++) {\n                int id = sc.nextInt();\n                int totalSeconds = 0;\n                \n                for (int j = 0; j < 4; j++) {\n                    int m = sc.nextInt();\n                    int s = sc.nextInt();\n                    totalSeconds += m * 60 + s;\n                }\n                \n                teams[i] = new Team(id, totalSeconds);\n            }\n            \n            Arrays.sort(teams);\n            \n            System.out.println(teams[0].id);\n            System.out.println(teams[1].id);\n            System.out.println(teams[n - 2].id);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Team implements  { this.id = id; this.totalSeconds = totalSeconds; } @Override public int compareTo(Team other)  main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; Team[] teams = new Team[n]; for (int i = 0; i < n; i++) { int id = sc.nextInt(); int  4; j++) { int m = sc.nextInt(); int s = sc.nextInt(); totalSeconds += m * 60 + s; } teams[i] = new Team(id, totalSeconds); } Arrays.sort(teams); System.out.println(teams[0].id); System.out.println(teams[1].id); System.out.println(teams[n - 2].id); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String args[]) { Scanner scan=new Scanner(System.in); while(true) { int n=scan.nextInt(); if(n==0)break; int num[]=new int[n]; int sum[]=new int[n]; for(int i=0;i<n;i++) { num[i]=scan.nextInt(); for(int j=0;j<8;j++) { if(j%2==0)sum[i]+=60*(scan.nextInt()); else sum[i]+=scan.nextInt(); } } for(int i=0;i<n;i++) { int min=sum[i],x=i; for(int j=i;j<n;j++) { if(min>sum[j]) { min=sum[j]; x=j;  } System.out.println(num[0]); System.out.println(num[1]); System.out.println(num[n-2]); } } }"], "original_ll": -0.8493826389312744, "sampled_ll": -0.4516538083553314, "all_perturbed_sampled_ll": [-1.1912219524383545], "all_perturbed_original_ll": [-1.1002148389816284], "perturbed_sampled_ll": -1.1912219524383545, "perturbed_original_ll": -1.1002148389816284, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n=int(input())\n    if n==0:break\n    a={}\n    for _ in range(n):\n        b=list(map(int,input().split()))\n        a[b[0]]=sum(b[1:8:2])*60+sum(b[2:9:2])\n    a=sorted(a.items(),key=lambda x:x[1])\n    for i in [0,1,-2]:print(a[i][0])", "sampled": "import sys\n\ndef solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        teams = []\n        for _ in range(n):\n            parts = list(map(int, input().split()))\n            team_id = parts[0]\n            \n            # Calculate total time in seconds\n            total_seconds = 0\n            for i in range(1, 9, 2):\n                minutes = parts[i]\n                seconds = parts[i + 1]\n                total_seconds += minutes * 60 + seconds\n            \n            teams.append((total_seconds, team_id))\n        \n        # Sort by total time\n        teams.sort()\n        \n        # Winner: smallest time (index 0)\n        winner = teams[0][1]\n        # Runner-up: second smallest time (index 1)\n        runner_up = teams[1][1]\n        # Booby prize: second to last (index n-2)\n        booby = teams[n - 2][1]\n        \n        print(winner)\n        print(runner_up)\n        print(booby)\n\nsolve()\n", "perturbed_sampled": ["import sys def solve(): while True: n = int(input()) if n == 0:  list(map(int, input().split())) team_id = parts[0] # Calculate total time in seconds total_seconds = 0 for i in range(1, 9, 2):  minutes * 60 + seconds teams.append((total_seconds, team_id)) # Sort by total time teams.sort() # Winner: smallest time (index 0) winner  = teams[1][1] # Booby prize: second to last (index n-2) booby = teams[n - 2][1] print(winner) print(runner_up) print(booby) solve()"], "perturbed_original": ["while 1: n=int(input()) if n==0:break a={} for _ in range(n): b=list(map(int,input().split())) a[b[0]]=sum(b[1:8:2])*60+sum(b[2:9:2]) a=sorted(a.items(),key=lambda x:x[1]) for i in [0,1,-2]:print(a[i][0])"], "original_ll": -1.3816105127334595, "sampled_ll": -1.039450764656067, "all_perturbed_sampled_ll": [-2.335449695587158], "all_perturbed_original_ll": [-1.7152557373046875], "perturbed_sampled_ll": -2.335449695587158, "perturbed_original_ll": -1.7152557373046875, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[110][110];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j,a,b;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<110;i++){\n      for(j=0;j<110;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d){a=4;b=2;}\n      else {a=2;b=4;}\n\tfor(i=y;i<y+a;i++){\n\t  for(j=x;j<x+b;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n\n    }\n    c=boad[xs][ys];\n \n  \n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    /*for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\nprintf(\"%2d\",boad[i][j]);\n      printf(\"\\n\");\n      }*/\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  if(x<=0||x>w||y<=0||y>h||boad[x][y]!=c)return 0;\n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i)+abs(j)==1 && boad[x+i][y+j]!=-1)\n\tif(dfs(x+i,y+j))return 1;\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 1000000\n\nint hamming[100000];\nint hamming_count = 0;\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nvoid generate_hamming() {\n    hamming[hamming_count++] = 1;\n    \n    int i2 = 0, i3 = 0, i5 = 0;\n    int next_2 = 2, next_3 = 3, next_5 = 5;\n    \n    while (1) {\n        int next = next_2;\n        if (next_3 < next) next = next_3;\n        if (next_5 < next) next = next_5;\n        \n        if (next > MAX) break;\n        \n        hamming[hamming_count++] = next;\n        \n        if (next == next_2) {\n            i2++;\n            next_2 = hamming[i2] * 2;\n        }\n        if (next == next_3) {\n            i3++;\n            next_3 = hamming[i3] * 3;\n        }\n        if (next == next_5) {\n            i5++;\n            next_5 = hamming[i5] * 5;\n        }\n    }\n}\n\nint binary_search_lower(int val) {\n    int left = 0, right = hamming_count - 1;\n    int result = hamming_count;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (hamming[mid] >= val) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return result;\n}\n\nint binary_search_upper(int val) {\n    int left = 0, right = hamming_count - 1;\n    int result = -1;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (hamming[mid] <= val) {\n            result = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    generate_hamming();\n    \n    int m, n;\n    while (1) {\n        scanf(\"%d\", &m);\n        if (m == 0) break;\n        scanf(\"%d\", &n);\n        \n        int lower = binary_search_lower(m);\n        int upper = binary_search_upper(n);\n        \n        if (lower <= upper) {\n            printf(\"%d\\n\", upper - lower + 1);\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #define  void *a, const void *b) { return (*(int*)a - *(int*)b); } void generate_hamming() { hamming[hamming_count++] = 1; int i2 = 0, i3 = 0, i5 = 0; int next_2 = 2, next_3 = 3, next_5 =  < next) next = next_3; if  break; hamming[hamming_count++] = next; if (next == next_2) { i2++; next_2 = hamming[i2] * 2; } if (next == next_3) { i3++; next_3 = hamming[i3]  = hamming[i5] * 5; } } } int binary_search_lower(int  1; int result = hamming_count; while   right = mid - 1; } else { left = mid + 1; } } return result; } int binary_search_upper(int val) { int  = -1; while (left <= right) { int mid = (left + right) / 2; if (hamming[mid] <= val) { result = mid; left = mid + 1; } else { right = mid - 1; } } return result; } int main() { generate_hamming(); int m, n; while (1) { scanf(\"%d\", &m); if (m == 0) break; scanf(\"%d\", &n); int lower = binary_search_lower(m); int upper = binary_search_upper(n); if (lower <= upper) { printf(\"%d\\n\", upper - lower + 1); } else { printf(\"0\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h> int dfs(int,int); int boad[110][110]; int w,h,xs,ys,xg,yg,n,c,d; int main(void){ int x,y,i,j,a,b; while(1){ scanf(\"%d %d\",&w,&h); if(w==0 && h==0)break; scanf(\"%d %d\",&xs,&ys); scanf(\"%d %d\",&xg,&yg); scanf(\"%d\",&n); for(i=0;i<110;i++){ for(j=0;j<110;j++){ boad[i][j]=-1; } } int k; for(k=0;k<n;k++){ scanf(\"%d %d %d %d\",&c,&d,&x,&y); if(d){a=4;b=2;} else {a=2;b=4;} for(i=y;i<y+a;i++){ for(j=x;j<x+b;j++){ boad[i][j]=c; } } } c=boad[xs][ys]; if(dfs(xs,ys))printf(\"OK\\n\"); else printf(\"NG\\n\"); /*for(i=0;i<15;i++){ for(j=0;j<15;j++) printf(\"%2d\",boad[i][j]); printf(\"\\n\"); }*/ } return 0; } int dfs(int x,int  } } return 0; }"], "original_ll": -1.0129550695419312, "sampled_ll": -0.45382261276245117, "all_perturbed_sampled_ll": [-1.302976131439209], "all_perturbed_original_ll": [-1.1826691627502441], "perturbed_sampled_ll": -1.302976131439209, "perturbed_original_ll": -1.1826691627502441, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint m, n;\n\t\tint a;\n\t\t\n\t\tint count;\n\t\t\n\t\twhile(true){\n\t\t\tm = scan.nextInt();\n\t\t\tn = scan.nextInt();\n\t\t\tif(m == 0)break;\n\t\t\t\n\t\t\tcount = 0;\n\t\t\tfor(int i = m;i <= n; i++){\n\t\t\t\ta = i;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(a == 1){\n\t\t\t\t\t\tcount++;;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(a % 2 != 0 && a % 3 != 0 && a % 5 != 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(a % 2 == 0)a /= 2;\n\t\t\t\t\telse if(a % 3 == 0)a /= 3;\n\t\t\t\t\telse if(a % 5 == 0)a /= 5;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Precompute all Hamming numbers up to 1000000\n        TreeSet<Long> hammingSet = new TreeSet<>();\n        long limit = 1000000;\n        \n        for (long i = 1; i <= limit; i *= 2) {\n            for (long j = i; j <= limit; j *= 3) {\n                for (long k = j; k <= limit; k *= 5) {\n                    hammingSet.add(k);\n                }\n            }\n        }\n        \n        List<Long> hamming = new ArrayList<>(hammingSet);\n        \n        while (true) {\n            int m = sc.nextInt();\n            if (m == 0) break;\n            int n = sc.nextInt();\n            \n            int count = 0;\n            for (long h : hamming) {\n                if (h >= m && h <= n) {\n                    count++;\n                } else if (h > n) {\n                    break;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); // Precompute all Hamming numbers up to  for (long i = 1; i <= limit; i  limit; j *=  k *= 5) { hammingSet.add(k); } } } List<Long> hamming = new ArrayList<>(hammingSet); while (true) { int m = sc.nextInt(); if (m == 0) break; int n = sc.nextInt(); int count = 0; for (long h : hamming) { if (h >= m && h <= n) { count++; } else if (h > n) { break; } } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String[] args){ Scanner scan = new Scanner(System.in); int m, n; int a; int count; while(true){ m = scan.nextInt(); n = scan.nextInt(); if(m  n; i++){ a = i; while(true){ if(a == 1){  % 3 != 0 && a % 5 != 0){ break; } if(a % 2 == 0)a /= 2; else if(a % 3 == 0)a /= 3; else if(a %  }"], "original_ll": -0.7110258340835571, "sampled_ll": -0.6186495423316956, "all_perturbed_sampled_ll": [-1.4959713220596313], "all_perturbed_original_ll": [-1.6025404930114746], "perturbed_sampled_ll": -1.4959713220596313, "perturbed_original_ll": -1.6025404930114746, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\nwhile True:\n    try:\n        m, n = map(int, raw_input().split())\n\n        f2 = int(math.log(n, 2)) + 1\n        f3 = int(math.log(n, 3)) + 1\n        f5 = int(math.log(n, 5)) + 1\n\n        c = 0\n        for i in range(f2):\n            for j in range(f3):\n                for k in range(f5):\n                    if m <= (2 ** i) * (3 ** j) * (5 ** k) <= n:\n                        c += 1\n        print c\n\n    except ValueError:\n        break", "sampled": "import heapq\n\ndef generate_hamming_numbers(limit):\n    hamming = set([1])\n    heap = [1]\n    \n    while heap:\n        h = heapq.heappop(heap)\n        if h > limit:\n            break\n        \n        for factor in [2, 3, 5]:\n            new_num = h * factor\n            if new_num <= limit and new_num not in hamming:\n                hamming.add(new_num)\n                heapq.heappush(heap, new_num)\n    \n    return sorted(hamming)\n\n# Pre-generate all Hamming numbers up to 1000000\nhamming_numbers = generate_hamming_numbers(1000000)\n\nwhile True:\n    line = input().strip()\n    if line == \"0\":\n        break\n    \n    m, n = map(int, line.split())\n    \n    # Binary search for the range\n    count = 0\n    for h in hamming_numbers:\n        if h < m:\n            continue\n        if h > n:\n            break\n        count += 1\n    \n    print(count)\n", "perturbed_sampled": ["import heapq def generate_hamming_numbers(limit): hamming = set([1]) heap = [1] while heap: h = heapq.heappop(heap) if h > limit: break for <extra_id_10>= hamming_numbers if h<extra_id_11>[ h<extra_id_12>1<extra_id_13>>=<extra_id_14>. max<extra_id_15>min ( h ,<extra_id_16>print ( n if new_num <= limit and new_num not in hamming: hamming.add(new_num) heapq.heappush(heap, new_num) return sorted(hamming) # Pre-generate all Hamming numbers up to 1000000 hamming_numbers = generate_hamming_numbers(1000000) while True: line = input().strip() if line == \"0\": break m, n = map(int, line.split()) # Binary search for the range count = 0 for  > n: break count += 1 print(count)"], "perturbed_original": ["import math while True: try: m, n = map(int, raw_input().split()) f2 = int(math.log(n,  = int(math.log(n, 5)) + 1 c = 0 for i in  m <= (2 ** i) * (3 ** j) * (5 ** k) <= n: c += 1 print c except ValueError: break"], "original_ll": -0.8032776117324829, "sampled_ll": -0.8577947616577148, "all_perturbed_sampled_ll": [-2.1221916675567627], "all_perturbed_original_ll": [-2.19124174118042], "perturbed_sampled_ll": -2.1221916675567627, "perturbed_original_ll": -2.19124174118042, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  const int d[8][8]={\n    {0,0,  0,  0,  0,  0,   0,  0},\n    {0,0,300,500,600,700,1350,1650},\n    {0,0,  0,350,450,600,1150,1500},\n    {0,0,  0,  0,250,400,1000,1350},\n    {0,0,  0,  0,  0,250, 850,1300},\n    {0,0,  0,  0,  0,  0, 600,1150},\n    {0,1,  0,  0,  0,  0,   0, 500},\n    {0,1,  1,  1,  1,  1,   0,   0}\n  };\n  int n,m,ih,it,oh,ot;\n  int p=0;\n  while(1){\n    scanf(\"%d\",&n);\n    if(!n)break;\n    scanf(\"%d %d %d %d %d\",&ih,&it,&m,&oh,&ot);\n    if(n>m){\n      p=n;\n      n=m;\n      m=p;\n    }\n    p=d[n][m];\n    it+=60*ih;\n    ot+=60*oh;\n    if(d[m][n]==0&&\n       ((17*60+30<=it&&it<=19*60+30)||\n\t17*60+30<=ot&&ot<=19*60+30))p/=2;\n    if(p%50)p+=25;\n    printf(\"%d\\n\",p);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int price[8][8] = {\n        {0, 0, 0, 0, 0, 0, 0, 0},\n        {0, 0, 350, 450, 600, 750, 1050, 1300},\n        {0, 350, 0, 450, 500, 650, 900, 1150},\n        {0, 450, 450, 0, 400, 500, 750, 1050},\n        {0, 600, 500, 400, 0, 350, 600, 850},\n        {0, 750, 650, 500, 350, 0, 450, 700},\n        {0, 1050, 900, 750, 600, 450, 0, 500},\n        {0, 1300, 1150, 1050, 850, 700, 500, 0}\n    };\n    \n    int distance[8][8] = {\n        {0, 0, 0, 0, 0, 0, 0, 0},\n        {0, 0, 9, 12, 19, 25, 39, 58},\n        {0, 9, 0, 12, 16, 22, 36, 55},\n        {0, 12, 12, 0, 10, 16, 30, 49},\n        {0, 19, 16, 10, 0, 10, 24, 43},\n        {0, 25, 22, 16, 10, 0, 18, 37},\n        {0, 39, 36, 30, 24, 18, 0, 19},\n        {0, 58, 55, 49, 43, 37, 19, 0}\n    };\n    \n    int d;\n    while(scanf(\"%d\", &d) == 1 && d != 0) {\n        int hd, md, a, ha, ma;\n        scanf(\"%d %d\", &hd, &md);\n        scanf(\"%d\", &a);\n        scanf(\"%d %d\", &ha, &ma);\n        \n        int start_time = hd * 60 + md;\n        int end_time = ha * 60 + ma;\n        int discount_start = 17 * 60 + 30;\n        int discount_end = 19 * 60 + 30;\n        \n        int dist = distance[d][a];\n        int cost = price[d][a];\n        \n        int is_discount = 0;\n        if ((start_time >= discount_start && start_time <= discount_end) ||\n            (end_time >= discount_start && end_time <= discount_end)) {\n            if (dist <= 40) {\n                is_discount = 1;\n            }\n        }\n        \n        if (is_discount) {\n            int half = cost / 2;\n            if (cost % 2 != 0) {\n                half++;\n            }\n            int remainder = half % 50;\n            if (remainder != 0) {\n                half = half + (50 - remainder);\n            }\n            cost = half;\n        }\n        \n        printf(\"%d\\n\", cost);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int price[8][8] = { {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 350, 450, 600, 750, 1050, 1300}, {0, 350, 0, 450,  750, 1050}, {0, 600, 500, 400, 0,  700}, {0, 1050, 900, 750, 600, 450,  }; int distance[8][8] = { {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 9, 12, 19, 25, 39, 58}, {0, 9, 0, 12, 16, 22, 36, 55}, {0, 12, 12, 0, 10, 16, 30, 49}, {0, 19, 16, 10, 0, 10, 24, 43}, {0, 25, 22, 16, 10, 0, 18, 37}, {0, 39, 36, 30,  ha, ma; scanf(\"%d %d\", &hd, &md); scanf(\"%d\", &a); scanf(\"%d %d\", &ha, &ma); int start_time = hd * 60 + md; int end_time = ha * 60 + ma; int discount_start = 17 * 60 + 30; int discount_end = 19 * 60 + 30; int dist  (end_time >= discount_start && end_time <= discount_end)) { if (dist <= 40) { is_discount = 1; } } if (is_discount) { int half = cost / 2; if (cost % 2 != 0) { half++; } int remainder = half % 50; if (remainder != 0) { half = half + (50 - remainder); } cost = half; } printf(\"%d\\n\", cost); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ const int d[8][8]={ {0,0, 0, 0, 0, 0, 0, 0}, {0,0,300,500,600,700,1350,1650}, {0,0, 0,350,450,600,1150,1500}, {0,0, 0, 0,250,400,1000,1350}, {0,0, 0, 0, 0,250, 850,1300}, {0,0, 0, 0, 0, 0, 600,1150}, {0,1,  scanf(\"%d\",&n); if(!n)break; scanf(\"%d %d %d %d %d\",&ih,&it,&m,&oh,&ot); if(n>m){ p=n; n=m; m=p; } p=d[n][m]; it+=60*ih; ot+=60*oh; if(d[m][n]==0&& ((17*60+30<=it&&it<=19*60+30)|| 17*60+30<=ot&&ot<=19*60+30))p/=2; if(p%50)p+=25; printf(\"%d\\n\",p); } return 0; }"], "original_ll": -1.0658456087112427, "sampled_ll": -0.5465840101242065, "all_perturbed_sampled_ll": [-0.998979389667511], "all_perturbed_original_ll": [-1.3680338859558105], "perturbed_sampled_ll": -0.998979389667511, "perturbed_original_ll": -1.3680338859558105, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static int[][] money = new int[][]\n\t\t\t{\n\t\t\t\t{\t0,\t300,\t500,\t600,\t700,\t1350,\t1650},\n\t\t\t\t{\t0,\t0,\t\t350,\t450,\t600,\t1150,\t1500},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t250,\t400,\t1000,\t1350},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t0,\t\t250,\t850,\t1300},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t0,\t\t0,\t\t600,\t1150},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t0,\t\t0,\t\t0,\t\t 500},\n\t\t\t};\n\t\n\tpublic static int[][] dist = new int[][]\n\t\t\t{\n\t\t\t\t{\t0,\t6,\t13,\t18,\t23,\t43,\t58},\n\t\t\t\t{\t0,\t0,\t7,\t12,\t17,\t37,\t52},\n\t\t\t\t{\t0,\t0,\t0,\t5,\t10,\t30,\t45},\n\t\t\t\t{\t0,\t0,\t0,\t0,\t5,\t25,\t40},\n\t\t\t\t{\t0,\t0,\t0,\t0,\t0,\t20,\t35},\n\t\t\t\t{\t0,\t0,\t0,\t0,\t0,\t0,\t15},\n\t\t\t};\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int start = sc.nextInt() - 1;\n\t\t\t\n\t\t\tif(start == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int start_h = sc.nextInt();\n\t\t\tfinal int start_m = sc.nextInt();\n\t\t\tfinal int start_t = start_h * 60 + start_m;\n\t\t\t\n\t\t\tfinal int end = sc.nextInt() - 1;\n\t\t\tfinal int end_h = sc.nextInt();\n\t\t\tfinal int end_m = sc.nextInt();\n\t\t\tfinal int end_t = end_h * 60 + end_m;\n\t\t\t\n\t\t\tint cost = 0;\n\t\t\tif(start_t <= (17 * 60 + 30) && end_t >= (17 * 60 + 30) && end_t <= (19 * 60 + 30) || start_t >= (17 * 60 + 30) && start_t <= (19 * 60 + 30) && end_t >= (19 * 60 + 30)){\n\t\t\t\tif(dist[start][end] <= 40){\n\t\t\t\t\tcost = (int) (Math.ceil((money[start][end] / (2.0 * 50)))) * 50;\n\t\t\t\t}else{\n\t\t\t\t\tcost = money[start][end];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcost = money[start][end];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cost);\n\t\t}\n\t\t\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Distance and price table\n        int[][] distance = new int[8][8];\n        int[][] price = new int[8][8];\n        \n        // Initialize distance table (symmetric)\n        int[][] distData = {\n            {0, 6, 12, 18, 32, 41, 58},\n            {6, 0, 6, 12, 26, 35, 52},\n            {12, 6, 0, 6, 20, 29, 46},\n            {18, 12, 6, 0, 14, 23, 40},\n            {32, 26, 20, 14, 0, 9, 26},\n            {41, 35, 29, 23, 9, 0, 17},\n            {58, 52, 46, 40, 26, 17, 0}\n        };\n        \n        int[][] priceData = {\n            {0, 350, 450, 600, 900, 1150, 1400},\n            {350, 0, 350, 450, 750, 900, 1200},\n            {450, 350, 0, 350, 600, 750, 1050},\n            {600, 450, 350, 0, 450, 600, 850},\n            {900, 750, 600, 450, 0, 350, 600},\n            {1150, 900, 750, 600, 350, 0, 350},\n            {1400, 1200, 1050, 850, 600, 350, 0}\n        };\n        \n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                distance[i+1][j+1] = distData[i][j];\n                price[i+1][j+1] = priceData[i][j];\n            }\n        }\n        \n        while (true) {\n            int d = sc.nextInt();\n            if (d == 0) break;\n            \n            int hd = sc.nextInt();\n            int md = sc.nextInt();\n            int a = sc.nextInt();\n            int ha = sc.nextInt();\n            int ma = sc.nextInt();\n            \n            int dist = distance[d][a];\n            int baseFare = price[d][a];\n            \n            // Check if discount applies\n            // 17:30 - 19:30 (1050 - 1170 minutes from midnight)\n            int departTime = hd * 60 + md;\n            int arriveTime = ha * 60 + ma;\n            \n            boolean discount = false;\n            if (dist <= 40) {\n                // Check if either departure or arrival is in discount time\n                if ((departTime >= 1050 && departTime <= 1170) || \n                    (arriveTime >= 1050 && arriveTime <= 1170)) {\n                    discount = true;\n                }\n            }\n            \n            int fare;\n            if (discount) {\n                // Half price, round up to nearest 50 yen\n                int halfFare = baseFare / 2;\n                fare = ((halfFare + 49) / 50) * 50;\n            } else {\n                fare = baseFare;\n            }\n            \n            System.out.println(fare);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); // Distance and price table int[][] distance =  table  41, 58}, {6, 0, 6, 12, 26, 35, 52}, {12, 6, 0, 6, 20, 29, 46}, {18, 12, 6, 0, 14, 23, 40}, {32, 26, 20, 14, 0, 9, 26}, {41, 35, 29, 23, 9, 0, 17}, {58, 52, 46, 40, 26, 17, 0} }; int[][] priceData = { {0, 350, 450, 600, 900, 1150, 1400}, {350, 0, 350, 450, 750, 900, 1200}, {450, 350, 0, 350, 600, 750, 1050}, {600, 450, 350, 0, 450,  900, 750, 600, 350, 0, 350}, {1400, 1200, 1050, 850, 600,  7; i++) { for (int j = 0; j < 7; j++) { distance[i+1][j+1] = distData[i][j]; price[i+1][j+1] = priceData[i][j]; } } while (true) { int d = sc.nextInt(); if (d == 0) break; int hd = sc.nextInt(); int md = sc.nextInt(); int a = sc.nextInt(); int ha = sc.nextInt(); int  price[d][a]; // Check if discount applies // 17:30 - 19:30 (1050 - 1170 minutes from midnight) int departTime = hd * 60 + md; int arriveTime = ha * 60 + ma; boolean discount = false; if  arrival is in discount time if ((departTime >=  arriveTime <= 1170)) { discount = true; } } int fare; if (discount) { // Half price, round  2;  else { fare = baseFare; } System.out.println(fare); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static int[][] money = new int[][] { { 0, 300, 500,  1150, 1500}, { 0, 0, 0,  850, 1300}, { 0, 0, 0, 0, 0, 600,  public static int[][] dist = new int[][] { { 0, 6, 13, 18, 23, 43, 58}, { 0, 0, 7, 12, 17, 37, 52}, { 0, 0, 0, 5, 10, 30, 45}, { 0, 0, 0, 0, 5, 25, 40}, { 0, 0, 0, 0, 0, 20, 35}, {  void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){ final int start = sc.nextInt() - 1; if(start == -1){ break; } final int start_h = sc.nextInt(); final int start_m = sc.nextInt();  int end = sc.nextInt() - 1; final int end_h = sc.nextInt();  <= (17 * 60 + 30) && end_t >= (17 * 60 + 30) && end_t <= (19 * 60 + 30) || start_t >= (17 * 60 + 30) && start_t <= (19  + 30)){ if(dist[start][end] <= 40){ cost = (int) (Math.ceil((money[start][end] / (2.0 * 50)))) * 50; }else{ cost = money[start][end]; } }else{ cost = money[start][end]; } System.out.println(cost); } } }"], "original_ll": -0.634609580039978, "sampled_ll": -0.6525737047195435, "all_perturbed_sampled_ll": [-1.3904750347137451], "all_perturbed_original_ll": [-1.1367439031600952], "perturbed_sampled_ll": -1.3904750347137451, "perturbed_original_ll": -1.1367439031600952, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "table=[[0,300,500,600,700,1350,1650],\n       [0,0,350,450,600,1150,1500],\n       [0,0,0,250,400,1000,1350],\n       [0,0,0,0,250,850,1300],\n       [0,0,0,0,0,600,1150],\n       [0,0,0,0,0,0,500]]\nfbd=[(1,6),(1,7),(2,7),(3,7)]\nwhile True:\n    init=input()\n    if init==0:break\n    h1,m1=map(int,raw_input().split())\n    fin=input()\n    h2,m2=map(int,raw_input().split())\n    if init>fin:\n        init,h1,m1,fin,h2,m2=fin,h2,m2,init,h1,m1\n    t1=h1*60+m1\n    t2=h2*60+m2\n    if 1050<=t1<=1170 or 1050<=t2<=1170 and (init,fin) not in fbd:\n        temp=table[init-1][fin-1]/2\n        if temp%100>0:\n            temp+=50-temp%50\n        print temp\n    else:\n        print table[init-1][fin-1]", "sampled": "import math\n\n# Distance and toll matrix\ndistance = [\n    [0, 6, 18, 25, 37, 48, 58],\n    [6, 0, 12, 19, 31, 42, 52],\n    [18, 12, 0, 7, 19, 30, 40],\n    [25, 19, 7, 0, 12, 23, 33],\n    [37, 31, 19, 12, 0, 11, 21],\n    [48, 42, 30, 23, 11, 0, 10],\n    [58, 52, 40, 33, 21, 10, 0]\n]\n\ntoll = [\n    [0, 200, 500, 650, 900, 1150, 1350],\n    [200, 0, 450, 600, 850, 1100, 1300],\n    [500, 450, 0, 250, 500, 750, 950],\n    [650, 600, 250, 0, 350, 600, 800],\n    [900, 850, 500, 350, 0, 300, 550],\n    [1150, 1100, 750, 600, 300, 0, 250],\n    [1350, 1300, 950, 800, 550, 250, 0]\n]\n\ndef in_discount_time(h, m):\n    time_minutes = h * 60 + m\n    start = 17 * 60 + 30  # 17:30\n    end = 19 * 60 + 30    # 19:30\n    return start <= time_minutes <= end\n\nwhile True:\n    d = int(input())\n    if d == 0:\n        break\n    \n    hd, md = map(int, input().split())\n    a = int(input())\n    ha, ma = map(int, input().split())\n    \n    # Convert to 0-indexed\n    d -= 1\n    a -= 1\n    \n    # Get base toll and distance\n    base_toll = toll[d][a]\n    dist = distance[d][a]\n    \n    # Check if discount applies\n    discount = False\n    if (in_discount_time(hd, md) or in_discount_time(ha, ma)) and dist <= 40:\n        discount = True\n    \n    if discount:\n        # Half price, rounded up to nearest 50\n        half_toll = base_toll / 2\n        final_toll = math.ceil(half_toll / 50) * 50\n    else:\n        final_toll = base_toll\n    \n    print(final_toll)\n", "perturbed_sampled": ["import math # Distance and toll matrix  0, 7, 19, 30, 40], [25, 19, 7, 0, 12, 23, 33], [37, 31, 19, 12, 0, 11, 21], [48, 42, 30, 23, 11,  toll = [ [0, 200, 500, 650, 900, 1150, 1350], [200, 0,  750, 950], [650, 600, 250, 0, 350, 600, 800], [900, 850, 500, 350, 0, 300, 550], [1150, 1100, 750, 600, 300, 0, 250], [1350, 1300, 950, 800, 550, 250, 0] ] def in_discount_time(h, m): time_minutes = h * 60 + m start = 17 * 60 + 30 # 17:30 end = 19 * 60 + 30 # 19:30 return start <= time_minutes <= end while True: d = int(input()) if d == 0: break hd, md = map(int, input().split()) a = int(input())  Check if discount applies discount = False if (in_discount_time(hd, md) or in_discount_time(ha, ma)) and dist <= 40: discount = True if discount: # Half price, rounded up to nearest 50 half_toll = base_toll / 2 final_toll = math.ceil(half_toll / 50) * 50 else: final_toll = base_toll print(final_toll)"], "perturbed_original": ["table=[[0,300,500,600,700,1350,1650], [0,0,350,450,600,1150,1500], [0,0,0,250,400,1000,1350], [0,0,0,0,250,850,1300], [0,0,0,0,0,600,1150], [0,0,0,0,0,0,500]] fbd=[(1,6),(1,7),(2,7),(3,7)]  init,h1,m1,fin,h2,m2=fin,h2,m2,init,h1,m1 t1=h1*60+m1 t2=h2*60+m2 if 1050<=t1<=1170 or 1050<=t2<=1170 and (init,fin) not in fbd: temp=table[init-1][fin-1]/2 if temp%100>0: temp+=50-temp%50 print temp else: print table[init-1][fin-1]"], "original_ll": -1.1162550449371338, "sampled_ll": -0.6413790583610535, "all_perturbed_sampled_ll": [-1.4101183414459229], "all_perturbed_original_ll": [-1.4147273302078247], "perturbed_sampled_ll": -1.4101183414459229, "perturbed_original_ll": -1.4147273302078247, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a[];main(f,l,i,n,S){for(;scanf(S=\"%d\\n\",&i)*i;){for(l=0;i--;)scanf(S,a+l++);for(n=32;n;f=!f)n-=f?~-n%5:a[++i%l],printf(S,n*=n>0);}}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int a[25];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        \n        int remaining = 32;\n        int jiro_index = 0;\n        int turn = 0; // 0 for Ichiro, 1 for Jiro\n        \n        while (remaining > 0) {\n            if (turn == 0) {\n                // Ichiro's turn\n                int take = (remaining - 1) % 5;\n                remaining -= take;\n                printf(\"%d\\n\", remaining);\n                turn = 1;\n            } else {\n                // Jiro's turn\n                int take = a[jiro_index];\n                if (take >= remaining) {\n                    take = remaining;\n                }\n                remaining -= take;\n                printf(\"%d\\n\", remaining);\n                jiro_index = (jiro_index + 1) % n;\n                turn = 0;\n            }\n        }\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while (scanf(\"%d\", &n) == 1 && n  i < n; i++) { scanf(\"%d\", &a[i]); } int remaining = 32; int jiro_index = 0; int turn = 0; // 0 for Ichiro, 1 for Jiro while  Ichiro's turn int take = (remaining - 1) % 5; remaining -= take; printf(\"%d\\n\", remaining); turn = 1; } else { // Jiro's turn int take = a[jiro_index]; if (take >= remaining) { take = remaining; } remaining -=  turn = 0; } } } return 0; }"], "perturbed_original": ["a[];main(f,l,i,n,S){for(;scanf(S=\"%d\\n\",&i)*i;){for(l=0;i--;)scanf(S,a+l++);for(n=32;n;f=!f)n-=f?~-n%5:a[++i%l],printf(S,n*=n>0);}}"], "original_ll": -4.209161758422852, "sampled_ll": -0.8070781230926514, "all_perturbed_sampled_ll": [-1.9936188459396362], "all_perturbed_original_ll": [-4.209161758422852], "perturbed_sampled_ll": -1.9936188459396362, "perturbed_original_ll": -4.209161758422852, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import static java.util.Arrays.deepToString;\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = sc.nextInt();\n\t\t\t\n\t\t\tint st = 32;\n\t\t\tfor (int time = 0; st > 0; time++) {\n\t\t\t\tst -= (st - 1) % 5;\n\t\t\t\tSystem.out.println(st);\n\t\t\t\tint g = a[time%a.length];\n\t\t\t\tst -= g;\n\t\t\t\tif (st < 0) {\n\t\t\t\t\tst = 0;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(st);\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt();\n            }\n            \n            int remaining = 32;\n            int jiroIndex = 0;\n            \n            while (remaining > 0) {\n                // Ichiro's turn\n                int ichiroTake = (remaining - 1) % 5;\n                remaining -= ichiroTake;\n                System.out.println(remaining);\n                \n                if (remaining == 0) break;\n                \n                // Jiro's turn\n                int jiroTake = Math.min(a[jiroIndex], remaining);\n                remaining -= jiroTake;\n                System.out.println(remaining);\n                \n                jiroIndex = (jiroIndex + 1) % n;\n                \n                if (remaining == 0) break;\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[] a = new int[n]; for  =  while (remaining > 0) { // Ichiro's turn int ichiroTake = (remaining - 1) % 5;  Jiro's turn int jiroTake = Math.min(a[jiroIndex], remaining); remaining -= jiroTake; System.out.println(remaining); jiroIndex = (jiroIndex + 1) % n; if (remaining == 0) break; } } sc.close(); } }"], "perturbed_original": ["import static ; t =<extra_id_11>0; i <<extra_id_12>> g ) { st<extra_id_13>-=<extra_id_14>for(int a[0]; i++){ // t<extra_id_15>//<extra_id_16>a[10]; if<extra_id_17>t < a.length) a[8]<extra_id_18> main(String[] args) { new Main().run(); } void tr(Object... os) { System.err.println(deepToString(os)); } Scanner sc = new Scanner(System.in); public void run() { for (;sc.hasNext();) { int n = sc.nextInt(); if (n == 0) break; int[] a = new int[n]; for (int i = 0; i < n; i++)  = 0; st > 0; time++) { st -= (st - 1) % 5; System.out.println(st); int g = a[time%a.length]; st -= g; if (st  } }"], "original_ll": -1.2089089155197144, "sampled_ll": -0.8288243412971497, "all_perturbed_sampled_ll": [-1.5950255393981934], "all_perturbed_original_ll": [-2.584155797958374], "perturbed_sampled_ll": -1.5950255393981934, "perturbed_original_ll": -2.584155797958374, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n=int(input())\n    if n==0: break\n    a=list(map(int,input().split()))\n    i,s=0,32\n    while s>0:\n        s-=(s-1)%5\n        print(s)\n        s-=a[i%n]\n        i+=1\n        print(max(0,s))", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    sequence = list(map(int, input().split()))\n    \n    remaining = 32\n    jiro_index = 0\n    \n    while remaining > 0:\n        # Ichiro's turn\n        to_take = (remaining - 1) % 5\n        remaining -= to_take\n        print(remaining)\n        \n        if remaining == 0:\n            break\n        \n        # Jiro's turn\n        to_take = min(sequence[jiro_index], remaining)\n        remaining -= to_take\n        print(remaining)\n        \n        jiro_index = (jiro_index + 1) % n\n        \n        if remaining == 0:\n            break\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break sequence = list(map(int, input().split())) remaining = 32  to_take = (remaining - 1) % 5 remaining -= to_take print(remaining) if remaining == 0: break # Jiro's turn to_take = min(sequence[jiro_index], remaining) remaining -= to_take print(remaining) jiro_index = (jiro_index + 1) % n if remaining == 0: break"], "perturbed_original": ["while 1: n=int(input()) if n==0: break a=list(map(int,input().split())) i,s=0,32 while s>0: s-=(s-1)%5 print(s) s-=a[i%n] i+=1 print(max(0,s))"], "original_ll": -1.8200606107711792, "sampled_ll": -1.2150248289108276, "all_perturbed_sampled_ll": [-2.127169370651245], "all_perturbed_original_ll": [-2.441899299621582], "perturbed_sampled_ll": -2.127169370651245, "perturbed_original_ll": -2.441899299621582, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\n#define MAX 10000000\n\nint pp[MAX + 1];\n\nint main(){\n  int n, p, m, i, j, prime, x, res, c;\n  pp[0] = pp[1] = 1;\n  for(i = 2; i < MAX / 2 ; ++i)\n    if(pp[i] != 1)\n      for(j = i * 2; j < MAX; j += i)\n\tpp[j] = 1;\n\n  while(scanf(\"%d\", &n) && n){\n    res = 0;\n    while(n--){\n      scanf(\"%d %d\", &p, &m);\n      c = 0;\n      for(i = ((p - m) < 0 ? 0 : p - m);i < ((p + m) > MAX ? MAX : p + m); ++i)\n\tif(pp[i] == 0) c++;\n      if(c > 0) c--;\n      res += c;\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MP 999983\n#define MAX_PRIMES 80000\n\nint is_prime[MP + 1];\nint primes[MAX_PRIMES];\nint prime_count = 0;\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i <= MP; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= MP; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n    \n    for (int i = 2; i <= MP; i++) {\n        if (is_prime[i]) {\n            primes[prime_count++] = i;\n        }\n    }\n}\n\nint binary_search_lower(int val) {\n    int left = 0, right = prime_count - 1;\n    int result = prime_count;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (primes[mid] >= val) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return result;\n}\n\nint binary_search_upper(int val) {\n    int left = 0, right = prime_count - 1;\n    int result = -1;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (primes[mid] <= val) {\n            result = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result;\n}\n\nint count_primes_in_range(int lower, int upper) {\n    if (lower > MP) return 0;\n    if (upper < 2) return 0;\n    \n    if (lower < 2) lower = 2;\n    if (upper > MP) upper = MP;\n    \n    int lower_idx = binary_search_lower(lower);\n    int upper_idx = binary_search_upper(upper);\n    \n    if (lower_idx > upper_idx || lower_idx >= prime_count || upper_idx < 0) {\n        return 0;\n    }\n    \n    return upper_idx - lower_idx + 1;\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long total = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int p, m;\n            scanf(\"%d %d\", &p, &m);\n            \n            int lower = p - m;\n            int upper = p + m;\n            \n            int X = count_primes_in_range(lower, upper);\n            \n            if (X > 1) {\n                total += (X - 1);\n            } else if (X == 0) {\n                total -= 1;\n            }\n        }\n        \n        if (total < 0) total = 0;\n        \n        printf(\"%lld\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> #define  1, sizeof(is_prime)); is_prime[0] = is_prime[1] = 0; for (int i = 2; i * i <= MP; i++) { if (is_prime[i]) { for (int j = i * i; j <= MP; j += i)  = 2; i <= MP; i++) { if (is_prime[i]) { primes[prime_count++] = i; } } } int binary_search_lower(int val) { int left = 0, right = prime_count - 1; int result = prime_count; while (left <= right) { int mid = (left + right) / 2; if (primes[mid] >= val) { result = mid; right  + 1; } } return result; } int binary_search_upper(int val)  int mid = (left + right) / 2; if (primes[mid] <= val) { result = mid; left = mid + 1; } else { right = mid - 1; } } return result; } int count_primes_in_range(int  2) lower = 2; if (upper > MP) upper =  (lower_idx > upper_idx || lower_idx >= prime_count || upper_idx < 0) { return 0; } return upper_idx - lower_idx + 1; } int main() { sieve(); int n; while (scanf(\"%d\", &n) == 1 && n != 0) { long long total = 0; for (int i = 0; i < n; i++) { int p, m; scanf(\"%d %d\", &p, &m); int lower = p - m; int upper = p + m; int X =  - 1); } else if (X == 0) { total -= 1; } } if (total < 0) total = 0; printf(\"%lld\\n\", total); } return 0; }"], "perturbed_original": ["#include <stdio.h> #define  p, m, i, j, prime, x, res, c; pp[0] = pp[1] = 1; for(i = 2; i < MAX / 2 ;  < MAX; j += i) pp[j] = 1; while(scanf(\"%d\", &n) && n){ res = 0; while(n--){ scanf(\"%d %d\", &p, &m); c = 0; for(i = ((p - m) < 0 ? 0 : p - m);i  + m); ++i) if(pp[i] == 0) c++; if(c > 0) c--; res += c; } printf(\"%d\\n\", res); } return 0; }"], "original_ll": -1.0047686100006104, "sampled_ll": -0.4375319182872772, "all_perturbed_sampled_ll": [-1.312408208847046], "all_perturbed_original_ll": [-1.95065176486969], "perturbed_sampled_ll": -1.312408208847046, "perturbed_original_ll": -1.95065176486969, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tlong[] m = new long[]{ 2, 7, 61 };\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> Ans = new ArrayList<Integer>();\n\t\tString line;\n\t\t\n\t\tint[] prime = new int[1000000];\n\t\t\n\t\twhile((line = in.readLine()) != null){\n\t\t\tint size = Integer.parseInt(line);\n\t\t\tif(size==0) break;\n\t\t\t\n\t\t\tint pay = 0;\n\t\t\tfor(int n=0; n<size; n++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tint center = Integer.parseInt(dst[0]);\n\t\t\t\tint range = Integer.parseInt(dst[1]);\n\t\t\t\t\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i=Math.max(2, center-range); i<=Math.min(center+range, 999983); i++){\n\t\t\t\t\tif(prime[i]==0){\n\t\t\t\t\t\tif(isPrime(i)){\n\t\t\t\t\t\t\tprime[i] = 1;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tprime[i] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(prime[i]==1){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpay += count - 1;\n\t\t\t}\n\t\t\t\n\t\t\tAns.add(Math.max(0, pay));\n\t\t}\n\t\t\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tSystem.out.println(Ans.get(n));\n\t\t}\t\t\n\t}\n\t\n\tpublic boolean isPrime(long x){\n\t\tif(x==2){\n\t\t\treturn true;\n\t\t}\n\t\telse if(x%2 == 0){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\tlong s = 0;\n\t\t\tlong d = x - 1;\n\t\t\twhile(d%2 == 0){\n\t\t\t\td = d / 2;\n\t\t\t\ts++;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<3; i++){\n\t\t\t\tlong a = m[i];\n\t\t\t\tif(a%x == 0) continue;\n\t\t\t\t\n\t\t\t\tlong pow = mod(a, d, x);\n\t\t\t\tif(pow == 1) continue;\n\t\t\t\tif(pow == x - 1) continue;\n\t\t\t\t\n\t\t\t\tboolean con2 = false;\n\t\t\t\tfor(int r=1; r<s; r++){\n\t\t\t\t\tpow = mod(pow, 2, x);\n\t\t\t\t\t//pow = mod(a, (long)(d * Math.pow(2.0, r)), x);\n\t\t\t\t\tif(pow ==  x - 1){\n\t\t\t\t\t\tcon2 = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!con2){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic long mod(long a, long d, long n){\n\t\tif(a==0 || n==0) return 0;\n\t\tif(d==0) return 1 % n;\n\t\t\n\t\tlong currentMod = a % n;\n\t\tlong currentValue = (d%2 == 1) ? currentMod : 1;\n\t\t\n\t\tfor(d>>=1; d>0; d>>=1){\n\t\t\tcurrentMod = (currentMod * currentMod) % n;\n\t\t\tif(d%2 == 1){\n\t\t\t\tcurrentValue = (currentValue * currentMod) % n;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn currentValue;\n\t\t\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MP = 999983;\n    static boolean[] isPrime;\n    static int[] primeCount;\n    \n    static void sieve() {\n        isPrime = new boolean[MP + 1];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i <= MP; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= MP; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        primeCount = new int[MP + 1];\n        int count = 0;\n        for (int i = 0; i <= MP; i++) {\n            if (isPrime[i]) count++;\n            primeCount[i] = count;\n        }\n    }\n    \n    static int countPrimes(int p, int m) {\n        int left = Math.max(0, p - m);\n        int right = Math.min(MP, p + m);\n        \n        int count = primeCount[right];\n        if (left > 0) {\n            count -= primeCount[left - 1];\n        }\n        \n        return count;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        \n        sieve();\n        \n        String line;\n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            long totalRequest = 0;\n            \n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                int p = Integer.parseInt(parts[0]);\n                int m = Integer.parseInt(parts[1]);\n                \n                int x = countPrimes(p, m);\n                \n                if (x == 0) {\n                    totalRequest -= 1;\n                } else {\n                    totalRequest += (x - 1);\n                }\n            }\n            \n            totalRequest = Math.max(0, totalRequest);\n            pw.println(totalRequest);\n        }\n        \n        pw.flush();\n        pw.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static final int MP = 999983; static boolean[] isPrime; static int[] primeCount; static void sieve() { isPrime = new boolean[MP + 1]; Arrays.fill(isPrime, true); isPrime[0] = isPrime[1] = false; for (int i = 2; i * i <= MP; i++) { if (isPrime[i]) { for (int j = i * i; j <= MP; j += i)  int[MP + 1]; int count = 0; for (int i = 0; i <= MP; i++)  int countPrimes(int p, int m) {  (left > 0) { count -= primeCount[left - 1]; } return  BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); PrintWriter pw = new PrintWriter(System.out); sieve(); String line; while ((line = br.readLine()) != null) { int n = Integer.parseInt(line.trim()); if (n == 0) break; long totalRequest = 0; for (int i = 0; i  =  if (x == 0) { totalRequest -= 1; } else { totalRequest += (x - 1); } } totalRequest = Math.max(0, totalRequest); pw.println(totalRequest); } pw.flush(); pw.close(); } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static void main(String args[]){ try{ new Main(); }catch(IOException e){ e.printStackTrace(); } } long[] m = new long[]{ 2, 7, 61 }; public Main() throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); List<Integer> Ans = new ArrayList<Integer>(); String line; int[] prime = new int[1000000]; while((line = in.readLine()) != null){ int size = Integer.parseInt(line); if(size==0) break; int pay =  = line.split(\" \"); int center = Integer.parseInt(dst[0]); int range = Integer.parseInt(dst[1]); int count = 0; for(int  count++; } else{ prime[i] = 2; } }else{ if(prime[i]==1){ count++;  pay)); } for(int  false; } else{ long s = 0; long d = x - 1; while(d%2 == 0){ d = d / 2; s++; } for(int i=0; i<3; i++){ long a = m[i]; if(a%x == 0) continue; long pow = mod(a, d, x); if(pow == 1) continue; if(pow == x - 1) continue; boolean con2 = false; for(int r=1;  (long)(d *  true; break; } } if(!con2){ return false; } } return true; } } public long mod(long a, long d, long n){ if(a==0 || n==0) return 0; if(d==0) return 1 % n; long currentMod = a % n; long currentValue = (d%2 == 1) ? currentMod : 1; for(d>>=1; d>0; d>>=1){ currentMod  = (currentValue * currentMod) % n; } } return currentValue; } }"], "original_ll": -0.9746206998825073, "sampled_ll": -0.5108595490455627, "all_perturbed_sampled_ll": [-1.2414389848709106], "all_perturbed_original_ll": [-1.7721236944198608], "perturbed_sampled_ll": -1.2414389848709106, "perturbed_original_ll": -1.7721236944198608, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nN=1000000\nprime=[1]*(N+1)\nprime[0]=0\nprime[1]=0\nfor i in range(2,int(math.sqrt(N))):\n    if prime[i]==1:\n        j=i\n        while i*j<=N:\n            prime[i*j]=0\n            j+=1\nprime=[i for i in range(N+1) if prime[i]==1]\n\nwhile True:\n    n=input()\n    if n==0:break\n    cnt=0\n    for i in range(n):\n        p,m=map(int,raw_input().split())\n        for j in range(len(prime)):\n            if p-m<=prime[j]<=p+m:\n                cnt+=1\n            if p+m<=prime[j]:\n                break\n    print cnt-n", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    primes = [i for i in range(limit + 1) if is_prime[i]]\n    return primes, is_prime\n\nMP = 999983\nprimes, is_prime = sieve_of_eratosthenes(MP)\n\ndef binary_search_left(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef binary_search_right(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef count_primes_in_range(low, high):\n    left_idx = binary_search_left(primes, low)\n    right_idx = binary_search_right(primes, high)\n    return right_idx - left_idx\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    total_cost = 0\n    for _ in range(n):\n        p, m = map(int, input().split())\n        low = max(0, p - m)\n        high = min(MP, p + m)\n        \n        X = count_primes_in_range(low, high)\n        \n        if X > 0:\n            total_cost += X - 1\n        else:\n            total_cost -= 1\n    \n    total_cost = max(0, total_cost)\n    print(total_cost)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] =  if is_prime[i]: for j in range(i*i, limit + 1, i): is_prime[j] = False  is_prime[i]] return primes, is_prime MP = 999983 primes, is_prime = sieve_of_eratosthenes(MP) def binary_search_left(arr, target): left, right = 0, len(arr) while left < right: mid = (left + right)  1 else: right = mid return left def binary_search_right(arr, target): left, right = 0, len(arr) while left < right: mid = (left + right) // 2 if arr[mid] <= target: left = mid + 1 else: right =  right_idx = binary_search_right(primes, high) return right_idx - left_idx while True: n = int(input()) if  range(n): p, m = map(int, input().split()) low = max(0, p - m) high = min(MP, p + m) X = count_primes_in_range(low, high) if X > 0: total_cost += X - 1 else: total_cost -= 1 total_cost = max(0, total_cost) print(total_cost)"], "perturbed_original": ["import math N=1000000 prime=[1]*(N+1) prime[0]=0 prime[1]=0 for  prime=[i for i in range(N+1) if prime[i]==1] while True: n=input() if n==0:break cnt=0 for i in range(n): p,m=map(int,raw_input().split()) for j in range(len(prime)): if p-m<=prime[j]<=p+m: cnt+=1 if p+m<=prime[j]: break print cnt-n"], "original_ll": -1.0373896360397339, "sampled_ll": -0.5129606127738953, "all_perturbed_sampled_ll": [-1.3918589353561401], "all_perturbed_original_ll": [-1.8193888664245605], "perturbed_sampled_ll": -1.3918589353561401, "perturbed_original_ll": -1.8193888664245605, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void) {\n  int n, data[100], j, tmp, i, count;\n  while(scanf(\"%d\",&n),n) {\n    count = 0;\n    for(i = 0; i < n; i++ ) {\n      scanf(\"%d\",&data[i]);\n    }\n    for(i = 0; i < n - 1; i++ ) {\n      for(j = 1; j < n - i; j++ ) {\n\tif(data[j] < data[j-1]) {\n\t  tmp = data[j];\n\t  data[j] = data[j-1];\n\t  data[j-1] = tmp;\n\t  count++;\n\t}\n      }\n    }\n    printf(\"%d\\n\",count);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int arr[100];\n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", &arr[i]);\n        }\n        \n        int swaps = 0;\n        for(int i = 0; i < n - 1; i++) {\n            for(int j = 0; j < n - 1 - i; j++) {\n                if(arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swaps++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", swaps);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) { scanf(\"%d\", &n);  i < n; i++) { scanf(\"%d\", &arr[i]); } int swaps = 0; for(int i = 0; i < n - 1; i++) { for(int  j++) { if(arr[j] > arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; swaps++; } } } printf(\"%d\\n\", swaps); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) {  = 0; for(i = 0; i < n; i++ ) { scanf(\"%d\",&data[i]); } for(i = 0; i < n - 1; i++ ) { for(j = 1; j  { tmp = data[j]; data[j] = data[j-1]; data[j-1] = tmp; count++; } } } printf(\"%d\\n\",count); } return 0; }"], "original_ll": -0.7557990550994873, "sampled_ll": -0.3426540493965149, "all_perturbed_sampled_ll": [-0.9492048621177673], "all_perturbed_original_ll": [-1.2757221460342407], "perturbed_sampled_ll": -0.9492048621177673, "perturbed_original_ll": -1.2757221460342407, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n\tScanner sc = new Scanner(System.in);\n\t\n\tprivate void doit(){\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint [] data = new int[n];\n\t\t\tfor(int i = 0; i  <n; i++){\n\t\t\t\tdata[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor(;;){\n\t\t\t\tboolean flg = false;\n\t\t\t\tfor(int j = 0; j < n-1; j++){\n\t\t\t\t\tif(data[j] > data[j + 1]){\n\t\t\t\t\t\tint temp = data[j];\n\t\t\t\t\t\tdata[j] = data[j+1];\n\t\t\t\t\t\tdata[j+1] = temp;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(! flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = sc.nextInt();\n            }\n            \n            int swapCount = bubbleSort(arr, n);\n            System.out.println(swapCount);\n        }\n        \n        sc.close();\n    }\n    \n    static int bubbleSort(int[] arr, int n) {\n        int count = 0;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - 1 - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[] arr = new int[n]; for (int i = 0; i < n; i++) { arr[i] = sc.nextInt(); } int  bubbleSort(int[] arr, int n) { int count = 0; for (int i = 0; i < n - 1; i++) { for (int j = 0;  (arr[j] > arr[j +  1]; arr[j + 1] = temp; count++; } } } return count; } }"], "perturbed_original": ["import java.util.*; public class Main{ Scanner sc = new Scanner(System.in); private void doit(){ while(true){ int n = sc.nextInt(); if(n  i = 0; i <n; i++){ data[i] = sc.nextInt(); } int  = 0; j < n-1; j++){ if(data[j] >  data[j+1] = temp; count++; flg = true; } } if(! flg){ break; } } System.out.println(count); } } private void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); } public static void main(String[] args) { new Main().doit(); } }"], "original_ll": -0.8794525265693665, "sampled_ll": -0.28202080726623535, "all_perturbed_sampled_ll": [-0.8669056296348572], "all_perturbed_original_ll": [-1.8084712028503418], "perturbed_sampled_ll": -0.8669056296348572, "perturbed_original_ll": -1.8084712028503418, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    Num_lis = []\n    cou = 0\n    for i in range(n):\n        Num_lis.append(int(input()))\n    S_lis = sorted(Num_lis)\n    while Num_lis != S_lis:\n        \n        for j in range(n - 1):\n            if Num_lis[j] > Num_lis[j + 1]:\n                Num_lis[j],Num_lis[j + 1] = Num_lis[j + 1],Num_lis[j]\n                cou += 1\n    print(cou)", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    arr = []\n    for _ in range(n):\n        arr.append(int(input()))\n    \n    count = 0\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                count += 1\n    \n    print(count)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break arr = [] for _ in range(n): arr.append(int(input())) count = 0 for i in range(n - 1): for j in range(n  arr[j], arr[j + 1] = arr[j + 1], arr[j] count += 1 print(count)"], "perturbed_original": ["while True: n = int(input()) if n == 0: break Num_lis = [] cou = 0 for i in range(n): Num_lis.append(int(input())) S_lis = sorted(Num_lis) while Num_lis != S_lis: for j in range(n - 1):  Num_lis[j + 1],Num_lis[j] cou += 1 print(cou)"], "original_ll": -0.8521052002906799, "sampled_ll": -0.4930432140827179, "all_perturbed_sampled_ll": [-1.5112062692642212], "all_perturbed_original_ll": [-1.744470238685608], "perturbed_sampled_ll": -1.5112062692642212, "perturbed_original_ll": -1.744470238685608, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  int n, p[31] = {}, i, res;\n  p[0] = 1;\n  p[1] = 1;\n  p[2] = 2;\n\n\n  while(scanf(\"%d\", &n) && n){\n    for(i = 3; i <= n; i++) p[i] = p[i - 1] + p[i - 2] + p[i - 3];\n    res = p[n] / 10 / 365 + 1;\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    long long dp[31];\n    \n    // Calculate number of ways to climb stairs for each n\n    dp[0] = 1;\n    dp[1] = 1;\n    dp[2] = 2;\n    \n    for (int i = 3; i <= 30; i++) {\n        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\n    }\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long ways = dp[n];\n        long long days = (ways + 9) / 10;  // Round up division\n        long long years = (days + 364) / 365;  // Round up division\n        printf(\"%lld\\n\", years);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; long long dp[31]; // Calculate number of ways to climb stairs for each n dp[0] = 1; dp[1] = 1; dp[2] = 2; for (int i = 3; i <= 30; i++) { dp[i] = dp[i-1] + dp[i-2] + dp[i-3]; }  long long ways = dp[n]; long long days = (ways + 9) / 10; // Round  365; // Round up division printf(\"%lld\\n\", years); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ int n, p[31] = {}, i, res; p[0] = 1; p[1] = 1; p[2] = 2; while(scanf(\"%d\",  p[i] = p[i - 1] + p[i - 2] + p[i - 3]; res = p[n] / 10 / 365 + 1; printf(\"%d\\n\", res); } return 0; }"], "original_ll": -0.9883154034614563, "sampled_ll": -0.798247218132019, "all_perturbed_sampled_ll": [-1.447512149810791], "all_perturbed_original_ll": [-1.4681220054626465], "perturbed_sampled_ll": -1.447512149810791, "perturbed_original_ll": -1.4681220054626465, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,i,j,a[];(n=s.nextInt())>0;System.out.println(a[n]/3650+1))for(a=new int[n+3],a[1]=a[2]=a[3]=1,i=0;i<n;++i)for(j=4;j-->1;)a[i+j]+=a[i];}}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        long[] ways = new long[31];\n        ways[0] = 1;\n        \n        for (int i = 1; i <= 30; i++) {\n            ways[i] = 0;\n            if (i >= 1) ways[i] += ways[i-1];\n            if (i >= 2) ways[i] += ways[i-2];\n            if (i >= 3) ways[i] += ways[i-3];\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            long totalWays = ways[n];\n            long days = (totalWays + 9) / 10;\n            long years = (days + 364) / 365;\n            \n            System.out.println(years);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args)  long[31]; ways[0] = 1; for (int i = 1; i <= 30; i++) { ways[i] = 0; if (i >= 1) ways[i] += ways[i-1]; if (i >= 2) ways[i] += ways[i-2]; if (i >= 3) ways[i] += ways[i-3]; } while (true) { int n = sc.nextInt(); if (n == 0) break; long totalWays  long years = (days + 364) / 365; System.out.println(years); } sc.close(); } }"], "perturbed_original": ["import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,i,j,a[];(n=s.nextInt())>0;System.out.println(a[n]/3650+1))for(a=new int[n+3],a[1]=a[2]=a[3]=1,i=0;i<n;++i)for(j=4;j-->1;)a[i+j]+=a[i];}}"], "original_ll": -2.00246524810791, "sampled_ll": -0.5796345472335815, "all_perturbed_sampled_ll": [-1.1595007181167603], "all_perturbed_original_ll": [-2.00246524810791], "perturbed_sampled_ll": -1.1595007181167603, "perturbed_original_ll": -2.00246524810791, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a = []\na[:4] = [0, 1, 2, 3]\ninList = []\nwhile True:\n    price = int(input())\n    if price == 0:\n        break\n    inList.append(int(input()))\nn = max(inList)\nfor i in range(4, n + 1):\n    a[i] = a[i-1] + a[i-2] + a[i-3]\nfor i in inList:\n    print((a[i] // 3650) + (a[i] % 3650 != 0))", "sampled": "import sys\n\ndef count_ways(n):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        dp[i] = dp[i-1]\n        if i >= 2:\n            dp[i] += dp[i-2]\n        if i >= 3:\n            dp[i] += dp[i-3]\n    \n    return dp[n]\n\ndef calculate_years(n):\n    ways = count_ways(n)\n    days = (ways + 9) // 10\n    years = (days + 364) // 365\n    return years\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    if n == 0:\n        break\n    print(calculate_years(n))\n", "perturbed_sampled": ["import sys def count_ways(n): if n == 0: return 1 if n < 0: return 0 dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): dp[i]  i >= 3: dp[i]  = (ways + 9) // 10 years = (days + 364) // 365 return years for line in sys.stdin: n = int(line.strip()) if n == 0: break print(calculate_years(n))"], "perturbed_original": ["a = [] a[:4] = [0, 1, 2, 3] inList = [] while True: price = int(input()) if price == 0: break inList.append(int(input())) n = max(inList) for i in range(4, n + 1): a[i] = a[i-1]  3650) + (a[i] % 3650 != 0))"], "original_ll": -1.2358615398406982, "sampled_ll": -0.5710834264755249, "all_perturbed_sampled_ll": [-1.5294663906097412], "all_perturbed_original_ll": [-2.010715961456299], "perturbed_sampled_ll": -1.5294663906097412, "perturbed_original_ll": -2.010715961456299, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint main(){\n  int i;\n  int c[128],m,n;\n  char s[256],*t;  \n  for(;;){\n    fgets(s,256,stdin);\n    s[strlen(s)-1]='\\0';\n    t=strtok(s,\" \");\n    c[0]=atoi(t)<10?atoi(t):10;\n    if(c[0]==0)\n      break;\n    for(n=1;(t=strtok(NULL,\" \"))!=NULL;n++)\n      c[n]=atoi(t)<10?atoi(t):10;\n    m=0;\n    for(i=0;i<n;i++)\n      m+=c[i];\n    for(i=0;i<n;i++){\n      if(m<12&&c[i]==1)\n\tm+=10;\n    }\n    if(m>21)\n      m=0;\n    printf(\"%d\\n\",m);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int card;\n    \n    while (1) {\n        scanf(\"%d\", &card);\n        if (card == 0) break;\n        \n        int sum = 0;\n        int aces = 0;\n        \n        do {\n            if (card == 1) {\n                sum += 1;\n                aces++;\n            } else if (card >= 2 && card <= 9) {\n                sum += card;\n            } else if (card >= 10 && card <= 13) {\n                sum += 10;\n            }\n            \n            int c = getchar();\n            if (c == '\\n' || c == EOF) break;\n            scanf(\"%d\", &card);\n        } while (1);\n        \n        // Try to maximize score by using 11 for aces\n        while (aces > 0 && sum + 10 <= 21) {\n            sum += 10;\n            aces--;\n        }\n        \n        if (sum > 21) {\n            sum = 0;\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  int aces = 0; do { if (card == 1) { sum += 1; aces++; } else if (card >= 2 && card <= 9) { sum += card; } else if (card >= 10 && card <= 13) { sum += 10; } int c = getchar(); if (c == '\\n' || c == EOF) break; scanf(\"%d\", &card); } while (1); // Try to maximize score by using 11 for aces while (aces > 0 && sum + 10 <= 21) { sum += 10; aces--; } if (sum >  0; }"], "perturbed_original": ["#include<stdio.h> #include<stdlib.h> #include<string.h> int main(){ int i; int c[128],m,n; char s[256],*t; for(;;){ fgets(s,256,stdin); s[strlen(s)-1]='\\0'; t=strtok(s,\" \"); c[0]=atoi(t)<10?atoi(t):10; if(c[0]==0) break; for(n=1;(t=strtok(NULL,\" \"))!=NULL;n++) c[n]=atoi(t)<10?atoi(t):10; m=0; for(i=0;i<n;i++)  0; }"], "original_ll": -1.152605652809143, "sampled_ll": -0.7723479866981506, "all_perturbed_sampled_ll": [-1.5350147485733032], "all_perturbed_original_ll": [-1.497314453125], "perturbed_sampled_ll": -1.5350147485733032, "perturbed_original_ll": -1.497314453125, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile(sc.hasNext()) {\n\t\t\tString[] text = sc.nextLine().split(\" \");\n\t\t\tint[] cards = new int[text.length];\n\t\t\tboolean one = false; //1????????????\n\t\t\tint sum = 0; //????\u00a8??????\u00b0\n\t\t\tboolean flag = false;\n\n\t\t\tfor(int $ = 0; $ < text.length; $++) {\n\t\t\t\tcards[$] = Integer.parseInt(text[$]);\n\t\t\t\tif(cards[0] == 0) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(cards[$] == 1) {\n\t\t\t\t\tone = true;\n\t\t\t\t\tsum++;\n\t\t\t\t} else if(cards[$] >= 10 && cards[$] <=13) {\n\t\t\t\t\tsum += 10;\n\t\t\t\t} else {\n\t\t\t\t\tsum += cards[$];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flag) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(one) {\n\t\t\t\tif(sum + 10 <= 21) {\n\t\t\t\t\tsum += 10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(sum > 21) {\n\t\t\t\tsum = 0;\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String line = sc.nextLine().trim();\n            if (line.equals(\"0\")) {\n                break;\n            }\n            \n            String[] tokens = line.split(\"\\\\s+\");\n            int[] cards = new int[tokens.length];\n            for (int i = 0; i < tokens.length; i++) {\n                cards[i] = Integer.parseInt(tokens[i]);\n            }\n            \n            int result = calculateScore(cards);\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n    \n    private static int calculateScore(int[] cards) {\n        int baseSum = 0;\n        int aceCount = 0;\n        \n        for (int card : cards) {\n            if (card == 1) {\n                aceCount++;\n                baseSum += 1;\n            } else if (card >= 10) {\n                baseSum += 10;\n            } else {\n                baseSum += card;\n            }\n        }\n        \n        // Try to maximize the score by using aces as 11\n        int maxScore = baseSum;\n        for (int i = 0; i <= aceCount; i++) {\n            int score = baseSum + i * 10; // Each ace used as 11 adds 10 more (since base is 1)\n            if (score <= 21) {\n                maxScore = Math.max(maxScore, score);\n            }\n        }\n        \n        if (maxScore > 21) {\n            return 0;\n        }\n        \n        return maxScore;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new  { break; } String[] tokens = line.split(\"\\\\s+\"); int[] cards = new int[tokens.length]; for (int i = 0; i < tokens.length; i++) { cards[i] = Integer.parseInt(tokens[i]);  static int calculateScore(int[] cards) { int baseSum = 0; int aceCount = 0; for  aceCount++; baseSum += 1; } else if (card >= 10) { baseSum += 10; } else { baseSum += card; } } // Try  maxScore =  { int score = baseSum + i * 10; // Each ace used as 11 adds 10 more (since base is 1) if (score <= 21) { maxScore = Math.max(maxScore, score); } } if (maxScore > 21) { return 0; } return maxScore; } }"], "perturbed_original": ["<extra_id_15> new Scanner(System.in); public static void main(String[] args) { while(sc.hasNext()) { String[] text = sc.nextLine().split(\" \"); int[] cards = new int[text.length]; boolean one = false; //1???????????? int sum = 0; //????\u00a8??????\u00b0 boolean flag = false; for(int $ = 0; $ < text.length; $++) { cards[$] = Integer.parseInt(text[$]); if(cards[0] == 0) { flag = true; break; }  if(cards[$] >= 10 && cards[$] <=13) { sum += 10; } else { sum += cards[$]; } } if(flag)  { sum += 10; } } if(sum > 21) { sum = 0; } System.out.println(sum); } } }"], "original_ll": -0.9448589086532593, "sampled_ll": -0.6871176362037659, "all_perturbed_sampled_ll": [-1.6631386280059814], "all_perturbed_original_ll": [-1.72586190700531], "perturbed_sampled_ll": -1.6631386280059814, "perturbed_original_ll": -1.72586190700531, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    h = map(int, raw_input().split())\n    if h[0] == 0:\n        break\n    t = 0\n    a = 0\n    for c in sorted(h, reverse=True):\n        if 2 <= c <= 9:\n            t += c\n        elif 10 <= c:\n            t += 10\n        elif c == 1:\n            a += 1\n            \n    t += a\n    if 21 < t:\n        print 0\n    else:\n        for i in range(a):\n            if 21 < t + 10:\n                print t\n                break\n            else:\n                t += 10\n        else:\n            print t", "sampled": "import sys\n\ndef calculate_hand_value(cards):\n    # Convert card values\n    converted = []\n    ace_count = 0\n    \n    for card in cards:\n        if card == 1:\n            ace_count += 1\n            converted.append(1)\n        elif card >= 10:\n            converted.append(10)\n        else:\n            converted.append(card)\n    \n    # Calculate base sum (all aces as 1)\n    base_sum = sum(converted)\n    \n    # Try to maximize by converting aces from 1 to 11\n    max_value = base_sum\n    \n    # We can convert at most one ace from 1 to 11 (adding 10 to the sum)\n    # because converting more than one would add 20+ which would likely bust\n    for i in range(ace_count + 1):\n        # i is the number of aces we treat as 11\n        current_sum = base_sum + (i * 10)\n        if current_sum <= 21:\n            max_value = max(max_value, current_sum)\n    \n    if max_value > 21:\n        return 0\n    return max_value\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line == '0':\n        break\n    \n    cards = list(map(int, line.split()))\n    result = calculate_hand_value(cards)\n    print(result)\n", "perturbed_sampled": ["import sys def calculate_hand_value(cards): # Convert card values converted = [] ace_count =  += 1 converted.append(1) elif card >= 10: converted.append(10) else: converted.append(card) # Calculate base sum (all aces as 1) base_sum = sum(converted) # Try to  base_sum # We can convert at   20+ which would likely bust for i in range(ace_count + 1): # i is the number of aces we treat as 11 current_sum = base_sum + (i * 10) if current_sum <= 21: max_value = max(max_value, current_sum) if max_value > 21: return 0 return max_value for line in sys.stdin: line = line.strip() if line == '0': break cards = list(map(int, line.split())) result = calculate_hand_value(cards) print(result)"], "perturbed_original": ["while True: h =  a = 0 for c in sorted(h, reverse=True): if 2 <= c <= 9: t += c elif 10 <= c: t += 10 elif c == 1: a += 1 t +=  in range(a): if 21 < t + 10: print t break else: t += 10 else: print t"], "original_ll": -1.105502963066101, "sampled_ll": -1.208677887916565, "all_perturbed_sampled_ll": [-2.1549630165100098], "all_perturbed_original_ll": [-2.3231494426727295], "perturbed_sampled_ll": -2.1549630165100098, "perturbed_original_ll": -2.3231494426727295, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\ntypedef struct i{char f[21];int s,w;} i;\ni g[10];\nint n,t[10],f[10]={0},ans[10],max=0;\n\nvoid rec(int d)\n{\n\tint i,w=0,G=0;\n\tif(d==n)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(w>g[t[i]].s)\n\t\t\t\treturn;\n\t\t\tw+=g[t[i]].w;\n\t\t\tG+=g[t[i]].w*(i+1);\n\t\t}\n\t\tif(max<G)\n\t\t{\n\t\t\tmax=G;\n\t\t\tmemcpy(ans,t,sizeof(t));\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(!f[i])\n\t\t\t{\n\t\t\t\tf[i]=1;\n\t\t\t\tt[d]=i;\n\t\t\t\trec(d+1);\n\t\t\t\tf[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i;\n\tfor(;;)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%s %d%d\",g[i].f,&g[i].w,&g[i].s);\n\t\trec(0);\n\t\twhile(--n>=0)\n\t\t\tputs(g[ans[n]].f);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[25];\n    int weight;\n    int strength;\n    int index;\n} Food;\n\nint n;\nFood foods[10];\nFood current[10];\nFood best[10];\nint visited[10];\ndouble best_center;\n\nint check_valid() {\n    for (int i = 0; i < n; i++) {\n        int weight_above = 0;\n        for (int j = i + 1; j < n; j++) {\n            weight_above += current[j].weight;\n        }\n        if (current[i].strength < weight_above) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ndouble calculate_center() {\n    int numerator = 0;\n    int denominator = 0;\n    for (int i = 0; i < n; i++) {\n        numerator += (i + 1) * current[i].weight;\n        denominator += current[i].weight;\n    }\n    return (double)numerator / denominator;\n}\n\nvoid solve(int depth) {\n    if (depth == n) {\n        if (check_valid()) {\n            double center = calculate_center();\n            if (center < best_center) {\n                best_center = center;\n                for (int i = 0; i < n; i++) {\n                    best[i] = current[i];\n                }\n            }\n        }\n        return;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            visited[i] = 1;\n            current[depth] = foods[i];\n            solve(depth + 1);\n            visited[i] = 0;\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s %d %d\", foods[i].name, &foods[i].weight, &foods[i].strength);\n            foods[i].index = i;\n        }\n        \n        best_center = 1e9;\n        memset(visited, 0, sizeof(visited));\n        \n        solve(0);\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%s\\n\", best[i].name);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  current[10]; Food best[10]; int visited[10]; double best_center; int check_valid() { for (int i = 0; i < n; i++) { int weight_above = 0; for (int j = i + 1; j < n; j++) { weight_above += current[j].weight; } if (current[i].strength < weight_above) { return 0; } } return 1; } double calculate_center() { int numerator = 0; int denominator = 0; for (int i =   denominator; } void solve(int depth) { if (depth == n) { if (check_valid()) { double center = calculate_center(); if (center < best_center) { best_center = center; for (int i = 0; i < n; i++) { best[i] = current[i]; } } } return; }  if (!visited[i])  visited[i] = 0; } }  (n == 0) break; for (int i = 0; i < n; i++) { scanf(\"%s %d %d\", foods[i].name, &foods[i].weight, &foods[i].strength); foods[i].index = i; } best_center = 1e9; memset(visited, 0, sizeof(visited)); solve(0); for (int i = 0; i < n; i++) { printf(\"%s\\n\", best[i].name); } } return 0; }"], "perturbed_original": [" int n,t[10],f[10]={0},ans[10],max=0; void rec(int d) { int i,w=0,G=0; if(d==n) { for(i=0;i<n;i++) { if(w>g[t[i]].s) return; w+=g[t[i]].w; G+=g[t[i]].w*(i+1); } if(max<G) { max=G; memcpy(ans,t,sizeof(t)); } } else { for(i=0;i<n;i++) { if(!f[i]) { f[i]=1; t[d]=i; rec(d+1); f[i]=0; } }  if(!n) return 0; for(i=0;i<n;i++) scanf(\"%s %d%d\",g[i].f,&g[i].w,&g[i].s); rec(0); while(--n>=0) puts(g[ans[n]].f); } return 0; }"], "original_ll": -1.005781888961792, "sampled_ll": -0.5256456732749939, "all_perturbed_sampled_ll": [-1.2448656558990479], "all_perturbed_original_ll": [-1.5168755054473877], "perturbed_sampled_ll": -1.2448656558990479, "perturbed_original_ll": -1.5168755054473877, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Food {\n\tString name;\n\tint w;\n\tint s;\n\n\tpublic Food(String name, int w, int s) {\n\t\tthis.name = name;\n\t\tthis.w = w;\n\t\tthis.s = s;\n\t}\n\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint max = 0;\n\t\t\tList<Food> list = new ArrayList<Food>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString l = scanner.next();\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tlist.add(new Food(l, a, b));\n\t\t\t\tmax += a;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint l = 0;\n\t\t\t\tint k = 0;\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\tint m = max - list.get(j).w;\n\t\t\t\t\tint ss = list.get(j).s;\n\t\t\t\t\tif (m <= ss) {\n\t\t\t\t\t\tif (list.get(j).w > k) {\n\t\t\t\t\t\t\tk = list.get(j).w;\n\t\t\t\t\t\t\tl = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax -= list.get(l).w;\n\t\t\t\tSystem.out.println(list.get(l).name);\n\t\t\t\tlist.get(l).s = -10;\n\t\t\t\tlist.get(l).w = 0;\n\t\t\t}\n\t\t}\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Food {\n        String name;\n        int weight;\n        int strength;\n        \n        Food(String name, int weight, int strength) {\n            this.name = name;\n            this.weight = weight;\n            this.strength = strength;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            Food[] foods = new Food[n];\n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                int weight = sc.nextInt();\n                int strength = sc.nextInt();\n                foods[i] = new Food(name, weight, strength);\n            }\n            \n            int[] bestPerm = null;\n            double minG = Double.MAX_VALUE;\n            \n            int[] perm = new int[n];\n            for (int i = 0; i < n; i++) {\n                perm[i] = i;\n            }\n            \n            do {\n                if (isValid(foods, perm)) {\n                    double g = calculateG(foods, perm);\n                    if (g < minG) {\n                        minG = g;\n                        bestPerm = perm.clone();\n                    }\n                }\n            } while (nextPermutation(perm));\n            \n            for (int i = 0; i < n; i++) {\n                System.out.println(foods[bestPerm[i]].name);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static boolean isValid(Food[] foods, int[] perm) {\n        int n = perm.length;\n        for (int i = 0; i < n; i++) {\n            int weightAbove = 0;\n            for (int j = i + 1; j < n; j++) {\n                weightAbove += foods[perm[j]].weight;\n            }\n            if (foods[perm[i]].strength < weightAbove) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    static double calculateG(Food[] foods, int[] perm) {\n        int n = perm.length;\n        double numerator = 0;\n        double denominator = 0;\n        for (int i = 0; i < n; i++) {\n            numerator += (i + 1) * foods[perm[i]].weight;\n            denominator += foods[perm[i]].weight;\n        }\n        return numerator / denominator;\n    }\n    \n    static boolean nextPermutation(int[] array) {\n        int i = array.length - 2;\n        while (i >= 0 && array[i] >= array[i + 1]) {\n            i--;\n        }\n        \n        if (i < 0) {\n            return false;\n        }\n        \n        int j = array.length - 1;\n        while (array[j] <= array[i]) {\n            j--;\n        }\n        \n        swap(array, i, j);\n        reverse(array, i + 1, array.length - 1);\n        return true;\n    }\n    \n    static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    \n    static void reverse(int[] array, int start, int end) {\n        while (start < end) {\n            swap(array, start, end);\n            start++;\n            end--;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Food { String name; int weight; int strength; Food(String name, int weight, int strength) { this.name = name; this.weight = weight; this.strength = strength; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt();  { String name = sc.next(); int weight = sc.nextInt(); int  int[] bestPerm = null; double minG = Double.MAX_VALUE; int[] perm = new int[n]; for (int i = 0; i < n; i++) { perm[i] = i; } do { if (isValid(foods, perm)) { double g = calculateG(foods, perm); if (g < minG) { minG = g; bestPerm =  0;  = perm.length; for (int i = 0; i < n; i++) { int weightAbove = 0; for (int j = i + 1; j < n; j++) { weightAbove += foods[perm[j]].weight; } if (foods[perm[i]].strength < weightAbove) { return false; } } return true; } static double calculateG(Food[] foods, int[] perm) { int n = perm.length; double numerator = 0; double denominator = 0; for (int i = 0; i < n; i++) { numerator += (i +  denominator; } static boolean nextPermutation(int[] array) { int i = array.length - 2; while (i  int j = array.length - 1; while (array[j] <= array[i]) { j--; } swap(array, i, j);  static void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } static void reverse(int[] array, int start, int end) { while (start < end) { swap(array, start, end); start++; end--; } } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.List; import  public Food(String name, int w, int s) { this.name = name; this.w = w; this.s =  main(String[] args) { new Main().run(); } public void run() { Scanner scanner = new Scanner(System.in); while (true) { int  new ArrayList<Food>(); for (int i = 0;  a = scanner.nextInt(); int b = scanner.nextInt(); list.add(new Food(l, a, b)); max += a; } for (int i = 0; i < n; i++) { int l =  j < list.size(); j++) { int m = max - list.get(j).w; int ss = list.get(j).s; if (m <= ss) { if (list.get(j).w > k) { k = list.get(j).w; l = j; } } } max -= list.get(l).w; System.out.println(list.get(l).name); list.get(l).s = -10; list.get(l).w = 0; } } } }"], "original_ll": -0.6833577156066895, "sampled_ll": -0.346086323261261, "all_perturbed_sampled_ll": [-1.048967957496643], "all_perturbed_original_ll": [-1.6067322492599487], "perturbed_sampled_ll": -1.048967957496643, "perturbed_original_ll": -1.6067322492599487, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0170\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom collections import namedtuple\nfrom itertools import permutations\n\n\ndef solve(items):\n    total_weight = 0\n    for i in items:\n        total_weight += i.w\n\n    best_ans = []\n    best_gp = float('inf')\n    # ???????????????????????????????????????????????\u00b0?????????????????\u00a7????????????\n    for perm in permutations(items):\n        ans = []\n        squashed = False\n        cw = 0\n        gp = 0\n        n = len(items)\n\n        for p in perm:\n            if p.s < cw:\n                squashed = True\n                break\n            cw += p.w\n            ans.append(p.name)\n            gp += n * p.w\n            n -= 1\n        # ????????\u00b0???????????\u00a3?????\u00b4????????????????\u00a8???????????????????????????????????????\u00a3?????????????????\u00a7????????????\n        if not squashed:\n            gp /= total_weight\n            if gp < best_gp:\n                best_gp = gp\n                best_ans = ans[:]\n    # ????????????????????????????????\u00a3??????????????\u00a7?????????????\u00b1?????????????????????????????????????????????????\n    best_ans.reverse()\n    return best_ans\n\n\nitem = namedtuple('item', ['name', 'w', 's'])\ndef main(args):\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        items = []\n        for _ in range(n):\n            name, w, s = input().split()\n            items.append(item(name, int(w), int(s)))\n\n        result = solve(items)\n        print('\\n'.join(result))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])", "sampled": "from itertools import permutations\n\ndef is_valid(order, items):\n    # Check if the order is valid (no food is crushed)\n    # order is a list of indices\n    for i in range(len(order)):\n        weight_above = sum(items[order[j]][1] for j in range(i + 1, len(order)))\n        if items[order[i]][2] < weight_above:\n            return False\n    return True\n\ndef calculate_center_of_gravity(order, items):\n    # Calculate center of gravity\n    # Lower is better\n    numerator = sum((i + 1) * items[order[i]][1] for i in range(len(order)))\n    denominator = sum(items[order[i]][1] for i in range(len(order)))\n    return numerator / denominator\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    items = []\n    for _ in range(n):\n        parts = input().split()\n        name = parts[0]\n        weight = int(parts[1])\n        strength = int(parts[2])\n        items.append((name, weight, strength))\n    \n    best_order = None\n    best_cog = float('inf')\n    \n    # Try all permutations\n    for perm in permutations(range(n)):\n        if is_valid(perm, items):\n            cog = calculate_center_of_gravity(perm, items)\n            if cog < best_cog:\n                best_cog = cog\n                best_order = perm\n    \n    # Output the result\n    for idx in best_order:\n        print(items[idx][0])\n", "perturbed_sampled": ["from itertools import permutations  (no food is crushed) # order is  sum(items[order[j]][1] for j in range(i + 1, len(order))) if items[order[i]][2] < weight_above: return False return True def calculate_center_of_gravity(order, items): # Calculate center of gravity # Lower is better numerator = sum((i +  for i in range(len(order))) return numerator / denominator while True: n = int(input()) if n  parts = input().split() name = parts[0] weight = int(parts[1]) strength = int(parts[2]) items.append((name, weight, strength)) best_order = None best_cog = float('inf') # Try all permutations for perm in permutations(range(n)): if is_valid(perm, items): cog = calculate_center_of_gravity(perm, items) if cog < best_cog: best_cog = cog best_order = perm # Output the result for idx in best_order: print(items[idx][0])"], "perturbed_original": ["# -*- coding: utf-8 -*- \"\"\" http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0170 \"\"\" import sys from sys import stdin input = stdin.readline from collections import namedtuple from itertools import permutations def solve(items): total_weight = 0 for i in items: total_weight += i.w best_ans =  ans = [] squashed = False cw = 0 gp = 0  cw: squashed = True break  total_weight if gp < best_gp: best_gp = gp best_ans = ans[:] # ????????????????????????????????\u00a3??????????????\u00a7?????????????\u00b1????????????????????????????????????????????????? best_ans.reverse() return best_ans item = namedtuple('item', ['name', 'w', 's']) def main(args): while True: n = int(input()) if n == 0: break items = [] for _ in range(n): name, w, s = input().split() items.append(item(name, int(w), int(s))) result = solve(items) print('\\n'.join(result)) if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -1.2382045984268188, "sampled_ll": -0.9374412298202515, "all_perturbed_sampled_ll": [-2.2668633460998535], "all_perturbed_original_ll": [-1.932702898979187], "perturbed_sampled_ll": -2.2668633460998535, "perturbed_original_ll": -1.932702898979187, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void)\n{\n\tchar class[20];\n\tint i, am, pm;\n\t\n\tfor(i=0;i<9;i++)\n\t{\n\t\tscanf(\"%s %d %d\",class,&am,&pm);\n\t\tprintf(\"%s %d %d\\n\",class,am+pm,(200*am)+(300*pm));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    char name[16];\n    int morning, afternoon;\n    \n    for (int i = 0; i < 9; i++) {\n        scanf(\"%s %d %d\", name, &morning, &afternoon);\n        int total = morning + afternoon;\n        int revenue = morning * 200 + afternoon * 300;\n        printf(\"%s %d %d\\n\", name, total, revenue);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { char name[16]; int morning, afternoon; for (int i = 0; i < 9; i++) { scanf(\"%s %d %d\", name, &morning, &afternoon); int total = morning +  300; printf(\"%s %d %d\\n\", name, total, revenue); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { char class[20]; int i, am, pm; for(i=0;i<9;i++) { scanf(\"%s %d %d\",class,&am,&pm); printf(\"%s %d %d\\n\",class,am+pm,(200*am)+(300*pm)); } return 0; }"], "original_ll": -1.5145469903945923, "sampled_ll": -1.0503125190734863, "all_perturbed_sampled_ll": [-1.650433897972107], "all_perturbed_original_ll": [-1.6370247602462769], "perturbed_sampled_ll": -1.650433897972107, "perturbed_original_ll": -1.6370247602462769, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/**\n * @author yuichirw\n *\n */\nimport java.util.*;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\tint a,b,rel,sum;\n\t\tString c;\n\n\t\tfor(int i = 0; i < 9; i++) {\n\t\t\tc = sc.next(); a = sc.nextInt(); b = sc.nextInt();\n\t\t\tsum = a + b;\n\t\t\trel = a * 200 + b * 300;\n\t\t\tSystem.out.println(c + \" \" + sum + \" \" + rel);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        for (int i = 0; i < 9; i++) {\n            String name = sc.next();\n            int morning = sc.nextInt();\n            int afternoon = sc.nextInt();\n            \n            int totalVisitors = morning + afternoon;\n            int totalRevenue = morning * 200 + afternoon * 300;\n            \n            System.out.println(name + \" \" + totalVisitors + \" \" + totalRevenue);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args)  0; i < 9; i++) { String name = sc.next(); int morning = sc.nextInt(); int afternoon = sc.nextInt(); int totalVisitors = morning + afternoon; int totalRevenue = morning * 200  + \" \" + totalRevenue); } sc.close(); } }"], "perturbed_original": ["/** * @author yuichirw * */ import java.util.*; public class Main { static Scanner sc = new Scanner(System.in); public static void main(String[] args) { int a,b,rel,sum; String c; for(int i  + b; rel = a * 200 + b * 300; System.out.println(c + \" \" + sum + \" \" + rel); } } }"], "original_ll": -1.304550051689148, "sampled_ll": -0.6639609932899475, "all_perturbed_sampled_ll": [-2.088259220123291], "all_perturbed_original_ll": [-2.196428060531616], "perturbed_sampled_ll": -2.088259220123291, "perturbed_original_ll": -2.196428060531616, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for i in range(9):\n    name,a,b=list(input().split())\n    print(name,int(a)+int(b),int(a)*200+int(b)*300)\n", "sampled": "for _ in range(9):\n    line = input().split()\n    name = line[0]\n    morning = int(line[1])\n    afternoon = int(line[2])\n    total = morning + afternoon\n    revenue = morning * 200 + afternoon * 300\n    print(name, total, revenue)\n", "perturbed_sampled": ["for _ in range(9): line = input().split() name = line[0] morning = int(line[1]) afternoon = int(line[2]) total = morning + afternoon revenue = morning * 200 + afternoon * 300 print(name, total, revenue)"], "perturbed_original": ["for i in range(9): name,a,b=list(input().split()) print(name,int(a)+int(b),int(a)*200+int(b)*300)"], "original_ll": -2.2199015617370605, "sampled_ll": -1.1376500129699707, "all_perturbed_sampled_ll": [-1.6383697986602783], "all_perturbed_original_ll": [-2.5514755249023438], "perturbed_sampled_ll": -1.6383697986602783, "perturbed_original_ll": -2.5514755249023438, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(a,b,c){for(a=b=0,getchar();(c=getchar())!='0';)if(c-'\\n')c=='A'?a++:b++;else{printf(\"%d %d\\n\",a>b?a+1:a,a<b?b+1:b),a=b=0;if(getchar()=='0')break;}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char record[101];\n    \n    while(1) {\n        if(scanf(\"%s\", record) != 1) break;\n        if(strcmp(record, \"0\") == 0) break;\n        \n        int len = strlen(record);\n        int scoreA = 0, scoreB = 0;\n        char lastServer = record[0];\n        \n        for(int i = 0; i < len; i++) {\n            if(record[i] != lastServer) {\n                // Server changed, so the previous server lost the point\n                if(lastServer == 'A') {\n                    scoreB++;\n                } else {\n                    scoreA++;\n                }\n                lastServer = record[i];\n            } else {\n                // Server stayed same, so server won the point\n                if(lastServer == 'A') {\n                    scoreA++;\n                } else {\n                    scoreB++;\n                }\n            }\n            \n            // Check if game ended\n            if(scoreA >= 11 || scoreB >= 11) {\n                if(scoreA >= 11 && scoreB >= 11) {\n                    if(scoreA - scoreB >= 2 || scoreB - scoreA >= 2) {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", scoreA, scoreB);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() {  \"0\") == 0) break; int len = strlen(record); int scoreA = 0, scoreB =  < len; i++) { if(record[i] != lastServer) { // Server changed, so the previous server lost the point if(lastServer  = record[i]; } else { // Server stayed same, so server won the point if(lastServer ==  Check if game ended if(scoreA >= 11 || scoreB >= 11) { if(scoreA >= 11 && scoreB >= 11) { if(scoreA - scoreB >= 2 || scoreB - scoreA >= 2) { break; } } else { break; } } } printf(\"%d %d\\n\", scoreA, scoreB); } return 0; }"], "perturbed_original": ["main(a,b,c){for(a=b=0,getchar();(c=getchar())!='0';)if(c-'\\n')c=='A'?a++:b++;else{printf(\"%d %d\\n\",a>b?a+1:a,a<b?b+1:b),a=b=0;if(getchar()=='0')break;}exit(0);}"], "original_ll": -2.4453697204589844, "sampled_ll": -0.8700991868972778, "all_perturbed_sampled_ll": [-1.942020297050476], "all_perturbed_original_ll": [-2.4453697204589844], "perturbed_sampled_ll": -1.942020297050476, "perturbed_original_ll": -2.4453697204589844, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main\n{\n    public static void main(String args[])\n    {\n\tScanner scan=new Scanner(System.in);\n\twhile(true)\n\t    {\n\t\tString str=scan.next();\n\t\tif(str.equals(\"0\"))break;\n\t\tint countA=0,countB=0;\n\t\tif(str.charAt(str.length()-1)=='A')\n\t\t    {\n\t\t\tcountA+=1;\n\t\t\t//countB-=1;\n\t\t    }\n\t\telse if(str.charAt(str.length()-1)=='B')\n\t\t    {\n\t\t    countB+=1;\n\t\t    //countA-=1;\n\t\t    }\n\t\tfor(int i=1;i<str.length();i++)\n\t\t    {\n\t\t\tif(str.charAt(i)=='A')countA+=1;\n\t\t\telse countB+=1;\n\t\t    }\n\t\tif(str.charAt(str.length()-1)=='B'&&(countB<countA))\n\t\t    {\n\t\t\tcountB-=1;\n\t\t\tcountA+=1;\n\t\t    }\n\t\telse if(str.charAt(str.length()-1)=='A'&&(countB>countA))\n\t\t    {\n\t\t\tcountA-=1;\n\t\t\tcountB+=1;\n\t\t    }\n\t\tSystem.out.println(countA+\" \"+countB);\n\t    }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String line = sc.nextLine();\n            if (line.equals(\"0\")) break;\n            \n            String game1 = line;\n            String game2 = sc.nextLine();\n            String game3 = sc.nextLine();\n            \n            System.out.println(processGame(game1));\n            System.out.println(processGame(game2));\n            System.out.println(processGame(game3));\n        }\n        \n        sc.close();\n    }\n    \n    static String processGame(String record) {\n        int scoreA = 0;\n        int scoreB = 0;\n        \n        for (int i = 0; i < record.length(); i++) {\n            char server = record.charAt(i);\n            \n            // The server who is recorded is the one who won the point\n            if (server == 'A') {\n                scoreA++;\n            } else {\n                scoreB++;\n            }\n            \n            // Check if game is over\n            if (scoreA >= 11 || scoreB >= 11) {\n                if (scoreA >= 10 && scoreB >= 10) {\n                    // Deuce situation - need 2 point difference\n                    if (Math.abs(scoreA - scoreB) >= 2) {\n                        break;\n                    }\n                } else {\n                    // Normal situation - first to 11\n                    if (scoreA >= 11 || scoreB >= 11) {\n                        break;\n                    }\n                }\n            }\n        }\n        \n        return scoreA + \" \" + scoreB;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { String line =  = sc.nextLine(); String game3 = sc.nextLine(); System.out.println(processGame(game1)); System.out.println(processGame(game2)); System.out.println(processGame(game3)); } sc.close(); } static String processGame(String record) { int scoreA = 0;  < record.length(); i++) { char server = record.charAt(i); // The server who is recorded is the one who won the point if (server == 'A') { scoreA++;  over if (scoreA >= 11 || scoreB >= 11)  // Deuce situation -  { break; } } else { // Normal situation - first to 11 if (scoreA >= 11 || scoreB >= 11) { break; } } } } return scoreA + \" \" + scoreB; } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String args[]) { Scanner scan=new Scanner(System.in); while(true) { String str=scan.next(); if(str.equals(\"0\"))break; int  //countA-=1; } for(int i=1;i<str.length();i++) { if(str.charAt(i)=='A')countA+=1; else countB+=1; } if(str.charAt(str.length()-1)=='B'&&(countB<countA)) { countB-=1; countA+=1; } else if(str.charAt(str.length()-1)=='A'&&(countB>countA)) { countA-=1; countB+=1; } System.out.println(countA+\" \"+countB); } } }"], "original_ll": -0.7426262497901917, "sampled_ll": -0.9009482860565186, "all_perturbed_sampled_ll": [-1.7930264472961426], "all_perturbed_original_ll": [-1.0226609706878662], "perturbed_sampled_ll": -1.7930264472961426, "perturbed_original_ll": -1.0226609706878662, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    ten=input()\n    if ten=='0':\n        break\n    a=ten.count('A')\n    b=ten.count('B')\n    if ten[0]=='A':\n        a-=1\n    elif ten[0]=='B':\n        b-=1\n    if a>b:\n        a+=1\n    else:\n        b+=1\n    print(a,b)\n", "sampled": "import sys\n\ndef solve_game(record):\n    score_a = 0\n    score_b = 0\n    \n    i = 0\n    while i < len(record):\n        server = record[i]\n        \n        # Check if game is over\n        if score_a >= 11 or score_b >= 11:\n            if abs(score_a - score_b) >= 2:\n                break\n            elif score_a >= 11 and score_b >= 11:\n                if abs(score_a - score_b) >= 2:\n                    break\n        \n        # Determine who won the point\n        if i + 1 < len(record):\n            next_server = record[i + 1]\n            if next_server == server:\n                # Same server, so server won the point\n                if server == 'A':\n                    score_a += 1\n                else:\n                    score_b += 1\n            else:\n                # Different server, so server lost the point\n                if server == 'A':\n                    score_b += 1\n                else:\n                    score_a += 1\n        else:\n            # Last serve, determine winner based on current score\n            # The game must end after this serve\n            if score_a < 11 and score_b < 11:\n                # Someone needs to reach 11\n                if server == 'A':\n                    score_a += 1\n                else:\n                    score_b += 1\n            elif score_a >= 10 and score_b >= 10:\n                # In deuce, need 2 point difference\n                if server == 'A':\n                    if score_a == score_b or score_a == score_b + 1:\n                        score_a += 1\n                    else:\n                        score_b += 1\n                else:\n                    if score_b == score_a or score_b == score_a + 1:\n                        score_b += 1\n                    else:\n                        score_a += 1\n            else:\n                if server == 'A':\n                    score_a += 1\n                else:\n                    score_b += 1\n        \n        i += 1\n    \n    return score_a, score_b\n\nwhile True:\n    line = input().strip()\n    if line == \"0\":\n        break\n    \n    game1 = line\n    game2 = input().strip()\n    game3 = input().strip()\n    \n    score1 = solve_game(game1)\n    score2 = solve_game(game2)\n    score3 = solve_game(game3)\n    \n    print(f\"{score1[0]} {score1[1]}\")\n    print(f\"{score2[0]} {score2[1]}\")\n    print(f\"{score3[0]} {score3[1]}\")\n", "perturbed_sampled": ["import sys def solve_game(record): score_a = 0 score_b = 0 i = 0 while i < len(record): server = record[i] # Check if game is  abs(score_a - score_b) >= 2: break elif score_a >= 11 and score_b >= 11: if abs(score_a - score_b) >=  + 1  server: # Same server, so server won the point if server == 'A': score_a += 1 else: score_b += 1 else: # Different server, so server lost the point if server  # Last serve, determine winner based on  if score_a < 11 and score_b < 11: # Someone needs to reach  += 1 elif score_a >= 10 and score_b >= 10: # In deuce, need 2 point difference if server == 'A': if score_a == score_b or score_a == score_b + 1: score_a += 1 else: score_b += 1 else: if score_b == score_a or score_b == score_a + 1: score_b += 1 else: score_a += 1 else: if  i += 1 return score_a, score_b while True: line = input().strip() if line == \"0\": break game1 = line game2 = input().strip() game3 = input().strip() score1 = solve_game(game1) score2 = solve_game(game2) score3 = solve_game(game3) print(f\"{score1[0]} {score1[1]}\") print(f\"{score2[0]} {score2[1]}\") print(f\"{score3[0]} {score3[1]}\")"], "perturbed_original": ["while True: ten=input() if ten=='0': break a=ten.count('A') b=ten.count('B') if ten[0]=='A': a-=1 elif ten[0]=='B': b-=1 if a>b: a+=1 else: b+=1 print(a,b)"], "original_ll": -1.0308562517166138, "sampled_ll": -0.7485212683677673, "all_perturbed_sampled_ll": [-1.4591790437698364], "all_perturbed_original_ll": [-1.5659122467041016], "perturbed_sampled_ll": -1.4591790437698364, "perturbed_original_ll": -1.5659122467041016, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\tint n,nbox[10000],temp,i,j,flg;\n\tscanf(\"%d\",&n);\n\twhile(n!=-1){\n\t\ttemp=0;\n\t\ti=0;\n\t\tflg=0;\n\t\twhile(n>=4){\n\t\t\tnbox[i]=n%4;\n\t\t\tn/=4;\n\t\t\ti++;\n\t\t}\n\t\tprintf(\"%d\",n);\n\t\tfor(j=i;j>=0;j--){\n\t\t\tif(flg==0){\n\t\t\t\tflg=1;\n\t\t\t}\n\t\t\telse if(flg==1){\n\t\t\t\tprintf(\"%d\",nbox[j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == -1) break;\n        \n        if(n == 0) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        char result[32];\n        int index = 0;\n        \n        while(n > 0) {\n            result[index++] = '0' + (n % 4);\n            n /= 4;\n        }\n        \n        for(int i = index - 1; i >= 0; i--) {\n            printf(\"%c\", result[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) { scanf(\"%d\", &n); if(n == -1) break; if(n == 0) { printf(\"0\\n\"); continue; } char result[32]; int index = 0; while(n > 0) { result[index++] = '0' + (n % 4); n /= 4; } for(int i = index - 1; i >=  }"], "perturbed_original": ["#include<stdio.h> int main(void) { int n,nbox[10000],temp,i,j,flg; scanf(\"%d\",&n); while(n!=-1){ temp=0; i=0; flg=0; while(n>=4){ nbox[i]=n%4; n/=4; i++; } printf(\"%d\",n); for(j=i;j>=0;j--){ if(flg==0){ flg=1; } else if(flg==1){ printf(\"%d\",nbox[j]); } } printf(\"\\n\"); scanf(\"%d\",&n); } return 0; }"], "original_ll": -0.9420862197875977, "sampled_ll": -0.5727057456970215, "all_perturbed_sampled_ll": [-1.1386288404464722], "all_perturbed_original_ll": [-1.1812434196472168], "perturbed_sampled_ll": -1.1386288404464722, "perturbed_original_ll": -1.1812434196472168, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n  public static void main (String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    while (scanner.hasNext()) {\n      int a = scanner.nextInt();\n      if (a < 0) {\n        break;\n      }\n      if (a == 0) {\n        System.out.println(0);\n        continue;\n      }\n      System.out.println(aaa(a));\n    }\n  }\n  public static String aaa (int a) {\n    if (a == 0) {\n      return \"\";\n    }\n    return aaa(a / 4) + a % 4;\n  }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == -1) break;\n            \n            if (n == 0) {\n                System.out.println(0);\n            } else {\n                StringBuilder result = new StringBuilder();\n                while (n > 0) {\n                    result.append(n % 4);\n                    n /= 4;\n                }\n                System.out.println(result.reverse().toString());\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == -1) break; if (n == 0) { System.out.println(0); } else { StringBuilder result = new StringBuilder(); while  } System.out.println(result.reverse().toString()); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main {  new Scanner(System.in); while (scanner.hasNext()) {  } if (a == 0) { System.out.println(0); continue; } System.out.println(aaa(a)); } } public static String aaa (int a) { if (a == 0) { return \"\"; } return aaa(a / 4) + a % 4; } }"], "original_ll": -0.7600666284561157, "sampled_ll": -0.5117871761322021, "all_perturbed_sampled_ll": [-1.0406461954116821], "all_perturbed_original_ll": [-1.6533607244491577], "perturbed_sampled_ll": -1.0406461954116821, "perturbed_original_ll": -1.6533607244491577, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from operator import add\nb2q = {\"00\":\"0\",\"01\":\"1\",\"10\":\"2\",\"11\":\"3\"}\nwhile True:\n    n = input()\n    if n == -1:\n        break\n    s = format(n,\"b\")\n    if len(s) % 2 == 1:\n        s = \"0\" + s\n    print \"\".join(map(b2q.get,map(add,s[::2],s[1::2])))", "sampled": "while True:\n    n = int(input())\n    if n == -1:\n        break\n    \n    if n == 0:\n        print(0)\n    else:\n        result = \"\"\n        while n > 0:\n            result = str(n % 4) + result\n            n //= 4\n        print(result)\n", "perturbed_sampled": ["while True: n = int(input()) if n == -1: break if n == 0: print(0) else: result = \"\" while n %4) result +=<extra_id_1>return result;<extra_id_2>else: print(n //= 4 print(result)"], "perturbed_original": ["from operator import add b2q = {\"00\":\"0\",\"01\":\"1\",\"10\":\"2\",\"11\":\"3\"} while True: n = input() if n == -1: break s = format(n,\"b\") if len(s) % 2 == 1: s = \"0\" + s print \"\".join(map(b2q.get,map(add,s[::2],s[1::2])))"], "original_ll": -1.342484951019287, "sampled_ll": -0.8362977504730225, "all_perturbed_sampled_ll": [-2.9508137702941895], "all_perturbed_original_ll": [-1.7819901704788208], "perturbed_sampled_ll": -2.9508137702941895, "perturbed_original_ll": -1.7819901704788208, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,r,g,b,d,ans,best;\nchar col[8][15]={\"black\",\"blue\",\"lime\",\"aqua\",\"red\",\"fuchsia\",\"yellow\",\"white\"};\nchar code[24];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%s\",&code);\n\t\tif(code[0]=='0')break;\n\t\tsscanf(code,\"#%2x%2x%2x\",&r,&g,&b);\n\t\tbest=99999999;\n\t\tfor(i=0;i<8;i++){\n\t\t\td=(r-255*(i>3))*(r-255*(i>3))+(g-255*(i%4>1))*(g-255*(i%4>1))+(b-255*(i%2))*(b-255*(i%2));\n\t\t\tif(d<best){best=d;ans=i;}\n\t\t}\n\t\tprintf(\"%s\\n\",col[ans]);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char name[10];\n    int r, g, b;\n} Color;\n\nint main() {\n    Color colors[8] = {\n        {\"black\", 0x00, 0x00, 0x00},\n        {\"blue\", 0x00, 0x00, 0xff},\n        {\"lime\", 0x00, 0xff, 0x00},\n        {\"aqua\", 0x00, 0xff, 0xff},\n        {\"red\", 0xff, 0x00, 0x00},\n        {\"fuchsia\", 0xff, 0x00, 0xff},\n        {\"yellow\", 0xff, 0xff, 0x00},\n        {\"white\", 0xff, 0xff, 0xff}\n    };\n    \n    char input[10];\n    \n    while(1) {\n        scanf(\"%s\", input);\n        if(input[0] == '0') break;\n        \n        int r, g, b;\n        char rstr[3], gstr[3], bstr[3];\n        \n        rstr[0] = input[1];\n        rstr[1] = input[2];\n        rstr[2] = '\\0';\n        \n        gstr[0] = input[3];\n        gstr[1] = input[4];\n        gstr[2] = '\\0';\n        \n        bstr[0] = input[5];\n        bstr[1] = input[6];\n        bstr[2] = '\\0';\n        \n        r = strtol(rstr, NULL, 16);\n        g = strtol(gstr, NULL, 16);\n        b = strtol(bstr, NULL, 16);\n        \n        int minDist = -1;\n        int minIdx = 0;\n        \n        for(int i = 0; i < 8; i++) {\n            int dr = r - colors[i].r;\n            int dg = g - colors[i].g;\n            int db = b - colors[i].b;\n            int dist = dr*dr + dg*dg + db*db;\n            \n            if(minDist == -1 || dist < minDist) {\n                minDist = dist;\n                minIdx = i;\n            }\n        }\n        \n        printf(\"%s\\n\", colors[minIdx].name);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> typedef struct { char name[10]; int r, g, b; } Color; int main() { Color colors[8] = { {\"black\", 0x00, 0x00, 0x00}, {\"blue\", 0x00,  {\"red\", 0xff, 0x00, 0x00}, {\"fuchsia\", 0xff, 0x00, 0xff}, {\"yellow\", 0xff, 0xff, 0x00}, {\"white\", 0xff, 0xff, 0xff} }; char input[10]; while(1) { scanf(\"%s\", input); if(input[0] == '0') break; int r, g, b; char rstr[3], gstr[3], bstr[3]; rstr[0] = input[1]; rstr[1] =  gstr[2] = '\\0'; bstr[0] = input[5]; bstr[1] = input[6]; bstr[2] = '\\0'; r = strtol(rstr, NULL, 16); g = strtol(gstr, NULL, 16); b = strtol(bstr, NULL, 16); int minDist = -1;  8; i++) { int dr = r - colors[i].r; int dg = g - colors[i].g; int db = b - colors[i].b; int dist = dr*dr + dg*dg + db*db;  dist;  }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int i,r,g,b,d,ans,best; char col[8][15]={\"black\",\"blue\",\"lime\",\"aqua\",\"red\",\"fuchsia\",\"yellow\",\"white\"}; char code[24]; int main(){ while(1){ scanf(\"%s\",&code); if(code[0]=='0')break; sscanf(code,\"#%2x%2x%2x\",&r,&g,&b); best=99999999; for(i=0;i<8;i++){ d=(r-255*(i>3))*(r-255*(i>3))+(g-255*(i%4>1))*(g-255*(i%4>1))+(b-255*(i%2))*(b-255*(i%2)); if(d<best){best=d;ans=i;} } printf(\"%s\\n\",col[ans]); } return 0; }"], "original_ll": -1.2552781105041504, "sampled_ll": -0.4099103510379791, "all_perturbed_sampled_ll": [-0.9694395661354065], "all_perturbed_original_ll": [-1.3240269422531128], "perturbed_sampled_ll": -0.9694395661354065, "perturbed_original_ll": -1.3240269422531128, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nimport java.util.HashMap;\nimport java.util.Arrays;\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[\\n#]+\");\n\t\twhile (true)\n\t\t{\n\t\t\tString str = sc.next();\n\t\t\tif (str.equals(\"0\")) break;\n\t\t\tint rk = Integer.parseInt(str.substring(0, 2), 16);\n\t\t\tint gk = Integer.parseInt(str.substring(2, 4), 16);\n\t\t\tint bk = Integer.parseInt(str.substring(4, 6), 16);\n\t\t\tint d[] = new int[8];\n\t\t\tHashMap<Integer, String> map = new HashMap<Integer, String>();\n\t\t\td[0] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[0], \"black\");\n\t\t\td[1] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[1], \"blue\");\n\t\t\td[2] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[2], \"lime\");\n\t\t\td[3] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[3], \"aqua\");\n\t\t\td[4] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[4], \"red\");\n\t\t\td[5] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[5], \"fuchsia\");\n\t\t\td[6] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[6], \"yellow\");\n\t\t\td[7] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[7], \"white\");\n\t\t\tArrays.sort(d);\n\t\t\tSystem.out.println(map.get(d[0]));\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        String[] colorNames = {\"black\", \"blue\", \"lime\", \"aqua\", \"red\", \"fuchsia\", \"yellow\", \"white\"};\n        int[][] colorValues = {\n            {0x00, 0x00, 0x00},  // black\n            {0x00, 0x00, 0xff},  // blue\n            {0x00, 0xff, 0x00},  // lime\n            {0x00, 0xff, 0xff},  // aqua\n            {0xff, 0x00, 0x00},  // red\n            {0xff, 0x00, 0xff},  // fuchsia\n            {0xff, 0xff, 0x00},  // yellow\n            {0xff, 0xff, 0xff}   // white\n        };\n        \n        while (true) {\n            String input = sc.next();\n            if (input.equals(\"0\")) {\n                break;\n            }\n            \n            // Parse color code\n            String colorCode = input.substring(1); // Remove '#'\n            int r = Integer.parseInt(colorCode.substring(0, 2), 16);\n            int g = Integer.parseInt(colorCode.substring(2, 4), 16);\n            int b = Integer.parseInt(colorCode.substring(4, 6), 16);\n            \n            // Find closest color\n            int minDistance = Integer.MAX_VALUE;\n            String closestColor = \"\";\n            \n            for (int i = 0; i < colorNames.length; i++) {\n                int rk = colorValues[i][0];\n                int gk = colorValues[i][1];\n                int bk = colorValues[i][2];\n                \n                int distance = (r - rk) * (r - rk) + (g - gk) * (g - gk) + (b - bk) * (b - bk);\n                \n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestColor = colorNames[i];\n                }\n            }\n            \n            System.out.println(closestColor);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  { Scanner sc = new Scanner(System.in); String[] colorNames = {\"black\", \"blue\", \"lime\", \"aqua\", \"red\", \"fuchsia\", \"yellow\", \"white\"}; int[][] colorValues = { {0x00, 0x00, 0x00}, // black {0x00, 0x00, 0xff}, // blue {0x00, 0xff, 0x00}, // lime {0x00, 0xff, 0xff}, // aqua {0xff, 0x00, 0x00}, // red {0xff, 0x00, 0xff}, // fuchsia {0xff, 0xff, 0x00}, // yellow {0xff, 0xff, 0xff} // white }; while (true) { String input = sc.next(); if (input.equals(\"0\")) { break; } // Parse color code String colorCode = input.substring(1); // Remove '#'  4), 16); int b = Integer.parseInt(colorCode.substring(4, 6), 16); // Find closest color int minDistance = Integer.MAX_VALUE; String closestColor = \"\"; for  rk = colorValues[i][0]; int gk  - rk)  - gk) + (b - bk) * (b - bk); if (distance < minDistance) { minDistance = distance; closestColor = colorNames[i]; } } System.out.println(closestColor); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; import java.util.HashMap; import java.util.Arrays; class Main { public static void main(String  String str = sc.next(); if (str.equals(\"0\")) break; int rk = Integer.parseInt(str.substring(0, 2), 16); int gk = Integer.parseInt(str.substring(2, 4), 16); int bk = Integer.parseInt(str.substring(4, 6), 16); int d[] = new int[8]; HashMap<Integer, String> map = new HashMap<Integer, String>(); d[0] = (0x00 - rk) * (0x00 - rk) +  bk) * (0x00 - bk); map.put(d[0], \"black\"); d[1] = (0x00 - rk) * (0x00 - rk) +  bk) * (0xff - bk); map.put(d[1], \"blue\"); d[2] = (0x00 - rk) * (0x00 - rk) + (0xff - gk) * (0xff - gk) + (0x00 - bk) * (0x00 -  - rk) + (0xff - gk) * (0xff - gk) + (0xff - bk) * (0xff - bk); map.put(d[3], \"aqua\"); d[4] = (0xff - rk) * (0xff - rk) + (0x00 - gk) * (0x00 - gk) + (0x00 - bk)  rk) * (0xff  \"fuchsia\"); d[6] = (0xff - rk) * (0xff - rk) + (0xff - gk) * (0xff - gk) + (0x00 - bk) * (0x00 - bk); map.put(d[6], \"yellow\"); d[7] = (0xff - rk) * (0xff - rk) + (0xff -  (0xff - bk); map.put(d[7], \"white\"); Arrays.sort(d); System.out.println(map.get(d[0])); } } }"], "original_ll": -0.39717236161231995, "sampled_ll": -0.41816282272338867, "all_perturbed_sampled_ll": [-1.1836178302764893], "all_perturbed_original_ll": [-0.9602006673812866], "perturbed_sampled_ll": -1.1836178302764893, "perturbed_original_ll": -0.9602006673812866, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nL=[\n(\"black\",00,00,00),\n(\"blue\",00,00,255),\n(\"lime\",00,255,00),\n(\"aqua\",00,255,255),\n(\"red\",255,00,00),\n(\"fuchsia\",255,00,255),\n(\"yellow\",255,255,00),\n(\"white\",255,255,255)]\nwhile True:\n    c=raw_input()\n    if c==\"0\":break\n    Rk,Gk,Bk=int(c[1:3],16),int(c[3:5],16),int(c[5:7],16)\n    m=10000\n    for cl,r,g,b in L:\n        t=math.sqrt(pow(r-Rk,2)+pow(g-Gk,2)+pow(b-Bk,2))\n        if t<m:\n            m=t\n            color=cl\n    print color", "sampled": "import sys\n\ncolors = [\n    (\"black\", 0x00, 0x00, 0x00),\n    (\"blue\", 0x00, 0x00, 0xff),\n    (\"lime\", 0x00, 0xff, 0x00),\n    (\"aqua\", 0x00, 0xff, 0xff),\n    (\"red\", 0xff, 0x00, 0x00),\n    (\"fuchsia\", 0xff, 0x00, 0xff),\n    (\"yellow\", 0xff, 0xff, 0x00),\n    (\"white\", 0xff, 0xff, 0xff)\n]\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line == \"0\":\n        break\n    \n    # Parse color code\n    color_code = line[1:]  # Remove #\n    R = int(color_code[0:2], 16)\n    G = int(color_code[2:4], 16)\n    B = int(color_code[4:6], 16)\n    \n    # Find closest color\n    min_distance = float('inf')\n    closest_color = \"\"\n    \n    for name, Rk, Gk, Bk in colors:\n        dk = (R - Rk) ** 2 + (G - Gk) ** 2 + (B - Bk) ** 2\n        if dk < min_distance:\n            min_distance = dk\n            closest_color = name\n    \n    print(closest_color)\n", "perturbed_sampled": ["import sys colors = [ (\"black\", 0x00, 0x00, 0x00), (\"blue\", 0x00, 0x00, 0xff), (\"lime\", 0x00,  (\"fuchsia\", 0xff, 0x00, 0xff), (\"yellow\", 0xff, 0xff, 0x00), (\"white\", 0xff, 0xff, 0xff) ] for line in sys.stdin: line  code color_code = line[1:] # Remove # R = int(color_code[0:2], 16) G = int(color_code[2:4], 16) B = int(color_code[4:6], 16) # Find closest color min_distance = float('inf') closest_color = \"\" for name, Rk, Gk, Bk in colors: dk = (R - Rk) ** 2 + (G -  dk < min_distance: min_distance = dk closest_color = name print(closest_color)"], "perturbed_original": ["import math L=[ (\"black\",00,00,00), (\"blue\",00,00,255), (\"lime\",00,255,00), (\"aqua\",00,255,255), (\"red\",255,00,00), (\"fuchsia\",255,00,255), (\"yellow\",255,255,00), (\"white\",255,255,255)] while True: c=raw_input() if c==\"0\":break Rk,Gk,Bk=int(c[1:3],16),int(c[3:5],16),int(c[5:7],16) m=10000 for cl,r,g,b in L: t=math.sqrt(pow(r-Rk,2)+pow(g-Gk,2)+pow(b-Bk,2)) if t<m: m=t color=cl print color"], "original_ll": -0.9571045637130737, "sampled_ll": -0.5650010108947754, "all_perturbed_sampled_ll": [-1.491884708404541], "all_perturbed_original_ll": [-1.1553815603256226], "perturbed_sampled_ll": -1.491884708404541, "perturbed_original_ll": -1.1553815603256226, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n#define PI 3.141592653589793\n#define r 6378.1\nint main(void) {\n\twhile(1){\n\t\tdouble a,b,c,d;\n\t\tscanf(\"%lf %lf %lf %lf\\n\",&a,&b,&c,&d);\n\t\tif(a==(-1)&&b==(-1)&&c==(-1)&&d==(-1)) break;\n\t\tdouble a1,b1,c1,d1;\n\t\ta1=a*PI/180.0;\n\t\tb1=b*PI/180.0;\n\t\tc1=c*PI/180.0;\n\t\td1=d*PI/180.0;\n\t\tdouble e1,f;\n\t\te1=d1-b1;\n\t\tf=r*acos((sin(a1)*sin(c1))+(cos(a1)*cos(c1)*cos(e1)));\n\t\tprintf(\"%.0f\\n\",f);\n\t}\n\treturn 0;\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159265358979323846\n#define RADIUS 6378.1\n\nint main() {\n    double a, b, c, d;\n    \n    while (1) {\n        scanf(\"%lf %lf %lf %lf\", &a, &b, &c, &d);\n        \n        if (a == -1 && b == -1 && c == -1 && d == -1) {\n            break;\n        }\n        \n        double lat1 = a * PI / 180.0;\n        double lon1 = b * PI / 180.0;\n        double lat2 = c * PI / 180.0;\n        double lon2 = d * PI / 180.0;\n        \n        double x1 = RADIUS * cos(lat1) * cos(lon1);\n        double y1 = RADIUS * cos(lat1) * sin(lon1);\n        double z1 = RADIUS * sin(lat1);\n        \n        double x2 = RADIUS * cos(lat2) * cos(lon2);\n        double y2 = RADIUS * cos(lat2) * sin(lon2);\n        double z2 = RADIUS * sin(lat2);\n        \n        double chord = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1));\n        \n        double angle = 2.0 * asin(chord / (2.0 * RADIUS));\n        \n        double distance = RADIUS * angle;\n        \n        int result = (int)(distance + 0.5);\n        \n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #define PI 3.14159265358979323846 #define RADIUS 6378.1 int main() { double a, b, c, d; while (1) { scanf(\"%lf %lf %lf %lf\", &a, &b, &c, &d); if (a == -1 && b == -1 && c == -1 && d == -1) { break; } double lat1 = a * PI / 180.0; double lon1 = b * PI / 180.0; double lat2 = c  / 180.0; double x1 = RADIUS * cos(lat1) * cos(lon1); double y1 = RADIUS * cos(lat1)  = RADIUS * cos(lat2) * cos(lon2); double y2 = RADIUS * cos(lat2) * sin(lon2); double z2 = RADIUS * sin(lat2);   = RADIUS * angle; int result = (int)(distance + 0.5); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> #define PI 3.141592653589793 #define r 6378.1 int  break; double a1,b1,c1,d1; a1=a*PI/180.0; b1=b*PI/180.0; c1=c*PI/180.0; d1=d*PI/180.0; double e1,f; e1=d1-b1; f=r*acos((sin(a1)*sin(c1))+(cos(a1)*cos(c1)*cos(e1))); printf(\"%.0f\\n\",f); } return 0; }"], "original_ll": -0.791118323802948, "sampled_ll": -0.39860960841178894, "all_perturbed_sampled_ll": [-0.9226452708244324], "all_perturbed_original_ll": [-1.272177815437317], "perturbed_sampled_ll": -0.9226452708244324, "perturbed_original_ll": -1.272177815437317, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tdouble c = sc.nextDouble();\n\t\t\tdouble d = sc.nextDouble();\n\t\t\tif((a==-1)&&(b==-1)&&(c==-1)&&(d==-1)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdouble vz = Math.sin(Math.toRadians(a));\n\t\t\tdouble vx = Math.cos(Math.toRadians(a))*Math.cos(Math.toRadians(b));\n\t\t\tdouble vy = Math.cos(Math.toRadians(a))*Math.sin(Math.toRadians(b));\n\n\t\t\tdouble wz = Math.sin(Math.toRadians(c));\n\t\t\tdouble wx = Math.cos(Math.toRadians(c))*Math.cos(Math.toRadians(d));\n\t\t\tdouble wy = Math.cos(Math.toRadians(c))*Math.sin(Math.toRadians(d));\n\n\t\t\tdouble dot = vz*wz + vx*wx + vy * wy;\n\t\t\tdouble theta = Math.acos(dot);\n\t\t\tdouble R =6378.1;\n\t\t\tSystem.out.println((int)(R*theta+0.5));\n\t\t}\n\t\t\n\t}\n\tpublic static void main(String[] args){\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            double a = sc.nextDouble();\n            double b = sc.nextDouble();\n            double c = sc.nextDouble();\n            double d = sc.nextDouble();\n            \n            if (a == -1 && b == -1 && c == -1 && d == -1) {\n                break;\n            }\n            \n            double lat1 = Math.toRadians(a);\n            double lon1 = Math.toRadians(b);\n            double lat2 = Math.toRadians(c);\n            double lon2 = Math.toRadians(d);\n            \n            double radius = 6378.1;\n            \n            double centralAngle = Math.acos(\n                Math.sin(lat1) * Math.sin(lat2) + \n                Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1)\n            );\n            \n            double distance = radius * centralAngle;\n            \n            long result = Math.round(distance);\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in); while (true) { double a = sc.nextDouble(); double b = sc.nextDouble(); double c = sc.nextDouble(); double d = sc.nextDouble(); if (a == -1 && b == -1 && c == -1 && d == -1) { break; } double lat1 = Math.toRadians(a); double lon1 = Math.toRadians(b); double lat2 = Math.toRadians(c); double lon2 = Math.toRadians(d); double radius = 6378.1; double centralAngle = Math.acos( Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2)  }"], "perturbed_original": ["import java.util.*; import java.lang.*; import java.math.*; public class Main  a = sc.nextDouble(); double b = sc.nextDouble(); double c = sc.nextDouble(); double d = sc.nextDouble(); if((a==-1)&&(b==-1)&&(c==-1)&&(d==-1)){ break; } double vz = Math.sin(Math.toRadians(a)); double vx = Math.cos(Math.toRadians(a))*Math.cos(Math.toRadians(b)); double vy = Math.cos(Math.toRadians(a))*Math.sin(Math.toRadians(b)); double wz = Math.sin(Math.toRadians(c)); double wx = Math.cos(Math.toRadians(c))*Math.cos(Math.toRadians(d)); double wy = Math.cos(Math.toRadians(c))*Math.sin(Math.toRadians(d)); double dot = vz*wz + vx*wx  =6378.1; System.out.println((int)(R*theta+0.5)); } } public static void main(String[] args){ Main m = new Main(); m.run(); } }"], "original_ll": -0.8860735297203064, "sampled_ll": -0.46987923979759216, "all_perturbed_sampled_ll": [-0.8119152188301086], "all_perturbed_original_ll": [-1.329321026802063], "perturbed_sampled_ll": -0.8119152188301086, "perturbed_original_ll": -1.329321026802063, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from math import acos,sin,cos,radians\nwhile 1:\n    a,b,c,d=map(float,input().split())\n    if a==b==c==d==-1:break\n    a,c=radians(a),radians(c)\n    print(int(6378.1*acos(sin(a)*sin(c) + cos(a)*cos(c)*cos(radians(d)-radians(b)))+0.5))", "sampled": "import math\n\nR = 6378.1\n\nwhile True:\n    line = input().split()\n    a, b, c, d = map(float, line)\n    \n    if a == -1 and b == -1 and c == -1 and d == -1:\n        break\n    \n    # Convert degrees to radians\n    lat1 = math.radians(a)\n    lon1 = math.radians(b)\n    lat2 = math.radians(c)\n    lon2 = math.radians(d)\n    \n    # Calculate great circle distance using spherical law of cosines\n    # or using haversine formula for better numerical stability\n    \n    # Using spherical law of cosines:\n    # d = R * arccos(sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2)*cos(lon2-lon1))\n    \n    cos_angle = math.sin(lat1) * math.sin(lat2) + math.cos(lat1) * math.cos(lat2) * math.cos(lon2 - lon1)\n    \n    # Clamp to [-1, 1] to avoid numerical errors\n    cos_angle = max(-1, min(1, cos_angle))\n    \n    angle = math.acos(cos_angle)\n    distance = R * angle\n    \n    print(round(distance))\n", "perturbed_sampled": ["import math R = 6378.1 while True: line = input().split() a, b,  b == -1 and c == -1 and d == -1: break # Convert degrees to radians lat1 = math.radians(a) lon1 = math.radians(b) lat2 = math.radians(c) lon2 = math.radians(d) # Calculate great circle distance using spherical  numerical stability # Using spherical law of cosines: # d = R *  * math.cos(lat2) * math.cos(lon2 - lon1) # Clamp to [-1, 1] to avoid numerical errors cos_angle = max(-1, min(1, cos_angle)) angle = math.acos(cos_angle) distance = R * angle print(round(distance))"], "perturbed_original": ["from math import acos,sin,cos,radians while 1: a,b,c,d=map(float,input().split()) if a==b==c==d==-1:break a,c=radians(a),radians(c) print(int(6378.1*acos(sin(a)*sin(c) + cos(a)*cos(c)*cos(radians(d)-radians(b)))+0.5))"], "original_ll": -1.657982349395752, "sampled_ll": -0.818010151386261, "all_perturbed_sampled_ll": [-1.9692981243133545], "all_perturbed_original_ll": [-1.9160884618759155], "perturbed_sampled_ll": -1.9692981243133545, "perturbed_original_ll": -1.9160884618759155, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,d,p,q,m[9999],h;main(b){for(;~scanf(\"%d\",&n),n;d&&printf(\"%d\\n\",p)){for(memset(m,d=0,39996);n--;){scanf(\"%d%d%d\",&d,&p,&q);b=(d-2?~-(1<<p):1)<<q;for(h=9998;~h&&!(m[h]&b);h--)d-2?p=1:0;for(h++;p--;m[h]-62?h++:memmove(m+h,m+h+1,9998-h))m[h]|=b;}for(p=0,h=9999;h--;)for(b=m[h];q=-b&b;b-=q)p++;}}", "sampled": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_HEIGHT 10000\n#define WIDTH 5\n\nint grid[MAX_HEIGHT][WIDTH];\n\nint getHeight(int col) {\n    int h = 0;\n    for (int i = 0; i < MAX_HEIGHT; i++) {\n        if (grid[i][col] == 1) {\n            h = i + 1;\n        }\n    }\n    return h;\n}\n\nvoid dropBlock(int d, int p, int q) {\n    q--; // Convert to 0-indexed\n    \n    if (d == 1) { // Horizontal\n        // Find the highest point where the block can land\n        int maxHeight = 0;\n        for (int i = 0; i < p; i++) {\n            int h = getHeight(q + i);\n            if (h > maxHeight) {\n                maxHeight = h;\n            }\n        }\n        // Place the block\n        for (int i = 0; i < p; i++) {\n            grid[maxHeight][q + i] = 1;\n        }\n    } else { // Vertical (d == 2)\n        int h = getHeight(q);\n        // Place the block\n        for (int i = 0; i < p; i++) {\n            grid[h + i][q] = 1;\n        }\n    }\n}\n\nvoid removeFullRows() {\n    int removed = 0;\n    for (int row = 0; row < MAX_HEIGHT; row++) {\n        int full = 1;\n        for (int col = 0; col < WIDTH; col++) {\n            if (grid[row][col] == 0) {\n                full = 0;\n                break;\n            }\n        }\n        if (full) {\n            // Mark row for removal\n            for (int col = 0; col < WIDTH; col++) {\n                grid[row][col] = 0;\n            }\n            // Shift everything above down\n            for (int r = row; r < MAX_HEIGHT - 1; r++) {\n                for (int col = 0; col < WIDTH; col++) {\n                    grid[r][col] = grid[r + 1][col];\n                }\n            }\n            for (int col = 0; col < WIDTH; col++) {\n                grid[MAX_HEIGHT - 1][col] = 0;\n            }\n            row--; // Check this row again\n        }\n    }\n}\n\nint countBlocks() {\n    int count = 0;\n    for (int i = 0; i < MAX_HEIGHT; i++) {\n        for (int j = 0; j < WIDTH; j++) {\n            if (grid[i][j] == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        // Clear the grid\n        memset(grid, 0, sizeof(grid));\n        \n        for (int i = 0; i < n; i++) {\n            int d, p, q;\n            scanf(\"%d %d %d\", &d, &p, &q);\n            dropBlock(d, p, q);\n            removeFullRows();\n        }\n        \n        printf(\"%d\\n\", countBlocks());\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #define MAX_HEIGHT 10000 #define WIDTH 5 int grid[MAX_HEIGHT][WIDTH]; int getHeight(int col) { int h = 0; for (int i = 0; i < MAX_HEIGHT; i++) { if (grid[i][col] == 1)  } void dropBlock(int d, int p, int q) { q--; // Convert to 0-indexed if (d == 1) { // Horizontal // Find the highest point where the block can land int maxHeight = 0; for (int i = 0; i < p; i++) { int h = getHeight(q + i); if (h > maxHeight) { maxHeight = h; } } // Place the block for (int i = 0; i < p; i++) { grid[maxHeight][q + i] = 1; } } else { // Vertical (d == 2) int h = getHeight(q); // Place the block for (int i = 0; i < p; i++) { grid[h + i][q] = 1; } } } void removeFullRows() { int removed = 0; for (int row = 0; row < MAX_HEIGHT; row++) { int full = 1; for  (grid[row][col] == 0) { full = 0; break; } } if (full) { // Mark row for removal for (int col = 0; col <  MAX_HEIGHT  < WIDTH; col++) { grid[r][col] = grid[r + 1][col]; } } for (int col = 0; col < WIDTH; col++) { grid[MAX_HEIGHT - 1][col] = 0; } row--; // Check  count  i++) { for (int j = 0; j  int n; while (scanf(\"%d\", &n) == 1 && n != 0) { //  q; scanf(\"%d %d %d\", &d, &p, &q); dropBlock(d, p, q); removeFullRows(); } printf(\"%d\\n\", countBlocks()); } return 0; }"], "perturbed_original": ["n,d,p,q,m[9999],h;main(b){for(;~scanf(\"%d\",&n),n;d&&printf(\"%d\\n\",p)){for(memset(m,d=0,39996);n--;){scanf(\"%d%d%d\",&d,&p,&q);b=(d-2?~-(1<<p):1)<<q;for(h=9998;~h&&!(m[h]&b);h--)d-2?p=1:0;for(h++;p--;m[h]-62?h++:memmove(m+h,m+h+1,9998-h))m[h]|=b;}for(p=0,h=9999;h--;)for(b=m[h];q=-b&b;b-=q)p++;}}"], "original_ll": -2.7408370971679688, "sampled_ll": -0.5612636804580688, "all_perturbed_sampled_ll": [-1.356518268585205], "all_perturbed_original_ll": [-2.7408370971679688], "perturbed_sampled_ll": -1.356518268585205, "perturbed_original_ll": -2.7408370971679688, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n//TETORIS\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tboolean[][] m = new boolean[5000][5];\n\t\t\twhile(n--!=0){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt()-1;\n\t\t\t\tif(d==2){\n\t\t\t\t\tint k = 4999;\n\t\t\t\t\twhile(k>=0&&!m[k][q])k--;\n\t\t\t\t\tk++;\n\t\t\t\t\tfor(int i=k;i<k+p;i++)m[i][q]=true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint k = 4999;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tif(k>=0){\n\t\t\t\t\t\t\tfor(int j=q;j<q+p;j++){\n\t\t\t\t\t\t\t\tif(m[k][j])f = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f||k==-1){\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\tfor(int j=q;j<q+p;j++)m[k][j]=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean con = true;\n\t\t\t\tint k = 0;\n\t\t\t\twhile(k<5000&&con){\n\t\t\t\t\tcon = false;\n\t\t\t\t\tboolean t = true;\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tif(m[k][j])con = true;\n\t\t\t\t\t\telse t = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(t){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tint i = k;\n\t\t\t\t\t\twhile(i<5000&&f){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\t\tif(m[i][j])f = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\t\t\tm[i][j] = m[i+1][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse k++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint s = 0;\n\t\t\tfor(int i=0;i<5000;i++)for(int j=0;j<5;j++)s+=m[i][j]?1:0;\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[][] board = new int[10000][5];\n            int maxHeight = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt() - 1;\n                \n                if (d == 1) {\n                    int dropHeight = 0;\n                    for (int col = q; col < q + p; col++) {\n                        for (int row = 0; row < 10000; row++) {\n                            if (board[row][col] == 1) {\n                                dropHeight = Math.max(dropHeight, row + 1);\n                                break;\n                            }\n                        }\n                    }\n                    \n                    for (int col = q; col < q + p; col++) {\n                        board[dropHeight][col] = 1;\n                    }\n                    maxHeight = Math.max(maxHeight, dropHeight + 1);\n                } else {\n                    int dropHeight = 0;\n                    for (int row = 0; row < 10000; row++) {\n                        if (board[row][q] == 1) {\n                            dropHeight = row + 1;\n                            break;\n                        }\n                    }\n                    \n                    for (int row = dropHeight; row < dropHeight + p; row++) {\n                        board[row][q] = 1;\n                    }\n                    maxHeight = Math.max(maxHeight, dropHeight + p);\n                }\n                \n                boolean cleared = true;\n                while (cleared) {\n                    cleared = false;\n                    for (int row = 0; row < maxHeight; row++) {\n                        boolean full = true;\n                        for (int col = 0; col < 5; col++) {\n                            if (board[row][col] == 0) {\n                                full = false;\n                                break;\n                            }\n                        }\n                        \n                        if (full) {\n                            cleared = true;\n                            for (int r = row; r < maxHeight - 1; r++) {\n                                for (int col = 0; col < 5; col++) {\n                                    board[r][col] = board[r + 1][col];\n                                }\n                            }\n                            for (int col = 0; col < 5; col++) {\n                                board[maxHeight - 1][col] = 0;\n                            }\n                            maxHeight--;\n                            break;\n                        }\n                    }\n                }\n            }\n            \n            int count = 0;\n            for (int row = 0; row < maxHeight; row++) {\n                for (int col = 0; col < 5; col++) {\n                    if (board[row][col] == 1) {\n                        count++;\n                    }\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void  { int n = sc.nextInt(); if (n == 0)  for (int i = 0; i < n;  int q = sc.nextInt() - 1; if (d == 1) { int dropHeight = 0; for (int col = q; col < q + p; col++) { for (int row  1) { dropHeight =  col = q; col < q + p; col++) { board[dropHeight][col] = 1; } maxHeight = Math.max(maxHeight, dropHeight + 1); } else { int dropHeight = 0;  if (board[row][q] == 1) { dropHeight = row + 1; break; } } for (int row = dropHeight; row < dropHeight + p; row++) { board[row][q] = 1; } maxHeight = Math.max(maxHeight, dropHeight + p); } boolean cleared = true; while (cleared) { cleared = false; for (int row = 0; row <  == 0) { full = false; break; } } if (full) { cleared = true; for (int r = row; r < maxHeight - 1; r++) { for (int col = 0; col < 5; col++) { board[r][col] = board[r + 1][col]; }  { board[maxHeight - 1][col] = 0; } maxHeight--; break; } } } } int count = 0; for (int row = 0; row < maxHeight; row++) { for (int col = 0; col < 5; col++) { if (board[row][col] == 1) { count++; } } } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; //TETORIS public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){ int n = sc.nextInt(); if(n==0)break; boolean[][] m = new boolean[5000][5]; while(n--!=0){ int d = sc.nextInt(); int p = sc.nextInt(); int q = sc.nextInt()-1; if(d==2){ int k = 4999; while(k>=0&&!m[k][q])k--; k++; for(int i=k;i<k+p;i++)m[i][q]=true; } else{ int   break; } k--; } } boolean con = true; int k = 0; while(k<5000&&con){ con = false; boolean t = true; for(int j=0;j<5;j++){  f = true; int i = k; while(i<5000&&f){ f = false; for(int j=0;j<5;j++){ if(m[i][j])f = true; } if(f){ for(int j=0;j<5;j++){  } } int s = 0; for(int i=0;i<5000;i++)for(int j=0;j<5;j++)s+=m[i][j]?1:0; System.out.println(s); } } }"], "original_ll": -0.8281287550926208, "sampled_ll": -0.45888951420783997, "all_perturbed_sampled_ll": [-1.213383674621582], "all_perturbed_original_ll": [-1.3647773265838623], "perturbed_sampled_ll": -1.213383674621582, "perturbed_original_ll": -1.3647773265838623, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#!/usr/local/bin/python\nfrom itertools import islice\n\ndef init():\n    return [[None] * 5] * 5000\n\nN = 4\n\nwhile True:\n    #N = int(input())\n    if N == 0:\n        break\n    d, l, pos = [int(n) for n in raw_input().split()]\n    lst = init()\n    flwr = 0\n    for i in xrange(N):\n        print d, l, pos\n        # if d == 1:\n        #     for i in xrange(l):\n        #         lst[flwr][pos-1 + i] = 1\n        # else:\n        #     tmp = 0\n        #     for i in xrange(l):\n        #         lst[flwr + tmp][pos-1] = 1\n        #         tmp += 1\n        #print lst[flwr]\n        #print not None in lst[flwr]\n        if not None in lst[flwr]:\n            flwr += 1\n    ret = 0\n    for i in xrange(flwr):\n        ret += len([i for i in lst[i] if not None])\n    #print ret\n    N -= 1\n    break", "sampled": "def solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        # Board: 5 columns, use a list to store heights at each column\n        # We'll use a grid representation where grid[row][col] tells if there's a block\n        grid = []  # Will grow as needed, grid[0] is bottom\n        \n        for _ in range(n):\n            d, p, q = map(int, input().split())\n            q -= 1  # Convert to 0-indexed\n            \n            if d == 1:  # Horizontal block\n                # Find the maximum height among columns q to q+p-1\n                max_height = 0\n                for col in range(q, q + p):\n                    # Find height of column col\n                    h = 0\n                    for row in range(len(grid)):\n                        if grid[row][col]:\n                            h = row + 1\n                    max_height = max(max_height, h)\n                \n                # Place block at row max_height\n                while len(grid) <= max_height:\n                    grid.append([False] * 5)\n                \n                for col in range(q, q + p):\n                    grid[max_height][col] = True\n                    \n            else:  # Vertical block (d == 2)\n                # Find height of column q\n                height = 0\n                for row in range(len(grid)):\n                    if grid[row][q]:\n                        height = row + 1\n                \n                # Place block from row height to height+p-1\n                while len(grid) < height + p:\n                    grid.append([False] * 5)\n                \n                for row in range(height, height + p):\n                    grid[row][q] = True\n            \n            # Check for complete rows and remove them\n            rows_to_remove = []\n            for row_idx in range(len(grid)):\n                if all(grid[row_idx]):\n                    rows_to_remove.append(row_idx)\n            \n            # Remove complete rows (from top to bottom to maintain indices)\n            for row_idx in reversed(rows_to_remove):\n                grid.pop(row_idx)\n        \n        # Count remaining blocks\n        count = 0\n        for row in grid:\n            count += sum(row)\n        \n        print(count)\n\nsolve()\n", "perturbed_sampled": ["def solve():   at each column # We'll use a grid representation where grid[row][col] tells if there's a block grid = [] # Will grow as needed, grid[0] is bottom for _ in range(n): d, p, q = map(int, input().split()) q -= 1 # Convert to 0-indexed if d == 1: # Horizontal block # Find the maximum height among columns q to q+p-1 max_height = 0 for col in range(q, q + p): # Find height  if grid[row][col]: h = row + 1 max_height = max(max_height, h) # Place block at row max_height while  q + p): grid[max_height][col] = True else: # Vertical block (d == 2) # Find height  if grid[row][q]: height = row + 1 # Place block from row height to height+p-1 while len(grid) < height + p: grid.append([False] * 5) for row in range(height, height + p): grid[row][q]   # Remove complete rows (from top to bottom to maintain indices) for row_idx in reversed(rows_to_remove): grid.pop(row_idx) # Count remaining blocks count = 0 for row in grid: count += sum(row) print(count) solve()"], "perturbed_original": ["#!/usr/local/bin/python from itertools import islice def init(): return [[None] * 5] * 5000 N = 4 while True: #N = int(input()) if N == 0: break d, l, pos = [int(n) for n in raw_input().split()] lst = init() flwr = 0 for i in xrange(N): print d, l, pos  lst[flwr + tmp][pos-1] = 1 # tmp += 1 #print lst[flwr] #print not None in lst[flwr] if not None in lst[flwr]: flwr += 1 ret = 0 for i in xrange(flwr): ret += len([i for i in lst[i] if not None]) #print ret N -= 1 break"], "original_ll": -1.3601551055908203, "sampled_ll": -1.0993638038635254, "all_perturbed_sampled_ll": [-2.329530954360962], "all_perturbed_original_ll": [-2.0154895782470703], "perturbed_sampled_ll": -2.329530954360962, "perturbed_original_ll": -2.0154895782470703, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\nchar chk[MAX+10];\nint Q[MAX+10], *top, *end, *qmax = Q + MAX;\nint N, K, mask;\n\nint nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b, step;\n\tint i, k;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) | k;\n\t\t}\n\t\tmask = (1 << N) - 1, r = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;\n\t\ttop = end = Q;\n\t\t*end++ = s, *end++ = -1, chk[s] = 1, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = *top; if (++top >= qmax) top = Q;\n\t\t\tif (s < 0) { step++, *end = -1; if (++end >= qmax) end = Q; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); break; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2, k2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n\t\t\t\tif (!chk[s2]) { chk[s2] = 1, *end = s2; if (++end >= qmax) end = Q; }\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LEN 11\n#define MAX_QUEUE 100000\n\ntypedef struct {\n    char state[MAX_LEN];\n    int steps;\n} QueueItem;\n\ntypedef struct {\n    char state[MAX_LEN];\n} HashItem;\n\nHashItem visited[MAX_QUEUE];\nint visited_count;\n\nint hash_string(char* s) {\n    int h = 0;\n    for (int i = 0; s[i]; i++) {\n        h = h * 31 + s[i];\n    }\n    return abs(h) % MAX_QUEUE;\n}\n\nint is_visited(char* s) {\n    for (int i = 0; i < visited_count; i++) {\n        if (strcmp(visited[i].state, s) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add_visited(char* s) {\n    strcpy(visited[visited_count].state, s);\n    visited_count++;\n}\n\nint is_uniform(char* s) {\n    char first = s[0];\n    for (int i = 1; s[i]; i++) {\n        if (s[i] != first) return 0;\n    }\n    return 1;\n}\n\nchar get_third_color(char a, char b) {\n    if ((a == 'r' && b == 'g') || (a == 'g' && b == 'r')) return 'b';\n    if ((a == 'r' && b == 'b') || (a == 'b' && b == 'r')) return 'g';\n    if ((a == 'g' && b == 'b') || (a == 'b' && b == 'g')) return 'r';\n    return a;\n}\n\nint solve(char* initial) {\n    if (is_uniform(initial)) return 0;\n    \n    QueueItem queue[MAX_QUEUE];\n    int front = 0, rear = 0;\n    \n    visited_count = 0;\n    strcpy(queue[rear].state, initial);\n    queue[rear].steps = 0;\n    rear++;\n    add_visited(initial);\n    \n    while (front < rear) {\n        QueueItem current = queue[front++];\n        \n        int len = strlen(current.state);\n        \n        for (int i = 0; i < len - 1; i++) {\n            if (current.state[i] != current.state[i+1]) {\n                char new_state[MAX_LEN];\n                strcpy(new_state, current.state);\n                \n                char new_color = get_third_color(current.state[i], current.state[i+1]);\n                new_state[i] = new_color;\n                new_state[i+1] = new_color;\n                \n                if (is_uniform(new_state)) {\n                    return current.steps + 1;\n                }\n                \n                if (!is_visited(new_state) && rear < MAX_QUEUE) {\n                    strcpy(queue[rear].state, new_state);\n                    queue[rear].steps = current.steps + 1;\n                    rear++;\n                    add_visited(new_state);\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    char input[MAX_LEN];\n    \n    while (1) {\n        scanf(\"%s\", input);\n        if (strcmp(input, \"0\") == 0) break;\n        \n        int result = solve(input);\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAX_LEN 11 #define MAX_QUEUE 100000 typedef struct { char state[MAX_LEN]; int steps; } QueueItem; typedef struct { char state[MAX_LEN]; } HashItem;  { h = h  int is_visited(char* s) { for (int i = 0; i < visited_count; i++) { if (strcmp(visited[i].state, s) == 0) { return  strcpy(visited[visited_count].state, s); visited_count++; } int is_uniform(char* s) { char first = s[0]; for (int i = 1; s[i]; i++)  } char get_third_color(char a, char b) { if ((a == 'r' && b == 'g') || (a == 'g' && b == 'r')) return 'b'; if ((a == 'r' && b == 'b') || (a == 'b' && b == 'r')) return 'g'; if ((a == 'g' && b == 'b')  return a; } int solve(char* initial) { if (is_uniform(initial)) return 0; QueueItem queue[MAX_QUEUE]; int front = 0, rear = 0; visited_count = 0; strcpy(queue[rear].state, initial); queue[rear].steps = 0; rear++; add_visited(initial); while (front < rear) { QueueItem current = queue[front++]; int len = strlen(current.state);  strcpy(new_state, current.state); char new_color = get_third_color(current.state[i], current.state[i+1]); new_state[i]  + 1; } if (!is_visited(new_state) && rear < MAX_QUEUE) { strcpy(queue[rear].state, new_state); queue[rear].steps = current.steps + 1; rear++; add_visited(new_state); } } } } return -1; } int main() { char input[MAX_LEN]; while (1) { scanf(\"%s\", input); if (strcmp(input, \"0\") == 0) break; int result = solve(input); if (result == -1) { printf(\"NA\\n\"); } else { printf(\"%d\\n\", result); } } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0179: Mysterious Worm // 2017.8.22 bal4u@uu #include <stdio.h> #include <string.h> #define MAX 0xaaaaa char chk[MAX+10]; int Q[MAX+10], *top, *end, *qmax = Q + MAX; int N, K, mask; int nxt[16]  r, g, b, step; int i, k; char buf[15], *bp; while (1) { scanf(\"%s\", buf);  = s = 0, bp = buf; *bp; bp++, N += 2) { if (*bp == 'r') k = 0; else if (*bp == 'g') k = 1; else k = 2; s = (s << 2) | k;  0, g = 0x55555 & mask, b = 0xaaaaa & mask; top = end = Q; *end++ = s, *end++ = -1, chk[s]  < end) { s = *top; if (++top >= qmax) top = Q; if (s < 0) { step++, *end = -1; if (++end >= qmax) end = Q; continue; } if (s ==  printf(\"%d\\n\", step); break; } for (i = 0; i <= K; i += 2) { int s2, k2; k =  == k) continue; s2 = (s  { chk[s2] = 1, *end = s2; if (++end >= qmax) end = Q; } } } if (top >= end) puts(\"NA\"); } return 0; }"], "original_ll": -1.4419238567352295, "sampled_ll": -0.5523600578308105, "all_perturbed_sampled_ll": [-1.1465915441513062], "all_perturbed_original_ll": [-2.2591612339019775], "perturbed_sampled_ll": -1.1465915441513062, "perturbed_original_ll": -2.2591612339019775, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Point2D;\nimport java.util.*;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\n\t\tnew AOJ0179();\n\n\n\t}\n\n\tclass AOJ0179{\n\t\tpublic AOJ0179() {\n\t\t\twhile(true){\n\t\t\t\tString warm = in.next();\n\t\t\t\tif(warm.equals(\"0\"))break;\n\t\t\t\tint ans = get_warm(warm);\n\t\t\t\tSystem.out.println(ans==-1? \"NA\":ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint get_warm(String input){\n\t\t\tQueue<String> warm = new LinkedList<String>();\n\t\t\tQueue<Integer> cnt = new LinkedList<Integer>();\n\t\t\tHashMap<String, Boolean> memo = new HashMap<String, Boolean>();\n\t\t\tmemo.put(input,true);\n\t\t\twarm.add(input);\n\t\t\tcnt.add(0);\n\t\t\twhile(warm.size()>0){\n\t\t\t\tString a = warm.remove();\n\t\t\t\tint step = cnt.remove();\n//\t\t\t\tSystem.out.println(a+\" \"+step);//deba\n\t\t\t\tboolean sw = true;\n\t\t\t\tfor(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1))sw=false;\n\t\t\t\tif(sw)return step;\n\t\t\t\t//\u3053\u3053\u304b\u3089\n\t\t\t\tfor(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1)){\n\t\t\t\t\tString b = a.substring(0,i)+getColor(a.charAt(i),a.charAt(i+1))+a.substring(i+2,a.length());\n\t\t\t\t\tif(memo.containsKey(b))continue;\n\t\t\t\t\twarm.add(b);\n\t\t\t\t\tcnt.add(step+1);\n\t\t\t\t\tmemo.put(b, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tString getColor(char a, char b){\n\t\t\tif(a=='r'&&b=='b'||a=='b'&&b=='r')return \"gg\";\n\t\t\telse if(a=='r'&&b=='g'||a=='g'&&b=='r')return \"bb\";\n\t\t\telse return \"rr\";\n\t\t}\n\t\t\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class State {\n        String config;\n        int steps;\n        \n        State(String config, int steps) {\n            this.config = config;\n            this.steps = steps;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String input = sc.next();\n            if (input.equals(\"0\")) break;\n            \n            int result = solve(input);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        sc.close();\n    }\n    \n    static int solve(String initial) {\n        if (isUniform(initial)) {\n            return 0;\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        queue.offer(new State(initial, 0));\n        visited.add(initial);\n        \n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            String config = current.config;\n            int steps = current.steps;\n            \n            // Find all adjacent pairs with different colors\n            for (int i = 0; i < config.length() - 1; i++) {\n                if (config.charAt(i) != config.charAt(i + 1)) {\n                    // Change this pair to the third color\n                    char newColor = getThirdColor(config.charAt(i), config.charAt(i + 1));\n                    String newConfig = config.substring(0, i) + newColor + newColor + config.substring(i + 2);\n                    \n                    if (isUniform(newConfig)) {\n                        return steps + 1;\n                    }\n                    \n                    if (!visited.contains(newConfig)) {\n                        visited.add(newConfig);\n                        queue.offer(new State(newConfig, steps + 1));\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static boolean isUniform(String s) {\n        if (s.length() == 0) return true;\n        char first = s.charAt(0);\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) != first) return false;\n        }\n        return true;\n    }\n    \n    static char getThirdColor(char c1, char c2) {\n        if ((c1 == 'r' && c2 == 'g') || (c1 == 'g' && c2 == 'r')) return 'b';\n        if ((c1 == 'r' && c2 == 'b') || (c1 == 'b' && c2 == 'r')) return 'g';\n        if ((c1 == 'g' && c2 == 'b') || (c1 == 'b' && c2 == 'g')) return 'r';\n        return c1; // Should not happen\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class State { String config; int steps; State(String config, int steps) { this.config = config; this.steps = steps; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { String input = sc.next(); if (input.equals(\"0\")) break; int result = solve(input); if (result == -1) { System.out.println(\"NA\"); } else { System.out.println(result);  (isUniform(initial)) { return 0; } Queue<State> queue = new LinkedList<>(); Set<String>   steps = current.steps; // Find all adjacent pairs with different colors for (int i = 0; i < config.length() -  // Change this pair to the third color char newColor = getThirdColor(config.charAt(i), config.charAt(i + 1)); String newConfig = config.substring(0, i) + newColor  steps + 1; } if (!visited.contains(newConfig)) { visited.add(newConfig); queue.offer(new State(newConfig, steps + 1)); } } } } return -1; } static boolean isUniform(String s) { if (s.length() == 0) return true; char first = s.charAt(0); for (int i = 1; i < s.length(); i++) { if (s.charAt(i) != first) return false; } return true; }  'r' && c2 == 'g') || (c1 == 'g' && c2 == 'r')) return 'b'; if ((c1 == 'r' && c2 == 'b') || (c1  == 'g' && c2 == 'b') ||  c1; // Should not happen } }"], "perturbed_original": ["import java.awt.geom.Point2D; import java.util.*; public class Main { Scanner in = new Scanner(System.in); public static void main(String[] args) { new Main(); }  { while(true){ String warm = in.next(); if(warm.equals(\"0\"))break; int ans = get_warm(warm); System.out.println(ans==-1? \"NA\":ans); } } int get_warm(String input){ Queue<String> warm = new LinkedList<String>(); Queue<Integer> cnt = new LinkedList<Integer>(); HashMap<String, Boolean> memo = new HashMap<String, Boolean>(); memo.put(input,true); warm.add(input); cnt.add(0); while(warm.size()>0){ String a = warm.remove();  true; for(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1))sw=false; if(sw)return step; //\u3053\u3053\u304b\u3089 for(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1)){ String b = a.substring(0,i)+getColor(a.charAt(i),a.charAt(i+1))+a.substring(i+2,a.length()); if(memo.containsKey(b))continue; warm.add(b); cnt.add(step+1); memo.put(b, true); } } return -1; } String  return \"rr\"; } } }"], "original_ll": -1.0500346422195435, "sampled_ll": -0.4743383824825287, "all_perturbed_sampled_ll": [-1.5570770502090454], "all_perturbed_original_ll": [-1.5641576051712036], "perturbed_sampled_ll": -1.5570770502090454, "perturbed_original_ll": -1.5641576051712036, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import deque\nused = [0]*(3**10)\n\n\nwhile True:\n\ts = raw_input()\n\tif s==\"0\":\n\t\tbreak\n\tn=len(s)\n\tt=0\n\tfor i in range(len(s)):\n\t\tt*=3\n\t\tif s[i]==\"r\":\n\t\t\tt+=0\n\t\tif s[i]==\"g\":\n\t\t\tt+=1\n\t\tif s[i]==\"b\":\n\t\t\tt+=2\n\tf=0\n\tfor i in range(3**n):\n\t\tused[i]=0\n\ttq=[t]\n\tq=deque(tq)\n\tused[t]=1\n\tans=-1\n\tcnt=0\n\twhile len(q)>0:\n\t\tqs=len(q)\n\t\tfor o in range(qs):\n\t\t\ttop=q.popleft()\n\t\t\tv=[0]\n\t\t\tv.pop()\n\t\t\tfor i in range(n):\n\t\t\t\tv.append(top%3)\n\t\t\t\ttop/=3\n\t\t\tok=1\n\t\t\ta=v[0]\n\t\t\tfor i in range(n):\n\t\t\t\tif v[i]!=a:\n\t\t\t\t\tok=0\n\t\t\tif ok==1:\n\t\t\t\tf=1\n\t\t\t\tans=cnt\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif v[i]!=v[i+1]:\n\t\t\t\t\tt1=v[i]\n\t\t\t\t\tt2=v[i+1]\n\t\t\t\t\tv[i]=3-t1-t2\n\t\t\t\t\tv[i+1]=3-t1-t2\n\t\t\t\t\ttmp=0\n\t\t\t\t\tfor j in range(n):\n\t\t\t\t\t\ttmp*=3\n\t\t\t\t\t\ttmp+=v[j]\n\t\t\t\t\tif used[tmp]==0:\n\t\t\t\t\t\tq.append(tmp)\n\t\t\t\t\t\tused[tmp]=1\n\t\t\t\t\tv[i]=t1\n\t\t\t\t\tv[i+1]=t2\n\t\tif f==1:\n\t\t\tbreak\n\t\telse:\n\t\t\tcnt+=1\n\tif ans==-1:\n\t\tprint \"NA\"\n\telse:\n\t\tprint ans", "sampled": "from collections import deque\n\ndef get_other_color(c1, c2):\n    colors = {'r', 'g', 'b'}\n    return list(colors - {c1, c2})[0]\n\ndef get_neighbors(state):\n    neighbors = []\n    for i in range(len(state) - 1):\n        if state[i] != state[i + 1]:\n            new_state = list(state)\n            new_color = get_other_color(state[i], state[i + 1])\n            new_state[i] = new_color\n            new_state[i + 1] = new_color\n            neighbors.append(''.join(new_state))\n    return neighbors\n\ndef solve(state):\n    if len(set(state)) == 1:\n        return 0\n    \n    visited = {state}\n    queue = deque([(state, 0)])\n    \n    while queue:\n        current, steps = queue.popleft()\n        \n        for neighbor in get_neighbors(current):\n            if len(set(neighbor)) == 1:\n                return steps + 1\n            \n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, steps + 1))\n    \n    return \"NA\"\n\nwhile True:\n    line = input().strip()\n    if line == \"0\":\n        break\n    print(solve(line))\n", "perturbed_sampled": ["from collections import deque def get_other_color(c1, c2): colors = {'r', 'g', 'b'} return list(colors - {c1, c2})[0] def get_neighbors(state): neighbors = []  new_color neighbors.append(''.join(new_state)) return neighbors def solve(state): if len(set(state)) == 1: return 0 visited = {state} queue = deque([(state, 0)]) while queue: current, steps = queue.popleft() for neighbor in get_neighbors(current): if len(set(neighbor)) == 1: return steps + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, steps + 1)) return \"NA\" while True: line = input().strip() if line == \"0\": break print(solve(line))"], "perturbed_original": ["from collections import deque used = [0]*(3**10) while True: s = raw_input() if s==\"0\": break n=len(s) t=0 for i in range(len(s)): t*=3 if s[i]==\"r\": t+=0 if s[i]==\"g\":  tq=[t] q=deque(tq) used[t]=1 ans=-1 cnt=0 while len(q)>0: qs=len(q) for o in range(qs): top=q.popleft() v=[0] v.pop() for i in range(n): v.append(top%3)  if ok==1: f=1 ans=cnt break for i in range(n-1):  range(n): tmp*=3 tmp+=v[j] if used[tmp]==0: q.append(tmp) used[tmp]=1 v[i]=t1 v[i+1]=t2 if f==1: break else: cnt+=1 if ans==-1: print \"NA\" else: print ans"], "original_ll": -1.0468782186508179, "sampled_ll": -0.7445476651191711, "all_perturbed_sampled_ll": [-1.3972843885421753], "all_perturbed_original_ll": [-2.1093037128448486], "perturbed_sampled_ll": -1.3972843885421753, "perturbed_original_ll": -2.1093037128448486, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0180: Demolition of Bridges\n// 2017.8.9\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x77777777\n#define MAX 100\n#define EMAX 500\nint n;\ntypedef struct { int b, c; } ND;\nND d[MAX + 2][MAX + 2];\nint w[MAX + 2];\nint visited[MAX];\n\nint qsize;\ntypedef struct { int a, b, c; } QUE;\nQUE que[EMAX + 1];\n\n#define PARENT(i) ((i)/2)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nstatic void min_heapify(int i)\n{\n\tint l, r, smallest;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].c < que[i].c) smallest = l; else smallest = i;\n\tif (r < qsize && que[r].c < que[smallest].c) smallest = r;\n\tif (smallest != i) {\n\t\tQUE t;\n\t\tmemcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + smallest, sizeof(QUE));\n\t\tmemcpy(que + smallest, &t, sizeof(QUE));\n\t\tmin_heapify(smallest);\n\t}\n}\n\nint deq(QUE *q)\n{\n\tif (qsize == 0) return -1;\n\tmemcpy(q, &que[0], sizeof(QUE));\n\tmemcpy(que, que + --qsize, sizeof(QUE));\n\tmin_heapify(0);\n\treturn 1;\n}\n\nvoid enq(QUE *q)\n{\n\tint i;\n\n\ti = qsize++;\n\tmemcpy(que + i, q, sizeof(QUE));\n\twhile (i > 0 && que[PARENT(i)].c > que[i].c) {\n\t\tQUE t;\n\t\tmemcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + PARENT(i), sizeof(QUE));\n\t\tmemcpy(que + PARENT(i), &t, sizeof(QUE));\n\t\ti = PARENT(i);\n\t}\n}\n\n\nint main()\n{\n\tint m, a, b, c;\n\tint i, k, ans;\n\tQUE q;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &n, &m); if (!n) return 0;\n\t\tmemset(w, 0, sizeof(w));\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\td[a][w[a]].b = b, d[a][w[a]++].c = c;\n\t\t\td[b][w[b]].b = a, d[b][w[b]++].c = c;\n\t\t}\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tans = 0, visited[0] = 1, k = 1, qsize = 0;\n\t\tfor (i = 0; i < w[0]; i++) q.a = 0, q.b = d[0][i].b, q.c = d[0][i].c, enq(&q);\n\t\twhile (k < n) {\n\t\t\tdo deq(&q);\n\t\t\twhile (visited[q.a] && visited[q.b]);\n\t\t\tk++;\n\t\t\ta = visited[q.a] ? q.b : q.a;\n\t\t\tvisited[a] = 1, ans += q.c;\n\t\t\tfor (i = 0; i < w[a]; i++) {\n\t\t\t\tb = d[a][i].b;\n\t\t\t\tif (!visited[b]) q.a = a, q.b = b, q.c = d[a][i].c, enq(&q);\n\t\t\t}\n\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int a, b, cost;\n} Edge;\n\nint parent[100];\n\nint find(int x) {\n    if (parent[x] == x) return x;\n    return parent[x] = find(parent[x]);\n}\n\nint unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return 0;\n    parent[x] = y;\n    return 1;\n}\n\nint compare(const void *a, const void *b) {\n    Edge *ea = (Edge *)a;\n    Edge *eb = (Edge *)b;\n    return ea->cost - eb->cost;\n}\n\nint main() {\n    int n, m;\n    \n    while (1) {\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0) break;\n        \n        Edge edges[500];\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &edges[i].a, &edges[i].b, &edges[i].cost);\n        }\n        \n        qsort(edges, m, sizeof(Edge), compare);\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        int total = 0;\n        int count = 0;\n        \n        for (int i = 0; i < m; i++) {\n            if (unite(edges[i].a, edges[i].b)) {\n                total += edges[i].cost;\n                count++;\n                if (count == n - 1) break;\n            }\n        }\n        \n        printf(\"%d\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int a, b, cost; } Edge; int parent[100]; int find(int x) { if (parent[x]  unite(int x, int y) { x = find(x); y = find(y); if (x == y) return 0; parent[x] = y; return 1; } int compare(const void  Edge *eb = (Edge *)b; return ea->cost - eb->cost; } int main()  &m); if  for (int i = 0; i < m; i++) { scanf(\"%d %d %d\", &edges[i].a, &edges[i].b, &edges[i].cost); } qsort(edges, m, sizeof(Edge), compare); for (int i =  int total = 0; int count = 0; for (int i = 0; i < m; i++) { if (unite(edges[i].a, edges[i].b)) { total += edges[i].cost; count++; if (count == n - 1) break; } } printf(\"%d\\n\", total); } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0180: Demolition of Bridges // 2017.8.9 #include <stdio.h> #include <stdlib.h> #include <string.h> #define INF 0x77777777 #define MAX 100 #define EMAX 500 int n; typedef struct { int b, c; } ND; ND d[MAX + 2][MAX + 2]; int w[MAX + 2]; int visited[MAX]; int qsize; typedef struct { int a, b, c; } QUE; QUE que[EMAX + 1]; #define PARENT(i) ((i)/2) #define LEFT(i) ((i)<<1) #define RIGHT(i) (((i)<<1)+1) static void min_heapify(int i) { int l, r, smallest; l = LEFT(i), r = RIGHT(i); if (l < qsize && que[l].c < que[i].c) smallest = l; else smallest = i; if (r < qsize && que[r].c < que[smallest].c) smallest = r; if (smallest != i) { QUE t;  } int deq(QUE *q) { if (qsize == 0) return -1; memcpy(q, &que[0], sizeof(QUE)); memcpy(que, que + --qsize, sizeof(QUE)); min_heapify(0); return 1; } void enq(QUE *q) { int  (i > 0 && que[PARENT(i)].c > que[i].c) { QUE t; memcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que  PARENT(i); } } int main() { int m, a, b, c; int i, k, ans; QUE q; while (1) { scanf(\"%d%d\", &n, &m); if (!n) return 0; memset(w, 0, sizeof(w)); for (i = 0; i < m; i++) { scanf(\"%d%d%d\",  ans = 0, visited[0]  = 0; i < w[0]; i++) q.a = 0, q.b = d[0][i].b, q.c = d[0][i].c, enq(&q); while (k < n) { do deq(&q); while (visited[q.a] && visited[q.b]); k++; a = visited[q.a] ? q.b : q.a; visited[a] = 1, ans   ans); } return 0; }"], "original_ll": -0.8816484212875366, "sampled_ll": -0.351275235414505, "all_perturbed_sampled_ll": [-1.3142101764678955], "all_perturbed_original_ll": [-1.518601655960083], "perturbed_sampled_ll": -1.3142101764678955, "perturbed_original_ll": -1.518601655960083, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tstatic int n, m;\n\tstatic int[][] node;\n\n\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\n\t}\n\n\tstatic boolean read(){\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tif(n == 0 && m == 0)  return false;\n\n\t\tnode = new int[n][n];  //\u008b\u0097\u0097\u00a3\u008ds\u0097\u00f1\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(i==j) node[i][j] = 0;\n\t\t\t\telse     node[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint node1 = sc.nextInt();\n\t\t\tint node2 = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\n\t\t\tnode[node1][node2] = cost;\n\t\t\tnode[node2][node1] = cost;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\t//\u0083v\u0083\u008a\u0083\u0080\u0096@\n\tstatic void solve(){\n\t\tint sum =0;\n\t\tHashSet<Integer> X = new HashSet<Integer>();  //\u008c\u0088\u0092\u00e8\u008d\u00cf\u0082\u00dd\u008fW\u008d\u0087\n\t\tHashSet<Integer> Y = new HashSet<Integer>();  //\u0096\u00a2\u008c\u0088\u0092\u00e8\u008fW\u008d\u0087\n\n\t\t//\u008fW\u008d\u0087\u0082\u00cc\u008f\u0089\u008a\u00fa\u0089\u00bb\n\t\tX.add(0);\n\t\tfor(int i=1; i<n; i++){\n\t\t\tY.add(i);\n\t\t}\n\n\t\t//\u0096\u00a2\u008c\u0088\u0092\u00e8\u0082\u00cc\u008fW\u008d\u0087\u0082\u00aa\u008b\u00f3\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00dc\u0082\u00c5\n\t\twhile(!Y.isEmpty()){\n\n\t\t\t//\u008d\u00c5\u008f\u00ac\u0083R\u0083X\u0083g\u0082\u00cc\u0097\u00d7\u0090\u00da\u0083m\u0081[\u0083h\u0082\u00f0\u0092\u00b2\u0082\u00d7\u0082\u00e9\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint min_num = -1, min_num2 = -1;\n\n\t\t\tfor(Iterator<Integer> i1 = X.iterator(); i1.hasNext();){\n\t\t\t\tint n1 = i1.next();\n\t\t\t\tfor (Iterator<Integer> i2 = Y.iterator(); i2.hasNext();){\n\t\t\t\t\tint n2 = i2.next();\n\t\t\t\t\tif(node[n1][n2] == -1)  continue;\n\n\t\t\t\t\tif(min > node[n1][n2]){\n\t\t\t\t\t\tmin = node[n1][n2];\n\t\t\t\t\t\tmin_num = n1;\n\t\t\t\t\t\tmin_num2 = n2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsum += node[min_num][min_num2];\n\t\t\tY.remove(min_num2);\n\t\t\tX.add(min_num2);\n\t\t}\n\n\t\tSystem.out.println(sum);  //\u008fo\u0097\u00cd\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge implements Comparable<Edge> {\n        int u, v, cost;\n        \n        Edge(int u, int v, int cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(Edge other) {\n            return this.cost - other.cost;\n        }\n    }\n    \n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) {\n                return false;\n            }\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            \n            return true;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) {\n                break;\n            }\n            \n            List<Edge> edges = new ArrayList<>();\n            \n            for (int i = 0; i < m; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int cost = sc.nextInt();\n                edges.add(new Edge(a, b, cost));\n            }\n            \n            Collections.sort(edges);\n            \n            UnionFind uf = new UnionFind(n);\n            int totalCost = 0;\n            int edgeCount = 0;\n            \n            for (Edge edge : edges) {\n                if (uf.union(edge.u, edge.v)) {\n                    totalCost += edge.cost;\n                    edgeCount++;\n                    if (edgeCount == n - 1) {\n                        break;\n                    }\n                }\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Edge implements Comparable<Edge> { int u, v, cost; Edge(int u, int v, int cost) { this.u = u; this.v = v; this.cost = cost; } @Override public int compareTo(Edge other) { return this.cost  int[] rank; UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i < n; i++) { parent[i] = i; rank[i] = 0; } } int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } boolean union(int x, int y) { int rootX = find(x);  = rootX; } else { parent[rootY] = rootX; rank[rootX]++; } return true; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); int m = sc.nextInt(); if (n == 0 && m == 0) { break; } List<Edge> edges = new  { int a = sc.nextInt(); int b =  Collections.sort(edges); UnionFind uf = new UnionFind(n); int totalCost = 0; int edgeCount = 0; for (Edge edge : edges) { if  n - 1) { break; } } } System.out.println(totalCost); } sc.close(); } }"], "perturbed_original": ["import java.util.HashSet; import java.util.Iterator; import java.util.Scanner; public class Main { static Scanner sc = new Scanner(System.in); static int n, m;  solve(); } } static boolean read(){ n = sc.nextInt(); m = sc.nextInt();  = new int[n][n]; //\u008b\u0097\u0097\u00a3\u008ds\u0097\u00f1 for(int i=0; i<n; i++){ for(int j=0; j<n; j++){ if(i==j) node[i][j] = 0; else node[i][j] = -1; } } for(int i=0; i<m; i++){ int node1 = sc.nextInt(); int node2 = sc.nextInt(); int cost = sc.nextInt(); node[node1][node2] = cost; node[node2][node1] = cost; } return true; } //\u0083v\u0083\u008a\u0083\u0080\u0096@ static void solve(){ int sum =0; HashSet<Integer> X = new HashSet<Integer>(); //\u008c\u0088\u0092\u00e8\u008d\u00cf\u0082\u00dd\u008fW\u008d\u0087 HashSet<Integer> Y = new HashSet<Integer>(); //\u0096\u00a2\u008c\u0088\u0092\u00e8\u008fW\u008d\u0087 //\u008fW\u008d\u0087\u0082\u00cc\u008f\u0089\u008a\u00fa\u0089\u00bb X.add(0); for(int i=1; i<n; i++){ Y.add(i); } //\u0096\u00a2\u008c\u0088\u0092\u00e8\u0082\u00cc\u008fW\u008d\u0087\u0082\u00aa\u008b\u00f3\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00dc\u0082\u00c5 while(!Y.isEmpty()){ //\u008d\u00c5\u008f\u00ac\u0083R\u0083X\u0083g\u0082\u00cc\u0097\u00d7\u0090\u00da\u0083m\u0081[\u0083h\u0082\u00f0\u0092\u00b2\u0082\u00d7\u0082\u00e9 int  for(Iterator<Integer> i1 = X.iterator(); i1.hasNext();){ int  n2 = i2.next(); if(node[n1][n2] == -1) continue; if(min > node[n1][n2]){ min =  sum += node[min_num][min_num2]; Y.remove(min_num2); X.add(min_num2); } System.out.println(sum); //\u008fo\u0097\u00cd } }"], "original_ll": -1.3004319667816162, "sampled_ll": -0.1961108148097992, "all_perturbed_sampled_ll": [-0.9817795753479004], "all_perturbed_original_ll": [-2.0416171550750732], "perturbed_sampled_ll": -0.9817795753479004, "perturbed_original_ll": -2.0416171550750732, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f(s, cost, route, ans):\n    route.append(s)\n    ans += cost[s]\n    del cost[s]\n    for k, c in data.items():\n        if s in k:\n            a, b = k\n            if s == a:\n                if not b in route:\n                    if not b in cost or c < cost[b]:\n                        cost[b] = c\n                        del data[(a, b)]\n            elif s == b:\n                if not a in route:\n                    if not a in cost or c < cost[a]:\n                        cost[a] = c\n                        del data[(a, b)]\n    if cost:\n        s = sorted(cost.items(), key=lambda x: x[1])[0][0]\n        return f(s, cost, route, ans)\n    return ans\n\nwhile 1:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    data = {}\n    for i in range(m):\n        a, b, c = map(int, raw_input().split())\n        data[(a, b)] = c\n    print f(0, {0:0}, [], 0)", "sampled": "import sys\nfrom typing import List, Tuple\n\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x: int) -> int:\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x: int, y: int) -> bool:\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False\n        \n        if self.rank[root_x] < self.rank[root_y]:\n            self.parent[root_x] = root_y\n        elif self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        else:\n            self.parent[root_y] = root_x\n            self.rank[root_x] += 1\n        \n        return True\n\ndef kruskal(n: int, edges: List[Tuple[int, int, int]]) -> int:\n    edges.sort(key=lambda x: x[2])\n    uf = UnionFind(n)\n    total_cost = 0\n    edges_added = 0\n    \n    for a, b, cost in edges:\n        if uf.union(a, b):\n            total_cost += cost\n            edges_added += 1\n            if edges_added == n - 1:\n                break\n    \n    return total_cost\n\ndef main():\n    input_lines = sys.stdin.read().strip().split('\\n')\n    i = 0\n    \n    while i < len(input_lines):\n        line = input_lines[i].strip()\n        if not line:\n            i += 1\n            continue\n        \n        parts = line.split()\n        n, m = int(parts[0]), int(parts[1])\n        \n        if n == 0 and m == 0:\n            break\n        \n        i += 1\n        edges = []\n        \n        for j in range(m):\n            line = input_lines[i].strip()\n            parts = line.split()\n            a, b, cost = int(parts[0]), int(parts[1]), int(parts[2])\n            edges.append((a, b, cost))\n            i += 1\n        \n        result = kruskal(n, edges)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from typing import List, Tuple class UnionFind: def __init__(self, n: int): self.parent = list(range(n)) self.rank = [0] * n def find(self,  self.find(self.parent[x]) return self.parent[x] def union(self, x: int, y: int) -> bool: root_x = self.find(x) root_y = self.find(y)  root_x else: self.parent[root_y] = root_x self.rank[root_x] += 1 return True def kruskal(n: int, edges: List[Tuple[int, int, int]]) ->  if uf.union(a, b): total_cost += cost edges_added += 1 if edges_added == n - 1: break return total_cost def main(): input_lines = sys.stdin.read().strip().split('\\n') i = 0 while i < len(input_lines): line = input_lines[i].strip() if  m = int(parts[0]), int(parts[1]) if n == 0 and m == 0: break i += 1 edges = [] for j in range(m): line = input_lines[i].strip() parts = line.split() a, b, cost = int(parts[0]), int(parts[1]), int(parts[2]) edges.append((a, b, cost)) i += 1 result = kruskal(n, edges) print(result) if __name__ == \"__main__\": main()"], "perturbed_original": ["def f(s, cost, route, ans): route.append(s) ans += cost[s] del  a, b = k if s == a: if not b in route: if not b in cost or c < cost[b]: cost[b] = c del data[(a, b)] elif s == b: if not a in  cost[a] = c del data[(a, b)] if cost: s = sorted(cost.items(), key=lambda x: x[1])[0][0] return f(s, cost, route, ans)  n == m == 0: break data = {} for i in range(m): a, b, c = map(int, raw_input().split()) data[(a, b)] = c print f(0, {0:0}, [], 0)"], "original_ll": -1.0400856733322144, "sampled_ll": -0.3186566233634949, "all_perturbed_sampled_ll": [-1.238322138786316], "all_perturbed_original_ll": [-2.116584539413452], "perturbed_sampled_ll": -1.238322138786316, "perturbed_original_ll": -2.116584539413452, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void){\n\tint m,n,q,r,a,i,j,t[100],s;\n\tfor(;scanf(\"%d%d\",&m,&n),m;printf(\"%d\\n\",q)){\n\t\tfor(s=i=q=0;i<n;i++){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tt[i]=a;\n\t\t\ts+=a;\n\t\t\tif(q<a)q=a;\n\t\t}\n\t\tr=s>1500000?1500000:s;\n\t\tfor(;q<r;){\n\t\t\tj=m;\n\t\t\ta=q+r>>1;\n\t\t\ts=0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\ts+=t[i];\n\t\t\t\tif(s>a){\n\t\t\t\t\tif(!--j)break;\n\t\t\t\t\ts=t[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==n){\tr=a;\t}\n\t\t\telse{\tq=a+1;\t}\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint m, n;\nint w[105];\nint dp[105][25];\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint solve(int pos, int shelves) {\n    if (pos == n) {\n        if (shelves == 0) return 0;\n        return 1e9;\n    }\n    if (shelves == 0) return 1e9;\n    \n    if (dp[pos][shelves] != -1) return dp[pos][shelves];\n    \n    int result = 1e9;\n    int sum = 0;\n    \n    for (int i = pos; i < n; i++) {\n        sum += w[i];\n        int remaining = solve(i + 1, shelves - 1);\n        if (remaining != 1e9) {\n            result = result < max(sum, remaining) ? result : max(sum, remaining);\n        }\n    }\n    \n    dp[pos][shelves] = result;\n    return result;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &m, &n);\n        if (m == 0 && n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &w[i]);\n        }\n        \n        memset(dp, -1, sizeof(dp));\n        printf(\"%d\\n\", solve(0, m));\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int m, n; int w[105]; int dp[105][25]; int max(int a, int b) { return a > b ? a : b; } int solve(int pos, int shelves) { if (pos == n)  if  dp[pos][shelves]; int result = 1e9; int sum = 0; for (int i = pos; i < n; i++) { sum += w[i]; int remaining = solve(i  result = result < max(sum, remaining) ? result : max(sum, remaining); } } dp[pos][shelves] = result; return result; } int main() { while (1) { scanf(\"%d %d\", &m,  for (int i = 0; i < n; i++) { scanf(\"%d\", &w[i]); } memset(dp, -1, sizeof(dp)); printf(\"%d\\n\", solve(0, m)); } return 0; }"], "perturbed_original": ["#include <stdio.h>  } r=s>1500000?1500000:s; for(;q<r;){ j=m; a=q+r>>1; s=0; for(i=0;i<n;i++){ s+=t[i]; if(s>a){ if(!--j)break; s=t[i]; } } if(i==n){ r=a; } else{ q=a+1; } } } return 0; }"], "original_ll": -1.5560170412063599, "sampled_ll": -0.5480055212974548, "all_perturbed_sampled_ll": [-1.2356672286987305], "all_perturbed_original_ll": [-2.311277389526367], "perturbed_sampled_ll": -1.2356672286987305, "perturbed_original_ll": -2.311277389526367, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m;\n\tstatic int book[];\n\n\tpublic static int binarySearch(int low, int high) {\n\t\tif (high - low <= 0) {\n\t\t\treturn high;\n\t\t}\n\t\tint mid = (low + high) / 2;\n\t\tint shellId = 0;\n\t\tint sumWidth = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (mid < sumWidth + book[i]) {\n\t\t\t\tshellId++;\n\t\t\t\tsumWidth = book[i];\n\t\t\t} else {\n\t\t\t\tsumWidth += book[i];\n\t\t\t}\n\t\t}\n\n\t\tif (n <= shellId) {\n\t\t\treturn binarySearch(mid + 1, high);\n\t\t} else {\n\t\t\treturn binarySearch(low, mid);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint max;\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();//tana\n\t\t\tm = sc.nextInt();//kann\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbook = new int[m];\n\t\t\tmax = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbook[i] = sc.nextInt();\n\t\t\t\tmax = Math.max(max, book[i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(binarySearch(max, 1500000));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            \n            if (m == 0 && n == 0) break;\n            \n            int[] w = new int[n];\n            for (int i = 0; i < n; i++) {\n                w[i] = sc.nextInt();\n            }\n            \n            // Binary search on the width\n            int left = 0;\n            int right = 1500000;\n            \n            // Find the minimum of maximum widths\n            for (int i = 0; i < n; i++) {\n                left = Math.max(left, w[i]);\n            }\n            \n            while (left < right) {\n                int mid = (left + right) / 2;\n                if (canFit(w, n, m, mid)) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            \n            System.out.println(left);\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean canFit(int[] w, int n, int m, int maxWidth) {\n        int shelves = 1;\n        int currentWidth = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (currentWidth + w[i] <= maxWidth) {\n                currentWidth += w[i];\n            } else {\n                shelves++;\n                currentWidth = w[i];\n                if (shelves > m) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in); while (true) { int m = sc.nextInt(); int n = sc.nextInt(); if (m == 0 && n == 0) break; int[] w =  on the width int left = 0; int right = 1500000; // Find the minimum of maximum widths for (int i = 0; i < n;  right) { int mid = (left + right) / 2; if (canFit(w, n, m, mid)) { right = mid; } else { left = mid + 1; } } System.out.println(left); } sc.close(); } private static boolean canFit(int[] w, int n, int m, int maxWidth) { int shelves = 1; int currentWidth = 0; for (int i =  <= maxWidth) { currentWidth += w[i]; } else { shelves++; currentWidth = w[i]; if (shelves > m) { return false; } } } return true; } }"], "perturbed_original": [" static int book[]; public static int binarySearch(int low, int  high; } int mid = (low + high) / 2; int shellId = 0; int sumWidth = 0; for (int i = 0; i  { shellId++; sumWidth = book[i]; } else { sumWidth += book[i]; } } if (n  { return binarySearch(low, mid); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int max; while (true) { n = sc.nextInt();//tana m = sc.nextInt();//kann if ((n | m) == 0) { break; } book = new int[m]; max = 0; for (int i = 0; i < m; i++) { book[i] = sc.nextInt(); max = Math.max(max, book[i]); } System.out.println(binarySearch(max, 1500000)); } } }"], "original_ll": -0.88388592004776, "sampled_ll": -0.5126283764839172, "all_perturbed_sampled_ll": [-1.4384405612945557], "all_perturbed_original_ll": [-1.7351329326629639], "perturbed_sampled_ll": -1.4384405612945557, "perturbed_original_ll": -1.7351329326629639, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def hondan(w,m):\n    m_sum = b_lis[0]\n    num = 0\n    if w < max(b_lis):\n        return False\n    else:\n        for i in range(len(b_lis) - 1):\n            m_sum += b_lis[i + 1]\n            if m_sum > w:\n\n                m_sum = b_lis[i + 1]\n                num += 1\n\n        if num < m:\n            return True\n        else:\n            return False\n        \ndef nibutan(f_id,e_id,m):\n    \n    \n    m_id = int((f_id + e_id) / 2)\n    m_bo = hondan(m_id,m)\n\n\n    if (f_id > e_id):\n        return m_id + 1\n    else:\n        if m_bo:\n            return(nibutan(f_id,m_id -1,m))\n        elif not m_bo:\n            return(nibutan(m_id + 1,e_id,m))\n        else:\n            return m_id + 1\n\n\n\nwhile True:\n    global w_lis\n    b_lis = []\n    w_lis = []\n    dan_num = [0]\n\n    m,n = map(int,input().split())\n    if m == n == 0:\n        break\n    for i in range(n):\n        num = int(input())\n        b_lis.append(num)\n    s_num = int(sum(b_lis) /m)\n\n    print(nibutan(s_num,1500000,m) )", "sampled": "def can_fit(books, m, max_width):\n    shelves_used = 1\n    current_width = 0\n    \n    for book in books:\n        if book > max_width:\n            return False\n        if current_width + book > max_width:\n            shelves_used += 1\n            current_width = book\n            if shelves_used > m:\n                return False\n        else:\n            current_width += book\n    \n    return True\n\ndef solve(m, n, books):\n    left = max(books)\n    right = sum(books)\n    \n    result = right\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_fit(books, m, mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\nwhile True:\n    line = input().split()\n    m, n = int(line[0]), int(line[1])\n    \n    if m == 0 and n == 0:\n        break\n    \n    books = []\n    for _ in range(n):\n        books.append(int(input()))\n    \n    print(solve(m, n, books))\n", "perturbed_sampled": ["def can_fit(books, m, max_width): shelves_used = 1 current_width = 0 for book in books: if book  shelves_used += 1  current_width += book return True def solve(m, n, books): left = max(books) right = sum(books) result = right while left <= right: mid = (left + right) // 2 if can_fit(books, m, mid): result = mid right = mid - 1 else: left = mid +  = int(line[0]), int(line[1]) if m == 0 and n == 0: break books = [] for _ in range(n): books.append(int(input())) print(solve(m, n, books))"], "perturbed_original": ["def hondan(w,m): m_sum = b_lis[0] num = 0 if w < max(b_lis): return False else: for i  m_sum > w: m_sum = b_lis[i + 1] num += 1 if num < m: return True else: return False def nibutan(f_id,e_id,m): m_id = int((f_id + e_id) / 2) m_bo = hondan(m_id,m) if (f_id > e_id): return m_id + 1 else: if m_bo: return(nibutan(f_id,m_id -1,m)) elif not m_bo: return(nibutan(m_id + 1,e_id,m)) else: return m_id + 1 while True: global w_lis b_lis = [] w_lis = []  int(input()) b_lis.append(num) s_num = int(sum(b_lis) /m) print(nibutan(s_num,1500000,m) )"], "original_ll": -1.5452972650527954, "sampled_ll": -0.6672963500022888, "all_perturbed_sampled_ll": [-1.6825517416000366], "all_perturbed_original_ll": [-2.0982768535614014], "perturbed_sampled_ll": -1.6825517416000366, "perturbed_original_ll": -2.0982768535614014, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\nint b[50]; // beaker status\nint d[50]; // used status\nint f[50]; // filled status\n\nint compare(const void *a, const void *b) {\n  return *(int *)b - *(int *)a;\n}\n\nint dcheck(int n) {\n  int i, r;\n  for (i = 0, r = 0; i < n; i++)\n    r += d[i];\n  if (r == n)\n    return 1;\n  else\n    return 0;\n}\n\nint beaker(int n, int m) {\n  int i, t;\n  f[m] = 0;\n  d[m] = 1;\n\n  if (n == 1) return 1;\n  for (i = m + 1, t = b[m]; i < n; i++) {\n    if (t >= b[i] && f[i] == 0) {\n      t -= b[i];\n      d[i] = f[i] = 1;\n    }\n    if (t == 0)\n      if (dcheck(n))\n        return 1;\n      else\n        beaker(n, m + 1);\n  }\n  return 0;\n}\n\nvoid init() {\n  int i;\n  for (i = 0; i < 50; i++)\n    b[i] = f[i] = d[i] = 0;\n  return;\n}\n\nint main() {\n  int i, n, m;\n\n  for (;;) {\n    scanf(\"%d\", &n);\n    if (n == 0)\n      return 0;\n    init();\n    for (i = 0; i < n; i++)\n      scanf(\"%d\", &b[i]);\n    qsort(b, n, sizeof(int), compare);\n    m = 0; // set max value posion\n    printf(\"%s\", beaker(n, m) ? \"YES\\n\" : \"NO\\n\");\n  }\n  return -1;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint canFill(int *beakers, int n) {\n    int *filled = (int*)calloc(n, sizeof(int));\n    int i, j;\n    \n    filled[0] = beakers[0];\n    \n    for (i = 0; i < n; i++) {\n        if (filled[i] == 0) continue;\n        \n        int water = filled[i];\n        \n        for (j = 0; j < n && water > 0; j++) {\n            if (filled[j] == 0) {\n                int toFill = beakers[j];\n                if (water >= toFill) {\n                    filled[j] = toFill;\n                    water -= toFill;\n                }\n            }\n        }\n        \n        if (water > 0) {\n            free(filled);\n            return 0;\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (filled[i] == 0) {\n            free(filled);\n            return 0;\n        }\n    }\n    \n    free(filled);\n    return 1;\n}\n\nint solve(int *beakers, int n, int index, long long water, int *used) {\n    if (water < 0) return 0;\n    \n    if (index == n) {\n        return (water == 0);\n    }\n    \n    if (used[index]) {\n        return solve(beakers, n, index + 1, water, used);\n    }\n    \n    if (water >= beakers[index]) {\n        used[index] = 1;\n        if (solve(beakers, n, 0, water - beakers[index], used)) {\n            used[index] = 0;\n            return 1;\n        }\n        used[index] = 0;\n    }\n    \n    return solve(beakers, n, index + 1, water, used);\n}\n\nint canFillRecursive(int *beakers, int n, int current, int *used) {\n    if (current == n) {\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) return 0;\n        }\n        return 1;\n    }\n    \n    if (!used[current]) return 0;\n    \n    long long water = beakers[current];\n    int *newUsed = (int*)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) newUsed[i] = used[i];\n    \n    if (solve(beakers, n, 0, water, newUsed)) {\n        if (canFillRecursive(beakers, n, current + 1, newUsed)) {\n            free(newUsed);\n            return 1;\n        }\n    }\n    \n    free(newUsed);\n    return 0;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int *beakers = (int*)malloc(n * sizeof(int));\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &beakers[i]);\n        }\n        \n        qsort(beakers, n, sizeof(int), compare);\n        \n        if (n == 1) {\n            printf(\"YES\\n\");\n            free(beakers);\n            continue;\n        }\n        \n        int *used = (int*)calloc(n, sizeof(int));\n        used[0] = 1;\n        \n        if (canFillRecursive(beakers, n, 0, used)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n        \n        free(used);\n        free(beakers);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int compare(const void *a, const void *b) { return (*(int*)b - *(int*)a); } int canFill(int *beakers,  j; filled[0] = beakers[0]; for (i = 0; i < n; i++) { if (filled[i] == 0) continue; int water = filled[i]; for (j = 0; j < n && water > 0; j++) { if (filled[j] == 0) { int toFill = beakers[j]; if (water >= toFill) { filled[j] = toFill; water -= toFill; } } } if  (i = 0; i < n; i++) { if (filled[i] == 0) { free(filled); return 0; } } free(filled); return 1; } int solve(int *beakers, int n, int index,  return 0; if (index == n) { return (water == 0); } if (used[index]) { return solve(beakers, n, index + 1, water, used); } if (water >= beakers[index]) { used[index] = 1; if (solve(beakers, n, 0, water - beakers[index], used)) { used[index] = 0; return 1; } used[index] = 0; } return solve(beakers, n, index + 1, water, used); } int canFillRecursive(int *beakers, int n, int current, int *used) { if (current == n) { for (int i = 0; i < n; i++) { if (!used[i]) return 0; } return 1; } if (!used[current])  (int*)malloc(n * sizeof(int)); for (int i = 0; i < n; i++) newUsed[i] = used[i]; if (solve(beakers, n, 0,  { free(newUsed); return 1; } } free(newUsed); return 0; }  && n  (int i = 0; i < n; i++) { scanf(\"%d\", &beakers[i]); } qsort(beakers, n, sizeof(int), compare); if (n == 1)  return 0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> int b[50]; // beaker status int d[50]; // used status int f[50]; // filled status int compare(const void *a, const void *b) { return *(int *)b - *(int *)a; } int dcheck(int n) { int i, r; for (i = 0, r = 0; i < n; i++) r += d[i]; if (r ==  int m) { int i, t; f[m] = 0; d[m] = 1; if (n == 1) return 1; for (i  i++) { if (t >= b[i] && f[i] == 0) { t -= b[i]; d[i] = f[i] = 1; } if (t == 0) if (dcheck(n)) return 1; else beaker(n, m + 1); } return 0; } void  50; i++) b[i]  { int i, n, m; for (;;) { scanf(\"%d\", &n); if (n == 0)  i++) scanf(\"%d\", &b[i]); qsort(b, n, sizeof(int), compare); m = 0; // set max value  -1; }"], "original_ll": -0.9560869336128235, "sampled_ll": -0.4946739375591278, "all_perturbed_sampled_ll": [-1.0889801979064941], "all_perturbed_original_ll": [-1.672412395477295], "perturbed_sampled_ll": -1.0889801979064941, "perturbed_original_ll": -1.672412395477295, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Beaker\npublic class Main{\n\n\tint n;\n\tint[] a;\n\tboolean[] have, t;\n\t\n\tboolean dfs(int k, int rest){\n\t\tif(rest==0){\n\t\t\tfor(int i=0;i<n;i++)t[i]=have[i];\n\t\t\treturn greedy();\n\t\t}\n\t\tif(rest < a[k])return false;\n\t\thave[k] = true;\n\t\tif(dfs(k+1, rest-a[k]))return true;\n\t\thave[k] = false;\n\t\treturn dfs(k+1, rest);\n\t}\n\t\n\tboolean choice(int k, int rest){\n\t\tif(rest==0)return true;\n\t\tif(k<0)return false;\n\t\tif(!t[k])return choice(k-1, rest);\n\t\tif(a[k]<=rest){\n\t\t\tt[k] = false;\n\t\t\tif(choice(k-1, rest-a[k]))return true;\n\t\t\tt[k] = true;\n\t\t}\n\t\treturn choice(k-1, rest);\n\t}\n\t\n\tboolean greedy(){\n\t\tfor(int i=0;i<n;i++)if(!t[i]){\n\t\t\tif(!choice(i-1, a[i]))return false;\n\t\t\tt[i] = true;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tt = new boolean[100];\n\t\thave = new boolean[100];\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\ta = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\tArrays.fill(have, false);\n\t\t\thave[0] = true;\n\t\t\tSystem.out.println(dfs(1, a[n-1]-a[0])?\"YES\":\"NO\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] beakers = new int[n];\n            for (int i = 0; i < n; i++) {\n                beakers[i] = sc.nextInt();\n            }\n            \n            if (canFillAll(beakers)) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static boolean canFillAll(int[] beakers) {\n        int n = beakers.length;\n        if (n == 1) return true;\n        \n        Arrays.sort(beakers);\n        int maxIdx = n - 1;\n        \n        return dfs(beakers, new boolean[n], maxIdx, beakers[maxIdx]);\n    }\n    \n    static boolean dfs(int[] beakers, boolean[] used, int currentIdx, int currentWater) {\n        used[currentIdx] = true;\n        \n        if (allUsed(used)) {\n            return true;\n        }\n        \n        return tryPour(beakers, used, currentWater, 0);\n    }\n    \n    static boolean tryPour(int[] beakers, boolean[] used, int water, int startIdx) {\n        if (water == 0) {\n            for (int i = beakers.length - 1; i >= 0; i--) {\n                if (!used[i]) {\n                    boolean[] newUsed = used.clone();\n                    if (dfs(beakers, newUsed, i, beakers[i])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        \n        for (int i = startIdx; i < beakers.length; i++) {\n            if (!used[i] && beakers[i] <= water) {\n                boolean[] newUsed = used.clone();\n                if (tryPour(beakers, newUsed, water - beakers[i], i + 1)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    static boolean allUsed(boolean[] used) {\n        for (boolean u : used) {\n            if (!u) return false;\n        }\n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[] beakers = new int[n]; for (int i = 0; i < n; i++)  else { System.out.println(\"NO\"); } } sc.close(); } static boolean canFillAll(int[] beakers) { int n = beakers.length; if (n == 1) return true; Arrays.sort(beakers); int maxIdx = n - 1; return dfs(beakers, new boolean[n], maxIdx, beakers[maxIdx]); } static boolean dfs(int[] beakers, boolean[] used, int currentIdx, int currentWater) { used[currentIdx] = true; if (allUsed(used)) { return true; } return tryPour(beakers,  { for (int i = beakers.length - 1; i >= 0; i--) { if (!used[i]) { boolean[] newUsed = used.clone(); if (dfs(beakers, newUsed, i, beakers[i])) { return true; } } } return false; } for (int i = startIdx; i < beakers.length; i++)  =  static boolean allUsed(boolean[] used) { for (boolean u : used) { if (!u) return false; } return true; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; //Beaker public class Main{ int n; int[] a; boolean[] have, t; boolean dfs(int k, int rest){ if(rest==0){ for(int i=0;i<n;i++)t[i]=have[i]; return greedy(); } if(rest < a[k])return false; have[k] = true; if(dfs(k+1, rest-a[k]))return true; have[k] = false; return dfs(k+1, rest); } boolean choice(int  if(a[k]<=rest){ t[k] = false; if(choice(k-1, rest-a[k]))return  greedy(){ for(int i=0;i<n;i++)if(!t[i]){ if(!choice(i-1, a[i]))return false; t[i]  = new Scanner(System.in); t = new boolean[100]; have = new boolean[100]; for(;;){ n =  sc.nextInt(); } Arrays.sort(a); Arrays.fill(have, false); have[0] = true; System.out.println(dfs(1, a[n-1]-a[0])?\"YES\":\"NO\"); } } public static void main(String[] args) { new Main().run(); } }"], "original_ll": -0.825313925743103, "sampled_ll": -0.5352585911750793, "all_perturbed_sampled_ll": [-1.169260859489441], "all_perturbed_original_ll": [-1.628265380859375], "perturbed_sampled_ll": -1.169260859489441, "perturbed_original_ll": -1.628265380859375, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(input())\n    if n == 0: break\n    beakers = list(map(int, input().split()))\n    m = max(beakers)\n    beakers.remove(m)\n    beakers.sort()\n    if beakers:\n        beakersum = [beakers[0]]\n        del beakers[0]\n    else:\n        print(\"YES\")\n        continue\n\n    if sum(beakers) < m:\n        print(\"NO\")\n        continue\n    elif sum(beakers) == m:\n        print(\"YES\")\n        continue\n\n    for b in beakers:\n        tmp = [bks + b for bks in beakersum if bks + b <= m]\n        beakersum.extend(tmp)\n        if m in beakersum:\n            break\n    \n    if m in beakersum:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n            \n        ", "sampled": "def can_fill_all_beakers(beakers):\n    n = len(beakers)\n    if n == 1:\n        return True\n    \n    beakers_sorted = sorted(beakers, reverse=True)\n    max_beaker = beakers_sorted[0]\n    \n    # Try DFS to see if we can fill all beakers\n    def dfs(filled, current_water):\n        if len(filled) == n:\n            return current_water == 0\n        \n        if current_water == 0:\n            return False\n        \n        # Try to fill each unfilled beaker\n        for i in range(n):\n            if i not in filled:\n                beaker_capacity = beakers_sorted[i]\n                if beaker_capacity <= current_water:\n                    # Fill this beaker\n                    new_filled = filled | {i}\n                    new_water = current_water - beaker_capacity + beaker_capacity\n                    # After filling, we pour out this beaker's water\n                    if dfs(new_filled, new_water):\n                        return True\n        \n        return False\n    \n    # Different approach: simulate the process\n    # Start with largest beaker filled\n    def solve():\n        # Use bitmask DP or backtracking\n        # State: which beakers have been filled\n        from functools import lru_cache\n        \n        @lru_cache(maxsize=None)\n        def can_fill(filled_mask, available_water):\n            if filled_mask == (1 << n) - 1:\n                return available_water == 0\n            \n            if available_water == 0:\n                return False\n            \n            # Try filling each unfilled beaker\n            for i in range(n):\n                if not (filled_mask & (1 << i)):\n                    capacity = beakers_sorted[i]\n                    if capacity <= available_water:\n                        # Fill beaker i\n                        new_mask = filled_mask | (1 << i)\n                        new_water = available_water - capacity + capacity\n                        if can_fill(new_mask, new_water):\n                            return True\n            \n            return False\n        \n        # Start with the largest beaker (index 0) filled\n        initial_mask = 1\n        initial_water = max_beaker\n        return can_fill(initial_mask, initial_water)\n    \n    return solve()\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    beakers = list(map(int, input().split()))\n    \n    if can_fill_all_beakers(beakers):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["def can_fill_all_beakers(beakers): n = len(beakers) if n == 1: return True beakers_sorted = sorted(beakers, reverse=True) max_beaker = beakers_sorted[0] # Try DFS  <= current_water: # Fill this beaker new_filled = filled | {i} new_water = current_water - beaker_capacity + beaker_capacity # After filling, we pour out this  Different approach: simulate the process # Start with largest beaker filled def solve(): # Use bitmask DP or backtracking #  @lru_cache(maxsize=None) def can_fill(filled_mask, available_water): if filled_mask == (1 << n) - 1: return available_water == 0 if available_water == 0: return False # Try filling each unfilled beaker for i in range(n): if not (filled_mask & (1 << i)): capacity = beakers_sorted[i] if capacity <= available_water: # Fill beaker i new_mask = filled_mask | (1 << i) new_water = available_water - capacity + capacity if can_fill(new_mask, new_water): return True return False # Start with the largest beaker (index 0) filled initial_mask = 1 initial_water = max_beaker return can_fill(initial_mask, initial_water) return solve() while True: n = int(input()) if n == 0: break beakers = list(map(int, input().split())) if can_fill_all_beakers(beakers): print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["while True: n = int(input()) if n  beakers.remove(m) beakers.sort() if beakers: beakersum = [beakers[0]] del beakers[0] else: print(\"YES\") continue if sum(beakers) < m: print(\"NO\") continue elif sum(beakers) == m: print(\"YES\") continue for b in beakers: tmp = [bks + b for bks in beakersum if  break if m in beakersum: print(\"YES\") else: print(\"NO\")"], "original_ll": -1.185887336730957, "sampled_ll": -0.9395316243171692, "all_perturbed_sampled_ll": [-1.7239435911178589], "all_perturbed_original_ll": [-2.40458083152771], "perturbed_sampled_ll": -1.7239435911178589, "perturbed_original_ll": -2.40458083152771, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\n#include<stdio.h>\nint main(){\n  char c[9],i;\n  int d[]={0,1,2,3,4,5,6,7,8,0,3,6,1,4,7,2,5,8,0,4,8,2,4,6};\n  while(scanf(\" %c\",&c[0]),c[0]-'0'){\n    for(i=1;i<9;i++){\n      scanf(\" %c\",&c[i]);\n    }\n    for(i=0;i<8;i++){\n      if(c[d[i*3+0]]==c[d[i*3+1]]&&c[d[i*3+1]]==c[d[i*3+2]]&&c[d[i*3+0]]-'+'){\n\tprintf(\"%c\\n\",c[d[i*3]]);\n\tbreak;\n      }\n    }\n      if(i==8)printf(\"NA\\n\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint check_win(char board[3][4], char player) {\n    // Check rows\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {\n            return 1;\n        }\n    }\n    \n    // Check columns\n    for (int j = 0; j < 3; j++) {\n        if (board[0][j] == player && board[1][j] == player && board[2][j] == player) {\n            return 1;\n        }\n    }\n    \n    // Check diagonals\n    if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return 1;\n    }\n    if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return 1;\n    }\n    \n    return 0;\n}\n\nint main() {\n    char board[3][4];\n    \n    while (1) {\n        if (scanf(\"%s\", board[0]) != 1) break;\n        if (board[0][0] == '0') break;\n        \n        scanf(\"%s\", board[1]);\n        scanf(\"%s\", board[2]);\n        \n        if (check_win(board, 'b')) {\n            printf(\"b\\n\");\n        } else if (check_win(board, 'w')) {\n            printf(\"w\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int check_win(char board[3][4], char player) { // Check rows for (int i = <extra_id_1>break; if<extra_id_2>in board[0][1]) { printf(\"A\\n\");<extra_id_3>0;<extra_id_4>if (int<extra_id_5>= [1, 2,<extra_id_6>} } <s><extra_id_7>int return 1; } } // Check columns for (int = 0 ;<extra_id_8>board, 'i'))<extra_id_9>{ printf(\"i\\n\")<extra_id_10>]<extra_id_11>,<extra_id_12>[ 3 ] = 1<extra_id_13>1 ) { do<extra_id_14>[<extra_id_15>( board[0][0] == == player && board[1][j] == player && board[2][j] == player) { return 1; } } // Check diagonals if (board[0][0] == player && board[1][1] == player && board[2][2] == player) { return 1; } if (board[0][2] == player && board[1][1] == player && board[2][0] == player) { return 1;  (1) { if (scanf(\"%s\", board[0]) != 1) break; if (board[0][0] == '0') break; scanf(\"%s\", board[1]); scanf(\"%s\", board[2]); if (check_win(board, 'b')) { printf(\"b\\n\"); } else if (check_win(board, 'w')) { printf(\"w\\n\"); } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ char c[9],i; int d[]={0,1,2,3,4,5,6,7,8,0,3,6,1,4,7,2,5,8,0,4,8,2,4,6}; while(scanf(\" %c\",&c[0]),c[0]-'0'){ for(i=1;i<9;i++){ scanf(\" %c\",&c[i]); } for(i=0;i<8;i++){ if(c[d[i*3+0]]==c[d[i*3+1]]&&c[d[i*3+1]]==c[d[i*3+2]]&&c[d[i*3+0]]-'+'){ printf(\"%c\\n\",c[d[i*3]]); break; } } if(i==8)printf(\"NA\\n\"); } return 0; }"], "original_ll": -1.2036434412002563, "sampled_ll": -0.39143824577331543, "all_perturbed_sampled_ll": [-1.657899022102356], "all_perturbed_original_ll": [-1.2225148677825928], "perturbed_sampled_ll": -1.657899022102356, "perturbed_original_ll": -1.2225148677825928, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[][] board = new char[3][3];\n\t\n\tstatic boolean read() {\n\t\tString line = sc.next();\n\t\tif(line.equals(\"0\")) return false;\n\t\tboard[0][0] = line.charAt(0); board[0][1] = line.charAt(1); board[0][2] = line.charAt(2);\n\t\tfor(int i = 1; i < 3; i++) {\n\t\t\tline = sc.next();\n\t\t\tfor(int j = 0; j < 3; j++) board[i][j] = line.charAt(j);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic String solve() {\n\t\tchar stone;\n\t\tboolean win;\n\t\t\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\twin = true;\n\t\t\tstone = board[i][0];\n\t\t\tfor(int j = 1; j < 3; j++) {\n\t\t\t\tif(stone != board[i][j]) win = false;\n\t\t\t}\n\t\t\tif(win) return \"\" + stone;\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < 3; j++) {\n\t\t\twin = true;\n\t\t\tstone = board[0][j];\n\t\t\tfor(int i = 1; i < 3; i++) {\n\t\t\t\tif(stone != board[i][j]) win = false;\n\t\t\t}\n\t\t\tif(win) return \"\" + stone;\n\t\t}\n\t\t\n\t\tif(board[0][0] == board[1][1] && board[0][0] == board[2][2]) return \"\" + board[0][0];\n\t\t\n\t\tif(board[2][0] == board[1][1]  && board[1][1] == board[0][2]) return \"\" + board[2][0];\n\t\t\n\t\treturn \"NA\";\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String line = sc.nextLine();\n            if (line.equals(\"0\")) {\n                break;\n            }\n            \n            char[][] board = new char[3][3];\n            board[0] = line.toCharArray();\n            board[1] = sc.nextLine().toCharArray();\n            board[2] = sc.nextLine().toCharArray();\n            \n            boolean bWins = checkWin(board, 'b');\n            boolean wWins = checkWin(board, 'w');\n            \n            if (bWins) {\n                System.out.println(\"b\");\n            } else if (wWins) {\n                System.out.println(\"w\");\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean checkWin(char[][] board, char player) {\n        // Check rows\n        for (int i = 0; i < 3; i++) {\n            if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {\n                return true;\n            }\n        }\n        \n        // Check columns\n        for (int j = 0; j < 3; j++) {\n            if (board[0][j] == player && board[1][j] == player && board[2][j] == player) {\n                return true;\n            }\n        }\n        \n        // Check diagonals\n        if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n            return true;\n        }\n        if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  new Scanner(System.in); while (true)  char[][] board = new char[3][3]; board[0] = line.toCharArray(); board[1] = sc.nextLine().toCharArray(); board[2] = sc.nextLine().toCharArray(); boolean bWins = checkWin(board, 'b'); boolean wWins = checkWin(board, 'w'); if (bWins) { System.out.println(\"b\"); } else if (wWins) { System.out.println(\"w\"); } else { System.out.println(\"NA\"); } } sc.close(); } private static boolean checkWin(char[][] board, char player) { // Check rows for (int i = 0; i < 3; i++)  Check columns for (int j = 0; j < 3; j++) { if (board[0][j] == player && board[1][j] == player && board[2][j] == player) { return  && board[1][1] == player && board[2][2] == player) { return true; } if (board[0][2] == player && board[1][1] == player && board[2][0] == player) { return true; } return false; } }"], "perturbed_original": ["import java.util.*; public class Main { static  char[3][3]; static boolean  i = 1; i < 3; i++) { line = sc.next(); for(int j = 0; j < 3; j++) board[i][j] = line.charAt(j); } return  for(int i = 0; i < 3; i++) { win = true; stone =  if(stone != board[i][j]) win = false; } if(win) return \"\" + stone; } for(int j = 0; j < 3; j++) { win = true; stone = board[0][j]; for(int i = 1; i < 3; i++) { if(stone != board[i][j]) win = false; } if(win) return \"\" + stone; } if(board[0][0] == board[1][1] && board[0][0] == board[2][2]) return \"\" + board[0][0]; if(board[2][0] == board[1][1] && board[1][1] == board[0][2]) return \"\" + board[2][0]; return \"NA\"; } public static void main(String[] args) { while(read()) { System.out.println(solve()); } } }"], "original_ll": -0.47139638662338257, "sampled_ll": -0.3035241365432739, "all_perturbed_sampled_ll": [-0.9501314759254456], "all_perturbed_original_ll": [-1.0532958507537842], "perturbed_sampled_ll": -0.9501314759254456, "perturbed_original_ll": -1.0532958507537842, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        f = [list(raw_input()) for _ in xrange(3)]\n    except EOFError:\n        break\n    g = map(lambda x:\"\".join(x),f+zip(*f))\n    print \"b\" if \"b\"*3 in g else \"w\" if \"w\"*3 in g else \"NA\"", "sampled": "import sys\n\ndef check_winner(board):\n    # Check rows\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2] and board[i][0] != '+':\n            return board[i][0]\n    \n    # Check columns\n    for i in range(3):\n        if board[0][i] == board[1][i] == board[2][i] and board[0][i] != '+':\n            return board[0][i]\n    \n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] != '+':\n        return board[0][0]\n    \n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] != '+':\n        return board[0][2]\n    \n    return 'NA'\n\nwhile True:\n    line = input().strip()\n    if line == '0':\n        break\n    \n    board = [line]\n    board.append(input().strip())\n    board.append(input().strip())\n    \n    result = check_winner(board)\n    print(result)\n", "perturbed_sampled": ["import sys def check_winner(board): # Check rows for i in range(3): if board[i][0] == board[i][1] == board[i][2] and board[i][0] != '+': return board[i][0] # Check columns for i in  '+': return board[0][i] # Check diagonals if board[0][0] == board[1][1] == board[2][2] and board[0][0] != '+': return board[0][0] if board[0][2] == board[1][1] ==  True: line = input().strip() if line == '0': break board = [line] board.append(input().strip()) board.append(input().strip()) result = check_winner(board) print(result)"], "perturbed_original": ["while True: try: f = [list(raw_input()) for _ in xrange(3)] except EOFError: break g = map(lambda x:\"\".join(x),f+zip(*f)) print \"b\" if \"b\"*3 in g else \"w\" if \"w\"*3 in g else \"NA\""], "original_ll": -1.9430196285247803, "sampled_ll": -0.38173946738243103, "all_perturbed_sampled_ll": [-1.2097800970077515], "all_perturbed_original_ll": [-2.0871458053588867], "perturbed_sampled_ll": -1.2097800970077515, "perturbed_original_ll": -2.0871458053588867, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n    int age0,age1,age2,age3,age4,age5,age6,n,i,x;\n    while(1){\n        age0=0;age1=0;age2=0;age3=0;age4=0;age5=0;age6=0;\n        scanf(\"%d\",&n);\n        if(n==0)break;\n        for(i=0;i<n;i++){\n            scanf(\"%d\",&x);\n            if(x>=60){\n                age6++;\n            }else if(x>=50){\n                age5++;\n            }else if(x>=40){\n                age4++;\n            }else if(x>=30){\n                age3++;\n            }else if(x>=20){\n                age2++;\n            }else if(x>=10){\n                age1++;\n            }else{\n                age0++;\n            }\n        }\n        printf(\"%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n\",age0,age1,age2,age3,age4,age5,age6);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int count[7] = {0};\n        \n        for(int i = 0; i < n; i++) {\n            int age;\n            scanf(\"%d\", &age);\n            \n            if(age < 10) {\n                count[0]++;\n            } else if(age < 20) {\n                count[1]++;\n            } else if(age < 30) {\n                count[2]++;\n            } else if(age < 40) {\n                count[3]++;\n            } else if(age < 50) {\n                count[4]++;\n            } else if(age < 60) {\n                count[5]++;\n            } else {\n                count[6]++;\n            }\n        }\n        \n        for(int i = 0; i < 7; i++) {\n            printf(\"%d\\n\", count[i]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(scanf(\"%d\", &n) == 1  i = 0; i < n; i++) { int age; scanf(\"%d\", &age); if(age < 10) { count[0]++; }  30) { count[2]++; } else if(age < 40) { count[3]++; } else if(age < 50) { count[4]++; } else if(age < 60) { count[5]++; } else { count[6]++; } } for(int i = 0; i < 7; i++) { printf(\"%d\\n\", count[i]); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int age0,age1,age2,age3,age4,age5,age6,n,i,x; while(1){ age0=0;age1=0;age2=0;age3=0;age4=0;age5=0;age6=0; scanf(\"%d\",&n); if(n==0)break; for(i=0;i<n;i++){ scanf(\"%d\",&x); if(x>=60){ age6++; }else if(x>=50){  }else if(x>=10){ age1++; }else{ age0++; } } printf(\"%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n\",age0,age1,age2,age3,age4,age5,age6); } return 0; }"], "original_ll": -0.388095885515213, "sampled_ll": -0.3377456068992615, "all_perturbed_sampled_ll": [-0.9381905794143677], "all_perturbed_original_ll": [-0.7443060874938965], "perturbed_sampled_ll": -0.9381905794143677, "perturbed_original_ll": -0.7443060874938965, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main\n{\n    public static void main(String args[])\n    {\n\tScanner scan=new Scanner(System.in);\n\twhile(true)\n\t    {\n\t\t\n\t\tint n=scan.nextInt();\n\t\tif(n==0)break;\n\t\tint s[]=new int[7];\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\t\n\t\t\tint old=scan.nextInt();\n\t\t\tint x=old/10;\n\t\t\tif(x>=6)x=6;\n\t\t\ts[x]++;\n\t\t    }\n\t\tfor(int i=0;i<7;i++)\n\t\t    {\n\t\t\tSystem.out.println(s[i]);\n\t\t    }\n\t    }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] counts = new int[7];\n            \n            for (int i = 0; i < n; i++) {\n                int age = sc.nextInt();\n                \n                if (age < 10) {\n                    counts[0]++;\n                } else if (age < 20) {\n                    counts[1]++;\n                } else if (age < 30) {\n                    counts[2]++;\n                } else if (age < 40) {\n                    counts[3]++;\n                } else if (age < 50) {\n                    counts[4]++;\n                } else if (age < 60) {\n                    counts[5]++;\n                } else {\n                    counts[6]++;\n                }\n            }\n            \n            for (int i = 0; i < 7; i++) {\n                System.out.println(counts[i]);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[] counts = new int[7]; for (int i = 0; i < n;  { counts[0]++; } else if (age  { counts[2]++; }  (age < 50) { counts[4]++; } else if (age < 60) { counts[5]++; } else { counts[6]++; } } for (int i = 0; i < 7; i++) { System.out.println(counts[i]); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String  int s[]=new int[7]; for(int i=0;i<n;i++) { int old=scan.nextInt(); int x=old/10; if(x>=6)x=6; s[x]++; } for(int i=0;i<7;i++) { System.out.println(s[i]); } } } }"], "original_ll": -1.1367543935775757, "sampled_ll": -0.2918674051761627, "all_perturbed_sampled_ll": [-0.9596461653709412], "all_perturbed_original_ll": [-1.9081364870071411], "perturbed_sampled_ll": -0.9596461653709412, "perturbed_original_ll": -1.9081364870071411, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\nimport sys\n'import math'\nwhile 1:\n    n=int(input())\n    if n==0: sys.exit()\n    arr=[0]*7\n    while n:\n        a=int(input())\n        if a>60: a=61\n        arr[int(a/10)]+=1\n        n-=1\n    for i in range(len(arr)):\n        print(arr[i])", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    counts = [0] * 7\n    \n    for _ in range(n):\n        age = int(input())\n        if age < 10:\n            counts[0] += 1\n        elif age < 20:\n            counts[1] += 1\n        elif age < 30:\n            counts[2] += 1\n        elif age < 40:\n            counts[3] += 1\n        elif age < 50:\n            counts[4] += 1\n        elif age < 60:\n            counts[5] += 1\n        else:\n            counts[6] += 1\n    \n    for count in counts:\n        print(count)\n", "perturbed_sampled": ["while True: n = int(input()) if n  in range(n): age =  < 20: counts[1] += 1 elif age < 30: counts[2] += 1 elif age < 40: counts[3] += 1 elif age < 50: counts[4] += 1 elif age < 60: counts[5] += 1 else: counts[6] += 1 for count in counts: print(count)"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys 'import math' while 1: n=int(input()) if n==0: sys.exit() arr=[0]*7 while n: a=int(input()) if a>60: a=61 arr[int(a/10)]+=1 n-=1 for i in range(len(arr)): print(arr[i])"], "original_ll": -1.4116450548171997, "sampled_ll": -0.36175739765167236, "all_perturbed_sampled_ll": [-1.1546605825424194], "all_perturbed_original_ll": [-1.8206453323364258], "perturbed_sampled_ll": -1.1546605825424194, "perturbed_original_ll": -1.8206453323364258, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "j,p[1<<20],n;\nmain(i)\n{\n\tfor(;++i<999;)\n\t\tif(!p[i])\n\t\t\tfor(j=i+i;j<1<<20;j+=i)\n\t\t\t\tp[j]=1;\n\tfor(;scanf(\"%d\",&n),j=0,n;printf(\"%d\\n\",j))\n\t\tfor(i=2;i<=n/2;i++)if(!p[i]&!p[n-i])j++;\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX 1000001\n\nint is_prime[MAX];\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int count = 0;\n        for (int p = 2; p <= n / 2; p++) {\n            if (is_prime[p] && is_prime[n - p]) {\n                count++;\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <math.h> #define MAX 1000001 int is_prime[MAX]; void sieve() { memset(is_prime, 1, sizeof(is_prime)); is_prime[0] = is_prime[1] = 0; for (int i  j < MAX; j += i) { is_prime[j] = 0; } } } } int main() { sieve(); int  { int count = 0; for (int p = 2; p <= n / 2; p++) { if (is_prime[p] && is_prime[n - p]) { count++; } } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["j,p[1<<20],n; main(i) { for(;++i<999;) if(!p[i]) for(j=i+i;j<1<<20;j+=i) p[j]=1; for(;scanf(\"%d\",&n),j=0,n;printf(\"%d\\n\",j)) for(i=2;i<=n/2;i++)if(!p[i]&!p[n-i])j++; return 0; }"], "original_ll": -2.147275686264038, "sampled_ll": -0.38091033697128296, "all_perturbed_sampled_ll": [-1.062546730041504], "all_perturbed_original_ll": [-2.2592594623565674], "perturbed_sampled_ll": -1.062546730041504, "perturbed_original_ll": -2.2592594623565674, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static boolean[] prime = new boolean[1000001];\n    static int n;\n    public static void main(String[] args) {\n        makePrime();\n        while(read()){\n            solve();\n        }\n\n    }\n\n    static void makePrime(){\n        Arrays.fill(prime, true);\n        prime[0] = false;\n        prime[1] = false;\n        for(int i = 2; i < prime.length; i++){\n            if(prime[i]){\n                for(int j = i*2; j < prime.length; j += i)prime[j] = false;\n            }\n        }\n    }\n\n    static boolean read(){\n        n = sc.nextInt();\n        if( n == 0 )return false;\n        return true;\n    }\n\n    static void solve(){\n        int res = 0;\n        for(int i = 2; i <= n/2; i++){\n            if(prime[n - i] && prime[i])res++;\n        }\n        System.out.println(res);\n    }\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static boolean[] sieve;\n    static int MAX = 1000001;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Sieve of Eratosthenes\n        sieve = new boolean[MAX];\n        Arrays.fill(sieve, true);\n        sieve[0] = sieve[1] = false;\n        \n        for (int i = 2; i * i < MAX; i++) {\n            if (sieve[i]) {\n                for (int j = i * i; j < MAX; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            for (int p = 2; p <= n / 2; p++) {\n                if (sieve[p] && sieve[n - p]) {\n                    count++;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  1000001; public static void main(String[] args) { Scanner sc = new Scanner(System.in); // Sieve of Eratosthenes sieve = new boolean[MAX]; Arrays.fill(sieve, true); sieve[0] = sieve[1] = false; for (int i = 2;  for (int j = i * i; j < MAX; j += i) { sieve[j] = false; } } } while (true) { int n = sc.nextInt(); if (n == 0) break; int count = 0; for (int p = 2; p <= n / 2; p++)  } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { static Scanner sc = new Scanner(System.in); static boolean[] prime = new boolean[1000001]; static int n; public static void main(String[]  Arrays.fill(prime, true); prime[0] = false; prime[1] =  for(int j = i*2; j < prime.length; j += i)prime[j] = false; } } } static boolean  return true; } static void solve(){ int res = 0; for(int i = 2; i <= n/2; i++){ if(prime[n - i] && prime[i])res++; } System.out.println(res); } }"], "original_ll": -0.6519679427146912, "sampled_ll": -0.40889692306518555, "all_perturbed_sampled_ll": [-1.1521639823913574], "all_perturbed_original_ll": [-1.5550029277801514], "perturbed_sampled_ll": -1.1521639823913574, "perturbed_original_ll": -1.5550029277801514, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import compress\nMAXN = 1000001\np = [True]*MAXN\np[0] = p[1] = False\nfor i in xrange(int(MAXN**0.5)+1):\n    if p[i]:\n        for j in xrange(i+i,MAXN,i):\n            p[j] = False\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    print sum(1 for i in compress(xrange(n/2+1),p) if p[n-i])", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\n# Precompute primes up to 1000000\nMAX_N = 1000000\nis_prime = sieve_of_eratosthenes(MAX_N)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = 0\n    for p in range(2, n // 2 + 1):\n        if is_prime[p]:\n            q = n - p\n            if is_prime[q]:\n                count += 1\n    \n    print(count)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(limit**0.5) + 1): if is_prime[i]: for j in range(i*i, limit + 1, i): is_prime[j] =  int(input()) if n == 0: break count = 0 for p in range(2, n // 2 + 1): if is_prime[p]: q = n - p if is_prime[q]: count += 1 print(count)"], "perturbed_original": ["from itertools import compress MAXN = 1000001 p = [True]*MAXN p[0] = p[1] = False for i in xrange(int(MAXN**0.5)+1): if  n = input() if n == 0: break print sum(1 for i in compress(xrange(n/2+1),p) if p[n-i])"], "original_ll": -1.1149413585662842, "sampled_ll": -0.5556136965751648, "all_perturbed_sampled_ll": [-0.9918375611305237], "all_perturbed_original_ll": [-1.9192252159118652], "perturbed_sampled_ll": -0.9918375611305237, "perturbed_original_ll": -1.9192252159118652, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint cross(int x1,int y1,int x2,int y2,\n\t\tint x3,int y3,int x4,int y4) {\n\tlong long b12x,b12y,b34x,b34y;\n\tlong long b24x,b24y;\n\tlong long b13x,b13y,b14x,b14y,b32x,b32y;\n\tlong long g1213,g1214,g3431,g3432;\n\tlong long n1213,n1214,n3431,n3432;\n\tlong long n2123,n2124,n4341,n4342;\n\n\tb12x=x2-x1;b12y=y2-y1;\n\tb34x=x4-x3;b34y=y4-y3;\n\tb13x=x3-x1;b13y=y3-y1;\n\tb14x=x4-x1;b14y=y4-y1;\n\tb32x=x2-x3;b32y=y2-y3;\n\tb24x=x4-x2;b24y=y4-y2;\n\n\tg1213=b12x*b13y-b13x*b12y;\n\tg1214=b12x*b14y-b14x*b12y;\n\tg3431=b34x*(-b13y)-(-b13x)*b34y;\n\tg3432=b34x*b32y-b32x*b34y;\n\n\tn1213=b12x*b13x+b12y*b13y;\n\tn1214=b12x*b14x+b12y*b14y;\n\tn3431=b34x*(-b13x)+b34y*(-b13y);\n\tn3432=b34x*b32x+b34y*b32y;\n\tn2123=(-b12x)*(-b32x)+(-b12y)*(-b32y);\n\tn2124=(-b12x)*b24x+(-b12y)*b24y;\n\tn4341=(-b34x)*(-b14x)+(-b34y)*(-b14y);\n\tn4342=(-b34x)*(-b24x)+(-b34y)*(-b24y);\n\n\tif(\n\t\t((g1213<0 && g1214>0) || (g1213>0 && g1214<0)) &&\n\t\t((g3431<0 && g3432>0) || (g3431>0 && g3432<0))\n\t) return 1;\n\tif(\n\t\t(g1213==0 && n1213>=0 && n2123>=0) ||\n\t\t(g1214==0 && n1214>=0 && n2124>=0) ||\n\t\t(g3431==0 && n3431>=0 && n4341>=0) ||\n\t\t(g3432==0 && n3432>=0 && n4342>=0)\n\t) return 1;\n\n\treturn 0;\n}\n\n/*\na1x+b1y=c1\na2x+b2y=c2\n*/\nint solve_houteisiki(double* x,double* y,\n\t\tint a1,int b1,int c1,\n\t\tint a2,int b2,int c2) {\n\tint d;\n\td=a1*b2-b1*a2;\n\tif(d==0)return 0;\n\t*x=(double)(b2*c1-b1*c2)/d;\n\t*y=(double)(-a2*c1+a1*c2)/d;\n\treturn 1;\n}\n\nint main(void) {\n\tint x[6],y[6];\n\tint no_triangle;\n\tint x1,y1,t1,x2,y2,t2,x3,y3,t3;\n\tdouble tx1,ty1,tx2,ty2,tx3,ty3;\n\tdouble s;\n\twhile(1) {\n\t\tscanf(\"%d%d%d%d\",&x[0],&y[0],&x[1],&y[1]);\n\t\tif((x[0]|y[0]|x[1]|y[1])==0)break;\n\t\tscanf(\"%d%d%d%d\",&x[2],&y[2],&x[3],&y[3]);\n\t\tscanf(\"%d%d%d%d\",&x[4],&y[4],&x[5],&y[5]);\n\t\tno_triangle=0;\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[0],y[0],x[1],y[1],x[2],y[2],x[3],y[3]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[2],y[2],x[3],y[3],x[4],y[4],x[5],y[5]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[4],y[4],x[5],y[5],x[0],y[0],x[1],y[1]);\n\t\tif(!no_triangle) {\n\t\t\tx1=y[1]-y[0];\n\t\t\ty1=-(x[1]-x[0]);\n\t\t\tt1=x[0]*(y[1]-y[0])-y[0]*(x[1]-x[0]);\n\t\t\tx2=y[3]-y[2];\n\t\t\ty2=-(x[3]-x[2]);\n\t\t\tt2=x[2]*(y[3]-y[2])-y[2]*(x[3]-x[2]);\n\t\t\tx3=y[5]-y[4];\n\t\t\ty3=-(x[5]-x[4]);\n\t\t\tt3=x[4]*(y[5]-y[4])-y[4]*(x[5]-x[4]);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx1,&ty1,\n\t\t\t\t\tx1,y1,t1,x2,y2,t2);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx2,&ty2,\n\t\t\t\t\tx2,y2,t2,x3,y3,t3);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx3,&ty3,\n\t\t\t\t\tx3,y3,t3,x1,y1,t1);\n\t\t}\n\t\tif(!no_triangle) {\n\t\t\ts=((tx2-tx1)*(ty3-ty1)-(tx3-tx1)*(ty2-ty1))/2;\n\t\t\tif(s<0)s=-s;\n\t\t\tif(s<1e-8)puts(\"kyo\");\n\t\t\telse if(s<100000+1e-8)puts(\"syo-kichi\");\n\t\t\telse if(s<1000000+1e-8)puts(\"kichi\");\n\t\t\telse if(s<1900000+1e-8)puts(\"chu-kichi\");\n\t\t\telse puts(\"dai-kichi\");\n\t\t} else puts(\"kyo\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point p1, p2;\n} Line;\n\nint getIntersection(Line l1, Line l2, Point *result) {\n    double x1 = l1.p1.x, y1 = l1.p1.y;\n    double x2 = l1.p2.x, y2 = l1.p2.y;\n    double x3 = l2.p1.x, y3 = l2.p1.y;\n    double x4 = l2.p2.x, y4 = l2.p2.y;\n    \n    double denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    \n    if (fabs(denom) < 1e-9) {\n        return 0;\n    }\n    \n    double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    \n    result->x = x1 + t * (x2 - x1);\n    result->y = y1 + t * (y2 - y1);\n    \n    return 1;\n}\n\ndouble triangleArea(Point p1, Point p2, Point p3) {\n    return fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0);\n}\n\nint areCollinear(Point p1, Point p2, Point p3) {\n    double area = fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)));\n    return area < 1e-6;\n}\n\nint main() {\n    Line lines[3];\n    \n    while (1) {\n        scanf(\"%lf %lf %lf %lf\", &lines[0].p1.x, &lines[0].p1.y, &lines[0].p2.x, &lines[0].p2.y);\n        \n        if (lines[0].p1.x == 0 && lines[0].p1.y == 0 && lines[0].p2.x == 0 && lines[0].p2.y == 0) {\n            break;\n        }\n        \n        scanf(\"%lf %lf %lf %lf\", &lines[1].p1.x, &lines[1].p1.y, &lines[1].p2.x, &lines[1].p2.y);\n        scanf(\"%lf %lf %lf %lf\", &lines[2].p1.x, &lines[2].p1.y, &lines[2].p2.x, &lines[2].p2.y);\n        \n        Point intersections[3];\n        \n        if (!getIntersection(lines[0], lines[1], &intersections[0]) ||\n            !getIntersection(lines[1], lines[2], &intersections[1]) ||\n            !getIntersection(lines[2], lines[0], &intersections[2])) {\n            printf(\"kyo\\n\");\n            continue;\n        }\n        \n        if (areCollinear(intersections[0], intersections[1], intersections[2])) {\n            printf(\"kyo\\n\");\n            continue;\n        }\n        \n        double area = triangleArea(intersections[0], intersections[1], intersections[2]);\n        \n        if (area < 1e-6) {\n            printf(\"kyo\\n\");\n        } else if (area >= 1900000) {\n            printf(\"dai-kichi\\n\");\n        } else if (area >= 1000000) {\n            printf(\"chu-kichi\\n\");\n        } else if (area >= 100000) {\n            printf(\"kichi\\n\");\n        } else {\n            printf(\"syo-kichi\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> typedef struct {  p2; } Line; int getIntersection(Line l1, Line l2, Point *result) { double x1 = l1.p1.x, y1 = l1.p1.y; double x2 = l1.p2.x, y2 = l1.p2.y;  l2.p2.x, y4 = l2.p2.y; double denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4); if (fabs(denom) < 1e-9) { return 0; } double t = ((x1 - x3) * (y3 - y4) -  = x1 + t * (x2 - x1); result->y = y1 + t * (y2 - y1); return 1; } double  (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0); } int areCollinear(Point p1, Point p2, Point p3) { double area = fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y)  } int main() { Line lines[3]; while (1) { scanf(\"%lf  && lines[0].p2.y == 0)  &lines[1].p2.y); scanf(\"%lf %lf %lf %lf\", &lines[2].p1.x, &lines[2].p1.y, &lines[2].p2.x, &lines[2].p2.y); Point intersections[3]; if (!getIntersection(lines[0], lines[1], &intersections[0]) || !getIntersection(lines[1], lines[2], &intersections[1]) || !getIntersection(lines[2], lines[0], &intersections[2])) { printf(\"kyo\\n\"); continue; } if (areCollinear(intersections[0], intersections[1], intersections[2])) { printf(\"kyo\\n\"); continue; } double area = triangleArea(intersections[0], intersections[1], intersections[2]); if (area < 1e-6) { printf(\"kyo\\n\"); } else if  1000000) { printf(\"chu-kichi\\n\"); } else if (area >= 100000) { printf(\"kichi\\n\"); } else { printf(\"syo-kichi\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h>  y4) { long long b12x,b12y,b34x,b34y; long long b24x,b24y; long long b13x,b13y,b14x,b14y,b32x,b32y; long long  b14x=x4-x1;b14y=y4-y1; b32x=x2-x3;b32y=y2-y3; b24x=x4-x2;b24y=y4-y2; g1213=b12x*b13y-b13x*b12y; g1214=b12x*b14y-b14x*b12y; g3431=b34x*(-b13y)-(-b13x)*b34y; g3432=b34x*b32y-b32x*b34y; n1213=b12x*b13x+b12y*b13y; n1214=b12x*b14x+b12y*b14y; n3431=b34x*(-b13x)+b34y*(-b13y); n3432=b34x*b32x+b34y*b32y; n2123=(-b12x)*(-b32x)+(-b12y)*(-b32y); n2124=(-b12x)*b24x+(-b12y)*b24y; n4341=(-b34x)*(-b14x)+(-b34y)*(-b14y); n4342=(-b34x)*(-b24x)+(-b34y)*(-b24y); if( ((g1213<0 && g1214>0) || (g1213>0 && g1214<0)) && ((g3431<0 && g3432>0) || (g3431>0  n2123>=0) || (g1214==0 && n1214>=0 && n2124>=0) || (g3431==0 && n3431>=0 && n4341>=0) || (g3432==0 && n3432>=0 &&  */ int solve_houteisiki(double* x,double* y, int a1,int b1,int c1, int a2,int b2,int c2) { int d; d=a1*b2-b1*a2; if(d==0)return 0; *x=(double)(b2*c1-b1*c2)/d; *y=(double)(-a2*c1+a1*c2)/d; return 1; } int main(void) { int x[6],y[6]; int no_triangle; int x1,y1,t1,x2,y2,t2,x3,y3,t3; double tx1,ty1,tx2,ty2,tx3,ty3; double s; while(1) { scanf(\"%d%d%d%d\",&x[0],&y[0],&x[1],&y[1]); if((x[0]|y[0]|x[1]|y[1])==0)break; scanf(\"%d%d%d%d\",&x[2],&y[2],&x[3],&y[3]); scanf(\"%d%d%d%d\",&x[4],&y[4],&x[5],&y[5]); no_triangle=0; no_triangle=no_triangle || !cross(x[0],y[0],x[1],y[1],x[2],y[2],x[3],y[3]); no_triangle=no_triangle || !cross(x[2],y[2],x[3],y[3],x[4],y[4],x[5],y[5]); no_triangle=no_triangle || !cross(x[4],y[4],x[5],y[5],x[0],y[0],x[1],y[1]); if(!no_triangle) { x1=y[1]-y[0]; y1=-(x[1]-x[0]); t1=x[0]*(y[1]-y[0])-y[0]*(x[1]-x[0]); x2=y[3]-y[2]; y2=-(x[3]-x[2]); t2=x[2]*(y[3]-y[2])-y[2]*(x[3]-x[2]); x3=y[5]-y[4]; y3=-(x[5]-x[4]); t3=x[4]*(y[5]-y[4])-y[4]*(x[5]-x[4]); no_triangle=no_triangle || !solve_houteisiki(&tx1,&ty1, x1,y1,t1,x2,y2,t2);  { s=((tx2-tx1)*(ty3-ty1)-(tx3-tx1)*(ty2-ty1))/2; if(s<0)s=-s; if(s<1e-8)puts(\"kyo\"); else if(s<100000+1e-8)puts(\"syo-kichi\"); else if(s<1000000+1e-8)puts(\"kichi\"); else if(s<1900000+1e-8)puts(\"chu-kichi\"); else puts(\"dai-kichi\"); } else puts(\"kyo\"); } return 0; }"], "original_ll": -0.5591878294944763, "sampled_ll": -0.3571866452693939, "all_perturbed_sampled_ll": [-1.0426132678985596], "all_perturbed_original_ll": [-0.8345053791999817], "perturbed_sampled_ll": -1.0426132678985596, "perturbed_original_ll": -0.8345053791999817, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=1e-4;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    static class Line {\n        Point p1, p2;\n        Line(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n    \n    static final double EPS = 1e-9;\n    \n    static Point getIntersection(Line l1, Line l2) {\n        double x1 = l1.p1.x, y1 = l1.p1.y;\n        double x2 = l1.p2.x, y2 = l1.p2.y;\n        double x3 = l2.p1.x, y3 = l2.p1.y;\n        double x4 = l2.p2.x, y4 = l2.p2.y;\n        \n        double denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        \n        if (Math.abs(denom) < EPS) {\n            return null; // parallel or coincident\n        }\n        \n        double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n        \n        double px = x1 + t * (x2 - x1);\n        double py = y1 + t * (y2 - y1);\n        \n        return new Point(px, py);\n    }\n    \n    static boolean isParallel(Line l1, Line l2) {\n        double dx1 = l1.p2.x - l1.p1.x;\n        double dy1 = l1.p2.y - l1.p1.y;\n        double dx2 = l2.p2.x - l2.p1.x;\n        double dy2 = l2.p2.y - l2.p1.y;\n        \n        return Math.abs(dx1 * dy2 - dy1 * dx2) < EPS;\n    }\n    \n    static double triangleArea(Point p1, Point p2, Point p3) {\n        return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)) / 2.0;\n    }\n    \n    static boolean areCollinear(Point p1, Point p2, Point p3) {\n        return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)) < EPS;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while (true) {\n            line = br.readLine();\n            String[] parts = line.split(\" \");\n            int x1 = Integer.parseInt(parts[0]);\n            int y1 = Integer.parseInt(parts[1]);\n            int x2 = Integer.parseInt(parts[2]);\n            int y2 = Integer.parseInt(parts[3]);\n            \n            if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;\n            \n            Line l1 = new Line(new Point(x1, y1), new Point(x2, y2));\n            \n            line = br.readLine();\n            parts = line.split(\" \");\n            x1 = Integer.parseInt(parts[0]);\n            y1 = Integer.parseInt(parts[1]);\n            x2 = Integer.parseInt(parts[2]);\n            y2 = Integer.parseInt(parts[3]);\n            Line l2 = new Line(new Point(x1, y1), new Point(x2, y2));\n            \n            line = br.readLine();\n            parts = line.split(\" \");\n            x1 = Integer.parseInt(parts[0]);\n            y1 = Integer.parseInt(parts[1]);\n            x2 = Integer.parseInt(parts[2]);\n            y2 = Integer.parseInt(parts[3]);\n            Line l3 = new Line(new Point(x1, y1), new Point(x2, y2));\n            \n            Point p12 = getIntersection(l1, l2);\n            Point p13 = getIntersection(l1, l3);\n            Point p23 = getIntersection(l2, l3);\n            \n            if (p12 == null || p13 == null || p23 == null) {\n                System.out.println(\"kyo\");\n                continue;\n            }\n            \n            if (areCollinear(p12, p13, p23)) {\n                System.out.println(\"kyo\");\n                continue;\n            }\n            \n            double area = triangleArea(p12, p13, p23);\n            \n            if (area < EPS) {\n                System.out.println(\"kyo\");\n            } else if (area < 100000) {\n                System.out.println(\"syo-kichi\");\n            } else if (area < 1000000) {\n                System.out.println(\"kichi\");\n            } else if (area < 1900000) {\n                System.out.println(\"chu-kichi\");\n            } else {\n                System.out.println(\"dai-kichi\");\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class  x, double y) { this.x = x; this.y = y; } } static class Line { Point p1, p2; Line(Point p1, Point p2) { this.p1 = p1; this.p2 = p2; } } static final double EPS = 1e-9; static Point getIntersection(Line l1, Line l2) { double x1 = l1.p1.x, y1 = l1.p1.y; double   y4) - (y1 - y2) * (x3 - x4); if (Math.abs(denom) < EPS) { return null; // parallel or coincident } double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom; double px = x1 + t * (x2 - x1); double py = y1 + t * (y2  l1, Line l2) { double dx1 = l1.p2.x - l1.p1.x; double dy1 = l1.p2.y - l1.p1.y; double dx2 = l2.p2.x - l2.p1.x; double dy2 = l2.p2.y - l2.p1.y; return Math.abs(dx1 * dy2 - dy1  p2, Point p3) { return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)) /  { return Math.abs((p2.x - p1.x) * (p3.y - p1.y) -  public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while (true) { line  Integer.parseInt(parts[0]); int y1 = Integer.parseInt(parts[1]); int  0 && y1 == 0 && x2 == 0 && y2 == 0)  y2)); line = br.readLine(); parts = line.split(\" \"); x1 = Integer.parseInt(parts[0]); y1 = Integer.parseInt(parts[1]); x2 = Integer.parseInt(parts[2]); y2 = Integer.parseInt(parts[3]);  line = br.readLine(); parts = line.split(\" \"); x1 = Integer.parseInt(parts[0]); y1 = Integer.parseInt(parts[1]); x2 = Integer.parseInt(parts[2]); y2 = Integer.parseInt(parts[3]); Line l3 = new Line(new Point(x1, y1), new Point(x2, y2)); Point p12 = getIntersection(l1, l2); Point p13 = getIntersection(l1, l3); Point p23 = getIntersection(l2, l3); if (p12  { System.out.println(\"kyo\"); continue; } if (areCollinear(p12, p13, p23)) { System.out.println(\"kyo\"); continue; } double area = triangleArea(p12,  if (area < 100000) { System.out.println(\"syo-kichi\"); } else if (area < 1000000) { System.out.println(\"kichi\"); } else if (area < 1900000) { System.out.println(\"chu-kichi\"); } else { System.out.println(\"dai-kichi\"); } } } }"], "perturbed_original": ["import java.util.*; public class Main { static double EPS=1e-4; public static void main(String[] args) { Scanner in=new Scanner(System.in); for(;;) { Point p1=new Point(in.nextDouble(), in.nextDouble()); Point p2=new Point(in.nextDouble(), in.nextDouble()); if(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0) return; Point p3=new Point(in.nextDouble(), in.nextDouble()); Point p4=new Point(in.nextDouble(), in.nextDouble()); Point p5=new Point(in.nextDouble(), in.nextDouble()); Point p6=new Point(in.nextDouble(), in.nextDouble()); boolean judge=true; if(!lineCross(p1, p2, p3, p4)) judge=false; if(!lineCross(p3, p4, p5, p6)) judge=false;  x1=p3.x; double y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y; if(a1==-1.123) y1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y; a1=slanting(p3, p4); a2=slanting(p5, p6); double  a1=slanting(p5, p6); a2=slanting(p1, p2); double x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2); if(a1==-1.123) x3=p5.x; else if(a2==-1.123) x3=p1.x; double y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y; if(a1==-1.123) y3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y; double a=x2-x1; double b=y2-y1; double c=x3-x1; double d=y3-y1; double S=Math.abs(a*d-b*c)/2; if(S<EPS) System.out.println(\"kyo\"); else if(S<100000)  else System.out.println(\"kyo\"); } } static boolean lineCross(Point p1,Point p2,Point p3,Point p4) { double jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);  } static double slanting(Point p1,Point p2) { if(Math.abs(p1.x-p2.x)<EPS) return -1.123; else return (p1.y-p2.y)/(p1.x-p2.x); } } class Point { double x; double y; Point(double x,double y) { this.x=x; this.y=y; } }"], "original_ll": -0.5582008957862854, "sampled_ll": -0.30411916971206665, "all_perturbed_sampled_ll": [-0.9729680418968201], "all_perturbed_original_ll": [-0.87794429063797], "perturbed_sampled_ll": -0.9729680418968201, "perturbed_original_ll": -0.87794429063797, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def cross3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)\ndef outer(x0, y0, x1, y1):\n    return x0*y1 - x1*y0\ndef is_intersection(P0, P1, Q0, Q1):\n    C0 = cross3(P0, P1, Q0)\n    C1 = cross3(P0, P1, Q1)\n    D0 = cross3(Q0, Q1, P0)\n    D1 = cross3(Q0, Q1, P1)\n    if C0 == C1 == 0:\n        return 0\n    return C0 * C1 <= 0 and D0 * D1 <= 0\ndef cross_point(P0, Q0, P1, Q1):\n    x0, y0 = P0; x1, y1 = Q0\n    x2, y2 = P1; x3, y3 = Q1\n    dx0 = x1 - x0\n    dy0 = y1 - y0\n    dx1 = x3 - x2\n    dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if s < 0:\n        s = -s\n        sm = -sm\n    if s == 0:\n        x = x0\n        y = y0\n    else:\n        x = x0 + s*dx0/sm\n        y = y0 + s*dy0/sm\n    return x, y\nwhile 1:\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == y1 == x2 == y2 == 0:\n        break\n    P1 = (x1, y1); Q1 = (x2, y2)\n    x3, y3, x4, y4 = map(int, input().split())\n    P2 = (x3, y3); Q2 = (x4, y4)\n    x5, y5, x6, y6 = map(int, input().split())\n    P3 = (x5, y5); Q3 = (x6, y6)\n    if (not is_intersection(P1, Q1, P2, Q2)\n            or not is_intersection(P2, Q2, P3, Q3)\n            or not is_intersection(P3, Q3, P1, Q1)):\n        print(\"kyo\")\n        continue\n    p1, q1 = cross_point(P1, Q1, P2, Q2)\n    p2, q2 = cross_point(P2, Q2, P3, Q3)\n    p3, q3 = cross_point(P3, Q3, P1, Q1)\n    S = abs(outer(p2-p1, q2-q1, p3-p1, q3-q1)) / 2.\n    if S < 1e-9:\n        print(\"kyo\")\n    elif S < 100000:\n        print(\"syo-kichi\")\n    elif S < 1000000:\n        print(\"kichi\")\n    elif S < 1900000:\n        print(\"chu-kichi\")\n    else:\n        print(\"dai-kichi\")\n", "sampled": "import sys\nfrom math import isclose\n\ndef line_intersection(x1, y1, x2, y2, x3, y3, x4, y4):\n    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if abs(denom) < 1e-9:\n        return None\n    \n    t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom\n    u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom\n    \n    px = x1 + t * (x2 - x1)\n    py = y1 + t * (y2 - y1)\n    \n    return (px, py)\n\ndef triangle_area(p1, p2, p3):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)\n    return area\n\ndef are_collinear(p1, p2, p3):\n    if p1 is None or p2 is None or p3 is None:\n        return True\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    return area < 1e-6\n\ndef solve(lines):\n    # Get intersection points\n    p1 = line_intersection(*lines[0], *lines[1])\n    p2 = line_intersection(*lines[0], *lines[2])\n    p3 = line_intersection(*lines[1], *lines[2])\n    \n    if p1 is None or p2 is None or p3 is None:\n        return \"kyo\"\n    \n    if are_collinear(p1, p2, p3):\n        return \"kyo\"\n    \n    area = triangle_area(p1, p2, p3)\n    \n    if area < 1e-9:\n        return \"kyo\"\n    elif area < 100000:\n        return \"syo-kichi\"\n    elif area < 1000000:\n        return \"kichi\"\n    elif area < 1900000:\n        return \"chu-kichi\"\n    else:\n        return \"dai-kichi\"\n\nwhile True:\n    line = input().split()\n    if line == ['0', '0', '0', '0']:\n        break\n    \n    lines = []\n    lines.append([int(x) for x in line])\n    for _ in range(2):\n        lines.append([int(x) for x in input().split()])\n    \n    result = solve(lines)\n    print(result)\n", "perturbed_sampled": ["import sys from math import isclose  = (x1 - x2) * (y3 - y4) - (y1 - y2)  t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom px = x1 + t * (x2 - x1) py = y1 + t * (y2 - y1) return (px, py) def triangle_area(p1, p2, p3): x1,  p3 area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0) return area def are_collinear(p1, p2, p3):  is None: return True x1, y1 = p1 x2, y2 =  - y3) + x2 *  area < 1e-6 def solve(lines): # Get intersection points p1 = line_intersection(*lines[0], *lines[1]) p2 = line_intersection(*lines[0], *lines[2]) p3 = line_intersection(*lines[1], *lines[2]) if p1 is None or p2 is None or p3 is None: return \"kyo\" if are_collinear(p1, p2, p3): return \"kyo\" area = triangle_area(p1, p2, p3) if area < 1e-9: return  else: return \"dai-kichi\" while True: line = input().split() if line == ['0', '0', '0', '0']: break lines = [] lines.append([int(x) for x in line]) for _ in range(2): lines.append([int(x) for x in input().split()]) result = solve(lines) print(result)"], "perturbed_original": ["def cross3(O, A, B): ox, oy = O; ax, ay = A; bx, by = B return (ax - ox) * (by - oy) -  x1, y1): return x0*y1 - x1*y0 def is_intersection(P0, P1, Q0, Q1): C0 = cross3(P0,  Q1, P0) D1 = cross3(Q0, Q1, P1) if C0 == C1 == 0: return 0 return C0 * C1  Q0, P1, Q1): x0, y0 = P0; x1, y1 = Q0 x2, y2 = P1; x3, y3 = Q1 dx0  = x3 - x2 dy1 = y3 - y2 s = (y0-y2)*dx1 -  s = -s sm = -sm if s == 0: x = x0 y = y0 else: x = x0 + s*dx0/sm y = y0 + s*dy0/sm return x, y while 1: x1, y1, x2, y2 = map(int, input().split()) if x1 == y1 == x2 == y2 == 0: break P1 = (x1, y1); Q1 = (x2, y2) x3, y3, x4, y4 = map(int, input().split()) P2 = (x3, y3); Q2  P3, Q3) or not is_intersection(P3, Q3, P1, Q1)): print(\"kyo\") continue p1, q1 = cross_point(P1, Q1, P2, Q2) p2, q2 = cross_point(P2, Q2, P3, Q3) p3, q3 = cross_point(P3, Q3, P1, Q1) S = abs(outer(p2-p1, q2-q1, p3-p1, q3-q1)) / 2. if S < 1e-9: print(\"kyo\")  elif S < 1900000: print(\"chu-kichi\") else: print(\"dai-kichi\")"], "original_ll": -0.656896710395813, "sampled_ll": -0.5668662190437317, "all_perturbed_sampled_ll": [-1.2365344762802124], "all_perturbed_original_ll": [-1.4249475002288818], "perturbed_sampled_ll": -1.2365344762802124, "perturbed_original_ll": -1.4249475002288818, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#define _CRT_SECURE_NO_WARNINGS\n//#define _USE_MATH_DEFINES\n#include<stdio.h>\n//#include<stdlib.h>\n//#include<math.h>\n//#include<string.h>\n#define P(type,x) fprintf(stdout,\"%\"#type\"\\n\",x)\nint main() {\n\tint n, l, m, r, A[100] = {}, i,key,cnt;\n\twhile (~fscanf(stdin, \"%d\", &n), n) {\n\t\tl = cnt = 0, r = n - 1;\n\t\tfor (i = 0; i < n; i++) fscanf(stdin, \"%d\", &A[i]);\n\t\tfscanf(stdin, \"%d\", &key);\n\t\twhile (l <= r) {\n\t\t\tm = (l + r) / 2;\n\t\t\tcnt++;\n\t\t\tif (A[m] > key) r = m-1;\n\t\t\telse if (A[m] < key) l = m+1;\n\t\t\telse break;\n\t\t}\n\t\tP(d, cnt);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint binarySearch(int arr[], int n, int target) {\n    int left = 0;\n    int right = n - 1;\n    int count = 0;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        count++;\n        \n        if (arr[mid] == target) {\n            return count;\n        } else if (target < arr[mid]) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int arr[100];\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &arr[i]);\n        }\n        \n        int k;\n        scanf(\"%d\", &k);\n        \n        int result = binarySearch(arr, n, k);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int binarySearch(int arr[], int n, int target) { int left = 0; int right = n - 1; int  = (left + right)  mid - 1; } else { left = mid + 1; } } return count; } int main() { int n; while (scanf(\"%d\", &n) == 1 && n != 0) { int arr[100]; for (int i = 0; i < n; i++) { scanf(\"%d\", &arr[i]); } int k; scanf(\"%d\", &k); int result = binarySearch(arr, n, k); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#define _CRT_SECURE_NO_WARNINGS //#define _USE_MATH_DEFINES #include<stdio.h> //#include<stdlib.h> //#include<math.h> //#include<string.h> #define P(type,x) fprintf(stdout,\"%\"#type\"\\n\",x) int main() { int n, l, m, r, A[100] = {}, i,key,cnt; while (~fscanf(stdin, \"%d\", &n), n) { l = cnt = 0, r = n - 1; for (i = 0; i < n; i++) fscanf(stdin, \"%d\", &A[i]); fscanf(stdin, \"%d\", &key); while (l <= r) { m = (l + r) / 2; cnt++; if (A[m] > key)  }"], "original_ll": -1.1881662607192993, "sampled_ll": -0.4395429790019989, "all_perturbed_sampled_ll": [-0.9757992625236511], "all_perturbed_original_ll": [-1.5084680318832397], "perturbed_sampled_ll": -0.9757992625236511, "perturbed_original_ll": -1.5084680318832397, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n    Main(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(sc.hasNext()){\n\t    int r = sc.nextInt(), t, cnt=1, l=0;\n\t    if(r == 0) break;\n\t    int[] ary = new int[r+1];\n\t    \n\t    for(int i = 0; i < r; i++)\n\t\tary[i] = sc.nextInt();\n\t    t = sc.nextInt();\n\t    r--;\n\n\t    while(l <= r){\n\t\tint v = (l+r)/2;\n\n\t\tif(ary[v] == t || l >= r) break;\n\t\telse if(ary[v] < t) l = v+1;\n\t\telse r = v-1;\n\n\t\tcnt++;\n\t    }\n\n\t    System.out.println(Integer.toString(cnt));\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main();\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = sc.nextInt();\n            }\n            \n            int k = sc.nextInt();\n            \n            int count = 0;\n            int left = 0;\n            int right = n - 1;\n            \n            while (left <= right) {\n                int mid = (left + right) / 2;\n                count++;\n                \n                if (arr[mid] == k) {\n                    break;\n                } else if (k < arr[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[] arr = new int[n]; for (int i = 0; i < n; i++) { arr[i] = sc.nextInt(); } int k = sc.nextInt(); int count = 0; int left = 0; int right = n  (left + right) / 2; count++; if (arr[mid] == k) { break; } else if  else { left = mid + 1; } } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ Main(){ Scanner sc = new Scanner(System.in); while(sc.hasNext()){ int r = sc.nextInt(), t, cnt=1, l=0; if(r == 0) break; int[]  r; i++) ary[i] = sc.nextInt(); t = sc.nextInt();  t || l >= r) break; else if(ary[v] < t) l = v+1; else r = v-1; cnt++; } System.out.println(Integer.toString(cnt)); } } public static void main(String[] args){ new Main(); } }"], "original_ll": -1.1872246265411377, "sampled_ll": -0.318664014339447, "all_perturbed_sampled_ll": [-1.1419223546981812], "all_perturbed_original_ll": [-2.002732515335083], "perturbed_sampled_ll": -1.1419223546981812, "perturbed_original_ll": -2.002732515335083, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\ndef f(check, n, L, count):\n    count += 1\n    median = int(math.floor(float(n-1)/2))\n    if len(L) == 1:\n        return count\n    elif L[median] == check:\n        return count\n    elif L[median] < check:\n        L = L[median+1:]\n    elif check < L[median]:\n        L = L[:median]\n    n = len(L)\n    return f(check, n, L, count)\n\nwhile True:\n    n = int(raw_input())\n    if n == 0: break\n    L = [int(raw_input()) for i in range(n)]\n    check = int(raw_input())\n    print f(check, n, L, 0)", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    arr = []\n    for _ in range(n):\n        arr.append(int(input()))\n    \n    k = int(input())\n    \n    left = 0\n    right = n - 1\n    count = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        count += 1\n        \n        if arr[mid] == k:\n            break\n        elif k < arr[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    print(count)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break arr = [] for _ in range(n): arr.append(int(input())) k = int(input()) left = 0 right = n - 1 count = 0 while left <= right: mid  arr[mid] == k: break elif k  mid + 1 print(count)"], "perturbed_original": ["import math def f(check, n,  count elif L[median] < check: L = L[median+1:] elif check < L[median]: L = L[:median] n = len(L) return f(check, n, L, count) while True: n = int(raw_input()) if n == 0: break L = [int(raw_input()) for i in range(n)] check = int(raw_input()) print f(check, n, L, 0)"], "original_ll": -1.0441051721572876, "sampled_ll": -0.4932064116001129, "all_perturbed_sampled_ll": [-1.817537546157837], "all_perturbed_original_ll": [-1.818123698234558], "perturbed_sampled_ll": -1.817537546157837, "perturbed_original_ll": -1.818123698234558, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][0]=0;q[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){\n\t\t\t\tif(FR>0 && cd!=14)fprintf(stderr,\"%d?\\n\",cd);\n\t\t\t\tans=(int)cd+q[FR][13];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20 && ans<9999)fprintf(stderr,\"ans:%d?\\n\",ans);\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_DEPTH 20\n\ntypedef struct {\n    int board[13];\n    int zero1, zero2;\n} State;\n\nint goal[13] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0};\n\nint adj[13][5] = {\n    {1, -1, -1, -1, -1},     // 0\n    {0, 2, 3, -1, -1},       // 1\n    {1, 4, -1, -1, -1},      // 2\n    {1, 4, 5, -1, -1},       // 3\n    {2, 3, 6, 8, -1},        // 4\n    {3, 6, 9, -1, -1},       // 5\n    {4, 5, 7, 10, -1},       // 6\n    {6, 8, 11, -1, -1},      // 7\n    {4, 7, 11, -1, -1},      // 8\n    {5, 10, -1, -1, -1},     // 9\n    {6, 9, 11, -1, -1},      // 10\n    {7, 8, 10, 12, -1},      // 11\n    {11, -1, -1, -1, -1}     // 12\n};\n\nint isGoal(State *s) {\n    for (int i = 0; i < 13; i++) {\n        if (s->board[i] != goal[i]) return 0;\n    }\n    return 1;\n}\n\ntypedef struct {\n    State state;\n    int depth;\n} QueueItem;\n\nQueueItem queue[10000000];\nint qfront, qback;\n\nunsigned long long hash(State *s) {\n    unsigned long long h = 0;\n    for (int i = 0; i < 13; i++) {\n        h = h * 13 + s->board[i];\n    }\n    return h;\n}\n\nint visited[1 << 24];\n\nint getVisitedIndex(unsigned long long h) {\n    return (int)(h % (1 << 24));\n}\n\nint solve(State *init) {\n    if (isGoal(init)) return 0;\n    \n    memset(visited, 0, sizeof(visited));\n    qfront = qback = 0;\n    \n    queue[qback].state = *init;\n    queue[qback].depth = 0;\n    qback++;\n    \n    unsigned long long h = hash(init);\n    visited[getVisitedIndex(h)] = 1;\n    \n    while (qfront < qback) {\n        QueueItem cur = queue[qfront++];\n        \n        if (cur.depth >= MAX_DEPTH) continue;\n        \n        int zeros[2] = {cur.state.zero1, cur.state.zero2};\n        \n        for (int zi = 0; zi < 2; zi++) {\n            int zpos = zeros[zi];\n            \n            for (int i = 0; adj[zpos][i] != -1; i++) {\n                int npos = adj[zpos][i];\n                \n                State next = cur.state;\n                next.board[zpos] = next.board[npos];\n                next.board[npos] = 0;\n                \n                if (zi == 0) {\n                    next.zero1 = npos;\n                } else {\n                    next.zero2 = npos;\n                }\n                \n                if (next.zero1 > next.zero2) {\n                    int tmp = next.zero1;\n                    next.zero1 = next.zero2;\n                    next.zero2 = tmp;\n                }\n                \n                if (isGoal(&next)) {\n                    return cur.depth + 1;\n                }\n                \n                h = hash(&next);\n                int idx = getVisitedIndex(h);\n                if (!visited[idx]) {\n                    visited[idx] = 1;\n                    queue[qback].state = next;\n                    queue[qback].depth = cur.depth + 1;\n                    qback++;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int first;\n    while (scanf(\"%d\", &first) == 1 && first != -1) {\n        State init;\n        init.board[0] = first;\n        \n        for (int i = 1; i < 13; i++) {\n            scanf(\"%d\", &init.board[i]);\n        }\n        \n        init.zero1 = -1;\n        init.zero2 = -1;\n        for (int i = 0; i < 13; i++) {\n            if (init.board[i] == 0) {\n                if (init.zero1 == -1) init.zero1 = i;\n                else init.zero2 = i;\n            }\n        }\n        \n        int result = solve(&init);\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include  3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0}; int adj[13][5] = { {1, -1, -1, -1, -1}, // 0 {0, 2, 3, -1, -1}, // 1 {1, 4, -1, -1, -1}, // 2 {1, 4, 5, -1, -1}, // 3 {2, 3, 6, 8, -1}, // 4 {3, 6, 9, -1, -1}, // 5 {4, 5, 7, 10, -1}, // 6 {6, 8, 11, -1, -1}, // 7 {4,  -1}, //  10, 12, -1}, // 11 {11, -1, -1, -1, -1} // 12 }; int isGoal(State *s) { for (int i = 0; i < 13; i++) { if (s->board[i] !=  State state; int depth; } QueueItem; QueueItem queue[10000000]; int qfront, qback; unsigned long long hash(State *s) { unsigned long long h = 0; for (int i = 0; i < 13; i++) { h = h * 13 + s->board[i]; } return h; } int visited[1 << 24]; int getVisitedIndex(unsigned long long h) { return (int)(h % (1 << 24)); } int solve(State *init) { if (isGoal(init)) return 0; memset(visited, 0, sizeof(visited)); qfront = qback = 0; queue[qback].state = *init; queue[qback].depth = 0; qback++; unsigned long long h = hash(init); visited[getVisitedIndex(h)] = 1; while (qfront < qback) { QueueItem cur = queue[qfront++]; if (cur.depth >= MAX_DEPTH) continue; int zeros[2] = {cur.state.zero1, cur.state.zero2}; for (int zi = 0; zi <   adj[zpos][i]; State next  == 0) { next.zero1 = npos; } else { next.zero2 = npos; } if (next.zero1 > next.zero2) {  } if (isGoal(&next)) { return cur.depth +  (!visited[idx]) { visited[idx] = 1; queue[qback].state = next; queue[qback].depth = cur.depth + 1; qback++; } } } } return -1; } int main() { int first; while (scanf(\"%d\", &first) ==  first; for (int i = 1; i < 13; i++) { scanf(\"%d\", &init.board[i]); } init.zero1 = -1; init.zero2 = -1;  init.zero1 = i; else init.zero2 = i; } } int result = solve(&init); if (result == -1) { printf(\"NA\\n\"); } else { printf(\"%d\\n\", result); } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> #include <stdlib.h> typedef struct{ long  long  z; z=*x; *x=*y; *y=z; } long long int convert(int a[]){ long long int ret=0; int i;  int ccc=code%30000; puzz* ppp=(puzz*)malloc(sizeof(puzz)); ppp->code=code; ppp->steps=step; if(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;} hash[ccc][size[ccc]]=ppp; size[ccc]++; } int hashsearch(long long int code){ int ccc=code%30000; int i=size[ccc]; for(i--;i>=0;i--){ if(hash[ccc][i]->code==code)return hash[ccc][i]->steps; } return -1; } void mark(int x,int y){ int k; long long int cd; swap(&q[FR][x],&q[FR][y]); cd=convert(q[FR]); if(SW==1 || hashsearch(cd)<0){ for(k=0;k<14;k++){q[TO][k]=q[FR][k];} q[TO][13]++; if(SW==0)hashadd(cd,q[TO][13]); TO++; } swap(&q[FR][x],&q[FR][y]); } void check(){ if(q[FR][0]==0){mark(0,2);} if(q[FR][1]==0){mark(1,2);mark(1,5);} if(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);} if(q[FR][3]==0){mark(3,2);mark(3,7);} if(q[FR][4]==0){mark(4,5);} if(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);} if(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);} if(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);} if(q[FR][8]==0){mark(8,7);} if(q[FR][9]==0){mark(9,5);mark(9,10);} if(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);} if(q[FR][11]==0){mark(11,7);mark(11,10);}  for(i=1;i<12;i++)q[0][i]=i; q[0][0]=0;q[0][12]=0;q[0][13]=0; FR=0;TO=1;SW=0; while(FR<TO && q[FR][13]<=13){ check(); FR++; } while(scanf(\"%d\",&q[0][0])*q[0][0]>=0){ for(i=1;i<13;i++)scanf(\"%d\",&q[0][i]); q[0][13]=0;FR=0;TO=1;SW=1;ans=9999; //for(i=0;i<30000;i++)size2[i]=0; while(FR<TO){ cd=hashsearch(convert(q[FR])); if(cd>=0){ if(FR>0 && cd!=14)fprintf(stderr,\"%d?\\n\",cd); ans=(int)cd+q[FR][13]; break; } if(q[FR][13]<6)check(); FR++; } if(ans>20 && ans<9999)fprintf(stderr,\"ans:%d?\\n\",ans); if(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans); } return 0; }"], "original_ll": -0.9786497354507446, "sampled_ll": -0.5188292264938354, "all_perturbed_sampled_ll": [-1.22605299949646], "all_perturbed_original_ll": [-1.2642631530761719], "perturbed_sampled_ll": -1.22605299949646, "perturbed_original_ll": -1.2642631530761719, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] adj = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };\n\t\tString g = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tint step = 1;\n\t\tdeque.offer(g);\n\t\tm.put(g, 0);\n\t\twhile (!deque.isEmpty() && step < 10) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int k = 0; k < size; k++) {\n\t\t\t\tString s = deque.pop();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (c[i] == '0') {\n\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\tc[i] = c[adj[i][j]];\n\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\tString n = String.valueOf(c);\n\t\t\t\t\t\t\tif (!m.containsKey(n)) {\n\t\t\t\t\t\t\t\tm.put(n, step);\n\t\t\t\t\t\t\t\tdeque.offer(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[adj[i][j]] = c[i];\n\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint p = scanner.nextInt();\n\t\t\tif (p == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cc = new char[13];\n\t\t\tcc[0] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tp = scanner.nextInt();\n\t\t\t\tcc[i] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\t}\n\t\t\tString st = String.valueOf(cc);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tdeque.clear();\n\t\t\tdeque.offer(st);\n\t\t\tstep = 0;\n\t\t\tboolean flag = false;\n\t\t\tString ans = \"\";\n\t\t\tloop: while (!deque.isEmpty() && step < 10) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tfor (int w = 0; w < size; w++) {\n\t\t\t\t\tString s = deque.pop();\n\t\t\t\t\tif (m.containsKey(s)) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tans = s;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] cs = s.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (cs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\t\tcs[i] = cs[adj[i][j]];\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = '0';\n\t\t\t\t\t\t\t\tString news = String.valueOf(cs);\n\t\t\t\t\t\t\t\tif (!set.contains(news)) {\n\t\t\t\t\t\t\t\t\tset.add(news);\n\t\t\t\t\t\t\t\t\tdeque.offer(news);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = cs[i];\n\t\t\t\t\t\t\t\tcs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? m.get(ans) : \"NA\");\n\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static final int[] GOAL = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0};\n    \n    static class State {\n        int[] board;\n        int steps;\n        \n        State(int[] board, int steps) {\n            this.board = board.clone();\n            this.steps = steps;\n        }\n        \n        String hash() {\n            return Arrays.toString(board);\n        }\n    }\n    \n    static int[] readInput(Scanner sc) {\n        int[] board = new int[13];\n        int idx = 0;\n        \n        // Row 1: 1 element\n        board[idx++] = sc.nextInt();\n        \n        // Row 2: 3 elements\n        for (int i = 0; i < 3; i++) {\n            board[idx++] = sc.nextInt();\n        }\n        \n        // Row 3: 5 elements\n        for (int i = 0; i < 5; i++) {\n            board[idx++] = sc.nextInt();\n        }\n        \n        // Row 4: 3 elements\n        for (int i = 0; i < 3; i++) {\n            board[idx++] = sc.nextInt();\n        }\n        \n        // Row 5: 1 element\n        board[idx++] = sc.nextInt();\n        \n        return board;\n    }\n    \n    static int[][] getNeighbors() {\n        int[][] neighbors = new int[13][];\n        neighbors[0] = new int[]{1};\n        neighbors[1] = new int[]{0, 2, 4};\n        neighbors[2] = new int[]{1, 3, 5};\n        neighbors[3] = new int[]{2, 6};\n        neighbors[4] = new int[]{1, 5, 7};\n        neighbors[5] = new int[]{2, 4, 6, 8};\n        neighbors[6] = new int[]{3, 5, 9};\n        neighbors[7] = new int[]{4, 8, 10};\n        neighbors[8] = new int[]{5, 7, 9, 11};\n        neighbors[9] = new int[]{6, 8, 12};\n        neighbors[10] = new int[]{7, 11};\n        neighbors[11] = new int[]{8, 10, 12};\n        neighbors[12] = new int[]{9, 11};\n        return neighbors;\n    }\n    \n    static int solve(int[] initial) {\n        if (Arrays.equals(initial, GOAL)) {\n            return 0;\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        State start = new State(initial, 0);\n        queue.offer(start);\n        visited.add(start.hash());\n        \n        int[][] neighbors = getNeighbors();\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.steps >= 20) {\n                continue;\n            }\n            \n            // Find empty spaces\n            List<Integer> empties = new ArrayList<>();\n            for (int i = 0; i < 13; i++) {\n                if (curr.board[i] == 0) {\n                    empties.add(i);\n                }\n            }\n            \n            // Try moving tiles into empty spaces\n            for (int emptyPos : empties) {\n                for (int neighbor : neighbors[emptyPos]) {\n                    if (curr.board[neighbor] != 0) {\n                        int[] newBoard = curr.board.clone();\n                        newBoard[emptyPos] = newBoard[neighbor];\n                        newBoard[neighbor] = 0;\n                        \n                        if (Arrays.equals(newBoard, GOAL)) {\n                            return curr.steps + 1;\n                        }\n                        \n                        String hash = Arrays.toString(newBoard);\n                        if (!visited.contains(hash)) {\n                            visited.add(hash);\n                            queue.offer(new State(newBoard, curr.steps + 1));\n                        }\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int first = sc.nextInt();\n            if (first == -1) break;\n            \n            int[] board = new int[13];\n            board[0] = first;\n            \n            for (int i = 1; i < 13; i++) {\n                board[i] = sc.nextInt();\n            }\n            \n            int result = solve(board);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static final int[] GOAL = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0}; static class State { int[] board;  this.steps = steps; } String hash() { return Arrays.toString(board); } } static int[] readInput(Scanner sc) { int[] board = new int[13]; int idx = 0; // Row 1: 1 element board[idx++] = sc.nextInt(); // Row 2: 3 elements for (int i = 0; i < 3; i++) { board[idx++] = sc.nextInt(); } // Row 3: 5 elements for (int i = 0; i < 5; i++) { board[idx++]  = sc.nextInt(); } // Row 5: 1 element board[idx++] = sc.nextInt(); return board; } static  new int[]{1}; neighbors[1]  5}; neighbors[3] = new int[]{2, 6}; neighbors[4] = new int[]{1, 5, 7}; neighbors[5] = new int[]{2, 4, 6, 8}; neighbors[6] = new int[]{3, 5, 9}; neighbors[7] = new int[]{4, 8, 10}; neighbors[8] = new int[]{5, 7, 9, 11}; neighbors[9] = new int[]{6, 8,  10, 12}; neighbors[12] = new int[]{9, 11}; return neighbors; } static int solve(int[] initial) { if (Arrays.equals(initial, GOAL)) { return 0; } Queue<State> queue = new LinkedList<>(); Set<String> visited = new HashSet<>(); State start = new State(initial, 0); queue.offer(start); visited.add(start.hash()); int[][] neighbors = getNeighbors(); while (!queue.isEmpty()) { State curr = queue.poll(); if (curr.steps >= 20) { continue; } // Find empty spaces List<Integer>  empties.add(i); } } // Try moving tiles into empty spaces for (int emptyPos : empties) { for (int neighbor : neighbors[emptyPos]) { if (curr.board[neighbor] != 0)  0; if (Arrays.equals(newBoard, GOAL)) { return curr.steps + 1;  State(newBoard, curr.steps + 1)); } } } } } return -1; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) {  board = new int[13]; board[0] = first; for (int i = 1;  result = solve(board); if (result == -1) { System.out.println(\"NA\"); } else { System.out.println(result); } } sc.close(); } }"], "perturbed_original": ["import java.util.ArrayDeque; import java.util.Deque; import java.util.HashMap; import java.util.HashSet; import  static void main(String[] args) { new Main().run(); } private void run() { Scanner scanner = new  5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 }, { 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7  String g = \"0ABCDEFGHIJK0\"; Map<String, Integer> m = new HashMap<String, Integer>(); Deque<String> deque = new ArrayDeque<String>(); int step = 1; deque.offer(g); m.put(g, 0); while (!deque.isEmpty() && step < 10) { int  size; k++) { String s = deque.pop(); char[] c = s.toCharArray(); for (int i  '0') { for (int j = 0; j < adj[i].length; j++) { c[i] = c[adj[i][j]]; c[adj[i][j]] = '0'; String n = String.valueOf(c); if (!m.containsKey(n)) { m.put(n, step); deque.offer(n); } c[adj[i][j]] = c[i]; c[i] = '0'; } } } } step++; } while (true) { int p = scanner.nextInt(); if (p == -1) break; char[] cc = new char[13]; cc[0] = p == 0 ? '0' : (char) (p - 1 + 'A'); for (int i = 1; i < 13; i++) { p = scanner.nextInt(); cc[i] = p == 0 ? '0' : (char) (p -  = new  String ans = \"\"; loop: while (!deque.isEmpty() && step < 10) { int size = deque.size(); for (int w = 0; w < size; w++) { String s = deque.pop(); if (m.containsKey(s)) { flag = true; ans = s; break loop; } char[] cs = s.toCharArray(); for (int i = 0; i  cs[i] = cs[adj[i][j]]; cs[adj[i][j]]  deque.offer(news); } cs[adj[i][j]] = cs[i]; cs[i] = '0'; } } } } step++; } System.out.println(flag ? m.get(ans) : \"NA\"); } } }"], "original_ll": -0.6402527689933777, "sampled_ll": -0.43421727418899536, "all_perturbed_sampled_ll": [-1.154386043548584], "all_perturbed_original_ll": [-1.2918412685394287], "perturbed_sampled_ll": -1.154386043548584, "perturbed_original_ll": -1.2918412685394287, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from math import factorial\nfrom Queue import PriorityQueue\n\nFACTORIAL=[factorial(i) for i in xrange(13)]\nLEFT,UP,RIGHT,DOWN=0,1,2,3\nMOVE=[[0] for u in xrange(13)]\nMOVE[0] =[-1,-1,-1, 2]\nMOVE[1] =[-1,-1, 2, 5]\nMOVE[2] =[ 1, 0, 3, 6]\nMOVE[3] =[ 2,-1,-1, 7] \nMOVE[4] =[-1,-1, 5,-1]\nMOVE[5] =[ 4, 1, 6, 9]\nMOVE[6] =[ 5, 2, 7,10]\nMOVE[7] =[ 6, 3, 8,11]\nMOVE[8] =[ 7,-1,-1,-1]\nMOVE[9] =[-1, 5,10,-1]\nMOVE[10]=[ 9, 6,11,12]\nMOVE[11]=[10, 7,-1,-1]\nMOVE[12]=[-1,10,-1,-1]\n\ndef hash(cell):\n    work = cell[:]\n    hash = 0\n    for i in xrange(12):\n        hash += work[i] * FACTORIAL[13-1-i]\n        for ii in xrange(i+1,13):\n            if work[ii]>work[i]:\n                work[ii]-=1\n    return hash\n\ndef dehash(key):\n    cell=[]\n    for i in xrange(13):\n        cell.append(key/FACTORIAL[13-1-i])\n        key %= FACTORIAL[13-1-i]\n    for i in xrange(13-1,-1,-1):\n        for ii in xrange(i+1,13):\n            if cell[i]<=cell[ii]:\n                cell[ii]+=1\n    return cell\n\ndef evaluate(cell):\n    point=[[0,2],\n           [1,1],[1,2],[1,3],\n           [2,0],[2,1],[2,2],[2,3],[2,4],\n           [3,1],[3,2],[3,3],\n           [4,2]]\n    eva=0\n    for i in xrange(0,13):\n        if not (cell[i]==0 or cell[i]==12):\n            eva+=abs(point[cell[i]][0]-point[i][0])\n            eva+=abs(point[cell[i]][1]-point[i][1])\n    return eva\n\nANS_HASH=[hash([0,1,2,3,4,5,6,7,8,9,10,11,12]),hash([12,1,2,3,4,5,6,7,8,9,10,11,0])]          \n\nwhile True:\n    p=[input()]\n    if p==[-1]:\n        break\n    for u in xrange(4):\n        for pp in map(int,raw_input().split()):\n            p.append(pp)\n    p[p.index(0)]=12\n    pq = PriorityQueue()\n    pq.put([evaluate(p),hash(p),0])\n    visited={}\n    visited[hash(p)]=True\n    ans=0 if hash(p) in ANS_HASH else \"NA\"\n    #cur=[eva,hashkey,step]\n    while not pq.empty():\n        eva,cur_hash,cur_step=pq.get()\n        cur_cell=dehash(cur_hash)\n        if not (eva<=20 and ans==\"NA\"):\n            break\n        for i in xrange(13):\n            if cur_cell[i]==0 or cur_cell[i]==12:\n                for ii in [LEFT,UP,RIGHT,DOWN]:\n                    if not MOVE[i][ii]==-1:\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n                        hashkey=hash(cur_cell)\n                        if not hashkey in visited:\n                            if hashkey in ANS_HASH:\n                                ans=cur_step+1\n                                break\n                            pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1])\n                            visited[hashkey]=True\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n    print ans", "sampled": "from collections import deque\n\ndef read_puzzle():\n    line = input().strip()\n    if line == '-1':\n        return None\n    \n    puzzle = []\n    puzzle.append(list(map(int, line.split())))\n    puzzle.append(list(map(int, input().split())))\n    puzzle.append(list(map(int, input().split())))\n    puzzle.append(list(map(int, input().split())))\n    input()  # empty line\n    \n    return puzzle\n\ndef puzzle_to_tuple(puzzle):\n    result = []\n    for row in puzzle:\n        result.extend(row)\n    return tuple(result)\n\ndef tuple_to_puzzle(t):\n    puzzle = []\n    puzzle.append(list(t[0:1]))\n    puzzle.append(list(t[1:4]))\n    puzzle.append(list(t[4:9]))\n    puzzle.append(list(t[9:12]))\n    return puzzle\n\ndef get_neighbors(puzzle):\n    neighbors = []\n    \n    # Find all zeros\n    zeros = []\n    for i in range(len(puzzle)):\n        for j in range(len(puzzle[i])):\n            if puzzle[i][j] == 0:\n                zeros.append((i, j))\n    \n    # For each zero, find adjacent numbers that can move\n    for zi, zj in zeros:\n        # Check all 4 directions\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        for di, dj in directions:\n            ni, nj = zi + di, zj + dj\n            if 0 <= ni < len(puzzle) and 0 <= nj < len(puzzle[ni]):\n                if puzzle[ni][nj] != 0:\n                    # Make a move\n                    new_puzzle = [row[:] for row in puzzle]\n                    new_puzzle[zi][zj] = new_puzzle[ni][nj]\n                    new_puzzle[ni][nj] = 0\n                    neighbors.append(new_puzzle)\n    \n    return neighbors\n\ndef solve_puzzle(start_puzzle):\n    goal = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0)\n    \n    start = puzzle_to_tuple(start_puzzle)\n    \n    if start == goal:\n        return 0\n    \n    queue = deque([(start_puzzle, 0)])\n    visited = {start}\n    \n    while queue:\n        current_puzzle, steps = queue.popleft()\n        \n        if steps >= 20:\n            continue\n        \n        for neighbor in get_neighbors(current_puzzle):\n            neighbor_tuple = puzzle_to_tuple(neighbor)\n            \n            if neighbor_tuple == goal:\n                return steps + 1\n            \n            if neighbor_tuple not in visited:\n                visited.add(neighbor_tuple)\n                queue.append((neighbor, steps + 1))\n    \n    return -1\n\nwhile True:\n    puzzle = read_puzzle()\n    if puzzle is None:\n        break\n    \n    result = solve_puzzle(puzzle)\n    if result == -1:\n        print(\"NA\")\n    else:\n        print(result)\n", "perturbed_sampled": [" line == '-1': return None puzzle = [] puzzle.append(list(map(int, line.split()))) puzzle.append(list(map(int, input().split()))) puzzle.append(list(map(int, input().split()))) puzzle.append(list(map(int, input().split())))  [] for row  puzzle.append(list(t[0:1])) puzzle.append(list(t[1:4])) puzzle.append(list(t[4:9])) puzzle.append(list(t[9:12])) return puzzle def get_neighbors(puzzle): neighbors = [] # Find all zeros zeros = [] for i in range(len(puzzle)): for j in range(len(puzzle[i])): if puzzle[i][j] == 0: zeros.append((i, j)) # For each zero, find adjacent numbers that can move for zi, zj in zeros: # Check all 4 directions directions = [(-1, 0), (1, 0), (0, -1),  zi + di, zj + dj if 0 <= ni < len(puzzle) and 0 <= nj < len(puzzle[ni]): if puzzle[ni][nj] != 0: # Make a move new_puzzle = [row[:] for row in puzzle] new_puzzle[zi][zj] = new_puzzle[ni][nj] new_puzzle[ni][nj] = 0 neighbors.append(new_puzzle) return neighbors def solve_puzzle(start_puzzle): goal = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10,  return 0 queue = deque([(start_puzzle, 0)]) visited = {start} while queue: current_puzzle, steps  get_neighbors(current_puzzle): neighbor_tuple = puzzle_to_tuple(neighbor) if neighbor_tuple == goal: return steps + 1 if neighbor_tuple not in visited: visited.add(neighbor_tuple) queue.append((neighbor, steps + 1)) return -1  result = solve_puzzle(puzzle) if result == -1: print(\"NA\") else: print(result)"], "perturbed_original": ["from math import factorial from Queue import PriorityQueue FACTORIAL=[factorial(i) for i in xrange(13)] LEFT,UP,RIGHT,DOWN=0,1,2,3 MOVE=[[0] for u in xrange(13)] MOVE[0] =[-1,-1,-1, 2] MOVE[1] =[-1,-1, 2, 5] MOVE[2] =[ 1,  2, 7,10] MOVE[7] =[ 6, 3, 8,11] MOVE[8] =[ 7,-1,-1,-1] MOVE[9] =[-1, 5,10,-1] MOVE[10]=[ 9, 6,11,12] MOVE[11]=[10, 7,-1,-1] MOVE[12]=[-1,10,-1,-1] def hash(cell): work = cell[:] hash = 0 for i in xrange(12): hash += work[i] * FACTORIAL[13-1-i] for ii in xrange(i+1,13): if work[ii]>work[i]: work[ii]-=1 return hash def dehash(key):  i in xrange(13-1,-1,-1): for ii in xrange(i+1,13): if cell[i]<=cell[ii]: cell[ii]+=1 return cell def evaluate(cell): point=[[0,2], [1,1],[1,2],[1,3], [2,0],[2,1],[2,2],[2,3],[2,4], [3,1],[3,2],[3,3], [4,2]] eva=0  eva+=abs(point[cell[i]][1]-point[i][1]) return eva ANS_HASH=[hash([0,1,2,3,4,5,6,7,8,9,10,11,12]),hash([12,1,2,3,4,5,6,7,8,9,10,11,0])] while True: p=[input()] if p==[-1]: break for u in xrange(4): for pp in map(int,raw_input().split()): p.append(pp) p[p.index(0)]=12 pq = PriorityQueue() pq.put([evaluate(p),hash(p),0]) visited={}  not pq.empty(): eva,cur_hash,cur_step=pq.get() cur_cell=dehash(cur_hash) if not (eva<=20 and ans==\"NA\"): break for i in xrange(13): if cur_cell[i]==0 or cur_cell[i]==12: for ii in [LEFT,UP,RIGHT,DOWN]: if not MOVE[i][ii]==-1: cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i] hashkey=hash(cur_cell) if not  visited[hashkey]=True cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i] print ans"], "original_ll": -1.0346330404281616, "sampled_ll": -0.6055989265441895, "all_perturbed_sampled_ll": [-1.3487088680267334], "all_perturbed_original_ll": [-1.550855040550232], "perturbed_sampled_ll": -1.3487088680267334, "perturbed_original_ll": -1.550855040550232, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "double g[100][100],G[100],H[100],a;main(n,m,i,j){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%.2f\\n\",a)){for(i=n;i--;G[i]=1)for(j=n;j--;)scanf(\"%lf\",g[i]+j);for(;--m;memcpy(G,H,8*n))for(i=n;i--;)for(H[i]=0,j=n;j--;a>H[i]?H[i]=a:0)a=G[j]*g[j][i];for(a=0;n--;)G[n]>a?a=G[n]:0;}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, m;\n    double g[101][101];\n    double dp[101][101];\n    \n    while (scanf(\"%d %d\", &n, &m) == 2) {\n        if (n == 0 && m == 0) break;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                scanf(\"%lf\", &g[i][j]);\n            }\n        }\n        \n        memset(dp, 0, sizeof(dp));\n        \n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = 1.0;\n        }\n        \n        for (int step = 2; step <= m; step++) {\n            for (int curr = 1; curr <= n; curr++) {\n                dp[step][curr] = 0.0;\n                for (int prev = 1; prev <= n; prev++) {\n                    double val = dp[step-1][prev] * g[prev][curr];\n                    if (val > dp[step][curr]) {\n                        dp[step][curr] = val;\n                    }\n                }\n            }\n        }\n        \n        double max_size = 0.0;\n        for (int i = 1; i <= n; i++) {\n            if (dp[m][i] > max_size) {\n                max_size = dp[m][i];\n            }\n        }\n        \n        printf(\"%.2lf\\n\", max_size);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n, m; double g[101][101]; double dp[101][101]; while (scanf(\"%d %d\",  m == 0) break; for (int i = 1; i <= n; i++) { for (int j = 1; j  sizeof(dp)); for (int i = 1;  (int step = 2; step <= m; step++) { for (int curr = 1; curr <= n; curr++) { dp[step][curr] = 0.0; for (int prev = 1; prev <= n; prev++) { double val = dp[step-1][prev] *  } } } double max_size = 0.0; for (int i = 1; i <= n; i++) { if (dp[m][i] > max_size) { max_size = dp[m][i]; } } printf(\"%.2lf\\n\", max_size); } return 0; }"], "perturbed_original": ["double g[100][100],G[100],H[100],a;main(n,m,i,j){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%.2f\\n\",a)){for(i=n;i--;G[i]=1)for(j=n;j--;)scanf(\"%lf\",g[i]+j);for(;--m;memcpy(G,H,8*n))for(i=n;i--;)for(H[i]=0,j=n;j--;a>H[i]?H[i]=a:0)a=G[j]*g[j][i];for(a=0;n--;)G[n]>a?a=G[n]:0;}exit(0);}"], "original_ll": -2.362244129180908, "sampled_ll": -0.4183570444583893, "all_perturbed_sampled_ll": [-1.1414052248001099], "all_perturbed_original_ll": [-2.362244129180908], "perturbed_sampled_ll": -1.1414052248001099, "perturbed_original_ll": -2.362244129180908, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static int n, m;\n    static double[][] dp, table;\n\n    public static void main(String[] args) {\n        while(read()){\n            solve();\n        }\n\n    }\n\n    static boolean read(){\n        if(!sc.hasNext())return false;\n        n = sc.nextInt();\n        m = sc.nextInt();\n        if(n == 0 || m == 0)return false;\n        dp = new double[m][n];\n        table = new double[m][n];\n\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                table[i][j] = sc.nextDouble();\n            }\n        }\n\n        for(int i = 0; i < 1; i++){\n            for(int j = 0; j < n; j++){\n                dp[i][j] = 1.0;\n            }\n        }\n\n        return true;\n    }\n\n    static void solve(){\n        int index = 0;\n        double value = 0.0, res = 0.0;\n        double[] array = new double[n];\n        for(int i = 0; i < m-1; i++){\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < n; k++){\n                    array[k] = table[j][k];\n                }\n                for(int k = 0; k < n; k++){\n                    if(value < array[k]){\n                        index = k;\n                        value = array[k];\n                    }\n                }\n                dp[i+1][index] = Math.max(dp[i+1][index], value*dp[i][j]);\n            }\n        }\n\n        for(int j = 0; j < n; j++){\n            res = Math.max(res, dp[m-1][j]);\n        }\n        System.out.printf(\"%.2f\\n\", res);\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) break;\n            \n            double[][] g = new double[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = sc.nextDouble();\n                }\n            }\n            \n            if (m == 1) {\n                System.out.println(\"1.00\");\n                continue;\n            }\n            \n            // dp[step][lastFertilizer] = maximum size after 'step' applications with last fertilizer being 'lastFertilizer'\n            double[][] dp = new double[m + 1][n];\n            \n            // Initialize: after 1 application, size is 1.0 for any fertilizer\n            for (int i = 0; i < n; i++) {\n                dp[1][i] = 1.0;\n            }\n            \n            // Fill DP table\n            for (int step = 2; step <= m; step++) {\n                for (int curr = 0; curr < n; curr++) {\n                    dp[step][curr] = 0.0;\n                    for (int prev = 0; prev < n; prev++) {\n                        if (dp[step - 1][prev] > 0) {\n                            dp[step][curr] = Math.max(dp[step][curr], dp[step - 1][prev] * g[prev][curr]);\n                        }\n                    }\n                }\n            }\n            \n            // Find maximum size after m applications\n            double maxSize = 0.0;\n            for (int i = 0; i < n; i++) {\n                maxSize = Math.max(maxSize, dp[m][i]);\n            }\n            \n            System.out.printf(\"%.2f\\n\", maxSize);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args)  == 0 && m == 0) break; double[][] g = new double[n][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { g[i][j] = sc.nextDouble(); } } if (m == 1) { System.out.println(\"1.00\"); continue; } // dp[step][lastFertilizer] = maximum size after 'step' applications with last fertilizer being 'lastFertilizer' double[][] dp = new double[m + 1][n]; // Initialize: after 1 application, size is 1.0 for any fertilizer for (int i = 0; i < n; i++) { dp[1][i] = 1.0; } // Fill DP  curr++) { dp[step][curr] = 0.0; for (int prev = 0;  0) { dp[step][curr] = Math.max(dp[step][curr], dp[step - 1][prev] * g[prev][curr]); } } } } //  for (int i = 0; i < n; i++) { maxSize = Math.max(maxSize, dp[m][i]); } System.out.printf(\"%.2f\\n\", maxSize); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { static Scanner sc = new Scanner(System.in); static int n, m; static double[][] dp, table; public static void main(String[] args) { while(read()){ solve(); } } static boolean ; }<extra_id_5>float f = 0.0;<extra_id_6>< n; k++){<extra_id_7>= (n * (n<extra_id_8>(n*n) - j); } array<extra_id_9>i ] = (<extra_id_10>) f ; }<extra_id_11>) d efault + +<extra_id_12>; for<extra_id_13>= r [ 1 -<extra_id_14>== 0 ) {<extra_id_15>== == 0 || m == 0)return false;  = 0; i < m; i++){ for(int j = 0; j < n; j++){ table[i][j] = sc.nextDouble(); } } for(int i = 0; i < 1; i++){ for(int j = 0; j < n; j++){ dp[i][j] = 1.0; } } return true; } static void solve(){ int index = 0; double value = 0.0, res = 0.0; double[] array = new double[n]; for(int i = 0; i < m-1; i++){ for(int j = 0; j < n;  = table[j][k]; } for(int k = 0; k < n; k++){ if(value <  = Math.max(dp[i+1][index], value*dp[i][j]); } } for(int j = 0; j  } }"], "original_ll": -0.5806625485420227, "sampled_ll": -0.5914410352706909, "all_perturbed_sampled_ll": [-1.3533775806427002], "all_perturbed_original_ll": [-1.9352282285690308], "perturbed_sampled_ll": -1.3533775806427002, "perturbed_original_ll": -1.9352282285690308, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n, m = map(int, raw_input().split())\n    if n==0:\n        exit(0)\n    mat = [map(float, raw_input().split()) for i in xrange(n)]\n    dp = [1.0] * n\n    for t in xrange(m-1):\n        dp2 = [-1.0] * n\n        for i in xrange(n):\n            mat_i = mat[i]; dp_i = dp[i]\n            for j in xrange(n):\n                dp2[j] = max(dp2[j], dp_i * mat_i[j])\n        dp = dp2\n    print \"%.02f\" % round(max(dp), 2)", "sampled": "import sys\n\ndef solve(n, m, growth):\n    if m == 1:\n        return 1.0\n    \n    # dp[step][fertilizer] = maximum growth after 'step' applications, ending with 'fertilizer'\n    dp = [[-1.0] * n for _ in range(m + 1)]\n    \n    # After first application, size is 1.0 for any fertilizer\n    for i in range(n):\n        dp[1][i] = 1.0\n    \n    # For each subsequent application\n    for step in range(2, m + 1):\n        for curr in range(n):\n            # Try all possible previous fertilizers\n            for prev in range(n):\n                if dp[step - 1][prev] > 0:\n                    # Apply fertilizer 'curr' after fertilizer 'prev'\n                    new_size = dp[step - 1][prev] * growth[prev][curr]\n                    dp[step][curr] = max(dp[step][curr], new_size)\n    \n    # Find maximum size after m applications\n    max_size = max(dp[m])\n    return max_size\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    if not line:\n        break\n    \n    parts = line.split()\n    n, m = int(parts[0]), int(parts[1])\n    \n    if n == 0 and m == 0:\n        break\n    \n    growth = []\n    for i in range(n):\n        row = list(map(float, sys.stdin.readline().split()))\n        growth.append(row)\n    \n    result = solve(n, m, growth)\n    print(f\"{result:.2f}\")\n", "perturbed_sampled": ["import sys def solve(n,  = maximum growth after 'step' applications, ending with 'fertilizer' dp = [[-1.0] * n for _ in range(m + 1)] # After first application, size is  1.0 # For each subsequent application  range(n): # Try all possible previous fertilizers for prev in range(n): if dp[step - 1][prev] > 0: # Apply fertilizer 'curr' after fertilizer 'prev' new_size = dp[step - 1][prev] * growth[prev][curr] dp[step][curr] = max(dp[step][curr], new_size) # Find maximum size after m applications max_size = max(dp[m]) return max_size while True: line = sys.stdin.readline().strip() if not line: break parts = line.split() n, m = int(parts[0]), int(parts[1]) if n == 0 and m ==  = list(map(float, sys.stdin.readline().split())) growth.append(row) result = solve(n, m, growth) print(f\"{result:.2f}\")"], "perturbed_original": ["while 1: n, m = map(int, raw_input().split()) if n==0: exit(0) mat = [map(float, raw_input().split())  t in xrange(m-1): dp2 = [-1.0] * n for i in xrange(n): mat_i = mat[i]; dp_i = dp[i] for j in xrange(n): dp2[j] = max(dp2[j], dp_i * mat_i[j]) dp = dp2 print \"%.02f\" % round(max(dp), 2)"], "original_ll": -1.1147741079330444, "sampled_ll": -0.9602656960487366, "all_perturbed_sampled_ll": [-2.1800997257232666], "all_perturbed_original_ll": [-1.9383553266525269], "perturbed_sampled_ll": -2.1800997257232666, "perturbed_original_ll": -1.9383553266525269, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,T,C[10][2],c,d,O[10][2],t,s,u,v,h,*p;D(h){p=C[s]+h;*p&&T>=O[s][h]?*p=!printf(\"%d%c\",*p,d<n|--c?32:10):0;}main(m){for(;~scanf(\"%d%d\",&m,&n);)for(memset(C,T=c=d=0,80);d<n|c;T++){for(s=m;s--;C[s][1]||D(0))D(1);for(;T>=d*10&d<n&c<m*2;C[s=~u?u:v][h]=++d,O[s][h]=T+t,c++)for(h=scanf(\"%d\",&t),u=v=-1,s=m;h&&s--;)*C[s]?C[s][1]||(*O[s]<T+t?!~v||*O[s]>*O[v]?v=s:0:!~u||*O[s]<*O[u]?u=s:0):(u=s,h=0);}}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SPACES 10\n#define MAX_CARS 100\n\ntypedef struct {\n    int id;\n    int parking_time;\n    int arrival_time;\n    int exit_time;\n} Car;\n\ntypedef struct {\n    int lower_car;\n    int upper_car;\n} Space;\n\ntypedef struct {\n    int car_id;\n    int arrival_time;\n} WaitingCar;\n\nint main() {\n    int m, n;\n    \n    while (1) {\n        scanf(\"%d %d\", &m, &n);\n        if (m == 0 && n == 0) break;\n        \n        Car cars[MAX_CARS];\n        Space spaces[MAX_SPACES];\n        WaitingCar waiting[MAX_CARS];\n        int waiting_count = 0;\n        int output[MAX_CARS];\n        int output_count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &cars[i].parking_time);\n            cars[i].id = i + 1;\n            cars[i].arrival_time = i * 10;\n            cars[i].exit_time = -1;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            spaces[i].lower_car = -1;\n            spaces[i].upper_car = -1;\n        }\n        \n        int current_car = 0;\n        int time = 0;\n        \n        while (output_count < n) {\n            // Process exits\n            for (int s = 0; s < m; s++) {\n                if (spaces[s].lower_car != -1) {\n                    int lower_id = spaces[s].lower_car;\n                    if (cars[lower_id].exit_time == time) {\n                        output[output_count++] = cars[lower_id].id;\n                        spaces[s].lower_car = -1;\n                        \n                        if (spaces[s].upper_car != -1) {\n                            int upper_id = spaces[s].upper_car;\n                            output[output_count++] = cars[upper_id].id;\n                            spaces[s].upper_car = -1;\n                        }\n                    }\n                }\n            }\n            \n            // Add arriving cars to waiting list\n            while (current_car < n && cars[current_car].arrival_time == time) {\n                waiting[waiting_count].car_id = current_car;\n                waiting[waiting_count].arrival_time = time;\n                waiting_count++;\n                current_car++;\n            }\n            \n            // Park waiting cars\n            int parked_any = 1;\n            while (waiting_count > 0 && parked_any) {\n                parked_any = 0;\n                int car_id = waiting[0].car_id;\n                int park_time = cars[car_id].parking_time;\n                \n                int best_space = -1;\n                int best_type = -1; // 0: empty, 1: one car\n                int best_diff = 999999;\n                \n                for (int s = 0; s < m; s++) {\n                    if (spaces[s].lower_car == -1) {\n                        if (best_type == -1 || best_type > 0) {\n                            best_space = s;\n                            best_type = 0;\n                        }\n                    } else if (spaces[s].upper_car == -1) {\n                        int remaining = cars[spaces[s].lower_car].exit_time - time;\n                        int diff;\n                        if (remaining >= park_time) {\n                            diff = remaining - park_time;\n                            if (best_type == -1 || best_type > 1 || (best_type == 1 && diff < best_diff)) {\n                                best_space = s;\n                                best_type = 1;\n                                best_diff = diff;\n                            }\n                        } else {\n                            diff = park_time - remaining;\n                            if (best_type == -1 || (best_type == 2 && diff < best_diff)) {\n                                best_space = s;\n                                best_type = 2;\n                                best_diff = diff;\n                            }\n                        }\n                    }\n                }\n                \n                if (best_space != -1) {\n                    if (spaces[best_space].lower_car == -1) {\n                        spaces[best_space].lower_car = car_id;\n                    } else {\n                        spaces[best_space].upper_car = car_id;\n                    }\n                    cars[car_id].exit_time = time + park_time;\n                    \n                    for (int i = 0; i < waiting_count - 1; i++) {\n                        waiting[i] = waiting[i + 1];\n                    }\n                    waiting_count--;\n                    parked_any = 1;\n                } else {\n                    break;\n                }\n            }\n            \n            time++;\n        }\n        \n        for (int i = 0; i < output_count; i++) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", output[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  typedef struct { int id; int  int lower_car; int upper_car; } Space; typedef struct { int car_id; int arrival_time; } WaitingCar; int main() { int m, n; while (1) { scanf(\"%d %d\", &m, &n); if (m == 0 && n == 0) break; Car cars[MAX_CARS]; Space spaces[MAX_SPACES]; WaitingCar waiting[MAX_CARS]; int waiting_count = 0; int output[MAX_CARS]; int output_count = 0; for (int i = 0; i < n; i++) { scanf(\"%d\", &cars[i].parking_time); cars[i].id = i + 1; cars[i].arrival_time = i * 10; cars[i].exit_time = -1; } for (int i = 0; i < m; i++) { spaces[i].lower_car = -1; spaces[i].upper_car = -1; } int current_car = 0; int time = 0; while (output_count  0; s < m; s++) { if (spaces[s].lower_car != -1) { int lower_id = spaces[s].lower_car; if (cars[lower_id].exit_time == time) { output[output_count++] = cars[lower_id].id; spaces[s].lower_car = -1; if (spaces[s].upper_car != -1) { int upper_id = spaces[s].upper_car; output[output_count++] = cars[upper_id].id; spaces[s].upper_car = -1; } } } } // Add arriving cars to waiting list while (current_car < n && cars[current_car].arrival_time == time) { waiting[waiting_count].car_id = current_car; waiting[waiting_count].arrival_time  parked_any = 1; while (waiting_count > 0 && parked_any) { parked_any = 0; int  -1; int best_type =  s++) { if (spaces[s].lower_car == -1) { if (best_type == -1 || best_type > 0) { best_space =  -1) { int remaining = cars[spaces[s].lower_car].exit_time -  remaining - park_time; if (best_type == -1 || best_type > 1 || (best_type == 1 && diff < best_diff)) { best_space = s; best_type = 1; best_diff = diff; } } else { diff =  2 && diff < best_diff)) { best_space = s; best_type = 2; best_diff = diff; } } } } if (best_space != -1) { if (spaces[best_space].lower_car == -1) { spaces[best_space].lower_car = car_id; } else { spaces[best_space].upper_car  { waiting[i] = waiting[i + 1]; } waiting_count--; parked_any = 1; } else { break; } } time++; } for (int i = 0; i <  output[i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["n,T,C[10][2],c,d,O[10][2],t,s,u,v,h,*p;D(h){p=C[s]+h;*p&&T>=O[s][h]?*p=!printf(\"%d%c\",*p,d<n|--c?32:10):0;}main(m){for(;~scanf(\"%d%d\",&m,&n);)for(memset(C,T=c=d=0,80);d<n|c;T++){for(s=m;s--;C[s][1]||D(0))D(1);for(;T>=d*10&d<n&c<m*2;C[s=~u?u:v][h]=++d,O[s][h]=T+t,c++)for(h=scanf(\"%d\",&t),u=v=-1,s=m;h&&s--;)*C[s]?C[s][1]||(*O[s]<T+t?!~v||*O[s]>*O[v]?v=s:0:!~u||*O[s]<*O[u]?u=s:0):(u=s,h=0);}}"], "original_ll": -3.212848424911499, "sampled_ll": -0.578671932220459, "all_perturbed_sampled_ll": [-1.2230902910232544], "all_perturbed_original_ll": [-3.212848424911499], "perturbed_sampled_ll": -1.2230902910232544, "perturbed_original_ll": -3.212848424911499, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX_SIZE = 10;\n\tpublic static final int MAX_CAR = 100;\n\t\n\tpublic static final int M_INF = Integer.MIN_VALUE / 2 + 1;\n\t\n\tpublic static boolean try_fst(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] <= M_INF){\n\t\t\t\tspaces[i][0] = remain_time;\n\t\t\t\tnumbers[i][0] = car_number;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void add_time(int[][] spaces, final int m, final int time){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] <= M_INF){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tspaces[i][0] -= time;\n\t\t\tspaces[i][1] -= time;\n\t\t}\n\t}\n\t\n\tpublic static boolean is_finish(int[][] spaces, final int m){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] > M_INF){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean can_upper(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] >= remain_time && spaces[i][1] <= M_INF){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean try_snd(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){\n\t\tfinal boolean can_upper = can_upper(spaces, numbers, m, remain_time, car_number);\n\t\t\n\t\tint pos = -1;\n\t\tint attr = can_upper ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\t//System.out.println(can_upper + \" \" + (spaces[i][0]<= M_INF) + \" \" + (attr < spaces[i][0]));\n\t\t\t\n\t\t\tif(can_upper && spaces[i][1] <= M_INF && spaces[i][0] >= remain_time && attr > spaces[i][0]){\n\t\t\t\tattr = spaces[i][0];\n\t\t\t\tpos = i;\n\t\t\t}else if(!can_upper && spaces[i][1] <= M_INF && attr < spaces[i][0]){\n\t\t\t\tattr = spaces[i][0];\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(attr  + \" \" + pos + \" \" + can_upper);\n\t\t\n\t\tif(pos < 0){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tspaces[pos][1] = Math.max(spaces[pos][0], remain_time);\n\t\tnumbers[pos][1] = numbers[pos][0];\n\t\tspaces[pos][0] = remain_time;\n\t\tnumbers[pos][0] = car_number;\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static void print(int[][] spaces, int[][] numbers, final int m){\n\t\tSystem.out.println(\"-----------------------------------\");\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(spaces[i][0] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(spaces[i][1] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(numbers[i][0] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(numbers[i][1] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"-----------------------------------\");\n\t\t\n\t}\n\t\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[][] spaces = new int[MAX_SIZE][2];\n\t\tint[][] numbers = new int[MAX_SIZE][2];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(m == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tspaces[i][0] = spaces[i][1] = M_INF;\n\t\t\t\tnumbers[i][0] = numbers[i][1] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> remain_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> number_queue = new LinkedList<Integer>();\n\t\t\t//int time = 0;\n\t\t\t\n\t\t\tLinkedList<Integer> out_numbers = new LinkedList<Integer>();\n\t\t\tfor(int car = 0; ; car++){\n\t\t\t\t//\n\t\t\t\tif(car < n){\n\t\t\t\t\tremain_queue.add(sc.nextInt());\n\t\t\t\t\tnumber_queue.add(car + 1);\n\t\t\t\t}else if(remain_queue.isEmpty() && is_finish(spaces, m)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tadd_time(spaces, m, 10);\n\t\t\t\t//print(spaces, numbers, m);\n\t\t\t\t\n\t\t\t\twhile(true){\n\t\t\t\t\tint min = 1;\n\t\t\t\t\tint min_pos = -1;\n\t\t\t\t\tint min_car = -1;\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\t\t\tif(spaces[i][0] <= M_INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(spaces[i][0] < min){\n\t\t\t\t\t\t\tmin = spaces[i][0];\n\t\t\t\t\t\t\tmin_car = numbers[i][0];\n\t\t\t\t\t\t\tmin_pos = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(min_car == -1){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tspaces[min_pos][0] = spaces[min_pos][1];\n\t\t\t\t\tnumbers[min_pos][0] = numbers[min_pos][1];\n\t\t\t\t\tspaces[min_pos][1] = M_INF;\n\t\t\t\t\tnumbers[min_pos][1] = M_INF;\n\t\t\t\t\tout_numbers.add(min_car);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile(!remain_queue.isEmpty()){\n\t\t\t\t\tfinal int remain_time = remain_queue.poll();\n\t\t\t\t\tfinal int car_number  = number_queue.poll();\n\t\t\t\t\t\n\t\t\t\t\tif(try_fst(spaces, numbers, m, remain_time, car_number)){\n\t\t\t\t\t\t//ok\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(try_snd(spaces, numbers, m, remain_time, car_number)){\n\t\t\t\t\t\t//ok\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//System.out.println(\"fail \" + car_number);\n\t\t\t\t\t\tremain_queue.addFirst(remain_time);\n\t\t\t\t\t\tnumber_queue.addFirst(car_number);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean first = true;\n\t\t\tfor(int i : out_numbers){\n\t\t\t\tif(first){\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tSystem.out.print(i);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.print(\" \" + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\t//System.out.println(out_numbers);\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Car {\n        int id;\n        int arrivalTime;\n        int parkingDuration;\n        int departureTime;\n        \n        Car(int id, int arrivalTime, int parkingDuration) {\n            this.id = id;\n            this.arrivalTime = arrivalTime;\n            this.parkingDuration = parkingDuration;\n            this.departureTime = arrivalTime + parkingDuration;\n        }\n    }\n    \n    static class Space {\n        Car lower;\n        Car upper;\n        \n        boolean isEmpty() {\n            return lower == null && upper == null;\n        }\n        \n        boolean hasSpace() {\n            return lower == null || upper == null;\n        }\n        \n        int getRemainingTime(int currentTime) {\n            if (lower != null) {\n                return Math.max(0, lower.departureTime - currentTime);\n            }\n            return 0;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            \n            if (m == 0 && n == 0) break;\n            \n            List<Car> cars = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int duration = sc.nextInt();\n                cars.add(new Car(i + 1, i * 10, duration));\n            }\n            \n            Space[] spaces = new Space[m];\n            for (int i = 0; i < m; i++) {\n                spaces[i] = new Space();\n            }\n            \n            Queue<Car> waitingQueue = new LinkedList<>();\n            List<Integer> exitOrder = new ArrayList<>();\n            int carIndex = 0;\n            int currentTime = 0;\n            \n            while (exitOrder.size() < n) {\n                // Process departures\n                List<Car> departing = new ArrayList<>();\n                for (int i = 0; i < m; i++) {\n                    Space space = spaces[i];\n                    if (space.lower != null && space.lower.departureTime <= currentTime) {\n                        departing.add(space.lower);\n                        if (space.upper != null && space.upper.departureTime <= currentTime) {\n                            departing.add(space.upper);\n                        }\n                    }\n                }\n                \n                Collections.sort(departing, (a, b) -> {\n                    for (int i = 0; i < m; i++) {\n                        if (spaces[i].lower == a) return -1;\n                        if (spaces[i].lower == b) return 1;\n                    }\n                    return 0;\n                });\n                \n                for (Car car : departing) {\n                    exitOrder.add(car.id);\n                    for (int i = 0; i < m; i++) {\n                        if (spaces[i].lower == car) {\n                            spaces[i].lower = spaces[i].upper;\n                            spaces[i].upper = null;\n                            break;\n                        }\n                    }\n                }\n                \n                // Add arriving cars to queue\n                while (carIndex < n && cars.get(carIndex).arrivalTime <= currentTime) {\n                    waitingQueue.add(cars.get(carIndex));\n                    carIndex++;\n                }\n                \n                // Process parking\n                while (!waitingQueue.isEmpty()) {\n                    Car car = waitingQueue.peek();\n                    int bestSpace = findBestSpace(spaces, car, currentTime);\n                    \n                    if (bestSpace == -1) break;\n                    \n                    waitingQueue.poll();\n                    if (spaces[bestSpace].isEmpty()) {\n                        spaces[bestSpace].lower = car;\n                    } else {\n                        spaces[bestSpace].upper = car;\n                    }\n                }\n                \n                currentTime++;\n            }\n            \n            for (int i = 0; i < exitOrder.size(); i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(exitOrder.get(i));\n            }\n            System.out.println();\n        }\n    }\n    \n    static int findBestSpace(Space[] spaces, Car car, int currentTime) {\n        int bestSpace = -1;\n        int bestDiff = Integer.MAX_VALUE;\n        boolean foundEmpty = false;\n        \n        // First check for empty spaces\n        for (int i = 0; i < spaces.length; i++) {\n            if (spaces[i].isEmpty()) {\n                return i;\n            }\n        }\n        \n        // Check for spaces with one car\n        for (int i = 0; i < spaces.length; i++) {\n            if (spaces[i].hasSpace() && !spaces[i].isEmpty()) {\n                int remaining = spaces[i].getRemainingTime(currentTime);\n                int diff = Math.abs(remaining - car.parkingDuration);\n                \n                if (remaining >= car.parkingDuration) {\n                    if (bestSpace == -1 || diff < bestDiff || \n                        (diff == bestDiff && remaining >= car.parkingDuration)) {\n                        bestSpace = i;\n                        bestDiff = diff;\n                    }\n                } else {\n                    if (bestSpace == -1 || spaces[bestSpace].getRemainingTime(currentTime) >= car.parkingDuration || diff < bestDiff) {\n                        bestSpace = i;\n                        bestDiff = diff;\n                    }\n                }\n            }\n        }\n        \n        return bestSpace;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  arrivalTime; int parkingDuration; int departureTime; Car(int id,  arrivalTime; this.parkingDuration = parkingDuration; this.departureTime = arrivalTime + parkingDuration; } } static class Space { Car lower; Car upper; boolean isEmpty() { return lower == null && upper == null; } boolean hasSpace() { return lower == null || upper == null; } int getRemainingTime(int currentTime) { if (lower != null) { return Math.max(0, lower.departureTime - currentTime); } return 0; } } public static void main(String[] args) { Scanner sc  int n = sc.nextInt(); if (m == 0 && n == 0) break; List<Car> cars = new ArrayList<>(); for (int  = sc.nextInt(); cars.add(new Car(i + 1, i * 10, duration)); } Space[] spaces =   = 0; int currentTime = 0; while (exitOrder.size() < n) { // Process departures List<Car> departing = new ArrayList<>(); for (int i =  if (space.lower != null && space.lower.departureTime <= currentTime) { departing.add(space.lower); if (space.upper != null && space.upper.departureTime <= currentTime) { departing.add(space.upper); } } } Collections.sort(departing, (a, b) -> { for (int i = 0; i < m; i++) { if (spaces[i].lower == a) return -1; if (spaces[i].lower == b) return 1; } return 0; }); for (Car car : departing) { exitOrder.add(car.id); for (int i = 0; i < m; i++) { if (spaces[i].lower == car) { spaces[i].lower = spaces[i].upper; spaces[i].upper = null; break; } } } // Add arriving cars to queue while (carIndex < n && cars.get(carIndex).arrivalTime <= currentTime) { waitingQueue.add(cars.get(carIndex)); carIndex++; } // Process parking while (!waitingQueue.isEmpty()) { Car car = waitingQueue.peek(); int bestSpace = findBestSpace(spaces, car, currentTime); if (bestSpace == -1) break;  spaces[bestSpace].upper = car; } } currentTime++; } for (int i = 0; i < exitOrder.size(); i++) { if (i >  findBestSpace(Space[]  int bestDiff = Integer.MAX_VALUE; boolean foundEmpty = false; // First check  } // Check for spaces with one car for (int i = 0; i < spaces.length; i++) {  diff = Math.abs(remaining - car.parkingDuration); if (remaining >= car.parkingDuration) { if (bestSpace == -1 || diff < bestDiff || (diff == bestDiff && remaining >= car.parkingDuration)) { bestSpace = i; bestDiff = diff; } } else {  < bestDiff) { bestSpace = i; bestDiff = diff; } } } } return bestSpace; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.LinkedList; import java.util.Scanner; public class Main { public static final int MAX_SIZE = 10; public static final int MAX_CAR = 100; public static  static boolean try_fst(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int  <= M_INF){ spaces[i][0] = remain_time; numbers[i][0] = car_number; return true; } } return false; } public static void add_time(int[][] spaces, final int m, final int time){ for(int i = 0; i < m; i++){ if(spaces[i][0] <= M_INF){ continue; } spaces[i][0] -= time; spaces[i][1] -= time; } } public static boolean is_finish(int[][] spaces, final int m){ for(int i = 0; i < m; i++){ if(spaces[i][0] > M_INF){ return false;  int[][] numbers, final int m, final int remain_time, final int car_number){ for(int i = 0; i < m; i++){ if(spaces[i][0] >= remain_time && spaces[i][1] <= M_INF){ return true; } } return false; } public static boolean try_snd(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){ final  Integer.MIN_VALUE; for(int i = 0; i < m; i++){ //System.out.println(can_upper + \" \"  if(can_upper && spaces[i][1] <= M_INF && spaces[i][0] >= remain_time && attr > spaces[i][0]){ attr = spaces[i][0]; pos = i; }else if(!can_upper && spaces[i][1] <= M_INF && attr < spaces[i][0]){ attr = spaces[i][0]; pos = i; } } //System.out.println(attr + \" \" + pos + \" \" + can_upper); if(pos < 0){ return false; } spaces[pos][1] = Math.max(spaces[pos][0], remain_time); numbers[pos][1] = numbers[pos][0]; spaces[pos][0] = remain_time; numbers[pos][0]  0; i  i = 0; i  i = 0; i < m; i++){ System.out.print(numbers[i][0] + \" \"); } System.out.println();  \" \"); } System.out.println(); System.out.println(\"-----------------------------------\"); } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int[][] spaces = new int[MAX_SIZE][2]; int[][] numbers = new int[MAX_SIZE][2]; while(true){ final int m = sc.nextInt(); final int n = sc.nextInt(); if(m == 0 && n == 0){ break; } for(int i = 0; i < m; i++){ spaces[i][0] = spaces[i][1] = M_INF; numbers[i][0] = numbers[i][1] = -1;  LinkedList<Integer>(); //int time = 0; LinkedList<Integer> out_numbers = new LinkedList<Integer>(); for(int car = 0; ; car++){ // if(car < n){ remain_queue.add(sc.nextInt()); number_queue.add(car + 1); }else if(remain_queue.isEmpty() && is_finish(spaces, m)){ break; } add_time(spaces, m, 10); //print(spaces, numbers, m); while(true){ int min =  i = 0; i < m; i++){ if(spaces[i][0] <= M_INF){ continue; }else if(spaces[i][0] < min){ min = spaces[i][0]; min_car = numbers[i][0]; min_pos = i; }  = numbers[min_pos][1]; spaces[min_pos][1] = M_INF; numbers[min_pos][1] = M_INF; out_numbers.add(min_car); } while(!remain_queue.isEmpty()){ final int remain_time = remain_queue.poll(); final int car_number = number_queue.poll(); if(try_fst(spaces,  remain_time, car_number)){ //ok continue; }else{ //System.out.println(\"fail \"  = true; for(int i : out_numbers){ if(first){ first = false; System.out.print(i); }else{  }"], "original_ll": -0.6510891914367676, "sampled_ll": -0.5915046334266663, "all_perturbed_sampled_ll": [-1.3832597732543945], "all_perturbed_original_ll": [-1.3403524160385132], "perturbed_sampled_ll": -1.3832597732543945, "perturbed_original_ll": -1.3403524160385132, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import deque\n\ndef out(time, parking):\n  x = len(parking)\n  outs = []\n  for i in range(x):\n    for j in range(2):\n      if parking[i][j] != None:\n        parking[i][j][0] -= time\n  \n  for i in range(x):\n    c1 = parking[i][0]\n    c2 = parking[i][1]\n    if c1 != None and c2 != None:\n      if c1[0] <= 0 and c2[0] <= 0:\n        outs.append([c2[1], c1[1]])\n        parking[i][0] = None\n        parking[i][1] = None\n      elif c2[0] <= 0:\n        outs.append([c2[1]])\n        parking[i][1] = None\n    elif c1 != None:\n      if c1[0] <= 0:\n        outs.append([c1[1]])\n        parking[i][0] = None\n    elif c2 != None:\n      if c2[0] <= 0:\n        outs.append([c2[1]])\n        parking[i][1] = None\n  outs.sort()\n  lst = []\n  for l in outs:\n    lst += l\n  return lst\n\ndef into(num, time, parking):\n  x = len(parking)\n  times = []\n  for i in range(x):\n    if parking[i] == [None, None]:\n      parking[i][0] = [time, num]\n      return\n    if parking[i][0] == None:\n      times.append((parking[i][1][0], i))\n    elif parking[i][1] == None:\n      times.append((parking[i][0][0], i))\n  times.sort()\n  \n  for t, ind in times:\n    if t >= time:\n      if parking[ind][0] == None:\n        parking[ind][0] = [time, num]\n      else:\n        parking[ind][1] = [time, num]\n      return\n  else:\n    max_t = t\n\n  for t, ind in times:\n    if t == max_t:\n      if parking[ind][0] == None:\n        parking[ind][0] = [time, num]\n      else:\n        parking[ind][1] = [time, num]\n      return\n \nwhile True:\n  m, n = map(int, input().split())\n  if m == 0:\n    break\n  \n  parking = [[None] * 2 for _ in range(m)]\n  wait = deque()\n  space = m * 2\n  ans = []\n  \n  for t in range(120 * n):\n    o = out(1, parking)\n    if o:\n      space += len(o)\n      ans += o\n\n    if t % 10 == 0 and t <= 10 * (n - 1):\n      time = int(input())\n      wait.append((t // 10 + 1, time))\n\n    for i in range(min(space, len(wait))):\n      num, time = wait.popleft()\n      into(num, time, parking)\n      space -= 1\n  print(*ans)\n", "sampled": "import heapq\nfrom collections import deque\n\ndef solve(m, n, parking_times):\n    # spaces[i] = [lower_car, upper_car] where car = (car_id, end_time)\n    spaces = [[None, None] for _ in range(m)]\n    waiting_queue = deque()\n    events = []  # (time, event_type, data)\n    exit_order = []\n    \n    current_time = 0\n    \n    for car_id in range(1, n + 1):\n        arrival_time = (car_id - 1) * 10\n        parking_time = parking_times[car_id - 1]\n        heapq.heappush(events, (arrival_time, 0, car_id, parking_time))  # 0 = arrival\n    \n    while events or waiting_queue:\n        if not events:\n            break\n            \n        current_time, event_type, *data = heapq.heappop(events)\n        \n        if event_type == 0:  # arrival\n            car_id, parking_time = data\n            end_time = current_time + parking_time\n            \n            # Process all exits at current time first\n            exits_now = []\n            temp_events = []\n            while events and events[0][0] == current_time and events[0][1] == 1:\n                temp_events.append(heapq.heappop(events))\n            \n            for ev in temp_events:\n                exits_now.append(ev)\n            \n            # Process exits\n            for exit_event in sorted(exits_now, key=lambda x: x[2]):\n                space_id = x[2]\n                process_exit(spaces, space_id, exit_order)\n            \n            # Put events back\n            for ev in temp_events:\n                if ev not in exits_now:\n                    heapq.heappush(events, ev)\n            \n            # Try to park cars from waiting queue\n            while waiting_queue:\n                w_car_id, w_parking_time, w_arrival = waiting_queue[0]\n                w_end_time = w_arrival + w_parking_time\n                space_idx = find_space(spaces, w_parking_time, current_time)\n                if space_idx == -1:\n                    break\n                waiting_queue.popleft()\n                park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events)\n            \n            # Try to park current car\n            space_idx = find_space(spaces, parking_time, current_time)\n            if space_idx == -1:\n                waiting_queue.append((car_id, parking_time, current_time))\n            else:\n                park_car(spaces, space_idx, car_id, end_time, current_time, events)\n                \n        elif event_type == 1:  # exit\n            space_id = data[0]\n            process_exit(spaces, space_id, exit_order)\n            \n            # Try to park cars from waiting queue\n            while waiting_queue:\n                w_car_id, w_parking_time, w_arrival = waiting_queue[0]\n                w_end_time = current_time + w_parking_time\n                space_idx = find_space(spaces, w_parking_time, current_time)\n                if space_idx == -1:\n                    break\n                waiting_queue.popleft()\n                park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events)\n    \n    return exit_order\n\ndef find_space(spaces, parking_time, current_time):\n    empty_spaces = []\n    one_car_spaces = []\n    \n    for i, space in enumerate(spaces):\n        if space[0] is None:\n            empty_spaces.append(i)\n        elif space[1] is None:\n            remaining_time = space[0][1] - current_time\n            one_car_spaces.append((i, remaining_time))\n    \n    if empty_spaces:\n        return min(empty_spaces)\n    \n    if not one_car_spaces:\n        return -1\n    \n    # Find best space\n    ge_spaces = [(i, rt) for i, rt in one_car_spaces if rt >= parking_time]\n    lt_spaces = [(i, rt) for i, rt in one_car_spaces if rt < parking_time]\n    \n    if ge_spaces:\n        best = min(ge_spaces, key=lambda x: (x[1] - parking_time, x[0]))\n        return best[0]\n    else:\n        best = min(lt_spaces, key=lambda x: (parking_time - x[1], x[0]))\n        return best[0]\n\ndef park_car(spaces, space_idx, car_id, end_time, current_time, events):\n    if spaces[space_idx][0] is None:\n        spaces[space_idx][0] = (car_id, end_time)\n        heapq.heappush(events, (end_time, 1, space_idx))\n    else:\n        spaces[space_idx][1] = (car_id, end_time)\n\ndef process_exit(spaces, space_id, exit_order):\n    if spaces[space_id][1] is not None:\n        exit_order.append(spaces[space_id][0][0])\n        exit_order.append(spaces[space_id][1][0])\n        spaces[space_id][0] = None\n        spaces[space_id][1] = None\n    elif spaces[space_id][0] is not None:\n        exit_order.append(spaces[space_id][0][0])\n        spaces[space_id][0] = None\n\nwhile True:\n    line = input().split()\n    m, n = int(line[0]), int(line[1])\n    if m == 0 and n == 0:\n        break\n    \n    parking_times = []\n    for _ in range(n):\n        parking_times.append(int(input()))\n    \n    result = solve(m, n, parking_times)\n    print(' '.join(map(str, result)))\n", "perturbed_sampled": ["import heapq from collections import deque def solve(m, n, parking_times): # spaces[i] = [lower_car, upper_car] where car = (car_id, end_time) spaces = [[None, None] for _ in range(m)] waiting_queue = deque() events = [] # (time, event_type, data) exit_order = [] current_time = 0 for car_id in range(1, n + 1): arrival_time = (car_id - 1)  car_id,  not events: break current_time, event_type, *data = heapq.heappop(events) if event_type == 0: # arrival car_id, parking_time = data end_time =  and  in temp_events: exits_now.append(ev) #  = x[2] process_exit(spaces, space_id, exit_order) # Put events back for ev in temp_events: if ev not in exits_now: heapq.heappush(events, ev) # Try to park cars  w_end_time = w_arrival + w_parking_time space_idx = find_space(spaces, w_parking_time, current_time) if space_idx == -1: break waiting_queue.popleft() park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events) # Try to park current car space_idx = find_space(spaces, parking_time, current_time) if space_idx == -1: waiting_queue.append((car_id, parking_time, current_time)) else: park_car(spaces, space_idx, car_id, end_time, current_time, events) elif event_type == 1: # exit space_id = data[0] process_exit(spaces, space_id, exit_order) # Try to park  waiting_queue[0] w_end_time = current_time + w_parking_time space_idx = find_space(spaces, w_parking_time, current_time) if space_idx == -1: break waiting_queue.popleft() park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events) return exit_order def find_space(spaces, parking_time, current_time): empty_spaces = [] one_car_spaces = [] for i, space in enumerate(spaces): if space[0] is None: empty_spaces.append(i) elif space[1] is  return min(empty_spaces) if not one_car_spaces: return -1 # Find best space ge_spaces = [(i, rt) for i, rt in one_car_spaces if rt >= parking_time] lt_spaces = [(i, rt) for i, rt in one_car_spaces if rt < parking_time] if ge_spaces: best = min(ge_spaces, key=lambda x: (x[1] - parking_time, x[0]))  x[1], x[0])) return best[0] def park_car(spaces, space_idx, car_id, end_time, current_time, events): if spaces[space_idx][0] is None: spaces[space_idx][0] = (car_id,  def process_exit(spaces, space_id, exit_order): if spaces[space_id][1] is not None: exit_order.append(spaces[space_id][0][0]) exit_order.append(spaces[space_id][1][0]) spaces[space_id][0] = None spaces[space_id][1] = None elif spaces[space_id][0] is not None: exit_order.append(spaces[space_id][0][0]) spaces[space_id][0] = None while True: line = input().split() m, n = int(line[0]), int(line[1])  = []  print(' '.join(map(str, result)))"], "perturbed_original": ["from collections import deque def out(time, parking): x = len(parking) outs = [] for i in range(x): for j in range(2): if parking[i][j] != None: parking[i][j][0] -= time for i in range(x): c1 = parking[i][0] c2 = parking[i][1] if c1 != None and c2 != None: if c1[0] <= 0 and c2[0] <= 0: outs.append([c2[1], c1[1]]) parking[i][0]  <= 0: outs.append([c1[1]]) parking[i][0]  outs.append([c2[1]]) parking[i][1] =  += l return lst def into(num, time, parking):  if parking[i] == [None, None]: parking[i][0] = [time, num] return if parking[i][0] == None: times.append((parking[i][1][0], i)) elif parking[i][1] == None: times.append((parking[i][0][0], i)) times.sort() for t, ind in  = [time, num] else: parking[ind][1] = [time, num] return else: max_t = t for t, ind in times: if t == max_t: if parking[ind][0] == None:  while True: m, n = map(int, input().split()) if m == 0: break parking = [[None] * 2 for _ in range(m)] wait = deque() space = m * 2 ans = [] for t in range(120 * n): o = out(1, parking) if o: space += len(o) ans += o if t  - 1): time = int(input()) wait.append((t // 10 + 1, time)) for i in range(min(space, len(wait))): num, time = wait.popleft() into(num, time, parking) space -= 1 print(*ans)"], "original_ll": -0.8700494170188904, "sampled_ll": -0.7929011583328247, "all_perturbed_sampled_ll": [-1.5657469034194946], "all_perturbed_original_ll": [-1.6686307191848755], "perturbed_sampled_ll": -1.5657469034194946, "perturbed_original_ll": -1.6686307191848755, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0193: Convenience Store\n// 2017.8.25 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define abs(a) ((a)>=0?(a):(-(a)))\n//#define min(a,b) ((a)<=(b)?(a):(b))\n\ntypedef struct { int r, c, f; } T;\nT shop[25]; int n, S, N;\nint R, C;\n\nint hexDistance(int r1, int c1, int r2, int c2)\n{\n\tint dr, dc, c;\n\tdr = abs(r2 - r1), dc = abs(c2 - c1);\n\tif (r2 == r1) return dc;\n\tif (c2 == c1) return dr;\n\tif (r2 < r1) c = r2, r2 = r1, r1 = c, c = c2, c2 = c1, c1 = c;\n\tif (c2 >= c1) {\n\t\tc = c1 + (dr+1-(r1&1))/2;\n\t\tif (c2 >= c) dr += abs(c-c2);\n\t} else {\n\t\tc = c1 - (dr+(r1&1))/2;\n\t\tif (c2 <= c) dr += abs(c-c2);\n\t}\n\treturn dr;\n}\n\nint belong(int r, int c)\n{\n\tint i, d, k, min;\n\tfor (min = -1, d = -2, k = 0, i = 1; i <= n; i++) {\n\t\td = hexDistance(shop[i].r, shop[i].c, r, c);\n\t\tif (min < 0 || d < min) min = d, k = i;\n\t\telse if (d == min) k = 0;\n\t}\n\treturn k;\n}\n\nint main()\n{\n\tint i, r, c;\n\tint ans;\n\n\twhile (scanf(\"%d%d\", &C, &R) && C) {\n\t\tscanf(\"%d\", &S);\n\t\tfor (n = 1, i = 0; i < S; i++) {\n\t\t\tscanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0;\n\t\t}\n\t\tscanf(\"%d\", &N);\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0;\n\t\t}\n\t\tn--;\n\t\tfor (r = 1; r <= R; r++) for (c = 1; c <= C; c++)\n\t\t\tif ((i = belong(r, c)) > 0) shop[i].f++;\n\t\tfor (ans = -1, i = S+1; i <= n; i++) if (shop[i].f > ans) ans = shop[i].f;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint dx_odd[6] = {0, 1, 1, 0, -1, -1};\nint dy_odd[6] = {-1, -1, 0, 1, 0, -1};\nint dx_even[6] = {-1, 0, 1, 1, 1, 0};\nint dy_even[6] = {-1, -1, 0, 1, 0, -1};\n\ntypedef struct {\n    int x, y, dist;\n} Node;\n\nint dist[101][101];\nint queue[20000][2];\nint qfront, qrear;\n\nvoid bfs(int sx, int sy, int m, int n) {\n    int visited[101][101] = {0};\n    qfront = qrear = 0;\n    queue[qrear][0] = sx;\n    queue[qrear][1] = sy;\n    qrear++;\n    visited[sx][sy] = 1;\n    dist[sx][sy] = 0;\n    \n    while (qfront < qrear) {\n        int cx = queue[qfront][0];\n        int cy = queue[qfront][1];\n        qfront++;\n        \n        int *dx = (cy % 2 == 1) ? dx_odd : dx_even;\n        int *dy = (cy % 2 == 1) ? dy_odd : dy_even;\n        \n        for (int i = 0; i < 6; i++) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n            \n            if (nx >= 1 && nx <= m && ny >= 1 && ny <= n && !visited[nx][ny]) {\n                visited[nx][ny] = 1;\n                dist[nx][ny] = dist[cx][cy] + 1;\n                queue[qrear][0] = nx;\n                queue[qrear][1] = ny;\n                qrear++;\n            }\n        }\n    }\n}\n\nint main() {\n    int m, n;\n    \n    while (scanf(\"%d %d\", &m, &n) == 2) {\n        if (m == 0 && n == 0) break;\n        \n        int s;\n        scanf(\"%d\", &s);\n        Point stores[11];\n        for (int i = 0; i < s; i++) {\n            scanf(\"%d %d\", &stores[i].x, &stores[i].y);\n        }\n        \n        int t;\n        scanf(\"%d\", &t);\n        Point candidates[11];\n        for (int i = 0; i < t; i++) {\n            scanf(\"%d %d\", &candidates[i].x, &candidates[i].y);\n        }\n        \n        int max_coverage = 0;\n        \n        for (int cand = 0; cand < t; cand++) {\n            int coverage = 0;\n            \n            for (int x = 1; x <= m; x++) {\n                for (int y = 1; y <= n; y++) {\n                    int min_dist_cand = 1000000;\n                    int min_dist_store = 1000000;\n                    int count_min_store = 0;\n                    \n                    bfs(candidates[cand].x, candidates[cand].y, m, n);\n                    min_dist_cand = dist[x][y];\n                    \n                    for (int i = 0; i < s; i++) {\n                        bfs(stores[i].x, stores[i].y, m, n);\n                        int d = dist[x][y];\n                        if (d < min_dist_store) {\n                            min_dist_store = d;\n                            count_min_store = 1;\n                        } else if (d == min_dist_store) {\n                            count_min_store++;\n                        }\n                    }\n                    \n                    if (min_dist_cand < min_dist_store) {\n                        coverage++;\n                    } else if (min_dist_cand == min_dist_store && count_min_store == 0) {\n                        coverage++;\n                    }\n                }\n            }\n            \n            if (coverage > max_coverage) {\n                max_coverage = coverage;\n            }\n        }\n        \n        printf(\"%d\\n\", max_coverage);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int x, y; }  int dy_odd[6] = {-1, -1, 0, 1, 0, -1}; int dx_even[6] = {-1, 0, 1, 1, 1, 0}; int dy_even[6]  int x, y, dist; } Node; int dist[101][101]; int queue[20000][2]; int qfront,  { int visited[101][101] =  = sy; qrear++; visited[sx][sy] = 1; dist[sx][sy] = 0; while (qfront < qrear) { int cx = queue[qfront][0]; int cy = queue[qfront][1]; qfront++; int *dx = (cy % 2 == 1) ? dx_odd : dx_even; int *dy = (cy % 2 == 1) ? dy_odd : dy_even; for (int i = 0; i < 6;  = cy + dy[i]; if (nx >= 1 &&  n && !visited[nx][ny]) { visited[nx][ny] = 1; dist[nx][ny] = dist[cx][cy] + 1; queue[qrear][0] = nx; queue[qrear][1] = ny; qrear++; } } } } int main() { int m, n; while (scanf(\"%d %d\", &m,  == 0)  = 0; i < s; i++) { scanf(\"%d %d\", &stores[i].x, &stores[i].y); } int t; scanf(\"%d\", &t); Point candidates[11]; for (int i = 0; i < t; i++) { scanf(\"%d %d\", &candidates[i].x, &candidates[i].y); } int max_coverage = 0; for (int cand = 0; cand < t; cand++) { int coverage = 0; for (int x = 1; x <= m; x++) { for (int y = 1; y <= n; y++) { int min_dist_cand = 1000000; int min_dist_store = 1000000; int count_min_store = 0; bfs(candidates[cand].x, candidates[cand].y, m, n); min_dist_cand = dist[x][y]; for (int i = 0; i < s; i++) { bfs(stores[i].x, stores[i].y, m, n); int d = dist[x][y]; if (d < min_dist_store)  (d == min_dist_store)  } else if (min_dist_cand == min_dist_store && count_min_store == 0) { coverage++; } }  } printf(\"%d\\n\", max_coverage); } return 0; }"], "perturbed_original": ["  struct { int r, c, f; } T; T shop[25]; int  c1, int r2, int c2) { int dr, dc, c; dr  r2 = r1, r1 = c, c = c2, c2 = c1, c1 = c; if (c2 >= c1) { c = c1 + (dr+1-(r1&1))/2; if  = c1 - (dr+(r1&1))/2; if (c2 <= c) dr += abs(c-c2); } return dr; } int belong(int r, int c) { int i, d, k, min; for (min = -1, d = -2, k = 0, i = 1; i <= n; i++) { d = hexDistance(shop[i].r, shop[i].c, r, c); if (min < 0 || d < min) min = d, k = i; else if (d == min) k = 0; } return k; } int main() { int i, r, c; int ans; while (scanf(\"%d%d\", &C, &R) && C) { scanf(\"%d\", &S); for (n = 1, i = 0; i < S; i++) { scanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0; } scanf(\"%d\", &N); for (i = 0; i < N; i++) { scanf(\"%d%d\", &shop[n].c, &shop[n].r),  <= R; r++) for (c = 1; c <= C; c++) if ((i = belong(r, c)) > 0) shop[i].f++; for (ans = -1, i = S+1; i <= n; i++) if (shop[i].f > ans) ans = shop[i].f; printf(\"%d\\n\", ans); } return 0; }"], "original_ll": -1.0939298868179321, "sampled_ll": -0.48738744854927063, "all_perturbed_sampled_ll": [-1.0935416221618652], "all_perturbed_original_ll": [-1.4664418697357178], "perturbed_sampled_ll": -1.0935416221618652, "perturbed_original_ll": -1.4664418697357178, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tfor(int m,n,x,a[][];(m=s.nextInt())>0;){\n\t\t\tn=s.nextInt();\n\t\t\tx=s.nextInt();\n\t\t\ta=new int[n][m];\n\t\t\tDeque<int[]>q=new ArrayDeque<int[]>();\n\t\t\tfor(int i=0;i<x;++i){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\ta[u][v]=1;\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t}\n\t\t\tint[][]dm={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}};\n\t\t\tint[][]dn={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}};\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[]t=q.poll();\n\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\tint u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i];\n\t\t\t\t\tif(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){\n\t\t\t\t\t\tq.add(new int[]{u,v,a[u][v]=t[2]+1});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=0;\n\t\t\tfor(x=s.nextInt();x-->0;){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\tif(a[u][v]>1){\n\t\t\t\t\tint[][] tmp = new int[n][];\n\t\t\t\t\tfor(int i=0;i<n;++i)\n\t\t\t\t\t\ttmp[i]=Arrays.copyOf(a[i],m);\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t\tint c=1;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint[]t=q.poll();\n\t\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\t\tint u1=t[0]+dn[t[0]%2][i],v1=t[1]+dm[t[0]%2][i];\n\t\t\t\t\t\tif(0<=u1&&u1<n&&0<=v1&&v1<m&&tmp[u1][v1]>t[2]+1){\n\t\t\t\t\t\t\t++c;\n\t\t\t\t\t\t\tq.add(new int[]{u1,v1,tmp[u1][v1]=t[2]+1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr=r>c?r:c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int m, n;\n    static int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, -1}, {-1, 1}};\n    \n    static int[][] getNeighbors(int x, int y) {\n        int[][] neighbors = new int[6][2];\n        if (y % 2 == 1) {\n            neighbors[0] = new int[]{x + 1, y};\n            neighbors[1] = new int[]{x - 1, y};\n            neighbors[2] = new int[]{x, y + 1};\n            neighbors[3] = new int[]{x, y - 1};\n            neighbors[4] = new int[]{x - 1, y + 1};\n            neighbors[5] = new int[]{x - 1, y - 1};\n        } else {\n            neighbors[0] = new int[]{x + 1, y};\n            neighbors[1] = new int[]{x - 1, y};\n            neighbors[2] = new int[]{x + 1, y + 1};\n            neighbors[3] = new int[]{x + 1, y - 1};\n            neighbors[4] = new int[]{x, y + 1};\n            neighbors[5] = new int[]{x, y - 1};\n        }\n        return neighbors;\n    }\n    \n    static int[][] computeDistances(int sx, int sy) {\n        int[][] dist = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            Arrays.fill(dist[i], -1);\n        }\n        \n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{sx, sy, 0});\n        dist[sx][sy] = 0;\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int x = curr[0];\n            int y = curr[1];\n            int d = curr[2];\n            \n            int[][] neighbors = getNeighbors(x, y);\n            for (int[] neighbor : neighbors) {\n                int nx = neighbor[0];\n                int ny = neighbor[1];\n                if (nx >= 1 && nx <= m && ny >= 1 && ny <= n && dist[nx][ny] == -1) {\n                    dist[nx][ny] = d + 1;\n                    queue.offer(new int[]{nx, ny, d + 1});\n                }\n            }\n        }\n        \n        return dist;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            m = sc.nextInt();\n            n = sc.nextInt();\n            if (m == 0 && n == 0) break;\n            \n            int s = sc.nextInt();\n            int[][] existing = new int[s][2];\n            for (int i = 0; i < s; i++) {\n                existing[i][0] = sc.nextInt();\n                existing[i][1] = sc.nextInt();\n            }\n            \n            int t = sc.nextInt();\n            int[][] candidates = new int[t][2];\n            for (int i = 0; i < t; i++) {\n                candidates[i][0] = sc.nextInt();\n                candidates[i][1] = sc.nextInt();\n            }\n            \n            int[][][] existingDist = new int[s][][];\n            for (int i = 0; i < s; i++) {\n                existingDist[i] = computeDistances(existing[i][0], existing[i][1]);\n            }\n            \n            int maxCoverage = 0;\n            \n            for (int c = 0; c < t; c++) {\n                int[][] newDist = computeDistances(candidates[c][0], candidates[c][1]);\n                int coverage = 0;\n                \n                for (int x = 1; x <= m; x++) {\n                    for (int y = 1; y <= n; y++) {\n                        boolean isExisting = false;\n                        for (int i = 0; i < s; i++) {\n                            if (existing[i][0] == x && existing[i][1] == y) {\n                                isExisting = true;\n                                break;\n                            }\n                        }\n                        if (isExisting) continue;\n                        \n                        if (candidates[c][0] == x && candidates[c][1] == y) continue;\n                        \n                        int minDist = newDist[x][y];\n                        if (minDist == -1) continue;\n                        \n                        boolean uniqueMin = true;\n                        for (int i = 0; i < s; i++) {\n                            int d = existingDist[i][x][y];\n                            if (d == -1) continue;\n                            if (d < minDist) {\n                                uniqueMin = false;\n                                break;\n                            } else if (d == minDist) {\n                                uniqueMin = false;\n                                break;\n                            }\n                        }\n                        \n                        if (uniqueMin) {\n                            coverage++;\n                        }\n                    }\n                }\n                \n                maxCoverage = Math.max(maxCoverage, coverage);\n            }\n            \n            System.out.println(maxCoverage);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int m, n; static int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, -1}, {-1, 1}}; static int[][] getNeighbors(int  (y %  = new int[]{x, y + 1}; neighbors[3] = new int[]{x, y - 1}; neighbors[4] = new int[]{x - 1, y +  } else  new int[]{x - 1, y}; neighbors[2] = new int[]{x + 1, y + 1}; neighbors[3] = new int[]{x + 1, y  =  int[][] computeDistances(int sx, int sy) { int[][] dist = new  i <= m; i++) { Arrays.fill(dist[i], -1); } Queue<int[]> queue = new LinkedList<>(); queue.offer(new int[]{sx, sy, 0}); dist[sx][sy] = 0; while (!queue.isEmpty()) { int[] curr = queue.poll(); int x = curr[0]; int y = curr[1]; int d = curr[2]; int[][] neighbors = getNeighbors(x, y); for (int[] neighbor : neighbors) { int nx = neighbor[0]; int ny = neighbor[1]; if (nx >= 1 && nx <= m && ny >= 1 && ny <= n &&   } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { m = sc.nextInt();  0) break; int s = sc.nextInt(); int[][] existing = new int[s][2]; for (int i = 0; i < s; i++) { existing[i][0]  int[][] candidates = new int[t][2]; for (int i = 0; i < t; i++) { candidates[i][0] = sc.nextInt(); candidates[i][1] = sc.nextInt(); } int[][][] existingDist =  i++) { existingDist[i] = computeDistances(existing[i][0], existing[i][1]); } int maxCoverage = 0;  int[][] newDist = computeDistances(candidates[c][0], candidates[c][1]); int coverage = 0; for (int x = 1; x <= m; x++) { for (int y = 1; y <= n; y++) { boolean isExisting = false; for (int i = 0; i < s; i++) { if (existing[i][0] == x && existing[i][1] == y) { isExisting = true; break; } } if (isExisting) continue; if (candidates[c][0] == x && candidates[c][1] == y) continue; int minDist = newDist[x][y]; if (minDist == -1) continue; boolean uniqueMin = true; for (int i  existingDist[i][x][y]; if (d == -1) continue; if (d < minDist) { uniqueMin = false; break; } else if (d == minDist) { uniqueMin = false; break; } } if (uniqueMin) { coverage++; } } } maxCoverage = Math.max(maxCoverage, coverage); } System.out.println(maxCoverage); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main  for(int m,n,x,a[][];(m=s.nextInt())>0;){ n=s.nextInt(); x=s.nextInt(); a=new int[n][m]; Deque<int[]>q=new ArrayDeque<int[]>(); for(int i=0;i<x;++i){ int v=s.nextInt()-1,u=s.nextInt()-1; a[u][v]=1; q.add(new int[]{u,v,1}); } int[][]dm={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}}; int[][]dn={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}}; while(!q.isEmpty()){ int[]t=q.poll(); for(int i=0;i<6;++i){ int u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i]; if(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){ q.add(new int[]{u,v,a[u][v]=t[2]+1}); } } } int r=0;  i=0;i<n;++i) tmp[i]=Arrays.copyOf(a[i],m); q.add(new int[]{u,v,1}); int c=1; while(!q.isEmpty()){ int[]t=q.poll(); for(int i=0;i<6;++i){ int u1=t[0]+dn[t[0]%2][i],v1=t[1]+dm[t[0]%2][i]; if(0<=u1&&u1<n&&0<=v1&&v1<m&&tmp[u1][v1]>t[2]+1){ ++c; q.add(new int[]{u1,v1,tmp[u1][v1]=t[2]+1}); } } } r=r>c?r:c; } } System.out.println(r); } } }"], "original_ll": -0.8560478687286377, "sampled_ll": -0.35556843876838684, "all_perturbed_sampled_ll": [-1.0295963287353516], "all_perturbed_original_ll": [-1.093595027923584], "perturbed_sampled_ll": -1.0295963287353516, "perturbed_original_ll": -1.093595027923584, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#Deven-Eleven:\nimport re\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n\nwhile True:\n    data = raw_input().sprit()\n    if data == \"0 0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()", "sampled": "from collections import deque\n\ndef get_neighbors(x, y, m, n):\n    neighbors = []\n    if y % 2 == 1:  # odd row\n        # neighbors for odd row\n        candidates = [\n            (x-1, y-1), (x, y-1),    # upper left, upper right\n            (x-1, y), (x+1, y),       # left, right\n            (x-1, y+1), (x, y+1)      # lower left, lower right\n        ]\n    else:  # even row\n        # neighbors for even row\n        candidates = [\n            (x, y-1), (x+1, y-1),     # upper left, upper right\n            (x-1, y), (x+1, y),       # left, right\n            (x, y+1), (x+1, y+1)      # lower left, lower right\n        ]\n    \n    for nx, ny in candidates:\n        if 1 <= nx <= m and 1 <= ny <= n:\n            neighbors.append((nx, ny))\n    \n    return neighbors\n\ndef bfs_distances(start_x, start_y, m, n):\n    distances = {}\n    queue = deque([(start_x, start_y, 0)])\n    distances[(start_x, start_y)] = 0\n    \n    while queue:\n        x, y, dist = queue.popleft()\n        \n        for nx, ny in get_neighbors(x, y, m, n):\n            if (nx, ny) not in distances:\n                distances[(nx, ny)] = dist + 1\n                queue.append((nx, ny, dist + 1))\n    \n    return distances\n\ndef count_covered_blocks(stores, m, n):\n    # For each block, find the minimum distance to any store\n    min_distances = {}\n    \n    for i, (sx, sy) in enumerate(stores):\n        distances = bfs_distances(sx, sy, m, n)\n        for (x, y), dist in distances.items():\n            if (x, y) not in min_distances:\n                min_distances[(x, y)] = []\n            min_distances[(x, y)].append((dist, i))\n    \n    # Count blocks covered by each store\n    coverage = [0] * len(stores)\n    \n    for (x, y), dists in min_distances.items():\n        dists.sort()\n        if len(dists) > 0:\n            min_dist = dists[0][0]\n            stores_at_min_dist = [store_idx for dist, store_idx in dists if dist == min_dist]\n            \n            # Only count if exactly one store is closest\n            if len(stores_at_min_dist) == 1:\n                coverage[stores_at_min_dist[0]] += 1\n    \n    return coverage\n\nwhile True:\n    m, n = map(int, input().split())\n    if m == 0 and n == 0:\n        break\n    \n    s = int(input())\n    existing_stores = []\n    for _ in range(s):\n        x, y = map(int, input().split())\n        existing_stores.append((x, y))\n    \n    t = int(input())\n    candidates = []\n    for _ in range(t):\n        p, q = map(int, input().split())\n        candidates.append((p, q))\n    \n    max_coverage = 0\n    \n    for candidate in candidates:\n        # Create a list of all stores including the new one\n        all_stores = existing_stores + [candidate]\n        \n        # Count coverage for all stores\n        coverage = count_covered_blocks(all_stores, m, n)\n        \n        # The last store in the list is the new one\n        new_store_coverage = coverage[-1]\n        \n        max_coverage = max(max_coverage, new_store_coverage)\n    \n    print(max_coverage)\n", "perturbed_sampled": ["from collections import deque def get_neighbors(x, y, m, n): neighbors = [] if y % 2 == 1: # odd row # neighbors for odd row candidates = [ (x-1, y-1), (x, y-1), # upper left, upper right (x-1, y),  lower left, lower right ] else: # even row # neighbors for even row candidates = [ (x, y-1), (x+1, y-1), #  right (x,  nx, ny in candidates: if 1 <= nx <= m and 1 <= ny <= n: neighbors.append((nx, ny)) return neighbors def bfs_distances(start_x, start_y, m, n): distances = {} queue = deque([(start_x, start_y, 0)]) distances[(start_x, start_y)] = 0 while  get_neighbors(x, y, m, n): if (nx, ny) not in distances: distances[(nx, ny)] = dist + 1 queue.append((nx,  # For each block, find the minimum distance to  enumerate(stores): distances = bfs_distances(sx, sy, m, n) for (x, y), dist in distances.items(): if (x, y) not in min_distances: min_distances[(x, y)] = [] min_distances[(x, y)].append((dist, i)) # Count  for (x, y), dists in min_distances.items(): dists.sort() if len(dists) > 0: min_dist = dists[0][0]  == min_dist] # Only count if exactly one store is closest if len(stores_at_min_dist) == 1: coverage[stores_at_min_dist[0]] += 1 return coverage while True: m, n = map(int, input().split()) if m == 0 and n == 0: break s = int(input()) existing_stores = [] for _ in range(s): x, y = map(int, input().split()) existing_stores.append((x, y)) t = int(input()) candidates = [] for _ in range(t):  for candidate in candidates: # Create a list of  [candidate] # Count coverage for all stores coverage = count_covered_blocks(all_stores, m, n)  one new_store_coverage = coverage[-1] max_coverage = max(max_coverage, new_store_coverage) print(max_coverage)"], "perturbed_original": ["#Deven-Eleven: import re D = (((-1, -1), (0, -1), (1, 0), (0, 1),  y, x, step = q.pop(0) if cover[y][x] >= 0: continue cover[y][x] = step for dx, dy in D[y % 2]: ny, nx = y + dy, x + dx if 0 <= ny < n and 0 <= nx < m: q.append((ny, nx, step + 1)) return cover def solve(): scover =  in xrange(m)] for y in xrange(n)] def count(cover): ret = 0 for y in xrange(n): for x in xrange(m): if cover[y][x] < min_cover[y][x]: ret += 1 return ret return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos) while True: data = raw_input().sprit() if data == \"0 0\": break m, n = map(int, data.split()) s = input() spos = [map(int, raw_input().split()) for _ in xrange(s)] t = input() tpos = [map(int, raw_input().split()) for _ in xrange(t)] print solve()"], "original_ll": -1.0495473146438599, "sampled_ll": -0.6586393713951111, "all_perturbed_sampled_ll": [-1.6478192806243896], "all_perturbed_original_ll": [-1.9327912330627441], "perturbed_sampled_ll": -1.6478192806243896, "perturbed_original_ll": -1.9327912330627441, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "M,N,D;P[101][4][21][21];S[21][21];C[4][21][21];J[4][21][21];h1,h2;i,n,v1,v2,k;xs,ys,xg,yg,T;d,x,y,d1,t1,x1,y1;vx[]={1,0,-1,0},vy[]={0,1,0,-1};void set_road(int A[][21][21],int h1,int v1,int h2,int v2,int d){if(v1==v2){A[h1<h2?1:3][v1][h1-96]=d;A[h1<h2?3:1][v2][h2-96]=d;}else{A[v1<v2?0:2][v1][h1-96]=d;A[v1<v2?2:0][v2][h2-96]=d;}}main(){for(;scanf(\"%d%d%d%d\",&M,&N,&D,&n),M;){memset(P,0,sizeof(P));memset(S,0,sizeof(S));memset(C,0,sizeof(C));memset(J,0,sizeof(J));for(i=0;i<n;i++){scanf(\"\\n%c-%d%d\",&h1,&v1,&k);S[v1][h1-96]=k;}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);set_road(C,h1,v1,h2,v2,1);}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d%d\",&h1,&v1,&h2,&v2,&k);set_road(J,h1,v1,h2,v2,k);}scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);xs=v1;ys=h1-96;xg=v2;yg=h2-96;P[0][0][xs][ys]=1;for(T=0;;T++)for(d=0;d<4;d++){if(P[T][d][xg][yg]){printf(\"%d\\n\",T);goto E;}for(x=1;x<=N;x++)for(y=1;y<=M;y++)if(P[T][d][x][y]&&(!S[x][y]||T/S[x][y]%2!=d%2))for(d1=0;d1<4;d1++){t1=T+D+J[d1][x][y];x1=x+vx[d1];y1=y+vy[d1];if(d1!=(d^2)&&!C[d1][x][y]&&t1<=100&&x1>=1&&x1<=N&&y1>=1&&y1<=M)P[t1][d1][x1][y1]=1;}}E:;}return 0;}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_N 20\n#define INF 1000000\n\ntypedef struct {\n    int r, c, time, dir;\n} State;\n\nint M, N, D;\nint signal[MAX_N][MAX_N];\nint period[MAX_N][MAX_N];\nint construction[MAX_N][MAX_N][MAX_N][MAX_N];\nint traffic[MAX_N][MAX_N][MAX_N][MAX_N];\nint visited[MAX_N][MAX_N][101][4];\n\nState queue[1000000];\nint head, tail;\n\nint dr[] = {0, 0, -1, 1};\nint dc[] = {-1, 1, 0, 0};\n\nvoid parseIntersection(char *s, int *r, int *c) {\n    char h[10];\n    int v;\n    sscanf(s, \"%[^-]-%d\", h, &v);\n    *r = h[0] - 'a';\n    *c = v - 1;\n}\n\nint canPass(int r, int c, int time, int from_dir, int to_dir) {\n    if (signal[r][c] == 0) return 1;\n    \n    int k = period[r][c];\n    int cycle = time % (2 * k);\n    int is_ns_green = (cycle < k);\n    \n    if (to_dir == 2 || to_dir == 3) {\n        return is_ns_green;\n    } else {\n        return !is_ns_green;\n    }\n}\n\nint solve(int sr, int sc, int er, int ec) {\n    memset(visited, 0, sizeof(visited));\n    \n    head = tail = 0;\n    queue[tail].r = sr;\n    queue[tail].c = sc;\n    queue[tail].time = 0;\n    queue[tail].dir = 1;\n    tail++;\n    visited[sr][sc][0][1] = 1;\n    \n    while (head < tail) {\n        State cur = queue[head++];\n        \n        if (cur.r == er && cur.c == ec) {\n            return cur.time;\n        }\n        \n        if (cur.time >= 100) continue;\n        \n        for (int d = 0; d < 4; d++) {\n            if (d == (cur.dir ^ 1)) continue;\n            \n            int nr = cur.r + dr[d];\n            int nc = cur.c + dc[d];\n            \n            if (nr < 0 || nr >= M || nc < 0 || nc >= N) continue;\n            if (construction[cur.r][cur.c][nr][nc]) continue;\n            \n            if (!canPass(cur.r, cur.c, cur.time, cur.dir, d)) continue;\n            \n            int next_time = cur.time + D + traffic[cur.r][cur.c][nr][nc];\n            \n            if (next_time > 100) continue;\n            if (visited[nr][nc][next_time][d]) continue;\n            \n            visited[nr][nc][next_time][d] = 1;\n            queue[tail].r = nr;\n            queue[tail].c = nc;\n            queue[tail].time = next_time;\n            queue[tail].dir = d;\n            tail++;\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &M, &N);\n        if (M == 0 && N == 0) break;\n        \n        scanf(\"%d\", &D);\n        \n        memset(signal, 0, sizeof(signal));\n        memset(period, 0, sizeof(period));\n        memset(construction, 0, sizeof(construction));\n        memset(traffic, 0, sizeof(traffic));\n        \n        int ns;\n        scanf(\"%d\", &ns);\n        for (int i = 0; i < ns; i++) {\n            char s[20];\n            int k, r, c;\n            scanf(\"%s %d\", s, &k);\n            parseIntersection(s, &r, &c);\n            signal[r][c] = 1;\n            period[r][c] = k;\n        }\n        \n        int nc;\n        scanf(\"%d\", &nc);\n        for (int i = 0; i < nc; i++) {\n            char s1[20], s2[20];\n            int r1, c1, r2, c2;\n            scanf(\"%s %s\", s1, s2);\n            parseIntersection(s1, &r1, &c1);\n            parseIntersection(s2, &r2, &c2);\n            construction[r1][c1][r2][c2] = 1;\n            construction[r2][c2][r1][c1] = 1;\n        }\n        \n        int nj;\n        scanf(\"%d\", &nj);\n        for (int i = 0; i < nj; i++) {\n            char s1[20], s2[20];\n            int r1, c1, r2, c2, d;\n            scanf(\"%s %s %d\", s1, s2, &d);\n            parseIntersection(s1, &r1, &c1);\n            parseIntersection(s2, &r2, &c2);\n            traffic[r1][c1][r2][c2] = d;\n            traffic[r2][c2][r1][c1] = d;\n        }\n        \n        char start[20], end[20];\n        int sr, sc, er, ec;\n        scanf(\"%s %s\", start, end);\n        parseIntersection(start, &sr, &sc);\n        parseIntersection(end, &er, &ec);\n        \n        int result = solve(sr, sc, er, ec);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAX_N 20 #define INF 1000000 typedef struct { int r, c, time, dir; } State; int M, N, D;  State queue[1000000]; int head, tail; int dr[] = {0, 0, -1, 1}; int dc[] = {-1, 1, 0, 0}; void parseIntersection(char *s, int *r, int *c) { char h[10]; int v; sscanf(s, \"%[^-]-%d\", h, &v); *r = h[0] - 'a'; *c = v - 1; }  * k); int is_ns_green = (cycle < k); if (to_dir  else { return !is_ns_green; } } int solve(int sr, int sc, int er, int ec) { memset(visited, 0, sizeof(visited)); head = tail = 0; queue[tail].r = sr;  visited[sr][sc][0][1] = 1; while (head < tail) { State cur = queue[head++]; if (cur.r == er && cur.c == ec) { return cur.time; } if (cur.time >= 100) continue; for (int d =  ^ 1)) continue; int nr = cur.r + dr[d]; int nc = cur.c + dc[d]; if (nr < 0 || nr >= M || nc < 0 || nc >= N) continue; if (construction[cur.r][cur.c][nr][nc]) continue; if (!canPass(cur.r,  D + traffic[cur.r][cur.c][nr][nc]; if (next_time > 100) continue; if (visited[nr][nc][next_time][d]) continue; visited[nr][nc][next_time][d] = 1;  = d; tail++; } } return -1; } int main() { while (1) {  == 0) break; scanf(\"%d\", &D); memset(signal, 0, sizeof(signal)); memset(period, 0, sizeof(period)); memset(construction, 0, sizeof(construction)); memset(traffic, 0, sizeof(traffic)); int ns; scanf(\"%d\", &ns); for (int i = 0; i < ns; i++)  &k); parseIntersection(s, &r, &c); signal[r][c] = 1; period[r][c] = k; } int nc; scanf(\"%d\", &nc); for (int i  parseIntersection(s1, &r1, &c1); parseIntersection(s2, &r2, &c2); construction[r1][c1][r2][c2] = 1; construction[r2][c2][r1][c1] = 1; } int nj; scanf(\"%d\", &nj); for (int i = 0; i < nj; i++) { char s1[20], s2[20]; int r1, c1, r2, c2, d; scanf(\"%s %s %d\", s1, s2,  traffic[r2][c2][r1][c1] = d; } char start[20], end[20]; int sr, sc, er, ec; scanf(\"%s %s\", start, end); parseIntersection(start, &sr, &sc); parseIntersection(end, &er, &ec); int result = solve(sr, sc, er, ec); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["M,N,D;P[101][4][21][21];S[21][21];C[4][21][21];J[4][21][21];h1,h2;i,n,v1,v2,k;xs,ys,xg,yg,T;d,x,y,d1,t1,x1,y1;vx[]={1,0,-1,0},vy[]={0,1,0,-1};void set_road(int A[][21][21],int h1,int v1,int h2,int v2,int d){if(v1==v2){A[h1<h2?1:3][v1][h1-96]=d;A[h1<h2?3:1][v2][h2-96]=d;}else{A[v1<v2?0:2][v1][h1-96]=d;A[v1<v2?2:0][v2][h2-96]=d;}}main(){for(;scanf(\"%d%d%d%d\",&M,&N,&D,&n),M;){memset(P,0,sizeof(P));memset(S,0,sizeof(S));memset(C,0,sizeof(C));memset(J,0,sizeof(J));for(i=0;i<n;i++){scanf(\"\\n%c-%d%d\",&h1,&v1,&k);S[v1][h1-96]=k;}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);set_road(C,h1,v1,h2,v2,1);}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d%d\",&h1,&v1,&h2,&v2,&k);set_road(J,h1,v1,h2,v2,k);}scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);xs=v1;ys=h1-96;xg=v2;yg=h2-96;P[0][0][xs][ys]=1;for(T=0;;T++)for(d=0;d<4;d++){if(P[T][d][xg][yg]){printf(\"%d\\n\",T);goto E;}for(x=1;x<=N;x++)for(y=1;y<=M;y++)if(P[T][d][x][y]&&(!S[x][y]||T/S[x][y]%2!=d%2))for(d1=0;d1<4;d1++){t1=T+D+J[d1][x][y];x1=x+vx[d1];y1=y+vy[d1];if(d1!=(d^2)&&!C[d1][x][y]&&t1<=100&&x1>=1&&x1<=N&&y1>=1&&y1<=M)P[t1][d1][x1][y1]=1;}}E:;}return 0;}"], "original_ll": -1.225968360900879, "sampled_ll": -0.5271077156066895, "all_perturbed_sampled_ll": [-1.1454944610595703], "all_perturbed_original_ll": [-1.225968360900879], "perturbed_sampled_ll": -1.1454944610595703, "perturbed_original_ll": -1.225968360900879, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.awt.Point;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint dx[] = {0,1,0,-1};\n\t\tint dy[] = {-1,0,1,0};\n\t\tboolean pass[] = {true,false,true,false};\n\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tint d = sc.nextInt();\n\n\t\t\tHashMap<Point,Integer> node = new HashMap<Point,Integer>();\n\t\t\tint ns = sc.nextInt();\n\t\t\tfor(int i=0;i<ns;i++){\n\t\t\t\tnode.put(toPoint(sc.next()),sc.nextInt());\n\t\t\t}\n\n\t\t\tHashMap<Point,HashMap<Point,Integer>> edge = new HashMap<Point,HashMap<Point,Integer>>();\n\t\t\tint nc = sc.nextInt();\n\t\t\tfor(int i=0;i<nc;i++){\n\t\t\t\tPoint a = toPoint(sc.next());\n\t\t\t\tPoint b = toPoint(sc.next());\n\t\t\t\tif(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>());\n\t\t\t\tif(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>());\n\t\t\t\tedge.get(a).put(b,-1);\n\t\t\t\tedge.get(b).put(a,-1);\n\t\t\t}\n\n\t\t\tint nj = sc.nextInt();\n\t\t\tfor(int i=0;i<nj;i++){\n\t\t\t\tPoint a = toPoint(sc.next());\n\t\t\t\tPoint b = toPoint(sc.next());\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tif(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>());\n\t\t\t\tif(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>());\n\t\t\t\tedge.get(a).put(b,cost);\n\t\t\t\tedge.get(b).put(a,cost);\n\t\t\t}\n\n\t\t\tPoint start = toPoint(sc.next());\n\t\t\tPoint goal = toPoint(sc.next());\n\n\t\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\t\tHashSet<State> closed = new HashSet<State>();\n\t\t\topen.add(new State(start,1,0));\n\t\t\t//closed.add(new State(start,1,0));\n\t\t\tState ans = null;\n\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState st = open.poll();\n\n\t\t\t\tif(closed.contains(st)) continue;\n\t\t\t\tclosed.add(st);\n\n\t\t\t\tif(st.p.equals(goal)){\n\t\t\t\t\tans = st;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t//U\u0083^\u0081[\u0083\u0093\u0082\u00b5\u0082\u00c4\u0082\u00cd\u0082\u00a2\u0082\u00af\u0082\u00c8\u0082\u00a2\n\t\t\t\t\tif((st.d + 2) % 4 == i) continue;\n\n\t\t\t\t\tPoint np = new Point(st.p.x + dx[i], st.p.y + dy[i]);\n\n\t\t\t\t\tif(np.x>=0 && np.x<w && np.y>=0 && np.y<h){\n\t\t\t\t\t\tint val = 0;\n\t\t\t\t\t\t//st.p\u0082\u00a9\u0082\u00e7np\u0082\u00d6\u0082\u00cc\u0093\u00b9\u008f\u00ee\u0095\u00f1\u0082\u00f0\u008e\u00e6\u0082\u00e8\u008fo\u0082\u00b7\n\t\t\t\t\t\tif(edge.containsKey(st.p) &&\n\t\t\t\t\t\t\t edge.get(st.p).containsKey(np)) val = edge.get(st.p).get(np);\n\t\t\t\t\t\t//\u008dH\u008e\u0096\u0092\u0086\u0082\u00c8\u0082\u00e7\u0092\u00ca\u0082\u00ea\u0082\u00c8\u0082\u00a2\n\t\t\t\t\t\tif(val == -1) continue;\n\n\t\t\t\t\t\tint ncost = st.cost + d + val;\n\n\t\t\t\t\t\t//\u0090M\u008d\u0086\u0082\u00aa\u0082\u00a0\u0082\u00e9\u008f\u00ea\u008d\u0087\u0082\u00cc\u008f\u0088\u0097\u009d\n\t\t\t\t\t\tif(node.containsKey(np)){\n\t\t\t\t\t\t\tint k = node.get(np);\n\t\t\t\t\t\t\tboolean flg = pass[i]; //true:\u0090N\u0093\u00fc\u0089\u00c2\u0094\\\u0082\u00c5\u0082\u00a0\u0082\u00e9\n\t\t\t\t\t\t\tint div = ncost / k;\n\t\t\t\t\t\t\tif(div % 2 == 1) flg = !flg;\n\t\t\t\t\t\t\tif(!flg) continue;\n\t\t\t\t\t\t\t//if(!flg) ncost += k - ncost % k;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\topen.add(new State(np,i,ncost));\n\t\t\t\t\t\tState nst = new State(np,i,ncost);\n\t\t\t\t\t\t//if(closed.contains(nst)) continue;\n\t\t\t\t\t\t//closed.add(nst);\n\t\t\t\t\t\t//open.add(nst);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(ans.cost);\n\t\t}\n\t}\n\n\tprivate static Point toPoint(String s){\n\t\tString[] tmp = s.split(\"-\");\n\t\tint x = Integer.parseInt(tmp[1]) - 1;\n\t\tint y = tmp[0].charAt(0) - 'a';\n\t\treturn new Point(x,y);\n\t}\n}\n\nclass State implements Comparable<State>{\n\tPoint p;\n\tint d,cost;\n\n\tState(Point p,int d,int cost){\n\t\tthis.p = new Point(p.x,p.y);\n\t\tthis.d = d;\n\t\tthis.cost = cost;\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn this.cost - st.cost;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tState st = (State)o;\n\t\treturn p.equals(st.p) && d == st.d;\n\t}\n\n\tpublic int hashCode(){\n\t\treturn p.x + p.y * 100 + d * 10000;\n\t}\n\n\tpublic String toString(){\n\t\treturn String.format(\"[(%d,%d),%d,%d]\",p.x,p.y,d,cost);\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class State implements Comparable<State> {\n        int row, col, time, dir;\n        \n        public State(int row, int col, int time, int dir) {\n            this.row = row;\n            this.col = col;\n            this.time = time;\n            this.dir = dir;\n        }\n        \n        public int compareTo(State other) {\n            return this.time - other.time;\n        }\n    }\n    \n    static final int EAST = 0, WEST = 1, SOUTH = 2, NORTH = 3;\n    static final int[] DR = {0, 0, 1, -1};\n    static final int[] DC = {1, -1, 0, 0};\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] tokens = line.trim().split(\"\\\\s+\");\n            int M = Integer.parseInt(tokens[0]);\n            int N = Integer.parseInt(tokens[1]);\n            \n            if (M == 0 && N == 0) break;\n            \n            int D = Integer.parseInt(br.readLine().trim());\n            \n            int[][] signal = new int[M][N];\n            for (int i = 0; i < M; i++) {\n                Arrays.fill(signal[i], -1);\n            }\n            \n            int ns = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < ns; i++) {\n                tokens = br.readLine().trim().split(\"\\\\s+\");\n                String[] pos = tokens[0].split(\"-\");\n                int row = pos[0].charAt(0) - 'a';\n                int col = Integer.parseInt(pos[1]) - 1;\n                int k = Integer.parseInt(tokens[1]);\n                signal[row][col] = k;\n            }\n            \n            boolean[][][] blocked = new boolean[M][N][4];\n            int nc = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < nc; i++) {\n                tokens = br.readLine().trim().split(\"\\\\s+\");\n                String[] pos1 = tokens[0].split(\"-\");\n                String[] pos2 = tokens[1].split(\"-\");\n                int r1 = pos1[0].charAt(0) - 'a';\n                int c1 = Integer.parseInt(pos1[1]) - 1;\n                int r2 = pos2[0].charAt(0) - 'a';\n                int c2 = Integer.parseInt(pos2[1]) - 1;\n                \n                for (int d = 0; d < 4; d++) {\n                    if (r1 + DR[d] == r2 && c1 + DC[d] == c2) {\n                        blocked[r1][c1][d] = true;\n                        blocked[r2][c2][d ^ 1] = true;\n                    }\n                }\n            }\n            \n            int[][] congestion = new int[M][N];\n            for (int i = 0; i < M; i++) {\n                for (int j = 0; j < N; j++) {\n                    congestion[i][j] = D;\n                }\n            }\n            \n            int nj = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < nj; i++) {\n                tokens = br.readLine().trim().split(\"\\\\s+\");\n                String[] pos1 = tokens[0].split(\"-\");\n                String[] pos2 = tokens[1].split(\"-\");\n                int r1 = pos1[0].charAt(0) - 'a';\n                int c1 = Integer.parseInt(pos1[1]) - 1;\n                int r2 = pos2[0].charAt(0) - 'a';\n                int c2 = Integer.parseInt(pos2[1]) - 1;\n                int d = Integer.parseInt(tokens[2]);\n                \n                congestion[r1][c1] = Math.max(congestion[r1][c1], D + d);\n            }\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            String[] start = tokens[0].split(\"-\");\n            String[] end = tokens[1].split(\"-\");\n            int sr = start[0].charAt(0) - 'a';\n            int sc = Integer.parseInt(start[1]) - 1;\n            int er = end[0].charAt(0) - 'a';\n            int ec = Integer.parseInt(end[1]) - 1;\n            \n            int result = dijkstra(M, N, sr, sc, er, ec, signal, blocked, congestion);\n            System.out.println(result);\n        }\n    }\n    \n    static int dijkstra(int M, int N, int sr, int sc, int er, int ec, \n                        int[][] signal, boolean[][][] blocked, int[][] congestion) {\n        int[][][] dist = new int[M][N][4];\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                Arrays.fill(dist[i][j], Integer.MAX_VALUE);\n            }\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(sr, sc, 0, EAST));\n        dist[sr][sc][EAST] = 0;\n        \n        while (!pq.isEmpty()) {\n            State curr = pq.poll();\n            \n            if (curr.row == er && curr.col == ec) {\n                return curr.time;\n            }\n            \n            if (curr.time > dist[curr.row][curr.col][curr.dir]) continue;\n            \n            for (int d = 0; d < 4; d++) {\n                if (d == (curr.dir ^ 1)) continue;\n                \n                if (blocked[curr.row][curr.col][d]) continue;\n                \n                if (signal[curr.row][curr.col] != -1) {\n                    int k = signal[curr.row][curr.col];\n                    int cycle = curr.time / k;\n                    boolean isNSGreen = (cycle % 2 == 0);\n                    boolean isEWGreen = !isNSGreen;\n                    \n                    if ((d == EAST || d == WEST) && !isEWGreen) continue;\n                    if ((d == NORTH || d == SOUTH) && !isNSGreen) continue;\n                }\n                \n                int nr = curr.row + DR[d];\n                int nc = curr.col + DC[d];\n                \n                if (nr < 0 || nr >= M || nc < 0 || nc >= N) continue;\n                \n                int travelTime = congestion[curr.row][curr.col];\n                int newTime = curr.time + travelTime;\n                \n                if (newTime < dist[nr][nc][d]) {\n                    dist[nr][nc][d] = newTime;\n                    pq.offer(new State(nr, nc, newTime, d));\n                }\n            }\n        }\n        \n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public  row, col, time, dir; public State(int row, int col, int  this.time = time; this.dir = dir; } public int compareTo(State other) {  = 3; static final int[] DR =  -1, 0, 0}; public static void main(String[] args) throws IOException { BufferedReader br = new  { String[] tokens = line.trim().split(\"\\\\s+\"); int M = Integer.parseInt(tokens[0]); int N = Integer.parseInt(tokens[1]); if (M == 0 && N == 0) break; int D = Integer.parseInt(br.readLine().trim()); int[][] signal = new int[M][N]; for (int i = 0; i < M; i++) { Arrays.fill(signal[i], -1); } int ns = Integer.parseInt(br.readLine().trim()); for (int i = 0; i < ns; i++) { tokens = br.readLine().trim().split(\"\\\\s+\"); String[] pos = tokens[0].split(\"-\"); int row = pos[0].charAt(0) - 'a'; int col = Integer.parseInt(pos[1]) - 1; int k = Integer.parseInt(tokens[1]); signal[row][col] = k; } boolean[][][] blocked = new boolean[M][N][4]; int nc =  { tokens = br.readLine().trim().split(\"\\\\s+\"); String[] pos1 = tokens[0].split(\"-\"); String[] pos2 = tokens[1].split(\"-\"); int r1 = pos1[0].charAt(0) - 'a'; int c1 = Integer.parseInt(pos1[1]) - 1; int r2 =  (int d = 0; d < 4; d++) { if (r1 + DR[d]  = true; blocked[r2][c2][d ^  int[M][N]; for (int i = 0; i < M; i++) { for (int j = 0; j < N; j++) { congestion[i][j] = D;  String[] pos1 = tokens[0].split(\"-\"); String[] pos2 = tokens[1].split(\"-\");  - 1; int r2 = pos2[0].charAt(0) - 'a'; int c2 = Integer.parseInt(pos2[1]) - 1; int d = Integer.parseInt(tokens[2]); congestion[r1][c1] = Math.max(congestion[r1][c1], D + d); } tokens = br.readLine().trim().split(\"\\\\s+\"); String[] start = tokens[0].split(\"-\"); String[] end = tokens[1].split(\"-\"); int sr  Integer.parseInt(end[1]) - 1; int result = dijkstra(M, N, sr,  int dijkstra(int M, int N, int sr, int sc, int er, int ec, int[][] signal, boolean[][][] blocked, int[][] congestion) { int[][][] dist = new int[M][N][4]; for (int i = 0; i < M; i++) { for (int j = 0; j < N; j++) { Arrays.fill(dist[i][j], Integer.MAX_VALUE); } } PriorityQueue<State> pq = new PriorityQueue<>(); pq.offer(new State(sr, sc, 0, EAST)); dist[sr][sc][EAST] = 0; while (!pq.isEmpty()) { State curr = pq.poll(); if (curr.row  if (curr.time > dist[curr.row][curr.col][curr.dir]) continue; for (int d = 0; d < 4; d++) { if (d == (curr.dir ^ 1)) continue; if (blocked[curr.row][curr.col][d]) continue; if (signal[curr.row][curr.col] != -1) { int k = signal[curr.row][curr.col]; int cycle  == 0); boolean isEWGreen = !isNSGreen; if ((d == EAST || d == WEST) && !isEWGreen) continue; if ((d == NORTH || d == SOUTH) && !isNSGreen) continue; } int nr = curr.row + DR[d]; int nc = curr.col + DC[d]; if (nr < 0 || nr >= M || nc < 0 || nc >= N)  travelTime; if (newTime < dist[nr][nc][d]) { dist[nr][nc][d] = newTime; pq.offer(new State(nr, nc, newTime, d)); } } } return -1; } }"], "perturbed_original": ["import java.util.*; import java.awt.Point;   {-1,0,1,0}; boolean pass[] = {true,false,true,false}; while(true){ int h = sc.nextInt();  0) break; int d = sc.nextInt(); HashMap<Point,Integer> node  sc.nextInt(); for(int i=0;i<nc;i++){ Point a  HashMap<Point,Integer>()); if(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>()); edge.get(a).put(b,-1); edge.get(b).put(a,-1); } int nj = sc.nextInt(); for(int  cost = sc.nextInt(); if(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>()); if(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>()); edge.get(a).put(b,cost); edge.get(b).put(a,cost); } Point start =  HashSet<State> closed = new HashSet<State>(); open.add(new State(start,1,0)); //closed.add(new State(start,1,0)); State ans = null; while(!open.isEmpty()){  st; break; } for(int i=0;i<4;i++){ //U\u0083^\u0081[\u0083\u0093\u0082\u00b5\u0082\u00c4\u0082\u00cd\u0082\u00a2\u0082\u00af\u0082\u00c8\u0082\u00a2  =  && np.y>=0 && np.y<h){ int val = 0; //st.p\u0082\u00a9\u0082\u00e7np\u0082\u00d6\u0082\u00cc\u0093\u00b9\u008f\u00ee\u0095\u00f1\u0082\u00f0\u008e\u00e6\u0082\u00e8\u008fo\u0082\u00b7 if(edge.containsKey(st.p) && edge.get(st.p).containsKey(np)) val = edge.get(st.p).get(np); //\u008dH\u008e\u0096\u0092\u0086\u0082\u00c8\u0082\u00e7\u0092\u00ca\u0082\u00ea\u0082\u00c8\u0082\u00a2 if(val == -1) continue; int ncost = st.cost + d + val; //\u0090M\u008d\u0086\u0082\u00aa\u0082 \u0082\u00e9\u008f\u00ea\u008d\u0087\u0082\u00cc\u008f\u0088\u0097\u009d if(node.containsKey(np)){ int k = node.get(np); boolean flg = pass[i]; //true:\u0090N\u0093\u00fc\u0089\u00c2\u0094\\\u0082\u00c5\u0082 \u0082\u00e9 int div = ncost / k; if(div % 2 == 1) flg = !flg; if(!flg) continue; //if(!flg) ncost += k - ncost % k; } open.add(new State(np,i,ncost)); State nst = new State(np,i,ncost); //if(closed.contains(nst)) continue; //closed.add(nst); //open.add(nst); } } } System.out.println(ans.cost); } } private static Point toPoint(String s){ String[] tmp = s.split(\"-\"); int x = Integer.parseInt(tmp[1]) - 1; int y = tmp[0].charAt(0) - 'a'; return new Point(x,y); } } class State implements Comparable<State>{ Point p; int d,cost; State(Point p,int d,int cost){ this.p = new Point(p.x,p.y); this.d = d; this.cost = cost; } public int compareTo(State st){ return this.cost - st.cost; } public boolean equals(Object o){ State st = (State)o; return p.equals(st.p) && d == st.d; } public int hashCode(){ return p.x + p.y * 100 + d * 10000; } public String toString(){ return String.format(\"[(%d,%d),%d,%d]\",p.x,p.y,d,cost); } }"], "original_ll": -1.0800551176071167, "sampled_ll": -0.42935001850128174, "all_perturbed_sampled_ll": [-1.1532950401306152], "all_perturbed_original_ll": [-1.8543291091918945], "perturbed_sampled_ll": -1.1532950401306152, "perturbed_original_ll": -1.8543291091918945, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#Byakko Delivery Company\nfrom heapq import heappop, heappush\nfrom string import ascii_lowercase as al\ndic = dict([(c,i) for i, c in enumerate(al)])\nf = lambda (h, v):(dic[h], int(v) - 1)\ng = lambda s:f(s.split(\"-\"))\n\ndef solve():\n    hq = [(0, start[0], start[1])]\n    while len(hq) != 0:\n        cost, cy, cx = heappop(hq)\n        #print \"cost = {}, pos = ({}, {})\".format(cost, cy, cx)\n        if (cy, cx) == goal:\n            return cost\n        for dy, dx in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            ny, nx = cy + dy, cx + dx\n            if 0 <= ny < M and 0 <= nx < N:\n                #print ny, nx, condition[ny][nx][cy][cx]\n                nc = condition[ny][nx][cy][cx] + D + cost\n                if field[ny][nx] == 0:\n                    heappush(hq, (nc, ny, nx))\n                else:\n                    if dy == 0:\n                        if (nc / field[ny][nx]) % 2 == 1:\n                            heappush(hq, (nc, ny, nx))\n                    else:\n                        if (nc / field[ny][nx]) % 2 == 0:\n                            heappush(hq, (nc, ny, nx))\nwhile True:\n    M, N = map(int, raw_input().split())\n    if M | N == 0:\n        break\n    D = input()\n    field = [[0] * N for _ in xrange(M)]\n    condition = [[[[0] * N for _ in xrange(M)] for _ in xrange(N)] for _ in xrange(M)]\n    for _ in xrange(input()):\n        p, k = raw_input().split()\n        h, v = g(p)\n        field[h][v] = int(k)\n\n    for _ in xrange(input()):    \n        (h1, v1), (h2, v2) = map(g, raw_input().split())\n        condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = 1 << 30\n\n    for _ in xrange(input()):\n        p1, p2, d = raw_input().split()\n        h1, v1 = g(p1)\n        h2, v2 = g(p2)\n        condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = int(d)\n\n    start, goal = map(g, raw_input().split())\n    print solve()", "sampled": "import heapq\nfrom collections import defaultdict\n\ndef parse_intersection(s):\n    parts = s.split('-')\n    h = ord(parts[0]) - ord('a')\n    v = int(parts[1]) - 1\n    return (h, v)\n\ndef solve():\n    while True:\n        line = input().split()\n        M, N = int(line[0]), int(line[1])\n        if M == 0 and N == 0:\n            break\n        \n        D = int(input())\n        \n        ns = int(input())\n        signals = {}\n        for _ in range(ns):\n            parts = input().split()\n            pos = parse_intersection(parts[0])\n            k = int(parts[1])\n            signals[pos] = k\n        \n        nc = int(input())\n        blocked = set()\n        for _ in range(nc):\n            parts = input().split()\n            pos1 = parse_intersection(parts[0])\n            pos2 = parse_intersection(parts[1])\n            blocked.add((min(pos1, pos2), max(pos1, pos2)))\n        \n        nj = int(input())\n        jams = {}\n        for _ in range(nj):\n            parts = input().split()\n            pos1 = parse_intersection(parts[0])\n            pos2 = parse_intersection(parts[1])\n            d = int(parts[2])\n            key = (min(pos1, pos2), max(pos1, pos2))\n            jams[key] = d\n        \n        parts = input().split()\n        start = parse_intersection(parts[0])\n        end = parse_intersection(parts[1])\n        \n        # Dijkstra with state (time, pos, direction)\n        # direction: 0=E, 1=W, 2=S, 3=N\n        pq = [(0, start, 0)]\n        visited = set()\n        \n        # Direction vectors: E, W, S, N\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        # EW: 0,1  NS: 2,3\n        \n        while pq:\n            time, pos, prev_dir = heapq.heappop(pq)\n            \n            if pos == end:\n                print(time)\n                break\n            \n            state = (pos, prev_dir)\n            if state in visited:\n                continue\n            visited.add(state)\n            \n            h, v = pos\n            \n            for d in range(4):\n                # No U-turn\n                if prev_dir == 0 and d == 1:\n                    continue\n                if prev_dir == 1 and d == 0:\n                    continue\n                if prev_dir == 2 and d == 3:\n                    continue\n                if prev_dir == 3 and d == 2:\n                    continue\n                \n                dh, dv = dirs[d]\n                nh, nv = h + dh, v + dv\n                \n                if nh < 0 or nh >= M or nv < 0 or nv >= N:\n                    continue\n                \n                new_pos = (nh, nv)\n                edge = (min(pos, new_pos), max(pos, new_pos))\n                \n                if edge in blocked:\n                    continue\n                \n                # Check signal at current position\n                if pos in signals:\n                    k = signals[pos]\n                    cycle_time = time % (2 * k)\n                    # At time 0, NS is green (d=2,3)\n                    # 0 to k-1: NS green (EW red)\n                    # k to 2k-1: EW green (NS red)\n                    \n                    if d in [0, 1]:  # EW direction\n                        if cycle_time < k:  # NS is green, EW is red\n                            continue\n                    else:  # NS direction\n                        if cycle_time >= k:  # EW is green, NS is red\n                            continue\n                \n                travel_time = D\n                if edge in jams:\n                    travel_time += jams[edge]\n                \n                new_time = time + travel_time\n                \n                if new_time <= 100:\n                    heapq.heappush(pq, (new_time, new_pos, d))\n\nsolve()\n", "perturbed_sampled": ["import heapq from collections import defaultdict def parse_intersection(s): parts = s.split('-') h = ord(parts[0]) - ord('a') v = int(parts[1]) -  input().split() M, N = int(line[0]), int(line[1]) if M == 0 and  signals = {} for _ in range(ns): parts = input().split()  = int(input()) blocked = set() for _ in range(nc): parts = input().split() pos1 = parse_intersection(parts[0]) pos2 = parse_intersection(parts[1]) blocked.add((min(pos1, pos2), max(pos1, pos2))) nj = int(input()) jams = {} for _ in range(nj): parts = input().split() pos1 = parse_intersection(parts[0])  max(pos1, pos2)) jams[key] = d parts = input().split() start = parse_intersection(parts[0]) end = parse_intersection(parts[1]) # Dijkstra with state (time,  [(0, start,  N dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)] # EW: 0,1 NS: 2,3 while pq: time, pos, prev_dir = heapq.heappop(pq) if pos == end: print(time) break state = (pos, prev_dir)  for d in range(4): # No U-turn if prev_dir == 0 and d == 1: continue if prev_dir == 1 and d == 0: continue if prev_dir == 2 and d == 3: continue if prev_dir == 3 and d == 2: continue dh, dv = dirs[d] nh, nv = h + dh, v + dv if nh < 0 or nh >= M or nv < 0 or nv >= N: continue new_pos = (nh, nv) edge = (min(pos, new_pos), max(pos, new_pos)) if edge  pos in signals:  # At time 0, NS is green (d=2,3) # 0 to k-1: NS  red) if d in [0,  is green, EW is red continue else: # NS direction if cycle_time >= k: # EW is green, NS is red continue travel_time = D if edge in jams: travel_time += jams[edge] new_time = time + travel_time if new_time <= 100: heapq.heappush(pq, (new_time, new_pos, d)) solve()"], "perturbed_original": ["#Byakko Delivery  as al dic = dict([(c,i) for i, c in enumerate(al)]) f = lambda (h, v):(dic[h], int(v) - 1) g = lambda s:f(s.split(\"-\")) def solve(): hq = [(0, start[0], start[1])] while len(hq) != 0: cost, cy, cx = heappop(hq) #print \"cost = {}, pos = ({}, {})\".format(cost, cy, cx) if (cy, cx)  (0, -1), (1, 0), (-1, 0)): ny, nx = cy + dy, cx + dx if 0 <= ny < M and 0 <= nx < N: #print ny, nx, condition[ny][nx][cy][cx] nc = condition[ny][nx][cy][cx] + D + cost if field[ny][nx]  0: if (nc / field[ny][nx]) % 2 == 1: heappush(hq, (nc, ny, nx)) else: if (nc / field[ny][nx]) % 2 ==  map(int, raw_input().split()) if M | N == 0:  _ in xrange(M)] condition = [[[[0] * N for _ in xrange(M)] for _ in xrange(N)] for _ in xrange(M)] for _ in xrange(input()): p, k = raw_input().split() h, v = g(p) field[h][v] = int(k) for _ in xrange(input()): (h1, v1), (h2, v2) = map(g, raw_input().split())  g(p1) h2, v2 = g(p2) condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = int(d) start, goal = map(g, raw_input().split()) print solve()"], "original_ll": -0.9956142902374268, "sampled_ll": -0.9774958491325378, "all_perturbed_sampled_ll": [-2.00016450881958], "all_perturbed_original_ll": [-1.7755697965621948], "perturbed_sampled_ll": -2.00016450881958, "perturbed_original_ll": -1.7755697965621948, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\t\n\tint i,sum,a,b,c;\n\tint top,topn;\n\t\n\ttop = 0;\n\t\n\twhile(1){\n\t\t\n\t\tscanf(\" %d %d\",&a,&b);\n\t\t\n\t\tif(a == 0 && b == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tc = a + b;\n\t\t\n\t\tif(top > c){\n\t\t\ttop = c;\n\t\t\ttopn = i;\n\t\t}\n\t\t\n\t\ti++;\n\t\t\n\t\tif(i==5){\n\t\t\tswitch(topn){\n\t\t\t\tcase 1:\n\t\t\t\t\tprintf(\"A \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tprintf(\"B \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tprintf(\"C \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tprintf(\"D \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tprintf(\"E \");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tprintf(\" %d\",top);\n\t\t}\n\t}\n\t\n\treturn(0);\n\t\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int s1, s2;\n    char stores[] = {'A', 'B', 'C', 'D', 'E'};\n    int totals[5];\n    \n    while(1) {\n        scanf(\"%d %d\", &s1, &s2);\n        if(s1 == 0 && s2 == 0) break;\n        \n        totals[0] = s1 + s2;\n        \n        for(int i = 1; i < 5; i++) {\n            scanf(\"%d %d\", &s1, &s2);\n            totals[i] = s1 + s2;\n        }\n        \n        int maxIndex = 0;\n        int maxTotal = totals[0];\n        \n        for(int i = 1; i < 5; i++) {\n            if(totals[i] > maxTotal) {\n                maxTotal = totals[i];\n                maxIndex = i;\n            }\n        }\n        \n        printf(\"%c %d\\n\", stores[maxIndex], maxTotal);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int  int totals[5]; while(1) { scanf(\"%d %d\", &s1, &s2); if(s1 == 0 && s2 == 0) break; totals[0] = s1 + s2; for(int i = 1; i < 5; i++) { scanf(\"%d %d\", &s1, &s2); totals[i] = s1 + s2; } int maxIndex = 0; int maxTotal = totals[0]; for(int i = 1; i < 5; i++) { if(totals[i] > maxTotal) { maxTotal = totals[i]; maxIndex =  }"], "perturbed_original": ["#include<stdio.h> int main(void){ int i,sum,a,b,c; int  0 && b == 0){ break; } c = a + b; if(top > c){ top  1: printf(\"A \"); break; case 2: printf(\"B \"); break; case 3: printf(\"C \"); break; case 4: printf(\"D \"); break; case 5: printf(\"E \"); break; } printf(\" %d\",top); } } return(0); }"], "original_ll": -0.9154200553894043, "sampled_ll": -0.5907330513000488, "all_perturbed_sampled_ll": [-0.9924958944320679], "all_perturbed_original_ll": [-1.8388603925704956], "perturbed_sampled_ll": -0.9924958944320679, "perturbed_original_ll": -1.8388603925704956, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tString[] k = new String[]{\"A\",\"B\",\"C\",\"D\",\"E\"};\n\t\twhile(true) {\n\t\t\tint number = 0;\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < 5; i++) {\n\t\t\t\tint tmp = stdIn.nextInt();\n\t\t\t\ttmp += stdIn.nextInt();\n\t\t\t\tif(tmp == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(tmp > max) {\n\t\t\t\t\tmax = tmp;\n\t\t\t\t\tnumber = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(k[number] + \" \" + max);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int s1A = sc.nextInt();\n            int s2A = sc.nextInt();\n            \n            if (s1A == 0 && s2A == 0) {\n                break;\n            }\n            \n            int s1B = sc.nextInt();\n            int s2B = sc.nextInt();\n            int s1C = sc.nextInt();\n            int s2C = sc.nextInt();\n            int s1D = sc.nextInt();\n            int s2D = sc.nextInt();\n            int s1E = sc.nextInt();\n            int s2E = sc.nextInt();\n            \n            int totalA = s1A + s2A;\n            int totalB = s1B + s2B;\n            int totalC = s1C + s2C;\n            int totalD = s1D + s2D;\n            int totalE = s1E + s2E;\n            \n            int max = totalA;\n            String store = \"A\";\n            \n            if (totalB > max) {\n                max = totalB;\n                store = \"B\";\n            }\n            if (totalC > max) {\n                max = totalC;\n                store = \"C\";\n            }\n            if (totalD > max) {\n                max = totalD;\n                store = \"D\";\n            }\n            if (totalE > max) {\n                max = totalE;\n                store = \"E\";\n            }\n            \n            System.out.println(store + \" \" + max);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int s1A = sc.nextInt(); int s2A = sc.nextInt(); if (s1A == 0 && s2A == 0) { break; } int s1B = sc.nextInt(); int s2B = sc.nextInt(); int s1C = sc.nextInt(); int s2C = sc.nextInt(); int s1D = sc.nextInt(); int s2D = sc.nextInt(); int s1E  + s2A; int totalB  s1E + s2E; int max = totalA;  = totalB; store = \"B\";  = \"C\"; } if (totalD > max) { max = totalD; store = \"D\"; } if (totalE > max) { max = totalE; store = \"E\"; } System.out.println(store + \" \" + max); } sc.close(); } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner stdIn = new Scanner(System.in); String[] k =  i++) { int tmp = stdIn.nextInt(); tmp += stdIn.nextInt(); if(tmp == 0) { return; } if(tmp > max) { max = tmp; number = i; } } System.out.println(k[number] + \" \" + max); } } }"], "original_ll": -0.8375464677810669, "sampled_ll": -0.298247367143631, "all_perturbed_sampled_ll": [-0.9401541948318481], "all_perturbed_original_ll": [-1.5217481851577759], "perturbed_sampled_ll": -0.9401541948318481, "perturbed_original_ll": -1.5217481851577759, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# Aizu Problem 0195: What is the Most Popular Shop in Tokaichi?\n#\nimport sys, math, os\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\nwhile True:\n    most = 0\n    shop = 'A'\n    a, b = [int(_) for _ in input().split()]\n    if a == b == 0:\n        break\n    most = a + b\n    for s in range(4):\n        a = sum([int(_) for _ in input().split()])\n        if a > most:\n            most = a\n            shop = chr(66 + s)\n    print(shop, most)\n            ", "sampled": "import sys\n\nfor line in sys.stdin:\n    s1_A, s2_A = map(int, line.split())\n    if s1_A == 0 and s2_A == 0:\n        break\n    \n    stores = []\n    stores.append(('A', s1_A + s2_A))\n    \n    for store_name in ['B', 'C', 'D', 'E']:\n        s1, s2 = map(int, input().split())\n        stores.append((store_name, s1 + s2))\n    \n    max_store = max(stores, key=lambda x: x[1])\n    print(max_store[0], max_store[1])\n", "perturbed_sampled": ["import sys for line in sys.stdin: s1_A, s2_A = map(int, line.split()) if s1_A == 0 and s2_A == 0: break stores = [] stores.append(('A', s1_A + s2_A)) for store_name in ['B', 'C', 'D', 'E']: s1, s2 = map(int, input().split()) stores.append((store_name,  max_store[1])"], "perturbed_original": ["# Aizu Problem 0195: What is the Most Popular Shop in Tokaichi? # import sys, math, os # read input: PYDEV = os.environ.get('PYDEV') if PYDEV==\"True\": sys.stdin =  a, b = [int(_) for _ in input().split()] if a == b == 0: break most = a + b for s in range(4): a = sum([int(_) for _  = chr(66 + s) print(shop, most)"], "original_ll": -1.9836997985839844, "sampled_ll": -0.9668151140213013, "all_perturbed_sampled_ll": [-1.7519112825393677], "all_perturbed_original_ll": [-3.134291172027588], "perturbed_sampled_ll": -1.7519112825393677, "perturbed_original_ll": -3.134291172027588, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0196: Baseball Championship\n// 2017.8.3\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar *gets(char *);\nchar buf[500], *p;\n\nint getInt(void)\n{\n\tint n = 0;\n\twhile (isspace(*p)) p++;\n\treturn *p++ - '0';\n}\n\nchar getStr(void)\n{\n\twhile (isspace(*p)) p++;\n\treturn *p++;\n}\n\ntypedef struct { char a; int k, w, l; } T;\nT t[15];\n\nint main()\n{\n\tint i, j, k, n;\n\tT tmp, *tp, *tt;\n\n\twhile (1) {\n\t\tgets(buf);\n\t\tif (!(n = atoi(buf))) break;\n\t\tfor (i = 0, tp = t; i < n; i++, tp++) {\n\t\t\tgets(p = buf);\n\t\t\ttp->a = getStr(), tp->k = i, tp->w = tp->l = 0;\n\t\t\tfor (j = 1; j < n; j++) {\n\t\t\t\tk = getInt();\n\t\t\t\tif (k == 0) tp->w++;\n\t\t\t\telse if (k == 1) tp->l++;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < n; i++) {\n\t\t\ttp = t + i;\n\t\t\tfor (j = i+1, tt = tp+1; j < n; j++, tt++) {\n\t\t\t\tif (tt->w > tp->w) tp = tt;\n\t\t\t\telse if (tt->w == tp->w) {\n\t\t\t\t\tif (tt->l < tp->l) tp = tt;\n\t\t\t\t\telse if (tt->l == tp->l && tt->k < tp->k) tp = tt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tp != t + i) {\n\t\t\t\tmemcpy(&tmp, t+i, sizeof(tmp));\n\t\t\t\tmemcpy(t+i, tp, sizeof(tmp));\n\t\t\t\tmemcpy(tp, &tmp, sizeof(tmp));\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < n; i++) putchar(t[i].a), putchar('\\n');\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name;\n    int wins;\n    int losses;\n    int order;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    \n    if (ta->wins != tb->wins) {\n        return tb->wins - ta->wins;\n    }\n    if (ta->losses != tb->losses) {\n        return ta->losses - tb->losses;\n    }\n    return ta->order - tb->order;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Team teams[10];\n        \n        for (int i = 0; i < n; i++) {\n            char name;\n            scanf(\" %c\", &name);\n            \n            teams[i].name = name;\n            teams[i].wins = 0;\n            teams[i].losses = 0;\n            teams[i].order = i;\n            \n            for (int j = 0; j < n - 1; j++) {\n                int result;\n                scanf(\"%d\", &result);\n                \n                if (result == 0) {\n                    teams[i].wins++;\n                } else if (result == 1) {\n                    teams[i].losses++;\n                }\n            }\n        }\n        \n        qsort(teams, n, sizeof(Team), compare);\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%c\\n\", teams[i].name);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef struct { char name; int wins; int losses; int order; } Team; int compare(const void *a, const void *b) { Team *ta = (Team *)a; Team *tb = (Team *)b; if  (ta->losses != tb->losses) { return ta->losses - tb->losses; } return ta->order - tb->order; } int main() { int n; while (scanf(\"%d\",  teams[i].wins = 0; teams[i].losses = 0; teams[i].order = i; for (int j = 0; j < n - 1; j++) { int result; scanf(\"%d\", &result); if (result == 0) { teams[i].wins++; } else if (result == 1) { teams[i].losses++; } } } qsort(teams, n, sizeof(Team), compare); for (int i = 0; i < n; i++) { printf(\"%c\\n\", teams[i].name); } } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0196:  getInt(void) { int n = 0; while (isspace(*p)) p++; return *p++ - '0'; } char getStr(void) { while (isspace(*p)) p++; return *p++; } typedef struct { char a; int k, w, l; } T; T t[15]; int main() { int i, j, k, n; T tmp, *tp, *tt; while (1) { gets(buf); if (!(n = atoi(buf))) break; for (i = 0, tp = t; i < n; i++, tp++) {  < n; j++) { k = getInt(); if (k == 0) tp->w++; else if  i < n; i++) { tp = t + i; for (j = i+1, tt = tp+1; j < n; j++, tt++) { if (tt->w > tp->w) tp = tt; else if (tt->w == tp->w) { if (tt->l < tp->l) tp  tp->k) tp = tt; } } if (tp != t + i) { memcpy(&tmp, t+i, sizeof(tmp)); memcpy(t+i, tp, sizeof(tmp)); memcpy(tp, &tmp, sizeof(tmp)); } } for (i = 0; i < n; i++) putchar(t[i].a), putchar('\\n'); } return 0; }"], "original_ll": -0.9839844703674316, "sampled_ll": -0.42950037121772766, "all_perturbed_sampled_ll": [-0.8844841718673706], "all_perturbed_original_ll": [-1.6553479433059692], "perturbed_sampled_ll": -0.8844841718673706, "perturbed_original_ll": -1.6553479433059692, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.*;\nimport java.util.*;\n\n\n// 2011/10/23\n\n// 0196 \u0096\u00ec\u008b\u0085\u0091\u00e5\u0089\u00ef\npublic class Main {\n\t\n\t\n\tclass Team implements Comparable<Team> {\n\t\tString name;\n\t\tint win;\n\t\tint lose;\n\t\tpublic Team(String name, int win, int lose) {\n\t\t\tthis.name = name;\n\t\t\tthis.win = win;\n\t\t\tthis.lose = lose;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Team o) {\n\t\t\tif (win != o.win) {\n\t\t\t\treturn -(win - o.win);\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn (lose - o.lose);\n\t\t}\n\t\t\n\t}\n\t\n\n\t// \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2\n\tboolean main() throws IOException {\n\n\t\tint n = readIntArray()[0];\n\t\tif (n == 0)\n\t\t\treturn false;\n\t\t\n\t\tList<Team> list = new ArrayList<Team>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tString s = reader.readLine();\n\t\t\tString[] sp = s.split(\" \");\n\t\t\t\n\t\t\tint win = 0;\n\t\t\tint lose = 0;\n\t\t\tfor(int j = 0; j < n - 1; j++) {\n\t\t\t\tString r = sp[j + 1];\n\t\t\t\tif (r.equals(\"0\")) {\n\t\t\t\t\twin++;\n\t\t\t\t}\n\t\t\t\telse if (r.equals(\"1\")) {\n\t\t\t\t\tlose++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist.add(new Team(sp[0], win, lose));\n\t\t}\t\n\t\t\n\t\tCollections.sort(list);\n\t\t\n\t\tfor(Team t: list) {\n\t\t\tSystem.out.printf(\"%s\\n\", t.name);\n\t\t}\n\t\t\n//\t\tSystem.out.printf(\"%d\\n\", sum / size);\n\t\t\n\t\treturn true; // \u0090\u00b3\u008f\u00ed\u008fI\u0097\u00b9 \u008e\u009f\u0082\u00d6\n\t}\n\t\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\t\t\t\n\t\t\tString inputStr = \"1:15:\";\n\n\t\t\tinputStr = inputStr.replace(\":\", \"\\n\");\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr)); \n\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // \u008f\u0091\u0082\u00ab\u008e\u00cc\u0082\u00c4\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // \u0083R\u0083\u0093\u0083\\\u0081[\u0083\u008b\u0082\u00a9\u0082\u00e7\n\t\t}\n\t\t\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t}\n\n\t\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\t\n\n\t// \u0095W\u008f\u0080\u0093\u00fc\u0097\u00cd\u0082\u00e6\u0082\u00e81\u008ds\u0095\u00aa\u0082\u00cc\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0095\u00b6\u008e\u009a\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0082\u00c5\u0082\u00cc\u0090\u00ae\u0090\u0094\u0092l\u0082\u00f0\u0093\u00c7\u0082\u00de\n\t// EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7\n\tprivate static int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = reader.readLine();\n//\t\t\tlog.printf(\"%s\\n\", s);\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // \u0081\u00a6\u0081\u00a6\u0081\u00a6\u0081@\u0082\u00c7\u0082\u00a4\u0082\u00e0\u0093\u00cb\u0091R\u008b\u00f3\u008ds\u0082\u00f0\u0093\u00c7\u0082\u00de\u0082\u00b1\u0082\u00c6\u0082\u00aa\u0082\u00a0\u0082\u00e9\u0081B\u0093\u00c7\u0082\u00dd\u0094\u00f2\u0082\u00ce\u0082\u00b7\u0082\u00c6\u0082\u00a4\u0082\u00dc\u0082\u00ad\u0082\u00a2\u0082\u00ad\u0082\u00e7\u0082\u00b5\u0082\u00a2\u0081B\u0081B\u0081B\u0081B\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tString[] sp = s.split(\"[ ,]\"); // \u008b\u00e6\u0090\u00d8\u0082\u00e8\u0095\u00b6\u008e\u009a\u0082\u00cd\u0083X\u0083y\u0081[\u0083X\u0082\u00a9\u0083J\u0083\u0093\u0083}\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\t\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Team {\n        String name;\n        int wins;\n        int losses;\n        int order;\n        \n        Team(String name, int wins, int losses, int order) {\n            this.name = name;\n            this.wins = wins;\n            this.losses = losses;\n            this.order = order;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            List<Team> teams = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                String teamName = sc.next();\n                int wins = 0;\n                int losses = 0;\n                \n                for (int j = 0; j < n - 1; j++) {\n                    int result = sc.nextInt();\n                    if (result == 0) {\n                        wins++;\n                    } else if (result == 1) {\n                        losses++;\n                    }\n                }\n                \n                teams.add(new Team(teamName, wins, losses, i));\n            }\n            \n            Collections.sort(teams, new Comparator<Team>() {\n                @Override\n                public int compare(Team t1, Team t2) {\n                    if (t1.wins != t2.wins) {\n                        return t2.wins - t1.wins;\n                    }\n                    if (t1.losses != t2.losses) {\n                        return t1.losses - t2.losses;\n                    }\n                    return t1.order - t2.order;\n                }\n            });\n            \n            for (Team team : teams) {\n                System.out.println(team.name);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  name; int wins; int losses; int order;  = name; this.wins = wins; this.losses = losses; this.order = order; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; List<Team> teams = new ArrayList<>(); for (int i = 0; i <  0; int losses = 0; for (int j = 0; j < n - 1; j++) { int result = sc.nextInt(); if (result == 0) { wins++; } else if (result  i)); } Collections.sort(teams, new Comparator<Team>() { @Override public int compare(Team t1, Team t2) { if (t1.wins != t2.wins) {  return t1.losses - t2.losses; } return t1.order - t2.order; } }); for (Team team : teams) { System.out.println(team.name); } } sc.close(); } }"], "perturbed_original": ["import java.io.*; import java.util.*; // 2011/10/23 // 0196 \u0096\u00ec\u008b \u0091\u00e5\u0089\u00ef  name; int win; int lose; public Team(String name, int win, int  (win != o.win) { return -(win - o.win); } else return (lose - o.lose); } } // \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2 boolean main() throws IOException { int  list = new ArrayList<Team>(); for(int i = 0; i < n; i++) { String s = reader.readLine(); String[] sp = s.split(\" \"); int win = 0; int lose = 0; for(int j = 0; j < n - 1; j++) { String r = sp[j + 1]; if (r.equals(\"0\")) { win++;  t.name); } // System.out.printf(\"%d\\n\", sum  final static boolean DEBUG = true; // debug private final static boolean DEBUG = false; // release public static void main(String[] args) throws IOException { if (DEBUG) { log = System.out; String inputStr = \"1:15:\"; inputStr = inputStr.replace(\":\", \"\\n\"); reader = new BufferedReader(new StringReader(inputStr)); } else { log = new PrintStream(new OutputStream() { public void write(int b) {} }  } int N = Integer.MAX_VALUE; //int N = readIntArray()[0]; for(int i = 0; i < N; i++) { boolean b = new Main().main(); if (!b) break; } reader.close();  EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7 private static int[] readIntArray() throws IOException { String s =  (s == null) return null; s = s.trim(); if (s.length() != 0) // \u0081\u00a6\u0081\u00a6\u0081\u00a6\u0081@\u0082\u00c7\u0082\u00a4\u0082\u00e0\u0093\u00cb\u0091R\u008b\u00f3\u008ds\u0082\u00f0\u0093\u00c7\u0082\u00de\u0082\u00b1\u0082\u00c6\u0082\u00aa\u0082 \u0082\u00e9\u0081B\u0093\u00c7\u0082\u00dd\u0094\u00f2\u0082\u00ce\u0082\u00b7\u0082\u00c6\u0082\u00a4\u0082\u00dc\u0082\u00ad\u0082\u00a2\u0082\u00ad\u0082\u00e7\u0082\u00b5\u0082\u00a2\u0081B\u0081B\u0081B\u0081B break; } String[] sp = s.split(\"[ ,]\"); // \u008b\u00e6\u0090\u00d8\u0082\u00e8\u0095\u00b6\u008e\u009a\u0082\u00cd\u0083X\u0083y\u0081[\u0083X\u0082\u00a9\u0083J\u0083\u0093\u0083} int[] a = new int[sp.length]; for(int i = 0; i < sp.length; i++) { a[i] = Integer.parseInt(sp[i]); } return a; } }"], "original_ll": -1.6692527532577515, "sampled_ll": -0.32606762647628784, "all_perturbed_sampled_ll": [-1.187148928642273], "all_perturbed_original_ll": [-2.2894604206085205], "perturbed_sampled_ll": -1.187148928642273, "perturbed_original_ll": -2.2894604206085205, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(raw_input())\n    if n == 0: break\n    ans = [[0]*4 for i in range(n)]\n    for i in range(n):\n        line = raw_input().split()\n        ans[i][2] = -i\n        ans[i][3] = line[0]\n        for c in line[1:]:\n            if c == '0':\n                ans[i][0] += 1\n            elif c == '1':\n                ans[i][1] -= 1\n    for a in sorted(ans, key=lambda x: (x[0], x[1], x[2]), reverse=True):\n        print a[3]", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    teams = []\n    for i in range(n):\n        line = input().split()\n        name = line[0]\n        results = list(map(int, line[1:]))\n        \n        wins = results.count(0)\n        losses = results.count(1)\n        \n        teams.append((name, wins, losses, i))\n    \n    # Sort by wins (descending), then losses (ascending), then input order (ascending)\n    teams.sort(key=lambda x: (-x[1], x[2], x[3]))\n    \n    for team in teams:\n        print(team[0])\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break teams = [] for i in range(n): line = input().split() name = line[0] results = list(map(int, line[1:])) wins = results.count(0) losses = results.count(1) teams.append((name, wins, losses, i)) # Sort by wins (descending), then losses (ascending), then input order  print(team[0])"], "perturbed_original": ["while True: n = int(raw_input()) if n == 0: break ans = [[0]*4 for i  = -i ans[i][3] = line[0] for c in line[1:]: if c == '0': ans[i][0] += 1 elif c == '1': ans[i][1] -= 1 for a in sorted(ans, key=lambda x: (x[0], x[1], x[2]), reverse=True): print a[3]"], "original_ll": -0.9418922662734985, "sampled_ll": -0.876808762550354, "all_perturbed_sampled_ll": [-1.5929147005081177], "all_perturbed_original_ll": [-1.7923475503921509], "perturbed_sampled_ll": -1.5929147005081177, "perturbed_original_ll": -1.7923475503921509, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void)\n{    \n    int a, b, r;\n    int count = 1;\n        \n    while(scanf(\"%d %d\", &a, &b) != EOF)\n    {     \n        if(a == 0 && b == 0)\n        {        \n            break;\n        }\n        \n        r = a % b;        \n        while(r!=0){            \n            a = b;            \n            b = r;            \n            r = a % b;            \n            count++;  \n            \n            \n        }\n        printf(\"%d %d\\n\",b,count);\n    }        \n      \n    return(0);\n    \n}\n", "sampled": "#include <stdio.h>\n\nint main() {\n    long long a, b;\n    \n    while (1) {\n        scanf(\"%lld %lld\", &a, &b);\n        \n        if (a == 0 && b == 0) {\n            break;\n        }\n        \n        long long x = a;\n        long long y = b;\n        int steps = 0;\n        long long temp;\n        \n        while (y != 0) {\n            temp = x % y;\n            x = y;\n            y = temp;\n            steps++;\n        }\n        \n        printf(\"%lld %d\\n\", x, steps);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { long long a, b; while (1) { scanf(\"%lld %lld\", &a, &b); if (a == 0 &&  a; long long y = b; int steps = 0; long long  y; x = y; y = temp; steps++; } printf(\"%lld %d\\n\", x, steps); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int a, b, r; int count = 1; while(scanf(\"%d %d\", &a, &b) != EOF) { if(a == 0 && b == )<extra_id_7>(b== a = b; b = r; r = a % b; count++; } printf(\"%d %d\\n\",b,count); } return(0); }"], "original_ll": -1.2448683977127075, "sampled_ll": -0.5486181974411011, "all_perturbed_sampled_ll": [-1.6854865550994873], "all_perturbed_original_ll": [-2.191352128982544], "perturbed_sampled_ll": -1.6854865550994873, "perturbed_original_ll": -2.191352128982544, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n \n         \n        public static void main(String[] args) throws java.io.IOException{\n            Scanner scan = new Scanner(System.in);\n            while(true){\n                int a =scan.nextInt();\n                int b = scan.nextInt();\n                if((a|b)==0)break;\n                if(b>a){\n                    a=a^b;\n                    b=a^b;\n                    a=a^b;\n                }\n                int c=0;\n                while(b!=0){\n                    a=a%b;\n                    a=a^b;\n                    b=a^b;\n                    a=a^b;\n                    c++;\n                }\n                System.out.println(a+\" \"+c);\n            }\n  \n        }\n   \n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long a = sc.nextLong();\n            long b = sc.nextLong();\n            \n            if (a == 0 && b == 0) {\n                break;\n            }\n            \n            long x = a;\n            long y = b;\n            int steps = 0;\n            \n            while (y != 0) {\n                long temp = x % y;\n                x = y;\n                y = temp;\n                steps++;\n            }\n            \n            System.out.println(x + \" \" + steps);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  sc.nextLong(); long b = sc.nextLong(); if (a == 0 && b == 0) { break; } long x = a; long y = b; int steps  x % y; x = y; y = temp; steps++; } System.out.println(x + \" \" + steps); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main  = new Scanner(System.in); while(true){ int a =scan.nextInt(); int b = scan.nextInt(); if((a|b)==0)break; if(b>a){ a=a^b; b=a^b; a=a^b; } int c=0; while(b!=0){ a=a%b; a=a^b; b=a^b; a=a^b; c++; } System.out.println(a+\" \"+c); } } }"], "original_ll": -1.0985480546951294, "sampled_ll": -0.4532148838043213, "all_perturbed_sampled_ll": [-1.745911955833435], "all_perturbed_original_ll": [-1.4598113298416138], "perturbed_sampled_ll": -1.745911955833435, "perturbed_original_ll": -1.4598113298416138, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\ndef f(d,x,y):\n    t = x % y\n    x = y\n    y = t\n    if y != 0:\n        return f(d+1,x,y)\n    else:\n        return (x,d+1)\n\nwhile 1:\n    y,x = sorted(list(map(int, input().split())))\n    if x == 0: break\n    ans = f(0,x,y)\n    print(ans[0],ans[1])\n\n\n", "sampled": "while True:\n    a, b = map(int, input().split())\n    if a == 0 and b == 0:\n        break\n    \n    x, y = a, b\n    steps = 0\n    \n    while y != 0:\n        remainder = x % y\n        x = remainder\n        x, y = y, x\n        steps += 1\n    \n    print(x, steps)\n", "perturbed_sampled": ["while True: a,  == 0: break x, y = a, b steps = 0 while y != 0: remainder = x % y x = remainder x, y = y, x steps += 1 print(x, steps)"], "perturbed_original": ["import sys def f(d,x,y): t = x % y x = y y = t if y !=  sorted(list(map(int, input().split()))) if x == 0: break ans = f(0,x,y) print(ans[0],ans[1])"], "original_ll": -1.4383140802383423, "sampled_ll": -0.9032934904098511, "all_perturbed_sampled_ll": [-2.1371426582336426], "all_perturbed_original_ll": [-2.715061902999878], "perturbed_sampled_ll": -2.1371426582336426, "perturbed_original_ll": -2.715061902999878, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\tint n,i,j,z;\n\tchar c1[1001],c2[1001],c3[1001],c4[1001],c5[1001],c6[1001];\n\twhile(n!=0){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%s %s %s %s %s %s\",&c1[i],&c2[i],&c3[i],&c4[i],&c5[i],&c6[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tz=0;\n\t\tfor(j=0;j<n;j++){\n\t\tif(c1[i]==c1[j] && c2[i]==c2[j] && c3[i]==c3[j] && c4[i]==c4[j] && c5[i]==c5[j] && c6[i]==c6[j]){\n\t\t\tz=z+1;\n\t\t}\n\t\telse if(c4[i]==c4[j] && c1[i]==c1[j] && c3[i]==c3[j] && c6[i]==c6[j]){\n\t\t\tif(c5[i]==c5[j] && c2[i]==c2[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c4[i]==c6[j] && c1[i]==c3[j] && c3[i]==c1[j] && c6[i]==c4[j]){\n\t\t\tif(c5[i]==c2[j] && c2[i]==c5[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c6[j] && c3[i]==c3[j] && c1[i]==c1[j] && c4[i]==c4[j]){\n\t\t\tif(c5[i]==c5[j] && c2[i]==c2[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c4[j] && c3[i]==c1[j] && c1[i]==c3[j] && c4[i]==c6[j]){\n\t\t\tif(c2[i]==c5[j] && c5[i]==c2[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c2[i]==c2[j] && c1[i]==c1[j] && c5[i]==c5[j] && c6[i]==c6[j]){\n\t\t\tif(c4[i]==c4[j] && c3[i]==c3[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c2[i]==c6[j] && c1[i]==c5[j] && c5[i]==c1[j] && c6[i]==c2[j]){\n\t\t\tif(c4[i]==c3[j] && c3[i]==c4[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c6[j] && c5[i]==c5[j] && c1[i]==c1[j] && c2[i]==c2[j]){\n\t\t\tif(c3[i]==c3[j] && c4[i]==c4[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c2[j] && c5[i]==c1[j] && c1[i]==c5[j] && c2[i]==c6[j]){\n\t\t\tif(c3[i]==c4[j] && c4[i]==c3[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",n);\n\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char faces[6][10];\n} Cube;\n\nvoid rotateCube(Cube *c, Cube *result, int rotation) {\n    // 24 rotations of a cube\n    int rotations[24][6] = {\n        {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5},\n        {1,0,3,2,5,4}, {1,2,0,5,3,4}, {1,3,5,0,2,4}, {1,5,2,3,0,4},\n        {2,0,1,4,5,3}, {2,1,5,0,4,3}, {2,4,0,5,1,3}, {2,5,4,1,0,3},\n        {3,0,4,1,5,2}, {3,1,0,5,4,2}, {3,4,5,0,1,2}, {3,5,1,4,0,2},\n        {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1},\n        {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0}\n    };\n    \n    for (int i = 0; i < 6; i++) {\n        strcpy(result->faces[i], c->faces[rotations[rotation][i]]);\n    }\n}\n\nint compareCubes(Cube *c1, Cube *c2) {\n    for (int i = 0; i < 6; i++) {\n        int cmp = strcmp(c1->faces[i], c2->faces[i]);\n        if (cmp != 0) return cmp;\n    }\n    return 0;\n}\n\nint areSameCube(Cube *c1, Cube *c2) {\n    Cube rotated;\n    for (int r = 0; r < 24; r++) {\n        rotateCube(c1, &rotated, r);\n        if (compareCubes(&rotated, c2) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Cube cubes[30];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 6; j++) {\n                scanf(\"%s\", cubes[i].faces[j]);\n            }\n        }\n        \n        int unique[30];\n        int uniqueCount = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int isUnique = 1;\n            for (int j = 0; j < uniqueCount; j++) {\n                if (areSameCube(&cubes[i], &cubes[unique[j]])) {\n                    isUnique = 0;\n                    break;\n                }\n            }\n            if (isUnique) {\n                unique[uniqueCount++] = i;\n            }\n        }\n        \n        printf(\"%d\\n\", n - uniqueCount);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef  *result, int rotation) { // 24 rotations of a cube int rotations[24][6] = { {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5}, {1,0,3,2,5,4}, {1,2,0,5,3,4},  {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1}, {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0} }; for (int i = 0; i < 6; i++) { strcpy(result->faces[i], c->faces[rotations[rotation][i]]); } } int compareCubes(Cube *c1, Cube *c2) { for (int i = 0; i < 6; i++) { int cmp = strcmp(c1->faces[i], c2->faces[i]); if (cmp != 0) return cmp; } return 0; } int areSameCube(Cube *c1, Cube *c2) {  r++) { rotateCube(c1, &rotated, r); if (compareCubes(&rotated, c2) == 0) { return 1; } } return 0; } int main() { int n; while (scanf(\"%d\", &n) == 1 && n != 0) { Cube cubes[30]; for (int i =  0; j < 6; j++) { scanf(\"%s\", cubes[i].faces[j]); } } int unique[30]; int uniqueCount = 0; for (int i = 0; i < n; i++) { int  uniqueCount; j++) { if (areSameCube(&cubes[i], &cubes[unique[j]])) { isUnique = 0; break; } }  - uniqueCount); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int n,i,j,z; char c1[1001],c2[1001],c3[1001],c4[1001],c5[1001],c6[1001]; while(n!=0){ scanf(\"%d\",&n); for(i=0;i<n;i++){ scanf(\"%s %s %s %s %s %s\",&c1[i],&c2[i],&c3[i],&c4[i],&c5[i],&c6[i]); } for(i=0;i<n;i++){ z=0; for(j=0;j<n;j++){ if(c1[i]==c1[j] && c2[i]==c2[j] && c3[i]==c3[j] && c4[i]==c4[j] && c5[i]==c5[j] && c6[i]==c6[j]){  if(c5[i]==c5[j] && c2[i]==c2[j]){ z=z+1;  if(c5[i]==c2[j] && c2[i]==c5[j]){ z=z+1; } } else if(c6[i]==c6[j] && c3[i]==c3[j] && c1[i]==c1[j] && c4[i]==c4[j]){ if(c5[i]==c5[j] && c2[i]==c2[j]){ z=z+1; } } else if(c6[i]==c4[j] && c3[i]==c1[j] && c1[i]==c3[j] && c4[i]==c6[j]){ if(c2[i]==c5[j] && c5[i]==c2[j]){ z=z+1; } } else if(c2[i]==c2[j] && c1[i]==c1[j] &&  c3[i]==c4[j]){ z=z+1; } } else if(c6[i]==c6[j] && c5[i]==c5[j] && c1[i]==c1[j] && c2[i]==c2[j]){ if(c3[i]==c3[j] && c4[i]==c4[j]){ z=z+1; } } else if(c6[i]==c2[j] && c5[i]==c1[j] && c1[i]==c5[j] && c2[i]==c6[j]){ if(c3[i]==c4[j] && c4[i]==c3[j]){ z=z+1; } } } } printf(\"%d\\n\",n); scanf(\"%d\",&n); } return 0; }"], "original_ll": -0.386676549911499, "sampled_ll": -0.5065474510192871, "all_perturbed_sampled_ll": [-1.118558645248413], "all_perturbed_original_ll": [-0.5532528162002563], "perturbed_sampled_ll": -1.118558645248413, "perturbed_original_ll": -0.5532528162002563, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n\n    ArrayList<char[]> color,list;\n    ArrayList<String> clist;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        clist = new ArrayList<String>();\n        clist.add(\"Red\");\n        clist.add(\"Yellow\");\n        clist.add(\"Blue\");\n        clist.add(\"Magenta\");\n        clist.add(\"Green\");\n        clist.add(\"Cyan\");\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            color = new ArrayList<char[]>();\n            int cnt = 0;\n            for(int i=0; i<n; i++){\n                char[] c = new char[6];\n                for(int j=0; j<6; j++) c[j] = (char)clist.indexOf(sc.next());\n                if(same(c)) cnt++;\n                else color.add(c);\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    int[][] rotate = {{1,2,4,3},{0,4,5,1},{0,2,5,3}};\n\n    boolean same(char[] dice){\n        list = new ArrayList<char[]>();\n        for(int i=0; i<4; i++){\n            dice = rotate(dice,0);\n            for(int j=0; j<4; j++){\n                dice = rotate(dice,1);\n                for(int l=0; l<4; l++){\n                    dice = rotate(dice,2);\n                    list.add(dice);\n                }\n            }\n        }\n\n        for(int i=0; i<list.size(); i++){\n            char[] s1 = list.get(i);\n            for(int j=0; j<color.size(); j++){\n                boolean boo = false;\n                char[] s2 = color.get(j);\n                for(int k=0; k<6; k++){\n                    if(s1[k]!=s2[k]){\n                        boo = false;\n                        break;\n                    }\n                    boo = true;\n                }\n                if(boo) return true;\n            }\n        }\n        return false;\n    }\n\n    char[] rotate(char[] dice, int idx){\n        char[] res = new char[6];\n        for(int i=0; i<6; i++) res[i] = dice[i];\n\n        char tmp = res[rotate[idx][3]];\n        for(int i=3; i>0; i--) res[rotate[idx][i]] = res[rotate[idx][i-1]];\n        res[rotate[idx][0]] = tmp;\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Cube {\n        String[] faces = new String[6];\n        \n        Cube(String[] f) {\n            faces = f.clone();\n        }\n        \n        // Generate all 24 rotations of the cube\n        List<String> getAllRotations() {\n            Set<String> rotations = new HashSet<>();\n            \n            // All 24 orientations of a cube\n            int[][] orientations = {\n                {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5},\n                {1,0,3,2,5,4}, {1,2,0,5,3,4}, {1,3,5,0,2,4}, {1,5,2,3,0,4},\n                {2,0,1,4,5,3}, {2,1,5,0,4,3}, {2,4,0,5,1,3}, {2,5,4,1,0,3},\n                {3,0,4,1,5,2}, {3,1,0,5,4,2}, {3,4,5,0,1,2}, {3,5,1,4,0,2},\n                {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1},\n                {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0}\n            };\n            \n            for (int[] orient : orientations) {\n                StringBuilder sb = new StringBuilder();\n                for (int i = 0; i < 6; i++) {\n                    if (i > 0) sb.append(\" \");\n                    sb.append(faces[orient[i]]);\n                }\n                rotations.add(sb.toString());\n            }\n            \n            return new ArrayList<>(rotations);\n        }\n        \n        String getCanonical() {\n            List<String> rotations = getAllRotations();\n            Collections.sort(rotations);\n            return rotations.get(0);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            sc.nextLine();\n            \n            Set<String> uniqueCubes = new HashSet<>();\n            \n            for (int i = 0; i < n; i++) {\n                String[] colors = sc.nextLine().split(\" \");\n                Cube cube = new Cube(colors);\n                String canonical = cube.getCanonical();\n                uniqueCubes.add(canonical);\n            }\n            \n            int needed = n - uniqueCubes.size();\n            System.out.println(needed);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Cube { String[] faces =  Generate all 24  new HashSet<>(); // All 24 orientations of a cube int[][] orientations = { {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5}, {1,0,3,2,5,4},  {3,5,1,4,0,2}, {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1}, {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0} };  StringBuilder();  if (i > 0) sb.append(\" \"); sb.append(faces[orient[i]]); } rotations.add(sb.toString()); } return new ArrayList<>(rotations); } String getCanonical() { List<String> rotations = getAllRotations(); Collections.sort(rotations); return rotations.get(0); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; sc.nextLine(); Set<String> uniqueCubes = new HashSet<>(); for (int i = 0; i < n; i++) { String[] colors = sc.nextLine().split(\" \"); Cube cube = new Cube(colors); String canonical = cube.getCanonical(); uniqueCubes.add(canonical); } int needed = n - uniqueCubes.size(); System.out.println(needed); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ ArrayList<char[]> color,list; ArrayList<String> clist; void solve(){ Scanner sc = new Scanner(System.in); clist = new ArrayList<String>(); clist.add(\"Red\"); clist.add(\"Yellow\"); clist.add(\"Blue\"); clist.add(\"Magenta\"); clist.add(\"Green\"); clist.add(\"Cyan\"); while(true){ int n = sc.nextInt(); if(n==0) break; color = new ArrayList<char[]>(); int cnt = 0; for(int i=0; i<n; i++){ char[] c = new char[6]; for(int j=0; j<6; j++) c[j] = (char)clist.indexOf(sc.next()); if(same(c)) cnt++; else color.add(c); }  for(int l=0; l<4; l++){ dice = rotate(dice,2); list.add(dice); } } } for(int i=0; i<list.size(); i++){ char[] s1 = list.get(i); for(int j=0; j<color.size(); j++){ boolean boo = false; char[] s2 = color.get(j); for(int k=0; k<6; k++){ if(s1[k]!=s2[k]){ boo = false; break; } boo = true; } if(boo) return  idx){ char[] res = new char[6]; for(int i=0; i<6; i++) res[i] = dice[i]; char tmp = res[rotate[idx][3]];  return res; } public static void main(String[] args){ new Main().solve(); } }"], "original_ll": -0.8817908763885498, "sampled_ll": -0.5371676087379456, "all_perturbed_sampled_ll": [-1.144095778465271], "all_perturbed_original_ll": [-1.380519986152649], "perturbed_sampled_ll": -1.144095778465271, "perturbed_original_ll": -1.380519986152649, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def equal(B):\n    temp=B[:]\n    S=set()\n    for i in range(4):\n        for j in range(4):\n            for k in range(4):\n                roll(0,2,5,3,temp)\n                S.add(tuple(temp))\n            roll(0,1,5,4,temp)\n        roll(1,2,4,3,temp)\n    return S\n\ndef roll(i,j,k,l,temp):\n    t=temp[i]\n    temp[i]=temp[j]\n    temp[j]=temp[k]\n    temp[k]=temp[l]\n    temp[l]=t\n\nwhile True:\n    n=input()\n    if n==0:break\n    L=[raw_input().split() for i in range(n)]\n    cnt=0\n    for i in range(n-1):\n        for j in range(i+1,n):\n            S=equal(L[j])\n            if tuple(L[i]) in S:\n                cnt+=1\n    print cnt", "sampled": "def normalize_cube(colors):\n    # Colors: [top, front, right, left, back, bottom]\n    # Indices:  0     1      2     3     4      5\n    \n    # Generate all 24 orientations of the cube\n    orientations = []\n    \n    # Original orientation\n    c = colors\n    \n    # All 24 rotations of a cube\n    # 4 rotations with each of the 6 faces as top\n    \n    def rotate_x(cube):\n        # Rotate around x-axis (right face axis) by 90 degrees\n        return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]]\n    \n    def rotate_y(cube):\n        # Rotate around y-axis (top face axis) by 90 degrees\n        return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]]\n    \n    def rotate_z(cube):\n        # Rotate around z-axis (front face axis) by 90 degrees\n        return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]]\n    \n    # Generate all 24 orientations\n    current = colors[:]\n    \n    for _ in range(4):\n        orientations.append(tuple(current))\n        for _ in range(3):\n            current = rotate_z(current)\n            orientations.append(tuple(current))\n        current = rotate_y(current)\n    \n    current = rotate_x(colors[:])\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.append(tuple(current))\n    \n    current = rotate_x(rotate_x(rotate_x(colors[:])))\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.append(tuple(current))\n    \n    # Return the lexicographically smallest orientation\n    return min(orientations)\n\ndef get_all_orientations(colors):\n    orientations = set()\n    \n    def rotate_x(cube):\n        return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]]\n    \n    def rotate_y(cube):\n        return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]]\n    \n    def rotate_z(cube):\n        return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]]\n    \n    current = colors[:]\n    for _ in range(4):\n        orientations.add(tuple(current))\n        for _ in range(3):\n            current = rotate_z(current)\n            orientations.add(tuple(current))\n        current = rotate_y(current)\n    \n    current = rotate_x(colors[:])\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.add(tuple(current))\n    \n    current = rotate_x(rotate_x(rotate_x(colors[:])))\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.add(tuple(current))\n    \n    return orientations\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    cubes = []\n    for _ in range(n):\n        colors = input().split()\n        cubes.append(colors)\n    \n    unique_cubes = set()\n    \n    for cube in cubes:\n        canonical = normalize_cube(cube)\n        unique_cubes.add(canonical)\n    \n    needed = n - len(unique_cubes)\n    print(needed)\n", "perturbed_sampled": ["def normalize_cube(colors): # Colors: [top, front, right, left, back, bottom] # Indices: 0 1 2 3 4  All 24 rotations of a cube # 4 rotations with each of the 6 faces as top def rotate_x(cube): # Rotate around x-axis (right face  cube[4]] def rotate_y(cube): # Rotate around y-axis (top face axis) by 90 degrees return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]] def rotate_z(cube): # Rotate around z-axis (front face axis) by 90 degrees return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]] # Generate all 24 orientations current = colors[:] for _ in range(4): orientations.append(tuple(current)) for _ in range(3): current = rotate_z(current) orientations.append(tuple(current)) current = rotate_y(current) current  current = rotate_x(rotate_x(rotate_x(colors[:]))) for _ in range(3): current = rotate_z(current) orientations.append(tuple(current)) # Return the lexicographically smallest orientation return min(orientations) def get_all_orientations(colors): orientations = set() def rotate_x(cube): return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]] def rotate_y(cube): return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]] def rotate_z(cube): return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]] current = colors[:] for _ in range(4): orientations.add(tuple(current)) for  rotate_z(current) orientations.add(tuple(current)) current = rotate_x(rotate_x(rotate_x(colors[:])))  while True: n = int(input()) if n == 0: break cubes  unique_cubes = set() for cube in cubes: canonical = normalize_cube(cube) unique_cubes.add(canonical) needed = n - len(unique_cubes) print(needed)"], "perturbed_original": ["def equal(B): temp=B[:]  k in range(4): roll(0,2,5,3,temp) S.add(tuple(temp)) roll(0,1,5,4,temp) roll(1,2,4,3,temp) return S def roll(i,j,k,l,temp): t=temp[i] temp[i]=temp[j] temp[j]=temp[k] temp[k]=temp[l] temp[l]=t while True: n=input() if n==0:break L=[raw_input().split() for i in range(n)] cnt=0 for i in range(n-1): for j in range(i+1,n): S=equal(L[j]) if tuple(L[i]) in S: cnt+=1 print cnt"], "original_ll": -1.2207125425338745, "sampled_ll": -0.7497959733009338, "all_perturbed_sampled_ll": [-1.3755232095718384], "all_perturbed_original_ll": [-1.9314810037612915], "perturbed_sampled_ll": -1.3755232095718384, "perturbed_original_ll": -1.9314810037612915, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,m,p;\nchar s[2],c[101];\nA(){\n\tfor(p=0;c[p]!='#';p++);\n}\nB(){\n\tfor(p=n-1;p>=0;p--)\n\t\tif(c[p]=='#'&&(p+1==n||c[p+1]!='A')&&(p-1<0||c[p-1]!='A'))\n\t\t\treturn;\n\tA();\n}\nC(){\n\tfor(p=0;p<n;p++){\n\t\tif(c[p]!='#'){\n\t\t\tif(p+1!=n&&c[p+1]=='#'){\n\t\t\t\tp++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(p-1>=0&&c[p-1]=='#'){\n\t\t\t\tp--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tp=n/2;\n}\nD(){\n\tint D[100],d=n,q;\n\tfor(p=-1;++p<n;){\n\t\td++;\n\t\tif(c[p]!='#')\n\t\t\td=0;\n\t\tD[p]=d;\n\t}\n\tfor(d=0;--p>=0;){\n\t\td++;\n\t\tif(c[p]!='#')\n\t\t\td=0;\n\t\tif(d<D[p])\n\t\t\tD[p]=d;\n\t}\n\tfor(p=q=0;q<n;q++)\n\t\tif(D[q]>D[p])\n\t\t\tp=q;\n}\nmain(){\n\tfor(;scanf(\"%d%d\",&n,&m),n;){\n\t\tmemset(c,'#',100);\n\t\tc[n]=0;\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s\",s);\n\t\t\tif(s[0]=='A')\n\t\t\t\tA();\n\t\t\tif(s[0]=='B')\n\t\t\t\tB();\n\t\t\tif(s[0]=='C')\n\t\t\t\tC();\n\t\t\tif(s[0]=='D')\n\t\t\t\tD();\n\t\t\tc[p]=s[0];\n\t\t}\n\t\tputs(c);\n\t}\n\texit(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, m;\n    \n    while(1) {\n        scanf(\"%d %d\", &n, &m);\n        if(n == 0 && m == 0) break;\n        \n        char seats[101];\n        for(int i = 0; i < n; i++) {\n            seats[i] = '#';\n        }\n        \n        for(int i = 0; i < m; i++) {\n            char type;\n            scanf(\" %c\", &type);\n            \n            if(type == 'A') {\n                // Left to right, first empty seat\n                for(int j = 0; j < n; j++) {\n                    if(seats[j] == '#') {\n                        seats[j] = 'A';\n                        break;\n                    }\n                }\n            }\n            else if(type == 'B') {\n                // Right to left, not next to A\n                int pos = -1;\n                for(int j = n-1; j >= 0; j--) {\n                    if(seats[j] == '#') {\n                        int nextToA = 0;\n                        if(j > 0 && seats[j-1] == 'A') nextToA = 1;\n                        if(j < n-1 && seats[j+1] == 'A') nextToA = 1;\n                        if(!nextToA) {\n                            pos = j;\n                            break;\n                        }\n                    }\n                }\n                if(pos == -1) {\n                    // All empty seats are next to A, take leftmost empty\n                    for(int j = 0; j < n; j++) {\n                        if(seats[j] == '#') {\n                            pos = j;\n                            break;\n                        }\n                    }\n                }\n                seats[pos] = 'B';\n            }\n            else if(type == 'C') {\n                // Next to someone, prefer right then left of leftmost person\n                int hasAnyone = 0;\n                for(int j = 0; j < n; j++) {\n                    if(seats[j] != '#') {\n                        hasAnyone = 1;\n                        break;\n                    }\n                }\n                \n                if(!hasAnyone) {\n                    // Sit in middle\n                    int mid = (n % 2 == 1) ? (n+1)/2 - 1 : n/2;\n                    seats[mid] = 'C';\n                } else {\n                    int pos = -1;\n                    for(int j = 0; j < n; j++) {\n                        if(seats[j] != '#') {\n                            if(j+1 < n && seats[j+1] == '#') {\n                                pos = j+1;\n                                break;\n                            } else if(j-1 >= 0 && seats[j-1] == '#') {\n                                pos = j-1;\n                                break;\n                            }\n                        }\n                    }\n                    seats[pos] = 'C';\n                }\n            }\n            else if(type == 'D') {\n                // Maximize minimum distance to nearest person\n                int hasAnyone = 0;\n                for(int j = 0; j < n; j++) {\n                    if(seats[j] != '#') {\n                        hasAnyone = 1;\n                        break;\n                    }\n                }\n                \n                if(!hasAnyone) {\n                    seats[0] = 'D';\n                } else {\n                    int bestPos = -1;\n                    int maxMinDist = -1;\n                    \n                    for(int j = 0; j < n; j++) {\n                        if(seats[j] == '#') {\n                            int minDist = n+1;\n                            for(int k = 0; k < n; k++) {\n                                if(seats[k] != '#') {\n                                    int dist = (j > k) ? (j - k) : (k - j);\n                                    if(dist < minDist) minDist = dist;\n                                }\n                            }\n                            if(minDist > maxMinDist) {\n                                maxMinDist = minDist;\n                                bestPos = j;\n                            }\n                        }\n                    }\n                    seats[bestPos] = 'D';\n                }\n            }\n        }\n        \n        for(int i = 0; i < n; i++) {\n            printf(\"%c\", seats[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main()  if(n == 0 && m == 0) break; char seats[101]; for(int i = 0; i < n; i++) {  m; i++) { char type; scanf(\" %c\", &type); if(type == 'A') { // Left to right, first empty seat for(int j = 0; j < n; j++) { if(seats[j] == '#') { seats[j] = 'A'; break; } } } else if(type == 'B') { // Right to left, not next to A int pos = -1; for(int j = n-1; j >= 0; j--) { if(seats[j]  && seats[j-1] == 'A')  nextToA = 1; if(!nextToA) { pos = j; break; } } } if(pos == -1)  leftmost empty for(int j = 0; j < n; j++) { if(seats[j] == '#') { pos = j; break; } } } seats[pos] = 'B'; } else if(type == 'C') { // Next to someone,  0; for(int j  { hasAnyone = 1;  mid = (n % 2 == 1) ? (n+1)/2 - 1 : n/2; seats[mid] = 'C'; } else { int pos = -1; for(int j = 0; j < n; j++) { if(seats[j] !=  pos = j+1; break; } else if(j-1 >= 0 && seats[j-1] == '#') { pos = j-1; break; } } } seats[pos] = 'C'; } } else if(type == 'D') { // Maximize minimum  = 0; j < n; j++) { if(seats[j] != '#') { hasAnyone = 1; break; } } if(!hasAnyone) { seats[0] = 'D'; } else { int  0; j < n; j++) { if(seats[j] == '#') {  n; k++) { if(seats[k] != '#') { int dist = (j > k) ? (j -  dist; } } if(minDist > maxMinDist) { maxMinDist = minDist; bestPos = j; } } } seats[bestPos] = 'D'; } } } for(int i = 0; i < n; i++) { printf(\"%c\", seats[i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["n,m,p; char s[2],c[101]; A(){ for(p=0;c[p]!='#';p++);  if(p+1!=n&&c[p+1]=='#'){ p++; return; } if(p-1>=0&&c[p-1]=='#'){ p--; return; } } } p=n/2;  for(d=0;--p>=0;){ d++; if(c[p]!='#') d=0; if(d<D[p]) D[p]=d; } for(p=q=0;q<n;q++) if(D[q]>D[p]) p=q; } main(){ for(;scanf(\"%d%d\",&n,&m),n;){ memset(c,'#',100); c[n]=0; for(;m--;){ scanf(\"%s\",s); if(s[0]=='A') A(); if(s[0]=='B') B(); if(s[0]=='C') C(); if(s[0]=='D') D(); c[p]=s[0]; } puts(c); } exit(0); }"], "original_ll": -1.2072032690048218, "sampled_ll": -0.5393253564834595, "all_perturbed_sampled_ll": [-1.388008713722229], "all_perturbed_original_ll": [-1.7270523309707642], "perturbed_sampled_ll": -1.388008713722229, "perturbed_original_ll": -1.7270523309707642, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tchar[] a = new char[n+2];\n\t\t\tArrays.fill(a,'#');\n\t\t\ta[0] = 'X';\n\t\t\ta[n+1] = 'X';\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif(c=='A'){\n\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\tif(a[j]=='#'){\n\t\t\t\t\t\t\ta[j] = c;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(c=='B'){\n\t\t\t\t\tboolean flag = true;\n\t\t\t\t\tfor(int j=n;j>0;j--){\n\t\t\t\t\t\tif(a[j]=='#' && a[j-1]!='A' && a[j+1]!='A'){\n\t\t\t\t\t\t\ta[j] = c;\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==true){\n\t\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\t\tif(a[j]=='#'){\n\t\t\t\t\t\t\t\ta[j] = c;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(c=='C'){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tif(n%2==0) a[(n+1)/2] = c;\n\t\t\t\t\t\telse a[n/2+1] = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\t\tif(a[j]!='#'){\n\t\t\t\t\t\t\t\tif(a[j+1]=='#'){\n\t\t\t\t\t\t\t\t\ta[j+1] = c;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(a[j-1]=='#'){\n\t\t\t\t\t\t\t\t\ta[j-1] = c;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(c=='D'){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\ta[1] = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint max = -1;\n\t\t\t\t\t\tint p = -1;\n\t\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\t\tif(a[j]=='#'){\n\t\t\t\t\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\t\t\t\t\tfor(int k=j-1;k>=0;k--){\n\t\t\t\t\t\t\t\t\tif(k==0) break;\n\t\t\t\t\t\t\t\t\tif(a[k]!='#'){\n\t\t\t\t\t\t\t\t\t\tmin = Math.min(min, j-k+1);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j+1;k<=n+1;k++){\n\t\t\t\t\t\t\t\t\tif(k==n+1) break;\n\t\t\t\t\t\t\t\t\tif(a[k]!='#'){\n\t\t\t\t\t\t\t\t\t\tmin = Math.min(min, k-j+1);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min>max){\n\t\t\t\t\t\t\t\t\tmax = min;\n\t\t\t\t\t\t\t\t\tp = j;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[p] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++) System.out.print(a[i]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) break;\n            \n            char[] chairs = new char[n];\n            Arrays.fill(chairs, '#');\n            \n            for (int i = 0; i < m; i++) {\n                String nationality = sc.next();\n                char person = nationality.charAt(0);\n                \n                if (person == 'A') {\n                    // Left to right, first empty chair\n                    for (int j = 0; j < n; j++) {\n                        if (chairs[j] == '#') {\n                            chairs[j] = 'A';\n                            break;\n                        }\n                    }\n                } else if (person == 'B') {\n                    // Right to left, not next to A\n                    boolean found = false;\n                    for (int j = n - 1; j >= 0; j--) {\n                        if (chairs[j] == '#') {\n                            boolean nextToA = false;\n                            if (j > 0 && chairs[j - 1] == 'A') nextToA = true;\n                            if (j < n - 1 && chairs[j + 1] == 'A') nextToA = true;\n                            \n                            if (!nextToA) {\n                                chairs[j] = 'B';\n                                found = true;\n                                break;\n                            }\n                        }\n                    }\n                    \n                    if (!found) {\n                        // Must sit next to A, left to right\n                        for (int j = 0; j < n; j++) {\n                            if (chairs[j] == '#') {\n                                chairs[j] = 'B';\n                                break;\n                            }\n                        }\n                    }\n                } else if (person == 'C') {\n                    // Next to someone, prefer right then left\n                    boolean found = false;\n                    \n                    // Check if anyone is sitting\n                    boolean anyoneSeated = false;\n                    for (int j = 0; j < n; j++) {\n                        if (chairs[j] != '#') {\n                            anyoneSeated = true;\n                            break;\n                        }\n                    }\n                    \n                    if (!anyoneSeated) {\n                        // Sit in middle\n                        int middle = (n % 2 == 1) ? n / 2 : n / 2;\n                        chairs[middle] = 'C';\n                    } else {\n                        // Find leftmost person and try right, then left\n                        for (int j = 0; j < n; j++) {\n                            if (chairs[j] != '#') {\n                                // Try right\n                                if (j + 1 < n && chairs[j + 1] == '#') {\n                                    chairs[j + 1] = 'C';\n                                    found = true;\n                                    break;\n                                }\n                                // Try left\n                                if (j - 1 >= 0 && chairs[j - 1] == '#') {\n                                    chairs[j - 1] = 'C';\n                                    found = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                } else if (person == 'D') {\n                    // Maximize minimum distance\n                    boolean anyoneSeated = false;\n                    for (int j = 0; j < n; j++) {\n                        if (chairs[j] != '#') {\n                            anyoneSeated = true;\n                            break;\n                        }\n                    }\n                    \n                    if (!anyoneSeated) {\n                        chairs[0] = 'D';\n                    } else {\n                        int bestPos = -1;\n                        int maxMinDist = -1;\n                        \n                        for (int j = 0; j < n; j++) {\n                            if (chairs[j] == '#') {\n                                int minDist = Integer.MAX_VALUE;\n                                \n                                for (int k = 0; k < n; k++) {\n                                    if (chairs[k] != '#') {\n                                        minDist = Math.min(minDist, Math.abs(j - k));\n                                    }\n                                }\n                                \n                                if (minDist > maxMinDist) {\n                                    maxMinDist = minDist;\n                                    bestPos = j;\n                                }\n                            }\n                        }\n                        \n                        chairs[bestPos] = 'D';\n                    }\n                }\n            }\n            \n            System.out.println(new String(chairs));\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) {  == 0 && m == 0) break; char[] chairs = new char[n]; Arrays.fill(chairs, '#'); for (int i  sc.next(); char  to right, first empty chair for (int j = 0; j < n; j++) { if (chairs[j] == '#') { chairs[j] = 'A'; break; } } } else if (person == 'B') { // Right to left, not next to A boolean  j >= 0; j--) { if (chairs[j] == '#') { boolean nextToA = false; if (j  + 1] == 'A')  = true; break; } } } if (!found) { // Must sit next to A, left to right for (int j = 0; j < n; j++) { if (chairs[j] == '#') {  (person == 'C') { // Next to someone, prefer right then left boolean found = false;  for (int j = 0; j < n; j++) { if (chairs[j] != '#') { anyoneSeated = true; break; } } if (!anyoneSeated) { // Sit in middle int middle = (n % 2 == 1) ? n / 2 : n / 2; chairs[middle] = 'C'; } else { // Find leftmost person and try right, then left for (int j = 0; j < n; j++) { if (chairs[j] != '#') { // Try right if (j + 1 < n && chairs[j + 1] == '#') { chairs[j + 1] =  (j - 1 >= 0 && chairs[j - 1] == '#') { chairs[j - 1] = 'C'; found = true; break; } } } } } else if (person == 'D') { // Maximize minimum distance boolean anyoneSeated = false; for  (chairs[j] != '#') { anyoneSeated = true; break; } } if (!anyoneSeated) { chairs[0] = 'D'; } else { int bestPos = -1; int maxMinDist = -1; for (int j = 0; j < n; j++) { if (chairs[j]  = 0; k < n; k++) { if (chairs[k] != '#') { minDist = Math.min(minDist, Math.abs(j - k)); } } if (minDist >  } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){  m==0) break; char[] a = new char[n+2]; Arrays.fill(a,'#'); a[0] = 'X'; a[n+1] = 'X'; for(int i=0;i<m;i++){ char c =  if(a[j]=='#' && a[j-1]!='A' && a[j+1]!='A'){ a[j] = c; flag = false; break; } } if(flag==true){ for(int  if(c=='C'){ if(i==0){ if(n%2==0) a[(n+1)/2] = c; else a[n/2+1] = c; }else{ for(int j=1;j<=n;j++){ if(a[j]!='#'){ if(a[j+1]=='#'){ a[j+1] = c; break; } if(a[j-1]=='#'){ a[j-1] = c; break; } } } } }else if(c=='D'){ if(i==0){ a[1] = c; }else{ int max = -1; int p = -1; for(int j=1;j<=n;j++){ if(a[j]=='#'){ int min = Integer.MAX_VALUE; for(int  } for(int k=j+1;k<=n+1;k++){ if(k==n+1) break; if(a[k]!='#'){ min = Math.min(min, k-j+1); break; } } if(min>max){ max = min; p = j; } } } a[p] = c; } } } for(int i=1;i<=n;i++) System.out.print(a[i]); System.out.println(); } } }"], "original_ll": -0.5161633491516113, "sampled_ll": -0.5180969834327698, "all_perturbed_sampled_ll": [-1.4213777780532837], "all_perturbed_original_ll": [-1.1443843841552734], "perturbed_sampled_ll": -1.4213777780532837, "perturbed_original_ll": -1.1443843841552734, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "INF = 10 ** 20\n\nwhile True:\n  n, m = map(int, input().split())\n  if not n:\n    break\n\n  chairs = list(\"#\" * n)\n\n  def sit(s):\n    if s == \"A\":\n      chairs[chairs.index(\"#\")] = \"A\"\n    elif s == \"B\":\n      for i in range(n - 1, -1, -1):\n        if chairs[i] == \"#\" and (i == 0 or chairs[i - 1] != \"A\") and (i == n - 1 or chairs[i + 1] != \"A\"):\n          chairs[i] = \"B\"\n          break\n      else:\n        chairs[chairs.index(\"#\")] = \"B\"\n\n    elif s == \"C\":\n      for i in range(1, n):\n        if chairs[i] == \"#\" and chairs[i - 1] != \"#\":\n          chairs[i] = \"C\"\n          break\n\n    else:\n      score = [INF for _ in range(n)]\n      dist = INF\n      for i in range(n):\n        if chairs[i] == \"#\":\n          dist += 1\n        else:\n          dist = 0\n        score[i] = dist\n\n      dist = INF\n      for i in range(n - 1, -1, -1):\n        if chairs[i] == \"#\":\n          dist += 1\n        else:\n          dist = 0\n        score[i] = min(score[i], dist)\n      high_score = max(score)\n      chairs[score.index(high_score)] = \"D\"\n  \n  first = input()\n  if first in [\"A\", \"D\"]:\n    chairs[0] = first\n  elif first == \"B\":\n    chairs[-1] = \"B\"\n  else:\n    chairs[n // 2] = \"C\"\n  for _ in range(m - 1):\n    sit(input())\n\n  print(\"\".join(chairs))\n\n", "sampled": "import sys\n\ndef solve(n, m, passengers):\n    seats = ['#'] * n  # 0-indexed\n    \n    for passenger in passengers:\n        if passenger == 'A':\n            # Left to right, first empty\n            for i in range(n):\n                if seats[i] == '#':\n                    seats[i] = 'A'\n                    break\n                    \n        elif passenger == 'B':\n            # Avoid A, right to left\n            # First try to find seat not adjacent to A\n            found = False\n            for i in range(n-1, -1, -1):\n                if seats[i] == '#':\n                    # Check if adjacent to A\n                    adjacent_to_a = False\n                    if i > 0 and seats[i-1] == 'A':\n                        adjacent_to_a = True\n                    if i < n-1 and seats[i+1] == 'A':\n                        adjacent_to_a = True\n                    \n                    if not adjacent_to_a:\n                        seats[i] = 'B'\n                        found = True\n                        break\n            \n            # If not found, sit left to right (adjacent to A is ok)\n            if not found:\n                for i in range(n):\n                    if seats[i] == '#':\n                        seats[i] = 'B'\n                        break\n                        \n        elif passenger == 'C':\n            # Sit next to someone\n            # Find leftmost person, try right then left\n            found = False\n            \n            # Check if anyone is seated\n            someone_seated = any(s != '#' for s in seats)\n            \n            if someone_seated:\n                for i in range(n):\n                    if seats[i] != '#':\n                        # Try right\n                        if i < n-1 and seats[i+1] == '#':\n                            seats[i+1] = 'C'\n                            found = True\n                            break\n                        # Try left\n                        elif i > 0 and seats[i-1] == '#':\n                            seats[i-1] = 'C'\n                            found = True\n                            break\n            \n            if not found:\n                # Sit in middle\n                if n % 2 == 1:\n                    mid = n // 2\n                else:\n                    mid = n // 2\n                seats[mid] = 'C'\n                \n        elif passenger == 'D':\n            # Maximize minimum distance\n            # If no one seated, sit at left end\n            someone_seated = any(s != '#' for s in seats)\n            \n            if not someone_seated:\n                seats[0] = 'D'\n            else:\n                # Find empty seat with max min distance\n                best_seat = -1\n                best_min_dist = -1\n                \n                for i in range(n):\n                    if seats[i] == '#':\n                        # Calculate min distance to any occupied seat\n                        min_dist = float('inf')\n                        for j in range(n):\n                            if seats[j] != '#':\n                                min_dist = min(min_dist, abs(i - j))\n                        \n                        if min_dist > best_min_dist:\n                            best_min_dist = min_dist\n                            best_seat = i\n                \n                seats[best_seat] = 'D'\n    \n    return ''.join(seats)\n\n# Read input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.strip())\n\ni = 0\nwhile i < len(lines):\n    parts = lines[i].split()\n    n, m = int(parts[0]), int(parts[1])\n    \n    if n == 0 and m == 0:\n        break\n    \n    i += 1\n    passengers = []\n    for j in range(m):\n        passengers.append(lines[i])\n        i += 1\n    \n    result = solve(n, m, passengers)\n    print(result)\n", "perturbed_sampled": ["import sys def solve(n, m, passengers): seats = ['#'] * n # 0-indexed for passenger in passengers: if passenger == 'A': # Left to right, first empty for i in range(n):  First try to find seat not adjacent to A found = False for i in range(n-1, -1, -1):  adjacent_to_a = False if i > 0 and seats[i-1] == 'A': adjacent_to_a = True if i < n-1 and seats[i+1] == 'A': adjacent_to_a = True if not adjacent_to_a: seats[i] = 'B' found =  (adjacent to A is ok)  '#': seats[i] = 'B' break elif  leftmost person, try right then left found = False # Check if anyone is seated someone_seated = any(s != '#'  if seats[i] != '#': # Try right if i < n-1 and seats[i+1] == '#': seats[i+1] = 'C' found = True break  '#': seats[i-1] = 'C' found = True break if not found: # Sit in middle if  else: mid = n // 2 seats[mid] = 'C' elif passenger == 'D': # Maximize minimum distance # If no one seated, sit at left end someone_seated = any(s != '#' for s in seats) if not someone_seated: seats[0] = 'D' else: # Find empty seat with max min distance best_seat = -1 best_min_dist = -1 for i in range(n): if seats[i] == '#': # Calculate min distance to any occupied seat min_dist =  = min(min_dist, abs(i - j)) if min_dist > best_min_dist: best_min_dist = min_dist best_seat = i seats[best_seat] = 'D' return ''.join(seats) # Read input lines = [] for line in sys.stdin: lines.append(line.strip()) i = 0 while i < len(lines): parts = lines[i].split() n, m = int(parts[0]), int(parts[1]) if n == 0 and m == 0: break i +=  += 1 result = solve(n, m, passengers) print(result)"], "perturbed_original": ["INF = 10 ** 20 while True: n, m = map(int, input().split()) if not n: break chairs  chairs[chairs.index(\"#\")] = \"A\" elif s == \"B\": for i in range(n - 1, -1, -1): if chairs[i] == \"#\" and (i == 0 or chairs[i - 1] != \"A\") and (i == n - 1 or chairs[i + 1] != \"A\"): chairs[i] = \"B\" break else: chairs[chairs.index(\"#\")] = \"B\" elif s == \"C\": for i in range(1, n): if chairs[i] == \"#\" and chairs[i - 1] != \"#\": chairs[i] = \"C\" break else: score = [INF for _ in range(n)] dist  dist += 1 else: dist = 0 score[i] = dist dist = INF for i in range(n - 1, -1, -1): if chairs[i] == \"#\": dist += 1 else: dist = 0 score[i] =  input() if  \"B\": chairs[-1] = \"B\"  - 1): sit(input()) print(\"\".join(chairs))"], "original_ll": -0.9353145956993103, "sampled_ll": -0.7778886556625366, "all_perturbed_sampled_ll": [-1.7674052715301514], "all_perturbed_original_ll": [-1.599546194076538], "perturbed_sampled_ll": -1.7674052715301514, "perturbed_original_ll": -1.599546194076538, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int i,j,k,l,n,m;\n  int d[2][100][100]={0};\n  while(scanf(\"%d %d\",&m,&n),n||m){\n    for(i=0;i<100;i++){\n      for(j=0;j<100;j++)d[0][i][j]=d[1][i][j]=100000000;\n      d[0][i][i]=d[1][i][i]=0;\n    }\n    while(m--){\n      scanf(\"%d %d %d %d\",&i,&j,&k,&l);\n      d[0][i-1][j-1]=d[0][j-1][i-1]=k;\n      d[1][i-1][j-1]=d[1][j-1][i-1]=l;\n    }\n    for(l=0;l<n;l++){\n      //for(i=0;i<2;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++){\n\t  //for(l=0;l<n;l++){\n\t  for(i=0;i<2;i++){\n\t    if(d[i][j][k]>d[i][j][l]+d[i][l][k]){\n\t       d[i][j][k]=d[i][j][l]+d[i][l][k];\n\t    }\n\t  }\n\t}\n      }\n    }\n    scanf(\"%d\",&l);\n    while(l--){\n      scanf(\"%d %d %d\",&i,&j,&k);\n      printf(\"%d\\n\",d[k][i-1][j-1]);\n    }\n  }\n  return 0;\n}\n      ", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_M 105\n#define INF 1000000000\n\nint n, m, k;\nint cost_graph[MAX_M][MAX_M];\nint time_graph[MAX_M][MAX_M];\n\nint dijkstra(int graph[MAX_M][MAX_M], int start, int end) {\n    int dist[MAX_M];\n    int visited[MAX_M];\n    int i, j;\n    \n    for (i = 1; i <= m; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    \n    dist[start] = 0;\n    \n    for (i = 0; i < m; i++) {\n        int min_dist = INF;\n        int u = -1;\n        \n        for (j = 1; j <= m; j++) {\n            if (!visited[j] && dist[j] < min_dist) {\n                min_dist = dist[j];\n                u = j;\n            }\n        }\n        \n        if (u == -1) break;\n        \n        visited[u] = 1;\n        \n        for (j = 1; j <= m; j++) {\n            if (!visited[j] && graph[u][j] != INF) {\n                if (dist[u] + graph[u][j] < dist[j]) {\n                    dist[j] = dist[u] + graph[u][j];\n                }\n            }\n        }\n    }\n    \n    return dist[end];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0) break;\n        \n        int i, j;\n        \n        for (i = 1; i <= m; i++) {\n            for (j = 1; j <= m; j++) {\n                if (i == j) {\n                    cost_graph[i][j] = 0;\n                    time_graph[i][j] = 0;\n                } else {\n                    cost_graph[i][j] = INF;\n                    time_graph[i][j] = INF;\n                }\n            }\n        }\n        \n        for (i = 0; i < n; i++) {\n            int a, b, cost, time;\n            scanf(\"%d %d %d %d\", &a, &b, &cost, &time);\n            \n            if (cost < cost_graph[a][b]) {\n                cost_graph[a][b] = cost;\n                cost_graph[b][a] = cost;\n            }\n            \n            if (time < time_graph[a][b]) {\n                time_graph[a][b] = time;\n                time_graph[b][a] = time;\n            }\n        }\n        \n        scanf(\"%d\", &k);\n        \n        for (i = 0; i < k; i++) {\n            int p, q, r;\n            scanf(\"%d %d %d\", &p, &q, &r);\n            \n            if (r == 0) {\n                printf(\"%d\\n\", dijkstra(cost_graph, p, q));\n            } else {\n                printf(\"%d\\n\", dijkstra(time_graph, p, q));\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h> #define MAX_M 105 #define INF 1000000000 int n, m, k; int cost_graph[MAX_M][MAX_M]; int time_graph[MAX_M][MAX_M]; int dijkstra(int graph[MAX_M][MAX_M], int start, int end) { int dist[MAX_M]; int visited[MAX_M]; int i, j; for (i =   int u = -1; for (j = 1; j <= m; j++) { if (!visited[j] &&  } }  = 1; j <= m; j++) { if (!visited[j] && graph[u][j] != INF) { if (dist[u] + graph[u][j] < dist[j]) { dist[j] = dist[u] + graph[u][j]; } } } } return dist[end]; } int main() { while (1) { scanf(\"%d %d\", &n, &m); if (n == 0 && m == 0) break; int i,  for (j = 1; j <= m; j++) { if (i == j) { cost_graph[i][j] = 0; time_graph[i][j]  INF; } } } for (i = 0; i < n; i++) { int a, b, cost, time; scanf(\"%d %d %d %d\", &a, &b, &cost, &time); if (cost < cost_graph[a][b]) { cost_graph[a][b] = cost; cost_graph[b][a] = cost; } if (time < time_graph[a][b]) { time_graph[a][b] = time; time_graph[b][a] = time; } } scanf(\"%d\", &k); for (i = 0;  %d %d\", &p, &q, &r); if (r == 0) { printf(\"%d\\n\", dijkstra(cost_graph, p, q)); } else { printf(\"%d\\n\", dijkstra(time_graph, p, q)); } } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int i,j,k,l,n,m; int d[2][100][100]={0}; while(scanf(\"%d %d\",&m,&n),n||m){ for(i=0;i<100;i++){ for(j=0;j<100;j++)d[0][i][j]=d[1][i][j]=100000000; d[0][i][i]=d[1][i][i]=0; } while(m--){ scanf(\"%d  //for(l=0;l<n;l++){ for(i=0;i<2;i++){ if(d[i][j][k]>d[i][j][l]+d[i][l][k]){ d[i][j][k]=d[i][j][l]+d[i][l][k]; } } } } } scanf(\"%d\",&l); while(l--){ scanf(\"%d %d %d\",&i,&j,&k); printf(\"%d\\n\",d[k][i-1][j-1]); } } return 0; }"], "original_ll": -0.6904141902923584, "sampled_ll": -0.33233898878097534, "all_perturbed_sampled_ll": [-0.8914207220077515], "all_perturbed_original_ll": [-0.98021000623703], "perturbed_sampled_ll": -0.8914207220077515, "perturbed_original_ll": -0.98021000623703, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic final int INF = 1000000000;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] cost = new int[m][m];\n\t\t\tint[][] time = new int[m][m];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t\t\ttime[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tcost[a][b] = sc.nextInt();\n\t\t\t\tcost[b][a] = cost[a][b];\n\t\t\t\ttime[a][b] = sc.nextInt();\n\t\t\t\ttime[b][a] = time[a][b];\n\t\t\t}\n\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\t\tfor(int j = i; j < m; j++){\n\t\t\t\t\t\tcost[i][j] = Math.min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t\t\tcost[j][i] = cost[i][j];\n\t\t\t\t\t\ttime[i][j] = Math.min(time[i][j], time[i][k] + time[k][j]);\n\t\t\t\t\t\ttime[j][i] = time[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint k = sc.nextInt();\n\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\tint p = sc.nextInt() - 1;\n\t\t\t\tint q = sc.nextInt() - 1;\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tif(r == 0){\n\t\t\t\t\tSystem.out.println(cost[p][q]);\n\t\t\t\t}else if(r == 1){\n\t\t\t\t\tSystem.out.println(time[p][q]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, cost, time;\n        Edge(int to, int cost, int time) {\n            this.to = to;\n            this.cost = cost;\n            this.time = time;\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        int node, value;\n        State(int node, int value) {\n            this.node = node;\n            this.value = value;\n        }\n        public int compareTo(State other) {\n            return this.value - other.value;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) break;\n            \n            List<Edge>[] graph = new ArrayList[m + 1];\n            for (int i = 0; i <= m; i++) {\n                graph[i] = new ArrayList<>();\n            }\n            \n            for (int i = 0; i < n; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int cost = sc.nextInt();\n                int time = sc.nextInt();\n                graph[a].add(new Edge(b, cost, time));\n                graph[b].add(new Edge(a, cost, time));\n            }\n            \n            int k = sc.nextInt();\n            for (int i = 0; i < k; i++) {\n                int p = sc.nextInt();\n                int q = sc.nextInt();\n                int r = sc.nextInt();\n                \n                if (r == 0) {\n                    System.out.println(dijkstra(graph, m, p, q, true));\n                } else {\n                    System.out.println(dijkstra(graph, m, p, q, false));\n                }\n            }\n        }\n        sc.close();\n    }\n    \n    static int dijkstra(List<Edge>[] graph, int m, int start, int end, boolean useCost) {\n        int[] dist = new int[m + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(start, 0));\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            int u = current.node;\n            int d = current.value;\n            \n            if (d > dist[u]) continue;\n            \n            for (Edge edge : graph[u]) {\n                int v = edge.to;\n                int weight = useCost ? edge.cost : edge.time;\n                \n                if (dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.offer(new State(v, dist[v]));\n                }\n            }\n        }\n        \n        return dist[end];\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Edge { int to, cost,  to; this.cost = cost; this.time = time; } } static class State implements Comparable<State> { int node, value; State(int node, int value) { this.node = node; this.value = value; } public int compareTo(State other) { return this.value - other.value; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); int m = sc.nextInt(); if (n == 0 && m == 0) break; List<Edge>[] graph = new ArrayList[m + 1]; for (int i = 0; i <= m; i++) {  i < n; i++) {  = sc.nextInt(); int time  } int k = sc.nextInt(); for (int i = 0; i < k; i++) {  = sc.nextInt(); if (r ==  System.out.println(dijkstra(graph, m, p, q, false)); } } } sc.close(); } static int dijkstra(List<Edge>[] graph, int m, int start, int end, boolean useCost) { int[] dist  PriorityQueue<State> pq = new PriorityQueue<>(); pq.offer(new State(start, 0)); while (!pq.isEmpty()) { State current = pq.poll(); int u = current.node; int d = current.value; if (d > dist[u]) continue; for (Edge edge : graph[u]) { int v = edge.to; int weight  < dist[v]) { dist[v] = dist[u] + weight; pq.offer(new State(v, dist[v])); } } } return dist[end]; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { static final int INF = 1000000000; public static void main(String[] args) { // TODO Auto-generated method stub Scanner sc = new Scanner(System.in); while(true){ int n = sc.nextInt(); int <extra_id_3>i><extra_id_4>i > m ;<extra_id_5>1 ] >=<extra_id_6>]<extra_id_7>time<extra_id_8>[ p<extra_id_9>r ; } /* j--<extra_id_10>< 12)*/ { //<extra_id_11>p<extra_id_12>0 ] ><extra_id_13>[<extra_id_14>m ; i ++ )<extra_id_15>r += i<extra_id_16>else<extra_id_17>System.out.println(time[p][q]); } } } }<extra_id_18>//<extra_id_19>int n; int m<extra_id_20>j=0 m; i++){ for(int j = 0; j < m; j++){ cost[i][j] = INF; time[i][j] = INF; } } for(int i = 0; i < n; i++){ int a = sc.nextInt() - 1; int b = sc.nextInt() - 1; cost[a][b] = sc.nextInt(); cost[b][a] = cost[a][b]; time[a][b] = sc.nextInt(); time[b][a] = time[a][b]; } for(int k = 0; k < m; k++){ for(int i = 0; i < m; i++){ for(int j = i; j <  cost[i][j]; time[i][j] = Math.min(time[i][j], time[i][k] + time[k][j]); time[j][i] = time[i][j]; } } } int k = sc.nextInt(); for(int i = 0; i < k;  0){ System.out.println(cost[p][q]); }else if(r == 1){ System.out.println(time[p][q]); } } } sc.close(); } }"], "original_ll": -0.37354564666748047, "sampled_ll": -0.3793591260910034, "all_perturbed_sampled_ll": [-1.1261615753173828], "all_perturbed_original_ll": [-1.5272506475448608], "perturbed_sampled_ll": -1.1261615753173828, "perturbed_original_ll": -1.5272506475448608, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nfrom copy import deepcopy\nINF = 1000000000\ndef dj(s, e, r):\n  d = [INF] * 100\n  done = [0] * 100\n  d[s] = 0\n  while True:\n    v = -1\n    for i in VL:\n      if not done[i] and (v == -1 or d[i] < d[v]):\n        v = i\n    if v == e:\n      return d[e]\n    done[v] = True\n    for i in VL:\n      d[i] = min(d[i], d[v] + cost[v][i][r])\n\nL100 = range(100)\ncostPre = [[[INF for k in range(2)] for j in L100] for i in L100]\nwhile True:\n  E, V = map(int, raw_input().split())\n  cost = deepcopy(costPre)\n  VL = range(V)\n  if not E:\n    break\n  for i in range(E):\n    a, b, c, d = map(int, raw_input().split())\n    a -= 1\n    b -= 1\n    cost[a][b][0] = cost[b][a][0] = c\n    cost[a][b][1] = cost[b][a][1] = d\n  k = input()\n  for i in range(k):\n    p, q, r = map(int, raw_input().split())\n    p -= 1\n    q -= 1\n    print dj(p, q, r)", "sampled": "import heapq\nfrom collections import defaultdict\nimport sys\n\ndef dijkstra(graph, start, end, mode):\n    # mode: 0 for cost, 1 for time\n    pq = [(0, start)]\n    visited = set()\n    dist = defaultdict(lambda: float('inf'))\n    dist[start] = 0\n    \n    while pq:\n        current_dist, node = heapq.heappop(pq)\n        \n        if node in visited:\n            continue\n            \n        visited.add(node)\n        \n        if node == end:\n            return current_dist\n        \n        for neighbor, cost, time in graph[node]:\n            weight = cost if mode == 0 else time\n            new_dist = current_dist + weight\n            \n            if new_dist < dist[neighbor]:\n                dist[neighbor] = new_dist\n                heapq.heappush(pq, (new_dist, neighbor))\n    \n    return dist[end]\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    if not line:\n        break\n    n = int(line)\n    m = int(sys.stdin.readline().strip())\n    \n    if n == 0 and m == 0:\n        break\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n):\n        parts = list(map(int, sys.stdin.readline().strip().split()))\n        a, b, cost, time = parts[0], parts[1], parts[2], parts[3]\n        graph[a].append((b, cost, time))\n        graph[b].append((a, cost, time))\n    \n    k = int(sys.stdin.readline().strip())\n    \n    for _ in range(k):\n        parts = list(map(int, sys.stdin.readline().strip().split()))\n        p, q, r = parts[0], parts[1], parts[2]\n        result = dijkstra(graph, p, q, r)\n        print(result)\n", "perturbed_sampled": ["import heapq from collections import defaultdict import sys def dijkstra(graph, start, end, mode): # mode: 0 for cost, 1 for time pq = [(0, start)] visited = set() dist = defaultdict(lambda: float('inf')) dist[start] = 0 while pq: current_dist, node = heapq.heappop(pq) if node in visited: continue visited.add(node) if node == end: return current_dist for  == 0 else time new_dist = current_dist + weight if new_dist  while True: line = sys.stdin.readline().strip() if not line:  for _ in range(n): parts = list(map(int, sys.stdin.readline().strip().split())) a, b, cost, time = parts[0], parts[1], parts[2], parts[3] graph[a].append((b, cost, time)) graph[b].append((a, cost, time)) k = int(sys.stdin.readline().strip()) for _ in range(k): parts = list(map(int, sys.stdin.readline().strip().split())) p, q, r = parts[0], parts[1], parts[2] result = dijkstra(graph, p, q, r) print(result)"], "perturbed_original": ["from copy import deepcopy INF = 1000000000 def dj(s, e, r): d = [INF] * 100 done = [0] * 100 d[s] = 0 while True: v = -1 for i in VL: if not done[i] and (v  i  range(100) costPre = [[[INF for k in range(2)] for j in L100] for i in L100] while True: E, V =  E: break for i in range(E): a, b, c, d = map(int, raw_input().split()) a -= 1 b -= 1 cost[a][b][0] = cost[b][a][0] = c cost[a][b][1] = cost[b][a][1] = d k = input() for i in range(k): p, q, r = map(int, raw_input().split()) p -= 1 q -= 1 print dj(p, q, r)"], "original_ll": -0.9250554442405701, "sampled_ll": -0.546992838382721, "all_perturbed_sampled_ll": [-1.2765038013458252], "all_perturbed_original_ll": [-1.7598923444747925], "perturbed_sampled_ll": -1.2765038013458252, "perturbed_original_ll": -1.7598923444747925, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-2 0201: Wrought Gold Master\n// 2017.8.17 bal4u@uu\n// ??\u00a2?????????????????????????????\\????????????????????\u00a3?????????\n\n#include <stdio.h>\n#include <string.h>\n\n#define HSIZ 499\ntypedef struct { char *w; int k; } HASH;\nHASH hash[HSIZ + 5];\n\nint lookup(char *w)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\tif (tp->w != NULL) {\n\t\tint inc = *w + (*(w + 1) << 1);\n\t\twhile (1) {\n\t\t\tif (!strcmp(tp->w, w)) return tp->k;\n\t\t\ti += inc; if (i >= HSIZ) i -= HSIZ;\n\t\t\ttp = hash + i;\n\t\t\tif (tp->w == NULL) break;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint insert(char *w, int k)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\tif (tp->w != NULL) {\n\t\tint inc = *w + (*(w + 1) << 1);\n\t\twhile (1) {\n\t\t\tif (!strcmp(tp->w, w)) return -1;\n\t\t\ti += inc; if (i >= HSIZ) i -= HSIZ;\n\t\t\ttp = hash + i;\n\t\t\tif (tp->w == NULL) break;\n\t\t}\n\t}\n\ttp->w = w, tp->k = k;\n\treturn 0;\n}\n\ntypedef struct { char a[102]; int m, k, i[102]; } MONO;\nMONO mono[205]; int no;\n\nint combi(int a)\n{\n\tint i, k, c = -1;\n\tk = mono[a].k;\n\tif (k > 0) for (c = i = 0; i < k; i++) c += combi(mono[a].i[i]);\n\tif (c < 0 || (mono[a].m >= 0 && mono[a].m < c)) c = mono[a].m;\n\treturn c;\n}\n\nint main()\n{\n\tint i, j, k, N, M;\n\tchar b[102];\n\n\twhile (scanf(\"%d\", &N) == 1 && N) {\n\t\tmemset(hash, 0, sizeof(hash)), no = 0;\n\t\twhile (N-- > 0) {\n\t\t\tscanf(\"%s%d\", mono[no].a, &(mono[no].m));\n\t\t\tmono[no].k = 0; insert(mono[no].a, no);\n\t\t\tno++;\n\t\t}\n\t\tscanf(\"%d\", &M);\n\t\twhile (M--) {\n\t\t\tscanf(\"%s%d\", mono[no].a, &k);\n\t\t\tif ((i = lookup(mono[no].a)) < 0) insert(mono[no].a, no), mono[no].m = -1, i = no++;\n\t\t\tmono[i].k = k;\n\t\t\tfor (j = 0; j < mono[i].k; j++) scanf(\"%s\", b), mono[i].i[j] = lookup(b);\n\t\t}\n\t\tscanf(\"%s\", b);\n\t\tprintf(\"%d\\n\", combi(lookup(b)));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_ITEMS 100\n#define MAX_NAME 101\n\ntypedef struct {\n    char name[MAX_NAME];\n    int price;\n    int has_recipe;\n    int num_ingredients;\n    int ingredients[MAX_ITEMS];\n} Item;\n\nItem items[MAX_ITEMS];\nint n, m;\nint memo[MAX_ITEMS];\nint computed[MAX_ITEMS];\n\nint find_item(char *name) {\n    for (int i = 0; i < n; i++) {\n        if (strcmp(items[i].name, name) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint min_cost(int idx) {\n    if (computed[idx]) {\n        return memo[idx];\n    }\n    \n    computed[idx] = 1;\n    int buy_cost = items[idx].price;\n    \n    if (!items[idx].has_recipe) {\n        memo[idx] = buy_cost;\n        return buy_cost;\n    }\n    \n    int craft_cost = 0;\n    for (int i = 0; i < items[idx].num_ingredients; i++) {\n        craft_cost += min_cost(items[idx].ingredients[i]);\n    }\n    \n    memo[idx] = (buy_cost < craft_cost) ? buy_cost : craft_cost;\n    return memo[idx];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s %d\", items[i].name, &items[i].price);\n            items[i].has_recipe = 0;\n            items[i].num_ingredients = 0;\n            computed[i] = 0;\n        }\n        \n        scanf(\"%d\", &m);\n        for (int i = 0; i < m; i++) {\n            char output[MAX_NAME];\n            int k;\n            scanf(\"%s %d\", output, &k);\n            \n            int out_idx = find_item(output);\n            items[out_idx].has_recipe = 1;\n            items[out_idx].num_ingredients = k;\n            \n            for (int j = 0; j < k; j++) {\n                char ingredient[MAX_NAME];\n                scanf(\"%s\", ingredient);\n                int ing_idx = find_item(ingredient);\n                items[out_idx].ingredients[j] = ing_idx;\n            }\n        }\n        \n        char target[MAX_NAME];\n        scanf(\"%s\", target);\n        int target_idx = find_item(target);\n        \n        printf(\"%d\\n\", min_cost(target_idx));\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAX_ITEMS 100 #define MAX_NAME 101 typedef struct { char name[MAX_NAME]; int price; int has_recipe; int num_ingredients; int ingredients[MAX_ITEMS]; } Item; Item  *name) { for (int i = 0; i < n; i++) { if (strcmp(items[i].name, name) == 0) { return i; } } return -1; } int min_cost(int idx) { if (computed[idx]) { return memo[idx]; } computed[idx] = 1; int buy_cost = items[idx].price;  craft_cost = 0; for (int i = 0; i < items[idx].num_ingredients; i++) { craft_cost += min_cost(items[idx].ingredients[i]); } memo[idx] = (buy_cost < craft_cost) ? buy_cost : craft_cost; return memo[idx]; } int main() { while (1) { scanf(\"%d\", &n); if (n == 0) break; for (int i = 0; i < n; i++) { scanf(\"%s %d\", items[i].name, &items[i].price); items[i].has_recipe = 0; items[i].num_ingredients = 0; computed[i] = 0;  output, &k); int out_idx =  = 0; j < k; j++) { char ingredient[MAX_NAME]; scanf(\"%s\", ingredient); int ing_idx = find_item(ingredient);  target_idx = find_item(target); printf(\"%d\\n\", min_cost(target_idx)); } return 0; }"], "perturbed_original": ["// Aizu Vol-2 0201: Wrought Gold Master // 2017.8.17 bal4u@uu // ??\u00a2?????????????????????????????\\????????????????????\u00a3????????? #include <stdio.h> #include <string.h> #define HSIZ 499 typedef struct { char *w; int k; } HASH; HASH hash[HSIZ + 5]; int lookup(char *w) { int i, l; HASH *tp; i = (101 * *w + 103 * *(w  % HSIZ; tp = hash + i; if (tp->w != NULL) { int inc = *w + (*(w + 1) << 1); while (1) { if (!strcmp(tp->w, w)) return tp->k; i += inc; if  i; if (tp->w == NULL) break; } } return -1; } int insert(char *w, int k) { int i, l; HASH *tp; i = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ; tp = hash + i; if (tp->w != NULL) { int inc = *w +  w)) return -1; i += inc; if (i >= HSIZ) i -= HSIZ; tp =  tp->w = w, tp->k = k; return 0; } typedef struct { char a[102]; int m, k, i[102]; } MONO; MONO mono[205]; int no; int combi(int a) { int i, k, c = -1; k =  0; i < k; i++) c += combi(mono[a].i[i]); if (c < 0 || (mono[a].m >= 0 && mono[a].m < c)) c = mono[a].m; return c; } int main() { int i, j, k, N, M; char b[102]; while (scanf(\"%d\",  = 0; while (N-- > 0) { scanf(\"%s%d\", mono[no].a, &(mono[no].m)); mono[no].k =  scanf(\"%s%d\", mono[no].a, &k); if ((i =  scanf(\"%s\", b); printf(\"%d\\n\", combi(lookup(b))); } return 0; }"], "original_ll": -1.1127487421035767, "sampled_ll": -0.5903927087783813, "all_perturbed_sampled_ll": [-1.2933698892593384], "all_perturbed_original_ll": [-1.8649932146072388], "perturbed_sampled_ll": -1.2933698892593384, "perturbed_original_ll": -1.8649932146072388, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tprice = new HashMap<String,Integer>();\n\t\t\twhile(n-- > 0){\n\t\t\t\tprice.put(sc.next(),sc.nextInt());\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\tmap = new HashMap<String,ArrayList<String>>();\n\t\t\twhile(n-- > 0){\n\t\t\t\tString s = sc.next();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tmap.put(s,new ArrayList<String>());\n\t\t\t\twhile(m-- > 0){\n\t\t\t\t\tmap.get(s).add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = new HashMap<String,Integer>();\n\t\t\tSystem.out.println(minCost(sc.next()));\n\t\t}\n\t}\n\n\tprivate static HashMap<String,Integer> price;\n\tprivate static HashMap<String,ArrayList<String>> map;\n\tprivate static HashMap<String,Integer> dp;\n\n\tprivate static int minCost(String s){\n\t\tif(map.get(s) == null) return price.get(s);\n\t\tif(dp.get(s) != null) return dp.get(s);\n\n\t\tint sum = 0;\n\n\t\tfor(String tmp : map.get(s)){\n\t\t\tsum += minCost(tmp);\n\t\t}\n\n\t\tdp.put(s, price.get(s) == null ? sum : Math.min(sum,price.get(s)));\n\n\t\treturn dp.get(s);\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static Map<String, Integer> itemPrice;\n    static Map<String, List<String>> recipes;\n    static Map<String, Integer> memo;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            itemPrice = new HashMap<>();\n            recipes = new HashMap<>();\n            memo = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                int price = sc.nextInt();\n                itemPrice.put(name, price);\n            }\n            \n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                String output = sc.next();\n                int k = sc.nextInt();\n                List<String> inputs = new ArrayList<>();\n                for (int j = 0; j < k; j++) {\n                    inputs.add(sc.next());\n                }\n                recipes.put(output, inputs);\n            }\n            \n            String target = sc.next();\n            System.out.println(getMinCost(target));\n        }\n        \n        sc.close();\n    }\n    \n    static int getMinCost(String item) {\n        if (memo.containsKey(item)) {\n            return memo.get(item);\n        }\n        \n        int buyPrice = itemPrice.get(item);\n        int minCost = buyPrice;\n        \n        if (recipes.containsKey(item)) {\n            List<String> ingredients = recipes.get(item);\n            int craftCost = 0;\n            for (String ingredient : ingredients) {\n                craftCost += getMinCost(ingredient);\n            }\n            minCost = Math.min(minCost, craftCost);\n        }\n        \n        memo.put(item, minCost);\n        return minCost;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static Map<String,  public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; itemPrice = new HashMap<>(); recipes = new HashMap<>(); memo = new HashMap<>(); for (int i = 0; i < n; i++) { String name = sc.next(); int price = sc.nextInt(); itemPrice.put(name, price); } int m = sc.nextInt(); for (int i = 0; i < m; i++) { String output = sc.next(); int k = sc.nextInt(); List<String> inputs = new ArrayList<>();  inputs.add(sc.next());  sc.close(); } static int getMinCost(String item) { if (memo.containsKey(item)) { return memo.get(item); } int buyPrice = itemPrice.get(item); int minCost = buyPrice; if (recipes.containsKey(item)) { List<String> ingredients = recipes.get(item);  craftCost += getMinCost(ingredient);  } }"], "perturbed_original": ["import java.util.*; public class Main{ public static void  = sc.nextInt(); if(n == 0) break; price = new HashMap<String,Integer>(); while(n-- > 0){ price.put(sc.next(),sc.nextInt()); } n = sc.nextInt(); map = new HashMap<String,ArrayList<String>>(); while(n-- > 0){ String s = sc.next(); int m = sc.nextInt(); map.put(s,new ArrayList<String>()); while(m-- > 0){ map.get(s).add(sc.next()); } } dp = new HashMap<String,Integer>(); System.out.println(minCost(sc.next())); } } private static  private static int minCost(String s){ if(map.get(s) == null) return price.get(s);  tmp : map.get(s)){ sum += minCost(tmp); } dp.put(s, price.get(s) == null ? sum : Math.min(sum,price.get(s))); return dp.get(s); } }"], "original_ll": -0.7359888553619385, "sampled_ll": -0.5192212462425232, "all_perturbed_sampled_ll": [-1.2885526418685913], "all_perturbed_original_ll": [-1.5059853792190552], "perturbed_sampled_ll": -1.2885526418685913, "perturbed_original_ll": -1.5059853792190552, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n  count = int(input())\n  if count == 0: break \n  thing,money=[],[]\n  for i in range(count):\n    hoge = map(str,raw_input().split())\n    t = int(hoge[1])\n    thing.append(hoge[0])\n    money.append(t)\n  count = int(input())\n  if count == 0:\n    hoge = raw_input()\n    if hoge not in thing:\n      print 0\n      continue\n    t = thing.index(hoge)\n    print money[t]\n  else:\n    for i in range(count):\n      hoge = map(str,raw_input().split())\n      if hoge[0] not in thing:\n        print 0\n      t = int(hoge[1])\n      x,y = 2,0\n      for j in range(t):\n        r = thing.index(hoge[x])\n        y += money[r]\n        x+=1\n      e = thing.index(hoge[0])\n      money[e]= y\n    g = raw_input()\n    ans = thing.index(g)\n    print money[ans]", "sampled": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        # Read items and their prices\n        prices = {}\n        for _ in range(n):\n            line = input().split()\n            item_name = line[0]\n            price = int(line[1])\n            prices[item_name] = price\n        \n        # Read recipes\n        m = int(input())\n        recipes = {}\n        for _ in range(m):\n            line = input().split()\n            output_item = line[0]\n            k = int(line[1])\n            ingredients = line[2:2+k]\n            recipes[output_item] = ingredients\n        \n        # Read target item\n        target = input().strip()\n        \n        # Memoization for minimum cost\n        memo = {}\n        \n        def min_cost(item):\n            if item in memo:\n                return memo[item]\n            \n            # Option 1: Buy directly\n            buy_cost = prices[item]\n            \n            # Option 2: Craft using recipe (if available)\n            if item in recipes:\n                craft_cost = 0\n                for ingredient in recipes[item]:\n                    craft_cost += min_cost(ingredient)\n                result = min(buy_cost, craft_cost)\n            else:\n                result = buy_cost\n            \n            memo[item] = result\n            return result\n        \n        print(min_cost(target))\n\nsolve()\n", "perturbed_sampled": ["import sys from collections import defaultdict def solve(): while True: n = int(input()) if n == 0: break # Read items and their prices prices = {} for _ in range(n): line = input().split() item_name = line[0] price = int(line[1]) prices[item_name] = price # Read recipes m = int(input()) recipes = {} for _ in range(m): line = input().split()  # Memoization for minimum cost memo = {} def min_cost(item): if item in memo: return memo[item] # Option 1: Buy directly buy_cost =  item  += min_cost(ingredient) result = min(buy_cost, craft_cost) else: result = buy_cost memo[item] = result return result print(min_cost(target)) solve()"], "perturbed_original": ["while True: count = int(input()) if count == 0: break thing,money=[],[] for i in range(count): hoge = map(str,raw_input().split()) t =  hoge = raw_input() if hoge not in thing: print 0 continue t = thing.index(hoge) print  hoge[0] not in thing: print 0 t = int(hoge[1]) x,y = 2,0 for j in range(t): r = thing.index(hoge[x]) y += money[r] x+=1 e = thing.index(hoge[0]) money[e]= y g = raw_input() ans = thing.index(g) print money[ans]"], "original_ll": -1.3456403017044067, "sampled_ll": -0.8778930902481079, "all_perturbed_sampled_ll": [-1.87554132938385], "all_perturbed_original_ll": [-2.343209743499756], "perturbed_sampled_ll": -1.87554132938385, "perturbed_original_ll": -2.343209743499756, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_PRIME\t(1000000)\n#define IS_PRIME(n)\t(prime[j]==0?1:0)\n\nint prime[MAX_PRIME + 1];\nint fare[MAX_PRIME + 1];\nint fare_next[MAX_PRIME + 1];\n\n\nvoid make_prime(void)\n{\n    int i;\n    int j;\n    int n;\n    int c;\n    \n    for (i = 2; i * i <= MAX_PRIME; i++){\n        if (prime[i] == 0){\n            for (j = i * 2; j <= MAX_PRIME; j += i){\n\t\t\t\tprime[j] = 1;\n            }\n        }\n    }\n}\n\n\nint main(void)\n{\n\tint n, x;\n\tint price[30];\n\tint i, j, k;\n\t\n\tmake_prime();\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &n, &x);\n\t\tif (n == 0 && x == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &price[i]);\n\t\t}\n\t\t\n\t\tmemset(fare_next, 0, sizeof(fare_next));\n\t\tfare_next[0] = 1;\n\t\tfor (i = 0; i < n; i++){\n\n\t\t\tmemcpy(fare, fare_next, sizeof(fare_next));\n\t\t\tfor (j = price[i]; j <= x; j += price[i]){\n\t\t\t\tfor (k = 0; k <= x; k++){\n\t\t\t\t\tif (fare[k] != 0){\n\t\t\t\t\t\tif (k + j <= x){\n\t\t\t\t\t\t\tfare_next[k + j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemcpy(fare, fare_next, sizeof(fare_next));\n\t\t\n//for (i = 1; i <= x; i++){\n//\tprintf(\"[%d=%d]\", i, fare[i]);\n//}\n\n\t\tfor (i = x; i >= 1; i--){\n\t\t\tif (fare[i] != 0 && prime[i] == 0){\n\t\t\t\tprintf(\"%d\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == 0){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nbool isNotDivisibleByAny(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n, x;\n    \n    while (scanf(\"%d %d\", &n, &x) == 2) {\n        if (n == 0 && x == 0) break;\n        \n        int v[30];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &v[i]);\n        }\n        \n        bool *possible = (bool *)calloc(x + 1, sizeof(bool));\n        possible[0] = true;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = v[i]; j <= x; j++) {\n                if (possible[j - v[i]]) {\n                    possible[j] = true;\n                }\n            }\n        }\n        \n        int result = -1;\n        for (int i = x; i >= 1; i--) {\n            if (possible[i]) {\n                bool divisible = false;\n                for (int d = 2; d <= i; d++) {\n                    if (i % d == 0) {\n                        divisible = true;\n                        break;\n                    }\n                }\n                if (!divisible && i > 1) {\n                    result = i;\n                    break;\n                }\n            }\n        }\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n        \n        free(possible);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdbool.h> int gcd(int a, int  (num <= 1) return false; for (int  if (num % i == 0) return false; } return true; } int main() { int n, x; while (scanf(\"%d %d\", &n, &x) == 2) { if (n == 0 && x == 0) break; int v[30]; for (int i = 0; i < n; i++) { scanf(\"%d\", &v[i]); } bool *possible = (bool *)calloc(x + 1, sizeof(bool)); possible[0] = true; for (int i = 0; i < n; i++) { for (int j = v[i]; j <= x; j++) { if (possible[j - v[i]]) { possible[j] = true; } } }  >= 1; i--) { if (possible[i]) { bool divisible = false; for (int d = 2; d <= i; d++) { if (i % d == 0) { divisible  1) { result = i; break; } } } if (result == -1) { printf(\"NA\\n\"); } else { printf(\"%d\\n\", result); } free(possible); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h>  int fare[MAX_PRIME + 1]; int fare_next[MAX_PRIME + 1]; void make_prime(void) { int i; int j; int n; int c;  if (prime[i] == 0){ for (j = i * 2; j <= MAX_PRIME; j  main(void) { int  (1){ scanf(\"%d%d\", &n, &x); if (n == 0 && x == 0){ break; } for (i = 0; i < n; i++){ scanf(\"%d\", &price[i]); } memset(fare_next, 0, sizeof(fare_next)); fare_next[0] = 1; for (i = 0; i < n; i++){ memcpy(fare, fare_next, sizeof(fare_next)); for (j = price[i]; j <= x; j  if (fare[k] != 0){ if (k + j <= x){ fare_next[k + j] = 1; } } } } } memcpy(fare, fare_next,  printf(\"[%d=%d]\", i, fare[i]); //} for (i = x; i >= 1; i--){ if (fare[i] != 0 && prime[i] == 0){ printf(\"%d\\n\", i); break; } } if (i == 0){ printf(\"NA\\n\"); } } return (0); }"], "original_ll": -0.8922199010848999, "sampled_ll": -0.48573121428489685, "all_perturbed_sampled_ll": [-1.1192011833190918], "all_perturbed_original_ll": [-1.5389506816864014], "perturbed_sampled_ll": -1.1192011833190918, "perturbed_original_ll": -1.5389506816864014, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint MAX = 1000000;\n\t\tboolean[] prime = new boolean[MAX + 1];\n\t\tfor (int i = 4; i <= MAX; i += 2) {\n\t\t\tprime[i] = true;\n\t\t}\n\t\tfor (int i = 3; i <= Math.sqrt(MAX); i += 2) {\n\t\t\tif (!prime[i]) {\n\t\t\t\tfor (int j = i * 3; j <= MAX; j += i * 2) {\n\t\t\t\t\tprime[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] a = new int[n];\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tboolean[] f = new boolean[m + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint s = scanner.nextInt();\n\t\t\t\tmin = Math.min(s, min);\n\t\t\t\ta[i] = s;\n\t\t\t\tfor (int j = s; j <= m; j += s) {\n\t\t\t\t\tf[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\tint max = 0;\n\t\t\tfor (int i = min; i <= m; i++) {\n\t\t\t\tif (!f[i])\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (i - a[j] >= 0 && f[i - a[j]]) {\n\t\t\t\t\t\t\tf[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif (f[i] && !prime[i])\n\t\t\t\t\tmax = i;\n\t\t\t}\n\t\t\tSystem.out.println(max == 0 ? \"NA\" : max);\n\n\t\t}\n\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (n == 0 && x == 0) break;\n            \n            int[] prices = new int[n];\n            for (int i = 0; i < n; i++) {\n                prices[i] = sc.nextInt();\n            }\n            \n            // Find all possible sums up to budget x\n            boolean[] possible = new boolean[x + 1];\n            possible[0] = true;\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = prices[i]; j <= x; j++) {\n                    if (possible[j - prices[i]]) {\n                        possible[j] = true;\n                    }\n                }\n            }\n            \n            // Find the maximum sum that is not divisible by any number from 2 to itself-1\n            int result = -1;\n            for (int sum = x; sum >= 2; sum--) {\n                if (possible[sum] && isPrime(sum)) {\n                    result = sum;\n                    break;\n                }\n            }\n            \n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean isPrime(int num) {\n        if (num < 2) return false;\n        if (num == 2) return true;\n        if (num % 2 == 0) return false;\n        \n        for (int i = 3; i * i <= num; i += 2) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {   = sc.nextInt(); if (n == 0 && x == 0)  0; i < n; i++) { prices[i] = sc.nextInt(); } // Find all possible sums up to budget x boolean[] possible = new boolean[x + 1]; possible[0] = true; for (int i = 0; i < n; i++) { for (int j = prices[i]; j <= x; j++) { if (possible[j - prices[i]]) { possible[j] = true; } } } // Find the maximum sum that is not divisible by any number from 2 to itself-1 int result = -1; for (int sum = x; sum >= 2; sum--) { if (possible[sum] && isPrime(sum)) { result  System.out.println(\"NA\"); } else { System.out.println(result); } } sc.close(); } private static boolean isPrime(int num) { if (num < 2) return false; if (num == 2) return true; if (num % 2 == 0) return false; for (int  false; } return true; } }"], "perturbed_original": ["import java.io.IOException; import java.util.Arrays; import  throws  { Scanner scanner = new Scanner(System.in); int MAX = 1000000; boolean[] prime = new boolean[MAX + 1]; for (int i = 4; i <= MAX; i += 2) { prime[i] = true; } for (int i = 3; i <=  j = i * 3; j <= MAX; j += i * 2) { prime[j] = true; } } } while (true) { int n = scanner.nextInt(); int m = scanner.nextInt(); if ((n | m) == 0) break; int[] a = new int[n]; int min = Integer.MAX_VALUE; boolean[] f = new boolean[m + 1]; for (int i = 0; i < n; i++) { int s = scanner.nextInt(); min = Math.min(s, min); a[i] =  += s) { f[j] = true; } } Arrays.sort(a); int max = 0; for (int i = min; i <= m; i++) { if (!f[i]) for (int j = 0; j < n; j++) { if (i - a[j] >= 0 && f[i -  ? \"NA\" : max); } } }"], "original_ll": -0.6422756314277649, "sampled_ll": -0.48780956864356995, "all_perturbed_sampled_ll": [-1.395245909690857], "all_perturbed_original_ll": [-1.3701841831207275], "perturbed_sampled_ll": -1.395245909690857, "perturbed_original_ll": -1.3701841831207275, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from array import array\nPRIME_MAX = 1000001\nisPrime = array('b', [1] * PRIME_MAX)\nisPrime[0] = 0\nisPrime[1] = 0\nfor i in xrange(2, PRIME_MAX):\n\tif not isPrime[i]: continue\n\tfor j in xrange(i << 1, PRIME_MAX, i):\n\t\tisPrime[j] = 0\nwhile True:\n\tn, x = map(int, raw_input().split())\n\tif n == x == 0: break\n\tmenu = [input() for i in xrange(n)]\n\tresult = 0\n\texists = set()\n\texists.add(0)\n\tfor i in xrange(x + 1):\n\t\tif i in exists:\n\t\t\texists.remove(i)\n\t\t\tfor v in menu:\n\t\t\t\texists.add(i + v)\n\t\t\tif isPrime[i]:\n\t\t\t\tresult = i\n\tif result:\n\t\tprint result\n\telse:\n\t\tprint \"NA\"", "sampled": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(n, budget, prices):\n    # Dynamic programming to find all possible sums\n    possible = [False] * (budget + 1)\n    possible[0] = True\n    \n    for price in prices:\n        for total in range(budget, price - 1, -1):\n            if possible[total - price]:\n                possible[total] = True\n    \n    # Find the largest sum that is not divisible by all numbers from 2 to sum\n    for total in range(budget, 0, -1):\n        if not possible[total]:\n            continue\n        \n        # Check if total is not divisible by any number from 2 to total-1\n        is_prime_like = True\n        for divisor in range(2, int(math.sqrt(total)) + 1):\n            if total % divisor == 0:\n                is_prime_like = False\n                break\n        \n        if is_prime_like and total > 1:\n            return total\n    \n    return \"NA\"\n\ndef is_not_divisible_by_any(num):\n    # A number is not divisible by any number except 1 and itself if it's prime\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef solve2(n, budget, prices):\n    # Dynamic programming to find all possible sums\n    possible = set([0])\n    \n    for price in prices:\n        new_possible = set()\n        for p in possible:\n            amount = p\n            while amount + price <= budget:\n                amount += price\n                new_possible.add(amount)\n        possible.update(new_possible)\n    \n    # Find the largest sum that is prime\n    for total in range(budget, 1, -1):\n        if total in possible and is_not_divisible_by_any(total):\n            return total\n    \n    return \"NA\"\n\nwhile True:\n    line = input().split()\n    n, x = int(line[0]), int(line[1])\n    \n    if n == 0 and x == 0:\n        break\n    \n    prices = []\n    for _ in range(n):\n        prices.append(int(input()))\n    \n    print(solve2(n, x, prices))\n", "perturbed_sampled": [" b: a, b = b, a  programming to find all possible sums possible = [False] * (budget + 1) possible[0] = True for price in prices: for total in range(budget, price - 1, -1): if possible[total - price]: possible[total] = True # Find the largest sum that is not divisible by all numbers from 2 to sum  number from 2 to total-1 is_prime_like = True for divisor in range(2, int(math.sqrt(total)) + 1): if total % divisor == 0: is_prime_like = False break if is_prime_like and total > 1: return total return \"NA\" def is_not_divisible_by_any(num): # A number is not divisible by any number except 1 and itself if it's prime if num <=  num % 2 == 0: return False for i  == 0: return False return True def solve2(n, budget, prices): # Dynamic programming to find all possible sums possible = set([0]) for price in prices: new_possible = set() for p in possible: amount = p while amount  Find the largest sum that is prime  and is_not_divisible_by_any(total): return total return \"NA\" while True: line = input().split() n, x = int(line[0]), int(line[1]) if n == 0 and x == 0: break prices = [] for _ in range(n): prices.append(int(input())) print(solve2(n, x, prices))"], "perturbed_original": ["from array import array PRIME_MAX = 1000001 isPrime  0 for i in xrange(2, PRIME_MAX): if not isPrime[i]: continue for j in xrange(i << 1, PRIME_MAX, i): isPrime[j] = 0 while True: n,  break menu = [input() for i in xrange(n)] result = 0 exists = set() exists.add(0) for i in xrange(x + 1): if i in exists: exists.remove(i) for v in menu: exists.add(i + v) if isPrime[i]: result = i if result: print result else: print \"NA\""], "original_ll": -1.0645134449005127, "sampled_ll": -0.7628482580184937, "all_perturbed_sampled_ll": [-1.8894742727279663], "all_perturbed_original_ll": [-1.9424389600753784], "perturbed_sampled_ll": -1.8894742727279663, "perturbed_original_ll": -1.9424389600753784, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\tint w,h,xd[]={1,0,-1},p,u[20][20];\n\tvoid ret(int x,int y){\n\t\tint i,s=x;\n\t\tif(h-1<=y)\n\t\t\tp++;\n\t\telse if(u[y][x]==2)\n\t\t\tret(x,y+2);\n\t\telse if(u[y][x]==0){\n\t\t\ty++;\n\t\t\tfor(i=0;i<3;i++){\n\t\t\t\tx=s+xd[i];\n\t\t\t\tif(x>=0&&x<=w-1){\n\t\t\t\t\tif(u[y][x]==2&&i==1)\n\t\t\t\t\t\tret(x,y+2);\n\t\t\t\t\telse if(u[y][x]==0)\n\t\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint main(){\n\t\tint i,j,x,y;\n\t\twhile(scanf(\"%d %d\",&w,&h),w||h){\n\t\t\tp=0;\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w-1;j++)\n\t\t\t\tscanf(\"%d \",&u[i][j]);\n\t\t\t\tscanf(\"%d\",&u[i][w-1]);\n\t\t\t}\n\t\t\tfor(i=0;i<w;i++){\n\t\t\t\tif(u[0][i]==0){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=0;\n\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t\telse if(u[0][i]==2){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=2;\n\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",p);\n\t\t}\n\t\treturn 0;\n\t}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint X, Y;\nint course[16][16];\nlong long dp[16][16];\n\nlong long countPaths() {\n    memset(dp, 0, sizeof(dp));\n    \n    // Initialize first row (y=1)\n    for (int x = 1; x <= X; x++) {\n        if (course[x][1] != 1) {  // Not an obstacle\n            dp[x][1] = 1;\n        }\n    }\n    \n    // Fill the dp table\n    for (int y = 1; y < Y; y++) {\n        for (int x = 1; x <= X; x++) {\n            if (dp[x][y] == 0) continue;\n            \n            if (course[x][y] == 2) {  // Jump platform\n                // Jump to (x, y+2)\n                if (y + 2 <= Y) {\n                    if (course[x][y+2] != 1) {\n                        dp[x][y+2] += dp[x][y];\n                    }\n                } else {\n                    // Jump goes beyond Y, count as reaching goal\n                    dp[x][Y] += dp[x][y];\n                }\n            } else {  // Normal cell (0)\n                // Move to (x-1, y+1), (x, y+1), (x+1, y+1)\n                for (int dx = -1; dx <= 1; dx++) {\n                    int nx = x + dx;\n                    int ny = y + 1;\n                    \n                    if (nx < 1 || nx > X) continue;\n                    \n                    if (ny > Y) {\n                        // Reached goal\n                        dp[x][Y] += dp[x][y];\n                    } else {\n                        if (course[nx][ny] == 1) {  // Obstacle\n                            continue;\n                        }\n                        if (course[nx][ny] == 2) {  // Jump platform\n                            // Can only enter jump platform from directly above (dx == 0)\n                            if (dx == 0) {\n                                dp[nx][ny] += dp[x][y];\n                            }\n                        } else {  // Normal cell\n                            dp[nx][ny] += dp[x][y];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Sum all paths that reached Y\n    long long total = 0;\n    for (int x = 1; x <= X; x++) {\n        total += dp[x][Y];\n    }\n    \n    return total;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &X, &Y);\n        if (X == 0 && Y == 0) break;\n        \n        for (int y = 1; y <= Y; y++) {\n            for (int x = 1; x <= X; x++) {\n                scanf(\"%d\", &course[x][y]);\n            }\n        }\n        \n        printf(\"%lld\\n\", countPaths());\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int X, Y; int course[16][16]; long long dp[16][16]; long long countPaths() { memset(dp, 0, sizeof(dp)); // Initialize first row (y=1) for (int x = 1; x <= X; x++) { if (course[x][1] != 1) { // Not an obstacle dp[x][1] = 1; } } // Fill the dp table for (int y = 1; y < Y; y++) { for (int x = 1; x <= X; x++) { if (dp[x][y] == 0) continue; if (course[x][y] == 2) { // Jump platform // Jump to (x, y+2) if (y + 2 <= Y) { if (course[x][y+2] != 1) { dp[x][y+2] += dp[x][y]; } } else { //  // Move to (x-1, y+1), (x, y+1), (x+1, y+1) for (int dx = -1; dx <= 1; dx++) { int nx = x + dx; int ny = y + 1; if (nx < 1 || nx > X) continue; if (ny > Y) { // Reached goal dp[x][Y] += dp[x][y]; }  dp[nx][ny] += dp[x][y]; } } } } } } // Sum all paths that reached Y long long total = 0; for (int x = 1; x <= X; x++) { total += dp[x][Y]; } return  &X, &Y); if (X == 0 && Y == 0) break; for (int y  = 1; x <= X; x++) { scanf(\"%d\", &course[x][y]); } } printf(\"%lld\\n\", countPaths()); } return 0; }"], "perturbed_original": [" p++; else if(u[y][x]==2) ret(x,y+2); else if(u[y][x]==0){ y++; for(i=0;i<3;i++){ x=s+xd[i]; if(x>=0&&x<=w-1){ if(u[y][x]==2&&i==1) ret(x,y+2); else if(u[y][x]==0) ret(x,y); } } } } int main(){ int i,j,x,y; while(scanf(\"%d %d\",&w,&h),w||h){ p=0; for(i=0;i<h;i++){ for(j=0;j<w-1;j++) scanf(\"%d \",&u[i][j]); scanf(\"%d\",&u[i][w-1]); } for(i=0;i<w;i++){ if(u[0][i]==0){ x=i; y=0; ret(x,y); } else if(u[0][i]==2){ x=i; y=2; ret(x,y); } } printf(\"%d\\n\",p); } return 0; }"], "original_ll": -1.0239510536193848, "sampled_ll": -0.7244669198989868, "all_perturbed_sampled_ll": [-1.275948405265808], "all_perturbed_original_ll": [-1.2058963775634766], "perturbed_sampled_ll": -1.275948405265808, "perturbed_original_ll": -1.2058963775634766, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int H,W;\n\tstatic int[][] field;\n\tstatic int[][] dp;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tW=cin.nextInt();\n\t\t\tH=cin.nextInt();\n\t\t\tif(W+H==0)break;\n\t\t\tfield=new int[H+2][W];\n\t\t\tdp=new int[H+2][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<W;i++){\n\t\t\t\tif(field[0][i]==0)dp[0][i]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]==0){\n\t\t\t\t\t\tif(i!=H-1){\n\t\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\t\tif(j+k<0||j+k>=W)continue;\n\t\t\t\t\t\t\t\tif(field[i+1][j+k]==1)continue;\n\t\t\t\t\t\t\t\tif(k!=0&&field[i+1][j+k]==2)continue;\n\t\t\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[i][j]==2){\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=H;i<H+2;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tans+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int X, Y;\n    static int[][] course;\n    static long[][] memo;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            X = sc.nextInt();\n            Y = sc.nextInt();\n            \n            if (X == 0 && Y == 0) break;\n            \n            course = new int[X + 1][Y + 1];\n            memo = new long[X + 1][Y + 1];\n            \n            for (int y = 1; y <= Y; y++) {\n                for (int x = 1; x <= X; x++) {\n                    course[x][y] = sc.nextInt();\n                    memo[x][y] = -1;\n                }\n            }\n            \n            long total = 0;\n            for (int x = 1; x <= X; x++) {\n                if (course[x][1] != 1) {\n                    total += dfs(x, 1);\n                }\n            }\n            \n            System.out.println(total);\n        }\n        \n        sc.close();\n    }\n    \n    static long dfs(int x, int y) {\n        if (y >= Y) {\n            return 1;\n        }\n        \n        if (memo[x][y] != -1) {\n            return memo[x][y];\n        }\n        \n        long count = 0;\n        \n        if (course[x][y] == 2) {\n            // Jump platform - skip to y+2\n            int nextY = y + 2;\n            if (nextY >= Y) {\n                count = 1;\n            } else if (course[x][nextY] != 1) {\n                if (course[x][nextY] == 2) {\n                    count = dfs(x, nextY);\n                } else {\n                    count = dfs(x, nextY);\n                }\n            }\n        } else {\n            // Normal movement to y+1\n            int nextY = y + 1;\n            \n            // Move to (x-1, y+1)\n            if (x - 1 >= 1 && course[x - 1][nextY] != 1) {\n                if (course[x - 1][nextY] == 2) {\n                    // Can't enter jump platform from diagonal\n                } else {\n                    count += dfs(x - 1, nextY);\n                }\n            }\n            \n            // Move to (x, y+1)\n            if (course[x][nextY] != 1) {\n                count += dfs(x, nextY);\n            }\n            \n            // Move to (x+1, y+1)\n            if (x + 1 <= X && course[x + 1][nextY] != 1) {\n                if (course[x + 1][nextY] == 2) {\n                    // Can't enter jump platform from diagonal\n                } else {\n                    count += dfs(x + 1, nextY);\n                }\n            }\n        }\n        \n        memo[x][y] = count;\n        return count;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int X, Y; static int[][] course; static long[][] memo; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { X = sc.nextInt(); Y = sc.nextInt(); if (X == 0 && Y == 0) break; course = new int[X + 1][Y + 1]; memo = new long[X + 1][Y + 1]; for (int y = 1; y <=  X; x++) { course[x][y] = sc.nextInt(); memo[x][y] = -1; } } long total = 0; for (int x = 1; x <=  dfs(x, 1); } } System.out.println(total); }  (y >= Y) { return 1; } if (memo[x][y] != -1) { return memo[x][y]; } long count = 0; if (course[x][y] == 2) { // Jump  } else if (course[x][nextY] !=  } } else { // Normal movement to y+1 int nextY = y + 1; // Move to (x-1, y+1) if (x - 1 >= 1 && course[x - 1][nextY] != 1) { if (course[x - 1][nextY] == 2) { // Can't enter jump platform from diagonal } else { count += dfs(x - 1, nextY); } } // Move to (x, y+1) if (course[x][nextY] != 1) { count += dfs(x, nextY); } // Move to (x+1, y+1) if (x + 1 <= X && course[x + 1][nextY] != 1) { if  platform from diagonal } else { count  count; return count; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { static int H,W; static int[][] field; static int[][] dp; public static void main(String[] args) { Scanner cin = new Scanner(System.in); for(;;){ W=cin.nextInt(); H=cin.nextInt(); if(W+H==0)break; field=new  if(i!=H-1){ for(int k=-1;k<=1;k++){ if(j+k<0||j+k>=W)continue; if(field[i+1][j+k]==1)continue; if(k!=0&&field[i+1][j+k]==2)continue; dp[i+1][j+k]+=dp[i][j]; } } else{ dp[i+1][j]+=dp[i][j]; } } else if(field[i][j]==2){ dp[i+2][j]+=dp[i][j]; } } } int ans=0; for(int i=H;i<H+2;i++){ for(int j=0;j<W;j++){ ans+=dp[i][j]; } } System.out.println(ans); } } }"], "original_ll": -0.6558745503425598, "sampled_ll": -0.4935590624809265, "all_perturbed_sampled_ll": [-1.249146819114685], "all_perturbed_original_ll": [-1.1557049751281738], "perturbed_sampled_ll": -1.249146819114685, "perturbed_original_ll": -1.1557049751281738, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n\tX,Y = map(int,raw_input().split())\n\tif X == 0: break\n\tA = [[0]+map(int,raw_input().split())+[0] for i in range(Y)]\n\tS = [[0]*(X+2) for i in range(Y)]\n\tfor x in range(1,X+1): S[0][x] = 1 if A[0][x] != 1 else 0\n\tfor y in range(1,Y):\n\t\tfor x in range(1,X+1):\n\t\t\tif A[y][x] == 0:\n\t\t\t\tfor i in range(-1,2):\n\t\t\t\t\tS[y][x] += (S[y-1][x-i] if A[y-1][x-i] == 0 else 0)\n\t\t\tif A[y][x] == 2:\n\t\t\t\tS[y][x] += S[y-1][x-1]\n\t\t\t\tif y+2 < Y and A[y+2][x] != 1:\n\t\t\t\t\tS[y+2][x] = S[y][x]\n\tans = 0\n\tfor x in range(1,X+1):\n\t\tans += S[Y-1][x] + (S[Y-2][x] if A[Y-2][x] == 2 else 0)\n\tprint ans", "sampled": "import sys\n\ndef solve(X, Y, grid):\n    # dp[y][x] = number of ways to reach position (x, y)\n    dp = [[0] * X for _ in range(Y + 1)]\n    \n    # Initialize starting positions at y=0 (0-indexed, which is y=1 in problem)\n    for x in range(X):\n        if grid[0][x] != 1:  # not an obstacle\n            dp[0][x] = 1\n    \n    # Process each row\n    for y in range(Y):\n        for x in range(X):\n            if dp[y][x] == 0:\n                continue\n            \n            # Check if current position has a jump platform\n            if grid[y][x] == 2:\n                # Jump to (x, y+2)\n                target_y = y + 2\n                if target_y < Y:\n                    if grid[target_y][x] != 1:  # not an obstacle\n                        dp[target_y][x] += dp[y][x]\n                else:\n                    # Reached beyond Y, count as completion\n                    # We need to track completions separately\n                    pass\n            else:\n                # Normal movement to (x-1, y+1), (x, y+1), (x+1, y+1)\n                target_y = y + 1\n                if target_y < Y:\n                    # Move to (x-1, y+1)\n                    if x - 1 >= 0:\n                        if grid[target_y][x-1] == 2:\n                            # Can't enter jump platform from diagonal\n                            pass\n                        elif grid[target_y][x-1] != 1:\n                            dp[target_y][x-1] += dp[y][x]\n                    \n                    # Move to (x, y+1)\n                    if grid[target_y][x] != 1:\n                        dp[target_y][x] += dp[y][x]\n                    \n                    # Move to (x+1, y+1)\n                    if x + 1 < X:\n                        if grid[target_y][x+1] == 2:\n                            # Can't enter jump platform from diagonal\n                            pass\n                        elif grid[target_y][x+1] != 1:\n                            dp[target_y][x+1] += dp[y][x]\n    \n    # Count paths that reach y >= Y\n    total = 0\n    \n    # Add paths from y = Y-1\n    for x in range(X):\n        if dp[Y-1][x] > 0:\n            if grid[Y-1][x] == 2:\n                # Jump from Y-1 goes to Y+1, which is >= Y\n                total += dp[Y-1][x]\n            else:\n                # Normal movement from Y-1 goes to Y, which is >= Y\n                total += dp[Y-1][x]\n    \n    # Add paths from y = Y-2 that jump\n    if Y >= 2:\n        for x in range(X):\n            if dp[Y-2][x] > 0 and grid[Y-2][x] == 2:\n                # Jump from Y-2 goes to Y, which is >= Y\n                # But we need to check if this was already counted\n                # Actually, when we process Y-2, we add to dp[Y][x] if Y < Y, which is false\n                # So we need to handle this separately\n                pass\n    \n    return total\n\n# Read input\nwhile True:\n    line = input().split()\n    X, Y = int(line[0]), int(line[1])\n    \n    if X == 0 and Y == 0:\n        break\n    \n    grid = []\n    for y in range(Y):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Re-implement with better logic\n    dp = [[0] * X for _ in range(Y + 2)]\n    \n    # Initialize\n    for x in range(X):\n        if grid[0][x] != 1:\n            dp[0][x] = 1\n    \n    for y in range(Y + 1):\n        for x in range(X):\n            if dp[y][x] == 0:\n                continue\n            \n            if y >= Y:\n                continue\n            \n            if grid[y][x] == 2:\n                # Jump\n                target_y = y + 2\n                if target_y <= Y:\n                    dp[target_y][x] += dp[y][x]\n            else:\n                # Normal move\n                target_y = y + 1\n                if target_y <= Y:\n                    for dx in [-1, 0, 1]:\n                        nx = x + dx\n                        if 0 <= nx < X:\n                            if target_y < Y:\n                                if grid[target_y][nx] == 2 and dx != 0:\n                                    continue\n                                if grid[target_y][nx] != 1:\n                                    dp[target_y][nx] += dp[y][x]\n                            else:\n                                dp[target_y][nx] += dp[y][x]\n    \n    result = sum(dp[Y])\n    print(result)\n", "perturbed_sampled": ["import sys def solve(X, Y, grid): # dp[y][x] = number of ways to reach position (x,  + 1)] # Initialize starting positions  in range(X): if grid[0][x] != 1: #  for y  continue # Check if current position has a jump platform if grid[y][x] == 2: # Jump to (x, y+2) target_y = y + 2 if target_y < Y: if grid[target_y][x] != 1: # not an obstacle dp[target_y][x] += dp[y][x] else: # Reached beyond Y, count as completion # We need to track completions separately pass else: # Normal movement to (x-1, y+1), (x, y+1), (x+1, y+1) target_y = y + 1 if target_y < Y: # Move to (x-1, y+1) if x - 1 >= 0: if grid[target_y][x-1] == 2: # Can't enter jump platform from diagonal pass elif grid[target_y][x-1] != 1: dp[target_y][x-1] += dp[y][x] # Move to (x, y+1) if grid[target_y][x] != 1: dp[target_y][x] += dp[y][x] # Move to (x+1, y+1) if x + 1 < X:  diagonal pass elif grid[target_y][x+1] != 1: dp[target_y][x+1] += dp[y][x] # Count paths that reach  y = Y-1 for x in range(X): if dp[Y-1][x] > 0: if grid[Y-1][x] == 2: # Jump from Y-1 goes to Y+1, which is >= Y total += dp[Y-1][x] else: # Normal movement from Y-1 goes to   2: for x in range(X): if  Y-2 goes to Y, which is >= Y  counted # Actually, when we process Y-2, we add to dp[Y][x] if Y < Y, which is false # So we need to handle this separately pass return total # Read input while True: line = input().split() X, Y = int(line[0]), int(line[1]) if X == 0 and Y == 0: break grid = [] for y in range(Y): row = list(map(int, input().split())) grid.append(row) # Re-implement with better logic dp = [[0] * X for _ in range(Y +  1: dp[0][x] = 1 for y in range(Y + 1): for x in range(X): if dp[y][x] == 0: continue if y >= Y: continue if grid[y][x] == 2:  Y: dp[target_y][x]  <= nx < X: if target_y < Y: if grid[target_y][nx] == 2 and dx != 0: continue if grid[target_y][nx] != 1: dp[target_y][nx] += dp[y][x] else: dp[target_y][nx] += dp[y][x] result = sum(dp[Y]) print(result)"], "perturbed_original": ["while 1:  [[0]+map(int,raw_input().split())+[0] for i in range(Y)] S = [[0]*(X+2) for i in range(Y)] for x in range(1,X+1): S[0][x] = 1 if A[0][x] != 1 else  A[y][x] == 0: for i in range(-1,2): S[y][x] += (S[y-1][x-i] if A[y-1][x-i] == 0 else 0) if A[y][x] == 2: S[y][x] += S[y-1][x-1] if y+2 < Y and A[y+2][x] != 1: S[y+2][x] = S[y][x] ans = 0 for  == 2 else 0) print ans"], "original_ll": -0.9001911878585815, "sampled_ll": -0.80415940284729, "all_perturbed_sampled_ll": [-1.558855652809143], "all_perturbed_original_ll": [-1.6625845432281494], "perturbed_sampled_ll": -1.558855652809143, "perturbed_original_ll": -1.6625845432281494, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-8)\n\ntypedef struct {\n\tdouble x,y;\n\tdouble angle;\n\tint r;\n\tint v;\n\tint arrive;\n} ufo_t;\n\nint N;\nufo_t ufo[100];\nint R;\n\ndouble get_dist(double mx,double my,double x,double y) {\n\treturn fabs(my*x-mx*y)/sqrt(my*my+mx*mx);\n}\n\nint main(void) {\n\tint i;\n\tint target;\n\tdouble target_dist;\n\tint count;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&R,&N);\n\t\tif(R==0 && N==0)break;\n\t\tfor(i=0;i<N;i++) {\n\t\t\tscanf(\"%lf%lf%d%d\",\n\t\t\t\t&ufo[i].x,&ufo[i].y,&ufo[i].r,&ufo[i].v);\n\t\t\tufo[i].arrive=1;\n\t\t\tufo[i].angle=atan2(ufo[i].y,ufo[i].x);\n\t\t}\n\t\ttarget=0;\n\t\twhile(target>=0) {\n\t\t\tfor(i=0;i<N;i++) {\n\t\t\t\tif(R+EPS<sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y)) {\n\t\t\t\t\tdouble prev_x,prev_y;\n\t\t\t\t\tprev_x=ufo[i].x;\n\t\t\t\t\tprev_y=ufo[i].y;\n\t\t\t\t\tufo[i].x-=ufo[i].v*cos(ufo[i].angle);\n\t\t\t\t\tufo[i].y-=ufo[i].v*sin(ufo[i].angle);\n\t\t\t\t\tif(prev_x*ufo[i].x<0)ufo[i].x=0;\n\t\t\t\t\tif(prev_y*ufo[i].y<0)ufo[i].y=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget=-1;\n\t\t\ttarget_dist=1000*1000;\n\t\t\tfor(i=0;i<N;i++) {\n\t\t\t\tdouble dist;\n\t\t\t\tif(!ufo[i].arrive)continue;\n\t\t\t\tdist=sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y);\n\t\t\t\tif(dist<target_dist+EPS && R+EPS<dist) {\n\t\t\t\t\ttarget_dist=dist;\n\t\t\t\t\ttarget=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(target<0)break;\n\t\t\tfor(i=0;i<N;i++) {\n\t\t\t\tif(sqrt(ufo[i].x*ufo[i].x+\n\t\t\t\t\tufo[i].y*ufo[i].y)<R+EPS)continue;\n\t\t\t\tif(get_dist(ufo[target].x,ufo[target].y,\n\t\t\t\t\t\tufo[i].x,ufo[i].y)<ufo[i].r+EPS &&\n\t\t\t\t\t\tufo[target].x*ufo[i].x>=0 &&\n\t\t\t\t\t\tufo[target].y*ufo[i].y>=0) {\n\t\t\t\t\tufo[i].arrive=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount=0;\n\t\tfor(i=0;i<N;i++) {\n\t\t\tif(ufo[i].arrive)count++;\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n#define INF 1e9\n\ntypedef struct {\n    double x, y;\n    double r;\n    double v;\n    bool destroyed;\n    bool entered;\n} UFO;\n\ndouble distance(double x, double y) {\n    return sqrt(x * x + y * y);\n}\n\ndouble distancePointToLine(double px, double py, double lx, double ly) {\n    if (lx == 0 && ly == 0) return INF;\n    double dot = px * lx + py * ly;\n    if (dot < 0) return INF;\n    double len = sqrt(lx * lx + ly * ly);\n    return fabs(px * ly - py * lx) / len;\n}\n\nint main() {\n    int R, N;\n    \n    while (scanf(\"%d %d\", &R, &N) == 2) {\n        if (R == 0 && N == 0) break;\n        \n        UFO ufos[MAX_N];\n        for (int i = 0; i < N; i++) {\n            scanf(\"%lf %lf %lf %lf\", &ufos[i].x, &ufos[i].y, &ufos[i].r, &ufos[i].v);\n            ufos[i].destroyed = false;\n            ufos[i].entered = false;\n        }\n        \n        int time = 1;\n        while (true) {\n            bool any_outside = false;\n            for (int i = 0; i < N; i++) {\n                if (ufos[i].destroyed || ufos[i].entered) continue;\n                \n                double dx = -ufos[i].x;\n                double dy = -ufos[i].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double curr_x = ufos[i].x + dx * ufos[i].v * time;\n                double curr_y = ufos[i].y + dy * ufos[i].v * time;\n                double dist = distance(curr_x, curr_y);\n                \n                if (dist > R) {\n                    any_outside = true;\n                    break;\n                }\n            }\n            \n            if (!any_outside) break;\n            \n            int target = -1;\n            double min_dist = INF;\n            \n            for (int i = 0; i < N; i++) {\n                if (ufos[i].destroyed || ufos[i].entered) continue;\n                \n                double dx = -ufos[i].x;\n                double dy = -ufos[i].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double curr_x = ufos[i].x + dx * ufos[i].v * time;\n                double curr_y = ufos[i].y + dy * ufos[i].v * time;\n                double dist = distance(curr_x, curr_y);\n                \n                if (dist > R && dist < min_dist) {\n                    min_dist = dist;\n                    target = i;\n                }\n            }\n            \n            if (target != -1) {\n                double dx = -ufos[target].x;\n                double dy = -ufos[target].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double target_x = ufos[target].x + dx * ufos[target].v * time;\n                double target_y = ufos[target].y + dy * ufos[target].v * time;\n                \n                for (int i = 0; i < N; i++) {\n                    if (ufos[i].destroyed || ufos[i].entered) continue;\n                    \n                    double dx2 = -ufos[i].x;\n                    double dy2 = -ufos[i].y;\n                    double len2 = sqrt(dx2 * dx2 + dy2 * dy2);\n                    dx2 /= len2;\n                    dy2 /= len2;\n                    \n                    double curr_x = ufos[i].x + dx2 * ufos[i].v * time;\n                    double curr_y = ufos[i].y + dy2 * ufos[i].v * time;\n                    \n                    double dist_to_laser = distancePointToLine(curr_x, curr_y, target_x, target_y);\n                    \n                    if (dist_to_laser <= ufos[i].r) {\n                        ufos[i].destroyed = true;\n                    }\n                }\n            }\n            \n            for (int i = 0; i < N; i++) {\n                if (ufos[i].destroyed || ufos[i].entered) continue;\n                \n                double dx = -ufos[i].x;\n                double dy = -ufos[i].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double curr_x = ufos[i].x + dx * ufos[i].v * time;\n                double curr_y = ufos[i].y + dy * ufos[i].v * time;\n                double dist = distance(curr_x, curr_y);\n                \n                if (dist <= R) {\n                    ufos[i].entered = true;\n                }\n            }\n            \n            time++;\n        }\n        \n        int count = 0;\n        for (int i = 0; i < N; i++) {\n            if (ufos[i].entered) count++;\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" INF 1e9 typedef  y) { return sqrt(x *  py, double  == 0) return INF; double dot = px * lx + py * ly; if (dot < 0) return INF; double len = sqrt(lx * lx +  lx) / len; } int main() { int R, N; while (scanf(\"%d %d\", &R, &N) == 2) { if (R == 0 && N == 0)  N; i++) { scanf(\"%lf %lf %lf %lf\", &ufos[i].x, &ufos[i].y, &ufos[i].r, &ufos[i].v); ufos[i].destroyed = false; ufos[i].entered = false; } int time = 1; while (true) { bool any_outside = false; for (int  || ufos[i].entered) continue; double dx = -ufos[i].x; double dy = -ufos[i].y; double len = sqrt(dx * dx + dy * dy); dx /= len; dy /= len; double curr_x = ufos[i].x + dx * ufos[i].v * time; double curr_y = ufos[i].y + dy * ufos[i].v * time; double dist = distance(curr_x, curr_y); if (dist > R) { any_outside = true; break; } } if (!any_outside) break; int target = -1; double min_dist = INF; for (int i = 0; i < N; i++) { if (ufos[i].destroyed || ufos[i].entered) continue; double dx = -ufos[i].x; double dy = -ufos[i].y; double len = sqrt(dx * dx  double curr_x = ufos[i].x + dx * ufos[i].v  * time; double dist = distance(curr_x, curr_y); if (dist > R && dist < min_dist) { min_dist = dist; target = i; } } if (target != -1) { double dx = -ufos[target].x; double dy  * dy); dx /= len; dy /=  time; double target_y = ufos[target].y + dy * ufos[target].v * time; for (int i = 0; i < N; i++) { if (ufos[i].destroyed || ufos[i].entered) continue; double dx2 = -ufos[i].x; double dy2 = -ufos[i].y; double len2 = sqrt(dx2 * dx2 + dy2 * dy2); dx2 /= len2; dy2 /= len2;  double curr_y = ufos[i].y + dy2 *  if (dist_to_laser <= ufos[i].r) { ufos[i].destroyed = true; } } } for (int i = 0; i < N; i++) { if (ufos[i].destroyed || ufos[i].entered) continue; double dx = -ufos[i].x; double dy =  dy); dx /=  * ufos[i].v * time; double curr_y = ufos[i].y + dy * ufos[i].v * time; double dist = distance(curr_x, curr_y); if (dist <= R) { ufos[i].entered = true; } } time++; } int count = 0; for (int i = 0; i < N; i++) { if (ufos[i].entered) count++; } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> #define EPS (1e-8) typedef struct { double x,y; double angle; int r; int v; int arrive; } ufo_t; int N; ufo_t ufo[100]; int R; double get_dist(double mx,double my,double x,double y) { return fabs(my*x-mx*y)/sqrt(my*my+mx*mx); } int main(void) { int i; int target;  for(i=0;i<N;i++) { scanf(\"%lf%lf%d%d\", &ufo[i].x,&ufo[i].y,&ufo[i].r,&ufo[i].v); ufo[i].arrive=1; ufo[i].angle=atan2(ufo[i].y,ufo[i].x); } target=0; while(target>=0) { for(i=0;i<N;i++) { if(R+EPS<sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y)) { double prev_x,prev_y;  for(i=0;i<N;i++) { double dist; if(!ufo[i].arrive)continue; dist=sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y); if(dist<target_dist+EPS && R+EPS<dist) { target_dist=dist; target=i; } } if(target<0)break; for(i=0;i<N;i++) { if(sqrt(ufo[i].x*ufo[i].x+ ufo[i].y*ufo[i].y)<R+EPS)continue; if(get_dist(ufo[target].x,ufo[target].y, ufo[i].x,ufo[i].y)<ufo[i].r+EPS && ufo[target].x*ufo[i].x>=0 && ufo[target].y*ufo[i].y>=0) { ufo[i].arrive=0; } }  }"], "original_ll": -0.7960120439529419, "sampled_ll": -0.34076812863349915, "all_perturbed_sampled_ll": [-1.0314937829971313], "all_perturbed_original_ll": [-1.160559892654419], "perturbed_sampled_ll": -1.0314937829971313, "perturbed_original_ll": -1.160559892654419, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint r, n;\n\t\twhile ((r = s.nextInt()) != 0 && (n = s.nextInt()) != 0) {\n\t\t\tdouble[][] ufo = new double[n][6];  // x, y, r, v(, dis, fin_step)\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tufo[i][j] = s.nextInt();\n\t\t\t\tufo[i][4] = Math.hypot(ufo[i][0], ufo[i][1]); // \u008b\u0097\u0097\u00a3\n\t\t\t\tufo[i][5] = Math.floor((Math.abs(ufo[i][4]) - r) / ufo[i][3]); // \u0090N\u0093\u00fc\u008e\u009e\u008a\u00d4\n\t\t\t}\n\n\t\t\tint[] st = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\tst[i] = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) { // step\t\t\t\t\n\t\t\t\t // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\u0082\u00f0\u0092T\u0082\u00b5\u0081A\u0093\u00af\u008e\u009e\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00b5\u0082\u00bdUFO\u0082\u00c9\u0083}\u0081[\u0083N\n\t\t\t\tint near = -1;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fcor\u008c\u0082\u0092\u00c4\n\t\t\t\t\tif (ufo[j][5] < i) st[j] = 1;  // \u0090N\u0093\u00fc\u0082\u00b5\u0082\u00bd\n\t\t\t\t\telse if (near == -1 || ufo[near][4] > ufo[j][4])\n\t\t\t\t\t\tnear = j; // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\n\t\t\t\t}\n\t\t\t\tif (near == -1) break;\n\t\t\t\tdouble x0 = ufo[near][0]; // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\n\t\t\t\tdouble y0 = ufo[near][1];\n\n\t\t\t\t// UFO\u0082\u00f0\u008c\u0082\u0092\u00c4\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00a9\u008c\u0082\u0092\u00c4\u008f\u00f3\u0091\u00d4\u0082\u00c8\u0082\u00e7\u0083X\u0083\u008b\u0081[\n\t\t\t\t\tdouble x1 = ufo[j][0];\n\t\t\t\t\tdouble y1 = ufo[j][1];\n\t\t\t\t\t\n\t\t\t\t\tif (y0 == 0) {\n\t\t\t\t\t\tif ((x0 >= 0 && x1 >= 0) || (x0 < 0 && x1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab\n\t\t\t\t\t\t\tif (Math.abs(y1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4\n\t\t\t\t\t} else if (x0 == 0) {\n\t\t\t\t\t\tif ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab\n\t\t\t\t\t\t\tif (Math.abs(x1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdouble a = y0 / x0; // \u008cX\u0082\u00ab\n\t\t\t\t\t\tif ((x0 >= 0 && x1 >= 0) || (x0 < 0 && x1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab\n\t\t\t\t\t\t\tif ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 < 0))\n\t\t\t\t\t\t\t\tif (Math.abs(y1 - a * x1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < n; j++) { // UFO\u0088\u00da\u0093\u00ae\n\t\t\t\t\tif (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00a9\u008c\u0082\u0092\u00c4\u008f\u00f3\u0091\u00d4\u0082\u00c8\u0082\u00e7\u0083X\u0083\u008b\u0081[\n\t\t\t\t\tufo[j][4] -= ufo[j][3];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (st[j] == 1) sum++;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class UFO {\n        double x, y;\n        double r;\n        double v;\n        boolean destroyed;\n        int id;\n        \n        UFO(double x, double y, double r, double v, int id) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n            this.v = v;\n            this.destroyed = false;\n            this.id = id;\n        }\n        \n        double distanceFromOrigin() {\n            return Math.sqrt(x * x + y * y);\n        }\n        \n        void moveTowardsOrigin(double time) {\n            if (destroyed) return;\n            double dist = distanceFromOrigin();\n            if (dist == 0) return;\n            double moveAmount = v * time;\n            if (moveAmount >= dist) {\n                x = 0;\n                y = 0;\n            } else {\n                double ratio = moveAmount / dist;\n                x -= x * ratio;\n                y -= y * ratio;\n            }\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            int R = Integer.parseInt(parts[0]);\n            int N = Integer.parseInt(parts[1]);\n            \n            if (R == 0 && N == 0) break;\n            \n            List<UFO> ufos = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                line = br.readLine();\n                parts = line.trim().split(\"\\\\s+\");\n                double x0 = Double.parseDouble(parts[0]);\n                double y0 = Double.parseDouble(parts[1]);\n                double r = Double.parseDouble(parts[2]);\n                double v = Double.parseDouble(parts[3]);\n                ufos.add(new UFO(x0, y0, r, v, i));\n            }\n            \n            int time = 1;\n            while (true) {\n                // Move all UFOs\n                for (UFO ufo : ufos) {\n                    ufo.moveTowardsOrigin(1);\n                }\n                \n                // Find closest UFO outside R\n                UFO target = null;\n                double minDist = Double.MAX_VALUE;\n                \n                for (UFO ufo : ufos) {\n                    if (!ufo.destroyed && ufo.distanceFromOrigin() > R) {\n                        double dist = ufo.distanceFromOrigin();\n                        if (dist < minDist) {\n                            minDist = dist;\n                            target = ufo;\n                        }\n                    }\n                }\n                \n                if (target == null) break;\n                \n                // Shoot laser through target\n                double tx = target.x;\n                double ty = target.y;\n                \n                for (UFO ufo : ufos) {\n                    if (!ufo.destroyed && ufo.distanceFromOrigin() > R) {\n                        if (laserHits(tx, ty, ufo)) {\n                            ufo.destroyed = true;\n                        }\n                    }\n                }\n                \n                time++;\n                if (time > 10000) break;\n            }\n            \n            int count = 0;\n            for (UFO ufo : ufos) {\n                if (!ufo.destroyed) {\n                    count++;\n                }\n            }\n            \n            System.out.println(count);\n        }\n    }\n    \n    static boolean laserHits(double lx, double ly, UFO ufo) {\n        // Laser goes from origin through (lx, ly)\n        // Check if it intersects circle at (ufo.x, ufo.y) with radius ufo.r\n        \n        double laserLen = Math.sqrt(lx * lx + ly * ly);\n        if (laserLen == 0) return false;\n        \n        // Normalize laser direction\n        double ldx = lx / laserLen;\n        double ldy = ly / laserLen;\n        \n        // Distance from ufo center to laser line\n        double dist = Math.abs(ldy * ufo.x - ldx * ufo.y);\n        \n        if (dist > ufo.r) return false;\n        \n        // Check if UFO is in the direction of the laser\n        double dot = ufo.x * ldx + ufo.y * ldy;\n        return dot > 0;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class UFO { double x,  x, double y, double r, double v, int id) { this.x = x; this.y = y; this.r = r; this.v = v; this.destroyed = false; this.id =  y * y); } void moveTowardsOrigin(double time) { if (destroyed) return; double dist = distanceFromOrigin(); if (dist == 0) return; double moveAmount = v * time; if (moveAmount >= dist) { x = 0; y = 0; } else { double ratio = moveAmount / dist; x -= x * ratio; y -= y *  IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) !=  int N = Integer.parseInt(parts[1]); if (R == 0 && N ==  = 0; i < N;  = Double.parseDouble(parts[0]); double y0 = Double.parseDouble(parts[1]); double r = Double.parseDouble(parts[2]); double v =  = 1; while (true) { // Move all UFOs for (UFO ufo : ufos) { ufo.moveTowardsOrigin(1); } // Find closest UFO outside R UFO target = null; double minDist = Double.MAX_VALUE; for (UFO ufo : ufos) { if (!ufo.destroyed && ufo.distanceFromOrigin() > R) { double dist = ufo.distanceFromOrigin(); if (dist < minDist) { minDist = dist; target = ufo;  laser through target double tx = target.x; double ty = target.y; for (UFO ufo : ufos) { if (!ufo.destroyed && ufo.distanceFromOrigin() > R) { if (laserHits(tx, ty, ufo)) { ufo.destroyed = true; } } } time++; if (time > 10000) break; } int count = 0; for  } System.out.println(count); } } static boolean laserHits(double lx, double ly, UFO ufo) { // Laser goes from origin through (lx, ly) // Check if it intersects circle at (ufo.x, ufo.y) with radius ufo.r double laserLen = Math.sqrt(lx * lx  //  ldy = ly  double dist = Math.abs(ldy * ufo.x - ldx * ufo.y); if (dist > ufo.r) return false; // Check if  = ufo.x * ldx + ufo.y * ldy; return dot > 0; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner s = new Scanner(System.in); int r, n; while ((r = s.nextInt()) != 0 && (n = s.nextInt()) != 0) { double[][] ufo = new double[n][6]; // x, y, r, v(, dis, fin_step) for (int i = 0; i < n; i++) { for (int j = 0; j < 4; j++) ufo[i][j] = s.nextInt(); ufo[i][4] = Math.hypot(ufo[i][0], ufo[i][1]); // \u008b\u0097\u0097\u00a3 ufo[i][5] = Math.floor((Math.abs(ufo[i][4]) - r) / ufo[i][3]); // \u0090N\u0093\u00fc\u008e\u009e\u008a\u00d4 } int[] st = new int[n]; for (int i = 0; i  \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\u0082\u00f0\u0092T\u0082\u00b5\u0081A\u0093\u00af\u008e\u009e\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00b5\u0082\u00bdUFO\u0082\u00c9\u0083}\u0081[\u0083N int near = -1; for (int j = 0; j < n; j++) { if (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fcor\u008c\u0082\u0092\u00c4  if (near ==  } if (near == -1) break; double x0 = ufo[near][0]; // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO double y0 = ufo[near][1]; // UFO\u0082\u00f0\u008c\u0082\u0092\u00c4 for (int j = 0; j < n; j++)  = ufo[j][0]; double y1 = ufo[j][1];  x1 >= 0) || (x0 < 0 && x1  2; // \u008c\u0082\u0092\u00c4 } else if (x0 == 0) { if ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab if (Math.abs(x1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4 } else { double a = y0  >= 0) || (x0 <  0 && y1 >= 0) || (y0 <  x1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4 } } for (int j = 0; j < n; j++) { // UFO\u0088\u00da\u0093\u00ae if  } int sum = 0; for (int j = 0; j < n; j++) if (st[j] == 1) sum++; System.out.println(sum); } } }"], "original_ll": -1.1060551404953003, "sampled_ll": -0.6230924129486084, "all_perturbed_sampled_ll": [-1.6339356899261475], "all_perturbed_original_ll": [-1.785658359527588], "perturbed_sampled_ll": -1.6339356899261475, "perturbed_original_ll": -1.785658359527588, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from math import sqrt\nwhile 1:\n    R, N = map(int, raw_input().split())\n    if R == N == 0:\n        break\n    P = []\n    for i in xrange(N):\n        x, y, r, v = map(int, raw_input().split())\n        P.append((sqrt(x**2+y**2), x**2+y**2, x, y, r, v, i))\n    kill = [0]*N\n    ans = 0\n    for t in xrange(1, N+1):\n        j = None; mi = 10**9\n        for l, ll, x, y, r, v, i in P:\n            if kill[i]:\n                continue\n            if ll < (R + t*v)**2:\n                kill[i] = 1\n                ans += 1\n\n            if not kill[i] and l - t*v < mi:\n                mi = l - t*v\n                j = i\n        if j is None:\n            break\n        l0, ll0, x0, y0, r0, v0, j = P[j]\n        for l, ll, x, y, r, v, i in P:\n            if kill[i]:\n                continue\n            if (l - t*v)*abs(x0*y - x*y0) < r*l*l0 + 1e-8:\n                kill[i] = 1\n    print ans", "sampled": "import math\n\ndef distance(x, y):\n    return math.sqrt(x*x + y*y)\n\ndef line_circle_intersection(x0, y0, r, px, py):\n    # Check if line from origin through (px, py) intersects circle at (x0, y0) with radius r\n    # Line can be parameterized as (t*px, t*py) for t >= 0\n    # Circle: (x-x0)^2 + (y-y0)^2 = r^2\n    # Substitute: (t*px - x0)^2 + (t*py - y0)^2 = r^2\n    \n    if px == 0 and py == 0:\n        return distance(x0, y0) <= r\n    \n    # Line direction vector (px, py)\n    # Distance from point (x0, y0) to line through origin with direction (px, py)\n    # d = |x0*py - y0*px| / sqrt(px^2 + py^2)\n    \n    d = abs(x0 * py - y0 * px) / math.sqrt(px*px + py*py)\n    \n    return d <= r\n\nwhile True:\n    line = input().split()\n    R = int(line[0])\n    N = int(line[1])\n    \n    if R == 0 and N == 0:\n        break\n    \n    ufos = []\n    for i in range(N):\n        parts = list(map(int, input().split()))\n        x0, y0, r, v = parts[0], parts[1], parts[2], parts[3]\n        ufos.append([x0, y0, r, v, True])  # True means not destroyed\n    \n    time = 1\n    invaded = 0\n    \n    while True:\n        # Move all UFOs\n        for i in range(N):\n            if ufos[i][4]:  # If not destroyed\n                x0, y0, r, v = ufos[i][0], ufos[i][1], ufos[i][2], ufos[i][3]\n                dist = distance(x0, y0)\n                if dist > 0:\n                    # Move towards origin\n                    dx = -x0 / dist\n                    dy = -y0 / dist\n                    ufos[i][0] += dx * v * time\n                    ufos[i][1] += dy * v * time\n        \n        # Check for invaded UFOs\n        for i in range(N):\n            if ufos[i][4]:\n                dist = distance(ufos[i][0], ufos[i][1])\n                if dist <= R:\n                    invaded += 1\n                    ufos[i][4] = False\n        \n        # Find closest UFO outside R\n        min_dist = float('inf')\n        target_idx = -1\n        for i in range(N):\n            if ufos[i][4]:\n                dist = distance(ufos[i][0], ufos[i][1])\n                if dist > R and dist < min_dist:\n                    min_dist = dist\n                    target_idx = i\n        \n        if target_idx == -1:\n            break\n        \n        # Fire laser at target\n        tx, ty = ufos[target_idx][0], ufos[target_idx][1]\n        \n        # Destroy all UFOs that intersect with this laser line\n        for i in range(N):\n            if ufos[i][4]:\n                dist = distance(ufos[i][0], ufos[i][1])\n                if dist > R:\n                    if line_circle_intersection(ufos[i][0], ufos[i][1], ufos[i][2], tx, ty):\n                        ufos[i][4] = False\n        \n        time = 1\n    \n    print(invaded)\n", "perturbed_sampled": ["import math def distance(x, y):  # Check if line from origin through (px, py) intersects circle at (x0, y0) with radius r # Line can be parameterized as (t*px, t*py) for t >= 0 # Circle: (x-x0)^2 + (y-y0)^2 = r^2 # Substitute: (t*px - x0)^2  and py ==  (px, py) # Distance from point  # d = |x0*py - y0*px| / sqrt(px^2 + py^2) d = abs(x0 * py - y0 * px) / math.sqrt(px*px + py*py) return d <=  = int(line[1]) if R == 0 and N == 0: break ufos = [] for i in range(N): parts = list(map(int, input().split())) x0, y0, r, v = parts[0], parts[1], parts[2], parts[3] ufos.append([x0, y0, r, v, True]) # True means not destroyed time = 1 invaded = 0 while True: # Move all UFOs for i in range(N): if ufos[i][4]: # If not  dist = distance(x0, y0) if dist > 0: # Move towards origin dx = -x0 / dist dy = -y0 / dist ufos[i][0] += dx * v * time ufos[i][1] += dy * v * time # Check for invaded UFOs for i in range(N): if ufos[i][4]: dist = distance(ufos[i][0], ufos[i][1]) if dist <= R: invaded += 1 ufos[i][4] = False # Find closest UFO outside R min_dist = float('inf') target_idx =  -1: break # Fire laser at target tx, ty = ufos[target_idx][0], ufos[target_idx][1] # Destroy all UFOs that intersect with this laser line for i in range(N): if ufos[i][4]: dist = distance(ufos[i][0], ufos[i][1]) if dist  False time = 1 print(invaded)"], "perturbed_original": ["from math import sqrt while 1: R, N = map(int, raw_input().split()) if R == N == 0: break P = [] for   ans = 0 for t in xrange(1, N+1): j = None; mi = 10**9 for l, ll, x, y, r, v, i in P: if kill[i]: continue if ll < (R + t*v)**2: kill[i] = 1 ans += 1 if not kill[i] and l - t*v < mi: mi = l -  l, ll, x, y, r, v, i in P: if kill[i]: continue if (l - t*v)*abs(x0*y - x*y0) < r*l*l0 + 1e-8: kill[i] = 1 print ans"], "original_ll": -1.1521791219711304, "sampled_ll": -0.8005489110946655, "all_perturbed_sampled_ll": [-1.741118311882019], "all_perturbed_original_ll": [-2.210709810256958], "perturbed_sampled_ll": -1.741118311882019, "perturbed_original_ll": -2.210709810256958, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n        int point[10][10]={0};\n        int person=0,endFlag=0,result=0,count,repeat,versusCount,myGTP,theyGTP;\n        printf(\"\u5165\u529b\\n\");\n        for(count=0; endFlag==0; count++){\n                for(person=0; person<5 && endFlag==0; person++){\n                        scanf(\"%d\",&point[count][person]);\n                        if(point[count][person]<0||point[count][person]>3){\n                        printf(\"\u30a8\u30e9\u30fc\u3001\u7d42\u4e86\u3057\u307e\u3059\u3002\");\n                        exit(1);\n                                }\n                        if(point[count][person]==0){\n                                endFlag=1;\n                                }\n                        }\n                }\n        repeat=count;\n        printf(\"\\n\u51fa\u529b\\n\");\n        for(count=0; count<repeat; count++){\n                for(person=0; point[count][person]!=0; person++){\n                        for(versusCount=0; point[count][versusCount]!=0; versusCount++){\n                        myGTP=point[count][person];\n                        theyGTP=point[count][versusCount];\n                        if(person!=versusCount){\n                        if(((myGTP+1==theyGTP)||(myGTP-2==theyGTP))&&(result!=1)&&(result!=3)){\n                                result+=1;\n                                }\n                        if(((myGTP+2==theyGTP)||(myGTP-1==theyGTP))&&(result!=2)&&(result!=3)){\n                                result+=2;\n                                }\n                        }\n                        }\n                if(result==0){\n                        result=3;\n                        }\n                                printf(\"\\n%d\",result);\n                                result=0;\n                                }\n                        }\n        return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int h[5];\n    \n    while(1) {\n        scanf(\"%d\", &h[0]);\n        if(h[0] == 0) break;\n        \n        for(int i = 1; i < 5; i++) {\n            scanf(\"%d\", &h[i]);\n        }\n        \n        int count[4] = {0};\n        for(int i = 0; i < 5; i++) {\n            count[h[i]]++;\n        }\n        \n        int types = 0;\n        for(int i = 1; i <= 3; i++) {\n            if(count[i] > 0) types++;\n        }\n        \n        if(types == 1 || types == 3) {\n            for(int i = 0; i < 5; i++) {\n                printf(\"3\\n\");\n            }\n        } else {\n            int winning_hand;\n            if(count[1] > 0 && count[2] > 0) {\n                winning_hand = 1;\n            } else if(count[2] > 0 && count[3] > 0) {\n                winning_hand = 2;\n            } else {\n                winning_hand = 3;\n            }\n            \n            for(int i = 0; i < 5; i++) {\n                if(h[i] == winning_hand) {\n                    printf(\"1\\n\");\n                } else {\n                    printf(\"2\\n\");\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int h[5]; while(1) { scanf(\"%d\", &h[0]); if(h[0] == 0) break; for(int i = 1; i <  for(int i = 0; i < 5; i++) { count[h[i]]++; } int types = 0; for(int i = 1; i <= 3; i++) { if(count[i] > 0) types++; } if(types == 1 ||  5; i++) { printf(\"3\\n\"); } } else { int winning_hand; if(count[1] > 0 && count[2] > 0) {  > 0) { winning_hand  i = 0; i < 5; i++) { if(h[i] == winning_hand) { printf(\"1\\n\"); } else { printf(\"2\\n\"); } } } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int point[10][10]={0}; int person=0,endFlag=0,result=0,count,repeat,versusCount,myGTP,theyGTP; printf(\"\u5165\u529b\\n\"); for(count=0; endFlag==0; count++){ for(person=0; person<5 && endFlag==0; person++){ scanf(\"%d\",&point[count][person]); if(point[count][person]<0||point[count][person]>3){ printf(\"\u30a8\u30e9\u30fc\u3001\u7d42\u4e86\u3057\u307e\u3059\u3002\"); exit(1); } if(point[count][person]==0){  point[count][person]!=0; person++){ for(versusCount=0; point[count][versusCount]!=0; versusCount++){ myGTP=point[count][person]; theyGTP=point[count][versusCount]; if(person!=versusCount){ if(((myGTP+1==theyGTP)||(myGTP-2==theyGTP))&&(result!=1)&&(result!=3)){ result+=1; } if(((myGTP+2==theyGTP)||(myGTP-1==theyGTP))&&(result!=2)&&(result!=3)){ result+=2; } } } if(result==0){ result=3; } printf(\"\\n%d\",result); result=0; } } return 0; }"], "original_ll": -1.2796039581298828, "sampled_ll": -0.561272144317627, "all_perturbed_sampled_ll": [-1.4492757320404053], "all_perturbed_original_ll": [-1.494653344154358], "perturbed_sampled_ll": -1.4492757320404053, "perturbed_original_ll": -1.494653344154358, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "//Volume2-0205\nimport java.util.Scanner;\n\nclass Main {\n\n\tprivate static int[] cnt,\n             \t\t     player,\n\t\t                 result;\n\n\tpublic static void main(String[] args){\n\t\tint   victory,loss;\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tcnt    = new int[4];\n\t\t\tplayer = new int[5];\n\t\t\tresult = new int[5];\n\t\t\tplayer[0] = sc.nextInt();\n\t\t\tif(player[0] == 0){break;}\n\t\t\tcnt[player[0]]++;\n\t\t\tfor(int i=1;i<5;i++){\n\t\t\t\tplayer[i] = sc.nextInt();\n\t\t\t\tcnt[player[i]]++;\n\t\t\t}\n\t\t\tscape : {\n\t\t\t\tif(cnt[1] == 5 || cnt[2] == 5 || cnt[3] == 5 ||\n\t\t\t\t  (cnt[1] != 0 && cnt[2] != 0 && cnt[3] != 0    )){\n\t\t\t\t\tfor(int j=0;j<5;j++){result[j] = 3;}\n\t\t\t\t\tbreak scape;\n\t\t\t\t}\n\t\t\t\tvictory = 0; loss = 0;\n\t\t\t\tif       (cnt[1] != 0 && cnt[2] != 0){\n\t\t\t\t\tvictory = 1;\n\t\t\t\t\tloss    = 2;\n\t\t\t\t} else if(cnt[2] != 0 && cnt[3] != 0){\n\t\t\t\t\tvictory = 2;\n\t\t\t\t\tloss    = 3;\n\t\t\t\t} else if(cnt[1] != 0 && cnt[3] != 0){\n\t\t\t\t\tvictory = 3;\n\t\t\t\t\tloss    = 1;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\tif        (player[j] == victory){\n\t\t\t\t\t\tresult[j] = 1;\n\t\t\t\t\t} else if (player[j] == loss){\n\t\t\t\t\t\tresult[j] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i:result){System.out.println(i);}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int h1 = sc.nextInt();\n            if (h1 == 0) break;\n            \n            int h2 = sc.nextInt();\n            int h3 = sc.nextInt();\n            int h4 = sc.nextInt();\n            int h5 = sc.nextInt();\n            \n            int[] hands = {h1, h2, h3, h4, h5};\n            \n            boolean hasRock = false;\n            boolean hasScissors = false;\n            boolean hasPaper = false;\n            \n            for (int hand : hands) {\n                if (hand == 1) hasRock = true;\n                else if (hand == 2) hasScissors = true;\n                else if (hand == 3) hasPaper = true;\n            }\n            \n            int distinctCount = 0;\n            if (hasRock) distinctCount++;\n            if (hasScissors) distinctCount++;\n            if (hasPaper) distinctCount++;\n            \n            if (distinctCount == 1 || distinctCount == 3) {\n                for (int i = 0; i < 5; i++) {\n                    System.out.println(3);\n                }\n            } else {\n                int winningHand;\n                if (hasRock && hasScissors) {\n                    winningHand = 1;\n                } else if (hasScissors && hasPaper) {\n                    winningHand = 2;\n                } else {\n                    winningHand = 3;\n                }\n                \n                for (int hand : hands) {\n                    if (hand == winningHand) {\n                        System.out.println(1);\n                    } else {\n                        System.out.println(2);\n                    }\n                }\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int h1 = sc.nextInt(); if (h1 == 0) break; int h2  int h5 = sc.nextInt(); int[] hands = {h1, h2, h3, h4, h5}; boolean hasRock = false; boolean hasScissors = false; boolean hasPaper = false; for (int hand : hands) { if (hand == 1)  true; else if (hand == 3) hasPaper  if (hasScissors) distinctCount++; if (hasPaper) distinctCount++;  (int i = 0; i < 5; i++) { System.out.println(3); } } else { int winningHand; if (hasRock && hasScissors) { winningHand = 1; } else if (hasScissors && hasPaper) { winningHand  (int hand : hands) { if (hand == winningHand) { System.out.println(1); } else { System.out.println(2); } } } } sc.close(); } }"], "perturbed_original": ["//Volume2-0205 import java.util.Scanner; class Main { private static int[] cnt, player, result; public static void main(String[] args){ int victory,loss; Scanner sc = new Scanner(System.in); while(true){ cnt = new int[4]; player = new int[5]; result = new int[5]; player[0] = sc.nextInt(); if(player[0]  scape : { if(cnt[1] == 5 || cnt[2] ==  cnt[2] != 0 && cnt[3] != 0 )){ for(int j=0;j<5;j++){result[j] = 3;} break scape; } victory =  != 0){ victory = 1; loss = 2; } else if(cnt[2] != 0 && cnt[3] != 0){ victory = 2; loss = 3; } else if(cnt[1] != 0 && cnt[3] != 0){ victory = 3; loss = 1; } for(int j=0;j<5;j++){ if (player[j] == victory){ result[j] = 1; } else  for(int i:result){System.out.println(i);} } } }"], "original_ll": -1.0414963960647583, "sampled_ll": -0.4549848735332489, "all_perturbed_sampled_ll": [-1.2632194757461548], "all_perturbed_original_ll": [-1.7595576047897339], "perturbed_sampled_ll": -1.2632194757461548, "perturbed_original_ll": -1.7595576047897339, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#5\u500b\u306e\u3046\u30611\u756a\u76ee\u306e\u5165\u529b\u304c0\u306a\u3089\u51e6\u7406\u3092\u7d42\u308f\u308b\u3002\nwhile True:\n    line = []\n    line.append(int(input()))\n    if line[0] == 0:break\n\n    #\u6a19\u6e96\u5165\u529b\u3092\u3057\u30ea\u30b9\u30c8\u3092\u30bb\u30c3\u30c8\u306b\u3057\u305f\u3082\u306e\u3092\u4f5c\u308b\u3002\n    for _ in range(4):line.append(int(input()))\n    se = set(line)\n    \n    #\u5168\u54e1\u304c\u540c\u3058\u6570\u3092\u51fa\u3059\u304b3\u7a2e\u985e\u306e\u624b\u304c\u51fa\u305f\u30895\u3053\"3\"\u3092\u51fa\u529b\u3059\u308b\u3002\n    if len(se) == 1 or len(se) == 3:\n        for _ in range(5):print(\"3\")\n        \"\"\n    #\u3058\u3083\u3093\u3051\u3093\u306e\u52dd\u6557\u306b\u57fa\u3065\u304d\u52dd\u3061\u3060\u3063\u305f\u3089\"1\"\u8ca0\u3051\u3060\u3063\u305f\u3089\"2\"\u3092\u51fa\u529b\u3059\u308b\n    else:\n        if sum(se) == 3:\n            for i in line:\n                if i == 1:print(\"1\")\n                else:print(\"2\")\n        if sum(se) == 4:\n            for i in line:\n                if i == 3:print(\"1\")\n                else:print(\"2\")\n        if sum(se) == 5:\n            for i in line:\n                if i == 2:print(\"1\")\n                else:print(\"2\")\n", "sampled": "while True:\n    h1 = int(input())\n    if h1 == 0:\n        break\n    \n    hands = [h1]\n    for _ in range(4):\n        hands.append(int(input()))\n    \n    unique_hands = set(hands)\n    \n    # Check if it's a draw (all same or all three types)\n    if len(unique_hands) == 1 or len(unique_hands) == 3:\n        for _ in range(5):\n            print(3)\n    else:\n        # Two types of hands - determine winner\n        hand_list = list(unique_hands)\n        h_a, h_b = hand_list[0], hand_list[1]\n        \n        # Determine which hand wins\n        # 1 (rock) beats 2 (scissors)\n        # 2 (scissors) beats 3 (paper)\n        # 3 (paper) beats 1 (rock)\n        if (h_a == 1 and h_b == 2) or (h_a == 2 and h_b == 1):\n            winning_hand = 1\n        elif (h_a == 2 and h_b == 3) or (h_a == 3 and h_b == 2):\n            winning_hand = 2\n        else:  # (h_a == 3 and h_b == 1) or (h_a == 1 and h_b == 3)\n            winning_hand = 3\n        \n        for hand in hands:\n            if hand == winning_hand:\n                print(1)\n            else:\n                print(2)\n", "perturbed_sampled": ["while True: h1 = int(input()) if h1 == 0: break hands = [h1] for _ in range(4): hands.append(int(input())) unique_hands  or all three types) if len(unique_hands) == 1 or len(unique_hands) == 3: for _ in range(5): print(3) else: #  wins # 1 (rock) beats 2 (scissors) # 2 (scissors) beats 3 (paper) # 3 (paper) beats 1 (rock) if (h_a  and h_b == 1): winning_hand = 1 elif (h_a == 2 and h_b == 3) or (h_a == 3 and h_b == 2): winning_hand = 2 else: # (h_a == 3 and h_b == 1) or (h_a == 1 and h_b == 3) winning_hand = 3 for hand in hands: if hand == winning_hand: print(1) else: print(2)"], "perturbed_original": ["#5\u500b\u306e\u3046\u30611\u756a\u76ee\u306e\u5165\u529b\u304c0\u306a\u3089\u51e6\u7406\u3092\u7d42\u308f\u308b\u3002 while True: line = [] line.append(int(input())) if line[0] == 0:break #\u6a19\u6e96\u5165\u529b\u3092\u3057\u30ea\u30b9\u30c8\u3092\u30bb\u30c3\u30c8\u306b\u3057\u305f\u3082\u306e\u3092\u4f5c\u308b\u3002 for _ in range(4):line.append(int(input())) se = set(line) #\u5168\u54e1\u304c\u540c\u3058\u6570\u3092\u51fa\u3059\u304b3\u7a2e\u985e\u306e\u624b\u304c\u51fa\u305f\u30895\u3053\"3\"\u3092\u51fa\u529b\u3059\u308b\u3002 if len(se) == 1 or len(se) == 3: for _ in range(5):print(\"3\") \"\" #\u3058\u3083\u3093\u3051\u3093\u306e\u52dd\u6557\u306b\u57fa\u3065\u304d\u52dd\u3061\u3060\u3063\u305f\u3089\"1\"\u8ca0\u3051\u3060\u3063\u305f\u3089\"2\"\u3092\u51fa\u529b\u3059\u308b else: if sum(se) == 3:  sum(se) == 4: for i in line: if i == 3:print(\"1\") else:print(\"2\") if  2:print(\"1\") else:print(\"2\")"], "original_ll": -1.6594135761260986, "sampled_ll": -0.8514084219932556, "all_perturbed_sampled_ll": [-1.4013851881027222], "all_perturbed_original_ll": [-2.391641139984131], "perturbed_sampled_ll": -1.4013851881027222, "perturbed_original_ll": -2.391641139984131, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n\tint i=0,l,n,m,a[12],b;\n\twhile(1){\n\t\tb=0;\n\t\tscanf(\"%d\",&l);\n\t\tif(l==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i=0;i<12;i++){\n\t\t\tscanf(\"%d%d\",&m,&n);\n\t\t\ta[i]=m-n;\n\t\t}\n\t\tfor(i=0;i<12;i++){\n\t\t\tb=b+a[i];\n\t\t\tif(b>=l){\n\t\t\t\tprintf(\"%d\\n\",i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(b<l){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int L;\n    \n    while (scanf(\"%d\", &L) == 1 && L != 0) {\n        int savings = 0;\n        int month = 0;\n        int found = 0;\n        \n        for (int i = 1; i <= 12; i++) {\n            int M, N;\n            scanf(\"%d %d\", &M, &N);\n            \n            if (!found) {\n                savings += (M - N);\n                if (savings >= L) {\n                    month = i;\n                    found = 1;\n                }\n            }\n        }\n        \n        if (found) {\n            printf(\"%d\\n\", month);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int L; while (scanf(\"%d\", &L) == 1 && L != 0) { int savings = 0; int month = 0; int found = 0; for (int i = 1; i <= 12; i++) { int M, N; scanf(\"%d %d\",  if (savings >= L) { month =  printf(\"%d\\n\", month); } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int i=0,l,n,m,a[12],b; while(1){ b=0; scanf(\"%d\",&l); if(l==0){ break; } for(i=0;i<12;i++){ scanf(\"%d%d\",&m,&n); a[i]=m-n; } for(i=0;i<12;i++){ b=b+a[i]; if(b>=l){ printf(\"%d\\n\",i+1); break; } } if(b<l){ printf(\"NA\\n\"); } } }"], "original_ll": -0.886232316493988, "sampled_ll": -0.8190506100654602, "all_perturbed_sampled_ll": [-1.6053673028945923], "all_perturbed_original_ll": [-1.173183798789978], "perturbed_sampled_ll": -1.6053673028945923, "perturbed_original_ll": -1.173183798789978, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main{\n\tstatic Scanner sc;\n\tstatic int L,M,N,T,mth;\n\t\n\tpublic static void main(String[]args){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tL=sc.nextInt();\n\t\t\tmth=0;\n\t\t\tT=0;M=0;N=0;\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tM=sc.nextInt();\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tT=T+M-N;\n\t\t\t\tif(T>=L && mth==0){\n\t\t\t\t\tmth=i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mth==0){System.out.println(\"NA\");}\n\t\t\telse{System.out.println(mth);}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int L = sc.nextInt();\n            if (L == 0) break;\n            \n            int savings = 0;\n            int month = 0;\n            boolean found = false;\n            \n            for (int i = 1; i <= 12; i++) {\n                int M = sc.nextInt();\n                int N = sc.nextInt();\n                savings += (M - N);\n                \n                if (!found && savings >= L) {\n                    month = i;\n                    found = true;\n                }\n            }\n            \n            if (found) {\n                System.out.println(month);\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int L = sc.nextInt(); if (L == 0) break; int savings = 0; int month = 0; boolean found = false; for (int i = 1; i <= 12; i++) { int M =  if (!found && savings >= L) {  { System.out.println(month); } else { System.out.println(\"NA\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main{ static Scanner sc; static int L,M,N,T,mth; public static void main(String[]args){ sc=new Scanner(System.in); while(sc.hasNext()){ L=sc.nextInt(); mth=0;  } } if(mth==0){System.out.println(\"NA\");} else{System.out.println(mth);} } } }"], "original_ll": -1.127163052558899, "sampled_ll": -0.718788743019104, "all_perturbed_sampled_ll": [-1.4279369115829468], "all_perturbed_original_ll": [-1.8904637098312378], "perturbed_sampled_ll": -1.4279369115829468, "perturbed_original_ll": -1.8904637098312378, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    L = int(input())\n    if L == 0:\n        break\n    \n    flag = True\n    ans = -1\n    d = 0\n    for i in range(12):\n        M,N = [int(i) for i in input().split()]\n        d = d + M - N\n        if d >= L and flag:\n            ans = i+1\n            flag = False\n    \n    if ans >= 0:\n        print(ans)\n    else:\n        print(\"NA\")\n\n", "sampled": "while True:\n    L = int(input())\n    if L == 0:\n        break\n    \n    savings = 0\n    months = 0\n    found = False\n    \n    for month in range(1, 13):\n        M, N = map(int, input().split())\n        savings += (M - N)\n        if savings >= L and not found:\n            months = month\n            found = True\n    \n    if found:\n        print(months)\n    else:\n        print(\"NA\")\n", "perturbed_sampled": ["while True: L = int(input()) if L == 0: break savings =  range(1, 13): M, N = map(int, input().split()) savings += (M - N) if savings >= L and not found: months = month found = True if found: print(months) else: print(\"NA\")"], "perturbed_original": ["while True: L = int(input()) if L == 0: break  i in range(12): M,N = [int(i) for i in input().split()] d = d + M - N if d >= L and flag: ans = i+1 flag = False if ans >= 0: print(ans) else: print(\"NA\")"], "original_ll": -1.2572733163833618, "sampled_ll": -1.1660139560699463, "all_perturbed_sampled_ll": [-2.563676595687866], "all_perturbed_original_ll": [-2.314002275466919], "perturbed_sampled_ll": -2.563676595687866, "perturbed_original_ll": -2.314002275466919, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0207\nTitle Block\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n#include <setjmp.h>\n//Global data section\nint w,h;\nint xs,ys;\nint xg,yg;\nint n;\nint c[100];\nint d[100];\nint x[100],y[100];\nint bd[100][100];\njmp_buf env;\n\n//\nvoid init()\n{\n  int i,j;\n  for(i=0;i<h;i++)\n    for(j=0;j<w;j++)\n      bd[i][j]=0;\n  for(i=0;i<100;i++)\n    {\n      x[i]=y[i]=d[i]=c[i]=0;\n    }\n}\nint get_block(int px,int py)\n{\n  int i;\n  // printf(\"GB%d,%d\\n\",px,py);\n  for(i=0;i<n;i++)\n    if(d[i]==0)         // yokonaga\n\t{\n\t  if(px-x[i] >=0 && px-x[i] <=3 && \n\t     py-y[i] >=0 && py-y[i] <= 1)\n\t    return(i);\n\t}\n    else if(d[i]==1)         // tatenaga\n      {\n\tif(px-x[i] >=0 && px-x[i] <=1 && \n\t   py-y[i] >=0 && py-y[i] <=3)\n\t  return(i);\n      }\n  return(-1);\n}\nint show()\n{\n  int i,j;\n  for(i=1;i<=h;i++)\n    {\n      for(j=1;j<=w;j++)\n\tprintf(\"%d\",bd[i][j]);\n      printf(\"\\n\");\n    }\n  printf(\"\\n\");\n}\nvoid paint0(int px,int py,int col,int ww,int hh)\n{\n  int i,j;\n  //printf(\"P0 %d %d\\n\",px,py);\n\n    for(i=0;i<hh;i++)\n      for(j=0;j<ww;j++)\n\tbd[py+i][px+j]=col;\n}\nint paint(int px,int py,int col)\n{\n  int cc,blk,dir,bx,by,w0,h0,i,j;\n  //printf(\"xyc=%d %d %d\\n\",px,py,col);\n\n  if(px < 1 ||py < 1) //out of bound\n    return(0);\n  if(bd[py][px])  // already painted\n    return(0);\n  blk=get_block(px,py);  // get block no of this place\n  //printf(\"blk=%d\\n\",blk);\n  if(blk<0)\n    return(0);\n  cc=c[blk];\n  dir=d[blk];\n  if(cc != col)\n    return(0);             // different color\n\n  bx=x[blk];\n  by=y[blk];\n   if(dir==0)         // yokonaga\n     { w0=4;h0=2;}\n   else\n     { w0=2;h0=4;}\n\n  paint0(bx,by,col,w0,h0); // paint this block\n\n  if(xg >= bx && xg <= bx+w0 && \n     yg >= by && yg <= by+h0 )     // reach the goal\n    {\n      longjmp(env,1);\n    }\n\n   for(i=-1;i<w0+1;i++)\n     if(i==-1||i==w0)\n       for(j=0;j<h0;j++)\n\t paint(bx+i,by+j,col);\n     else\n       for(j=-1;j<h0+1;j++)\n\t paint(bx+i,by+j,col);\n\n   return(0);\n}\nmain()\n{\n  int i,bl,col,dir,ret;\n  while(EOF != scanf(\"%d %d\",&w,&h) && (w || h))\n    {\n      init();\n      scanf(\"%d %d\",&xs,&ys);\n      scanf(\"%d %d\",&xg,&yg);\n      scanf(\"%d\",&n);\n      for(i=0;i<n;i++)\n\tscanf(\"%d %d %d %d\",&(c[i]),&(d[i]),&(x[i]),&(y[i]));\n      \n      bl = get_block(xs,ys);\n      col=c[bl];\n      if(setjmp(env)==0)\n\t{\n\t  ret = paint(xs,ys,col);\n\t}\n      else\n\tret=-1;\n      \n      paint(1,1,2);\n      show();\n      printf(\"%s\\n\",ret?\"OK\":\"NG\");\n    }\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint w, h, xs, ys, xg, yg, n;\nint board[105][105];\nint visited[105][105];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint dfs(int x, int y, int color) {\n    if (x == xg && y == yg) {\n        return 1;\n    }\n    \n    visited[y][x] = 1;\n    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        \n        if (nx >= 1 && nx <= w && ny >= 1 && ny <= h) {\n            if (!visited[ny][nx] && board[ny][nx] == color) {\n                if (dfs(nx, ny, color)) {\n                    return 1;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &w, &h);\n        if (w == 0 && h == 0) break;\n        \n        scanf(\"%d %d\", &xs, &ys);\n        scanf(\"%d %d\", &xg, &yg);\n        scanf(\"%d\", &n);\n        \n        memset(board, 0, sizeof(board));\n        memset(visited, 0, sizeof(visited));\n        \n        for (int i = 0; i < n; i++) {\n            int c, d, x, y;\n            scanf(\"%d %d %d %d\", &c, &d, &x, &y);\n            \n            if (d == 0) {\n                // horizontal: 4 wide, 2 tall\n                for (int py = y; py < y + 2 && py <= h; py++) {\n                    for (int px = x; px < x + 4 && px <= w; px++) {\n                        board[py][px] = c;\n                    }\n                }\n            } else {\n                // vertical: 2 wide, 4 tall\n                for (int py = y; py < y + 4 && py <= h; py++) {\n                    for (int px = x; px < x + 2 && px <= w; px++) {\n                        board[py][px] = c;\n                    }\n                }\n            }\n        }\n        \n        int startColor = board[ys][xs];\n        \n        if (startColor == 0 || board[yg][xg] != startColor) {\n            printf(\"NG\\n\");\n        } else {\n            if (dfs(xs, ys, startColor)) {\n                printf(\"OK\\n\");\n            } else {\n                printf(\"NG\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int w, h, xs, ys, xg, yg, n; int board[105][105]; int visited[105][105]; int dx[] = {0, 0, 1, -1}; int dy[] = {1, -1, 0, 0}; int dfs(int x, int y, int color) { if (x == xg && y == yg) { return 1; } visited[y][x] = 1; for (int i = 0; i < 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if  board[ny][nx] == color) { if (dfs(nx, ny, color)) { return 1; } }  { scanf(\"%d %d\", &w, &h); if (w == 0 && h == 0) break; scanf(\"%d %d\", &xs, &ys); scanf(\"%d %d\", &xg, &yg); scanf(\"%d\",  d, x, y; scanf(\"%d %d %d %d\", &c, &d, &x, &y); if (d == 0) {  y; py < y + 2 && py <= h; py++) { for (int  } else { // vertical: 2 wide,  + 4 && py <= h; py++) { for (int px = x; px < x + 2 && px <= w; px++) { board[py][px] = c; } } } } int startColor = board[ys][xs]; if (startColor == 0 || board[yg][xg] != startColor) { printf(\"NG\\n\"); } else { if (dfs(xs, ys, startColor)) { printf(\"OK\\n\"); } else { printf(\"NG\\n\"); } } } return 0; }"], "perturbed_original": ["/* AizuOnline A0207 Title Block */ #include <stdio.h> //  //#include <limits.h> #include <setjmp.h> //Global data section int w,h; int xs,ys; int xg,yg; int n; int c[100]; int d[100]; int x[100],y[100]; int bd[100][100]; jmp_buf env; // void init() { int i,j; for(i=0;i<h;i++) for(j=0;j<w;j++) bd[i][j]=0; for(i=0;i<100;i++) { x[i]=y[i]=d[i]=c[i]=0; } } int get_block(int px,int py) { int i; // printf(\"GB%d,%d\\n\",px,py); for(i=0;i<n;i++) if(d[i]==0) // yokonaga { if(px-x[i] >=0 && px-x[i] <=3 &&  // tatenaga { if(px-x[i] >=0 && px-x[i] <=1 && py-y[i] >=0 && py-y[i] <=3) return(i); } return(-1); } int show() { int i,j; for(i=1;i<=h;i++) { for(j=1;j<=w;j++) printf(\"%d\",bd[i][j]); printf(\"\\n\");  { int i,j; //printf(\"P0 %d %d\\n\",px,py); for(i=0;i<hh;i++) for(j=0;j<ww;j++) bd[py+i][px+j]=col; } int paint(int  < 1 ||py < 1)  // get block no of this place //printf(\"blk=%d\\n\",blk); if(blk<0) return(0); cc=c[blk];  if(dir==0) // yokonaga { w0=4;h0=2;} else { w0=2;h0=4;} paint0(bx,by,col,w0,h0); // paint this block if(xg >= bx && xg <= bx+w0 && yg >= by && yg <=  if(i==-1||i==w0) for(j=0;j<h0;j++) paint(bx+i,by+j,col); else for(j=-1;j<h0+1;j++) paint(bx+i,by+j,col); return(0); } main() { int i,bl,col,dir,ret; while(EOF != scanf(\"%d %d\",&w,&h) && (w || h)) { init(); scanf(\"%d %d\",&xs,&ys); scanf(\"%d %d\",&xg,&yg); scanf(\"%d\",&n); for(i=0;i<n;i++) scanf(\"%d %d %d %d\",&(c[i]),&(d[i]),&(x[i]),&(y[i])); bl = get_block(xs,ys);  show(); printf(\"%s\\n\",ret?\"OK\":\"NG\"); } return(0); }"], "original_ll": -1.230553150177002, "sampled_ll": -0.45623278617858887, "all_perturbed_sampled_ll": [-1.2235755920410156], "all_perturbed_original_ll": [-1.6773637533187866], "perturbed_sampled_ll": -1.2235755920410156, "perturbed_original_ll": -1.6773637533187866, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 0, -1, 0};\n    int[] dirY = {0, 1, 0, -1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\t    makeRoute();\n\t    //show();\n\n\t    if(!route[ys][xs] || !route[yg][xg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\t    else System.out.println(search(xs, ys) ? \"OK\":\"NG\");\n\t}\n    }\n\n    /*\n      \u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2\u304c\u8fd1\u304f\u306a\u308b\u3088\u3046\u306b\u9053\u3092\u9078\u3076\n      (\u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u77ed\u7e2e\u3092\u898b\u3064\u3051\u3089\u308c\u306a\u3051\u308c\u3070)\u884c\u3051\u308b\u6240\u306b\u884c\u304f\n      \u3069\u3053\u306b\u3082\u884c\u3051\u306a\u3051\u308c\u3070\u307b\u3052\u3002\n    */\n    boolean search(int x, int y){\n\tint d = getD(x, y);\n\tboolean[] goodRoute = new boolean[4];\n\tboolean[] canRoute = new boolean[4];\n\tint gc = 0;\n\tint cc = 0;\n\tif(d==0) return true;\n\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<w && b>0 && b<h && route[b][a]){\n\t\tcanRoute[i] = true;\n\t\tcc++;\n\t\tif(getD(a, b)<d){\n\t\t    goodRoute[i] = true;\n\t\t    gc++;\n\t\t}\n\t    }\n\t}\n\t\n\tif(gc!=0){\n\t    for(int i=0; i<4; i++)\n\t\tif(goodRoute[i]) \n\t\t    if(search(x+dirX[i], y+dirY[i])) return true;\n\t}\n\telse if(cc!=0){\n\t    for(int i=0; i<4; i++)\n\t\tif(canRoute[i]) \n\t\t    if(search(x+dirX[i], y+dirY[i])) return true;\n\t}\n\t\t    \n\treturn false;\n    }\n\n    int getD(int x, int y){ return Math.abs(xg-x) + Math.abs(yg-y); }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"\u25a1\":\"\u25a0\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[h][w];\n\troute = new boolean[h][w];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[b][a] = c;    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[b][a] = c;\n\t}\n    }\n\n    void makeRoute(){\n\tint tcolor = block[ys][xs];\n\tfor(int i=0; i<w; i++)\n\t    for(int k=0; k<h; k++)\n\t\tif(block[k][i]==tcolor) route[k][i] = true;\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Block {\n        int color;\n        int dir;\n        int x;\n        int y;\n        \n        Block(int color, int dir, int x, int y) {\n            this.color = color;\n            this.dir = dir;\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            \n            if (w == 0 && h == 0) break;\n            \n            int xs = sc.nextInt();\n            int ys = sc.nextInt();\n            int xg = sc.nextInt();\n            int yg = sc.nextInt();\n            int n = sc.nextInt();\n            \n            int[][] board = new int[h + 1][w + 1];\n            \n            for (int i = 0; i < n; i++) {\n                int c = sc.nextInt();\n                int d = sc.nextInt();\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                \n                if (d == 0) { // horizontal (2 high, 4 wide)\n                    for (int dy = 0; dy < 2; dy++) {\n                        for (int dx = 0; dx < 4; dx++) {\n                            if (y + dy <= h && x + dx <= w) {\n                                board[y + dy][x + dx] = c;\n                            }\n                        }\n                    }\n                } else { // vertical (4 high, 2 wide)\n                    for (int dy = 0; dy < 4; dy++) {\n                        for (int dx = 0; dx < 2; dx++) {\n                            if (y + dy <= h && x + dx <= w) {\n                                board[y + dy][x + dx] = c;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            int startColor = board[ys][xs];\n            int goalColor = board[yg][xg];\n            \n            if (startColor == 0 || goalColor == 0 || startColor != goalColor) {\n                System.out.println(\"NG\");\n                continue;\n            }\n            \n            boolean[][] visited = new boolean[h + 1][w + 1];\n            Queue<int[]> queue = new LinkedList<>();\n            queue.offer(new int[]{xs, ys});\n            visited[ys][xs] = true;\n            \n            boolean found = false;\n            int[] dx = {0, 0, 1, -1};\n            int[] dy = {1, -1, 0, 0};\n            \n            while (!queue.isEmpty()) {\n                int[] curr = queue.poll();\n                int cx = curr[0];\n                int cy = curr[1];\n                \n                if (cx == xg && cy == yg) {\n                    found = true;\n                    break;\n                }\n                \n                for (int dir = 0; dir < 4; dir++) {\n                    int nx = cx + dx[dir];\n                    int ny = cy + dy[dir];\n                    \n                    if (nx >= 1 && nx <= w && ny >= 1 && ny <= h \n                        && !visited[ny][nx] \n                        && board[ny][nx] == startColor) {\n                        visited[ny][nx] = true;\n                        queue.offer(new int[]{nx, ny});\n                    }\n                }\n            }\n            \n            System.out.println(found ? \"OK\" : \"NG\");\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Block { int color; int  x, int y) { this.color = color; this.dir = dir; this.x = x; this.y = y; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int w = sc.nextInt(); int h = sc.nextInt(); if (w ==  yg = sc.nextInt(); int n = sc.nextInt(); int[][] board = new int[h + 1][w + 1]; for (int i = 0; i < n; i++) { int c = sc.nextInt(); int d = sc.nextInt(); int  0) { // horizontal  < 2; dy++) {  if (y +  board[y + dy][x + dx] = c; } } }  (int dy = 0; dy < 4; dy++) { for (int dx = 0; dx < 2; dx++) { if (y + dy <= h && x + dx <= w) { board[y + dy][x + dx] = c; } } } } } int startColor = board[ys][xs]; int goalColor = board[yg][xg]; if (startColor == 0 || goalColor == 0 || startColor != goalColor) { System.out.println(\"NG\"); continue; } boolean[][] visited = new boolean[h   dx = {0, 0, 1, -1}; int[] dy = {1, -1, 0, 0}; while (!queue.isEmpty()) { int[] curr = queue.poll(); int cx = curr[0]; int cy = curr[1]; if (cx == xg && cy == yg) { found = true; break; }  int nx = cx + dx[dir]; int ny = cy + dy[dir]; if (nx >= 1 && nx <= w && ny >= 1 && ny <= h && !visited[ny][nx] && board[ny][nx] == startColor) { visited[ny][nx] = true; queue.offer(new int[]{nx, ny}); } } } System.out.println(found ? \"OK\" : \"NG\"); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ public static void main(String[] args){ new Main().run(); } Scanner sc = new Scanner(System.in); int w, h, xs, ys, xg, yg, n; int c, d, x, y; int[][] block; boolean[][] route; int[] dirX = {1, 0, -1, 0}; int[] dirY = {0, 1, 0, -1}; void run(){ while(sc.hasNext()){ w = sc.nextInt()+1; h  || !route[yg][xg]){ System.out.println(\"NG\"); continue; } else System.out.println(search(xs, ys) ? \"OK\":\"NG\"); } } /* \u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2\u304c\u8fd1\u304f\u306a\u308b\u3088\u3046\u306b\u9053\u3092\u9078\u3076 (\u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u77ed\u7e2e\u3092\u898b\u3064\u3051\u3089\u308c\u306a\u3051\u308c\u3070)\u884c\u3051\u308b\u6240\u306b\u884c\u304f \u3069\u3053\u306b\u3082\u884c\u3051\u306a\u3051\u308c\u3070\u307b\u3052\u3002 */ boolean search(int x,  new boolean[4]; boolean[] canRoute = new boolean[4]; int gc = 0; int cc = 0; if(d==0) return  b  route[b][a]){ canRoute[i]  } } if(gc!=0){ for(int i=0; i<4; i++) if(goodRoute[i]) if(search(x+dirX[i], y+dirY[i])) return true; } else if(cc!=0){ for(int i=0;  } int getD(int x, int y){ return Math.abs(xg-x) + Math.abs(yg-y); } void show(){ for(int i=1; i<w; i++){ for(int k=1; k<h; k++) System.out.print(route[i][k] ? \"\u25a1\":\"\u25a0\"); System.out.println(); } System.out.println(\"----------------\"); } void put(){ xs = sc.nextInt(); ys = sc.nextInt(); xg = sc.nextInt(); yg = sc.nextInt(); n = sc.nextInt();  i<n; i++){ c = sc.nextInt(); d = sc.nextInt();  a++) for(int b=y; b<y+2; b++) block[b][a] = c; else for(int a=x; a<x+2; a++) for(int b=y; b<y+4; b++) block[b][a] = c; } } void makeRoute(){ int tcolor = block[ys][xs]; for(int i=0; i<w; i++) for(int k=0; k<h; k++) if(block[k][i]==tcolor) route[k][i] = true; } }"], "original_ll": -1.0710303783416748, "sampled_ll": -0.4206470251083374, "all_perturbed_sampled_ll": [-1.1975256204605103], "all_perturbed_original_ll": [-1.8321154117584229], "perturbed_sampled_ll": -1.1975256204605103, "perturbed_original_ll": -1.8321154117584229, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "sys.setrecursionlimit(10000) \n\ndef tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal\n    [clx,cly]=cl\n    for i in range(clx-1,clx+2):\n        for j in range(cly-1,cly+2):\n            if [i,j] in nc:\n                nc.remove([i,j])\n                ok.append([i,j])\n                tansaku([i,j],nc,ok,goal)\n\n\nwhile(1):\n    [boardw,boardh]=[int(x) for x in raw_input().split()]\n    if boardw==0 and boardh==0:\n        break\n    else:\n        [startx,starty]=[int(x) for x in raw_input().split()]\n        [goalx,goaly]=[int(x) for x in raw_input().split()]\n        blockn=int(raw_input())\n        blist={1:[],2:[],3:[],4:[],5:[]}\n        startc=-1\n        goalc=-1\n        #mark location of block\n        for i in range(blockn):\n            [c,d,x,y]=[int(x) for x in raw_input().split()]\n            if d: #d=1,tatenaga\n                for xx in range(x,x+2):\n                    for yy in range(y,y+4):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n            else:\n                for xx in range(x,x+4):\n                    for yy in range(y,y+2):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n        if startc==-1 or goalc==-1:\n            print \"NG\"\n        elif startc != goalc:\n            print \"NG\"\n        else:\n            #check if connected\n            cl=[startx,starty]\n            nc=blist[c]\n            nc.remove(cl)\n            ok=[cl]\n            goal=[goalx,goaly]\n            tansaku(cl,nc,ok,goal)\n            if goal in ok:\n                print \"OK\"\n            else:\n                print \"NG\"", "sampled": "from collections import deque\n\ndef solve():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n        \n        xs, ys = map(int, input().split())\n        xg, yg = map(int, input().split())\n        n = int(input())\n        \n        # Create board to store color at each position\n        board = [[0] * (w + 1) for _ in range(h + 1)]\n        \n        for _ in range(n):\n            c, d, x, y = map(int, input().split())\n            if d == 0:  # horizontal (2 height, 4 width)\n                for dy in range(2):\n                    for dx in range(4):\n                        if 1 <= y + dy <= h and 1 <= x + dx <= w:\n                            board[y + dy][x + dx] = c\n            else:  # vertical (4 height, 2 width)\n                for dy in range(4):\n                    for dx in range(2):\n                        if 1 <= y + dy <= h and 1 <= x + dx <= w:\n                            board[y + dy][x + dx] = c\n        \n        # BFS from start to goal\n        start_color = board[ys][xs]\n        if start_color == 0 or board[yg][xg] != start_color:\n            print(\"NG\")\n            continue\n        \n        visited = [[False] * (w + 1) for _ in range(h + 1)]\n        queue = deque([(xs, ys)])\n        visited[ys][xs] = True\n        found = False\n        \n        while queue:\n            x, y = queue.popleft()\n            if x == xg and y == yg:\n                found = True\n                break\n            \n            # Check 4 adjacent cells\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 1 <= nx <= w and 1 <= ny <= h:\n                    if not visited[ny][nx] and board[ny][nx] == start_color:\n                        visited[ny][nx] = True\n                        queue.append((nx, ny))\n        \n        print(\"OK\" if found else \"NG\")\n\nsolve()\n", "perturbed_sampled": ["from collections import deque def solve(): while True: w, h = map(int,  xs, ys =  # Create board to store color at each position board = [[0] * (w  in range(n): c, d, x, y = map(int, input().split()) if  dy in range(2): for dx in range(4): if 1  + dx <= w: board[y + dy][x + dx] = c else: # vertical (4 height, 2  1 <= y + dy <= h and 1 <= x + dx <= w: board[y + dy][x + dx] = c # BFS from start to goal start_color = board[ys][xs] if start_color == 0 or board[yg][xg] != start_color: print(\"NG\") continue visited = [[False] * (w + 1) for _ in range(h + 1)] queue = deque([(xs, ys)]) visited[ys][xs] = True found = False while queue: x, y = queue.popleft() if x == xg and y == yg: found = True break # Check 4 adjacent cells for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]: nx, ny = x + dx, y + dy if 1 <= nx <= w and 1 <= ny <= h: if not visited[ny][nx]  if found else \"NG\") solve()"], "perturbed_original": ["sys.setrecursionlimit(10000) def tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal [clx,cly]=cl for i in range(clx-1,clx+2): for j in range(cly-1,cly+2): if [i,j] in nc: nc.remove([i,j]) ok.append([i,j]) tansaku([i,j],nc,ok,goal) while(1): [boardw,boardh]=[int(x) for x in raw_input().split()] if boardw==0 and boardh==0: break else: [startx,starty]=[int(x) for x in raw_input().split()] [goalx,goaly]=[int(x) for x in raw_input().split()] blockn=int(raw_input()) blist={1:[],2:[],3:[],4:[],5:[]}  [c,d,x,y]=[int(x) for x in raw_input().split()] if d:  if [xx,yy]==[startx,starty]: startc=c if [xx,yy]==[goalx,goaly]: goalc=c else: for xx in range(x,x+4): for yy in range(y,y+2): blist[c].append([xx,yy]) if [xx,yy]==[startx,starty]: startc=c if [xx,yy]==[goalx,goaly]: goalc=c if startc==-1 or goalc==-1: print  connected cl=[startx,starty] nc=blist[c] nc.remove(cl) ok=[cl] goal=[goalx,goaly] tansaku(cl,nc,ok,goal) if goal in ok: print \"OK\" else: print \"NG\""], "original_ll": -1.0870022773742676, "sampled_ll": -0.6240677833557129, "all_perturbed_sampled_ll": [-1.7892475128173828], "all_perturbed_original_ll": [-1.4848040342330933], "perturbed_sampled_ll": -1.7892475128173828, "perturbed_original_ll": -1.4848040342330933, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "long long table[8]={0,1,2,3,5,7,8,9},r;main(n,i){for(;scanf(\"%d\",&n),n;printf(\"%lld\\n\",r))for(r=0,i=1;n;n/=8,i*=10)r+=table[n&7]*i;exit(0);}", "sampled": "#include <stdio.h>\n\nlong long convert(long long n) {\n    long long result = 0;\n    long long base = 1;\n    \n    while (n > 0) {\n        long long digit = n % 10;\n        n /= 10;\n        \n        if (digit >= 4) digit++;\n        if (digit >= 6) digit++;\n        \n        result = digit * base + result;\n        base *= 10;\n    }\n    \n    return result;\n}\n\nlong long solve(long long n) {\n    long long left = 1, right = 10000000000LL;\n    long long answer = 1;\n    \n    while (left <= right) {\n        long long mid = left + (right - left) / 2;\n        long long converted = convert(mid);\n        \n        if (converted == n) {\n            return n;\n        } else if (converted < n) {\n            answer = converted;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return answer;\n}\n\nlong long count_valid(long long n) {\n    if (n == 0) return 0;\n    \n    long long result = 0;\n    long long power = 1;\n    long long temp = n;\n    int digits = 0;\n    \n    while (temp > 0) {\n        digits++;\n        temp /= 10;\n    }\n    \n    for (int d = 1; d < digits; d++) {\n        long long count = 1;\n        for (int i = 0; i < d; i++) {\n            count *= 8;\n        }\n        result += count;\n    }\n    \n    temp = n;\n    long long prefix = 0;\n    for (int pos = digits; pos >= 1; pos--) {\n        long long divisor = 1;\n        for (int i = 1; i < pos; i++) {\n            divisor *= 10;\n        }\n        \n        long long digit = temp / divisor;\n        temp %= divisor;\n        \n        long long count_before = digit;\n        if (digit > 4) count_before--;\n        if (digit > 6) count_before--;\n        \n        long long suffix_count = 1;\n        for (int i = 1; i < pos; i++) {\n            suffix_count *= 8;\n        }\n        \n        result += count_before * suffix_count;\n        \n        if (digit == 4 || digit == 6) {\n            return result;\n        }\n    }\n    \n    result++;\n    return result;\n}\n\nlong long find_nth(long long n) {\n    long long left = 1, right = 10000000000LL;\n    long long answer = 1;\n    \n    while (left <= right) {\n        long long mid = left + (right - left) / 2;\n        long long count = count_valid(mid);\n        \n        if (count == n) {\n            while (mid % 10 == 4 || mid % 10 == 6) {\n                mid--;\n            }\n            long long temp = mid;\n            int has_4_or_6 = 0;\n            while (temp > 0) {\n                int d = temp % 10;\n                if (d == 4 || d == 6) {\n                    has_4_or_6 = 1;\n                    break;\n                }\n                temp /= 10;\n            }\n            if (!has_4_or_6) {\n                return mid;\n            }\n            right = mid - 1;\n        } else if (count < n) {\n            left = mid + 1;\n        } else {\n            answer = mid;\n            right = mid - 1;\n        }\n    }\n    \n    while (left <= 10000000000LL) {\n        long long count = count_valid(left);\n        if (count == n) {\n            long long temp = left;\n            int has_4_or_6 = 0;\n            while (temp > 0) {\n                int d = temp % 10;\n                if (d == 4 || d == 6) {\n                    has_4_or_6 = 1;\n                    break;\n                }\n                temp /= 10;\n            }\n            if (!has_4_or_6) {\n                return left;\n            }\n        }\n        left++;\n    }\n    \n    return answer;\n}\n\nint main() {\n    long long n;\n    while (scanf(\"%lld\", &n) == 1 && n != 0) {\n        printf(\"%lld\\n\", find_nth(n));\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include  > 0) { long long digit = n % 10; n /= 10; if (digit >= 4) digit++; if (digit >= 6) digit++; result = digit * base + result; base *= 10; } return result; } long long solve(long long n) { long long left = 1, right = 10000000000LL; long  2; long long converted = convert(mid); if (converted == n) { return n; } else if (converted < n) { answer = converted; left = mid + 1; } else { right = mid - 1; } } return answer; } long long count_valid(long long n) { if (n == 0) return 0; long long  temp = n; int digits =  } for (int d = 1; d < digits; d++) { long long count = 1; for (int i = 0; i < d; i++) { count *= 8; } result  0; for (int pos = digits; pos >= 1; pos--) {  i < pos; i++) { divisor *= 10; } long long digit = temp / divisor; temp %= divisor; long long count_before  6) count_before--; long long suffix_count = 1; for (int i = 1; i < pos;  suffix_count; if (digit == 4 || digit == 6) { return result; } } result++; return result; } long long find_nth(long long n) { long long left = 1, right = 10000000000LL; long long answer = 1; while (left <= right) { long long mid = left +  if (count == n) { while (mid % 10 == 4 || mid % 10 == 6) { mid--; } long long temp = mid; int has_4_or_6 =  6) { has_4_or_6 = 1; break; }  right = mid - 1; } else if (count < n) { left = mid + 1; } else { answer = mid; right = mid - 1; } } while (left <= 10000000000LL) { long long count = count_valid(left); if (count == n) { long long temp = left; int has_4_or_6 = 0; while (temp > 0) { int d = temp % 10; if (d == 4 || d == 6) { has_4_or_6 = 1; break; } temp /= 10; } if (!has_4_or_6) { return left;  long long n; while (scanf(\"%lld\", &n) == 1 && n != 0) { printf(\"%lld\\n\", find_nth(n)); } return 0; }"], "perturbed_original": ["long long table[8]={0,1,2,3,5,7,8,9},r;main(n,i){for(;scanf(\"%d\",&n),n;printf(\"%lld\\n\",r))for(r=0,i=1;n;n/=8,i*=10)r+=table[n&7]*i;exit(0);}"], "original_ll": -2.177025079727173, "sampled_ll": -0.5175026655197144, "all_perturbed_sampled_ll": [-1.2135719060897827], "all_perturbed_original_ll": [-2.177025079727173], "perturbed_sampled_ll": -1.2135719060897827, "perturbed_original_ll": -2.177025079727173, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nimport java.util.regex.Pattern;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tPattern pattern = Pattern.compile(\"^4|^6\");\n\t\tPattern pattern2 = Pattern.compile(\".*4.*|.*6.*\");\n\n\t\twhile(true){\n\t\t\tlong oldNumber = stdIn.nextLong();\n\t\t\tlong newNumber = 0;\n\n\t\t\tif(oldNumber == 0){break;}\n\n\t\t\tint count = 0;\n\t\t\twhile(count < oldNumber){\n\t\t\t\tnewNumber++;\n\t\t\t\tString stringNewNumber = Long.toString(newNumber);\n\t\t\t\tif(pattern.matcher(stringNewNumber).find()){\n\t\t\t\t\tnewNumber += Math.pow(10, stringNewNumber.length()-1);\n\t\t\t\t}else if(pattern2.matcher(stringNewNumber).find()){\n\t\t\t\t\twhile(pattern2.matcher(Long.toString(newNumber)).find()){\n\t\t\t\t\t\tnewNumber++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tSystem.out.println(newNumber);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long n = sc.nextLong();\n            if (n == 0) break;\n            \n            System.out.println(convertToNewRoomNumber(n));\n        }\n        \n        sc.close();\n    }\n    \n    static long convertToNewRoomNumber(long oldNumber) {\n        long result = 0;\n        long multiplier = 1;\n        long remaining = oldNumber;\n        \n        while (remaining > 0) {\n            long digit = remaining % 10;\n            remaining /= 10;\n            \n            // Map digit to new system (base 8 excluding 4 and 6)\n            // 0->0, 1->1, 2->2, 3->3, 4->5, 5->7, 6->8, 7->9\n            long mappedDigit;\n            if (digit <= 3) {\n                mappedDigit = digit;\n            } else if (digit == 4) {\n                mappedDigit = 5;\n            } else if (digit == 5) {\n                mappedDigit = 7;\n            } else if (digit == 6) {\n                mappedDigit = 8;\n            } else {\n                mappedDigit = 9;\n            }\n            \n            result += mappedDigit * multiplier;\n            multiplier *= 10;\n        }\n        \n        return result;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { long  sc.close(); } static long convertToNewRoomNumber(long oldNumber) { long result = 0; long multiplier = 1; long remaining = oldNumber; while (remaining > 0) { long digit = remaining % 10; remaining /=  4  7->9 long mappedDigit; if (digit <= 3) { mappedDigit = digit; } else if (digit == 4) { mappedDigit = 5; } else if (digit == 5)  { mappedDigit = 8; } else { mappedDigit = 9; } result += mappedDigit * multiplier; multiplier *= 10; } return result; } }"], "perturbed_original": ["import java.util.Scanner; import java.util.regex.Pattern; class Main{ public static void main(String[] args){ Scanner stdIn = new Scanner(System.in); Pattern pattern = Pattern.compile(\"^4|^6\"); Pattern pattern2 = Pattern.compile(\".*4.*|.*6.*\"); while(true){ long oldNumber = stdIn.nextLong(); long newNumber = 0; if(oldNumber == 0){break;} int count = 0; while(count < oldNumber){ newNumber++; String stringNewNumber = Long.toString(newNumber); if(pattern.matcher(stringNewNumber).find()){ newNumber += Math.pow(10,  } } }"], "original_ll": -0.9945505261421204, "sampled_ll": -0.6980358362197876, "all_perturbed_sampled_ll": [-1.508340835571289], "all_perturbed_original_ll": [-1.486871600151062], "perturbed_sampled_ll": -1.508340835571289, "perturbed_original_ll": -1.486871600151062, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def testcase_ends():\n    n = int(input())\n    if n == 0:\n        return 1\n\n    n = oct(n)[2:]\n    n = n.replace('7', '9')\n    n = n.replace('6', '8')\n    n = n.replace('5', '7')\n    n = n.replace('4', '5')\n    print(n)\n    return 0\n\ndef main():\n    while not testcase_ends():\n        pass\n\nif __name__ == '__main__':\n    main()\n\n", "sampled": "def convert_to_new_room(n):\n    # Convert n to base-8 representation, treating digits 0-7 as valid\n    # Then map: 0->1, 1->2, 2->3, 3->5, 4->7, 5->8, 6->9, 7->10\n    # This is essentially converting to a number system without 4 and 6\n    \n    # First, convert n to base 8\n    if n == 0:\n        return 0\n    \n    result = 0\n    multiplier = 1\n    temp_n = n\n    \n    while temp_n > 0:\n        digit = temp_n % 8\n        temp_n //= 8\n        \n        # Map the digit (0-7 in base 8 concept) to actual digit without 4 and 6\n        # digit 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 5, 4 -> 7, 5 -> 8, 6 -> 9, 7 -> 10\n        if digit == 0:\n            mapped = 1\n        elif digit == 1:\n            mapped = 2\n        elif digit == 2:\n            mapped = 3\n        elif digit == 3:\n            mapped = 5\n        elif digit == 4:\n            mapped = 7\n        elif digit == 5:\n            mapped = 8\n        elif digit == 6:\n            mapped = 9\n        else:  # digit == 7\n            mapped = 10\n        \n        result += mapped * multiplier\n        multiplier *= 10\n    \n    return result\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(convert_to_new_room(n))\n", "perturbed_sampled": [" 0-7 as valid # Then map: 0->1, 1->2, 2->3, 3->5, 4->7, 5->8, 6->9, 7->10 # This is essentially converting to a number system without 4 and 6 # First, convert n to base 8 if n  temp_n = n while temp_n > 0: digit = temp_n % 8 temp_n //= 8 # Map the digit (0-7 in base 8 concept) to actual digit without 4 and 6 # digit 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 5, 4  10 if digit == 0: mapped = 1 elif digit == 1: mapped = 2 elif digit == 2: mapped = 3 elif digit == 3: mapped = 5 elif digit == 4: mapped = 7 elif digit == 5: mapped = 8 elif digit == 6: mapped = 9 else: # digit ==  if n == 0: break print(convert_to_new_room(n))"], "perturbed_original": ["def testcase_ends(): n = int(input()) if n == 0: return 1 n = oct(n)[2:]  n.replace('5', '7') n = n.replace('4', '5') print(n) return 0 def main(): while not testcase_ends(): pass if __name__ == '__main__': main()"], "original_ll": -1.3329813480377197, "sampled_ll": -0.8546311259269714, "all_perturbed_sampled_ll": [-1.6771485805511475], "all_perturbed_original_ll": [-2.224860906600952], "perturbed_sampled_ll": -1.6771485805511475, "perturbed_original_ll": -2.224860906600952, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\n\ntypedef struct{\n  int x;\n  int y;\n  int ny;\n  int nx;\n  char dir;\n  int movable;\n}man;\ntypedef struct{\n  int x;\n  int y;\n}d;\n\nchar map[30][31];\nint w,h;\nman ms[900];\nint msize;\nd dir[4]={{1,0},{0,-1},{-1,0},{0,1}};\n//memo 0:east 1:north 2:west 3:south\nchar n2d(int d){\n  return d==0?'E':d==1?'N':d==2?'W':'S';\n}\nint d2n(char d){\n  return d=='E'?0:d=='N'?1:d=='W'?2:d=='S'?3:-1;\n}\nint main(){\n  int i,j,l,k,nx,ny;\n  do{\n    scanf(\"%d %d\",&w,&h);\n    if(w==0&&h==0) break;\n    msize=0;\n    for(i=0;i<h;i++){      \n      scanf(\"%s\",map+i);\n      for(j=0;j<w;j++){\n\tif(map[i][j]!='#'&&map[i][j]!='.'&&map[i][j]!='X'){\n\t  ms[msize].x=j;\n\t  ms[msize].y=i;\n\t  ms[msize].dir=d2n(map[i][j]);\n\t  msize++;\n\t}\n      }\n    }\n    for(i=1;i<181;i++){\n      /*            for(j=0;j<h;j++)\n\tprintf(\"%s\\n\",map+j);\n\tprintf(\"\\n\");*/\n      for(j=0;j<msize;j++){\n\tms[j].movable=0;\n\tfor(k=-1;k<3;k++){\n\t  ms[j].nx=ms[j].x+dir[(4+ms[j].dir+k)%4].x;\n\t  ms[j].ny=ms[j].y+dir[(4+ms[j].dir+k)%4].y;\n\t  if(map[ms[j].ny][ms[j].nx]=='X'){\n\t    ms[j].movable=1;\n\t    break;\t    \n\t  }else if(map[ms[j].ny][ms[j].nx]=='.'){\n\t    ms[j].dir=(4+ms[j].dir+k)%4;\n\t    ms[j].movable=1;\n\t    break;\n\t  }\t  \n\t}\n      }\n      for(j=0;j<msize;j++){\n\tif(map[ms[j].ny][ms[j].nx]!='X'&&ms[j].movable)\n\t  for(k=0;k<4;k++){\n\t    nx=ms[j].nx+dir[k].x;\n\t    ny=ms[j].ny+dir[k].y;\n\t    //\t    printf(\"(%d %d %c) \",ny,nx,map[ny][nx]);\n\t    if(isalpha(map[ny][nx])\n\t       &&map[ny][nx]!='X'\n\t       &&((d2n(map[ny][nx])+2)%4)==k){\n//\t      printf(\"%d %d %c\\n\",ny,nx,map[ny][nx]);\n\t      if(ms[j].x!=nx||ms[j].y!=ny){\n\t\tms[j].movable=0;\t\t\n\t      }\n\t      break;\n\t    }else if(ms[j].x==nx&&ms[j].y==ny){\n\t      map[ms[j].y][ms[j].x]=n2d(ms[j].dir);\n\t      break;\n\t    }\n\t  }\n\t//\tprintf(\"\\n\");\n      }\n      for(j=0;j<msize;j++){\n\tif(map[ms[j].ny][ms[j].nx]=='X'){\n\t  map[ms[j].y][ms[j].x]='.';\n\t  for(l=j;l<msize;l++){\n\t    ms[l]=ms[l+1];\n\t  }\t    \n\t  j--;\n\t  msize--;\n\t}else if(ms[j].movable){\n\t  map[ms[j].y][ms[j].x]='.';\n\t  map[ms[j].ny][ms[j].nx]=n2d(ms[j].dir);\n\t  ms[j].x=ms[j].nx;\n\t  ms[j].y=ms[j].ny;\n\t}\n      }\n      if(msize==0){\n\tprintf(\"%d\\n\",i);\n\tbreak;\n      }\n    }\n    if(i==181)\n      printf(\"NA\\n\");\n  }while(1);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 30\n\ntypedef struct {\n    int x, y;\n    char dir;\n} Person;\n\nchar grid[MAX][MAX];\nint W, H;\nPerson people[MAX*MAX];\nint num_people;\n\nint dx[] = {1, 0, -1, 0}; // E, N, W, S\nint dy[] = {0, -1, 0, 1};\nchar dirs[] = \"ENWS\";\n\nint get_dir_idx(char d) {\n    for(int i = 0; i < 4; i++) {\n        if(dirs[i] == d) return i;\n    }\n    return 0;\n}\n\nint is_passable(int x, int y) {\n    if(x < 0 || x >= W || y < 0 || y >= H) return 0;\n    return grid[y][x] == '.' || grid[y][x] == 'X';\n}\n\nvoid simulate() {\n    int time = 0;\n    \n    while(num_people > 0 && time <= 180) {\n        time++;\n        \n        // Step 1: Change direction\n        for(int i = 0; i < num_people; i++) {\n            int dir_idx = get_dir_idx(people[i].dir);\n            int found = 0;\n            \n            // Check right, front, left, back\n            int order[] = {(dir_idx + 3) % 4, dir_idx, (dir_idx + 1) % 4, (dir_idx + 2) % 4};\n            \n            for(int j = 0; j < 4; j++) {\n                int d = order[j];\n                int nx = people[i].x + dx[d];\n                int ny = people[i].y + dy[d];\n                \n                if(is_passable(nx, ny)) {\n                    people[i].dir = dirs[d];\n                    found = 1;\n                    break;\n                }\n            }\n        }\n        \n        // Step 2: Move\n        int target_count[MAX][MAX];\n        int target_who[MAX][MAX][4];\n        memset(target_count, 0, sizeof(target_count));\n        \n        for(int i = 0; i < num_people; i++) {\n            int dir_idx = get_dir_idx(people[i].dir);\n            int nx = people[i].x + dx[dir_idx];\n            int ny = people[i].y + dy[dir_idx];\n            \n            if(is_passable(nx, ny)) {\n                target_who[ny][nx][target_count[ny][nx]++] = i;\n            }\n        }\n        \n        int moved[MAX*MAX];\n        memset(moved, 0, sizeof(moved));\n        \n        for(int y = 0; y < H; y++) {\n            for(int x = 0; x < W; x++) {\n                if(target_count[y][x] > 1) {\n                    // Multiple people want this spot\n                    // Priority: E, N, W, S of the target\n                    int priority_order[] = {0, 1, 2, 3}; // E, N, W, S\n                    int selected = -1;\n                    \n                    for(int p = 0; p < 4; p++) {\n                        int check_x = x - dx[priority_order[p]];\n                        int check_y = y - dy[priority_order[p]];\n                        \n                        for(int k = 0; k < target_count[y][x]; k++) {\n                            int who = target_who[y][x][k];\n                            if(people[who].x == check_x && people[who].y == check_y) {\n                                selected = who;\n                                break;\n                            }\n                        }\n                        if(selected != -1) break;\n                    }\n                    \n                    if(selected != -1) {\n                        moved[selected] = 1;\n                    }\n                } else if(target_count[y][x] == 1) {\n                    moved[target_who[y][x][0]] = 1;\n                }\n            }\n        }\n        \n        // Apply moves\n        for(int i = 0; i < num_people; i++) {\n            if(moved[i]) {\n                int dir_idx = get_dir_idx(people[i].dir);\n                people[i].x += dx[dir_idx];\n                people[i].y += dy[dir_idx];\n            }\n        }\n        \n        // Remove people at exits\n        int new_num = 0;\n        for(int i = 0; i < num_people; i++) {\n            if(grid[people[i].y][people[i].x] != 'X') {\n                people[new_num++] = people[i];\n            }\n        }\n        num_people = new_num;\n    }\n    \n    if(num_people == 0) {\n        printf(\"%d\\n\", time);\n    } else {\n        printf(\"NA\\n\");\n    }\n}\n\nint main() {\n    while(1) {\n        scanf(\"%d %d\", &W, &H);\n        if(W == 0 && H == 0) break;\n        \n        num_people = 0;\n        for(int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n            for(int j = 0; j < W; j++) {\n                if(grid[i][j] == 'E' || grid[i][j] == 'N' || \n                   grid[i][j] == 'W' || grid[i][j] == 'S') {\n                    people[num_people].x = j;\n                    people[num_people].y = i;\n                    people[num_people].dir = grid[i][j];\n                    num_people++;\n                    grid[i][j] = '.';\n                }\n            }\n        }\n        \n        simulate();\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #define MAX 30 typedef struct { int x, y; char dir; } Person; char grid[MAX][MAX]; int W, H; Person people[MAX*MAX]; int num_people; int dx[] = {1, 0, -1, 0}; //  1}; char dirs[] = \"ENWS\"; int get_dir_idx(char d) { for(int i = 0;  y < 0 || y >=  'X'; } void simulate() { int time = 0; while(num_people > 0 && time <= 180) { time++; //  num_people; i++) { int dir_idx = get_dir_idx(people[i].dir); int found = 0; // Check right, front, left, back int order[] = {(dir_idx + 3) % 4, dir_idx, (dir_idx + 1) % 4, (dir_idx + 2) % 4}; for(int j = 0; j < 4;  + dx[d]; int ny = people[i].y + dy[d]; if(is_passable(nx, ny)) { people[i].dir = dirs[d]; found = 1; break; } } } // Step 2: Move int target_count[MAX][MAX]; int target_who[MAX][MAX][4]; memset(target_count, 0, sizeof(target_count)); for(int i = 0; i < num_people; i++) { int dir_idx = get_dir_idx(people[i].dir); int nx =  ny)) { target_who[ny][nx][target_count[ny][nx]++] = i; } } int moved[MAX*MAX]; memset(moved, 0, sizeof(moved)); for(int y = 0; y <  x++) { if(target_count[y][x] >  E, N, W, S of the target int priority_order[] = {0, 1, 2, 3}; // E, N, W, S int selected = -1; for(int p = 0; p < 4; p++) { int check_x = x - dx[priority_order[p]]; int check_y = y - dy[priority_order[p]]; for(int k = 0; k < target_count[y][x]; k++) { int who = target_who[y][x][k]; if(people[who].x == check_x && people[who].y == check_y) { selected = who; break; } } if(selected != -1) break; } if(selected != -1) { moved[selected] = 1; } } else if(target_count[y][x] == 1) { moved[target_who[y][x][0]] = 1; } } } // Apply moves for(int i = 0; i < num_people;   people[new_num++] = people[i]; } } num_people = new_num; } if(num_people == 0) { printf(\"%d\\n\", time); } else { printf(\"NA\\n\"); } } int main() { while(1) { scanf(\"%d %d\", &W, &H); if(W ==  i = 0; i < H; i++) { scanf(\"%s\", grid[i]); for(int j = 0; j < W; j++) { if(grid[i][j] == 'E' || grid[i][j] == 'N' || grid[i][j] == 'W' || grid[i][j] == 'S') { people[num_people].x = j; people[num_people].y = i; people[num_people].dir = grid[i][j]; num_people++; grid[i][j] = '.'; } } } simulate(); } return 0; }"], "perturbed_original": ["#include<stdio.h> typedef struct{ int x; int y; int ny; int nx; char dir; int movable; }man; typedef struct{ int x; int y; }d; char map[30][31]; int w,h; man ms[900]; int msize; d dir[4]={{1,0},{0,-1},{-1,0},{0,1}}; //memo 0:east 1:north 2:west 3:south char n2d(int d){ return d==0?'E':d==1?'N':d==2?'W':'S'; } int d2n(char d){ return d=='E'?0:d=='N'?1:d=='W'?2:d=='S'?3:-1; } int main(){ int i,j,l,k,nx,ny; do{ scanf(\"%d %d\",&w,&h); if(w==0&&h==0)  } } } for(i=1;i<181;i++){ /* for(j=0;j<h;j++) printf(\"%s\\n\",map+j); printf(\"\\n\");*/ for(j=0;j<msize;j++){ ms[j].movable=0; for(k=-1;k<3;k++){ ms[j].nx=ms[j].x+dir[(4+ms[j].dir+k)%4].x; ms[j].ny=ms[j].y+dir[(4+ms[j].dir+k)%4].y;  } for(j=0;j<msize;j++){ if(map[ms[j].ny][ms[j].nx]!='X'&&ms[j].movable) for(k=0;k<4;k++){ nx=ms[j].nx+dir[k].x; ny=ms[j].ny+dir[k].y; // printf(\"(%d %d %c) \",ny,nx,map[ny][nx]); if(isalpha(map[ny][nx]) &&map[ny][nx]!='X' &&((d2n(map[ny][nx])+2)%4)==k){ // printf(\"%d %d %c\\n\",ny,nx,map[ny][nx]); if(ms[j].x!=nx||ms[j].y!=ny){ ms[j].movable=0; } break; }else if(ms[j].x==nx&&ms[j].y==ny){ map[ms[j].y][ms[j].x]=n2d(ms[j].dir);  ms[l]=ms[l+1]; } j--;  printf(\"%d\\n\",i); break; } } if(i==181) printf(\"NA\\n\"); }while(1); return 0; }"], "original_ll": -0.9181114435195923, "sampled_ll": -0.5872248411178589, "all_perturbed_sampled_ll": [-1.320173740386963], "all_perturbed_original_ll": [-1.301052212715149], "perturbed_sampled_ll": -1.320173740386963, "perturbed_original_ll": -1.301052212715149, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n\tint [] vx = {1,0,-1,0};\n\tint [] vy = {0,-1,0,1};\n\tboolean [] isgoal;\n\t\n\tclass C{\n\t\tint x,y,dir;\n\t\tpublic C(int x, int y, int dir) {\n\t\t\tthis.x = x;this.y = y;\n\t\t\tif(dir == 'E')\n\t\t\t\tdir = 0;\n\t\t\telse if(dir == 'N')\n\t\t\t\tdir = 1;\n\t\t\telse if(dir == 'S')\n\t\t\t\tdir = 3;\n\t\t\telse if(dir == 'W')\n\t\t\t\tdir = 2;\n\t\t\telse{\n\t\t\t\t\n\t\t\t}\n\t\t\tthis.dir = dir;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", dir=\" + dir + \"]\";\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tchar [][] map = new char[h][w];\n\t\t\tArrayList<C> humlist = new ArrayList<C>();\n\t\t\tfor(int i=0; i < h;i++){\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=0; j < w;j++){\n\t\t\t\t\tchar c = line.charAt(j);\n\t\t\t\t\tif(c == 'E' || c == 'N' || c == 'W' || c == 'S'){\n\t\t\t\t\t\thumlist.add(new C(j,i,(int)c));\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[i][j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//debug\n//\t\t\tfor(int i=0; i < h; i++){\n//\t\t\t\tfor(int j = 0; j < w; j++){\n//\t\t\t\t\tSystem.out.print(map[i][j]);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\tSystem.out.println(\"list= \" + humlist.toString());\n\t\t\tint step = 0;\n\t\t\tLinkedList<Integer> open = new LinkedList<Integer>();\n\t\t\topen.add(step);\n\t\t\tint len = humlist.size();\n\t\t\tisgoal = new boolean[len];\n\t\t\tboolean isachieve = true;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tstep = open.removeFirst();\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(humlist.toString());\n\t\t\t\t//change dir\n\t\t\t\tfor(int i = 0; i < len;i++){\n\t\t\t\t\tif(isgoal[i])continue;\n\t\t\t\t\tC nowhum = humlist.get(i);\n\t\t\t\t\tint nowdir = nowhum.dir;\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tnowdir = (j + 4 + nowhum.dir - 1) % 4;\n\t\t\t\t\t\tint xx = nowhum.x + vx[nowdir];\n\t\t\t\t\t\tint yy = nowhum.y + vy[nowdir];\n\t\t\t\t\t\tif(map[yy][xx] == '#') continue;\n\t\t\t\t\t\tif((map[yy][xx] == 'X' || map[yy][xx] == '.') && ! isin(xx,yy,humlist)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnowhum.dir = nowdir;\n\t\t\t\t\thumlist.set(i, nowhum);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//move\n\t\t\t\tArrayList<C> humlistrecord = valueC(humlist);\n\t\t\t\tfor(int i=0; i < len; i++){\n\t\t\t\t\tif(isgoal[i]) continue;\n\t\t\t\t\tC nowhum = humlist.get(i);\n\t\t\t\t\tint xx = nowhum.x + vx[nowhum.dir];\n\t\t\t\t\tint yy = nowhum.y + vy[nowhum.dir];\n\t\t\t\t\tif(map[yy][xx] == '#' || isin(xx,yy,humlist)) continue;\n\t\t\t\t\tint movehum = getmove(xx,yy,humlistrecord);\n\t\t\t\t\tif(movehum == i){\n\t\t\t\t\t\tnowhum.x = xx;\n\t\t\t\t\t\tnowhum.y = yy;\n\t\t\t\t\t\thumlist.set(i, nowhum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//escape\n\t\t\t\tfor(int i = 0; i < len;i++){\n\t\t\t\t\tC nowhum = humlist.get(i);\n\t\t\t\t\tint humx = nowhum.x,humy = nowhum.y;\n\t\t\t\t\tif(map[humy][humx] == 'X'){\n\t\t\t\t\t\tisgoal[i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//fin\n\t\t\t\tif(isAllGoal()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(step + 1 > 180){\n\t\t\t\t\tisachieve = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\topen.add(step + 1);\n\t\t\t}\n\t\t\tif(isachieve){\n\t\t\t\tif(humlist.size() == 0){\n\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(step + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean isAllGoal(){\n\t\tfor(int i=0; i < isgoal.length;i++){\n\t\t\tif(! isgoal[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate int getmove(int x, int y, ArrayList<C> list){\n\t\tfor(int i=0; i < 4;i++){\n\t\t\tint xx = x + vx[i];\n\t\t\tint yy = y + vy[i];\n\t\t\tfor(int j=0; j < list.size(); j++){\n\t\t\t\tif(isgoal[j])continue;\n\t\t\t\tC now = list.get(j);\n\t\t\t\tboolean cond1 = (xx == now.x && yy == now.y);\n\t\t\t\tboolean cond2 = ((now.x + vx[now.dir]) == x && (now.y + vy[now.dir]) == y);\n\t\t\t\tif(cond1 && cond2){\n\t\t\t\t\treturn j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprivate ArrayList<C> valueC(ArrayList<C> list){\n\t\tArrayList<C> res =  new ArrayList<C>();\n\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\tC now = list.get(i);\n\t\t\tres.add(new C(now.x, now.y, now.dir));\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tprivate boolean isin(int x, int y,ArrayList<C> list){\n\t\tfor(int i=0; i < list.size();i++){\n\t\t\tif(isgoal[i])continue;\n\t\t\tC now = list.get(i);\n\t\t\tif(now.x == x && now.y == y){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Person {\n        int x, y;\n        char dir;\n        \n        Person(int x, int y, char dir) {\n            this.x = x;\n            this.y = y;\n            this.dir = dir;\n        }\n    }\n    \n    static int[] dx = {1, 0, -1, 0}; // E, N, W, S\n    static int[] dy = {0, -1, 0, 1};\n    static Map<Character, Integer> dirMap = new HashMap<>();\n    \n    static {\n        dirMap.put('E', 0);\n        dirMap.put('N', 1);\n        dirMap.put('W', 2);\n        dirMap.put('S', 3);\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\" \");\n            int W = Integer.parseInt(parts[0]);\n            int H = Integer.parseInt(parts[1]);\n            \n            if (W == 0 && H == 0) break;\n            \n            char[][] grid = new char[H][W];\n            List<Person> people = new ArrayList<>();\n            \n            for (int i = 0; i < H; i++) {\n                String str = br.readLine();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = str.charAt(j);\n                    if (dirMap.containsKey(grid[i][j])) {\n                        people.add(new Person(j, i, grid[i][j]));\n                        grid[i][j] = '.';\n                    }\n                }\n            }\n            \n            int result = simulate(grid, people, W, H);\n            if (result > 180) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n    }\n    \n    static int simulate(char[][] grid, List<Person> people, int W, int H) {\n        int time = 0;\n        \n        while (!people.isEmpty() && time <= 180) {\n            time++;\n            \n            // Step 1: Update directions\n            for (Person p : people) {\n                int currentDir = dirMap.get(p.dir);\n                int[] checkOrder = {(currentDir + 3) % 4, currentDir, (currentDir + 1) % 4, (currentDir + 2) % 4};\n                \n                for (int d : checkOrder) {\n                    int nx = p.x + dx[d];\n                    int ny = p.y + dy[d];\n                    \n                    if (nx >= 0 && nx < W && ny >= 0 && ny < H && \n                        (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) {\n                        p.dir = getDir(d);\n                        break;\n                    }\n                }\n            }\n            \n            // Step 2: Determine moves\n            Map<String, List<Person>> targetMap = new HashMap<>();\n            \n            for (Person p : people) {\n                int d = dirMap.get(p.dir);\n                int nx = p.x + dx[d];\n                int ny = p.y + dy[d];\n                \n                if (nx >= 0 && nx < W && ny >= 0 && ny < H && \n                    (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) {\n                    String key = nx + \",\" + ny;\n                    targetMap.putIfAbsent(key, new ArrayList<>());\n                    targetMap.get(key).add(p);\n                }\n            }\n            \n            // Step 3: Move people\n            Set<Person> toRemove = new HashSet<>();\n            \n            for (String key : targetMap.keySet()) {\n                List<Person> candidates = targetMap.get(key);\n                \n                if (candidates.size() == 1) {\n                    Person p = candidates.get(0);\n                    String[] coords = key.split(\",\");\n                    p.x = Integer.parseInt(coords[0]);\n                    p.y = Integer.parseInt(coords[1]);\n                    \n                    if (grid[p.y][p.x] == 'X') {\n                        toRemove.add(p);\n                    }\n                } else {\n                    // Priority: E, N, W, S (by position of source)\n                    Person selected = null;\n                    int[] priority = {0, 1, 2, 3}; // E, N, W, S\n                    \n                    for (int pri : priority) {\n                        for (Person p : candidates) {\n                            int d = dirMap.get(p.dir);\n                            if (d == pri) {\n                                selected = p;\n                                break;\n                            }\n                        }\n                        if (selected != null) break;\n                    }\n                    \n                    if (selected != null) {\n                        String[] coords = key.split(\",\");\n                        selected.x = Integer.parseInt(coords[0]);\n                        selected.y = Integer.parseInt(coords[1]);\n                        \n                        if (grid[selected.y][selected.x] == 'X') {\n                            toRemove.add(selected);\n                        }\n                    }\n                }\n            }\n            \n            people.removeAll(toRemove);\n        }\n        \n        return time;\n    }\n    \n    static char getDir(int d) {\n        switch (d) {\n            case 0: return 'E';\n            case 1: return 'N';\n            case 2: return 'W';\n            case 3: return 'S';\n        }\n        return 'E';\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import  dir) { this.x = x; this.y = y; this.dir = dir; }  E, N,  static Map<Character, Integer> dirMap = new HashMap<>(); static { dirMap.put('E', 0); dirMap.put('N', 1); dirMap.put('W', 2); dirMap.put('S', 3); } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line;  line.trim().split(\" \"); int W = Integer.parseInt(parts[0]); int H = Integer.parseInt(parts[1]); if (W == 0 && H == 0) break; char[][]  String str = br.readLine(); for (int j = 0; j < W; j++) { grid[i][j] =  '.'; } } } int result = simulate(grid, people, W, H); if (result > 180) { System.out.println(\"NA\"); } else { System.out.println(result); } } } static int simulate(char[][] grid, List<Person> people, int W, int H) { int time = 0; while (!people.isEmpty() && time <= 180) { time++; // Step 1: Update directions for (Person p : people) { int currentDir = dirMap.get(p.dir); int[] checkOrder = {(currentDir + 3) % 4, currentDir, (currentDir + 1) % 4, (currentDir + 2) % 4}; for (int d : checkOrder) { int nx = p.x + dx[d]; int ny = p.y + dy[d]; if  0 && ny < H && (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) { p.dir = getDir(d); break; } } } // Step 2: Determine moves Map<String, List<Person>> targetMap = new HashMap<>(); for (Person p : people) { int d  = p.y + dy[d]; if (nx >= 0 && nx < W && ny >= 0 && ny < H && (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) { String key = nx + \",\" + ny;  : targetMap.keySet()) { List<Person> candidates  candidates.get(0); String[] coords = key.split(\",\"); p.x = Integer.parseInt(coords[0]); p.y = Integer.parseInt(coords[1]); if (grid[p.y][p.x] == 'X') { toRemove.add(p); } } else { // Priority: E, N, W, S (by position of source) Person selected = null; int[] priority = {0, 1, 2, 3}; // E, N, W, S for (int pri : priority) { for (Person p : candidates) { int d = dirMap.get(p.dir); if (d == pri) { selected = p; break; } } if (selected != null) break; } if (selected !=  = Integer.parseInt(coords[1]); if (grid[selected.y][selected.x] == 'X') { toRemove.add(selected); } } } } people.removeAll(toRemove); } return  case 0: return 'E'; case 1: return 'N'; case  } }"], "perturbed_original": ["import java.util.*; public class Main { int [] vx = {1,0,-1,0}; int [] vy = {0,-1,0,1}; boolean [] isgoal; class C{ int x,y,dir; public C(int x, int y, int dir) { this.x = x;this.y = y; if(dir == 'E') dir = 0; else if(dir == 'N') dir = 1; else if(dir  = 2; else{ }  [x=\" + x + \", y=\" + y + \", dir=\" + dir + \"]\"; } } private void doit(){ Scanner sc=new Scanner(System.in); while(true){ int w = sc.nextInt(),  = new char[h][w]; ArrayList<C> humlist = new ArrayList<C>(); for(int i=0; i < h;i++){ String line =  if(c == 'E' || c == 'N' || c == 'W' || c == 'S'){ humlist.add(new C(j,i,(int)c)); map[i][j] = '.'; } else{ map[i][j] = c; } }  // for(int j = 0; j < w; j++){ // System.out.print(map[i][j]); // } // System.out.println(); // } // System.out.println(); // System.out.println(\"list= \" + humlist.toString()); int step = 0; LinkedList<Integer> open  new boolean[len]; boolean isachieve = true; while(! open.isEmpty()){ step = open.removeFirst(); //debug //System.out.println(humlist.toString()); //change dir for(int i = 0; i < len;i++){ if(isgoal[i])continue; C nowhum  j < 4; j++){ nowdir = (j + 4 + nowhum.dir - 1) % 4; int xx = nowhum.x + vx[nowdir]; int yy = nowhum.y + vy[nowdir]; if(map[yy][xx]  && ! isin(xx,yy,humlist)){ break; } } nowhum.dir = nowdir; humlist.set(i, nowhum);  len; i++){ if(isgoal[i]) continue; C nowhum = humlist.get(i); int xx = nowhum.x + vx[nowhum.dir]; int yy = nowhum.y + vy[nowhum.dir]; if(map[yy][xx] == '#' || isin(xx,yy,humlist)) continue; int movehum = getmove(xx,yy,humlistrecord); if(movehum ==  C nowhum = humlist.get(i); int humx = nowhum.x,humy = nowhum.y; if(map[humy][humx] == 'X'){ isgoal[i] = true; } } //fin if(isAllGoal()){ break; } if(step + 1 > 180){ isachieve  == 0){ System.out.println(0); } else{ System.out.println(step + 1); } } else{ System.out.println(\"NA\"); } } } private boolean isAllGoal(){  return true; } private int getmove(int x, int y, ArrayList<C> list){ for(int i=0; i < 4;i++){ int xx = x + vx[i]; int yy = y + vy[i]; for(int  boolean cond1 = (xx == now.x && yy == now.y); boolean cond2 = ((now.x + vx[now.dir]) == x && (now.y + vy[now.dir]) == y); if(cond1 && cond2){ return j;  ArrayList<C> res = new ArrayList<C>(); for(int i  boolean isin(int x, int y,ArrayList<C> list){ for(int i=0; i < list.size();i++){ if(isgoal[i])continue; C now = list.get(i); if(now.x == x && now.y == y){ return true; } } return false; } public static void main(String[] args) { Main obj = new Main(); obj.doit(); } }"], "original_ll": -0.7980371117591858, "sampled_ll": -0.49809587001800537, "all_perturbed_sampled_ll": [-1.3527570962905884], "all_perturbed_original_ll": [-1.5751632452011108], "perturbed_sampled_ll": -1.3527570962905884, "perturbed_original_ll": -1.5751632452011108, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\ndirection = {'N' : 0, 'E' : 1, 'S' : 2, 'W' : 3}\nstep = [( -1, 0 ), ( 0, 1 ), ( 1, 0 ), ( 0, -1 )]\nvv = []\n\nwhile True:\n    W, H = map( int, sys.stdin.readline().rstrip().split() )\n    if W == 0 and H == 0: break\n    m = [ list( sys.stdin.readline().strip() ) for i in xrange( H ) ]\n    people = [ ( i, j, direction[ m[i][j] ] ) for i in xrange( H ) for j in range( W )\n               if m[i][j] in \"NESW\" ]\n    time = 0\n    while any( people ):\n        time += 1\n        if time > 180:\n            time = -1\n            break\n        sched = []\n        for n in xrange( len( people ) ):\n            if people[n] is None: continue\n            x, y, d = people[n]\n            for i in range(1, -3, -1):\n                    dx, dy = step[(d + i) % 4]\n                    if 0 <= x+dx < H and 0 <= y+dy < W and m[x+dx][y+dy] in \"X.\":\n                        people[n][2] = (d + i) % 4\n                        beat = True\n                        for k in range( len( sched ) ):\n                            xx, yy, dd = sched[k][1:]\n                            if ( x+dx, y+dy ) == ( xx, yy ):\n                                if dd < (d + i) % 4:\n                                    sched[k] = ( n, x+dx, y+dy, (d + i) % 4 )\n                                    beat = False\n                                    break\n                                else:\n                                    beat = False\n                                    break\n                        if beat:\n                            sched.append( ( n, x+dx, y+dy, (d + i) % 4 ) )\n\t\t\tbreak\n        for ( k, x, y, d ) in sched:\n            m[ people[k][0] ][ people[k][1] ] = '.'\n            if m[x][y] == 'X':\n                people[k] = None\n            else:\n                m[x][y] = 'H'\n                people[k] = x, y, d\n    if time >= 0:\n        vv.append(time)\n    else:\n        vv.append('NA')\n\nfor v in vv:\n    print v", "sampled": "from collections import deque\n\ndef solve():\n    while True:\n        W, H = map(int, input().split())\n        if W == 0 and H == 0:\n            break\n        \n        grid = []\n        people = []\n        \n        for i in range(H):\n            row = input().strip()\n            grid.append(list(row))\n            for j in range(len(row)):\n                if row[j] in 'ENSW':\n                    people.append([i, j, row[j]])\n                    grid[i][j] = '.'\n        \n        # Direction mappings\n        dir_map = {\n            'E': (0, 1),\n            'W': (0, -1),\n            'N': (-1, 0),\n            'S': (1, 0)\n        }\n        \n        dir_names = ['E', 'W', 'N', 'S']\n        \n        # Right, front, left, back relative to current direction\n        turn_order = {\n            'E': ['S', 'E', 'N', 'W'],\n            'W': ['N', 'W', 'S', 'E'],\n            'N': ['E', 'N', 'W', 'S'],\n            'S': ['W', 'S', 'E', 'N']\n        }\n        \n        time = 0\n        \n        while people and time <= 180:\n            # Step 1: Update directions\n            new_people = []\n            for person in people:\n                r, c, facing = person\n                \n                # Check right, front, left, back\n                found_dir = None\n                for check_dir in turn_order[facing]:\n                    dr, dc = dir_map[check_dir]\n                    nr, nc = r + dr, c + dc\n                    \n                    if 0 <= nr < H and 0 <= nc < W:\n                        cell = grid[nr][nc]\n                        if cell == '.' or cell == 'X':\n                            # Check if occupied by another person\n                            occupied = False\n                            for other in people:\n                                if other[0] == nr and other[1] == nc:\n                                    occupied = True\n                                    break\n                            \n                            if not occupied:\n                                found_dir = check_dir\n                                break\n                \n                if found_dir:\n                    new_people.append([r, c, found_dir])\n                else:\n                    new_people.append([r, c, facing])\n            \n            people = new_people\n            \n            # Step 2: Move people\n            # Calculate target positions for each person\n            targets = {}\n            for idx, person in enumerate(people):\n                r, c, facing = person\n                dr, dc = dir_map[facing]\n                nr, nc = r + dr, c + dc\n                \n                if 0 <= nr < H and 0 <= nc < W:\n                    cell = grid[nr][nc]\n                    if cell == '.' or cell == 'X':\n                        if (nr, nc) not in targets:\n                            targets[(nr, nc)] = []\n                        targets[(nr, nc)].append((idx, r, c))\n            \n            # Resolve conflicts\n            moved = set()\n            new_people = []\n            \n            for target, candidates in targets.items():\n                if len(candidates) == 1:\n                    idx, r, c = candidates[0]\n                    moved.add(idx)\n                else:\n                    # Priority: E, N, W, S\n                    priority_order = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n                    tr, tc = target\n                    \n                    selected = None\n                    for dr, dc in priority_order:\n                        sr, sc = tr - dr, tc - dc\n                        for idx, r, c in candidates:\n                            if r == sr and c == sc:\n                                selected = idx\n                                break\n                        if selected is not None:\n                            break\n                    \n                    if selected is not None:\n                        moved.add(selected)\n            \n            # Update people positions\n            final_people = []\n            for idx, person in enumerate(people):\n                r, c, facing = person\n                if idx in moved:\n                    dr, dc = dir_map[facing]\n                    nr, nc = r + dr, c + dc\n                    \n                    # Check if it's an exit\n                    if grid[nr][nc] == 'X':\n                        # Person escapes\n                        continue\n                    else:\n                        final_people.append([nr, nc, facing])\n                else:\n                    final_people.append([r, c, facing])\n            \n            people = final_people\n            time += 1\n        \n        if people:\n            print(\"NA\")\n        else:\n            print(time)\n\nsolve()\n", "perturbed_sampled": ["from collections import deque def solve(): while True: W, H = map(int, input().split()) if W == 0 and H == 0: break grid = [] people = [] for i in range(H): row = input().strip() grid.append(list(row)) for j in range(len(row)): if row[j] in 'ENSW': people.append([i, j, row[j]]) grid[i][j] = '.' # Direction  'N': (-1, 0), 'S': (1, 0) } dir_names = ['E', 'W', 'N', 'S'] # Right, front,  ['S',  'N', 'W', 'S'], 'S': ['W', 'S', 'E', 'N']  # Step 1: Update directions new_people = [] for person in people: r, c, facing = person #  in turn_order[facing]: dr, dc = dir_map[check_dir] nr, nc = r + dr, c + dc if 0 <= nr < H and 0 <= nc < W: cell = grid[nr][nc] if cell == '.' or cell  = False for other in people: if other[0] == nr and other[1] == nc: occupied = True break if not occupied: found_dir = check_dir break if found_dir: new_people.append([r, c,  2: Move people # Calculate target positions for each person targets =  person dr, dc = dir_map[facing] nr, nc = r + dr, c + dc if  W: cell = grid[nr][nc] if  not in targets: targets[(nr, nc)] = [] targets[(nr, nc)].append((idx, r, c)) # Resolve conflicts moved = set()  == 1: idx, r, c = candidates[0] moved.add(idx) else: # Priority: E, N, W, S priority_order = [(0, 1), (-1, 0), (0, -1), (1, 0)] tr, tc = target selected = None for dr, dc in priority_order: sr, sc = tr - dr, tc - dc for idx, r, c in candidates: if r == sr and c == sc: selected = idx break if selected is not None: break if selected is not None: moved.add(selected) # Update people positions  facing = person if idx in moved: dr, dc = dir_map[facing] nr, nc  it's an exit if grid[nr][nc] == 'X': # Person escapes continue else: final_people.append([nr, nc, facing]) else: final_people.append([r, c, facing]) people = final_people time += 1 if people: print(\"NA\") else: print(time) solve()"], "perturbed_original": ["import sys direction = {'N' : 0, 'E' : 1, 'S' : 2, 'W' : 3} step = [( -1, 0 ), ( 0, 1 ), ( 1, 0 ), ( 0, -1 )] vv = [] while True: W, H = map( int, sys.stdin.readline().rstrip().split() ) if W == 0 and H == 0: break m = [ list( sys.stdin.readline().strip() ) for i in xrange( H ) ] people = [ ( i, j, direction[ m[i][j]  in range( W ) if m[i][j] in \"NESW\" ] time = 0 while any( people ): time += 1 if time > 180: time = -1 break sched = [] for n in xrange( len( people ) ): if people[n] is None: continue x, y, d = people[n] for i in range(1, -3, -1): dx, dy = step[(d + i) % 4] if 0 <= x+dx < H and 0 <= y+dy <  % 4 beat = True for k in range( len( sched ) ): xx, yy,  xx, yy ): if dd < (d + i) % 4: sched[k] = ( n, x+dx, y+dy, (d +   (d +  y,  '.' if m[x][y] == 'X': people[k] = None else: m[x][y] = 'H' people[k]  vv.append('NA') for v in vv: print v"], "original_ll": -1.0252050161361694, "sampled_ll": -0.7398157715797424, "all_perturbed_sampled_ll": [-1.8054221868515015], "all_perturbed_original_ll": [-1.8947867155075073], "perturbed_sampled_ll": -1.8054221868515015, "perturbed_original_ll": -1.8947867155075073, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#define N 10\ntypedef unsigned long long int INT;\nINT GCD(INT a, INT b){\n\tif( b == 0 ) return a;\n\telse return GCD(b,a%b);\n}\nINT LCM(INT a, INT b){\n\treturn (a/GCD(a,b))*b;\n}\nint main(){\n\twhile(1){\n\t\tint i,n;\n\t\tINT d[N];\n\t\tINT v[N];\n\t\tINT Rates[N];\n\t\tINT lcmV = 1;\n\t\tINT gcdRates = 1;\n\t\tINT lcmRates = 1;\n\n\t\tscanf(\"%d\",&n);\n\t\tif(0==n)break;\n\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tint td, tv;\n\t\t\tint gcd;\n\t\t\tscanf(\"%d%d\",&td,&tv);\n\t\t\tgcd = GCD(td,tv);\n\t\t\td[i] = (INT)td/gcd;\n\t\t\tv[i] = (INT)tv/gcd;\n\t\t}\n\t\t\n\t\tlcmV = LCM( v[0], v[1] );\n\t\tfor(i = 2; i < n; ++i){\n\t\t\tlcmV = LCM( lcmV, v[i] );\n\t\t}\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tRates[i] = (lcmV / v[i])*d[i];\n\t\t}\n\t\tgcdRates = GCD( Rates[0], Rates[1] );\n\t\tfor(i = 2; i < n; ++i){\n\t\t\tgcdRates = GCD( gcdRates, Rates[i] );\n\t\t}\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tRates[i] /= gcdRates;\n\t\t}\n\t\tlcmRates = LCM( Rates[0], Rates[1] );\n\t\tfor(i = 2; i < n; ++i){\n\t\t\tlcmRates = LCM( lcmRates, Rates[i] );\n\t\t}\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tprintf(\"%u\\n\", (unsigned int)(lcmRates / Rates[i]));\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long lcm(long long a, long long b) {\n    return (a / gcd(a, b)) * b;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long times[10];\n        long long d, v;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%lld %lld\", &d, &v);\n            long long g = gcd(d, v);\n            d /= g;\n            v /= g;\n            times[i] = d;\n        }\n        \n        long long lcm_time = times[0];\n        for (int i = 1; i < n; i++) {\n            lcm_time = lcm(lcm_time, times[i]);\n        }\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%lld\\n\", lcm_time / times[i]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> long long gcd(long long a, long long b) { while (b != 0) { long long temp = b; b = a % b;  long a, long long b) { return (a / gcd(a, b)) * b; } int main() { int n; while (scanf(\"%d\", &n) == 1  d, v; for (int i = 0; i < n; i++) { scanf(\"%lld %lld\", &d, &v); long long g = gcd(d, v); d /= g; v /=  for (int i = 1; i < n; i++) { lcm_time = lcm(lcm_time, times[i]); } for (int i = 0;  } return 0; }"], "perturbed_original": ["#include<stdio.h> #define N 10 typedef unsigned long long int INT; INT GCD(INT a, INT b){ if( b == 0 ) return a; else return GCD(b,a%b); } INT LCM(INT a, INT b){ return (a/GCD(a,b))*b; } int main(){ while(1){ int i,n; INT d[N]; INT v[N]; INT Rates[N]; INT lcmV = 1; INT gcdRates = 1; INT lcmRates = 1;  = (INT)td/gcd; v[i] = (INT)tv/gcd; } lcmV = LCM( v[0], v[1] ); for(i = 2; i < n; ++i){ lcmV = LCM(  ++i){ Rates[i] = (lcmV / v[i])*d[i]; } gcdRates = GCD( Rates[0], Rates[1] ); for(i = 2; i < n; ++i){ gcdRates = GCD( gcdRates, Rates[i] ); } for(i = 0;  LCM( Rates[0], Rates[1] ); for(i = 2; i < n; ++i){ lcmRates = LCM( lcmRates,  printf(\"%u\\n\", (unsigned int)(lcmRates / Rates[i])); } } return 0; }"], "original_ll": -0.8198227286338806, "sampled_ll": -0.49272772669792175, "all_perturbed_sampled_ll": [-1.4294708967208862], "all_perturbed_original_ll": [-1.5091660022735596], "perturbed_sampled_ll": -1.4294708967208862, "perturbed_original_ll": -1.5091660022735596, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.Scanner;\nimport java.math.BigInteger;\n\npublic class Main\n{\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner cin = new Scanner(System.in);\n\t\t\n\t\tint n;\n\t\twhile(true)\n\t\t{\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\n\t\t\tBigInteger   p = new BigInteger(\"1\"); \n\t\t\tBigInteger[] s = new BigInteger[10];\n\t\t\tBigInteger[] t = new BigInteger[10];\n\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\ts[i] = new BigInteger(cin.next());\n\t\t\t\tt[i] = new BigInteger(cin.next());\n\t\t\t\t\n\t\t\t\tp = t[i].multiply( p.divide( p.gcd(t[i]) ));\n\t\t\t}\n\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\ts[i] = s[i].multiply( p.divide(t[i]) );\n\t\t\t}\n\t\t\t\n\t\t\tp = new BigInteger(\"1\");\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tp = s[i].multiply( p.divide( p.gcd(s[i]) ));\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tSystem.out.println(p.divide(s[i]));\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            long[] d = new long[n];\n            long[] v = new long[n];\n            \n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                d[i] = Long.parseLong(parts[0]);\n                v[i] = Long.parseLong(parts[1]);\n            }\n            \n            // Calculate time for each student to complete one lap\n            // time = distance / speed = d / v\n            // We need to find LCM of all times\n            // time_i = d_i / v_i\n            // To avoid floating point, we work with fractions\n            \n            // Reduce each fraction d_i / v_i\n            long[] numerators = new long[n];\n            long[] denominators = new long[n];\n            \n            for (int i = 0; i < n; i++) {\n                long g = gcd(d[i], v[i]);\n                numerators[i] = d[i] / g;\n                denominators[i] = v[i] / g;\n            }\n            \n            // Find LCM of fractions: LCM(a/b, c/d) = LCM(a,c) / GCD(b,d)\n            long lcmNum = numerators[0];\n            long lcmDen = denominators[0];\n            \n            for (int i = 1; i < n; i++) {\n                lcmNum = lcm(lcmNum, numerators[i]);\n                lcmDen = gcd(lcmDen, denominators[i]);\n            }\n            \n            // The total time when all meet is lcmNum / lcmDen\n            // Number of laps for student i = (lcmNum / lcmDen) / (numerators[i] / denominators[i])\n            //                               = (lcmNum / lcmDen) * (denominators[i] / numerators[i])\n            //                               = (lcmNum * denominators[i]) / (lcmDen * numerators[i])\n            \n            for (int i = 0; i < n; i++) {\n                long laps = (lcmNum * denominators[i]) / (lcmDen * numerators[i]);\n                System.out.println(laps);\n            }\n        }\n    }\n    \n    static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n    \n    static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String  = Integer.parseInt(line.trim()); if (n == 0) break; long[] d = new long[n]; long[] v = new long[n]; for (int i = 0; i < n; i++) { String[] parts = br.readLine().trim().split(\"\\\\s+\"); d[i] = Long.parseLong(parts[0]); v[i] = Long.parseLong(parts[1]); } // Calculate time for each student to complete one lap // time = distance / speed = d / v // We need to find LCM of all times // time_i =  with fractions // Reduce each fraction d_i / v_i long[] numerators =  = gcd(d[i], v[i]); numerators[i] = d[i] / g; denominators[i] = v[i] / g; } // Find LCM of fractions: LCM(a/b, c/d) = LCM(a,c) / GCD(b,d) long lcmNum = numerators[0]; long lcmDen = denominators[0]; for (int i = 1; i < n; i++) { lcmNum = lcm(lcmNum, numerators[i]); lcmDen = gcd(lcmDen, denominators[i]); } // The total  of laps for student i = (lcmNum / lcmDen) / (numerators[i] / denominators[i])  = (lcmNum * denominators[i]) / (lcmDen * numerators[i]) for (int i = 0; i < n; i++) { long laps = (lcmNum * denominators[i]) / (lcmDen * numerators[i]); System.out.println(laps); } } } static long gcd(long a,  = b; b = a   b) * b; } }"], "perturbed_original": ["import java.io.*; import cin; n; new<extra_id_1>new BigInteger(cand.next());<extra_id_2>=<extra_id_3>cin = new BigInteger(cin.next());<extra_id_4>new BigInteger(cin.next()); t[s[i].multiply(<extra_id_5>; }<extra_id_6>return p; } } }<extra_id_7>\"double\"<extra_id_8>.<extra_id_9>new Number(cin.next()); T [i]<extra_id_10>int<extra_id_11>; p<extra_id_12>; }<extra_id_13>.<extra_id_14>( s [<extra_id_15>. println ( new BigInteger(\"1\"); BigInteger[] s = new BigInteger[10]; BigInteger[] t = new BigInteger[10]; for(int i=0; i<n; i++) { s[i] = new BigInteger(cin.next()); t[i] = new BigInteger(cin.next()); p = t[i].multiply( p.divide( p.gcd(t[i]) )); } for(int i=0; i<n; i++) { s[i] = s[i].multiply( p.divide(t[i]) ); } p = new BigInteger(\"1\"); for(int i=0; i<n; i++) { p = s[i].multiply( p.divide( p.gcd(s[i]) )); } for(int i=0; i<n; i++) { System.out.println(p.divide(s[i])); } } } }"], "original_ll": -0.8160963654518127, "sampled_ll": -0.7031213641166687, "all_perturbed_sampled_ll": [-1.3461498022079468], "all_perturbed_original_ll": [-1.7921316623687744], "perturbed_sampled_ll": -1.3461498022079468, "perturbed_original_ll": -1.7921316623687744, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\"\"\" Created by Jieyi on 10/4/16. \"\"\"\nimport io\nimport sys\n\nif len(sys.argv) > 1:\n    filename = sys.argv[1]\n    inp = ''.join(open(filename, \"r\").readlines())\n    sys.stdin = io.StringIO(inp)\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n\n    return x\n\n\ndef lcm(x, y):\n    l_lcm = (x * y) // gcd(x, y)\n    return l_lcm\n\n\ndef mul_lcm(array):\n    l = lcm(array[0], array[1])\n    if len(array) > 3:\n        for i in range(2, len(array)):\n            l = lcm(array[i], l)\n    return l\n\n\ndef algorithm(students):\n    denominator_lcm = mul_lcm([y for _, y in students])\n    for i in range(len(students)):\n        students[i][0] *= int(denominator_lcm / students[i][1])\n    molecular_lcm = mul_lcm([x for x, _ in students])\n\n    return [int(molecular_lcm / students[i][0]) for i in range(len(students))]\n\n\ndef input_sample():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n\n        students = []\n        for _ in range(n):\n            students.append(list(map(int, input().split())))\n        answer_list = algorithm(students)\n        for ans in answer_list:\n            print(ans)\n\n\ndef main():\n    input_sample()\n\n\nif __name__ == '__main__':\n    main()", "sampled": "from math import gcd\nfrom fractions import Fraction\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef lcm_multiple(numbers):\n    result = numbers[0]\n    for num in numbers[1:]:\n        result = lcm(result, num)\n    return result\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    students = []\n    for _ in range(n):\n        d, v = map(int, input().split())\n        students.append((d, v))\n    \n    # Calculate time for one lap for each student as a fraction\n    times = []\n    for d, v in students:\n        times.append(Fraction(d, v))\n    \n    # Find LCM of all times\n    # LCM of fractions a/b and c/d is LCM(a,c)/GCD(b,d)\n    numerators = [t.numerator for t in times]\n    denominators = [t.denominator for t in times]\n    \n    lcm_num = lcm_multiple(numerators)\n    gcd_den = denominators[0]\n    for den in denominators[1:]:\n        gcd_den = gcd(gcd_den, den)\n    \n    meeting_time = Fraction(lcm_num, gcd_den)\n    \n    # Calculate laps for each student\n    for time in times:\n        laps = meeting_time / time\n        print(int(laps))\n", "perturbed_sampled": ["from math import gcd from fractions import Fraction def lcm(a, b): return a * b // gcd(a, b) def lcm_multiple(numbers): result =  result while True: n = int(input()) if n == 0: break students = [] for _ in range(n): d, v  lap for each student as a fraction times = [] for d, v in students: times.append(Fraction(d, v)) # Find LCM of all times # LCM of fractions a/b and c/d is LCM(a,c)/GCD(b,d) numerators = [t.numerator for t in times]  gcd(gcd_den, den) meeting_time = Fraction(lcm_num, gcd_den) # Calculate laps for each student for time in times: laps = meeting_time / time print(int(laps))"], "perturbed_original": ["\"\"\" Created by Jieyi on 10/4/16. \"\"\" import io import sys if len(sys.argv) > 1: filename = sys.argv[1] inp = ''.join(open(filename, \"r\").readlines()) sys.stdin = io.StringIO(inp) def gcd(x, y): while y: x, y = y, x % y return x def lcm(x, y):  3: for i in range(2,  = mul_lcm([y for _, y in students]) for i in range(len(students)): students[i][0] *= int(denominator_lcm / students[i][1]) molecular_lcm = mul_lcm([x for x, _ in students]) return [int(molecular_lcm  n = int(input()) if n == 0: break students = [] for _ in range(n): students.append(list(map(int, input().split()))) answer_list = algorithm(students) for ans in answer_list: print(ans) def main(): input_sample() if __name__ == '__main__': main()"], "original_ll": -1.0426514148712158, "sampled_ll": -0.9305617809295654, "all_perturbed_sampled_ll": [-2.3709371089935303], "all_perturbed_original_ll": [-1.8779644966125488], "perturbed_sampled_ll": -2.3709371089935303, "perturbed_original_ll": -1.8779644966125488, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\n#define INF 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[11][101];\n\nint W[101][101];\nint c, V, n, s, d;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nvoid dijkstra(int start) {\n    int i, x, p, step;\n    for (i = 0; i <= c; i++) {\n\tfor (x = 1; x <= n; x++) {\n\t    vertex[i][x].distance = INF; vertex[i][x].state = 0;\n\t}\n\tvertex[i][start].distance = 0; \n    }\n    for (i = 0; i <= c; i++) {\n\tfor (step = 1; step <= n; step++) {\n\t    int minimum = INF;\n\t    for (x = 1; x <= n; x++)\n\t\tif (vertex[i][x].state == 0 && vertex[i][x].distance < minimum) {\n\t\t    p = x; minimum = vertex[i][x].distance;\n\t\t}\n\t    vertex[i][p].state = 1;\n\t    for (x = 1 ; x <= n; x++)\n\t\tif (vertex[i][x].state == 0) {\n\t\t    if (i == 0)\n\t\t\tvertex[i][x].distance = min(vertex[i][x].distance, \n\t\t\t\t\t\t    vertex[i][p].distance+W[p][x]);\n\t\t    else\n\t\t\tvertex[i][x].distance = min(vertex[i][x].distance, \n\t\t\t\t\t\t    min(vertex[i][p].distance+W[p][x],\n\t\t\t\t\t\t\tvertex[i-1][p].distance+W[p][x]/2));\n\t\t}\n\t}\n    }\n}\n\nint main(void) {\n    int i, j;\n    int from, to, m;\n     \n    while (1) {\n\tscanf(\"%d%d%d%d%d\", &c, &V, &n, &s, &d);\n        if (c + V + n + s + d == 0) break;\n         \n        for (i = 0; i <= V; i++)\n            for (j = 0; j <= V; j++)\n                W[i][j] = INF;\n         \n\tfor (i = 0; i < n; i++) {\n            scanf(\"%d%d%d\", &from, &to, &m);\n            W[from][to] = m;\n\t    W[to][from] = m;\n        }\n         \n        dijkstra(s);\n\tprintf(\"%d\\n\", vertex[c][d].distance);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 101\n#define MAX_M 501\n#define INF INT_MAX\n\ntypedef struct {\n    int to;\n    int cost;\n} Edge;\n\nEdge edges[MAX_M * 2];\nint head[MAX_N];\nint next_edge[MAX_M * 2];\nint edge_count;\n\nvoid add_edge(int from, int to, int cost) {\n    edges[edge_count].to = to;\n    edges[edge_count].cost = cost;\n    next_edge[edge_count] = head[from];\n    head[from] = edge_count;\n    edge_count++;\n}\n\ntypedef struct {\n    int node;\n    int tickets_used;\n    int cost;\n} State;\n\nState queue[MAX_N * 12];\nint queue_start, queue_end;\n\nvoid enqueue(int node, int tickets, int cost) {\n    queue[queue_end].node = node;\n    queue[queue_end].tickets_used = tickets;\n    queue[queue_end].cost = cost;\n    queue_end++;\n}\n\nState dequeue() {\n    return queue[queue_start++];\n}\n\nint min_cost[MAX_N][12];\n\nint dijkstra(int n, int s, int d, int c) {\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= c; j++) {\n            min_cost[i][j] = INF;\n        }\n    }\n    \n    queue_start = 0;\n    queue_end = 0;\n    enqueue(s, 0, 0);\n    min_cost[s][0] = 0;\n    \n    while (queue_start < queue_end) {\n        State current = dequeue();\n        int u = current.node;\n        int tickets = current.tickets_used;\n        int curr_cost = current.cost;\n        \n        if (curr_cost > min_cost[u][tickets]) {\n            continue;\n        }\n        \n        for (int e = head[u]; e != -1; e = next_edge[e]) {\n            int v = edges[e].to;\n            int edge_cost = edges[e].cost;\n            \n            // Without using discount\n            int new_cost = curr_cost + edge_cost;\n            if (new_cost < min_cost[v][tickets]) {\n                min_cost[v][tickets] = new_cost;\n                enqueue(v, tickets, new_cost);\n            }\n            \n            // With discount\n            if (tickets < c) {\n                int discounted_cost = curr_cost + edge_cost / 2;\n                if (discounted_cost < min_cost[v][tickets + 1]) {\n                    min_cost[v][tickets + 1] = discounted_cost;\n                    enqueue(v, tickets + 1, discounted_cost);\n                }\n            }\n        }\n    }\n    \n    int result = INF;\n    for (int i = 0; i <= c; i++) {\n        if (min_cost[d][i] < result) {\n            result = min_cost[d][i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    int c, n, m, s, d;\n    \n    while (1) {\n        scanf(\"%d %d %d %d %d\", &c, &n, &m, &s, &d);\n        if (c == 0 && n == 0 && m == 0 && s == 0 && d == 0) {\n            break;\n        }\n        \n        edge_count = 0;\n        for (int i = 0; i <= n; i++) {\n            head[i] = -1;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int a, b, f;\n            scanf(\"%d %d %d\", &a, &b, &f);\n            add_edge(a, b, f);\n            add_edge(b, a, f);\n        }\n        \n        int result = dijkstra(n, s, d, c);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h>  struct { int to; int cost; } Edge; Edge edges[MAX_M * 2]; int head[MAX_N]; int next_edge[MAX_M * 2]; int edge_count;  to; edges[edge_count].cost = cost; next_edge[edge_count] = head[from]; head[from] = edge_count; edge_count++; } typedef struct { int node; int tickets_used; int cost; } State;  int tickets, int cost) { queue[queue_end].node = node; queue[queue_end].tickets_used = tickets; queue[queue_end].cost = cost; queue_end++; } State dequeue() { return queue[queue_start++]; } int min_cost[MAX_N][12]; int dijkstra(int n, int s, int d, int c) { for (int i = 0; i <= n; i++) { for (int j = 0; j <= c; j++) { min_cost[i][j]  enqueue(s, 0, 0); min_cost[s][0]  int curr_cost = current.cost; if (curr_cost > min_cost[u][tickets]) { continue; } for (int e = head[u]; e != -1; e = next_edge[e]) { int v = edges[e].to; int edge_cost = edges[e].cost; // Without using discount int new_cost = curr_cost + edge_cost; if (new_cost < min_cost[v][tickets]) { min_cost[v][tickets]  (tickets < c) { int discounted_cost = curr_cost + edge_cost / 2; if (discounted_cost < min_cost[v][tickets + 1]) { min_cost[v][tickets + 1] = discounted_cost; enqueue(v, tickets + 1, discounted_cost); } } } } int result = INF;  if (min_cost[d][i] < result) {  { int c, n, m, s, d; while (1) { scanf(\"%d %d  == 0  == 0 && d == 0) { break; } edge_count = 0; for (int i = 0; i <= n; i++) { head[i] = -1; } for (int i = 0; i < m; i++) { int a, b, f; scanf(\"%d %d %d\", &a, &b, &f); add_edge(a, b, f); add_edge(b, a, f); } int result = dijkstra(n, s, d, c); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> #define INF 100000000 struct NODE { int distance; int state; } vertex[11][101]; int  int b) { return (a > b ? b : a); } void dijkstra(int start) { int i, x, p,  for (x = 1; x <= n; x++) { vertex[i][x].distance = INF; vertex[i][x].state = 0; } vertex[i][start].distance = 0; } for (i = 0; i <= c; i++) { for (step = 1; step <= n; step++) { int minimum = INF; for (x = 1; x <= n; x++) if (vertex[i][x].state == 0  vertex[i][x].distance; } vertex[i][p].state = 1; for (x = 1 ; x <= n; x++) if (vertex[i][x].state  vertex[i][p].distance+W[p][x]); else vertex[i][x].distance = min(vertex[i][x].distance, min(vertex[i][p].distance+W[p][x], vertex[i-1][p].distance+W[p][x]/2)); } } } } int main(void) { int i,  &V, &n, &s, &d); if (c + V + n + s + d == 0) break; for (i = 0; i <= V; i++) for (j = 0; j <= V; j++) W[i][j] =  scanf(\"%d%d%d\", &from, &to,  vertex[c][d].distance); } return 0; }"], "original_ll": -0.7991953492164612, "sampled_ll": -0.4713601768016815, "all_perturbed_sampled_ll": [-1.3362772464752197], "all_perturbed_original_ll": [-1.519468903541565], "perturbed_sampled_ll": -1.3362772464752197, "perturbed_original_ll": -1.519468903541565, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String arg[])\n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=1000001;\n\t\tfor(;;)\n\t\t{\n\t\t\tint c=in.nextInt();//\u30c1\u30b1\u30c3\u30c8\u306e\u6570\n\t\t\tint n=in.nextInt(),m=in.nextInt();//\u30d0\u30b9\u505c\u306e\u6570,\u9053\u306e\u6570\n\t\t\tint s=in.nextInt(),d=in.nextInt();//\u30b9\u30bf\u30fc\u30c8&\u30b4\u30fc\u30eb\n\t\t\tif((c|n|m|s|d)==0)\n\t\t\t\treturn;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tfor(int q[]: cost) {\n\t\t\t\tArrays.fill(q, M);\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint a=in.nextInt();\n\t\t\t\tint b=in.nextInt();\n\t\t\t\tint f=in.nextInt();\n\t\t\t\tcost[a][b]=f;\n\t\t\t\tcost[b][a]=f;\n\t\t\t}\n\t\t\tint p=0,w=0;\n\t\t\tint v[][] = new int[n+1][c+1];// decision flag\n\t\t\tint leng[][]=new int[n+1][c+1];// minimum distance\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int k=0;k<=c;k++)\n\t\t\t\t{\n\t\t\t\t\tleng[i][k]=M;\n\t\t\t\t\tv[i][k]=0;\n\t\t\t\t}\n\t\t\tleng[s][c]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tint min=M;//\u6700\u5c0f\u306e\u7bc0\u70b9\u3092\u63a2\u3059\n\t\t\t\tfor(int l=1;l<=n;l++)\n\t\t\t\t\tfor(int k=1;k<=c;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(v[l][k]==0&&leng[l][k]<min)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp=l;\n\t\t\t\t\t\t\tw=k;\n\t\t\t\t\t\t\tmin=leng[l][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(min==M)\n\t\t\t\t\tbreak;\n\t\t\t\tv[p][w]=1;//\u78ba\u5b9a\u30d5\u30e9\u30b0\n\t\t\t\tfor(int l=1;l<=n;l++) //p\u3092\u7d4c\u7531\u3057\u3066l\u306b\u81f3\u308b\u9577\u3055\u304c\u305d\u308c\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\u3088\u308a\u5c0f\u3055\u3051\u308c\u3070\u66f4\u65b0\n\t\t\t\t{\n\t\t\t\t\tleng[l][w]=Math.min(leng[l][w], leng[p][w]+cost[p][l]);\n\t\t\t\t\tif (w>0)\n\t\t\t\t\t\tleng[l][w-1]=Math.min(leng[l][w-1], leng[p][w]+cost[p][l]/2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(leng[d][0]);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, cost;\n        Edge(int to, int cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        int node, couponsUsed, cost;\n        \n        State(int node, int couponsUsed, int cost) {\n            this.node = node;\n            this.couponsUsed = couponsUsed;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int c = sc.nextInt();\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            int d = sc.nextInt();\n            \n            if (c == 0 && n == 0 && m == 0 && s == 0 && d == 0) {\n                break;\n            }\n            \n            List<List<Edge>> graph = new ArrayList<>();\n            for (int i = 0; i <= n; i++) {\n                graph.add(new ArrayList<>());\n            }\n            \n            for (int i = 0; i < m; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int f = sc.nextInt();\n                graph.get(a).add(new Edge(b, f));\n                graph.get(b).add(new Edge(a, f));\n            }\n            \n            int result = dijkstra(graph, n, c, s, d);\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n    \n    static int dijkstra(List<List<Edge>> graph, int n, int c, int s, int d) {\n        int[][] dist = new int[n + 1][c + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(dist[i], Integer.MAX_VALUE);\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(s, 0, 0));\n        dist[s][0] = 0;\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            if (current.node == d) {\n                return current.cost;\n            }\n            \n            if (current.cost > dist[current.node][current.couponsUsed]) {\n                continue;\n            }\n            \n            for (Edge edge : graph.get(current.node)) {\n                // Without using coupon\n                int newCost = current.cost + edge.cost;\n                if (newCost < dist[edge.to][current.couponsUsed]) {\n                    dist[edge.to][current.couponsUsed] = newCost;\n                    pq.offer(new State(edge.to, current.couponsUsed, newCost));\n                }\n                \n                // With using coupon\n                if (current.couponsUsed < c) {\n                    int discountedCost = current.cost + edge.cost / 2;\n                    if (discountedCost < dist[edge.to][current.couponsUsed + 1]) {\n                        dist[edge.to][current.couponsUsed + 1] = discountedCost;\n                        pq.offer(new State(edge.to, current.couponsUsed + 1, discountedCost));\n                    }\n                }\n            }\n        }\n        \n        int minCost = Integer.MAX_VALUE;\n        for (int i = 0; i <= c; i++) {\n            minCost = Math.min(minCost, dist[d][i]);\n        }\n        \n        return minCost;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Edge { int to, cost;  cost; } } static class State implements Comparable<State> { int node, couponsUsed, cost; State(int node, int couponsUsed, int cost) { this.node = node; this.couponsUsed = couponsUsed; this.cost = cost; } @Override public int compareTo(State other) { return Integer.compare(this.cost, other.cost); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int c = sc.nextInt(); int n = sc.nextInt(); int m = sc.nextInt(); int s = sc.nextInt(); int d = sc.nextInt(); if (c == 0 && n == 0  == 0) { break; } List<List<Edge>> graph = new ArrayList<>(); for (int i = 0; i <= n;  i < m; i++) { int a = sc.nextInt(); int b =  d); System.out.println(result); } sc.close(); } static int dijkstra(List<List<Edge>> graph, int n, int c, int s, int  i++) { Arrays.fill(dist[i], Integer.MAX_VALUE); }  = 0; while (!pq.isEmpty()) { State current = pq.poll(); if (current.node == d) { return current.cost; } if (current.cost > dist[current.node][current.couponsUsed]) { continue; } for (Edge edge : graph.get(current.node)) { // Without using coupon int newCost = current.cost + edge.cost; if (newCost < dist[edge.to][current.couponsUsed])  With using coupon if (current.couponsUsed < c) { int discountedCost = current.cost + edge.cost / 2; if (discountedCost < dist[edge.to][current.couponsUsed + 1]) { dist[edge.to][current.couponsUsed + 1] = discountedCost; pq.offer(new State(edge.to, current.couponsUsed + 1, discountedCost)); } } } } int minCost = Integer.MAX_VALUE; for (int i = 0; i <=  } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { public static void  int c=in.nextInt();//\u30c1\u30b1\u30c3\u30c8\u306e\u6570 int n=in.nextInt(),m=in.nextInt();//\u30d0\u30b9\u505c\u306e\u6570,\u9053\u306e\u6570 int s=in.nextInt(),d=in.nextInt();//\u30b9\u30bf\u30fc\u30c8&\u30b4\u30fc\u30eb if((c|n|m|s|d)==0) return; int cost[][]=new int[n+1][n+1]; for(int i=0;i<=n;i++) Arrays.fill(cost[i], M); for(int q[]: cost) { Arrays.fill(q, M); }  int f=in.nextInt(); cost[a][b]=f; cost[b][a]=f; } int p=0,w=0; int v[][] = new int[n+1][c+1];// decision flag int leng[][]=new int[n+1][c+1];// minimum distance for(int i=0;i<=n;i++) for(int k=0;k<=c;k++) { leng[i][k]=M; v[i][k]=0; } leng[s][c]=0; for(;;) { int min=M;//\u6700\u5c0f\u306e\u7bc0\u70b9\u3092\u63a2\u3059 for(int l=1;l<=n;l++) for(int k=1;k<=c;k++) { if(v[l][k]==0&&leng[l][k]<min) { p=l; w=k; min=leng[l][k]; } } if(min==M) break; v[p][w]=1;//\u78ba\u5b9a\u30d5\u30e9\u30b0  } } System.out.println(leng[d][0]); } } }"], "original_ll": -1.0878812074661255, "sampled_ll": -0.34633150696754456, "all_perturbed_sampled_ll": [-1.1895631551742554], "all_perturbed_original_ll": [-1.749000072479248], "perturbed_sampled_ll": -1.1895631551742554, "perturbed_original_ll": -1.749000072479248, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from sys import stdin\nreadline = stdin.readline\n\n\n\nfrom collections import namedtuple\nRunner = namedtuple('Runner', 'd v')\n\ndef main():\n    while True:\n        ticket, vertex, edge, start, destination = map(int, readline().split())\n        if ticket == 0:\n            break\n\n        start -= 1\n        destination -= 1\n        g = defaultdict(list)\n        for i in range(edge):\n            s, t, length = map(int, readline().split())\n            s -= 1\n            t -= 1\n            g[s].append((length, t))\n            g[t].append((length, s))\n        \n        d = ex_dijkstra(g, vertex, start, ticket)\n        print(min(d[destination]))\n\n\n\nfrom heapq import heappush, heappop\nfrom collections import defaultdict\ndef ex_dijkstra(g, size, start, ticket):\n    d = [[float('inf')] * (ticket + 1) for i in range(size)]\n    d[start][ticket] = 0\n    heap = [(d[start][ticket], start, ticket)]\n    while heap:\n        du, u, ticket = heappop(heap)\n        for length, v in g[u]:\n            if d[v][ticket] > du + length:\n                d[v][ticket] = du + length\n                heappush(heap,(d[v][ticket], v, ticket))\n            if ticket and d[v][ticket - 1] > du + length // 2:\n                d[v][ticket - 1] = du + length // 2\n                heappush(heap,(d[v][ticket - 1], v, ticket - 1))\n\n    return d\n\nmain()", "sampled": "import heapq\nfrom sys import stdin\n\ndef solve(c, n, m, s, d, edges):\n    # Build adjacency list\n    graph = [[] for _ in range(n + 1)]\n    for a, b, f in edges:\n        graph[a].append((b, f))\n        graph[b].append((a, f))\n    \n    # Dijkstra with state (cost, node, discounts_used)\n    # We need to track how many discounts we've used\n    dist = {}  # (node, discounts_used) -> min_cost\n    pq = [(0, s, 0)]  # (cost, node, discounts_used)\n    dist[(s, 0)] = 0\n    \n    while pq:\n        cost, node, discounts_used = heapq.heappop(pq)\n        \n        if node == d:\n            continue\n        \n        if (node, discounts_used) in dist and dist[(node, discounts_used)] < cost:\n            continue\n        \n        for next_node, fare in graph[node]:\n            # Option 1: Don't use discount\n            new_cost = cost + fare\n            if (next_node, discounts_used) not in dist or dist[(next_node, discounts_used)] > new_cost:\n                dist[(next_node, discounts_used)] = new_cost\n                heapq.heappush(pq, (new_cost, next_node, discounts_used))\n            \n            # Option 2: Use discount if available\n            if discounts_used < c:\n                new_cost = cost + fare // 2\n                if (next_node, discounts_used + 1) not in dist or dist[(next_node, discounts_used + 1)] > new_cost:\n                    dist[(next_node, discounts_used + 1)] = new_cost\n                    heapq.heappush(pq, (new_cost, next_node, discounts_used + 1))\n    \n    # Find minimum cost to reach destination with any number of discounts used\n    min_cost = float('inf')\n    for i in range(c + 1):\n        if (d, i) in dist:\n            min_cost = min(min_cost, dist[(d, i)])\n    \n    return min_cost\n\n# Read input\nlines = []\nfor line in stdin:\n    lines.append(line.strip())\n\ni = 0\nwhile i < len(lines):\n    parts = lines[i].split()\n    c, n, m, s, d = map(int, parts)\n    if c == 0 and n == 0 and m == 0 and s == 0 and d == 0:\n        break\n    \n    edges = []\n    for j in range(m):\n        i += 1\n        a, b, f = map(int, lines[i].split())\n        edges.append((a, b, f))\n    \n    result = solve(c, n, m, s, d, edges)\n    print(result)\n    \n    i += 1\n", "perturbed_sampled": ["import heapq from sys import stdin def solve(c, n, m, s, d,  in range(n + 1)] for a, b, f in edges: graph[a].append((b, f)) graph[b].append((a, f)) # Dijkstra with state (cost, node, discounts_used) # We need to track how many discounts we've used dist = {} # (node,  node, discounts_used = heapq.heappop(pq) if node == d: continue if (node, discounts_used) in dist and dist[(node, discounts_used)] < cost: continue for next_node, fare in graph[node]: # Option 1: Don't use discount new_cost = cost + fare if (next_node, discounts_used) not in dist or dist[(next_node, discounts_used)] > new_cost: dist[(next_node, discounts_used)] = new_cost  available if discounts_used < c: new_cost = cost + fare // 2 if (next_node, discounts_used + 1) not in dist or dist[(next_node, discounts_used + 1)] > new_cost: dist[(next_node, discounts_used +  Find minimum cost to reach destination with any number of discounts used min_cost = float('inf') for i in range(c + 1): if (d, i)  lines.append(line.strip()) i = 0 while i < len(lines): parts = lines[i].split() c, n, m, s, d  0 and m == 0 and s == 0 and d == 0: break edges = [] for j in range(m): i += 1 a, b, f = map(int, lines[i].split()) edges.append((a, b, f)) result = solve(c, n, m, s, d, edges) print(result) i += 1"], "perturbed_original": ["from sys import stdin readline = stdin.readline from collections import namedtuple Runner =  start, destination = map(int, readline().split()) if ticket == 0: break start -= 1 destination -= 1 g = defaultdict(list) for i in range(edge): s, t, length = map(int, readline().split()) s -= 1 t -= 1 g[s].append((length, t)) g[t].append((length, s)) d = ex_dijkstra(g, vertex, start, ticket) print(min(d[destination])) from heapq import heappush, heappop from collections import defaultdict def ex_dijkstra(g, size, start, ticket): d = [[float('inf')] * (ticket + 1) for  ticket)] while heap: du, u, ticket =  + length: d[v][ticket] = du + length heappush(heap,(d[v][ticket], v, ticket)) if ticket and d[v][ticket - 1] > du + length // 2: d[v][ticket - 1] =  - 1)) return d main()"], "original_ll": -0.8965162038803101, "sampled_ll": -0.6120855808258057, "all_perturbed_sampled_ll": [-1.6086941957473755], "all_perturbed_original_ll": [-2.0889482498168945], "perturbed_sampled_ll": -1.6086941957473755, "perturbed_original_ll": -2.0889482498168945, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu 0213: Subdivide The Land\n// 2017.9.24 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { int id, x, y, k; } T;\nT tbl[16]; \nint X, Y, n;\nchar map[10][10];\nchar ans[10][10], cnt;\nint pair[101][13][2], plen[101];\n\nint cmp(T *a, T *b) { if (a->y - b->y) return a->y - b->y; return a->x - b->x; }\n\nvoid mark(int c, int x, int y, int w, int h)\n{\n\tint yy;\n\tfor (yy = 0; yy < h; yy++) memset(map[y+yy]+x, c, w);\n}\n\nint check(int c, int x, int y, int w, int h)\n{\n\tint xx, yy;\n\tfor (yy = 0; yy < h; yy++) for (xx = 0; xx < w; xx++) \n\t\tif (map[y+yy][x+xx] > 0 && map[y+yy][x+xx] != c) return 0;\n\treturn 1;\n}\n\nint combi(int i)\n{\n\tint x, y, x0, y0, id, x1, y1, h, w, j, k;\n\n\tif (i == n+1) {\n\t\tif (cnt) return 0;\n\t\tcnt = 1, memcpy(ans, map, sizeof(map));\n\t\treturn 1;\n\t}\n\tk = tbl[i].k;\n\tif (k == 1) return combi(i+1);\n\tx0 = tbl[i].x, y0 = tbl[i].y, id = tbl[i].id;\n\n\tfor (j = 0; j < plen[k]; j++) {\n\t\tw = pair[k][j][0], h = pair[k][j][1];\n\t\tx1 = x0 - w + 1, y1 = y0 - h + 1;\n\t\tif (x1 < 0) x1 = 0; if (y1 < 0) y1 = 0;\n\t\tfor (y = y1; y <= y0; y++) for (x = x1; x <= x0; x++) {\n\t\t\tif (x + w > X || y + h > Y) goto Next;\n\t\t\tif (!check(id, x, y, w, h)) continue;\n\t\t\tmark(id, x, y, w, h);\n\t\t\tif (!combi(i+1)) return 0;\n\t\t\tmark(0, x, y, w, h);\n\t\t}\nNext:;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n    int i, b, t, s, x, y;\n\n\tfor (x = 1; x <= 100; x++) for (y = 1; y <= 100; y++)\n\t\tif ((t = x * y) <= 100) pair[t][plen[t]][0] = x, pair[t][plen[t]++][1] = y;\n\n\twhile (scanf(\"%d%d%d\", &X, &Y, &n) && n > 0) {\n\t\tfor (s = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &b, &t);\n\t\t\ttbl[b].k = t, tbl[b].id = b;\n\t\t\ts += t;\n\t\t}\n\t\tfor (y = 0; y < Y; y++) for (x = 0; x < X; x++) {\n\t\t\tscanf(\"%d\", &b), map[y][x] = b;\n\t\t\tif (b > 0) tbl[b].x = x, tbl[b].y = y;\n\t\t}\n\t\tif (s != X*Y) { puts(\"NA\"); continue; }\n\t\tqsort(tbl+1, n, sizeof(T), cmp);\n\n\t\tcnt = 0;\n\t\tif (!combi(1)) puts(\"NA\");\n\t\telse for (y = 0; y < Y; y++) {\n\t\t\tprintf(\"%d\", ans[y][0]);\n\t\t\tfor (x = 1; x < X; x++) printf(\" %d\", ans[y][x]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint X, Y, n;\nint b[16], k[16];\nint s[11][11];\nint grid[11][11];\nint solutions;\n\nint isValidRectangle(int buyer, int x1, int y1, int x2, int y2) {\n    int count = 0;\n    int hasSign = 0;\n    \n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            if (grid[i][j] != 0) return 0;\n            count++;\n            if (s[i][j] == buyer) hasSign = 1;\n        }\n    }\n    \n    if (count != k[buyer] || !hasSign) return 0;\n    return 1;\n}\n\nvoid fillRectangle(int x1, int y1, int x2, int y2, int buyer) {\n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            grid[i][j] = buyer;\n        }\n    }\n}\n\nvoid clearRectangle(int x1, int y1, int x2, int y2) {\n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            grid[i][j] = 0;\n        }\n    }\n}\n\nvoid solve(int buyer) {\n    if (solutions > 1) return;\n    \n    if (buyer > n) {\n        solutions++;\n        return;\n    }\n    \n    for (int x1 = 1; x1 <= X; x1++) {\n        for (int y1 = 1; y1 <= Y; y1++) {\n            for (int x2 = x1; x2 <= X; x2++) {\n                for (int y2 = y1; y2 <= Y; y2++) {\n                    if (isValidRectangle(buyer, x1, y1, x2, y2)) {\n                        fillRectangle(x1, y1, x2, y2, buyer);\n                        solve(buyer + 1);\n                        if (solutions > 1) {\n                            clearRectangle(x1, y1, x2, y2);\n                            return;\n                        }\n                        clearRectangle(x1, y1, x2, y2);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d\", &X, &Y, &n);\n        if (X == 0 && Y == 0 && n == 0) break;\n        \n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d %d\", &b[i], &k[i]);\n        }\n        \n        for (int j = 1; j <= Y; j++) {\n            for (int i = 1; i <= X; i++) {\n                scanf(\"%d\", &s[i][j]);\n            }\n        }\n        \n        memset(grid, 0, sizeof(grid));\n        solutions = 0;\n        solve(1);\n        \n        if (solutions == 1) {\n            for (int j = 1; j <= Y; j++) {\n                for (int i = 1; i <= X; i++) {\n                    if (i > 1) printf(\" \");\n                    printf(\"%d\", grid[i][j]);\n                }\n                printf(\"\\n\");\n            }\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int X, Y, n; int b[16], k[16]; int s[11][11]; int grid[11][11]; int solutions; int isValidRectangle(int buyer, int x1, int y1, int x2, int y2) { int count = 0; int hasSign = 0; for (int i = x1; i <= x2; i++) { for (int j = y1; j <= y2; j++) { if (grid[i][j] != 0) return 0; count++; if (s[i][j] == buyer) hasSign = 1; } } if (count  <= y2; j++) { grid[i][j] = buyer; } } } void clearRectangle(int x1, int y1, int x2, int y2) { for (int i =  y1; j <= y2; j++) { grid[i][j] = 0;  1) return; if (buyer > n) { solutions++; return; } for (int x1 = 1; x1 <= X; x1++) { for (int y1 = 1; y1 <= Y;  x2++) { for  y2, buyer); solve(buyer + 1); if (solutions > 1) { clearRectangle(x1, y1, x2, y2); return; }  int main() { while (1) { scanf(\"%d %d %d\", &X, &Y, &n); if (X == 0 && Y == 0 && n ==  i++) { scanf(\"%d %d\", &b[i], &k[i]); } for (int j = 1; j <= Y; j++) { for (int i = 1; i <= X; i++) { scanf(\"%d\", &s[i][j]); } } memset(grid, 0, sizeof(grid)); solutions = 0; solve(1); if (solutions == 1) { for (int j = 1; j <= Y; j++) { for (int i = 1; i <= X; i++) { if (i > 1) printf(\" \"); printf(\"%d\", grid[i][j]); } printf(\"\\n\"); } } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["// Aizu 0213: Subdivide The Land  struct { int id, x, y, k; } T; T tbl[16]; int X, Y, n; char map[10][10]; char ans[10][10], cnt; int pair[101][13][2], plen[101]; int cmp(T *a, T *b) { if (a->y - b->y) return a->y - b->y; return a->x - b->x; } void mark(int c, int x, int y,  0; yy < h; yy++) memset(map[y+yy]+x, c, w); } int check(int c, int x, int y, int w, int h) { int xx, yy; for (yy = 0; yy < h; yy++) for (xx = 0; xx < w; xx++) if (map[y+yy][x+xx] > 0 && map[y+yy][x+xx] != c) return 0; return 1; } int combi(int i) { int x, y, x0, y0, id, x1, y1, h, w, j, k;  = tbl[i].k; if (k == 1) return combi(i+1); x0 = tbl[i].x, y0 = tbl[i].y, id = tbl[i].id; for (j =  = pair[k][j][1]; x1 = x0 - w + 1, y1 = y0 - h + 1; if (x1 < 0) x1 = 0; if (y1 < 0) y1 = 0; for (y = y1; y <= y0; y++) for (x = x1; x <= x0; x++) { if (x + w > X || y + h > Y)  x, y, w, h); if (!combi(i+1)) return 0; mark(0, x, y, w, h); } Next:; }  s, x, y; for (x = 1; x  y++) if ((t = x * y)  (s = i = 0; i < n; i++) { scanf(\"%d%d\", &b, &t); tbl[b].k = t, tbl[b].id = b;  Y; y++) for (x =  b; if (b > 0) tbl[b].x = x, tbl[b].y = y; } if (s != X*Y) { puts(\"NA\"); continue; } qsort(tbl+1, n, sizeof(T), cmp); cnt = 0; if (!combi(1)) puts(\"NA\"); else for (y = 0; y < Y; y++) { printf(\"%d\", ans[y][0]); for (x  } } return 0; }"], "original_ll": -0.9753254652023315, "sampled_ll": -0.47214704751968384, "all_perturbed_sampled_ll": [-1.1633481979370117], "all_perturbed_original_ll": [-1.534606695175171], "perturbed_sampled_ll": -1.1633481979370117, "perturbed_original_ll": -1.534606695175171, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport scala.languageFeature.postfixOps;\nimport sun.tools.jar.resources.jar;\nimport lombok.Data;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((w | h | n) == 0)\n\t\t\t\tbreak;\n\t\t\tsize = new int[n + 1];\n\t\t\tpos = new int[n + 1][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tsize[b] = k;\n\t\t\t}\n\t\t\tm = new int[h][w];\n\t\t\t\n\t\t\tfor (int[] a : m)\n\t\t\t\tArrays.fill(a, -1);\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tm[i][j] = x;\n\t\t\t\t\tif (x > 0) {\n\t\t\t\t\t\tpos[x][0] = i;\n\t\t\t\t\t\tpos[x][1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassign = new int[n + 1][4];\n\t\t\tc = 0;\n\t\t\tans = new int[h][w];\n\t\t\tf(1);\n\t\t\tif (c == 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate void f(int k) {\n\t\tif (k == n + 1) {\n\t\t\tc++;\n\t\t\tif (c == 2)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint a = m[i][j];\n\t\t\t\t\tans[i][j] = a >= 100 ? a / 100 : a;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = size[k];\n\t\tfor (int x = 1; x <= s; x++) {\n\t\t\tif (s % x != 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int lj = pos[k][1] + 1 - x; lj <= pos[k][1]; lj++) {\n\t\t\t\tif (lj < 0 || lj > w)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int li = pos[k][0] + 1 - s / x; li <= pos[k][0]; li++) {\n\t\t\t\t\tif (li < 0 || li > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint rj = lj + x;\n\t\t\t\t\tint ri = li + s / x;\n\t\t\t\t\tif (rj > w)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (ri > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != 0 && m[i][j] != k)\n\t\t\t\t\t\t\t\tcontinue loop;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = k * 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf(k + 1);\n\t\t\t\t\tif (c == 2)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tint[][] m;\n\tint[] size;\n\tint[][] pos;\n\tint[][] assign;\n\tint w, h, n, c;\n\tint[][] ans;\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int X, Y, n;\n    static int[] buyers;\n    static int[] counts;\n    static int[][] signs;\n    static List<int[][]> validSolutions;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            X = sc.nextInt();\n            Y = sc.nextInt();\n            n = sc.nextInt();\n            \n            if (X == 0 && Y == 0 && n == 0) break;\n            \n            buyers = new int[n];\n            counts = new int[n];\n            \n            for (int i = 0; i < n; i++) {\n                buyers[i] = sc.nextInt();\n                counts[i] = sc.nextInt();\n            }\n            \n            signs = new int[Y][X];\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    signs[i][j] = sc.nextInt();\n                }\n            }\n            \n            validSolutions = new ArrayList<>();\n            int[][] grid = new int[Y][X];\n            boolean[] used = new boolean[n];\n            \n            backtrack(grid, used, 0);\n            \n            if (validSolutions.size() == 0) {\n                System.out.println(\"NA\");\n            } else if (validSolutions.size() > 1) {\n                System.out.println(\"NA\");\n            } else {\n                int[][] sol = validSolutions.get(0);\n                for (int i = 0; i < Y; i++) {\n                    for (int j = 0; j < X; j++) {\n                        if (j > 0) System.out.print(\" \");\n                        System.out.print(sol[i][j]);\n                    }\n                    System.out.println();\n                }\n            }\n        }\n    }\n    \n    static void backtrack(int[][] grid, boolean[] used, int buyerIdx) {\n        if (buyerIdx == n) {\n            if (isValidComplete(grid)) {\n                int[][] copy = new int[Y][X];\n                for (int i = 0; i < Y; i++) {\n                    for (int j = 0; j < X; j++) {\n                        copy[i][j] = grid[i][j];\n                    }\n                }\n                validSolutions.add(copy);\n            }\n            return;\n        }\n        \n        if (validSolutions.size() > 1) return;\n        \n        int buyer = -1;\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                buyer = i;\n                break;\n            }\n        }\n        \n        if (buyer == -1) return;\n        \n        int buyerNum = buyers[buyer];\n        int count = counts[buyer];\n        \n        for (int y1 = 0; y1 < Y; y1++) {\n            for (int x1 = 0; x1 < X; x1++) {\n                for (int y2 = y1; y2 < Y; y2++) {\n                    for (int x2 = x1; x2 < X; x2++) {\n                        int w = x2 - x1 + 1;\n                        int h = y2 - y1 + 1;\n                        if (w * h != count) continue;\n                        \n                        if (canPlace(grid, x1, y1, x2, y2, buyerNum)) {\n                            place(grid, x1, y1, x2, y2, buyerNum);\n                            used[buyer] = true;\n                            backtrack(grid, used, buyerIdx + 1);\n                            used[buyer] = false;\n                            place(grid, x1, y1, x2, y2, 0);\n                            \n                            if (validSolutions.size() > 1) return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    static boolean canPlace(int[][] grid, int x1, int y1, int x2, int y2, int buyerNum) {\n        boolean hasSign = false;\n        for (int y = y1; y <= y2; y++) {\n            for (int x = x1; x <= x2; x++) {\n                if (grid[y][x] != 0) return false;\n                if (signs[y][x] != 0) {\n                    if (signs[y][x] != buyerNum) return false;\n                    hasSign = true;\n                }\n            }\n        }\n        return hasSign;\n    }\n    \n    static void place(int[][] grid, int x1, int y1, int x2, int y2, int buyerNum) {\n        for (int y = y1; y <= y2; y++) {\n            for (int x = x1; x <= x2; x++) {\n                grid[y][x] = buyerNum;\n            }\n        }\n    }\n    \n    static boolean isValidComplete(int[][] grid) {\n        for (int i = 0; i < Y; i++) {\n            for (int j = 0; j < X; j++) {\n                if (grid[i][j] == 0) return false;\n            }\n        }\n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int X, Y, n;  List<int[][]> validSolutions; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { X = sc.nextInt(); Y = sc.nextInt(); n = sc.nextInt(); if (X == 0 && Y == 0 && n == 0) break; buyers = new int[n]; counts = new int[n]; for (int i = 0; i < n; i++) { buyers[i] = sc.nextInt(); counts[i] = sc.nextInt(); } signs = new int[Y][X]; for (int i = 0; i < Y; i++) { for (int j = 0; j < X; j++) {  grid = new int[Y][X]; boolean[]  0) {  else { int[][] sol = validSolutions.get(0); for (int i = 0; i < Y; i++) { for (int j = 0; j < X; j++) { if (j > 0) System.out.print(\" \");  grid, boolean[] used, int buyerIdx) { if (buyerIdx == n) { if (isValidComplete(grid)) { int[][] copy = new int[Y][X]; for (int  j = 0; j < X; j++) { copy[i][j] = grid[i][j]; } } validSolutions.add(copy); } return; } if (validSolutions.size() > 1) return; int buyer = -1; for (int i = 0; i < n; i++) {  (buyer == -1) return; int buyerNum = buyers[buyer]; int count = counts[buyer]; for (int y1 = 0; y1 < Y; y1++) { for (int x1 = 0; x1 < X; x1++) { for (int y2 = y1; y2 < Y;  x2++) {  = y2 - y1 +  x2, y2, buyerNum); used[buyer] = true; backtrack(grid, used, buyerIdx + 1); used[buyer] = false; place(grid, x1, y1, x2, y2, 0); if (validSolutions.size() > 1) return; } } } } } } static boolean canPlace(int[][] grid, int x1, int y1,  false; for (int y = y1; y <= y2; y++) { for (int x =  return false; if (signs[y][x] != 0) { if (signs[y][x] != buyerNum) return false; hasSign = true; } } } return hasSign; } static void place(int[][] grid, int x1, int y1, int  y1; y <= y2; y++) { for (int x = x1; x <= x2; x++) { grid[y][x] = buyerNum; } } } static boolean isValidComplete(int[][] grid) {  for (int j = 0; j < X; j++) { if (grid[i][j] == 0) return false; } } return true; } }"], "perturbed_original": ["import java.io.IOException; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.PriorityQueue; import java.util.Scanner; import scala.languageFeature.postfixOps; import sun.tools.jar.resources.jar; import lombok.Data; public class Main { public static void main(String[]  (true) { w = scanner.nextInt(); h = scanner.nextInt(); n =  size = new int[n + 1]; pos = new int[n + 1][2]; for  b = scanner.nextInt(); int k = scanner.nextInt(); size[b] = k; } m = new int[h][w]; for (int[] a : m) Arrays.fill(a, -1); for (int i = 0; i < h; i++) { for (int j = 0; j < w; j++) { int x = scanner.nextInt();  i; pos[x][1] = j; } } } assign = new  f(1); if (c == 1) { for (int i = 0; i < h; i++) {  if (j > 0) System.out.print(\" \"); System.out.print(ans[i][j]); } System.out.println(); } } else { System.out.println(\"NA\"); } } } private void f(int k) { if  2) return; for (int i = 0; i < h; i++) { for (int j = 0; j < w; j++) { int a = m[i][j]; ans[i][j] = a >= 100 ? a / 100 : a; } } return; } int s = size[k]; for (int x = 1; x <= s; x++) { if (s % x != 0) continue; for  pos[k][1]; lj++) { if (lj < 0 || lj > w) continue; loop: for (int li = pos[k][0] + 1 - s / x; li <= pos[k][0]; li++) { if (li < 0 || li > h) continue; int rj = lj + x; int ri = li + s / x; if (rj > w)  li; i < ri; i++) { for (int j = lj; j < rj; j++) { if (m[i][j] != 0 && m[i][j] != k) continue loop; } } for (int i = li; i < ri; i++) { for (int j = lj; j < rj; j++) { if (m[i][j] != k) m[i][j] = k  2)  { for (int j  k) m[i][j] = 0; } } } } } } int[][]  n, c; int[][] ans; }"], "original_ll": -0.7249079942703247, "sampled_ll": -0.4022025465965271, "all_perturbed_sampled_ll": [-1.1797738075256348], "all_perturbed_original_ll": [-1.4854069948196411], "perturbed_sampled_ll": -1.1797738075256348, "perturbed_original_ll": -1.4854069948196411, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import copy\n\ndef main(land, b):\n    for h in range(H):\n        for w in range(W):\n            if land[h][w] == b:\n                if f1(land, h, w, b, data[land[h][w]]):\n                    return\n            \ndef f1(land, h, w, b, k):\n    for q in range(1, k+1):\n        if k%q == 0:\n            if f2(land, h, w, q, k/q, b):\n                return True\n    else:\n        return\n        \ndef f2(land, h, w, r, c, b):\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h-_h and 0 <= w-_w:\n                if f3(land, h-_h, w-_w, r, c, b):\n                    return True\n    else:\n        return\n                \ndef f3(land, h, w, r, c, b):\n    _land = copy.deepcopy(land)\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h+_h <= H-1 and 0 <= w+_w <= W-1:\n                if _land[h+_h][w+_w] == 0 or _land[h+_h][w+_w] == b:\n                    _land[h+_h][w+_w] = b\n                else:\n                    return\n            else:\n                return\n    else:\n        if b < n:\n            return main(_land, b+1)\n        else:\n            for line in _land:\n                print ' '.join(map(str, line))\n            return True\n\nwhile True:\n    W, H, n = map(int, raw_input().split())\n    if H == W == n == 0: break\n    data = {}\n    for i in range(n):\n        b, k = map(int, raw_input().split())\n        data[b] = k\n    land = [map(int, raw_input().split()) for i in range(H)]\n    main(land, 1)", "sampled": "import sys\nfrom itertools import product\n\ndef read_input():\n    datasets = []\n    lines = sys.stdin.read().strip().split('\\n')\n    i = 0\n    while i < len(lines):\n        parts = lines[i].split()\n        X, Y, n = int(parts[0]), int(parts[1]), int(parts[2])\n        if X == 0 and Y == 0 and n == 0:\n            break\n        \n        i += 1\n        memo = []\n        for _ in range(n):\n            b, k = map(int, lines[i].split())\n            memo.append((b, k))\n            i += 1\n        \n        signs = []\n        for _ in range(Y):\n            row = list(map(int, lines[i].split()))\n            signs.append(row)\n            i += 1\n        \n        datasets.append((X, Y, n, memo, signs))\n    \n    return datasets\n\ndef get_all_rectangles(X, Y):\n    rectangles = []\n    for x1 in range(X):\n        for y1 in range(Y):\n            for x2 in range(x1, X):\n                for y2 in range(y1, Y):\n                    rectangles.append((x1, y1, x2, y2))\n    return rectangles\n\ndef solve(X, Y, n, memo, signs):\n    rectangles = get_all_rectangles(X, Y)\n    \n    # Group rectangles by size\n    size_to_rects = {}\n    for rect in rectangles:\n        x1, y1, x2, y2 = rect\n        size = (x2 - x1 + 1) * (y2 - y1 + 1)\n        if size not in size_to_rects:\n            size_to_rects[size] = []\n        size_to_rects[size].append(rect)\n    \n    # For each buyer, get possible rectangles\n    buyer_rects = {}\n    for b, k in memo:\n        if k in size_to_rects:\n            buyer_rects[b] = size_to_rects[k]\n        else:\n            return \"NA\"\n    \n    # Try all combinations\n    def check_assignment(assignment):\n        grid = [[0] * Y for _ in range(X)]\n        \n        for buyer, rect in assignment.items():\n            x1, y1, x2, y2 = rect\n            for x in range(x1, x2 + 1):\n                for y in range(y1, y2 + 1):\n                    if grid[x][y] != 0:\n                        return None\n                    grid[x][y] = buyer\n        \n        # Check if signs match\n        for x in range(X):\n            for y in range(Y):\n                if signs[y][x] != 0:\n                    if grid[x][y] != signs[y][x]:\n                        return None\n        \n        return grid\n    \n    valid_grids = []\n    \n    def backtrack(buyers, assignment):\n        if not buyers:\n            grid = check_assignment(assignment)\n            if grid:\n                valid_grids.append(grid)\n            return\n        \n        buyer = buyers[0]\n        for rect in buyer_rects[buyer]:\n            assignment[buyer] = rect\n            backtrack(buyers[1:], assignment)\n            del assignment[buyer]\n    \n    buyers = [b for b, k in memo]\n    backtrack(buyers, {})\n    \n    if len(valid_grids) == 0:\n        return \"NA\"\n    elif len(valid_grids) == 1:\n        grid = valid_grids[0]\n        result = []\n        for y in range(Y):\n            row = []\n            for x in range(X):\n                row.append(str(grid[x][y]))\n            result.append(' '.join(row))\n        return '\\n'.join(result)\n    else:\n        return \"NA\"\n\ndatasets = read_input()\nfor X, Y, n, memo, signs in datasets:\n    result = solve(X, Y, n, memo, signs)\n    print(result)\n", "perturbed_sampled": ["import sys from itertools import product def read_input(): datasets = [] lines = sys.stdin.read().strip().split('\\n') i = 0 while i < len(lines): parts = lines[i].split() X, Y, n = int(parts[0]), int(parts[1]), int(parts[2]) if X == 0 and Y == 0 and n == 0: break i += 1 memo = [] for _ in range(n): b, k = map(int, lines[i].split()) memo.append((b, k)) i += 1  lines[i].split())) signs.append(row) i += 1 datasets.append((X, Y, n, memo, signs)) return datasets def get_all_rectangles(X, Y): rectangles = [] for x1 in range(X): for y1 in  Group rectangles by size size_to_rects = {} for rect in rectangles: x1, y1, x2, y2 = rect size = (x2 - x1 + 1) * (y2 - y1 + 1) if size not in size_to_rects: size_to_rects[size] = [] size_to_rects[size].append(rect) # For each buyer, get  if k in size_to_rects: buyer_rects[b] = size_to_rects[k] else: return \"NA\" # Try all combinations def check_assignment(assignment): grid = [[0] * Y for _ in range(X)] for buyer, rect in assignment.items(): x1, y1, x2, y2 = rect for x in range(x1, x2 + 1): for y in range(y1, y2 + 1):  y in range(Y): if signs[y][x] != 0: if grid[x][y] != signs[y][x]: return None return grid valid_grids = [] def backtrack(buyers, assignment): if not buyers: grid = check_assignment(assignment) if grid: valid_grids.append(grid)  rect  in memo] backtrack(buyers, {}) if len(valid_grids) == 0: return \"NA\" elif len(valid_grids) == 1: grid = valid_grids[0] result = [] for y in range(Y): row = [] for x in range(X): row.append(str(grid[x][y])) result.append(' '.join(row)) return '\\n'.join(result) else: return \"NA\" datasets = read_input() for X, Y, n,  signs) print(result)"], "perturbed_original": ["import copy def main(land, b): for h in range(H): for w in range(W): if land[h][w] == b: if f1(land, h, w, b, data[land[h][w]]): return def f1(land, h, w, b, k): for q in range(1, k+1): if k%q == 0:  _h in range(r): for _w in range(c): if 0 <= h-_h and 0 <= w-_w: if f3(land, h-_h, w-_w, r, c, b): return True else: return def f3(land, h, w, r, c, b): _land = copy.deepcopy(land) for _h in range(r): for _w in range(c): if 0  if _land[h+_h][w+_w] == 0 or _land[h+_h][w+_w] == b: _land[h+_h][w+_w] = b else: return else: return else: if b < n: return main(_land, b+1) else: for line in _land: print ' '.join(map(str, line)) return True while True: W, H, n  b, k = map(int, raw_input().split()) data[b] = k land = [map(int, raw_input().split()) for i in range(H)] main(land, 1)"], "original_ll": -0.9159784317016602, "sampled_ll": -0.6988242268562317, "all_perturbed_sampled_ll": [-1.555677890777588], "all_perturbed_original_ll": [-1.4526065587997437], "perturbed_sampled_ll": -1.555677890777588, "perturbed_original_ll": -1.4526065587997437, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nlong z(long a,long b,long c,long d,long e,long f){\n    return (c-a)*(f-b)-(e-a)*(d-b);\n}\nint x(int (*a)[8],int (*b)[8]){\n    int i,j;\n    for(i=0;i<4;i++){\n        for(j=0;j<4;j++){\n            if(z((*a)[j*2],(*a)[j*2+1],(*a)[(j*2+2)%8],(*a)[(j*2+2)%8+1],(*b)[i*2],(*b)[i*2+1])>0)break;\n        }\n        if(j==4)return 1;\n    }\n    return 0;\n}\n\nint main(){\n    int n,m;\n    int a[100],l[100][8],b[100];\n    int i,j,k;\n    int min,ii,jj,kk;\n    while(scanf(\"%d\",&n)&&n){\n        while(n--){\n            scanf(\"%d\",&m);\n            for(i=0;i<m;i++){\n                a[i]=i;\n                for(j=0;j<8;j++)scanf(\"%d\",&l[i][j]);\n            }\n            for(i=0;i<m;i++){\n                for(j=i+1;j<m;j++){\n                    if(x(&l[i],&l[j])){\n                        k=0;\n                        ii=i;\n                        while((b[k++]=ii),a[ii]!=ii)ii=a[ii];\n                        jj=j;\n                        while((b[k++]=jj),a[jj]!=jj)jj=a[jj];\n                        min=ii<jj?ii:jj;\n                        for(kk=0;kk<k;kk++)a[b[kk]]=min;\n                    }\n                }\n            }\n            for(i=0;i<m;i++){\n                j=i;\n                while(a[j]!=j)j=a[j];\n                a[i]=j;\n            }\n            k=0;\n            for(i=0;i<m;i++){\n                for(j=0;j<i;j++){\n                    if(a[i]==a[j])break;\n                }\n                if(j==i)k++;\n            }\n            printf(\"%d\\n\",k);\n        }\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point vertices[4];\n} Rectangle;\n\nbool segmentsIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int d1 = (q1.x - p1.x) * (p2.y - p1.y) - (q1.y - p1.y) * (p2.x - p1.x);\n    int d2 = (q1.x - p1.x) * (q2.y - p1.y) - (q1.y - p1.y) * (q2.x - p1.x);\n    int d3 = (q2.x - p2.x) * (p1.y - p2.y) - (q2.y - p2.y) * (p1.x - p2.x);\n    int d4 = (q2.x - p2.x) * (q1.y - p2.y) - (q2.y - p2.y) * (q1.x - p2.x);\n    \n    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool pointOnSegment(Point p, Point q, Point r) {\n    if (q.x <= (p.x > r.x ? p.x : r.x) && q.x >= (p.x < r.x ? p.x : r.x) &&\n        q.y <= (p.y > r.y ? p.y : r.y) && q.y >= (p.y < r.y ? p.y : r.y))\n        return true;\n    return false;\n}\n\nbool segmentsTouchOrIntersect(Point p1, Point q1, Point p2, Point q2) {\n    long long d1 = (long long)(q1.x - p1.x) * (p2.y - p1.y) - (long long)(q1.y - p1.y) * (p2.x - p1.x);\n    long long d2 = (long long)(q1.x - p1.x) * (q2.y - p1.y) - (long long)(q1.y - p1.y) * (q2.x - p1.x);\n    long long d3 = (long long)(q2.x - p2.x) * (p1.y - p2.y) - (long long)(q2.y - p2.y) * (p1.x - p2.x);\n    long long d4 = (long long)(q2.x - p2.x) * (q1.y - p2.y) - (long long)(q2.y - p2.y) * (q1.x - p2.x);\n    \n    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n        return true;\n    }\n    \n    if (d1 == 0 && pointOnSegment(p1, p2, q1)) return true;\n    if (d2 == 0 && pointOnSegment(p1, q2, q1)) return true;\n    if (d3 == 0 && pointOnSegment(p2, p1, q2)) return true;\n    if (d4 == 0 && pointOnSegment(p2, q1, q2)) return true;\n    \n    return false;\n}\n\nbool pointInRectangle(Point p, Rectangle r) {\n    int crossings = 0;\n    for (int i = 0; i < 4; i++) {\n        Point p1 = r.vertices[i];\n        Point p2 = r.vertices[(i + 1) % 4];\n        \n        if ((p1.y <= p.y && p2.y > p.y) || (p1.y > p.y && p2.y <= p.y)) {\n            double vt = (double)(p.y - p1.y) / (p2.y - p1.y);\n            if (p.x < p1.x + vt * (p2.x - p1.x)) {\n                crossings++;\n            }\n        }\n    }\n    return (crossings % 2) == 1;\n}\n\nbool rectanglesTouchOrOverlap(Rectangle r1, Rectangle r2) {\n    for (int i = 0; i < 4; i++) {\n        if (pointInRectangle(r1.vertices[i], r2)) return true;\n        if (pointInRectangle(r2.vertices[i], r1)) return true;\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            if (segmentsTouchOrIntersect(r1.vertices[i], r1.vertices[(i+1)%4],\n                                        r2.vertices[j], r2.vertices[(j+1)%4])) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nint find(int parent[], int i) {\n    if (parent[i] != i)\n        parent[i] = find(parent, parent[i]);\n    return parent[i];\n}\n\nvoid unionSet(int parent[], int rank[], int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n    \n    if (rank[xroot] < rank[yroot])\n        parent[xroot] = yroot;\n    else if (rank[xroot] > rank[yroot])\n        parent[yroot] = xroot;\n    else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\nint main() {\n    int N;\n    \n    while (scanf(\"%d\", &N) && N != 0) {\n        for (int i = 0; i < N; i++) {\n            int M;\n            scanf(\"%d\", &M);\n            \n            Rectangle rectangles[100];\n            for (int j = 0; j < M; j++) {\n                for (int k = 0; k < 4; k++) {\n                    scanf(\"%d %d\", &rectangles[j].vertices[k].x, &rectangles[j].vertices[k].y);\n                }\n            }\n            \n            int parent[100], rank[100];\n            for (int j = 0; j < M; j++) {\n                parent[j] = j;\n                rank[j] = 0;\n            }\n            \n            for (int j = 0; j < M; j++) {\n                for (int k = j + 1; k < M; k++) {\n                    if (rectanglesTouchOrOverlap(rectangles[j], rectangles[k])) {\n                        unionSet(parent, rank, j, k);\n                    }\n                }\n            }\n            \n            int count = 0;\n            for (int j = 0; j < M; j++) {\n                if (find(parent, j) == j) {\n                    count++;\n                }\n            }\n            \n            printf(\"%d\\n\", count);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <stdbool.h> typedef struct { int x, y; } Point; typedef struct { Point vertices[4]; } Rectangle; bool segmentsIntersect(Point p1, Point q1, Point p2, Point q2) { int d1 =  - p1.x) * (q2.y - p1.y) - (q1.y - p1.y) * (q2.x - p1.x); int d3 = (q2.x - p2.x) * (p1.y - p2.y) - (q2.y - p2.y) * (p1.x - p2.x); int d4 = (q2.x - p2.x) * (q1.y - p2.y) - (q2.y - p2.y) * (q1.x - p2.x); if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 <  false;  && q.x >= (p.x < r.x ? p.x : r.x) && q.y <= (p.y > r.y ? p.y :  r.y)) return true; return false; } bool segmentsTouchOrIntersect(Point p1, Point q1, Point p2, Point q2) { long long d1  - p1.x); long long d3 = (long long)(q2.x  p2.y) * (p1.x - p2.x); long  p2.y) - (long long)(q2.y - p2.y) * (q1.x - p2.x); if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) { return true; }  if  (d3 == 0 && pointOnSegment(p2, p1, q2)) return true; if (d4 == 0 && pointOnSegment(p2, q1, q2)) return true; return false; } bool pointInRectangle(Point p, Rectangle r) { int crossings = 0; for (int i = 0; i < 4; i++) { Point p1 = r.vertices[i]; Point p2 = r.vertices[(i + 1) % 4]; if ((p1.y <= p.y && p2.y > p.y) || (p1.y > p.y && p2.y <= p.y)) { double vt = (double)(p.y - p1.y) / (p2.y - p1.y); if (p.x  } } } return (crossings % 2) == 1; } bool rectanglesTouchOrOverlap(Rectangle r1, Rectangle r2) { for (int i = 0; i < 4; i++) { if (pointInRectangle(r1.vertices[i], r2)) return true; if (pointInRectangle(r2.vertices[i], r1)) return true; } for (int i = 0; i < 4; i++) { for (int j = 0; j < 4; j++) { if (segmentsTouchOrIntersect(r1.vertices[i], r1.vertices[(i+1)%4], r2.vertices[j], r2.vertices[(j+1)%4])) { return true; } } } return false; }  parent[i] = find(parent, parent[i]); return parent[i]; } void unionSet(int parent[], int rank[], int x, int y) { int xroot = find(parent, x); int yroot = find(parent, y); if (rank[xroot] < rank[yroot]) parent[xroot] = yroot; else if (rank[xroot] > rank[yroot]) parent[yroot] = xroot; else { parent[yroot] = xroot; rank[xroot]++; } } int main() { int N; while (scanf(\"%d\", &N) && N != 0) { for (int i = 0; i < N; i++) { int M; scanf(\"%d\", &M); Rectangle rectangles[100]; for (int j = 0; j < M; j++) { for (int k = 0; k < 4; k++) { scanf(\"%d %d\",  = 0; j < M; j++) {  = 0;  + 1; k < M; k++) {  }  < M; j++) { if (find(parent, j) == j) { count++; } } printf(\"%d\\n\", count); } } return 0; }"], "perturbed_original": ["#include <stdio.h> long z(long a,long  (*a)[8],int (*b)[8]){ int i,j; for(i=0;i<4;i++){ for(j=0;j<4;j++){ if(z((*a)[j*2],(*a)[j*2+1],(*a)[(j*2+2)%8],(*a)[(j*2+2)%8+1],(*b)[i*2],(*b)[i*2+1])>0)break; } if(j==4)return 1; } return 0; } int main(){ int n,m; int a[100],l[100][8],b[100]; int i,j,k; int min,ii,jj,kk; while(scanf(\"%d\",&n)&&n){ while(n--){ scanf(\"%d\",&m); for(i=0;i<m;i++){ a[i]=i; for(j=0;j<8;j++)scanf(\"%d\",&l[i][j]); } for(i=0;i<m;i++){ for(j=i+1;j<m;j++){ if(x(&l[i],&l[j])){ k=0; ii=i; while((b[k++]=ii),a[ii]!=ii)ii=a[ii]; jj=j; while((b[k++]=jj),a[jj]!=jj)jj=a[jj]; min=ii<jj?ii:jj; for(kk=0;kk<k;kk++)a[b[kk]]=min; } } } for(i=0;i<m;i++){ j=i; while(a[j]!=j)j=a[j]; a[i]=j; } k=0;  0; }"], "original_ll": -0.9146959781646729, "sampled_ll": -0.33945316076278687, "all_perturbed_sampled_ll": [-0.8466009497642517], "all_perturbed_original_ll": [-1.2710394859313965], "perturbed_sampled_ll": -0.8466009497642517, "perturbed_original_ll": -1.2710394859313965, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Autumnal Illumination\npublic class Main{\n\n\tint n;\n\tint[][][] p;\n\t\n\tint cross(int[] s, int[] t, int[] r){\n\t\tint x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];\n\t\treturn x1*y2-x2*y1;\n\t}\n\tboolean online(int[] s, int[] t, int[] r){\n\t\tif(cross(s, t, r)!=0)return false;\n\t\tint minx = Math.min(s[0], t[0]), maxx = Math.max(s[0], t[0]);\n\t\tint miny = Math.min(s[1], t[1]), maxy = Math.max(s[1], t[1]);\n\t\treturn minx<=r[0]&&r[0]<=maxx&&miny<=r[1]&&r[1]<=maxy;\n\t}\n\tboolean isCross(int[] a, int[] b, int[] s, int[] t){\n\t\tif(cross(a, b, s)*cross(a, b, t)>=0)return false;\n\t\treturn cross(b, a, s)*cross(b, a, t)<0;\n\t}\n\t\n\tboolean col(int a, int b){\n\t\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++){\n\t\t\tif(online(p[a][i], p[a][(i+1)%4], p[b][j]))return true;\n\t\t\tif(online(p[b][i], p[b][(i+1)%4], p[a][j]))return true;\n\t\t\tif(isCross(p[a][i], p[a][(i+1)%4], p[b][j], p[b][(j+1)%4]))return true;\n\t\t}\n\t\tfor(int j=0;j<4;j++){\n\t\t\tboolean in = true;\n\t\t\tfor(int i=0;i<4;i++)if(cross(p[a][i], p[a][(i+1)%4], p[b][j])>=0)in = false;\n\t\t\tif(in)return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint m = sc.nextInt();\n\t\t\tif(m==0)break;\n\t\t\twhile(m--!=0){\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tp = new int[n][4][2];\n\t\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<4;j++)for(int k=0;k<2;k++)p[i][j][k]=sc.nextInt();\n\t\t\t\tUnionFind u = new UnionFind(n);\n\t\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\t\tif(u.find(i, j))continue;\n\t\t\t\t\tif(col(i, j))u.union(i, j);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(u.num);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass UnionFind {\n\t\tfinal int[] tree;\n\t\tint num;\n\t\tpublic UnionFind(int n) {\n\t\t\tthis.tree = new int[n];\n\t\t\tArrays.fill(tree, -1);\n\t\t\tnum=n;\n\t\t}\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif(x != y) {\n\t\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t\t}\n\t\t\t\ttree[x] += tree[y];\n\t\t\t\ttree[y] = x;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tboolean find(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\t\tint root(int x) {\n\t\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t\t}\n\t\tint size(int x) {\n\t\t\treturn -tree[root(x)];\n\t\t}\n\t\tint getNum() {\n\t\t\treturn num;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    static class Quad {\n        Point[] points;\n        Quad(Point[] points) {\n            this.points = points;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            for (int i = 0; i < n; i++) {\n                int m = Integer.parseInt(br.readLine().trim());\n                Quad[] quads = new Quad[m];\n                \n                for (int j = 0; j < m; j++) {\n                    String[] tokens = br.readLine().trim().split(\"\\\\s+\");\n                    Point[] points = new Point[4];\n                    for (int k = 0; k < 4; k++) {\n                        points[k] = new Point(\n                            Double.parseDouble(tokens[k * 2]),\n                            Double.parseDouble(tokens[k * 2 + 1])\n                        );\n                    }\n                    quads[j] = new Quad(points);\n                }\n                \n                int components = countComponents(quads);\n                System.out.println(components);\n            }\n        }\n    }\n    \n    static int countComponents(Quad[] quads) {\n        int n = quads.length;\n        boolean[] visited = new boolean[n];\n        int count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, quads, visited);\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    static void dfs(int idx, Quad[] quads, boolean[] visited) {\n        visited[idx] = true;\n        \n        for (int i = 0; i < quads.length; i++) {\n            if (!visited[i] && intersectsOrTouches(quads[idx], quads[i])) {\n                dfs(i, quads, visited);\n            }\n        }\n    }\n    \n    static boolean intersectsOrTouches(Quad q1, Quad q2) {\n        // Check if q1 and q2 overlap or touch\n        if (polygonsIntersect(q1.points, q2.points)) return true;\n        if (polygonContainsPolygon(q1.points, q2.points)) return true;\n        if (polygonContainsPolygon(q2.points, q1.points)) return true;\n        return false;\n    }\n    \n    static boolean polygonsIntersect(Point[] p1, Point[] p2) {\n        // Check edge intersections or touching\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                if (segmentsIntersectOrTouch(p1[i], p1[(i+1)%4], p2[j], p2[(j+1)%4])) {\n                    return true;\n                }\n            }\n        }\n        \n        // Check if any vertex of one is inside the other\n        for (int i = 0; i < 4; i++) {\n            if (pointInOrOnPolygon(p1[i], p2)) return true;\n            if (pointInOrOnPolygon(p2[i], p1)) return true;\n        }\n        \n        return false;\n    }\n    \n    static boolean polygonContainsPolygon(Point[] p1, Point[] p2) {\n        for (int i = 0; i < 4; i++) {\n            if (pointInPolygon(p2[i], p1)) return true;\n        }\n        return false;\n    }\n    \n    static boolean segmentsIntersectOrTouch(Point p1, Point p2, Point p3, Point p4) {\n        double d1 = direction(p3, p4, p1);\n        double d2 = direction(p3, p4, p2);\n        double d3 = direction(p1, p2, p3);\n        double d4 = direction(p1, p2, p4);\n        \n        if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n            ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n            return true;\n        }\n        \n        if (Math.abs(d1) < 1e-9 && onSegment(p3, p4, p1)) return true;\n        if (Math.abs(d2) < 1e-9 && onSegment(p3, p4, p2)) return true;\n        if (Math.abs(d3) < 1e-9 && onSegment(p1, p2, p3)) return true;\n        if (Math.abs(d4) < 1e-9 && onSegment(p1, p2, p4)) return true;\n        \n        return false;\n    }\n    \n    static double direction(Point p1, Point p2, Point p3) {\n        return (p3.x - p1.x) * (p2.y - p1.y) - (p2.x - p1.x) * (p3.y - p1.y);\n    }\n    \n    static boolean onSegment(Point p1, Point p2, Point p) {\n        return Math.min(p1.x, p2.x) <= p.x + 1e-9 && p.x <= Math.max(p1.x, p2.x) + 1e-9 &&\n               Math.min(p1.y, p2.y) <= p.y + 1e-9 && p.y <= Math.max(p1.y, p2.y) + 1e-9;\n    }\n    \n    static boolean pointInOrOnPolygon(Point p, Point[] poly) {\n        return pointInPolygon(p, poly) || pointOnPolygonBoundary(p, poly);\n    }\n    \n    static boolean pointInPolygon(Point p, Point[] poly) {\n        int n = poly.length;\n        boolean inside = false;\n        for (int i = 0, j = n - 1; i < n; j = i++) {\n            if ((poly[i].y > p.y) != (poly[j].y > p.y) &&\n                p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) {\n                inside = !inside;\n            }\n        }\n        return inside;\n    }\n    \n    static boolean pointOnPolygonBoundary(Point p, Point[] poly) {\n        int n = poly.length;\n        for (int i = 0; i < n; i++) {\n            if (Math.abs(direction(poly[i], poly[(i+1)%n], p)) < 1e-9 &&\n                onSegment(poly[i], poly[(i+1)%n], p)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class Point { double x, y; Point(double x, double y) { this.x = x; this.y = y; } } static class Quad { Point[] points; Quad(Point[] points) { this.points = points; } } public static void main(String[]  String line; while ((line = br.readLine()) != null) { int n = Integer.parseInt(line.trim()); if (n == 0) break; for (int i = 0; i < n; i++) { int m = Integer.parseInt(br.readLine().trim()); Quad[] quads =  j++) { String[] tokens = br.readLine().trim().split(\"\\\\s+\"); Point[] points = new Point[4]; for (int k = 0; k < 4; k++) { points[k] = new Point( Double.parseDouble(tokens[k * 2]), Double.parseDouble(tokens[k * 2 + 1]) ); } quads[j] = new Quad(points); }  countComponents(Quad[] quads) { int n = quads.length; boolean[] visited = new boolean[n]; int count = 0; for (int i = 0; i <  } } return count; } static void dfs(int idx, Quad[] quads, boolean[] visited) { visited[idx] = true; for (int  } static boolean intersectsOrTouches(Quad q1, Quad q2) { // Check if q1 and q2 overlap or touch if (polygonsIntersect(q1.points, q2.points)) return true; if (polygonContainsPolygon(q1.points, q2.points)) return true; if (polygonContainsPolygon(q2.points, q1.points)) return true; return false; } static boolean polygonsIntersect(Point[] p1, Point[] p2) { // Check edge intersections or touching for (int i = 0; i < 4; i++) { for (int j = 0; j < 4; j++) { if (segmentsIntersectOrTouch(p1[i], p1[(i+1)%4], p2[j],  any vertex of one  < 4; i++) { if (pointInOrOnPolygon(p1[i], p2)) return true; if (pointInOrOnPolygon(p2[i],  p1, Point[] p2) { for (int i = 0; i < 4; i++) { if (pointInPolygon(p2[i], p1)) return true; } return false; } static boolean segmentsIntersectOrTouch(Point p1, Point p2, Point p3, Point p4) { double d1 = direction(p3, p4, p1); double d2 =  d4 = direction(p1, p2, p4); if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) { return true; } if (Math.abs(d1) < 1e-9 && onSegment(p3, p4, p1)) return true; if (Math.abs(d2) < 1e-9 && onSegment(p3, p4, p2)) return  true; if (Math.abs(d4) < 1e-9 && onSegment(p1, p2, p4)) return true;  p1.y) - (p2.x - p1.x) * (p3.y  p) { return Math.min(p1.x, p2.x) <= p.x + 1e-9 && p.x <= Math.max(p1.x,  && p.y <= Math.max(p1.y, p2.y) + 1e-9; } static boolean pointInOrOnPolygon(Point p, Point[] poly) {  p, Point[] poly) { int n = poly.length; boolean inside = false; for (int i =  = i++) { if ((poly[i].y > p.y) != (poly[j].y > p.y) && p.x < (poly[j].x -  poly[i].x) { inside  p, Point[] poly) { int n = poly.length; for (int i = 0; i < n; i++) { if (Math.abs(direction(poly[i], poly[(i+1)%n], p)) < 1e-9 && onSegment(poly[i], poly[(i+1)%n], p)) { return true; } } return false; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; //Autumnal Illumination public class Main{ int n; int[][][]  = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1]; return x1*y2-x2*y1; } boolean online(int[] s, int[] t, int[] r){ if(cross(s, t,  t[0]); int miny = Math.min(s[1], t[1]), maxy = Math.max(s[1], t[1]); return minx<=r[0]&&r[0]<=maxx&&miny<=r[1]&&r[1]<=maxy; } boolean isCross(int[] a, int[] b, int[] s, int[] t){ if(cross(a, b, s)*cross(a, b, t)>=0)return false; return cross(b, a, s)*cross(b, a, t)<0; } boolean col(int a, int b){ for(int i=0;i<4;i++)for(int j=0;j<4;j++){ if(online(p[a][i], p[a][(i+1)%4], p[b][j]))return  } for(int j=0;j<4;j++){ boolean in = true; for(int i=0;i<4;i++)if(cross(p[a][i], p[a][(i+1)%4], p[b][j])>=0)in = false; if(in)return true; } return false; } void run(){ Scanner sc = new Scanner(System.in); for(;;){ int m = sc.nextInt(); if(m==0)break; while(m--!=0){ n = sc.nextInt(); p = new int[n][4][2]; for(int i=0;i<n;i++)for(int j=0;j<4;j++)for(int k=0;k<2;k++)p[i][j][k]=sc.nextInt(); UnionFind u = new UnionFind(n); for(int i=0;i<n;i++)for(int j=0;j<n;j++){ if(u.find(i,  root(x); y = root(y); if(x != y) { if(tree[x] < tree[y]) { x ^= y; y ^= x; x^=  } boolean find(int x, int y) { return root(x) == root(y); } int root(int x) { return tree[x] < 0 ? x : (tree[x] = root(tree[x])); } int size(int x) { return -tree[root(x)]; } int getNum() { return num; } } public static void main(String[] args) { new Main().run(); } }"], "original_ll": -0.6681732535362244, "sampled_ll": -0.38209161162376404, "all_perturbed_sampled_ll": [-1.0814805030822754], "all_perturbed_original_ll": [-1.3325594663619995], "perturbed_sampled_ll": -1.0814805030822754, "perturbed_original_ll": -1.3325594663619995, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from sys import stdin\nfrom itertools import product\n\ndef chk_in_rect(xy1,xy2):\n    chk = True\n    for i in range(4):\n        for j in range(4):\n            a = (xy1[(2*i+2)&7]-xy1[(2*i  )&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+1)&7])\n            b = (xy1[(2*i+3)&7]-xy1[(2*i+1)&7]) * (xy2[(2*j  )&7]-xy1[(2*i  )&7])\n            if a > b: chk = False; break\n    if chk: return True\n    else: return False\n\ndef chk_intersect(xy1,xy2):\n    for i,j in product(range(4),repeat=2):\n        a = (xy1[(2*i  )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+3)&7])\n        a+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i  )&7]-xy1[(2*j  )&7])\n        b = (xy1[(2*i  )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+3)&7]-xy1[(2*i+3)&7])\n        b+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i  )&7]-xy1[(2*j+2)&7])\n        if a*b < 0 : return True\n    else:\n        return False\n\nwhile(True):\n    try:\n        n = int(stdin.readline())\n        if not n: break\n    except:\n        break\n    for _ in range(n):\n        m = int(stdin.readline())\n        p = list(range(m))\n        xys = [ list(map(int, stdin.readline().split())) for i in range(m) ]\n        # print(n,m,xys)\n        for i in range(m):\n            if len(set(p)) == 1: print(1); break\n            for j in range(i+1,m):\n                if p[i] == p[j]:\n                    continue\n                if chk_in_rect(xys[i],xys[j]):\n                    # print(\"in_rect\")\n                    p = [i if e==j else e for e in p]\n                    continue\n                if chk_intersect(xys[i],xys[j]):\n                    # print(\"intersect\")\n                    p = [i if e==j else e for e in p]\n                    continue\n        else: print(len(set(p)))\n\n\n\n\n", "sampled": "def rectangles_overlap_or_touch(rect1, rect2):\n    # Check if two rectangles overlap or touch (including edges)\n    # rect is list of 4 points [(x1,y1), (x2,y2), (x3,y3), (x4,y4)]\n    \n    # Check if rectangles are separated (no overlap or touch)\n    # Use Separating Axis Theorem (SAT)\n    \n    def get_edges(rect):\n        edges = []\n        for i in range(4):\n            p1 = rect[i]\n            p2 = rect[(i+1)%4]\n            edges.append((p2[0]-p1[0], p2[1]-p1[1]))\n        return edges\n    \n    def get_normals(edges):\n        normals = []\n        for edge in edges:\n            normals.append((-edge[1], edge[0]))\n        return normals\n    \n    def project(rect, axis):\n        dots = []\n        for point in rect:\n            dots.append(point[0]*axis[0] + point[1]*axis[1])\n        return min(dots), max(dots)\n    \n    def overlap(proj1, proj2):\n        return proj1[1] >= proj2[0] and proj2[1] >= proj1[0]\n    \n    edges1 = get_edges(rect1)\n    edges2 = get_edges(rect2)\n    normals = get_normals(edges1) + get_normals(edges2)\n    \n    for normal in normals:\n        proj1 = project(rect1, normal)\n        proj2 = project(rect2, normal)\n        if not overlap(proj1, proj2):\n            return False\n    \n    return True\n\ndef find_connected_components(rectangles):\n    n = len(rectangles)\n    if n == 0:\n        return 0\n    \n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if rectangles_overlap_or_touch(rectangles[i], rectangles[j]):\n                adj[i].append(j)\n                adj[j].append(i)\n    \n    # DFS to count connected components\n    visited = [False] * n\n    components = 0\n    \n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            components += 1\n    \n    return components\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    for _ in range(n):\n        m = int(input())\n        rectangles = []\n        for _ in range(m):\n            coords = list(map(int, input().split()))\n            rect = [(coords[i], coords[i+1]) for i in range(0, 8, 2)]\n            rectangles.append(rect)\n        \n        result = find_connected_components(rectangles)\n        print(result)\n", "perturbed_sampled": ["def rectangles_overlap_or_touch(rect1, rect2): # Check if two rectangles overlap  points [(x1,y1), (x2,y2),  or touch) # Use Separating Axis Theorem (SAT) def get_edges(rect): edges = [] for i in range(4): p1 = rect[i] p2 = rect[(i+1)%4] edges.append((p2[0]-p1[0], p2[1]-p1[1])) return edges def get_normals(edges): normals = [] for  dots = [] for point in rect: dots.append(point[0]*axis[0] + point[1]*axis[1]) return min(dots), max(dots) def overlap(proj1, proj2): return proj1[1] >= proj2[0] and proj2[1]  get_normals(edges1) + get_normals(edges2) for normal in normals: proj1 = project(rect1, normal) proj2 = project(rect2, normal) if not overlap(proj1, proj2): return False return True def find_connected_components(rectangles): n = len(rectangles) if n == 0: return 0 # Build adjacency list adj = [[] for _ in range(n)] for i in range(n): for j in range(i+1, n): if rectangles_overlap_or_touch(rectangles[i], rectangles[j]):  [False] * n components = 0 def  visited[neighbor]: dfs(neighbor) for i in range(n): if not visited[i]: dfs(i) components += 1 return components while True: n = int(input()) if n == 0: break for _ in range(n): m = int(input()) rectangles = []  [(coords[i], coords[i+1]) for i in range(0, 8, 2)] rectangles.append(rect) result = find_connected_components(rectangles) print(result)"], "perturbed_original": ["from sys import stdin from itertools import product def  = (xy1[(2*i+3)&7]-xy1[(2*i+1)&7]) * (xy2[(2*j )&7]-xy1[(2*i  chk: return True else: return False def chk_intersect(xy1,xy2): for i,j in product(range(4),repeat=2): a = (xy1[(2*i )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+3)&7]) a+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i )&7]-xy1[(2*j )&7]) b = (xy1[(2*i )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+3)&7]-xy1[(2*i+3)&7]) b+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i )&7]-xy1[(2*j+2)&7]) if a*b < 0 : return True else: return False while(True): try: n = int(stdin.readline()) if not n:  p = list(range(m)) xys = [ list(map(int, stdin.readline().split())) for i in range(m) ] # print(n,m,xys) for i in range(m): if len(set(p)) == 1: print(1); break for j in range(i+1,m): if p[i] == p[j]: continue if chk_in_rect(xys[i],xys[j]): # print(\"in_rect\") p = [i if e==j else e for e in p] continue if  for e in p] continue else: print(len(set(p)))"], "original_ll": -0.8006585836410522, "sampled_ll": -0.6944035291671753, "all_perturbed_sampled_ll": [-1.5516791343688965], "all_perturbed_original_ll": [-1.3429192304611206], "perturbed_sampled_ll": -1.5516791343688965, "perturbed_original_ll": -1.3429192304611206, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "mx,my;pn[7];px[7][1000],py[7][1000];M[5][7][1000];a0;Calc(a1,a2){int n1,n2,m,mm;for(n2=0;n2<pn[a2];n2++){mm=1e9;for(n1=0;n1<pn[a1];n1++){m=M[a0][a1][n1]+abs(px[a1][n1]-px[a2][n2])+abs(py[a1][n1]-py[a2][n2]);if(m<mm)mm=m;}M[a0][a2][n2]=mm;}}main(){int x,y,c,a,am;for(;scanf(\"%d%d\\n\",&mx,&my),mx;){memset(pn,0,sizeof(pn));for(y=0;y<my;y++){for(x=0;x<=mx;x++){c=getchar();if(c>='1'){if(c<='5')a=c-'0';else if(c=='S')a=0;else if(c=='G')a=6;px[a][pn[a]]=x;py[a][pn[a]++]=y;}}}am=0;for(a0=0;a0<5;a0++){M[a0][0][0]=0;Calc(0,1+(a0+1)%5);for(a=0;a<3;a++)Calc(1+(a0+a+1)%5,1+(a0+a+2)%5);Calc(1+(a0+4)%5,6);if(M[a0][6][0]<M[am][6][0])am=a0;}printf(M[am][6][0]!=1e9?\"%d %d\\n\":\"NA\\n\",1+am,M[am][6][0]);}{int n;for(n=1000000;n--;)getchar();}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX 1000\n#define INF 1000000000\n\ntypedef struct {\n    int x, y, mask;\n} State;\n\ntypedef struct {\n    int x, y;\n} Point;\n\nchar map[MAX][MAX];\nint W, H;\nPoint start, goal;\nPoint creatures[5][MAX];\nint creature_count[5];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\ntypedef struct {\n    State data[MAX * MAX * 32];\n    int front, rear;\n} Queue;\n\nvoid init_queue(Queue *q) {\n    q->front = 0;\n    q->rear = 0;\n}\n\nvoid enqueue(Queue *q, State s) {\n    q->data[q->rear++] = s;\n}\n\nState dequeue(Queue *q) {\n    return q->data[q->front++];\n}\n\nint is_empty(Queue *q) {\n    return q->front == q->rear;\n}\n\nint bfs(int start_attr) {\n    int dist[MAX][MAX][32];\n    int i, j, k;\n    \n    for (i = 0; i < H; i++) {\n        for (j = 0; j < W; j++) {\n            for (k = 0; k < 32; k++) {\n                dist[i][j][k] = INF;\n            }\n        }\n    }\n    \n    Queue q;\n    init_queue(&q);\n    \n    State s;\n    s.x = start.x;\n    s.y = start.y;\n    s.mask = (1 << start_attr);\n    dist[s.x][s.y][s.mask] = 0;\n    enqueue(&q, s);\n    \n    while (!is_empty(&q)) {\n        State cur = dequeue(&q);\n        int cx = cur.x;\n        int cy = cur.y;\n        int cmask = cur.mask;\n        \n        if (cx == goal.x && cy == goal.y && cmask == 31) {\n            return dist[cx][cy][cmask];\n        }\n        \n        for (i = 0; i < 4; i++) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n            \n            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            \n            int nmask = cmask;\n            \n            if (map[nx][ny] >= '1' && map[nx][ny] <= '5') {\n                int attr = map[nx][ny] - '1';\n                int can_catch = 0;\n                \n                for (j = 0; j < 5; j++) {\n                    if (cmask & (1 << j)) {\n                        int catchable = (j + 1) % 5;\n                        if (catchable == attr) {\n                            can_catch = 1;\n                            break;\n                        }\n                    }\n                }\n                \n                if (can_catch) {\n                    nmask |= (1 << attr);\n                }\n            }\n            \n            if (dist[nx][ny][nmask] > dist[cx][cy][cmask] + 1) {\n                dist[nx][ny][nmask] = dist[cx][cy][cmask] + 1;\n                State ns;\n                ns.x = nx;\n                ns.y = ny;\n                ns.mask = nmask;\n                enqueue(&q, ns);\n            }\n        }\n    }\n    \n    return INF;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &W, &H);\n        if (W == 0 && H == 0) break;\n        \n        int i, j;\n        for (i = 0; i < 5; i++) {\n            creature_count[i] = 0;\n        }\n        \n        for (i = 0; i < H; i++) {\n            scanf(\"%s\", map[i]);\n            for (j = 0; j < W; j++) {\n                if (map[i][j] == 'S') {\n                    start.x = i;\n                    start.y = j;\n                } else if (map[i][j] == 'G') {\n                    goal.x = i;\n                    goal.y = j;\n                } else if (map[i][j] >= '1' && map[i][j] <= '5') {\n                    int attr = map[i][j] - '1';\n                    creatures[attr][creature_count[attr]].x = i;\n                    creatures[attr][creature_count[attr]].y = j;\n                    creature_count[attr]++;\n                }\n            }\n        }\n        \n        int min_dist = INF;\n        int best_attr = -1;\n        \n        for (i = 0; i < 5; i++) {\n            int d = bfs(i);\n            if (d < min_dist) {\n                min_dist = d;\n                best_attr = i;\n            }\n        }\n        \n        if (min_dist == INF) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d %d\\n\", best_attr + 1, min_dist);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" INF 1000000000 typedef struct  int x, y; } Point; char map[MAX][MAX]; int W, H; Point start, goal; Point creatures[5][MAX]; int creature_count[5]; int dx[] = {0, 0, 1, -1}; int dy[] = {1, -1, 0, 0}; typedef struct { State data[MAX * MAX * 32]; int front, rear; } Queue; void init_queue(Queue *q) { q->front = 0; q->rear = 0; } void enqueue(Queue *q, State s) { q->data[q->rear++] = s; } State dequeue(Queue *q) { return q->data[q->front++]; } int is_empty(Queue *q) {  dist[MAX][MAX][32]; int i, j,  dist[i][j][k] = INF; } } } Queue q; init_queue(&q); State s; s.x = start.x; s.y = start.y; s.mask = (1 << start_attr); dist[s.x][s.y][s.mask] = 0; enqueue(&q, s); while (!is_empty(&q)) { State cur = dequeue(&q); int cx = cur.x; int cy = cur.y; int  goal.y && cmask == 31) { return dist[cx][cy][cmask]; } for (i = 0; i < 4; i++) { int nx = cx + dx[i]; int ny = cy + dy[i]; if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue; int nmask = cmask; if (map[nx][ny] >= '1' && map[nx][ny] <= '5') { int attr = map[nx][ny] - '1'; int can_catch = 0;  (cmask & (1 <<  if (catchable == attr) { can_catch = 1; break; } } } if (can_catch) { nmask |= (1 << attr); } } if (dist[nx][ny][nmask] > dist[cx][cy][cmask]  enqueue(&q, ns); } } } return INF; } int main() { while (1) { scanf(\"%d %d\", &W,  int i, j; for (i = 0; i < 5;  i < H; i++) { scanf(\"%s\", map[i]); for (j = 0; j < W; j++) { if (map[i][j] == 'S') { start.x = i; start.y = j; } else if (map[i][j] == 'G') { goal.x = i; goal.y = j; } else if  = map[i][j] - '1'; creatures[attr][creature_count[attr]].x = i; creatures[attr][creature_count[attr]].y = j; creature_count[attr]++; } } } int min_dist = INF; int best_attr = -1; for (i = 0; i < 5; i++) { int d = bfs(i); if (d  } if (min_dist == INF) { printf(\"NA\\n\"); } else { printf(\"%d %d\\n\", best_attr + 1, min_dist); } } return 0; }"], "perturbed_original": ["mx,my;pn[7];px[7][1000],py[7][1000];M[5][7][1000];a0;Calc(a1,a2){int n1,n2,m,mm;for(n2=0;n2<pn[a2];n2++){mm=1e9;for(n1=0;n1<pn[a1];n1++){m=M[a0][a1][n1]+abs(px[a1][n1]-px[a2][n2])+abs(py[a1][n1]-py[a2][n2]);if(m<mm)mm=m;}M[a0][a2][n2]=mm;}}main(){int x,y,c,a,am;for(;scanf(\"%d%d\\n\",&mx,&my),mx;){memset(pn,0,sizeof(pn));for(y=0;y<my;y++){for(x=0;x<=mx;x++){c=getchar();if(c>='1'){if(c<='5')a=c-'0';else if(c=='S')a=0;else if(c=='G')a=6;px[a][pn[a]]=x;py[a][pn[a]++]=y;}}}am=0;for(a0=0;a0<5;a0++){M[a0][0][0]=0;Calc(0,1+(a0+1)%5);for(a=0;a<3;a++)Calc(1+(a0+a+1)%5,1+(a0+a+2)%5);Calc(1+(a0+4)%5,6);if(M[a0][6][0]<M[am][6][0])am=a0;}printf(M[am][6][0]!=1e9?\"%d %d\\n\":\"NA\\n\",1+am,M[am][6][0]);}{int n;for(n=1000000;n--;)getchar();}exit(0);}"], "original_ll": -1.6285407543182373, "sampled_ll": -0.46010008454322815, "all_perturbed_sampled_ll": [-1.1967453956604004], "all_perturbed_original_ll": [-1.6285407543182373], "perturbed_sampled_ll": -1.1967453956604004, "perturbed_original_ll": -1.6285407543182373, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\t/** ????\u00a7??????? */\n\tstatic final String WHITE_SPACE = \" \";\n\n\t/** ??????????????????_X */\n\tstatic int mapSizeX = 0;\n\n\t/** ??????????????????_Y */\n\tstatic int mapSizeY = 0;\n\n\t/** ??????????????\u00b0 */\n\tstatic int maxNode = 0;\n\n\t/** ????????\u00a2??????????????? */\n\tstatic List<Point> pachimonList = new ArrayList<Point>();\n\n\t/** ?????????????\u00a8??????????????????????????\u00b4??????? */\n\tstatic boolean[] visited = new boolean[5003];\n\n\t/** ??????????????????????????? */\n\tstatic int[] cost = new int[5003];\n\n\t/** ?????????????????? */\n\tstatic int startIdx = 0;\n\n\t/** ??\u00b4???????????? */\n\tstatic int goalIdx = 0;\n\n\t/**\n\t * @param args\n\t * @throws IOException\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\tString[] mapSizeLine = new String[2];\n\t\tPoint output = createPos(0, Integer.MAX_VALUE);\n\t\twhile (true) {\n\t\t\tmapSizeLine = br.readLine().split(WHITE_SPACE);\n\t\t\tmapSizeX = Integer.parseInt(mapSizeLine[0]);\n\t\t\tmapSizeY = Integer.parseInt(mapSizeLine[1]);\n\t\t\tif (mapSizeX == 0 && mapSizeY == 0)\n\t\t\t\tbreak;\n\n\t\t\treadMap(br);\n\t\t\toutput.x = 0;\n\t\t\toutput.y = Integer.MAX_VALUE;\n\t\t\tif (maxNode > 5) {\n\t\t\t\tfor (int type = 1; type <= 5; type++) {\n\t\t\t\t\t// ??????????????????????????\u00a2??????????????????????????????????????????????\u00b4\u00a2\n\t\t\t\t\tint cost = searchRoute(type);\n\t\t\t\t\tif (cost < output.y && cost > 0) {\n\t\t\t\t\t\toutput.x = type;\n\t\t\t\t\t\toutput.y = cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ???????????????\n\t\t\tif (output.y == Integer.MAX_VALUE) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(output.x + WHITE_SPACE + output.y);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * ?????????????????????????????????\n\t * @param scanner ????????\u00a3??????\n\t * @throws IOException\n\t */\n\tprivate static void readMap(BufferedReader br) throws IOException {\n\t\t// ??????????????\u00b1????????????\n\t\tpachimonList.removeAll(pachimonList);\n\t\tmaxNode = 0;\n\t\tstartIdx = 0;\n\n\t\tfor (int i = 0; i < mapSizeY; i++) {\n\t\t\tfor (int j = 0; j < mapSizeX; j++) {\n\t\t\t\tint val = convertInt(br.read());\n\t\t\t\tif (val < 9) {\n\t\t\t\t\t// ???????????\u00a2????????\u00b0????\u00a8????\n\t\t\t\t\tif (val == 0)\n\t\t\t\t\t\tstartIdx = pachimonList.size();\n\t\t\t\t\tif (val == 6)\n\t\t\t\t\t\tgoalIdx = pachimonList.size();\n\t\t\t\t\tpachimonList.add(createPos(val, calcIndex(j, i)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????????????\u00a3???\u00b0???\n\t\t\tbr.readLine();\n\t\t}\n\t\tmaxNode = pachimonList.size();\n\t}\n\n\t/**\n\t * ??\u00a2????????????????????????int??????????????????\n\t * @param target ????\u00b1??????????\n\t * @return ???????????????\n\t */\n\tprivate static int convertInt(int target) {\n\t\tif (target == 83)\n\t\t\treturn 0;\n\t\tif (target == 71)\n\t\t\treturn 6;\n\t\tif (target >= 49 && target <= 53)\n\t\t\treturn target - 48;\n\t\treturn 9;\n\t}\n\n\t/**\n\t * X????????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7????\u00a8????<br>\n\t * ????????????:0?????\u00b4??????:6???????????\u00a2???????\u00b1???\u00a7:1???5<br>\n\t * Y????????????????????????????????????????\u00b4?\n\t * @param type ?????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7\n\t * @param index ??????????????????????????????\n\t * @return\n\t */\n\tprivate static Point createPos(int type, int index) {\n\t\treturn new Point(type, index);\n\t}\n\n\t/**\n\t * ?????\u00a8????????\u00a2???????????????????????????????????????????????\u00a2???????\u00b1???\u00a7?????????\n\t * @param currentType ??????????????????????????\u00a2???????\u00b1???\u00a7\n\t * @return ?????????????????????????????\u00a2???????\u00b1???\u00a7\n\t */\n\tprivate static int getNextType(int currentType) {\n\t\tif (currentType == 5)\n\t\t\treturn 1;\n\t\treturn currentType + 1;\n\t}\n\n\t/**\n\t * ??????????????????????????\u00a2?????????????????????????????????????????\u00a2???????\u00b1???\u00a7?????????\n\t * @param firstType ??????????????????????????\u00a2???????\u00b1???\u00a7\n\t * @return ?????????????????????????????\u00a2???????\u00b1???\u00a7\n\t */\n\tprivate static int getEndType(int firstType) {\n\t\tif (firstType == 1)\n\t\t\treturn 5;\n\t\treturn firstType - 1;\n\t}\n\n\t/**\n\t * ??\u00a3??\\??????????\u00a8?????????????????????????????????\u00b4???????????\u00a7???<br>\n\t * ????????????????????????????\u00b1???????\n\t * @param adjacent ??\u00a3??\\??????\n\t * @return ????????????????????????\n\t */\n\tprivate static int searchRoute(int firstType) {\n\n\t\tfor (int i = 0; i < maxNode; i++) {\n\t\t\tcost[i] = Integer.MAX_VALUE;\n\t\t\tvisited[i] = false;\n\t\t}\n\n\t\t// ??????????????\u00b0????????\u00a7???????????????0\n\t\tcost[startIdx] = 0;\n\n\t\twhile (true) {\n\t\t\t// ?\u00a8?????????????????????????????????\u00a7?????????????????????????\u00b1???????\n\t\t\tint node = minIndex(cost, visited);\n\t\t\tif (node < 0) {\n\t\t\t\treturn cost[goalIdx];\n\t\t\t}\n\t\t\t// ??\u00a2?\u00b4\u00a2???????????????????????????????????\u00b0????????????\n\t\t\tvisited[node] = true;\n\t\t\tfor (int j = 0; j < maxNode; j++) {\n\t\t\t\tif (isLinked(node, j, firstType) && !visited[j]) {\n\t\t\t\t\tint nextNodeCost = cost[node] + clucCost(pachimonList.get(node), pachimonList.get(j));\n\t\t\t\t\t// ????????\u00a7????????\u00a2??????????\u00b0????????????\u00b0???????????\u00a2??\u00a8???????\u00a8???\u00b6\n\t\t\t\t\tif (nextNodeCost < cost[j]) {\n\t\t\t\t\t\tcost[j] = nextNodeCost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * ?????\u00a8??????????????\u00a8????\u00b1??????????????????\\?\u00b6?????????????????????????????????\\\n\t * @param node ?????\u00a8????????????\n\t * @param target ????\u00b1?????????????\n\t * @return ?????\\??????\n\t */\n\tprivate static boolean isLinked(int node, int target, int firstType) {\n\t\tint currentType = pachimonList.get(node).x;\n\t\tint targetType = pachimonList.get(target).x;\n\t\t// ??????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????????????????????????????????????????\\?\u00b6????????????????\n\t\tif (currentType == firstType)\n\t\t\treturn false;\n\t\t// ????\u00b1??????????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????\u00b4????????\\?\u00b6????????????????\n\t\tif (targetType == firstType)\n\t\t\treturn false;\n\t\t// ??????????????\u00b4???????????\u00b4????????\\?\u00b6??????????????????????????????????\n\t\tif (currentType == maxNode)\n\t\t\treturn false;\n\n\t\t// ????????????????????????(\"0\")?????\u00b4??????????\u00b1???????????????????????????\u00a2???????\u00b1???\u00a7????\u00ac?????????\\?\u00b6????????????????\n\t\tif (currentType == 0)\n\t\t\treturn targetType == getNextType(firstType);\n\n\t\t// ?????\u00a8????????????????\u00b1???\u00a7????????????????????????????????\u00a2????????\u00b4????????\u00b4??????????????\\?\u00b6?\n\t\tif (currentType == getEndType(firstType))\n\t\t\treturn targetType == 6;\n\n\t\treturn getNextType(currentType) == targetType;\n\t}\n\n\t/**\n\t * ?\u00a8???????????????????????????????????????????????????????????????????????????????????\u00b1???????\n\t * @param cost ???????????????????????????\n\t * @param visited ?????????????\u00a8??????????????????????????\u00b4???????\n\t * @return ??????????????????\n\t */\n\tprivate static int minIndex(int[] cost, boolean[] visited) {\n\t\tint index = 0;\n\t\tfor (; index < maxNode; index++) {\n\t\t\tif (!visited[index])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (index == maxNode)\n\t\t\treturn -1;\n\t\tfor (int i = index + 1; i < maxNode; i++) {\n\t\t\tif (!visited[i] && cost[i] < cost[index])\n\t\t\t\tindex = i;\n\t\t}\n\t\treturn index;\n\t}\n\n\t/**\n\t * ????????????????????????????????\u00b4???????????\u00a7????????????????\u00a8?????????????\n\t * @param sx ???????????????X??\u00a7?\u00a8?\n\t * @param sy ???????????????Y??\u00a7?\u00a8?\n\t * @param gx ??\u00b4?????????X??\u00a7?\u00a8?\n\t * @param gy ??\u00b4?????????Y??\u00a7?\u00a8?\n\t * @param nextType ?\u00ac????????????????????????\u00a2????\u00b1???\u00a7\n\t */\n\tprivate static int clucCost(Point from, Point to) {\n\t\tint fx = from.y / mapSizeY;\n\t\tint fy = from.y % mapSizeY;\n\t\tint tx = to.y / mapSizeY;\n\t\tint ty = to.y % mapSizeY;\n\t\treturn Math.abs(tx - fx) + Math.abs(ty - fy);\n\t}\n\n\t/**\n\t * X??\u00a7?\u00a8???\u00a8Y??\u00a7?\u00a8???????????????\u00a3?????????????????????????????????????????\u00b4?????????\n\t *\n\t * @param x X??\u00a7?\u00a8?\n\t * @param y Y??\u00a7?\u00a8?\n\t * @return\n\t */\n\tprivate static int calcIndex(int x, int y) {\n\t\treturn x * mapSizeY + y;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] tokens = line.trim().split(\"\\\\s+\");\n            int W = Integer.parseInt(tokens[0]);\n            int H = Integer.parseInt(tokens[1]);\n            \n            if (W == 0 && H == 0) break;\n            \n            char[][] map = new char[H][W];\n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            \n            for (int i = 0; i < H; i++) {\n                String row = br.readLine();\n                for (int j = 0; j < W; j++) {\n                    map[i][j] = row.charAt(j);\n                    if (map[i][j] == 'S') {\n                        sx = i;\n                        sy = j;\n                    } else if (map[i][j] == 'G') {\n                        gx = i;\n                        gy = j;\n                    }\n                }\n            }\n            \n            int minDist = Integer.MAX_VALUE;\n            int bestAttr = -1;\n            \n            for (int startAttr = 1; startAttr <= 5; startAttr++) {\n                int dist = solve(map, H, W, sx, sy, gx, gy, startAttr);\n                if (dist != -1 && dist < minDist) {\n                    minDist = dist;\n                    bestAttr = startAttr;\n                }\n            }\n            \n            if (bestAttr == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(bestAttr + \" \" + minDist);\n            }\n        }\n    }\n    \n    static int solve(char[][] map, int H, int W, int sx, int sy, int gx, int gy, int startAttr) {\n        int targetMask = 0;\n        for (int i = 1; i <= 5; i++) {\n            if (i != startAttr) {\n                targetMask |= (1 << i);\n            }\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Map<String, Integer> visited = new HashMap<>();\n        \n        int initialMask = (1 << startAttr);\n        State start = new State(sx, sy, initialMask, 0);\n        queue.offer(start);\n        visited.put(sx + \",\" + sy + \",\" + initialMask, 0);\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.x == gx && curr.y == gy && (curr.mask & targetMask) == targetMask) {\n                return curr.dist;\n            }\n            \n            for (int d = 0; d < 4; d++) {\n                int nx = curr.x + dx[d];\n                int ny = curr.y + dy[d];\n                \n                if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                \n                int newMask = curr.mask;\n                char cell = map[nx][ny];\n                \n                if (cell >= '1' && cell <= '5') {\n                    int attr = cell - '0';\n                    if (canCatch(curr.mask, attr)) {\n                        newMask |= (1 << attr);\n                    }\n                }\n                \n                String key = nx + \",\" + ny + \",\" + newMask;\n                if (!visited.containsKey(key) || visited.get(key) > curr.dist + 1) {\n                    visited.put(key, curr.dist + 1);\n                    queue.offer(new State(nx, ny, newMask, curr.dist + 1));\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static boolean canCatch(int mask, int target) {\n        int[] catchMap = {0, 2, 3, 4, 5, 1}; // 1->2, 2->3, 3->4, 4->5, 5->1\n        for (int i = 1; i <= 5; i++) {\n            if ((mask & (1 << i)) != 0 && catchMap[i] == target) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    static class State {\n        int x, y, mask, dist;\n        \n        State(int x, int y, int mask, int dist) {\n            this.x = x;\n            this.y = y;\n            this.mask = mask;\n            this.dist = dist;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import  0, 1, -1}; static int[] dy = {1, -1, 0, 0}; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] tokens = line.trim().split(\"\\\\s+\");  == 0 && H == 0) break; char[][] map = new char[H][W]; int sx =  for (int i = 0; i < H; i++) { String row = br.readLine(); for (int j = 0; j < W; j++) {  i; sy = j; } else if (map[i][j] == 'G') { gx  = Integer.MAX_VALUE; int bestAttr = -1; for  dist = solve(map, H, W, sx, sy, gx, gy, startAttr); if (dist != -1 && dist < minDist) { minDist = dist; bestAttr = startAttr; } } if (bestAttr == -1) { System.out.println(\"NA\"); } else { System.out.println(bestAttr + \" \" + minDist); } } } static int solve(char[][] map, int H, int W, int  int targetMask = 0; for (int i = 1; i <= 5; i++) { if (i != startAttr) { targetMask |= (1 << i); } } Queue<State> queue = new LinkedList<>(); Map<String, Integer> visited = new HashMap<>(); int initialMask = (1 << startAttr); State start = new State(sx, sy, initialMask, 0); queue.offer(start); visited.put(sx + \",\" + sy + \",\" + initialMask, 0); while (!queue.isEmpty()) { State curr = queue.poll(); if (curr.x == gx && curr.y == gy && (curr.mask & targetMask) ==  d < 4; d++) { int nx = curr.x + dx[d];  ny >= W) continue; int newMask = curr.mask; char cell = map[nx][ny]; if (cell >= '1' && cell <= '5') { int attr = cell - '0'; if (canCatch(curr.mask, attr))  newMask; if (!visited.containsKey(key) || visited.get(key) > curr.dist + 1) { visited.put(key, curr.dist + 1); queue.offer(new State(nx, ny, newMask, curr.dist + 1)); } } } return -1; } static boolean canCatch(int mask, int target) { int[] catchMap = {0, 2, 3, 4, 5, 1}; // 1->2, 2->3, 3->4, 4->5, 5->1  catchMap[i] ==  class State { int x, y, mask, dist; State(int x, int y, int mask, int dist) { this.x = x; this.y = y; this.mask = mask; this.dist = dist; } } }"], "perturbed_original": ["import java.awt.Point; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.List; public class Main { /** ????\u00a7??????? */ static final String WHITE_SPACE = \" \"; /** ??????????????????_X */ static int mapSizeX = 0;  */ static int maxNode  ArrayList<Point>(); /** ?????????????\u00a8??????????????????????????\u00b4??????? */ static boolean[] visited = new boolean[5003];  ?????????????????? */ static int startIdx = 0; /** ??\u00b4???????????? */ static int goalIdx = 0; /** * @param args * @throws IOException */ public static void main(String[] args) throws IOException { InputStreamReader is = new  String[2]; Point output = createPos(0, Integer.MAX_VALUE); while (true) { mapSizeLine = br.readLine().split(WHITE_SPACE); mapSizeX = Integer.parseInt(mapSizeLine[0]); mapSizeY = Integer.parseInt(mapSizeLine[1]); if (mapSizeX == 0 && mapSizeY == 0) break; readMap(br); output.x = 0; output.y = Integer.MAX_VALUE; if (maxNode > 5) { for (int type = 1; type <= 5; type++) { // ??????????????????????????\u00a2??????????????????????????????????????????????\u00b4\u00a2 int cost = searchRoute(type); if (cost < output.y && cost > 0) { output.x = type; output.y = cost; } } } //   ????????????????????????????????? * @param scanner ????????\u00a3?????? * @throws IOException */ private static void readMap(BufferedReader br) throws IOException { // ??????????????\u00b1???????????? pachimonList.removeAll(pachimonList);  0; i < mapSizeY; i++) { for (int j = 0; j < mapSizeX; j++) { int val = convertInt(br.read()); if (val < 9) { // ???????????\u00a2????????\u00b0????\u00a8???? if (val == 0) startIdx = pachimonList.size(); if (val == 6) goalIdx = pachimonList.size(); pachimonList.add(createPos(val, calcIndex(j, i))); } } // ????????????????\u00a3???\u00b0??? br.readLine(); } maxNode = pachimonList.size();  ??????????????? */ private  0; if (target == 71) return 6;  - 48; return 9; } /** * X????????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7????\u00a8????<br> * ????????????:0?????\u00b4??????:6???????????\u00a2???????\u00b1???\u00a7:1???5<br> *  @return */ private static Point createPos(int type, int index) { return new Point(type, index); } /** * ?????\u00a8????????\u00a2???????????????????????????????????????????????\u00a2???????\u00b1???\u00a7????????? * @param currentType ??????????????????????????\u00a2???????\u00b1???\u00a7 * @return ?????????????????????????????\u00a2???????\u00b1???\u00a7 */ private static int getNextType(int currentType) { if (currentType == 5) return 1; return currentType + 1; } /** * ??????????????????????????\u00a2?????????????????????????????????????????\u00a2???????\u00b1???\u00a7????????? * @param firstType ??????????????????????????\u00a2???????\u00b1???\u00a7 * @return ?????????????????????????????\u00a2???????\u00b1???\u00a7 */ private static int getEndType(int firstType) { if (firstType == 1) return 5; return firstType -  ??\u00a3??\\?????? * @return ???????????????????????? */ private static int searchRoute(int firstType) { for (int i = 0; i <  // ??????????????\u00b0????????\u00a7???????????????0 cost[startIdx] = 0; while (true) { // ?\u00a8?????????????????????????????????\u00a7?????????????????????????\u00b1??????? int node = minIndex(cost, visited); if (node < 0) { return cost[goalIdx]; } // ??\u00a2?\u00b4\u00a2???????????????????????????????????\u00b0???????????? visited[node] = true; for (int j = 0; j  { int nextNodeCost = cost[node] +  = nextNodeCost; } } } } } /** * ?????\u00a8??????????????\u00a8????\u00b1??????????????????\\?\u00b6?????????????????????????????????\\ * @param node ?????\u00a8????????????  boolean  pachimonList.get(node).x; int targetType = pachimonList.get(target).x; // ??????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????????????????????????????????????????\\?\u00b6???????????????? if (currentType == firstType) return false; // ????\u00b1??????????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????\u00b4????????\\?\u00b6???????????????? if (targetType == firstType) return false; // ??????????????\u00b4???????????\u00b4????????\\?\u00b6?????????????????????????????????? if (currentType == maxNode) return false; // ????????????????????????(\"0\")?????\u00b4??????????\u00b1???????????????????????????\u00a2???????\u00b1???\u00a7????\u00ac?????????\\?\u00b6???????????????? if (currentType == 0) return targetType == getNextType(firstType); // ?????\u00a8????????????????\u00b1???\u00a7????????????????????????????????\u00a2????????\u00b4????????\u00b4??????????????\\?\u00b6? if (currentType == getEndType(firstType)) return targetType == 6; return getNextType(currentType)  * @param visited ?????????????\u00a8??????????????????????????\u00b4??????? * @return ?????????????????? */ private static int minIndex(int[] cost,  < maxNode; index++) { if (!visited[index]) break; } if (index ==  i < maxNode; i++) { if (!visited[i] && cost[i] < cost[index]) index = i; } return index; } /** * ????????????????????????????????\u00b4???????????\u00a7????????????????\u00a8????????????? * @param sx ???????????????X??\u00a7?\u00a8? * @param sy ???????????????Y??\u00a7?\u00a8? * @param gx ??\u00b4?????????X??\u00a7?\u00a8? * @param gy ??\u00b4?????????Y??\u00a7?\u00a8? * @param nextType ?\u00ac????????????????????????\u00a2????\u00b1???\u00a7  fx = from.y / mapSizeY; int fy = from.y % mapSizeY; int tx = to.y / mapSizeY; int ty = to.y % mapSizeY;  * X??\u00a7?\u00a8???\u00a8Y??\u00a7?\u00a8???????????????\u00a3?????????????????????????????????????????\u00b4????????? * * @param x X??\u00a7?\u00a8? * @param  int y) { return x * mapSizeY + y; } }"], "original_ll": -1.0931262969970703, "sampled_ll": -0.43971604108810425, "all_perturbed_sampled_ll": [-1.3130877017974854], "all_perturbed_original_ll": [-1.747665286064148], "perturbed_sampled_ll": -1.3130877017974854, "perturbed_original_ll": -1.747665286064148, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import product\n# from line_profiler import LineProfiler\ndef main():\n    while(True):\n        W, H = map(int,input().split())\n        if not W: break\n        # ma = [[-1]*(W+2) for _ in range(H+2)]\n        ps = [[] for _ in range(5)]\n        ans = 10**10\n        for i in range(H):\n            for j,a in enumerate(input()):\n                if a == \"S\": ss = [[i,j]]\n                elif a == \"G\": gg = [[i,j]]\n                elif a != \".\": ps[int(a)-1].append([i,j])\n        # if [1 for i in range(5) if len(ps[i])==0]:\n        #     print(\"NA\"); continue\n        # print(ps)\n        B = float(\"inf\")\n        Bi = -1\n        for mon1 in range(5):\n            dp = [[float(\"inf\")]*1000 for _ in range(5)]\n            cand = [[0,ss[0][0],ss[0][1]]]\n            for mon2 in range(5):\n                dpCacheNow = dp[mon2]\n                dpCacheNxt = dp[(mon1+mon2+1)%5]\n                dpCacheNow[0] = 0\n                nxt = ps[(mon1+mon2+1)%5] if mon2<4 else gg\n                # print(nxt)\n                # print(cand)\n                tmp = []\n                for i,[ty,tx] in enumerate(nxt):\n                    # if dpCacheNow[i] >= B:\n                    #     continue\n                    tc = float(\"inf\")\n                    # for cc,cy,cx in cand:\n                    for cc,cy,cx in cand:\n                        if cc > B:\n                            # print(\"a\",end=\"\")\n                            tc = float(\"inf\")\n                            break\n                        else:\n                            tc = min(tc,abs(ty-cy)+abs(tx-cx)+cc)\n                    tmp.append([tc,ty,tx])\n                    dpCacheNxt[i] = min(dpCacheNxt[i],tc)\n                cand = tmp\n            if cand[0][0] < B:\n                B = cand[0][0]\n                Bi = mon1\n        if(Bi == -1):\n            print(\"NA\")\n        else:\n            print(\"%d %d\"%(Bi+1,B))\n        # for mon1 in range(5):\n        #     mon2 = (mon1+1)%5\n        #     dp = [[10**10]*1000 for _ in range(5)]\n        #     for i,yx in enumerate(ps[mon2]):\n        #         dp[mon2][i] = abs(ss[0]-yx[0])+abs(ss[1]-yx[1])\n        #     mon3 = mon2\n        #     for mon3 in range(mon2,mon2+3):\n        #         mon3 = mon3%5\n        #         mon4 = (mon3+1)%5\n        #         for [i,yx],[j,nyx] in product(enumerate(ps[mon3]),enumerate(ps[mon4])):\n        #             dp[mon4][j] = min(dp[mon4][j],dp[mon3][i]+abs(yx[0]-nyx[0])+abs(yx[1]-nyx[1]))\n        #     mon5 = (mon1-1)%5\n        #     for i,yx in enumerate(ps[mon5]):\n        #         d = dp[mon5][i] + abs(gg[0]-yx[0])+abs(gg[1]-yx[1])\n        #         if ans > d:\n        #             ans,ansi = d,mon1\n        # print(ansi+1,ans)\n\nif __name__ == \"__main__\":\n    # prf = LineProfiler()\n    # prf.add_function(main)\n    # prf.runcall(main)\n    # prf.print_stats()\n    main()\n", "sampled": "from collections import deque\nimport sys\n\ndef bfs(grid, start, H, W):\n    \"\"\"BFS to find shortest distances from start to all positions\"\"\"\n    dist = [[-1] * W for _ in range(H)]\n    queue = deque([start])\n    dist[start[0]][start[1]] = 0\n    \n    while queue:\n        r, c = queue.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and dist[nr][nc] == -1:\n                dist[nr][nc] = dist[r][c] + 1\n                queue.append((nr, nc))\n    \n    return dist\n\ndef solve(W, H, grid):\n    # Find S and G positions\n    start = goal = None\n    creatures = {1: [], 2: [], 3: [], 4: [], 5: []}\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n            elif grid[i][j] in '12345':\n                creatures[int(grid[i][j])].append((i, j))\n    \n    # can_catch[attr] gives which attribute attr can catch\n    can_catch = {1: 2, 2: 3, 3: 4, 4: 5, 5: 1}\n    \n    # Compute distances from start and goal\n    dist_from_start = bfs(grid, start, H, W)\n    dist_from_goal = bfs(grid, goal, H, W)\n    \n    # For each creature position, compute distance from start and to goal\n    creature_dists = {}\n    for attr in range(1, 6):\n        creature_dists[attr] = []\n        for pos in creatures[attr]:\n            ds = dist_from_start[pos[0]][pos[1]]\n            dg = dist_from_goal[pos[0]][pos[1]]\n            if ds != -1 and dg != -1:\n                creature_dists[attr].append((ds, dg, pos))\n    \n    best_attr = None\n    best_dist = float('inf')\n    \n    # Try each starting attribute\n    for start_attr in range(1, 6):\n        # Need to catch the other 4 attributes\n        to_catch = [attr for attr in range(1, 6) if attr != start_attr]\n        \n        # Check if we can catch all required attributes\n        can_solve = True\n        for attr in to_catch:\n            if not creature_dists[attr]:\n                can_solve = False\n                break\n        \n        if not can_solve:\n            continue\n        \n        # State: (current_attr, caught_set) where caught_set is a frozenset of caught attributes\n        # We want to find minimum distance to reach goal with all attributes caught\n        \n        # Use Dijkstra-like approach with states\n        from heapq import heappush, heappop\n        \n        initial_state = (start_attr, frozenset([start_attr]))\n        # dist_state[(attr, caught)] = minimum distance to have attr and caught set\n        dist_state = {}\n        dist_state[initial_state] = 0\n        pq = [(0, start_attr, frozenset([start_attr]))]\n        \n        min_dist_to_goal = float('inf')\n        \n        while pq:\n            d, curr_attr, caught = heappop(pq)\n            \n            if d > dist_state.get((curr_attr, caught), float('inf')):\n                continue\n            \n            # Check if we have all attributes and can go to goal\n            if len(caught) == 5:\n                min_dist_to_goal = min(min_dist_to_goal, d + dist_from_goal[start[0]][start[1]])\n                continue\n            \n            # Try to catch next creature\n            next_attr = can_catch[curr_attr]\n            if next_attr not in caught and creature_dists[next_attr]:\n                # Find closest creature of next_attr from current position\n                # We need to track position too...\n                \n                for ds, dg, pos in creature_dists[next_attr]:\n                    new_caught = caught | {next_attr}\n                    new_dist = ds  # Distance from start to this creature\n                    new_state = (next_attr, new_caught)\n                    \n                    if new_dist < dist_state.get(new_state, float('inf')):\n                        dist_state[new_state] = new_dist\n                        heappush(pq, (new_dist, next_attr, new_caught))\n        \n        # This approach is getting complex. Let me try simpler state space.\n        # State: frozenset of caught attributes\n        # For each state, track minimum distance and where we are\n        \n        # Actually, let's use different approach\n        # Try all permutations of catching order and compute minimum\n        \n        from itertools import permutations\n        \n        for order in permutations(to_catch):\n            # Check if this order is valid (can catch in sequence)\n            current_attr = start_attr\n            valid = True\n            for attr in order:\n                if can_catch[current_attr] != attr:\n                    valid = False\n                    break\n                current_attr = attr\n            \n            if not valid:\n                continue\n            \n            # Compute minimum distance for this order\n            total_dist = 0\n            prev_pos = start\n            valid_path = True\n            \n            for attr in order:\n                # Find closest creature of this attribute from prev_pos\n                min_d = float('inf')\n                next_pos = None\n                \n                for pos in creatures[attr]:\n                    # BFS from prev_pos to pos\n                    d = dist_from_start[pos[0]][pos[1]]  # This is wrong, need distance from prev_pos\n                    \n                # This is getting complicated. Need to precompute all distances\n                \n        # Let me use a simpler DP approach with memoization\n        \n    # Simpler approach: try all orderings using DP\n    # Actually the constraints make this feasible\n    \n    # For each starting attribute, do BFS on state space\n    for start_attr in range(1, 6):\n        # BFS on (position, caught_set)\n        initial = (start, frozenset([start_attr]), start_attr)\n        queue = deque([initial])\n        visited = {(start, frozenset([start_attr]), start_attr): 0}\n        \n        while queue:\n            pos, caught, curr_attr = queue.popleft()\n            dist = visited[(pos, caught, curr_attr)]\n            \n            # If we have all 5 attributes and at goal\n            if len(caught) == 5 and pos == goal:\n                if dist < best_dist or (dist == best_dist and start_attr < best_attr):\n                    best_dist = dist\n                    best_attr = start_attr\n                continue\n            \n            # Try moving to adjacent cells\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = pos[0] + dr, pos[1] + dc\n                if 0 <= nr < H and 0 <= nc < W:\n                    new_pos = (nr, nc)\n                    new_caught = caught\n                    new_attr = curr_attr\n                    \n                    # Check if we catch a creature here\n                    cell = grid[nr][nc]\n                    if cell in '12345':\n                        creature_attr = int(cell)\n                        if can_catch[curr_attr] == creature_attr:\n                            new_caught = caught | {creature_attr}\n                            new_attr = creature_attr\n                    \n                    new_state = (new_pos, new_caught, new_attr)\n                    if new_state not in visited or visited[new_state] > dist + 1:\n                        visited[new_state] = dist + 1\n                        queue.append(new_state)\n    \n    if best_attr is None:\n        return \"NA\"\n    else:\n        return f\"{best_attr} {best_dist}\"\n\nwhile True:\n    line = input().split()\n    W, H = int(line[0]), int(line[1])\n    if W == 0 and H == 0:\n        break\n    \n    grid = []\n    for _ in range(H):\n        grid.append(input().strip())\n    \n    print(solve(W, H, grid))\n", "perturbed_sampled": ["from collections import deque import sys def bfs(grid, start, H, W): \"\"\"BFS to find shortest distances from start to all positions\"\"\" dist = [[-1] * W for _ in range(H)] queue = deque([start]) dist[start[0]][start[1]] = 0 while queue: r, c = queue.popleft() for dr,  nr, nc = r + dr, c + dc if 0 <= nr < H and 0 <= nc < W and dist[nr][nc] == -1: dist[nr][nc] = dist[r][c] + 1 queue.append((nr, nc)) return dist def solve(W,  goal = None creatures = {1: [], 2: [], 3: [], 4: [], 5: []} for i in range(H): for j in range(W): if  'G': goal = (i, j) elif grid[i][j] in '12345': creatures[int(grid[i][j])].append((i, j)) # can_catch[attr] gives which attribute attr can catch can_catch = {1: 2, 2: 3, 3: 4, 4: 5, 5: 1} # Compute distances from start and goal dist_from_start = bfs(grid, start, H, W) dist_from_goal = bfs(grid,  from start and to goal  [] for pos in creatures[attr]: ds = dist_from_start[pos[0]][pos[1]] dg = dist_from_goal[pos[0]][pos[1]] if ds != -1 and dg != -1: creature_dists[attr].append((ds, dg, pos)) best_attr = None best_dist = float('inf') # Try each starting attribute for start_attr in range(1, 6): # Need to catch the other 4 attributes to_catch = [attr  Check if we can catch all required attributes can_solve = True for attr in to_catch: if not  caught attributes # We want to find minimum distance to reach goal with all attributes caught # Use Dijkstra-like approach with states  dist_state[(attr, caught)] = minimum distance to have attr and caught set dist_state = {} dist_state[initial_state] = 0 pq = [(0, start_attr, frozenset([start_attr]))] min_dist_to_goal = float('inf') while pq: d, curr_attr, caught = heappop(pq) if d  all attributes and can go to goal if len(caught) == 5: min_dist_to_goal = min(min_dist_to_goal, d + dist_from_goal[start[0]][start[1]]) continue # Try to catch next creature next_attr = can_catch[curr_attr] if next_attr not in caught and creature_dists[next_attr]: #  need to track position too... for ds, dg, pos in creature_dists[next_attr]: new_caught = caught | {next_attr} new_dist = ds # Distance from start to this creature new_state = (next_attr, new_caught) if new_dist < dist_state.get(new_state, float('inf')): dist_state[new_state] = new_dist heappush(pq, (new_dist, next_attr, new_caught)) # This approach is getting complex. Let me try simpler state space. # State: frozenset of caught attributes # For each state, track minimum distance and where we are # Actually, let's use different approach # Try all  permutations for order in permutations(to_catch): # Check if this  valid = True for attr in order: if can_catch[current_attr] != attr: valid = False break current_attr = attr if not valid: continue # Compute minimum distance for this order total_dist = 0 prev_pos = start valid_path = True for attr in order: # Find closest creature of this attribute from prev_pos min_d = float('inf') next_pos = None for pos  dist_from_start[pos[0]][pos[1]] # This is wrong, need distance from prev_pos  # Let me use a simpler DP approach with memoization # Simpler approach: try all orderings using DP # Actually the constraints make  state space for start_attr in range(1, 6): # BFS on (position, caught_set) initial = (start, frozenset([start_attr]), start_attr) queue = deque([initial]) visited  = queue.popleft()  5 attributes and at goal if len(caught) == 5 and pos == goal: if dist < best_dist or (dist ==  start_attr continue # Try moving to adjacent cells for dr,  if 0  new_pos = (nr, nc) new_caught = caught new_attr = curr_attr # Check if we catch   | {creature_attr} new_attr = creature_attr new_state = (new_pos, new_caught, new_attr) if new_state not  dist + 1 queue.append(new_state) if best_attr is None: return \"NA\" else: return f\"{best_attr} {best_dist}\" while True: line = input().split() W, H = int(line[0]), int(line[1]) if W == 0 and H ==  print(solve(W, H, grid))"], "perturbed_original": ["from itertools import product # from line_profiler import LineProfiler  break # ma = [[-1]*(W+2) for _ in range(H+2)] ps = [[] for _ in range(5)] ans = 10**10 for i in range(H): for j,a in enumerate(input()): if a == \"S\": ss = [[i,j]] elif a == \"G\": gg  for i in range(5) if len(ps[i])==0]: # print(\"NA\"); continue # print(ps) B = float(\"inf\") Bi = -1 for mon1 in range(5): dp = [[float(\"inf\")]*1000 for _ in range(5)] cand = [[0,ss[0][0],ss[0][1]]] for mon2 in range(5): dpCacheNow = dp[mon2] dpCacheNxt = dp[(mon1+mon2+1)%5] dpCacheNow[0] = 0 nxt = ps[(mon1+mon2+1)%5] if mon2<4 else gg # print(nxt) # print(cand) tmp = [] for i,[ty,tx] in enumerate(nxt): # if dpCacheNow[i] >= B: # continue tc  cand: if cc > B: # print(\"a\",end=\"\") tc = float(\"inf\") break else: tc = min(tc,abs(ty-cy)+abs(tx-cx)+cc)  B: B = cand[0][0] Bi = mon1 if(Bi == -1): print(\"NA\") else: print(\"%d %d\"%(Bi+1,B)) # for mon1 in range(5): # mon2 = (mon1+1)%5 #   # for mon3 in range(mon2,mon2+3): # mon3 = mon3%5 # mon4  min(dp[mon4][j],dp[mon3][i]+abs(yx[0]-nyx[0])+abs(yx[1]-nyx[1])) # mon5 = (mon1-1)%5 # for i,yx  ans > d: # ans,ansi = d,mon1 # print(ansi+1,ans) if __name__ == \"__main__\": # prf = LineProfiler() # prf.add_function(main) # prf.runcall(main) # prf.print_stats() main()"], "original_ll": -1.1454944610595703, "sampled_ll": -0.9636845588684082, "all_perturbed_sampled_ll": [-2.05688738822937], "all_perturbed_original_ll": [-2.158052921295166], "perturbed_sampled_ll": -2.05688738822937, "perturbed_original_ll": -2.158052921295166, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\t\tint n,t,i,k,j,g,s,r,a,w,z,o;\n\twhile(1)\t{\n\t\tscanf(\"%d\",&t);\n\t\tif(t==-1)\tbreak;\n\t\tif(10>=t){\n\t\t\tprintf(\"3130\\n\");\n\t\t\t}\n\t\tif(t>10&&t<20){\n\t\t\tn=t-10;\n\t\t\ti=4280-(n*125+1150);\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\t}\n\t\tif(t>20&&t<30){\n\t\t\tk=t-20;\n\t\t\tj=4280-((k*140)+2400);\n\t\t\tprintf(\"%d\\n\",j);\n\t\t}\n\t\tif(t>30){\n\t\t\ts=t-30;\n\t\t\tg=4280-((s*160)+3800);\n\t\t\tprintf(\"%d\\n\",g);\n\t\t}\t\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint calculate_bill(int w) {\n    int bill = 1150; // base charge\n    \n    if (w <= 10) {\n        return bill;\n    }\n    \n    if (w <= 20) {\n        bill += (w - 10) * 125;\n        return bill;\n    }\n    \n    bill += 10 * 125;\n    \n    if (w <= 30) {\n        bill += (w - 20) * 140;\n        return bill;\n    }\n    \n    bill += 10 * 140;\n    bill += (w - 30) * 160;\n    \n    return bill;\n}\n\nint main() {\n    int w;\n    int last_month = 4280;\n    \n    while (1) {\n        scanf(\"%d\", &w);\n        if (w == -1) break;\n        \n        int current_bill = calculate_bill(w);\n        int savings = last_month - current_bill;\n        \n        printf(\"%d\\n\", savings);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int calculate_bill(int w) { int bill =  (w - 10) * 125; return bill; } bill += 10 * 125; if (w <= 30) { bill += (w - 20) * 140; return bill; } bill += 10 * 140; bill += (w - 30) * 160; return bill; } int  { scanf(\"%d\", &w); if (w == -1) break; int current_bill = calculate_bill(w); int savings = last_month - current_bill; printf(\"%d\\n\", savings); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int n,t,i,k,j,g,s,r,a,w,z,o; while(1) { scanf(\"%d\",&t); if(t==-1) break; if(10>=t){ printf(\"3130\\n\"); } if(t>10&&t<20){ n=t-10; i=4280-(n*125+1150); printf(\"%d\\n\",i); } if(t>20&&t<30){ k=t-20; j=4280-((k*140)+2400); printf(\"%d\\n\",j); } if(t>30){ s=t-30; g=4280-((s*160)+3800); printf(\"%d\\n\",g); } } return 0; }"], "original_ll": -1.2676897048950195, "sampled_ll": -0.8720086216926575, "all_perturbed_sampled_ll": [-1.4431451559066772], "all_perturbed_original_ll": [-1.3054076433181763], "perturbed_sampled_ll": -1.4431451559066772, "perturbed_original_ll": -1.3054076433181763, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\twhile(kbd.hasNext()) {\n\t    int w = kbd.nextInt();\n\t    if(w!=-1){\n\t\tSystem.out.println(4280-solve(w));\n\t    }\n\t}\n    }\n\n    static int solve(int w) {\n\tint r = 0;\n\tint bill = 0;\n\twhile(w>=0){\n\t    bill += cost(w, r);\n\t    w -= 10;\n\t    r ++;\n\t    //System.out.println(\"p\");\n\t}\n\treturn bill;\n    }\n\n    static int cost(int w, int r){\n\tif(r==0){ return 1150; }\n\telse if(r==1){ \n\t    if(w>=10) return 125*10;\n\t    else return 125*w;\n\t}\n\telse if(r==2){\n\t    if(w>=10) return 140*10;\n\t    else return 140*w;\n\t}\n\telse if(r>2){\n\t    if(w>=10) return 160*10;\n\t    else return 160*w;\n\t}\n\telse return 0;\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int w = sc.nextInt();\n            if (w == -1) break;\n            \n            int currentBill = calculateBill(w);\n            int difference = 4280 - currentBill;\n            System.out.println(difference);\n        }\n        \n        sc.close();\n    }\n    \n    static int calculateBill(int w) {\n        int bill = 1150; // Base charge\n        \n        if (w <= 10) {\n            return bill;\n        }\n        \n        // Second tier: 10 < w <= 20\n        if (w <= 20) {\n            bill += (w - 10) * 125;\n            return bill;\n        }\n        \n        bill += 10 * 125; // Full second tier\n        \n        // Third tier: 20 < w <= 30\n        if (w <= 30) {\n            bill += (w - 20) * 140;\n            return bill;\n        }\n        \n        bill += 10 * 140; // Full third tier\n        \n        // Fourth tier: w > 30\n        bill += (w - 30) * 160;\n        \n        return bill;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in);  4280 - currentBill; System.out.println(difference); } sc.close();  // Base charge if (w <= 10) { return bill; } // Second tier: 10 < w <= 20 if (w <=  bill; } bill += 10 * 125; // Full second tier // Third tier: 20 < w <= 30 if (w <= 30) { bill += (w - 20) * 140; return bill; } bill += 10 * 140; // Full third tier // Fourth tier: w > 30 bill += (w - 30) * 160; return bill; } }"], "perturbed_original": ["import java.util.*; public class Main { static Scanner kbd = new Scanner(System.in); public static void main(String[]  } } static int solve(int w) { int r = 0; int bill = 0; while(w>=0){ bill += cost(w, r); w -= 10; r ++; //System.out.println(\"p\"); } return bill; } static int cost(int w, int r){ if(r==0){ return 1150; } else if(r==1){ if(w>=10) return 125*10; else return 125*w; } else  if(w>=10) return 160*10; else return 160*w; } else return 0; } }"], "original_ll": -1.0966719388961792, "sampled_ll": -0.7214460968971252, "all_perturbed_sampled_ll": [-1.6413695812225342], "all_perturbed_original_ll": [-1.5611499547958374], "perturbed_sampled_ll": -1.6413695812225342, "perturbed_original_ll": -1.5611499547958374, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def fee(w):\n    if w>30:\n        return (w-30)*160+10*140+10*125+1150\n    if w>20:\n        return (w-20)*140+10*125+1150\n    if w>10:\n        return (w-10)*125+1150\n    return 1150\n\nprev_m=4280\nwhile True:\n    W=int(input())\n    if W==-1:\n        break\n    print(prev_m-fee(W))\n    # prev_m=fee(W)\n\n", "sampled": "def calculate_water_bill(w):\n    if w <= 10:\n        return 1150\n    elif w <= 20:\n        return 1150 + (w - 10) * 125\n    elif w <= 30:\n        return 1150 + 10 * 125 + (w - 20) * 140\n    else:\n        return 1150 + 10 * 125 + 10 * 140 + (w - 30) * 160\n\nlast_month_bill = 4280\n\nwhile True:\n    w = int(input())\n    if w == -1:\n        break\n    \n    current_bill = calculate_water_bill(w)\n    savings = last_month_bill - current_bill\n    print(savings)\n", "perturbed_sampled": ["def calculate_water_bill(w): if w <= 10: return 1150 elif w <= 20: return 1150 + (w  + 10 * 125 + (w - 20) * 140 else: return 1150 + 10 * 125 + 10 * 140 + (w - 30) * 160 last_month_bill = 4280 while True:  calculate_water_bill(w) savings = last_month_bill - current_bill print(savings)"], "perturbed_original": ["def fee(w): if w>30: return (w-30)*160+10*140+10*125+1150 if w>20: return (w-20)*140+10*125+1150 if w>10: return (w-10)*125+1150 return 1150 prev_m=4280 while True: W=int(input()) if W==-1: break print(prev_m-fee(W)) # prev_m=fee(W)"], "original_ll": -1.2482658624649048, "sampled_ll": -0.8674608469009399, "all_perturbed_sampled_ll": [-1.8491243124008179], "all_perturbed_original_ll": [-1.6112303733825684], "perturbed_sampled_ll": -1.8491243124008179, "perturbed_original_ll": -1.6112303733825684, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main()\n{\n\tint i,a,b,c,d,max=0,s=0;\n\tscanf(\"%d\",&a);\n\twhile(a!=0){\n\t\ts=0;\nmax=0;\n\tfor(i=0;i<a;i++){\n\t\tscanf(\"%d %d %d\",&b,&c,&d);\n\t\tc=c+d;\n\t\tif(max<c){\n\t\t\tmax=c;\n\t\t\ts=b;\n\t\t}\n\t}\n\t\n\tprintf(\"%d %d\\n\",s,max);\n\tscanf(\"%d\",&a);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int max_id = 0;\n        int max_distance = -1;\n        \n        for(int i = 0; i < n; i++) {\n            int p, d1, d2;\n            scanf(\"%d %d %d\", &p, &d1, &d2);\n            int total = d1 + d2;\n            \n            if(total > max_distance) {\n                max_distance = total;\n                max_id = p;\n            }\n        }\n        \n        printf(\"%d %d\\n\", max_id, max_distance);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n;  = 0; int max_distance = -1; for(int i = 0; i < n; i++) { int p, d1, d2; scanf(\"%d %d %d\",  > max_distance) { max_distance = total; max_id = p; } } printf(\"%d %d\\n\", max_id, max_distance); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main() { int i,a,b,c,d,max=0,s=0; scanf(\"%d\",&a); while(a!=0){ s=0; max=0; for(i=0;i<a;i++){ scanf(\"%d %d %d\",&b,&c,&d); c=c+d; if(max<c){ max=c; s=b; } } printf(\"%d %d\\n\",s,max); scanf(\"%d\",&a); } return 0; }"], "original_ll": -1.0832152366638184, "sampled_ll": -0.6275161504745483, "all_perturbed_sampled_ll": [-1.7939573526382446], "all_perturbed_original_ll": [-1.1129746437072754], "perturbed_sampled_ll": -1.7939573526382446, "perturbed_original_ll": -1.1129746437072754, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\n\n\npublic class Main {\n\n\tprivate BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1);\n\n\tprivate String inputData = null;\n\n\tpublic String[] data = null;\n\n\tpublic int num = 0;\n\n\tpublic int count = 0;\n\n\tpublic HashMap<Integer, Integer> humanData = new HashMap<Integer, Integer>();\n\n\tpublic ArrayList<Integer> topId = new ArrayList<Integer>();\n\n\tpublic ArrayList<Integer> topLength = new ArrayList<Integer>();\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().start();\n\t\tSystem.exit(0);\n\t}\n\n\tpublic void start() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\tif (this.data.length == 1) {\n\t\t\t\tif (this.data[0].equals(\"0\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.num = Integer.parseInt(this.data[0]);\n\t\t\t}\n\n\t\t\tthis.humanData.clear();\n\n\t\t\tfor (int i = 0; i < this.num; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\t\tthis.humanData.put(Integer.parseInt(data[0]),\n\t\t\t\t\t\tInteger.parseInt(data[1]) + Integer.parseInt(data[2]));\n\n\t\t\t}\n\n\t\t\tIterator<Integer> itId = this.humanData.keySet().iterator();\n\t\t\tint numCount = 0;\n\t\t\twhile (itId.hasNext()) {\n\t\t\t\tint id = itId.next();\n\t\t\t\tif (numCount == 0) {\n\t\t\t\t\tthis.topId.add(id);\n\t\t\t\t\tthis.topLength.add(this.humanData.get(id));\n\t\t\t\t} else {\n\t\t\t\t\tif (this.topLength.get(count) <= this.humanData.get(id)) {\n\t\t\t\t\t\tthis.topId.set(this.count, id);\n\t\t\t\t\t\tthis.topLength.set(this.count, this.humanData.get(id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnumCount++;\n\t\t\t}\n\n\t\t\tthis.count++;\n\n\t\t}\n\n\t\tfor (int i = 0; i < this.topId.size(); i++) {\n\t\t\tSystem.out.println(this.topId.get(i) + \" \" + this.topLength.get(i));\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int maxPatient = 0;\n            int maxDistance = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int p = sc.nextInt();\n                int d1 = sc.nextInt();\n                int d2 = sc.nextInt();\n                int total = d1 + d2;\n                \n                if (total > maxDistance) {\n                    maxDistance = total;\n                    maxPatient = p;\n                }\n            }\n            \n            System.out.println(maxPatient + \" \" + maxDistance);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void  { int n = sc.nextInt(); if (n == 0) break; int maxPatient = 0; int maxDistance = 0;  int p = sc.nextInt(); int d1 = sc.nextInt(); int d2 = sc.nextInt(); int total = d1 + d2; if (total > maxDistance) { maxDistance = total; maxPatient = p; } } System.out.println(maxPatient + \" \" + maxDistance); } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator;  InputStreamReader(System.in), 1); private String inputData = null; public String[] data = null; public int  Integer>  ArrayList<Integer>(); public ArrayList<Integer> topLength = new ArrayList<Integer>(); public static void  { while (true) { try { this.inputData = reader.readLine(); } catch (IOException e) { e.printStackTrace(); } this.data = this.inputData.split(\" \");  this.num = Integer.parseInt(this.data[0]); } this.humanData.clear(); for (int i = 0; i < this.num; i++) { try { this.inputData = reader.readLine(); } catch (IOException e) { e.printStackTrace(); } this.data = this.inputData.split(\" \"); this.humanData.put(Integer.parseInt(data[0]), Integer.parseInt(data[1]) + Integer.parseInt(data[2])); } Iterator<Integer> itId = this.humanData.keySet().iterator(); int numCount = 0; while (itId.hasNext()) { int id = itId.next(); if (numCount == 0) { this.topId.add(id); this.topLength.add(this.humanData.get(id)); } else { if  numCount++; } this.count++; } for (int i = 0; i < this.topId.size(); i++) { System.out.println(this.topId.get(i) + \" \" + this.topLength.get(i)); } } }"], "original_ll": -0.6698124408721924, "sampled_ll": -0.5245659947395325, "all_perturbed_sampled_ll": [-1.3401110172271729], "all_perturbed_original_ll": [-1.3872073888778687], "perturbed_sampled_ll": -1.3401110172271729, "perturbed_original_ll": -1.3872073888778687, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(input())\n    if n == 0:\n        break\n\n    patients = []\n    for _ in range(n):\n        p, d1, d2 = map(int, input().split())\n        patients.append((p, d1+d2))\n    print(*max(patients, key=lambda x: x[1]))", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    max_distance = -1\n    max_patient = -1\n    \n    for _ in range(n):\n        data = list(map(int, input().split()))\n        patient_id = data[0]\n        d1 = data[1]\n        d2 = data[2]\n        total_distance = d1 + d2\n        \n        if total_distance > max_distance:\n            max_distance = total_distance\n            max_patient = patient_id\n    \n    print(max_patient, max_distance)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break max_distance =  list(map(int, input().split())) patient_id = data[0] d1 = data[1] d2 = data[2] total_distance = d1 + d2 if total_distance > max_distance: max_distance = total_distance max_patient = patient_id print(max_patient, max_distance)"], "perturbed_original": ["while True: n = int(input()) if n == 0: break patients = [] for _ in range(n): p, d1, d2 = map(int, input().split()) patients.append((p, d1+d2)) print(*max(patients, key=lambda x: x[1]))"], "original_ll": -1.1281121969223022, "sampled_ll": -0.8109328746795654, "all_perturbed_sampled_ll": [-1.6592581272125244], "all_perturbed_original_ll": [-1.3009191751480103], "perturbed_sampled_ll": -1.6592581272125244, "perturbed_original_ll": -1.3009191751480103, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "m,e,j,s;main(n){for(;scanf(\"%d\",&n)*n;)for(;n--;puts(m>99|e>99|j>99|m+e>179|s>239?\"A\":s>209||s>149&&m>79|e>79?\"B\":\"C\"))scanf(\"%d%d%d\",&m,&e,&j),s=m+e+j;}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        for(int i = 0; i < n; i++) {\n            int pm, pe, pj;\n            scanf(\"%d %d %d\", &pm, &pe, &pj);\n            \n            char cls = 'C';\n            \n            // Check conditions for A class\n            if(pm == 100 || pe == 100 || pj == 100) {\n                cls = 'A';\n            }\n            else if((pm + pe) / 2.0 >= 90) {\n                cls = 'A';\n            }\n            else if((pm + pe + pj) / 3.0 >= 80) {\n                cls = 'A';\n            }\n            // Check conditions for B class\n            else if((pm + pe + pj) / 3.0 >= 70) {\n                cls = 'B';\n            }\n            else if((pm + pe + pj) / 3.0 >= 50 && (pm >= 80 || pe >= 80)) {\n                cls = 'B';\n            }\n            \n            printf(\"%c\\n\", cls);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) { scanf(\"%d\", &n); if(n == 0) break; for(int i = 0; i < n;  &pe, &pj); char cls = 'C'; // Check conditions for A class if(pm == 100 || pe == 100 || pj == 100) { cls = 'A'; } else if((pm + pe) /  + pe + pj) / 3.0 >= 80) { cls = 'A'; }  + pj) / 3.0 >= 70) { cls = 'B'; } else if((pm + pe + pj) / 3.0 >= 50 && (pm >= 80 || pe >=  return 0; }"], "perturbed_original": ["m,e,j,s;main(n){for(;scanf(\"%d\",&n)*n;)for(;n--;puts(m>99|e>99|j>99|m+e>179|s>239?\"A\":s>209||s>149&&m>79|e>79?\"B\":\"C\"))scanf(\"%d%d%d\",&m,&e,&j),s=m+e+j;}"], "original_ll": -2.6041934490203857, "sampled_ll": -0.7207226157188416, "all_perturbed_sampled_ll": [-1.7575798034667969], "all_perturbed_original_ll": [-2.6041934490203857], "perturbed_sampled_ll": -1.7575798034667969, "perturbed_original_ll": -2.6041934490203857, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tchar c[]=new char[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint pm=sc.nextInt();\n\t\t\t\tint pe=sc.nextInt();\n\t\t\t\tint pj=sc.nextInt();\n\t\t\t\tif(pm==100||pe==100||pj==100)c[i]='A';\n\t\t\t\telse if((pm+pe)/2>=90)c[i]='A';\n\t\t\t\telse if((pm+pe+pj)/3>=80)c[i]='A';\n\t\t\t\telse if((pm+pe+pj)/3>=70)c[i]='B';\n\t\t\t\telse if((pm+pe+pj)/3>=50&&(pm>=80||pe>=80))c[i]='B';\n\t\t\t\telse c[i]='C';\n\t\t\t\tSystem.out.println(c[i]);\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            for (int i = 0; i < n; i++) {\n                int pm = sc.nextInt();\n                int pe = sc.nextInt();\n                int pj = sc.nextInt();\n                \n                String cls = getClass(pm, pe, pj);\n                System.out.println(cls);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static String getClass(int pm, int pe, int pj) {\n        // Check for class A conditions\n        if (pm == 100 || pe == 100 || pj == 100) {\n            return \"A\";\n        }\n        \n        double mathEngAvg = (pm + pe) / 2.0;\n        if (mathEngAvg >= 90) {\n            return \"A\";\n        }\n        \n        double threeAvg = (pm + pe + pj) / 3.0;\n        if (threeAvg >= 80) {\n            return \"A\";\n        }\n        \n        // Check for class B conditions\n        if (threeAvg >= 70) {\n            return \"B\";\n        }\n        \n        if (threeAvg >= 50 && (pm >= 80 || pe >= 80)) {\n            return \"B\";\n        }\n        \n        // Otherwise class C\n        return \"C\";\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; for (int i =  int pe  pe, pj); System.out.println(cls); } } sc.close(); } static String getClass(int pm, int pe, int pj) { // Check for class A conditions if  100)  / 2.0; if (mathEngAvg >= 90) { return \"A\"; } double threeAvg = (pm + pe + pj) / 3.0; if (threeAvg >= 80) { return \"A\"; } // Check for class B conditions if (threeAvg >= 70) { return \"B\"; } if (threeAvg >= 50 && (pm >= 80 || pe >= 80)) { return \"B\"; } // Otherwise class C return \"C\"; } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc=new Scanner(System.in); while(true){ int n=sc.nextInt(); if(n==0)break; char c[]=new char[n]; for(int i=0;i<n;i++){ int pm=sc.nextInt();  if((pm+pe+pj)/3>=70)c[i]='B'; else if((pm+pe+pj)/3>=50&&(pm>=80||pe>=80))c[i]='B'; else c[i]='C'; System.out.println(c[i]); } } } }"], "original_ll": -0.8382114768028259, "sampled_ll": -0.7714477181434631, "all_perturbed_sampled_ll": [-1.6637483835220337], "all_perturbed_original_ll": [-1.4008538722991943], "perturbed_sampled_ll": -1.6637483835220337, "perturbed_original_ll": -1.4008538722991943, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n = int(input())\n    if n == 0: break\n    i = 0\n    while True:\n        if i == n: break\n        m, e, j = map(int, input().split())\n        sum = m + e + j\n        if m==100 or e==100 or j==100:\n            print(\"A\")\n        elif (m+e)/2 >= 90:\n            print(\"A\")\n        elif sum/3 >= 80:\n            print(\"A\")\n        elif sum/3 >= 70:\n            print(\"B\")\n        elif sum/3 >= 50 and m >= 80 or e >= 80:\n            print(\"B\")\n        else:\n            print(\"C\")\n        i += 1\n    \n", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    for _ in range(n):\n        pm, pe, pj = map(int, input().split())\n        \n        # Check conditions for class A\n        if pm == 100 or pe == 100 or pj == 100:\n            print(\"A\")\n            continue\n        \n        if (pm + pe) / 2 >= 90:\n            print(\"A\")\n            continue\n        \n        if (pm + pe + pj) / 3 >= 80:\n            print(\"A\")\n            continue\n        \n        # Check conditions for class B\n        if (pm + pe + pj) / 3 >= 70:\n            print(\"B\")\n            continue\n        \n        if (pm + pe + pj) / 3 >= 50 and (pm >= 80 or pe >= 80):\n            print(\"B\")\n            continue\n        \n        # Otherwise class C\n        print(\"C\")\n", "perturbed_sampled": ["while True: n =  pm, pe, pj = map(int, input().split()) # Check conditions for class A if pm == 100 or pe == 100 or pj == 100: print(\"A\") continue if (pm + pe) / 2 >= 90: print(\"A\") continue if (pm + pe + pj) / 3 >= 80: print(\"A\") continue # Check conditions for class B if (pm + pe + pj) / 3 >= 70:  >= 50 and (pm >= 80  print(\"C\")"], "perturbed_original": ["while 1:  0 while True: if i == n: break m, e, j = map(int, input().split()) sum = m + e  (m+e)/2 >= 90: print(\"A\") elif sum/3 >= 80: print(\"A\") elif sum/3 >= 70: print(\"B\") elif sum/3 >= 50 and m >= 80 or e >= 80: print(\"B\") else: print(\"C\") i += 1"], "original_ll": -1.0176674127578735, "sampled_ll": -0.8166347742080688, "all_perturbed_sampled_ll": [-1.7957935333251953], "all_perturbed_original_ll": [-1.7633417844772339], "perturbed_sampled_ll": -1.7957935333251953, "perturbed_original_ll": -1.7633417844772339, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main()\n{\n    int n;\n    int c;\n\n    while (scanf(\"%d\", &n), n != 0) {\n        int cnt[10] = {};\n\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &c);\n\n            cnt[c]++;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            if (cnt[i] == 0) {\n                putchar('-');\n            }\n            else {\n                for (int j = 0; j < cnt[i]; j++) {\n                    putchar('*');\n                }\n            }\n\n            putchar('\\n');\n        }\n    }\n\n    return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int count[10] = {0};\n        \n        for(int i = 0; i < n; i++) {\n            int c;\n            scanf(\"%d\", &c);\n            count[c]++;\n        }\n        \n        for(int i = 0; i < 10; i++) {\n            if(count[i] == 0) {\n                printf(\"-\\n\");\n            } else {\n                for(int j = 0; j < count[i]; j++) {\n                    printf(\"*\");\n                }\n                printf(\"\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(scanf(\"%d\", &n) == 1 &&  = 0; i < n; i++) { int c; scanf(\"%d\", &c); count[c]++; } for(int i = 0; i <  { for(int j = 0; j < count[i]; j++) { printf(\"*\"); } printf(\"\\n\"); } } } return 0; }"], "perturbed_original": ["#include <stdio.h> int main() { int n; int c; while (scanf(\"%d\", &n), n != 0) { int cnt[10] =  { scanf(\"%d\", &c); cnt[c]++; } for (int i = 0; i < 10; i++) { if (cnt[i]  = 0; j < cnt[i]; j++) { putchar('*'); } } putchar('\\n'); } } return 0; }"], "original_ll": -0.6518388986587524, "sampled_ll": -0.4910286068916321, "all_perturbed_sampled_ll": [-1.34810471534729], "all_perturbed_original_ll": [-1.3785089254379272], "perturbed_sampled_ll": -1.34810471534729, "perturbed_original_ll": -1.3785089254379272, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] num = new int[10];\n\t\t\twhile(n-->0){\n\t\t\t\tnum[scanner.nextInt()]++;\n\t\t\t}\n\t\t\tfor(int a:num){\n\t\t\t\tif(a==0)\n\t\t\t\t\tSystem.out.println('-');\n\t\t\t\telse{\n\t\t\t\t\tchar[] c = new char[a];\n\t\t\t\t\tArrays.fill(c, '*');\n\t\t\t\t\tSystem.out.println(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] count = new int[10];\n            \n            for (int i = 0; i < n; i++) {\n                int c = sc.nextInt();\n                count[c]++;\n            }\n            \n            for (int i = 0; i < 10; i++) {\n                if (count[i] == 0) {\n                    System.out.println(\"-\");\n                } else {\n                    for (int j = 0; j < count[i]; j++) {\n                        System.out.print(\"*\");\n                    }\n                    System.out.println();\n                }\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[] count  n; i++) { int c = sc.nextInt(); count[c]++; } for (int i = 0; i < 10; i++) { if (count[i] == 0) { System.out.println(\"-\"); } else { for (int j = 0; j < count[i]; j++) { System.out.print(\"*\"); } System.out.println(); } } } sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String[] args) throws IOException {  scanner = new Scanner(System.in); while (true) { int n = scanner.nextInt(); if (n == 0) break; int[] num = new int[10]; while(n-->0){ num[scanner.nextInt()]++; } for(int a:num){ if(a==0) System.out.println('-'); else{  } } }"], "original_ll": -0.8657097816467285, "sampled_ll": -0.3890190124511719, "all_perturbed_sampled_ll": [-1.0216407775878906], "all_perturbed_original_ll": [-1.2745550870895386], "perturbed_sampled_ll": -1.0216407775878906, "perturbed_original_ll": -1.2745550870895386, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    q={}\n    a=input()\n    if a==0:break\n    for i in range(10): q[i]=0\n    for i in range(a): q[input()]+=1\n    for i in range(10):  print \"*\"*q[i] if q[i] != 0 else \"-\"", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = [0] * 10\n    for _ in range(n):\n        c = int(input())\n        count[c] += 1\n    \n    for i in range(10):\n        if count[i] == 0:\n            print('-')\n        else:\n            print('*' * count[i])\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0:  c = int(input()) count[c] += 1 for i in range(10): if count[i] == 0: print('-') else: print('*' * count[i])"], "perturbed_original": ["while True: q={} a=input() if a==0:break for i in range(10): q[i]=0 for i in range(a): q[input()]+=1 for i in range(10): print \"*\"*q[i] if q[i] != 0 else \"-\""], "original_ll": -1.4989075660705566, "sampled_ll": -0.729781448841095, "all_perturbed_sampled_ll": [-1.7757235765457153], "all_perturbed_original_ll": [-2.0150980949401855], "perturbed_sampled_ll": -1.7757235765457153, "perturbed_original_ll": -2.0150980949401855, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  double n;\n  char a[12];\n  int m,i;\n  while(1){\n    scanf(\"%lf\",&n);\n    if(n<0)break;\n    n*=16;\n    m=n;\n    if(m-n){\n      printf(\"NA\\n\");\n      continue;\n    }\n    for(i=12;i;i--){\n      a[i-1]=m%2+'0';\n      m/=2;\n    }\n    if(m){\n      printf(\"NA\\n\");\n      continue;\n    }\n    for(i=0;i<12;i++){\n      if(i==8)printf(\".\");\n      printf(\"%c\",a[i]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\nint main() {\n    double n;\n    \n    while (scanf(\"%lf\", &n) == 1) {\n        if (n < 0) break;\n        \n        // Extract integer and fractional parts\n        int int_part = (int)n;\n        double frac_part = n - int_part;\n        \n        // Check if integer part fits in 8 bits\n        if (int_part > 255) {\n            printf(\"NA\\n\");\n            continue;\n        }\n        \n        // Convert integer part to binary (8 bits)\n        char int_binary[9];\n        for (int i = 7; i >= 0; i--) {\n            int_binary[i] = (int_part % 2) + '0';\n            int_part /= 2;\n        }\n        int_binary[8] = '\\0';\n        \n        // Convert fractional part to binary (4 bits)\n        char frac_binary[5];\n        int valid = 1;\n        double temp_frac = frac_part;\n        \n        for (int i = 0; i < 4; i++) {\n            temp_frac *= 2;\n            if (temp_frac >= 1) {\n                frac_binary[i] = '1';\n                temp_frac -= 1;\n            } else {\n                frac_binary[i] = '0';\n            }\n        }\n        frac_binary[4] = '\\0';\n        \n        // Check if there's remaining fractional part\n        temp_frac *= 2;\n        if (temp_frac > 0.0001) {  // Allow small floating point error\n            valid = 0;\n        }\n        \n        // Alternative check: reconstruct the number and compare\n        double reconstructed = 0;\n        int int_val = 0;\n        for (int i = 0; i < 8; i++) {\n            int_val = int_val * 2 + (int_binary[i] - '0');\n        }\n        reconstructed = int_val;\n        \n        double frac_val = 0;\n        for (int i = 0; i < 4; i++) {\n            frac_val = frac_val + (frac_binary[i] - '0') * pow(0.5, i + 1);\n        }\n        reconstructed += frac_val;\n        \n        if (fabs(reconstructed - n) > 0.0001) {\n            valid = 0;\n        }\n        \n        if (valid) {\n            printf(\"%s.%s\\n\", int_binary, frac_binary);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <math.h> int main() { double n; while (scanf(\"%lf\", &n) == 1) { if (n < 0) break; // Extract integer and fractional parts int int_part = (int)n; double frac_part = n - int_part; // Check if integer part fits in 8 bits if (int_part > 255) { printf(\"NA\\n\"); continue; } // Convert integer part to binary (8 bits) char int_binary[9];  int_binary[i] = (int_part % 2) + '0'; int_part /= 2; } int_binary[8] = '\\0'; // Convert fractional part to binary (4 bits)  for (int i = 0; i < 4; i++) { temp_frac *= 2; if (temp_frac >= 1)  frac_binary[i] = '0'; } } frac_binary[4] = '\\0'; // Check if there's remaining fractional part  small floating point error valid =  double reconstructed = 0; int int_val = 0; for (int i  * 2 + (int_binary[i] - '0'); } reconstructed = int_val; double frac_val = 0; for (int i = 0; i < 4; i++) { frac_val = frac_val + (frac_binary[i] - '0') * pow(0.5, i + 1); } reconstructed += frac_val; if (fabs(reconstructed - n) > 0.0001) {  } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int  n*=16; m=n; if(m-n){ printf(\"NA\\n\"); continue; } for(i=12;i;i--){ a[i-1]=m%2+'0'; m/=2; } if(m){ printf(\"NA\\n\"); continue; } for(i=0;i<12;i++){ if(i==8)printf(\".\"); printf(\"%c\",a[i]); } printf(\"\\n\"); } return 0; }"], "original_ll": -1.1134214401245117, "sampled_ll": -0.6523396372795105, "all_perturbed_sampled_ll": [-1.3439466953277588], "all_perturbed_original_ll": [-2.0149283409118652], "perturbed_sampled_ll": -1.3439466953277588, "perturbed_original_ll": -2.0149283409118652, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/**\n * Problem E: Binary Digit A Doctor Loved\n */\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tif (line.charAt(0) == '-') {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint ni;\n\t\t\tdouble nd;\n\t\t\tni = Integer.parseInt(line.substring(0, line.indexOf('.')));\n\t\t\tif (line.indexOf('.') != -1) {\n\t\t\t\tnd = Double.parseDouble(\"0\"\n\t\t\t\t\t\t+ (line.substring(line.indexOf('.')))) * 16;\n\t\t\t} else {\n\t\t\t\tnd = 0.0;\n\t\t\t}\n\t\t\tif (ni > 255 || nd % 1.0 > 0.0) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else {\n\t\t\t\tchar[] si, sd;\n\t\t\t\tsi = new char[8];\n\t\t\t\tsd = new char[4];\n\n\t\t\t\tfor (int i = 7; i >= 0; i--) {\n\t\t\t\t\tif ((ni & (int) (Math.pow(2, i))) != 0) {\n\t\t\t\t\t\tsi[7 - i] = '1';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsi[7 - i] = '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 3; i >= 0; i--) {\n\t\t\t\t\tif (((int) nd & (int) (Math.pow(2, i))) != 0) {\n\t\t\t\t\t\tsd[3 - i] = '1';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsd[3 - i] = '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(new String(si) + \".\" + new String(sd));\n\t\t\t}\n\t\t}\n\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double n = sc.nextDouble();\n            if (n < 0) break;\n            \n            // Split into integer and fractional parts\n            int intPart = (int) n;\n            double fracPart = n - intPart;\n            \n            // Check if integer part fits in 8 bits\n            if (intPart > 255) {\n                System.out.println(\"NA\");\n                continue;\n            }\n            \n            // Convert integer part to binary (8 digits)\n            String intBinary = String.format(\"%8s\", Integer.toBinaryString(intPart)).replace(' ', '0');\n            \n            // Convert fractional part to binary (4 digits)\n            StringBuilder fracBinary = new StringBuilder();\n            boolean valid = true;\n            double temp = fracPart;\n            \n            for (int i = 0; i < 4; i++) {\n                temp *= 2;\n                if (temp >= 1) {\n                    fracBinary.append('1');\n                    temp -= 1;\n                } else {\n                    fracBinary.append('0');\n                }\n            }\n            \n            // Check if there's remaining fractional part\n            if (temp > 1e-9) {\n                valid = false;\n            }\n            \n            if (valid) {\n                System.out.println(intBinary + \".\" + fracBinary.toString());\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new  < 0) break; // Split into integer and fractional parts int intPart = (int) n; double fracPart = n - intPart;  (intPart > 255) { System.out.println(\"NA\"); continue; } // Convert integer part to binary (8 digits) String intBinary = String.format(\"%8s\", Integer.toBinaryString(intPart)).replace(' ', '0'); // Convert fractional part to binary (4 digits) StringBuilder fracBinary = new StringBuilder(); boolean valid = true; double temp = fracPart; for (int  2; if (temp >= 1) { fracBinary.append('1'); temp -= 1; } else {  if (temp > 1e-9) { valid = false; } if (valid) { System.out.println(intBinary + \".\" + fracBinary.toString()); } else { System.out.println(\"NA\"); } } sc.close(); } }"], "perturbed_original": [" import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = \"\"; while ((line = br.readLine()) != null && !line.isEmpty()) { if (line.charAt(0) == '-') { break; } int ni; double  nd = Double.parseDouble(\"0\" + (line.substring(line.indexOf('.')))) * 16; } else { nd = 0.0; } if (ni > 255 || nd % 1.0 > 0.0) { System.out.println(\"NA\"); } else  new char[4]; for (int i = 7; i >= 0; i--) { if ((ni & (int) (Math.pow(2, i))) != 0) { si[7 - i] = '1'; } else { si[7 - i] = '0'; } } for (int i = 3; i >= 0; i--) { if (((int) nd & (int) (Math.pow(2, i)))  { sd[3 - i] =  } } } }"], "original_ll": -0.915639340877533, "sampled_ll": -0.6806674599647522, "all_perturbed_sampled_ll": [-1.4715309143066406], "all_perturbed_original_ll": [-1.384832739830017], "perturbed_sampled_ll": -1.4715309143066406, "perturbed_original_ll": -1.384832739830017, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# Aizu Problem 0220: Binary Digit A Doctor Loved\n\nimport sys, math, os, struct\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\n\nwhile True:\n    n = float(input())\n    if n < 0:\n        break\n    pre = int(n)\n    post = n - int(n)\n    res = bin(pre)[2:].zfill(8) + '.'\n    for k in range(4):\n        post *= 2\n        res += str(int(post))\n        post -= int(post)\n    if pre > 255 or post > 0:\n        print(\"NA\")\n    else:\n        print(res)\n    #m = int(n * 16)\n    #if n == m / 16. and m < 4096:\n    #    res = \"\"\n    #    for k in range(12):\n    #        res += str(m % 2)\n    #        m //= 2\n    #        if k == 7:\n    #            res += '.'\n    #    print(res)\n    #else:\n    #    print(\"NA\")", "sampled": "import sys\n\ndef decimal_to_binary(n):\n    if n < 0:\n        return None\n    \n    # Split into integer and fractional parts\n    integer_part = int(n)\n    fractional_part = n - integer_part\n    \n    # Check if integer part fits in 8 bits\n    if integer_part >= 256:  # 2^8\n        return \"NA\"\n    \n    # Convert integer part to binary\n    int_binary = bin(integer_part)[2:].zfill(8)\n    \n    # Convert fractional part to binary (up to 4 digits)\n    frac_binary = \"\"\n    for _ in range(4):\n        fractional_part *= 2\n        bit = int(fractional_part)\n        frac_binary += str(bit)\n        fractional_part -= bit\n    \n    # Check if there's remaining fractional part (can't be represented exactly)\n    if fractional_part > 1e-9:  # small epsilon for floating point errors\n        return \"NA\"\n    \n    return int_binary + \".\" + frac_binary\n\nfor line in sys.stdin:\n    n = float(line.strip())\n    if n < 0:\n        break\n    result = decimal_to_binary(n)\n    print(result)\n", "perturbed_sampled": ["import sys def decimal_to_binary(n): if n < 0: return None # Split into integer and fractional parts integer_part = int(n) fractional_part = n - integer_part # Check if integer part fits in 8 bits if integer_part >= 256: # 2^8 return  # Convert fractional part to binary (up to 4 digits) frac_binary = \"\" for _ in range(4): fractional_part *= 2 bit = int(fractional_part) frac_binary += str(bit) fractional_part -=  represented exactly)  errors return \"NA\" return int_binary + \".\" + frac_binary for line in sys.stdin: n = float(line.strip()) if n < 0: break result = decimal_to_binary(n) print(result)"], "perturbed_original": ["# Aizu Problem 0220: Binary Digit A Doctor Loved import sys,  PYDEV==\"True\": sys.stdin = open(\"sample-input.txt\", \"rt\") while True: n = float(input()) if n < 0: break pre = int(n) post = n - int(n) res = bin(pre)[2:].zfill(8) + '.' for k in range(4): post *= 2 res += str(int(post)) post -= int(post) if pre > 255 or post > 0: print(\"NA\") else: print(res) #m = int(n * 16) #if n == m / 16. and m < 4096: # res = \"\" # for k in   # print(res) #else: # print(\"NA\")"], "original_ll": -1.6585206985473633, "sampled_ll": -0.9749753475189209, "all_perturbed_sampled_ll": [-2.0118703842163086], "all_perturbed_original_ll": [-2.5725934505462646], "perturbed_sampled_ll": -2.0118703842163086, "perturbed_original_ll": -2.5725934505462646, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\nint main(){\n  int n,m,t;\n  int i,c;\n  char s[12];\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0)break;\n    scanf(\"\\n\");\n    t=1;\n    c=n;\n    int p[1001]={0};\n    p[n+1]=-1;\n    for(i=1;i<=m;i++){\n      if(t==c+1)t=1;\n      for(;p[t]==-1;t++);\n      if(t==c+1)t=1;\n      for(;p[t]==-1;t++);\n      fgets(s,10,stdin);\n      if(n!=1){\n\tif(i%3==0){\n\t  if(i%5==0){\n\t    if(strcmp(s,\"FizzBuzz\\n\\0\")!=0)p[t]=-1;\n\t  }\n\t  else{\n\t    if(strcmp(s,\"Fizz\\n\\0\")!=0)p[t]=-1;\n\t  }\n\t}\n\telse{\n\t  if(i%5==0){\n\t    if(strcmp(s,\"Buzz\\n\\0\")!=0)p[t]=-1;\n\t  }\n\t  else{\n\t    if(!(s[0]==i+'0'&&s[1]==10))p[t]=-1;\n\t  }\n\t}\n\tif(p[t]==-1)n--;\n      }\n      t++;\n    }\n    n=0;\n    for(i=1;i<=c;i++){\n      if(p[i]==0){\n\tif(n==1)printf(\" \");\n\tprintf(\"%d\",i);\n\tn=1;\n      }\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int m, n;\n    \n    while(1) {\n        scanf(\"%d %d\", &m, &n);\n        if(m == 0 && n == 0) break;\n        \n        int active[1001];\n        for(int i = 1; i <= m; i++) {\n            active[i] = 1;\n        }\n        \n        int current_player = 1;\n        int current_number = 1;\n        int remaining_players = m;\n        \n        for(int i = 0; i < n; i++) {\n            char statement[10];\n            scanf(\"%s\", statement);\n            \n            if(remaining_players == 1) {\n                continue;\n            }\n            \n            // Find next active player\n            while(active[current_player] == 0) {\n                current_player++;\n                if(current_player > m) current_player = 1;\n            }\n            \n            // Check if statement is correct\n            int correct = 0;\n            \n            if(current_number % 15 == 0) {\n                if(strcmp(statement, \"FizzBuzz\") == 0) correct = 1;\n            }\n            else if(current_number % 3 == 0) {\n                if(strcmp(statement, \"Fizz\") == 0) correct = 1;\n            }\n            else if(current_number % 5 == 0) {\n                if(strcmp(statement, \"Buzz\") == 0) correct = 1;\n            }\n            else {\n                int num;\n                if(sscanf(statement, \"%d\", &num) == 1 && num == current_number) {\n                    correct = 1;\n                }\n            }\n            \n            if(!correct) {\n                active[current_player] = 0;\n                remaining_players--;\n            }\n            \n            current_number++;\n            \n            // Move to next player\n            current_player++;\n            if(current_player > m) current_player = 1;\n        }\n        \n        int first = 1;\n        for(int i = 1; i <= m; i++) {\n            if(active[i]) {\n                if(!first) printf(\" \");\n                printf(\"%d\", i);\n                first = 0;\n            }\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int m, n; while(1) { scanf(\"%d %d\", &m, &n); if(m == 0 && n == 0) break; int active[1001]; for(int i = 1; i <= m; i++) { active[i] = 1; } int  { char statement[10]; scanf(\"%s\", statement); if(remaining_players == 1) { continue; } // Find next active player while(active[current_player] == 0) { current_player++; if(current_player > m) current_player = 1; } // Check if statement is correct int correct = 0; if(current_number % 15 == 0) {   = 1; } else if(current_number % 5 == 0) { if(strcmp(statement, \"Buzz\") == 0) correct = 1; } else { int num; if(sscanf(statement, \"%d\", &num) == 1 && num == current_number) { correct = 1; } } if(!correct) {  int first = 1; for(int i = 1; i <= m; i++) { if(active[i]) { if(!first) printf(\" \"); printf(\"%d\", i); first = 0; } } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> int main(){ int n,m,t; int i,c; char s[12]; while(1){ scanf(\"%d %d\",&n,&m); if(n==0&&m==0)break; scanf(\"\\n\"); t=1; c=n; int p[1001]={0}; p[n+1]=-1; for(i=1;i<=m;i++){ if(t==c+1)t=1; for(;p[t]==-1;t++); if(t==c+1)t=1; for(;p[t]==-1;t++); fgets(s,10,stdin); if(n!=1){ if(i%3==0){  } else{ if(!(s[0]==i+'0'&&s[1]==10))p[t]=-1; } } if(p[t]==-1)n--; } t++; } n=0; for(i=1;i<=c;i++){ if(p[i]==0){ if(n==1)printf(\" \"); printf(\"%d\",i); n=1; } } printf(\"\\n\"); } return 0; }"], "original_ll": -1.0801706314086914, "sampled_ll": -0.6141173243522644, "all_perturbed_sampled_ll": [-1.2805964946746826], "all_perturbed_original_ll": [-1.4437402486801147], "perturbed_sampled_ll": -1.2805964946746826, "perturbed_original_ll": -1.4437402486801147, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m,n;\n\t\tFizzBuzz fb;\n\t\tfor(;;) {\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(m==0 && n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfb = new FizzBuzz(m);\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tif(!fb.sayNextStatement(sc.next())) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfb.showPlayer();\n\t\t}\n\t}\n}\n\nclass FizzBuzz {\n\tprivate int current,currentPlayer;\n\tprivate int m;\n\tprivate int[] player;\n\t\n\tpublic FizzBuzz(int m) {\n\t\tcurrent = 0;\n\t\tcurrentPlayer = 0;\n\t\tthis.m = m;\n\t\tplayer = new int[m];\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tplayer[i] = i+1;\n\t\t}\n\t}\n\t\n\tpublic void showPlayer() {\n\t\tfor(int pl:player){\n\t\t\tif(pl != -1){\n\t\t\t\tSystem.out.println(pl);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic boolean sayNextStatement(String statement) {\n\t\ttry {\n\t\t\tint num = Integer.valueOf(statement);\n\t\t\tif(!checkFizzBuzz(num)) {\n\t\t\t\tplayer[currentPlayer] = -1;\n\t\t\t}\n\t\t} catch(NumberFormatException e) {\n\t\t\tif(!checkFizzBuzz(statement)) {\n\t\t\t\tplayer[currentPlayer] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!setCurrentPlayer()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate boolean setCurrentPlayer() {\n\t\tint prev = currentPlayer;\n\t\t\n\t\tif(currentPlayer+1 == m) {\n\t\t\tcurrentPlayer = 0;\n\t\t} else {\n\t\t\tcurrentPlayer ++;\n\t\t}\n\t\t\n\t\twhile(player[currentPlayer] == -1) {\n\t\t\tif(currentPlayer+1 == m) {\n\t\t\t\tcurrentPlayer = 0;\n\t\t\t} else {\n\t\t\t\tcurrentPlayer ++;\n\t\t\t}\n\t\t\t\n\t\t\tif(prev == currentPlayer) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate boolean checkFizzBuzz(int statement) {\n\t\tcurrent ++;\n\t\t\n\t\tif((current % 3 == 0) || (current % 5 == 0)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif(current == statement) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean checkFizzBuzz(String statement) {\n\t\tcurrent ++;\n\t\tif((current % 3 == 0) && (current % 5 == 0)) {\n\t\t\tif(statement.equals(\"FizzBuzz\")) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(current % 3 == 0) {\n\t\t\tif(statement.equals(\"Fizz\")) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(current % 5 == 0) {\n\t\t\tif(statement.equals(\"Buzz\")) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            \n            if (m == 0 && n == 0) break;\n            \n            boolean[] active = new boolean[m + 1];\n            for (int i = 1; i <= m; i++) {\n                active[i] = true;\n            }\n            \n            int currentNumber = 1;\n            int currentPlayer = 1;\n            int activePlayers = m;\n            \n            for (int i = 0; i < n; i++) {\n                String statement = sc.next();\n                \n                if (activePlayers == 1) {\n                    continue;\n                }\n                \n                while (!active[currentPlayer]) {\n                    currentPlayer++;\n                    if (currentPlayer > m) currentPlayer = 1;\n                }\n                \n                String correct = getCorrectStatement(currentNumber);\n                \n                if (!statement.equals(correct)) {\n                    active[currentPlayer] = false;\n                    activePlayers--;\n                } else {\n                    currentNumber++;\n                }\n                \n                if (activePlayers > 1) {\n                    currentPlayer++;\n                    if (currentPlayer > m) currentPlayer = 1;\n                }\n            }\n            \n            List<Integer> result = new ArrayList<>();\n            for (int i = 1; i <= m; i++) {\n                if (active[i]) {\n                    result.add(i);\n                }\n            }\n            \n            for (int i = 0; i < result.size(); i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(result.get(i));\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n    \n    static String getCorrectStatement(int num) {\n        if (num % 15 == 0) {\n            return \"FizzBuzz\";\n        } else if (num % 3 == 0) {\n            return \"Fizz\";\n        } else if (num % 5 == 0) {\n            return \"Buzz\";\n        } else {\n            return String.valueOf(num);\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int m = sc.nextInt(); int n = sc.nextInt(); if (m == 0 && n == 0) break; boolean[] active = new boolean[m + 1]; for (int i = 1; i <= m; i++) { active[i] = true; } int  m; for (int i = 0; i < n; i++) { String statement = sc.next(); if (activePlayers == 1) { continue; } while (!active[currentPlayer]) {  correct = getCorrectStatement(currentNumber);  (currentPlayer > m) currentPlayer = 1; } } List<Integer> result = new ArrayList<>(); for (int i = 1; i <= m; i++) { if (active[i]) { result.add(i); } }  if (i > 0) System.out.print(\" \"); System.out.print(result.get(i)); } System.out.println(); } sc.close(); } static String getCorrectStatement(int num) {  else if (num % 3 == 0) { return \"Fizz\"; } else if (num % 5 == 0) { return \"Buzz\"; } else { return String.valueOf(num); } } }"], "perturbed_original": ["import java.util.*; class Main { public static void  m,n; FizzBuzz fb; for(;;) { m = sc.nextInt(); n = sc.nextInt(); if(m==0 && n==0) { break; } fb = new FizzBuzz(m); for(int i=0; i<n; i++) { if(!fb.sayNextStatement(sc.next())) { break; } } fb.showPlayer(); } } } class FizzBuzz { private int current,currentPlayer;  current = 0; currentPlayer = 0; this.m = m; player = new int[m]; for(int i=0; i<m; i++) { player[i] = i+1; } } public void showPlayer() { for(int pl:player){ if(pl  { try { int num = Integer.valueOf(statement); if(!checkFizzBuzz(num)) {  player[currentPlayer] = -1; } } if(!setCurrentPlayer())  {  0; } else { currentPlayer ++; } while(player[currentPlayer] == -1) { if(currentPlayer+1 == m) { currentPlayer = 0; } else { currentPlayer ++; } if(prev == currentPlayer) { return false; } } return true; } private boolean checkFizzBuzz(int statement) { current ++; if((current % 3 ==  } else { if(current == statement) { return  boolean checkFizzBuzz(String statement) { current ++; if((current % 3 == 0) && (current % 5 == 0)) { if(statement.equals(\"FizzBuzz\")) { return true; } else { return false; } } else if(current % 3 == 0) { if(statement.equals(\"Fizz\")) {  if(current % 5 == 0) { if(statement.equals(\"Buzz\")) { return true; } else { return false; } } else { return false; } } }"], "original_ll": -0.6554927825927734, "sampled_ll": -0.535376787185669, "all_perturbed_sampled_ll": [-1.214228630065918], "all_perturbed_original_ll": [-1.5621205568313599], "perturbed_sampled_ll": -1.214228630065918, "perturbed_original_ll": -1.5621205568313599, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# Aizu Problem 0221: Fizz Buzz\n\nimport sys, math, os, struct\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\ndef valid(k, a):\n    if k % 3 == 0 and k % 5 == 0:\n        return a == \"FizzBuzz\"\n    elif k % 3 == 0:\n        return a == \"Fizz\"\n    elif k % 5 == 0:\n        return a == \"Buzz\"\n    else:\n        return int(a) == k\n\n    \ndef fizz_buzz(m, n, A):\n    players = list(range(1, m + 1))\n    p = 0\n    k = 0\n    while len(A) > 0:\n        k += 1\n        a = A.pop(0)\n        if valid(k, a):\n            p = (p + 1) % m\n        else:\n            if len(players) == 0:\n                print()\n                return\n            players.pop(p)\n            if len(players) == 1:\n                break\n            m -= 1\n            if p == m:\n                p = 0\n    print(' '.join([str(p) for p in players]))\n    \n    \nwhile True:\n    m, n = [int(_) for _ in input().split()]\n    if m == 0:\n        break\n    A = [input().strip() for _ in range(n)]\n    fizz_buzz(m, n, A)", "sampled": "def get_expected(num):\n    if num % 15 == 0:\n        return \"FizzBuzz\"\n    elif num % 3 == 0:\n        return \"Fizz\"\n    elif num % 5 == 0:\n        return \"Buzz\"\n    else:\n        return str(num)\n\nwhile True:\n    line = input().split()\n    m, n = int(line[0]), int(line[1])\n    \n    if m == 0 and n == 0:\n        break\n    \n    players = set(range(1, m + 1))\n    current_num = 1\n    current_player = 1\n    \n    for _ in range(n):\n        statement = input().strip()\n        \n        if len(players) == 1:\n            continue\n        \n        while current_player not in players:\n            current_player += 1\n            if current_player > m:\n                current_player = 1\n        \n        expected = get_expected(current_num)\n        \n        if statement != expected:\n            players.discard(current_player)\n        \n        current_num += 1\n        current_player += 1\n        if current_player > m:\n            current_player = 1\n    \n    result = sorted(list(players))\n    print(' '.join(map(str, result)))\n", "perturbed_sampled": ["def get_expected(num): if num % 15 == 0: return \"FizzBuzz\" elif num % 3 == 0: return \"Fizz\" elif num % 5 == 0: return \"Buzz\" else: .values() [<extra_id_3>else: print(' '.join(map(str, cur)).replace('_','_')<extra_id_4>break<extra_id_5>break result . add<extra_id_6>current_player ) #print(' '<extra_id_7>return<extra_id_1>\"Mann\" else int(line[0]), int(line[1]) if m == 0 and n == 0: break players = set(range(1, m + 1)) current_num = 1 current_player = 1 for _ in range(n): statement  in  1 expected = get_expected(current_num) if statement != expected: players.discard(current_player) current_num += 1 current_player += 1 if current_player > m: current_player = 1 result = sorted(list(players)) print(' '.join(map(str, result)))"], "perturbed_original": ["# Aizu Problem 0221: Fizz Buzz import sys, math, os, struct # read input: PYDEV = os.environ.get('PYDEV') if PYDEV==\"True\": sys.stdin = open(\"sample-input.txt\", \"rt\") def valid(k, a): if k % 3 == 0 and k % 5 == <extra_id_3>in players])) p<extra_id_4>: print(' '.join[str(p)) ,<extra_id_5>print('<extra_id_6>players.pop(p)<extra_id_7>if<extra_id_8>: p +=<extra_id_9>1<extra_id_10>0:<extra_id_11>== -<extra_id_12>(players.pop(0)*12.5 elif valid(9,<extra_id_13>:<extra_id_14>players . pop(p)<extra_id_15># if<extra_id_16> 0: return a == \"Fizz\" elif k % 5 == 0: return a == \"Buzz\" else: return int(a) == k def fizz_buzz(m, n, A): players = list(range(1, m + 1)) p = 0 k = 0 while len(A) > 0: k += 1 a = A.pop(0) if valid(k, a): p = (p +  players.pop(p)  == m: p = 0 print(' '.join([str(p) for p in players])) while True: m, n = [int(_) for  [input().strip() for _ in range(n)] fizz_buzz(m, n, A)"], "original_ll": -1.1929103136062622, "sampled_ll": -0.9095302224159241, "all_perturbed_sampled_ll": [-2.3546078205108643], "all_perturbed_original_ll": [-2.357494354248047], "perturbed_sampled_ll": -2.3546078205108643, "perturbed_original_ll": -2.357494354248047, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "c[1<<23],*p,n=1e7;main(a,b){for(;a+=2,a<n;)for(b=a/2;(b+=a)<n;)c[b]=1;for(;scanf(\"%d\",&n)*n;printf(\"%d\\n\",n))for(;p=c+n/2-4,~n&1|p[4]|p[3]|p[1]|*p;n--);}", "sampled": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX 10000010\n\nbool is_prime[MAX];\nint quadruplets[MAX];\n\nvoid sieve() {\n    memset(is_prime, true, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n}\n\nvoid find_quadruplets() {\n    memset(quadruplets, 0, sizeof(quadruplets));\n    \n    for (int a = 2; a + 8 < MAX; a++) {\n        if (is_prime[a] && is_prime[a+2] && is_prime[a+6] && is_prime[a+8]) {\n            int size = a + 8;\n            quadruplets[size] = size;\n        }\n    }\n    \n    int max_so_far = 0;\n    for (int i = 0; i < MAX; i++) {\n        if (quadruplets[i] > 0) {\n            max_so_far = quadruplets[i];\n        }\n        quadruplets[i] = max_so_far;\n    }\n}\n\nint main() {\n    sieve();\n    find_quadruplets();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        printf(\"%d\\n\", quadruplets[n]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  void sieve() { memset(is_prime, true, sizeof(is_prime)); is_prime[0] = is_prime[1] = false; for (int i = 2; i *  j = i * i; j < MAX; j += i) { is_prime[j] = false; }  (int a = 2; a + 8 < MAX; a++) { if (is_prime[a] && is_prime[a+2] && is_prime[a+6] && is_prime[a+8]) { int size = a + 8; quadruplets[size] = size; } } int max_so_far = 0; for (int i = 0; i < MAX; i++) { if (quadruplets[i] > 0) { max_so_far = quadruplets[i]; } quadruplets[i] = max_so_far; }  &n) == 1 && n != 0) { printf(\"%d\\n\", quadruplets[n]); } return 0; }"], "perturbed_original": ["c[1<<23],*p,n=1e7;main(a,b){for(;a+=2,a<n;)for(b=a/2;(b+=a)<n;)c[b]=1;for(;scanf(\"%d\",&n)*n;printf(\"%d\\n\",n))for(;p=c+n/2-4,~n&1|p[4]|p[3]|p[1]|*p;n--);}"], "original_ll": -3.0333800315856934, "sampled_ll": -0.5400764346122742, "all_perturbed_sampled_ll": [-1.471227765083313], "all_perturbed_original_ll": [-3.0333800315856934], "perturbed_sampled_ll": -1.471227765083313, "perturbed_original_ll": -3.0333800315856934, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tfinal int MAX = 10000000;\n\n\tboolean[] prime = new boolean[MAX + 10];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tArrays.fill(prime, true);\n\n\t\t//\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\n\t\tprime[0] = prime[1] = false;\n\t\tfor (int i = 2; i * i < MAX + 10; i++) {\n\t\t\tif (prime[i]) {\n\t\t\t\tfor (int j = i + i; j < MAX + 10; j += i) {\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint max = 0;\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = n; i >= 8; i--) {\n\t\t\t\tif (prime[i] && prime[i - 2] && prime[i - 6] && prime[i - 8]) {\n\t\t\t\t\tmax = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int MAX = 10000000;\n        boolean[] isPrime = new boolean[MAX + 10];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i <= MAX + 8; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= MAX + 8; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        List<Integer> quadPrimes = new ArrayList<>();\n        for (int a = 2; a <= MAX; a++) {\n            if (isPrime[a] && isPrime[a + 2] && isPrime[a + 6] && isPrime[a + 8]) {\n                quadPrimes.add(a + 8);\n            }\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int result = 0;\n            for (int size : quadPrimes) {\n                if (size <= n) {\n                    result = size;\n                } else {\n                    break;\n                }\n            }\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int MAX = 10000000; boolean[] isPrime = new boolean[MAX + 10]; Arrays.fill(isPrime, true); isPrime[0] = isPrime[1] = false; for (int  i++)  i; j <= MAX + 8;  List<Integer> quadPrimes = new ArrayList<>(); for (int a = 2; a <= MAX; a++) { if (isPrime[a] && isPrime[a + 2] && isPrime[a + 6] && isPrime[a + 8]) { quadPrimes.add(a + 8); } } while (true) { int n = sc.nextInt(); if (n == 0) break; int result = 0; for (int size : quadPrimes) { if (size <= n) { result  sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { final int MAX = 10000000; boolean[] prime = new boolean[MAX +  true); //\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9 prime[0] = prime[1] = false; for (int i = 2; i * i < MAX + 10; i++)  { int n = sc.nextInt(); int max = 0; if (n == 0) { break; } for (int i = n; i >= 8; i--) { if (prime[i] && prime[i - 2] && prime[i - 6] && prime[i - 8]) { max = i; break; } } System.out.println(max); } } public static void main(String[] args) { new Main().run(); } }"], "original_ll": -0.7576233148574829, "sampled_ll": -0.5165873169898987, "all_perturbed_sampled_ll": [-1.1912693977355957], "all_perturbed_original_ll": [-1.3805015087127686], "perturbed_sampled_ll": -1.1912693977355957, "perturbed_original_ll": -1.3805015087127686, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def get_quad(n, p):\n    for ni in range(n,0,-1):\n        if p[ni] and p[ni - 2] and p[ni - 6] and p[ni - 8]:\n            return ni\n        \ndef sieve():\n    n = 10000001\n    p = [1] * n\n    p[0] = p[1] = 0\n    \n    for i in range(int(n ** 0.5)):\n        if p[i]:\n            for j in range(2 * i, len(p), i):\n                p[j] = 0\n    return p\nimport sys\nf = sys.stdin\n\nprime = sieve()\nwhile True:\n    n = f.readline()\n    if not n.isnumeric():\n        continue\n    n = int(n)\n    if n == 0:\n        break\n    print(get_quad(ni, prime))", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\ndef find_quadruplet_primes(limit):\n    is_prime = sieve_of_eratosthenes(limit)\n    quadruplets = []\n    \n    for a in range(2, limit - 7):\n        if is_prime[a] and is_prime[a+2] and is_prime[a+6] and is_prime[a+8]:\n            quadruplets.append(a + 8)\n    \n    return quadruplets\n\n# Precompute all quadruplet primes up to 10,000,000\nMAX_LIMIT = 10000000\nquadruplet_sizes = find_quadruplet_primes(MAX_LIMIT)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    # Binary search for the largest quadruplet size <= n\n    result = 0\n    for size in quadruplet_sizes:\n        if size <= n:\n            result = size\n        else:\n            break\n    \n    print(result)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1]  is_prime[i]: for j in range(i*i, limit + 1, i): is_prime[j] = False return is_prime def find_quadruplet_primes(limit): is_prime = sieve_of_eratosthenes(limit) quadruplets = [] for a in range(2, limit - 7): if is_prime[a] and is_prime[a+2] and is_prime[a+6] and is_prime[a+8]: quadruplets.append(a + 8) return quadruplets # Precompute all quadruplet primes up to 10,000,000 MAX_LIMIT = 10000000 quadruplet_sizes = find_quadruplet_primes(MAX_LIMIT) while True: n = int(input()) if  in quadruplet_sizes: if size <= n: result = size else: break print(result)"], "perturbed_original": ["def get_quad(n, p): for ni in range(n,0,-1): if p[ni] and p[ni - 2] and p[ni - 6] and p[ni - 8]: return ni def sieve(): n = 10000001 p = [1] * n p[0] =   = 0 return p import sys f = sys.stdin prime = sieve() while True: n = f.readline() if not n.isnumeric(): continue n = int(n) if n == 0: break print(get_quad(ni, prime))"], "original_ll": -1.2205712795257568, "sampled_ll": -0.6833537817001343, "all_perturbed_sampled_ll": [-1.2508206367492676], "all_perturbed_original_ll": [-1.9297926425933838], "perturbed_sampled_ll": -1.2508206367492676, "perturbed_original_ll": -1.9297926425933838, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\n#include<stdbool.h>\n\n#define MIN(x,y) (((x)<(y))?(x):(y))\n#define INFTY (1<<21)\n\n\nint m, n, k, d, C[7], G[110][110], N, D[110][64];\n\nint getID(char *str);\nint isC(int x);\nint bellman(void);\n\nint main(void){\n  char source[16], target[16];\n  int cost,s,t;\n  int i,j;\n  while(scanf(\"%d%*c%d%*c%d%*c%d%*c\",&m,&n,&k,&d) && m ){\n    N = 2 + n + m;\n    for(i=1;i<m+1;i++) scanf(\"%d%*c\",&C[i]);\n    for(i=0;i<N;i++) for(j=0;j<N;j++) G[i][j] = INFTY;\n    for(i=0;i<d;i++){\n      scanf(\"%s%*c%s%*c%d%*c\",source,target,&cost);\n      s = getID(source);\n      t = getID(target);\n      G[t][s] = G[s][t] = MIN(G[s][t], cost * k);\n    }\n    printf(\"%d\\n\",bellman());\n  }\n  return 0;\n}\n\nint getID(char *str){\n  char num[16];\n  if ( str[0] == 'H' ) return 0;\n  if ( str[0] == 'D' ) return N - 1;\n  strcpy(num,str+1);\n  if ( str[0] == 'C' ) return atoi(num);\n  return atoi(num) + m;\n}\n\nint isC(int x){\n  return 1 <= x && x <= m;\n}\nint bellman(void){\n  bool change=0;\n  int minv;\n  int i,o,u,v,b,j;\n\n  for(i=0;i<N;i++) for(j=0;j<(1<<m);j++) D[i][j] = INFTY;\n  D[0][0] = 0;\n  for(o=0;o<N*(1<<m);o++){\n    for(u=0;u<N;u++){\n      for(v=0;v<N;v++){\n\tif ( u == v || G[u][v] == INFTY ) continue;\n\tfor(b=0;b<(1<<m);b++){\n\t  if (isC(v) && (b&(1<<(v-1))) != 0 ) continue;\n\t  if ( isC(v) ) {\n\t    if ( D[u][b] + G[u][v] - C[v] < D[v][b|(1<<(v-1))] ) {\n\t      D[v][b|(1<<(v-1))] = D[u][b] + G[u][v] - C[v];\n\t      change = true;\n\t    }\n\t  } else {\n\t    if ( D[u][b] + G[u][v] < D[v][b] ){\n\t      D[v][b] = D[u][b] + G[u][v];\n\t      change = true;\n\t    }\n\t  }\n\t}\n      }\n    }\n    if ( !change ) break;\n  }\n  minv = INFTY;\n  for(i=0;i<(1<<m);i++) minv = MIN(minv, D[N-1][i]);\n  return minv;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define INF 1000000000\n#define MAX_NODES 110\n\nint m, n, k, d;\nint calories[10];\nint dist[MAX_NODES][MAX_NODES];\nint H_idx, D_idx;\nint C_idx[10];\nint L_idx[110];\n\nint parse_node(char *s) {\n    if (s[0] == 'H') return H_idx;\n    if (s[0] == 'D') return D_idx;\n    if (s[0] == 'C') {\n        int num;\n        sscanf(s + 1, \"%d\", &num);\n        return C_idx[num - 1];\n    }\n    if (s[0] == 'L') {\n        int num;\n        sscanf(s + 1, \"%d\", &num);\n        return L_idx[num - 1];\n    }\n    return -1;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid floyd_warshall(int nodes) {\n    for (int k = 0; k < nodes; k++) {\n        for (int i = 0; i < nodes; i++) {\n            for (int j = 0; j < nodes; j++) {\n                if (dist[i][k] != INF && dist[k][j] != INF) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d %d\", &m, &n, &k, &d);\n        if (m == 0 && n == 0 && k == 0 && d == 0) break;\n\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d\", &calories[i]);\n        }\n\n        int nodes = 2 + m + n;\n        H_idx = 0;\n        D_idx = 1;\n        for (int i = 0; i < m; i++) C_idx[i] = 2 + i;\n        for (int i = 0; i < n; i++) L_idx[i] = 2 + m + i;\n\n        for (int i = 0; i < nodes; i++) {\n            for (int j = 0; j < nodes; j++) {\n                if (i == j) dist[i][j] = 0;\n                else dist[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < d; i++) {\n            char s[10], t[10];\n            int e;\n            scanf(\"%s %s %d\", s, t, &e);\n            int u = parse_node(s);\n            int v = parse_node(t);\n            dist[u][v] = min(dist[u][v], e);\n            dist[v][u] = min(dist[v][u], e);\n        }\n\n        floyd_warshall(nodes);\n\n        int min_cost = INF;\n        for (int mask = 0; mask < (1 << m); mask++) {\n            int perm[10];\n            int cnt = 0;\n            for (int i = 0; i < m; i++) {\n                if (mask & (1 << i)) {\n                    perm[cnt++] = i;\n                }\n            }\n\n            if (cnt == 0) {\n                int total_dist = dist[H_idx][D_idx];\n                int cost = total_dist * k;\n                min_cost = min(min_cost, cost);\n            } else {\n                int fact = 1;\n                for (int i = 1; i <= cnt; i++) fact *= i;\n                \n                for (int p = 0; p < fact; p++) {\n                    int temp_perm[10];\n                    for (int i = 0; i < cnt; i++) temp_perm[i] = perm[i];\n                    \n                    int temp = p;\n                    for (int i = 0; i < cnt; i++) {\n                        int j = i + temp % (cnt - i);\n                        temp /= (cnt - i);\n                        int t = temp_perm[i];\n                        temp_perm[i] = temp_perm[j];\n                        temp_perm[j] = t;\n                    }\n\n                    int total_dist = dist[H_idx][C_idx[temp_perm[0]]];\n                    int total_cal = calories[temp_perm[0]];\n                    for (int i = 1; i < cnt; i++) {\n                        total_dist += dist[C_idx[temp_perm[i - 1]]][C_idx[temp_perm[i]]];\n                        total_cal += calories[temp_perm[i]];\n                    }\n                    total_dist += dist[C_idx[temp_perm[cnt - 1]]][D_idx];\n\n                    int cost = total_dist * k - total_cal;\n                    min_cost = min(min_cost, cost);\n                }\n            }\n        }\n\n        printf(\"%d\\n\", min_cost);\n    }\n    return 0;\n}\n", "perturbed_sampled": [" MAX_NODES 110  H_idx, D_idx; int C_idx[10]; int L_idx[110]; int parse_node(char *s) { if (s[0] == 'H') return H_idx; if (s[0] == 'D') return D_idx; if (s[0] == 'C') { int num; sscanf(s + 1, \"%d\", &num); return C_idx[num - 1]; } if (s[0] == 'L') { int num; sscanf(s + 1, \"%d\", &num); return L_idx[num - 1]; } return -1; } int min(int a, int b) { return a < b ? a : b; } void floyd_warshall(int nodes) { for (int k = 0; k < nodes; k++) { for (int i = 0; i < nodes; i++) {  dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } } } } } int main() { while (1) { scanf(\"%d %d  && n == 0  (int i = 0; i < m; i++) { scanf(\"%d\", &calories[i]); } int nodes = 2 + m + n;  0; i < m; i++) C_idx[i] = 2 + i; for (int i = 0; i < n; i++) L_idx[i] = 2 + m + i; for (int i = 0; i < nodes; i++) { for (int j = 0; j < nodes; j++) { if (i == j) dist[i][j] = 0; else dist[i][j] = INF; } } for (int i = 0; i < d; i++) { char s[10], t[10]; int e; scanf(\"%s %s %d\", s, t, &e); int u = parse_node(s); int v = parse_node(t); dist[u][v] = min(dist[u][v], e); dist[v][u] = min(dist[v][u], e); } floyd_warshall(nodes); int min_cost = INF; for (int mask = 0; mask < (1   if (mask & (1 << i)) { perm[cnt++] = i; } } if (cnt == 0) { int  1; for (int i = 1; i <= cnt;  < fact; p++) { int temp_perm[10]; for (int i = 0;  p; for (int i = 0; i < cnt; i++) { int j = i + temp % (cnt - i); temp /= (cnt - i); int t = temp_perm[i]; temp_perm[i] = temp_perm[j]; temp_perm[j] = t; } int total_dist  1; i < cnt; i++) { total_dist += dist[C_idx[temp_perm[i - 1]]][C_idx[temp_perm[i]]]; total_cal += calories[temp_perm[i]]; } total_dist += dist[C_idx[temp_perm[cnt - 1]]][D_idx]; int cost = total_dist * k - total_cal;  return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> #include<stdbool.h> #define  C[7], G[110][110], N, D[110][64]; int getID(char *str); int isC(int x); int bellman(void); int main(void){ char source[16], target[16]; int cost,s,t; int i,j; while(scanf(\"%d%*c%d%*c%d%*c%d%*c\",&m,&n,&k,&d) && m ){ N = 2 + n + m; for(i=1;i<m+1;i++) scanf(\"%d%*c\",&C[i]); for(i=0;i<N;i++)  = getID(target); G[t][s] = G[s][t] = MIN(G[s][t], cost  return 0; if ( str[0] == 'D' ) return N - 1; strcpy(num,str+1); if ( str[0] == 'C' ) return atoi(num); return atoi(num) + m; } int isC(int x){ return 1 <= x && x <= m; }  D[i][j] = INFTY; D[0][0] = 0; for(o=0;o<N*(1<<m);o++){ for(u=0;u<N;u++){ for(v=0;v<N;v++){ if ( u == v || G[u][v] == INFTY ) continue; for(b=0;b<(1<<m);b++){ if (isC(v) && (b&(1<<(v-1))) != 0 ) continue; if ( isC(v) ) { if ( D[u][b] + G[u][v]  G[u][v] - C[v]; change = true; } } else { if ( D[u][b] + G[u][v] < D[v][b] ){ D[v][b] = D[u][b] + G[u][v]; change = true; } } } } } if ( !change ) break; } minv = INFTY; for(i=0;i<(1<<m);i++) minv = MIN(minv, D[N-1][i]); return minv; }"], "original_ll": -0.9954560995101929, "sampled_ll": -0.5099862217903137, "all_perturbed_sampled_ll": [-1.189185380935669], "all_perturbed_original_ll": [-1.6422183513641357], "perturbed_sampled_ll": -1.189185380935669, "perturbed_original_ll": -1.6422183513641357, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tstatic int m;\n\tstatic int n;\n\tstatic int k;\n\tstatic int d;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tk = sc.nextInt();\n\t\t\td = sc.nextInt();\n\t\t\tif(m == 0 && n == 0 && k == 0 && d == 0) break;\n\t\t\tint[] c = new int[m];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] node = new Node[m + n + 2];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tnode[i] = new Node();\n\t\t\t\tnode[i].type = 2;\n\t\t\t}\n\t\t\tfor(int i = m; i < m + n; i++) {\n\t\t\t\tnode[i] = new Node();\n\t\t\t\tnode[i].type = 3;\n\t\t\t}\n\t\t\tnode[m + n    ] = new Node();\n\t\t\tnode[m + n    ].type = 0;\n\t\t\tnode[m + n + 1] = new Node();\n\t\t\tnode[m + n + 1].type = 1;\n\t\t\t\n\t\t\tfor(int i = 0; i < d; i++) {\n\t\t\t\tString a = sc.next();\n\t\t\t\tString b = sc.next();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tint idA = -100;\n\t\t\t\tint idB = -100;\n\t\t\t\tif(a.length() == 1) {\n\t\t\t\t\tif(a.equals(\"H\")) idA = m + n;\n\t\t\t\t\telse \t\t\t  idA = m + n + 1;\n\t\t\t\t}\n\t\t\t\tif(b.length() == 1) {\n\t\t\t\t\tif(b.equals(\"H\")) idB = m + n;\n\t\t\t\t\telse\t\t\t  idB = m + n + 1;\n\t\t\t\t}\n\t\t\t\tif(idA == -100) {\n\t\t\t\t\tif(a.charAt(0) == 'C') {\n\t\t\t\t\t\tidA = Integer.parseInt(a.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tidA = m + Integer.parseInt(a.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(idB == -100) {\n\t\t\t\t\tif(b.charAt(0) == 'C') {\n\t\t\t\t\t\tidB = Integer.parseInt(b.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tidB = m + Integer.parseInt(b.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode[idA].edge_to.add(idB);\n\t\t\t\tnode[idA].edge_cost.add(cost);\n\t\t\t\tnode[idB].edge_to.add(idA);\n\t\t\t\tnode[idB].edge_cost.add(cost);\n\t\t\t}\n\t\t\tint[][] dp = new int[n + m + 2][1 << m];\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tfor(int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\tdp[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Data> queue = new PriorityQueue<Data>();\n\t\t\tqueue.add(new Data(m + n,new boolean[m],0));\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tData tmp = queue.poll();\n\t\t\t\tint V = 0;\n\t\t\t\tfor(int i = 0; i < tmp.v.length; i++) {\n\t\t\t\t\tif(tmp.v[i]) {\n\t\t\t\t\t\tV |= 1 << i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dp[tmp.now][V] <= tmp.cost) continue;\n\t\t\t\tdp[tmp.now][V] = tmp.cost;\n\t\t\t\tNode now = node[tmp.now];\n\t\t\t\tfor(int i = 0; i < now.edge_to.size(); i++) {\n\t\t\t\t\tif(node[now.edge_to.get(i)].type == 2 && tmp.v[now.edge_to.get(i)]) continue;\n\t\t\t\t\tif(node[now.edge_to.get(i)].type == 2) {\n\t\t\t\t\t\tboolean[] copy = Arrays.copyOf(tmp.v, tmp.v.length);\n\t\t\t\t\t\tcopy[now.edge_to.get(i)] = true; \n\t\t\t\t\t\tqueue.add(new Data(now.edge_to.get(i),copy, tmp.cost - c[now.edge_to.get(i)] + now.edge_cost.get(i) * k));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tqueue.add(new Data(now.edge_to.get(i),tmp.v, tmp.cost + now.edge_cost.get(i) * k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint MIN = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < dp[m + n + 1].length; i++) {\n\t\t\t\tMIN = Math.min(MIN, dp[m + n + 1][i]);\n\t\t\t}\n\t\t\tSystem.out.println(MIN);\n\t\t}\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint cost;\n\t\tboolean[] v;\n\t\tint now;\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t\tData(int c, boolean[] b, int a) {\n\t\t\tcost = a;\n\t\t\tv    = b;\n\t\t\tnow  = c;\n\t\t}\n\t}\n\tstatic class Node {\n\t\tint type; // 0 H, 1 D, 2 C, 3 L\n\t\tboolean c;\n\t\tArrayList<Integer> edge_to = new ArrayList<Integer>();\n\t\tArrayList<Integer> edge_cost = new ArrayList<Integer>();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Edge {\n        String to;\n        int dist;\n        Edge(String to, int dist) {\n            this.to = to;\n            this.dist = dist;\n        }\n    }\n    \n    static Map<String, List<Edge>> graph;\n    static int[] cakeCals;\n    static int m, n, k, d;\n    static Map<String, Integer> nodeToIdx;\n    static String[] idxToNode;\n    static int numNodes;\n    static int[][] dist;\n    static final int INF = 1000000000;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            m = Integer.parseInt(parts[0]);\n            n = Integer.parseInt(parts[1]);\n            k = Integer.parseInt(parts[2]);\n            d = Integer.parseInt(parts[3]);\n            \n            if (m == 0 && n == 0 && k == 0 && d == 0) break;\n            \n            cakeCals = new int[m + 1];\n            parts = br.readLine().trim().split(\"\\\\s+\");\n            for (int i = 1; i <= m; i++) {\n                cakeCals[i] = Integer.parseInt(parts[i - 1]);\n            }\n            \n            graph = new HashMap<>();\n            Set<String> nodes = new HashSet<>();\n            \n            for (int i = 0; i < d; i++) {\n                parts = br.readLine().trim().split(\"\\\\s+\");\n                String s = parts[0];\n                String t = parts[1];\n                int e = Integer.parseInt(parts[2]);\n                \n                nodes.add(s);\n                nodes.add(t);\n                \n                graph.putIfAbsent(s, new ArrayList<>());\n                graph.putIfAbsent(t, new ArrayList<>());\n                graph.get(s).add(new Edge(t, e));\n                graph.get(t).add(new Edge(s, e));\n            }\n            \n            nodeToIdx = new HashMap<>();\n            idxToNode = new String[nodes.size()];\n            int idx = 0;\n            for (String node : nodes) {\n                nodeToIdx.put(node, idx);\n                idxToNode[idx] = node;\n                idx++;\n            }\n            numNodes = nodes.size();\n            \n            // Floyd-Warshall\n            dist = new int[numNodes][numNodes];\n            for (int i = 0; i < numNodes; i++) {\n                Arrays.fill(dist[i], INF);\n                dist[i][i] = 0;\n            }\n            \n            for (String from : graph.keySet()) {\n                int fromIdx = nodeToIdx.get(from);\n                for (Edge e : graph.get(from)) {\n                    int toIdx = nodeToIdx.get(e.to);\n                    dist[fromIdx][toIdx] = Math.min(dist[fromIdx][toIdx], e.dist);\n                }\n            }\n            \n            for (int kk = 0; kk < numNodes; kk++) {\n                for (int i = 0; i < numNodes; i++) {\n                    for (int j = 0; j < numNodes; j++) {\n                        if (dist[i][kk] != INF && dist[kk][j] != INF) {\n                            dist[i][j] = Math.min(dist[i][j], dist[i][kk] + dist[kk][j]);\n                        }\n                    }\n                }\n            }\n            \n            int minCal = INF;\n            \n            // Try all permutations of visiting cake shops\n            for (int mask = 0; mask < (1 << m); mask++) {\n                List<Integer> cakeShops = new ArrayList<>();\n                for (int i = 0; i < m; i++) {\n                    if ((mask & (1 << i)) != 0) {\n                        cakeShops.add(i + 1);\n                    }\n                }\n                \n                if (cakeShops.isEmpty()) {\n                    int hIdx = nodeToIdx.get(\"H\");\n                    int dIdx = nodeToIdx.get(\"D\");\n                    int totalDist = dist[hIdx][dIdx];\n                    int cal = totalDist * k;\n                    minCal = Math.min(minCal, cal);\n                } else {\n                    int[] perm = new int[cakeShops.size()];\n                    for (int i = 0; i < cakeShops.size(); i++) {\n                        perm[i] = cakeShops.get(i);\n                    }\n                    \n                    permute(perm, 0, minCal);\n                }\n            }\n            \n            System.out.println(minCal);\n        }\n    }\n    \n    static int minCal;\n    \n    static void permute(int[] arr, int start, int currentMin) {\n        if (start == arr.length) {\n            int hIdx = nodeToIdx.get(\"H\");\n            int dIdx = nodeToIdx.get(\"D\");\n            \n            int totalDist = dist[hIdx][nodeToIdx.get(\"C\" + arr[0])];\n            int totalCakeCal = cakeCals[arr[0]];\n            \n            for (int i = 1; i < arr.length; i++) {\n                totalDist += dist[nodeToIdx.get(\"C\" + arr[i - 1])][nodeToIdx.get(\"C\" + arr[i])];\n                totalCakeCal += cakeCals[arr[i]];\n            }\n            \n            totalDist += dist[nodeToIdx.get(\"C\" + arr[arr.length - 1])][dIdx];\n            \n            int cal = totalDist * k - totalCakeCal;\n            minCal = Math.min(minCal, cal);\n            return;\n        }\n        \n        for (int i = start; i < arr.length; i++) {\n            swap(arr, i, start);\n            permute(arr, start + 1, currentMin);\n            swap(arr, i, start);\n        }\n    }\n    \n    static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class Edge { String to; int dist; Edge(String to, int dist) { this.to = to; this.dist = dist; } } static Map<String, List<Edge>> graph; static int[] cakeCals; static int m, n,  int numNodes; static  void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] parts = line.trim().split(\"\\\\s+\"); m = Integer.parseInt(parts[0]); n = Integer.parseInt(parts[1]); k = Integer.parseInt(parts[2]); d = Integer.parseInt(parts[3]); if (m == 0 && n == 0 && k == 0 && d == 0) break; cakeCals = new int[m + 1]; parts = br.readLine().trim().split(\"\\\\s+\"); for (int i = 1; i <= m; i++) {  Set<String> nodes = new HashSet<>(); for (int i = 0; i < d; i++) { parts = br.readLine().trim().split(\"\\\\s+\"); String s = parts[0]; String t = parts[1]; int e = Integer.parseInt(parts[2]); nodes.add(s); nodes.add(t); graph.putIfAbsent(s, new ArrayList<>());  idx = 0; for (String node : nodes) { nodeToIdx.put(node, idx); idxToNode[idx] = node; idx++; } numNodes = nodes.size(); // Floyd-Warshall dist = new int[numNodes][numNodes]; for (int i  = 0; } for (String from : graph.keySet()) { int fromIdx = nodeToIdx.get(from); for (Edge e : graph.get(from)) { int toIdx = nodeToIdx.get(e.to); dist[fromIdx][toIdx] = Math.min(dist[fromIdx][toIdx], e.dist); } } for (int kk = 0; kk < numNodes; kk++) { for (int i = 0; i < numNodes; i++) { for (int j = 0; j < numNodes; j++)  dist[i][j] = Math.min(dist[i][j], dist[i][kk] + dist[kk][j]); } } } } int minCal = INF; // Try all permutations of visiting cake shops for (int mask = 0; mask < (1 << m); mask++) { List<Integer> cakeShops = new ArrayList<>(); for (int i = 0; i < m; i++) { if ((mask & (1 << i)) != 0)   dist[hIdx][dIdx]; int cal = totalDist * k; minCal = Math.min(minCal, cal); } else { int[] perm = new int[cakeShops.size()]; for (int i = 0; i < cakeShops.size(); i++) { perm[i] = cakeShops.get(i); } permute(perm,  arr[0])]; int totalCakeCal = cakeCals[arr[0]]; for (int i = 1; i < arr.length; i++) { totalDist += dist[nodeToIdx.get(\"C\" + arr[i  * k - totalCakeCal; minCal = Math.min(minCal, cal); return; } for (int i = start; i  1, currentMin); swap(arr, i, start); } } static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } }"], "perturbed_original": ["import java.util.*; import java.math.*; public class Main{ static int INF = 2 << 27; static int m; static int n; static int k; static  = new Scanner(System.in); while(true) { m = sc.nextInt(); n = sc.nextInt(); k = sc.nextInt(); d = sc.nextInt(); if(m == 0 && n == 0 && k ==  int[m]; for(int i = 0; i < m; i++) { c[i] = sc.nextInt();  for(int i = 0; i < m; i++) { node[i]  m; i < m + n;  node[m + n ] = new Node(); node[m + n ].type = 0; node[m + n + 1] = new Node(); node[m + n + 1].type = 1; for(int i = 0; i < d; i++) { String a = sc.next(); String b = sc.next(); int cost = sc.nextInt(); int idA = -100; int idB = -100; if(a.length() == 1) { if(a.equals(\"H\")) idA = m + n; else idA = m + n + 1; } if(b.length() == 1) { if(b.equals(\"H\")) idB  + 1; }  Integer.parseInt(a.substring(1)) - 1; } else { idA = m + Integer.parseInt(a.substring(1)) - 1; } } if(idB == -100) { if(b.charAt(0) == 'C') { idB = Integer.parseInt(b.substring(1)) - 1; } else { idB = m  } int[][] dp = new  0; i < dp.length; i++) { for(int j = 0; j < dp[i].length; j++) {  queue.add(new Data(m + n,new boolean[m],0)); while(!queue.isEmpty()) { Data tmp = queue.poll(); int V = 0; for(int i = 0; i < tmp.v.length; i++) { if(tmp.v[i]) { V |= 1 << i; } } if(dp[tmp.now][V] <= tmp.cost) continue; dp[tmp.now][V] = tmp.cost; Node now = node[tmp.now]; for(int i = 0; i < now.edge_to.size(); i++) { if(node[now.edge_to.get(i)].type == 2 && tmp.v[now.edge_to.get(i)]) continue; if(node[now.edge_to.get(i)].type == 2) { boolean[] copy = Arrays.copyOf(tmp.v, tmp.v.length); copy[now.edge_to.get(i)] = true;  else { queue.add(new Data(now.edge_to.get(i),tmp.v, tmp.cost + now.edge_cost.get(i) * k));  0; i < dp[m + n + 1].length; i++) { MIN = Math.min(MIN, dp[m + n + 1][i]); } System.out.println(MIN); } } static class Data  int compareTo(Data o) { return this.cost - o.cost; } Data(int c, boolean[]  now =  0 H, 1 D, 2 C, 3 L boolean c; ArrayList<Integer> edge_to = new ArrayList<Integer>(); ArrayList<Integer> edge_cost = new ArrayList<Integer>(); } }"], "original_ll": -0.6346538066864014, "sampled_ll": -0.4915972650051117, "all_perturbed_sampled_ll": [-1.1721867322921753], "all_perturbed_original_ll": [-1.4303619861602783], "perturbed_sampled_ll": -1.1721867322921753, "perturbed_original_ll": -1.4303619861602783, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import combinations\nfrom heapq import heappop, heappush\nimport sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef convert(s, m, n):\n  if s == \"H\":\n    return 0\n  if s == \"D\":\n    return 1\n  if s[0] == \"C\":\n    return int(s[1]) + 1\n  if s[0] == \"L\":\n    return int(s[1]) + m + 1\n\ndef get_cost(start, m, n, edges):\n  cost = [INF] * (m + n + 2)\n  cost[start] = 0\n  que = []\n  heappush(que, (0, start))\n  while que:\n    total, node = heappop(que)\n    for dist, to in edges[node]:\n      if cost[to] > total + dist:\n        cost[to] = total + dist\n        if not (2 <= to <= m + 1):\n          heappush(que, (total + dist, to))\n  return cost\n\n\ndef shortest_path(start, goal, rest, cakes_dist, dic):\n  if not rest:\n    return cakes_dist[start][goal]\n  if (start, rest) in dic:\n    return dic[(now, rest)]\n  \n  ret = INF\n  for to in rest:\n    ret = min(ret, shortest_path(to, goal, tuple((i for i in rest if i != to)), cakes_dist, dic) + cakes_dist[start][to])\n  dic[(start, rest)] = ret\n  return ret\n\nwhile True:\n  m, n, k, d = map(int, input().split())\n  if m == 0:\n    break\n  clst = list(map(int, input().split()))\n  \"\"\"\n  Home ... 0\n  D ... 1\n  Cake ... 2, 3, ... m + 1\n  Land ... m + 2, m + 3, ... m + n + 1\n  \"\"\"\n  edges = [[] for _ in range(m + n + 2)]\n  for _ in range(d):\n    s, t, e = input().split()\n    e = int(e)\n    s = convert(s, m, n)\n    t = convert(t, m, n)\n    edges[s].append((e, t))\n    edges[t].append((e, s))\n  \n  cakes_dist = [[INF] * (m + 2) for _ in range(m + 2)]\n  for start in range(m + 2):\n    cost = get_cost(start, m, n, edges)\n    for to in range(m + 2):\n      if to != start:\n        cakes_dist[start][to] = cost[to]\n\n", "sampled": "import sys\nfrom itertools import permutations\nfrom collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start, end, avoid_set):\n    \"\"\"Find shortest path avoiding nodes in avoid_set\"\"\"\n    dist = defaultdict(lambda: float('inf'))\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        if u == end:\n            return d\n        for v, w in graph[u]:\n            if v in avoid_set:\n                continue\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    \n    return float('inf')\n\ndef solve(m, n, k, d, calories, edges):\n    # Build graph\n    graph = defaultdict(list)\n    for s, t, e in edges:\n        graph[s].append((t, e))\n        graph[t].append((s, e))\n    \n    # Get all cake shops\n    cake_shops = [f'C{i+1}' for i in range(m)]\n    \n    min_cost = float('inf')\n    \n    # Try all subsets of cake shops (including empty set)\n    for r in range(m + 1):\n        for perm in permutations(cake_shops, r):\n            # For this permutation, calculate the cost\n            # We need to go from H to each shop in order, then to D\n            # avoiding already visited shops\n            \n            visited_shops = set()\n            current = 'H'\n            total_distance = 0\n            total_calories = 0\n            valid = True\n            \n            for shop in perm:\n                # Find shortest path from current to shop, avoiding visited shops\n                dist = dijkstra(graph, current, shop, visited_shops)\n                if dist == float('inf'):\n                    valid = False\n                    break\n                total_distance += dist\n                visited_shops.add(shop)\n                # Eat cake at this shop\n                shop_idx = int(shop[1:]) - 1\n                total_calories += calories[shop_idx]\n                current = shop\n            \n            if not valid:\n                continue\n            \n            # Go from current to D, avoiding visited shops\n            dist = dijkstra(graph, current, 'D', visited_shops)\n            if dist == float('inf'):\n                continue\n            total_distance += dist\n            \n            # Calculate net calorie consumption\n            net_calories = total_distance * k - total_calories\n            min_cost = min(min_cost, net_calories)\n    \n    return min_cost\n\ndef main():\n    while True:\n        line = sys.stdin.readline().strip()\n        if not line:\n            break\n        m, n, k, d = map(int, line.split())\n        if m == 0 and n == 0 and k == 0 and d == 0:\n            break\n        \n        calories = list(map(int, sys.stdin.readline().split()))\n        \n        edges = []\n        for _ in range(d):\n            parts = sys.stdin.readline().split()\n            s, t, e = parts[0], parts[1], int(parts[2])\n            edges.append((s, t, e))\n        \n        result = solve(m, n, k, d, calories, edges)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from itertools import permutations from collections import defaultdict import heapq def dijkstra(graph, start, end, avoid_set): \"\"\"Find  dist[start] = 0 pq = [(0, start)] while pq: d, u = heapq.heappop(pq) if d > dist[u]: continue if u == end: return d for v, w in graph[u]: if v in avoid_set: continue if dist[u] + w < dist[v]: dist[v] = dist[u] + w heapq.heappush(pq, (dist[v], v)) return float('inf') def solve(m, n, k, d, calories, edges): # Build graph graph = defaultdict(list) for s, t, e in edges: graph[s].append((t, e)) graph[t].append((s, e)) # Get all cake shops cake_shops = [f'C{i+1}' for i in range(m)] min_cost = float('inf') # Try all subsets of cake shops (including empty set) for r in range(m + 1): for perm in permutations(cake_shops, r): # For this permutation, calculate the cost # We need to go from H  already visited shops visited_shops = set() current = 'H' total_distance = 0 total_calories = 0 valid = True for shop in perm: # Find shortest path from current to shop, avoiding visited  float('inf'): valid = False break total_distance += dist visited_shops.add(shop) # Eat cake at this  = shop if not valid: continue # Go from current to D, avoiding visited shops dist  =  min_cost def main(): while True: line = sys.stdin.readline().strip()  line.split()) if  0 and d == 0: break calories = list(map(int, sys.stdin.readline().split())) edges  t, e = parts[0], parts[1], int(parts[2]) edges.append((s, t, e)) result = solve(m, n, k, d, calories, edges) print(result) if __name__ == \"__main__\": main()"], "perturbed_original": ["from itertools import combinations from heapq import heappop, heappush  m, n): if s == \"H\": return 0 if s == \"D\": return 1 if s[0]  return  cost = [INF] * (m + n + 2) cost[start] = 0 que = [] heappush(que, (0, start)) while que: total, node = heappop(que) for dist, to in edges[node]: if cost[to] > total + dist: cost[to] = total + dist if not (2 <= to <= m + 1): heappush(que, (total + dist, to)) return cost def shortest_path(start, goal, rest, cakes_dist, dic): if not rest: return cakes_dist[start][goal] if (start,  to in rest: ret = min(ret, shortest_path(to, goal, tuple((i for i in rest if i != to)), cakes_dist, dic) + cakes_dist[start][to]) dic[(start, rest)] = ret return ret while True: m, n, k, d = map(int, input().split()) if m == 0: break  Land ... m + 2, m + 3,  for _ in range(m + n + 2)] for _ in range(d): s, t, e = input().split() e = int(e) s = convert(s,  s)) cakes_dist = [[INF] * (m + 2) for _ in range(m + 2)] for start in range(m + 2): cost = get_cost(start, m, n, edges) for to in range(m + 2): if to != start: cakes_dist[start][to] = cost[to]"], "original_ll": -0.9437721371650696, "sampled_ll": -0.7794063091278076, "all_perturbed_sampled_ll": [-1.7375011444091797], "all_perturbed_original_ll": [-1.7183243036270142], "perturbed_sampled_ll": -1.7375011444091797, "perturbed_original_ll": -1.7183243036270142, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0225\nTitle\n@kankichi573\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint n;\nint dir[26];     // in +1 out -1\nint alpha[26];   // tunagatte iruka\nchar buf[33];\nchar con[26][26];  //char a->b connection\nchar con_flag[26]; \n//\nint count_char()\n{\n        int i,cnt=0;\n\n        for(i=0;i<26;i++)\n        {\n                if (alpha[i])\n                {\n                        cnt ++;\n                        //printf(\"CH %c\\n\",'a'+i);\n                }\n        }\n        return(cnt);\n}\nint find_first()\n{\n        int i,cnt=0;\n\n        for(i=0;i<26;i++)\n                if(alpha[i]>0)\n                        return(i);\n        return(-1);\n}\n\nint connected()\n{\n        int from;\n\n        from=find_first();\n        //printf(\"FF=%c\\n\",'a'+from);\n        con_flag[from]=1;\n        return(connected2(from));\n}\nint connected2(int node)\n{\n        int i;\n        int cnt=1;\n        //printf(\"CN2=%c\\n\",'a'+node);\n\n        for(i=0;i<26;i++)\n        {\n                if(i==node)\n                        continue;\n                if(con[node][i] && !con_flag[i])\n                {\n                        //printf(\"CN2_2=%c\\n\",'a'+i);\n\n                        con_flag[i]=1;\n                        cnt += connected2(i);\n                        con_flag[i]=0;\n                }\n        }\n        return(cnt);\n}\nmain()\n{\n        int i,j;\n        int stt,end,ret,ret1;\n        while(EOF!=scanf(\"%d\",&n) && n)\n        {\n                for(i=0;i<26;i++)\n                {\n                        alpha[i]=0;\n                        dir[i]=0;\n                        con_flag[i]=0;\n                        for(j=0;j<26;j++)\n                                con[i][j]=0;\n                }\n                for(i=0;i<n;i++)\n                {\n                        scanf(\"%s\",buf);\n                        stt=buf[0]-'a';\n                        end=buf[strlen(buf)-1]-'a';\n                        dir[stt]++;\n                        dir[end]--;\n                        alpha[stt]=alpha[end]=1;\n                        con[stt][end]=1;\n                }\n\n                ret=connected();   // saisho ni toujou suru\n                                   //node to tunagatte iru suu\n                ret1=count_char(); // node no kazu\n\n                //printf(\"r=%d %d\\n\",ret,ret1);\n\n                if(ret != ret1)   // subeteno node ga tunagaruka\n                {\n                        printf(\"NG\\n\");\n                        continue;\n                }\n\n                for(i=0;i<26;i++) //zenbu guuten ka siraberu\n                        if(dir[i])\n                        {\n                                printf(\"NG\\n\");\n                                goto NEXT;\n                        }\n                printf(\"OK\\n\");\n        NEXT:\n                ;\n        }\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        char words[10000][33];\n        int first[10000], last[10000];\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", words[i]);\n            first[i] = words[i][0] - 'a';\n            last[i] = words[i][strlen(words[i]) - 1] - 'a';\n        }\n        \n        int in_degree[26] = {0};\n        int out_degree[26] = {0};\n        int char_used[26] = {0};\n        \n        for (int i = 0; i < n; i++) {\n            out_degree[first[i]]++;\n            in_degree[last[i]]++;\n            char_used[first[i]] = 1;\n            char_used[last[i]] = 1;\n        }\n        \n        int start_count = 0;\n        int end_count = 0;\n        int ok = 1;\n        \n        for (int i = 0; i < 26; i++) {\n            if (out_degree[i] - in_degree[i] == 1) {\n                start_count++;\n            } else if (in_degree[i] - out_degree[i] == 1) {\n                end_count++;\n            } else if (in_degree[i] != out_degree[i]) {\n                ok = 0;\n                break;\n            }\n        }\n        \n        if (ok) {\n            if (!((start_count == 0 && end_count == 0) || (start_count == 1 && end_count == 1))) {\n                ok = 0;\n            }\n        }\n        \n        if (ok) {\n            int adj[26][26] = {0};\n            for (int i = 0; i < n; i++) {\n                adj[first[i]][last[i]] = 1;\n            }\n            \n            int visited[26] = {0};\n            int start_node = -1;\n            for (int i = 0; i < 26; i++) {\n                if (char_used[i]) {\n                    start_node = i;\n                    break;\n                }\n            }\n            \n            int stack[26];\n            int top = 0;\n            stack[top++] = start_node;\n            visited[start_node] = 1;\n            \n            while (top > 0) {\n                int node = stack[--top];\n                for (int i = 0; i < 26; i++) {\n                    if ((adj[node][i] || adj[i][node]) && !visited[i]) {\n                        visited[i] = 1;\n                        stack[top++] = i;\n                    }\n                }\n            }\n            \n            for (int i = 0; i < 26; i++) {\n                if (char_used[i] && !visited[i]) {\n                    ok = 0;\n                    break;\n                }\n            }\n        }\n        \n        printf(\"%s\\n\", ok ? \"OK\" : \"NG\");\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; while (scanf(\"%d\", &n) == 1 && n != 0) {  words[i][0] - 'a'; last[i] = words[i][strlen(words[i]) - 1] - 'a'; } int  {0}; for (int i = 0; i < n; i++) { out_degree[first[i]]++; in_degree[last[i]]++; char_used[first[i]] = 1; char_used[last[i]] = 1; } int  1; for (int i = 0; i < 26; i++) { if (out_degree[i] - in_degree[i] == 1) { start_count++; } else if (in_degree[i] - out_degree[i] == 1) { end_count++; } else if (in_degree[i] != out_degree[i]) { ok = 0; break; } } if (ok) { if (!((start_count == 0 && end_count == 0) || (start_count  } } if (ok) { int adj[26][26] = {0}; for (int i = 0; i < n; i++) { adj[first[i]][last[i]] = 1; } int visited[26] = {0}; int start_node = -1; for (int i = 0; i < 26; i++) { if (char_used[i]) { start_node = i; break; } } int stack[26]; int top = 0; stack[top++] = start_node; visited[start_node] = 1; while  i = 0; i < 26;  = 1; stack[top++] = i; } } } for (int i = 0; i < 26; i++) { if (char_used[i]  printf(\"%s\\n\", ok ? \"OK\" : \"NG\"); } return 0; }"], "perturbed_original": ["/* AizuOnline A0225 Title @kankichi573 */ #include <stdio.h> // Select Below //#include <stdlib.h> #include <string.h> //#include <float.h> //#include <math.h> //#include  +1 out -1 int alpha[26]; // tunagatte iruka char buf[33]; char con[26][26]; //char a->b connection char con_flag[26]; //  cnt ++; //printf(\"CH  for(i=0;i<26;i++) if(alpha[i]>0) return(i); return(-1);  } int connected2(int node) { int i; int cnt=1; //printf(\"CN2=%c\\n\",'a'+node); for(i=0;i<26;i++) { if(i==node) continue; if(con[node][i] && !con_flag[i]) { //printf(\"CN2_2=%c\\n\",'a'+i); con_flag[i]=1; cnt += connected2(i); con_flag[i]=0; } } return(cnt); } main() {  alpha[i]=0; dir[i]=0; con_flag[i]=0; for(j=0;j<26;j++) con[i][j]=0; } for(i=0;i<n;i++) { scanf(\"%s\",buf); stt=buf[0]-'a'; end=buf[strlen(buf)-1]-'a'; dir[stt]++; dir[end]--; alpha[stt]=alpha[end]=1; con[stt][end]=1; } ret=connected(); // saisho ni toujou suru //node to tunagatte iru suu ret1=count_char(); // node no kazu //printf(\"r=%d %d\\n\",ret,ret1); if(ret != ret1) // subeteno node ga tunagaruka { printf(\"NG\\n\"); continue; } for(i=0;i<26;i++) //zenbu guuten ka siraberu if(dir[i]) { printf(\"NG\\n\"); goto NEXT; } printf(\"OK\\n\"); NEXT: ; } return(0); }"], "original_ll": -1.6619365215301514, "sampled_ll": -0.42779767513275146, "all_perturbed_sampled_ll": [-1.0723339319229126], "all_perturbed_original_ll": [-2.385960102081299], "perturbed_sampled_ll": -1.0723339319229126, "perturbed_original_ll": -2.385960102081299, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tvoid run() {\n\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true) {\n\n\t\t\tint N = Integer.parseInt(in.next());\n\t\t\t\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tList<String> wordList = new ArrayList<String>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tString word = in.next();\n\t\t\t\twordList.add(word.substring(0, 1));\n\t\t\t\twordList.add(word.substring(word.length() - 1, word.length()));\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(wordList);\n\t\t\t\n\t\t\tif(check(wordList)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean check(List<String> wordList) {\n\t\t\n\t\tint count = 1;\n\t\tString word1 = wordList.get(0);\n\t\tfor(int i = 1; i < wordList.size(); i++) {\n\t\t\tString word2 = wordList.get(i);\n\t\t\tif(word1.equals(word2)) { \n\t\t\t\tcount++; \n\t\t\t} else {\n\t\t\t\tif(count % 2 != 0) return false;\n\t\t\t\tword1 = word2;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t\tif(count % 2 != 0) { \n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static Map<Character, List<String>> startMap;\n    static Map<Character, List<String>> endMap;\n    static Set<String> used;\n    static List<String> words;\n    static int n;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            n = sc.nextInt();\n            if (n == 0) break;\n            \n            words = new ArrayList<>();\n            startMap = new HashMap<>();\n            endMap = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                String word = sc.next();\n                words.add(word);\n                \n                char start = word.charAt(0);\n                char end = word.charAt(word.length() - 1);\n                \n                startMap.putIfAbsent(start, new ArrayList<>());\n                startMap.get(start).add(word);\n                \n                endMap.putIfAbsent(end, new ArrayList<>());\n                endMap.get(end).add(word);\n            }\n            \n            boolean found = false;\n            for (String firstWord : words) {\n                used = new HashSet<>();\n                used.add(firstWord);\n                char startChar = firstWord.charAt(0);\n                char endChar = firstWord.charAt(firstWord.length() - 1);\n                \n                if (dfs(endChar, startChar, 1)) {\n                    found = true;\n                    break;\n                }\n            }\n            \n            System.out.println(found ? \"OK\" : \"NG\");\n        }\n        \n        sc.close();\n    }\n    \n    static boolean dfs(char currentEnd, char targetStart, int count) {\n        if (count == n) {\n            return currentEnd == targetStart;\n        }\n        \n        if (!startMap.containsKey(currentEnd)) {\n            return false;\n        }\n        \n        for (String word : startMap.get(currentEnd)) {\n            if (!used.contains(word)) {\n                used.add(word);\n                char nextEnd = word.charAt(word.length() - 1);\n                if (dfs(nextEnd, targetStart, count + 1)) {\n                    return true;\n                }\n                used.remove(word);\n            }\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static Map<Character, List<String>> startMap; static Map<Character, List<String>> endMap; static Set<String> used; static List<String> words; static int n; public  while (true) { n = sc.nextInt(); if (n == 0) break; words = new ArrayList<>(); startMap = new HashMap<>(); endMap = new HashMap<>(); for (int i = 0; i < n; i++)  startMap.get(start).add(word); endMap.putIfAbsent(end, new ArrayList<>()); endMap.get(end).add(word); } boolean found = false; for (String firstWord : words) { used = new HashSet<>(); used.add(firstWord); char startChar = firstWord.charAt(0); char endChar = firstWord.charAt(firstWord.length() - 1); if (dfs(endChar, startChar, 1)) { found = true; break; } } System.out.println(found  n) { return currentEnd == targetStart; } if (!startMap.containsKey(currentEnd)) { return false; } for (String word : startMap.get(currentEnd)) { if (!used.contains(word)) { used.add(word); char nextEnd = word.charAt(word.length() - 1); if (dfs(nextEnd, targetStart, count + 1)) { return true; } used.remove(word); } } return false; } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Collections; import java.util.List; import  = new Scanner(System.in); while(true) { int N = Integer.parseInt(in.next()); if (N == 0) break; List<String> wordList = new ArrayList<String>(); for(int i = 0;  1)); wordList.add(word.substring(word.length() - 1, word.length())); } Collections.sort(wordList); if(check(wordList)) { System.out.println(\"OK\"); } else {  = 1; String word1 = wordList.get(0); for(int i = 1;  { count++; } else { if(count % 2 != 0) return false; word1 = word2; count = 1; } } if(count % 2 != 0) { return false; } else { return true; } } public static void main(String[] args) { new Main().run(); } }"], "original_ll": -0.6098966002464294, "sampled_ll": -0.4669997990131378, "all_perturbed_sampled_ll": [-1.1476505994796753], "all_perturbed_original_ll": [-1.3204154968261719], "perturbed_sampled_ll": -1.1476505994796753, "perturbed_original_ll": -1.3204154968261719, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import defaultdict\nwhile True:\n    try:\n        n=input()\n    except SyntaxError:\n        pass\n    if n==0:break\n    dic=defaultdict(int)\n    for i in range(n):\n        w=raw_input()\n        dic[w[0]]+=1\n        dic[w[-1]]+=1\n    if len(set(dic.values()))==1:\n        print \"OK\"\n    else:\n        print \"NG\"", "sampled": "import sys\nfrom collections import defaultdict, deque\n\ndef can_form_shiritori(words):\n    if len(words) == 1:\n        return words[0][0] == words[0][-1]\n    \n    # Build graph of first and last characters\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    out_degree = defaultdict(int)\n    \n    for word in words:\n        first = word[0]\n        last = word[-1]\n        graph[first].append(last)\n        out_degree[first] += 1\n        in_degree[last] += 1\n    \n    # Get all vertices\n    vertices = set(in_degree.keys()) | set(out_degree.keys())\n    \n    # Check if Eulerian circuit exists\n    # For Eulerian circuit: in_degree == out_degree for all vertices\n    for v in vertices:\n        if in_degree[v] != out_degree[v]:\n            return False\n    \n    # Check if graph is connected (considering it as undirected for connectivity)\n    # We need to check if all edges form one connected component\n    if not vertices:\n        return True\n    \n    # Build undirected graph for connectivity check\n    undirected = defaultdict(set)\n    for word in words:\n        first = word[0]\n        last = word[-1]\n        undirected[first].add(last)\n        undirected[last].add(first)\n    \n    # BFS to check connectivity\n    start = next(iter(vertices))\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in undirected[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    # Check if all vertices with non-zero degree are visited\n    return len(visited) == len(vertices)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    words = []\n    for _ in range(n):\n        words.append(input().strip())\n    \n    if can_form_shiritori(words):\n        print(\"OK\")\n    else:\n        print(\"NG\")\n", "perturbed_sampled": ["import sys from collections import defaultdict, deque def can_form_shiritori(words): if len(words) == 1: return words[0][0] == words[0][-1] # Build graph of first and last characters graph = defaultdict(list) in_degree = defaultdict(int) out_degree  =  all vertices vertices = set(in_degree.keys()) | set(out_degree.keys())  in_degree == out_degree for all vertices for v in vertices: if in_degree[v] != out_degree[v]:  as undirected for connectivity) # We need to check if all edges form one connected component if not vertices: return True # Build undirected graph for connectivity check undirected = defaultdict(set) for word in words: first =  connectivity start = next(iter(vertices)) visited = set() queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in undirected[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Check if all  while True: n = int(input()) if n == 0: break words = [] for _ in range(n): words.append(input().strip()) if can_form_shiritori(words): print(\"OK\") else: print(\"NG\")"], "perturbed_original": ["from collections import defaultdict while True: try: n=input() except SyntaxError: pass if n==0:break dic=defaultdict(int) for i in range(n): w=raw_input() dic[w[0]]+=1 dic[w[-1]]+=1 if len(set(dic.values()))==1: print \"OK\" else: print \"NG\""], "original_ll": -1.2103073596954346, "sampled_ll": -0.7851046323776245, "all_perturbed_sampled_ll": [-1.9800176620483398], "all_perturbed_original_ll": [-1.6337246894836426], "perturbed_sampled_ll": -1.9800176620483398, "perturbed_original_ll": -1.6337246894836426, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<string.h>\n#include<stdio.h>\nint main()\n{\n\tint h,b,i,j;\n\tchar r[5],a[5];\n\twhile(1){\n\t\tscanf(\"%s %s\",r,a);\n\t\tif(strcmp(r,\"0\")==0&&strcmp(a,\"0\")==0){\n\t\t\tbreak;\n\t\t}\n\t\th=0;\n\t\tb=0;\n\t\tfor(i=0;i<4;i++){\n\t\t\tif(r[i]==a[i]){\n\t\t\t\th++;\n\t\t\t\tr[i]='r';\n\t\t\t\ta[i]='a';\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<4;i++){\n\t\t\tfor(j=0;j<4;j++){\n\t\t\t\tif(r[i]==a[j]){\n\t\t\t\t\tb++;\n\t\t\t\t\tr[i]='r';\n\t\t\t\t\ta[j]='a';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",h,b);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char r[5], a[5];\n    \n    while (1) {\n        scanf(\"%s %s\", r, a);\n        \n        if (strcmp(r, \"0\") == 0 && strcmp(a, \"0\") == 0) {\n            break;\n        }\n        \n        int hit = 0, blow = 0;\n        \n        // Count hits\n        for (int i = 0; i < 4; i++) {\n            if (r[i] == a[i]) {\n                hit++;\n            }\n        }\n        \n        // Count blows\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                if (i != j && r[i] == a[j]) {\n                    blow++;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", hit, blow);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char r[5], a[5]; while (1) { scanf(\"%s %s\", r, a); if (strcmp(r, \"0\") == 0 && strcmp(a, \"0\") == 0) { break; } int hit = 0, blow = 0;  4; i++) { if (r[i] == a[i]) { hit++; } } // Count blows for (int i  = 0; j < 4; j++) { if (i != j && r[i] == a[j]) { blow++;  }"], "perturbed_original": [" scanf(\"%s %s\",r,a); if(strcmp(r,\"0\")==0&&strcmp(a,\"0\")==0){ break; } h=0; b=0; for(i=0;i<4;i++){ if(r[i]==a[i]){ h++; r[i]='r'; a[i]='a'; } } for(i=0;i<4;i++){ for(j=0;j<4;j++){ if(r[i]==a[j]){ b++; r[i]='r'; a[j]='a'; } } } printf(\"%d %d\\n\",h,b); } return 0; }"], "original_ll": -0.7700193524360657, "sampled_ll": -0.5035959482192993, "all_perturbed_sampled_ll": [-1.4874982833862305], "all_perturbed_original_ll": [-1.0621294975280762], "perturbed_sampled_ll": -1.4874982833862305, "perturbed_original_ll": -1.0621294975280762, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\tScanner s=new Scanner (System.in);\n\t\twhile(true){\n\t\t\tString a=s.next();\n\t\t\tString b=s.next();\n\t\t\tif(a.length()==1)System.exit(0);\n\t\t\tint hit=0;\n\t\t\tfor(int i=0;i<4;i++)if(a.charAt(i)==b.charAt(i))hit++;\n\t\t\tint blow=0;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\tif(a.charAt(i)==b.charAt(j)&&i!=j)blow++;\n\t\t\tSystem.out.println(hit+\" \"+blow);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String r = sc.next();\n            String a = sc.next();\n            \n            if (r.equals(\"0\") && a.equals(\"0\")) {\n                break;\n            }\n            \n            int hits = 0;\n            int blows = 0;\n            \n            // Count hits\n            for (int i = 0; i < 4; i++) {\n                if (r.charAt(i) == a.charAt(i)) {\n                    hits++;\n                }\n            }\n            \n            // Count blows\n            for (int i = 0; i < 4; i++) {\n                for (int j = 0; j < 4; j++) {\n                    if (i != j && r.charAt(i) == a.charAt(j)) {\n                        blows++;\n                    }\n                }\n            }\n            \n            System.out.println(hits + \" \" + blows);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) {  && a.equals(\"0\")) { break; }  hits for (int i = 0; i < 4; i++) { if (r.charAt(i) == a.charAt(i)) { hits++; } } // Count blows for (int i = 0; i <  4; j++) { if (i != j && r.charAt(i) == a.charAt(j)) { blows++; } } } System.out.println(hits + \" \" + blows); } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main{  String a=s.next(); String b=s.next(); if(a.length()==1)System.exit(0); int hit=0; for(int i=0;i<4;i++)if(a.charAt(i)==b.charAt(i))hit++; int blow=0; for(int i=0;i<4;i++) for(int j=0;j<4;j++) if(a.charAt(i)==b.charAt(j)&&i!=j)blow++; System.out.println(hit+\" \"+blow); } } }"], "original_ll": -0.9533368945121765, "sampled_ll": -0.4721856713294983, "all_perturbed_sampled_ll": [-1.3912594318389893], "all_perturbed_original_ll": [-1.3760976791381836], "perturbed_sampled_ll": -1.3912594318389893, "perturbed_original_ll": -1.3760976791381836, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    a,b=raw_input().split()\n    if a==b==\"0\":break\n    hit,blow=0,0\n    for i,j in zip(a,b):\n        if i==j:\n            hit+=1\n    for i in a:\n        if i in b:\n            blow+=1\n    print hit,blow-hit", "sampled": "import sys\n\nfor line in sys.stdin:\n    parts = line.strip().split()\n    if len(parts) < 2:\n        continue\n    r, a = parts[0], parts[1]\n    if r == '0' and a == '0':\n        break\n    \n    hits = 0\n    blows = 0\n    \n    for i in range(4):\n        if r[i] == a[i]:\n            hits += 1\n    \n    for i in range(4):\n        if r[i] != a[i]:\n            for j in range(4):\n                if i != j and r[i] == a[j] and r[j] != a[j]:\n                    blows += 1\n                    break\n    \n    print(hits, blows)\n", "perturbed_sampled": ["import sys for line in sys.stdin: parts = line.strip().split() if len(parts) < 2: continue r, a = parts[0], parts[1] if r == '0' and a == '0': break hits = 0 blows = 0  1 for  range(4): if i != j and r[i] == a[j] and r[j] != a[j]: blows += 1 break print(hits, blows)"], "perturbed_original": ["while True: a,b=raw_input().split() if a==b==\"0\":break hit,blow=0,0 for i,j in zip(a,b): if i==j: hit+=1 for i in a: if i in b: blow+=1 print hit,blow-hit"], "original_ll": -1.261081337928772, "sampled_ll": -0.9217848181724548, "all_perturbed_sampled_ll": [-1.949330449104309], "all_perturbed_original_ll": [-1.7567806243896484], "perturbed_sampled_ll": -1.949330449104309, "perturbed_original_ll": -1.7567806243896484, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,m,i,p[1000],P;\n//M(int*a){return*1[&a]-*a;}\nM(int*a,int*b){return*b-*a;}\nmain(){\n\tfor(;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",p+i);\n\t\t}\n\t\tqsort(p,n,4,M);\n\t\tP=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(i%m!=m-1)\n\t\t\t\tP+=p[i];\n\t\t}\n\t\tprintf(\"%d\\n\",P);\n\t}\n\texit(0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int n, m;\n    \n    while(1) {\n        scanf(\"%d %d\", &n, &m);\n        if(n == 0 && m == 0) break;\n        \n        int prices[1000];\n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", &prices[i]);\n        }\n        \n        qsort(prices, n, sizeof(int), compare);\n        \n        int total = 0;\n        int count = 0;\n        \n        for(int i = 0; i < n; i++) {\n            count++;\n            if(count == m) {\n                count = 0;\n            } else {\n                total += prices[i];\n            }\n        }\n        \n        printf(\"%d\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int compare(const void *a, const void *b) { return (*(int*)b - *(int*)a); } int main() { int n, m; while(1) { scanf(\"%d %d\", &n, &m); if(n == 0 && m == 0) break; int prices[1000]; for(int i = 0; i < n; i++) { scanf(\"%d\", &prices[i]); } qsort(prices, n, sizeof(int), compare); int total = 0; int count =  else { total += prices[i]; } } printf(\"%d\\n\", total); } return 0; }"], "perturbed_original": ["n,m,i,p[1000],P; //M(int*a){return*1[&a]-*a;} M(int*a,int*b){return*b-*a;} main(){ for(;scanf(\"%d%d\",&n,&m),n;){ for(i=0;i<n;i++){ scanf(\"%d\",p+i); } qsort(p,n,4,M); P=0; for(i=0;i<n;i++){ if(i%m!=m-1) P+=p[i]; } printf(\"%d\\n\",P); } exit(0); }"], "original_ll": -1.7378989458084106, "sampled_ll": -0.5420929193496704, "all_perturbed_sampled_ll": [-0.8695558905601501], "all_perturbed_original_ll": [-1.9674817323684692], "perturbed_sampled_ll": -0.8695558905601501, "perturbed_original_ll": -1.9674817323684692, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] num = new int[n];\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tnum[i] = scanner.nextInt();\n\t\t\t\tsum += num[i];\n\t\t\t}\n\t\t\tint mod = n % m;\n\t\t\tArrays.sort(num);\n\n\t\t\tfor (int i = mod; i < n; i += m) {\n\t\t\t\tsum -= num[i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) {\n                break;\n            }\n            \n            Integer[] prices = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                prices[i] = sc.nextInt();\n            }\n            \n            // Sort in descending order to maximize discount\n            Arrays.sort(prices, Collections.reverseOrder());\n            \n            int totalCost = 0;\n            \n            // Process full bags of m items\n            for (int i = 0; i < n; i++) {\n                // Every m-th item (0-indexed: m-1, 2m-1, 3m-1, ...) is free\n                if ((i + 1) % m == 0) {\n                    // This item is free (cheapest in its bag)\n                    continue;\n                }\n                totalCost += prices[i];\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); int m = sc.nextInt(); if (n  prices = new Integer[n]; for (int i = 0; i < n; i++) { prices[i] = sc.nextInt(); } // Sort in descending order to maximize discount Arrays.sort(prices, Collections.reverseOrder()); int totalCost = 0; // Process full bags of m  { // Every m-th item (0-indexed: m-1, 2m-1, 3m-1, ...) is free if ((i + 1) % m == 0) { // This item is  } System.out.println(totalCost); } sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String[] args) throws IOException { new Main().run(); } private void run()  if ((n | m) == 0) break; int[] num = new int[n]; int sum = 0; for (int i = 0; i < n; i++) { num[i] = scanner.nextInt(); sum  for (int i = mod; i < n; i += m) { sum -= num[i]; } System.out.println(sum); } } }"], "original_ll": -0.7017500996589661, "sampled_ll": -0.8482555150985718, "all_perturbed_sampled_ll": [-1.621227502822876], "all_perturbed_original_ll": [-1.3157870769500732], "perturbed_sampled_ll": -1.621227502822876, "perturbed_original_ll": -1.3157870769500732, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    a = raw_input()\n    print 'a'", "sampled": "import sys\n\ndef solve(n, m, prices):\n    # Sort prices in descending order\n    prices.sort(reverse=True)\n    \n    total = 0\n    i = 0\n    \n    while i < n:\n        # Take up to m items for this bag\n        bag_size = min(m, n - i)\n        \n        if bag_size == m:\n            # Full bag - the cheapest (last) item is free\n            for j in range(bag_size - 1):\n                total += prices[i + j]\n            # prices[i + bag_size - 1] is free (the cheapest in this bag)\n        else:\n            # Incomplete bag - no discount\n            for j in range(bag_size):\n                total += prices[i + j]\n        \n        i += bag_size\n    \n    return total\n\n# Read input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.strip())\n\ni = 0\nwhile i < len(lines):\n    parts = lines[i].split()\n    n, m = int(parts[0]), int(parts[1])\n    \n    if n == 0 and m == 0:\n        break\n    \n    i += 1\n    prices = list(map(int, lines[i].split()))\n    i += 1\n    \n    result = solve(n, m, prices)\n    print(result)\n", "perturbed_sampled": ["import sys def solve(n,  = 0 i = 0 while i < n: # Take up to m items for this bag bag_size = min(m, n - i) if bag_size == m: # Full bag - the cheapest (last) item is  + j] # prices[i + bag_size - 1] is free (the cheapest in this bag) else: # Incomplete bag - no discount for j in  in sys.stdin: lines.append(line.strip()) i = 0 while i < len(lines): parts = lines[i].split() n, m = int(parts[0]), int(parts[1]) if n == 0 and m == 0: break i += 1 prices = list(map(int, lines[i].split())) i += 1 result = solve(n, m, prices) print(result)"], "perturbed_original": ["while True: a = raw_input() print 'a'"], "original_ll": -2.5658493041992188, "sampled_ll": -0.9757249355316162, "all_perturbed_sampled_ll": [-2.135751247406006], "all_perturbed_original_ll": [-3.257502794265747], "perturbed_sampled_ll": -2.135751247406006, "perturbed_original_ll": -3.257502794265747, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  int i,j,n,num,prev;\n  char segment[]=\"0000000\";\n  char nums[][8]={\"0111111\",\"0000110\",\"1011011\",\"1001111\",\n\t\t  \"1100110\",\"1101101\",\"1111101\",\"0100111\",\n\t\t  \"1111111\",\"1101111\",\"0000000\"};\n  do{\n    scanf(\"%d\",&n);\n    if(n==-1) break;\n    for(prev=10,i=0;i<n;i++,prev=num){\n      scanf(\"%d\",&num);\n      for(j=0;j<7;j++){\n\tif(nums[prev][j]==nums[num][j]){\n\t  segment[j]='0';\n\t}else{\n\t  segment[j]='1';\n\t}\n      }\n      printf(\"%s\\n\",segment);\n    }\n  }while(1);\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int segments[10] = {\n        0b0111111,  // 0\n        0b0000110,  // 1\n        0b1011011,  // 2\n        0b1001111,  // 3\n        0b1100110,  // 4\n        0b1101101,  // 5\n        0b1111101,  // 6\n        0b0000111,  // 7\n        0b1111111,  // 8\n        0b1101111   // 9\n    };\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != -1) {\n        int current = 0;  // Initial state: all segments off\n        \n        for (int i = 0; i < n; i++) {\n            int digit;\n            scanf(\"%d\", &digit);\n            \n            int target = segments[digit];\n            int signal = current ^ target;  // XOR to get the toggle bits\n            \n            // Print signal in binary (7 bits, from bit 6 to bit 0)\n            for (int j = 6; j >= 0; j--) {\n                printf(\"%d\", (signal >> j) & 1);\n            }\n            printf(\"\\n\");\n            \n            current = target;  // Update current state\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  // 4 0b1101101, // 5 0b1111101, // 6 0b0000111, // 7 0b1111111, // 8 0b1101111 // 9 }; int n; while (scanf(\"%d\", &n) == 1 && n !=  segments off for (int i = 0; i < n; i++) { int digit; scanf(\"%d\", &digit); int target = segments[digit]; int signal = current ^ target; // XOR to get the toggle bits // Print signal in binary (7 bits, from bit 6 to bit 0) for (int j = 6; j >= 0;  current = target; // Update current state } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int i,j,n,num,prev; char segment[]=\"0000000\"; char nums[][8]={\"0111111\",\"0000110\",\"1011011\",\"1001111\", \"1100110\",\"1101101\",\"1111101\",\"0100111\", \"1111111\",\"1101111\",\"0000000\"}; do{ scanf(\"%d\",&n); if(n==-1) break; for(prev=10,i=0;i<n;i++,prev=num){ scanf(\"%d\",&num); for(j=0;j<7;j++){ if(nums[prev][j]==nums[num][j]){ segment[j]='0'; }else{ segment[j]='1'; } } printf(\"%s\\n\",segment); } }while(1); return 0; }"], "original_ll": -1.06485915184021, "sampled_ll": -0.7571138739585876, "all_perturbed_sampled_ll": [-1.8509186506271362], "all_perturbed_original_ll": [-1.1375330686569214], "perturbed_sampled_ll": -1.8509186506271362, "perturbed_original_ll": -1.1375330686569214, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tString [] digit = {\"0111111\",\"0000110\",\"1011011\",\"1001111\",\"1100110\",\n\t\t\t\"1101101\",\"1111101\", \"0100111\",\"1111111\",\"1101111\"};\n\t\n\tprivate void doit() {\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1) break;\n\t\t\tStringBuilder nowstate = new StringBuilder(\"0000000\");\n\t\t\twhile(n-- > 0){\n\t\t\t\tint num = sc.nextInt();\n\t\t\t\tString numstr = digit[num];\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(int i = 0; i < numstr.length(); i++){\n\t\t\t\t\tif(numstr.charAt(i) == nowstate.charAt(i)){\n\t\t\t\t\t\tsb.append(0);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tsb.append(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sb.toString());\n\t\t\t\tnowstate = new StringBuilder(numstr);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Define 7-segment patterns for digits 0-9\n        // Pattern is in order: abcdefg (bits 0-6)\n        int[] patterns = {\n            0b0111111, // 0\n            0b0000110, // 1\n            0b1011011, // 2\n            0b1001111, // 3\n            0b1100110, // 4\n            0b1101101, // 5\n            0b1111101, // 6\n            0b0000111, // 7\n            0b1111111, // 8\n            0b1101111  // 9\n        };\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == -1) break;\n            \n            int currentState = 0; // Initially all segments are off\n            \n            for (int i = 0; i < n; i++) {\n                int digit = sc.nextInt();\n                int targetState = patterns[digit];\n                \n                // Calculate XOR to get the signal needed\n                int signal = currentState ^ targetState;\n                \n                // Output the signal in reverse bit order (gfedcba)\n                StringBuilder sb = new StringBuilder();\n                for (int bit = 6; bit >= 0; bit--) {\n                    sb.append((signal >> bit) & 1);\n                }\n                System.out.println(sb.toString());\n                \n                // Update current state\n                currentState = targetState;\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in); // Define 7-segment patterns for digits 0-9 // Pattern is in order: abcdefg (bits 0-6) int[] patterns = { 0b0111111, // 0 0b0000110, // 1 0b1011011, //  0b1111101, // 6 0b0000111, // 7 0b1111111, // 8 0b1101111 // 9 }; while (true) { int n = sc.nextInt(); if (n == -1) break; int currentState = 0; // Initially all segments are off for (int i = 0; i < n; i++) { int  to get the signal needed int signal = currentState ^ targetState; // Output the signal in reverse bit order (gfedcba) StringBuilder sb = new StringBuilder(); for (int bit = 6; bit >= 0; bit--) { sb.append((signal >> bit) & 1);  } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { Scanner sc  private void doit() { while (true) { int n = sc.nextInt(); if(n == -1) break; StringBuilder nowstate = new StringBuilder(\"0000000\"); while(n-- > 0){ int num = sc.nextInt(); String numstr = digit[num]; StringBuilder sb = new  == nowstate.charAt(i)){ sb.append(0); } else{ sb.append(1); } }  debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); } public static void main(String[] args) { new Main().doit(); } }"], "original_ll": -1.080339789390564, "sampled_ll": -0.8338609337806702, "all_perturbed_sampled_ll": [-1.6522752046585083], "all_perturbed_original_ll": [-2.058540105819702], "perturbed_sampled_ll": -1.6522752046585083, "perturbed_original_ll": -2.058540105819702, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# AOJ 0228: Seven Segments\n# Python3 2018.6.25 bal4u\n \np = [[1,1,1,1,1,1,0], [0,1,1,0,0,0,0], [1,1,0,1,1,0,1], [1,1,1,1,0,0,1], [0,1,1,0,0,1,1], \\\n     [1,0,1,1,0,1,1], [1,0,1,1,1,1,1], [1,1,1,0,0,1,0], [1,1,1,1,1,1,1], [1,1,1,1,0,1,1]]\n \nwhile True:\n    n = int(input())\n    if n < 0: break\n    a = [0]*7\n    for i in range(n):\n        d = int(input())\n        ans = ''\n        for j in range(6,-1,-1):\n            k = (a[j] ^ p[d][j]) & 1\n            ans += '1' if k else '0'\n            if k: a[j] = 1-a[j]\n        print(ans)\n", "sampled": "def get_segments(digit):\n    segments = {\n        0: \"0111111\",\n        1: \"0000110\",\n        2: \"1011011\",\n        3: \"1001111\",\n        4: \"1100110\",\n        5: \"1101101\",\n        6: \"1111101\",\n        7: \"0000111\",\n        8: \"1111111\",\n        9: \"1101111\"\n    }\n    return segments[digit]\n\ndef xor_bits(a, b):\n    result = \"\"\n    for i in range(7):\n        if a[i] != b[i]:\n            result += \"1\"\n        else:\n            result += \"0\"\n    return result\n\nwhile True:\n    n = int(input())\n    if n == -1:\n        break\n    \n    current_state = \"0000000\"\n    \n    for _ in range(n):\n        digit = int(input())\n        target_state = get_segments(digit)\n        signal = xor_bits(current_state, target_state)\n        print(signal)\n        current_state = target_state\n", "perturbed_sampled": [" 7: \"0000111\", 8: \"1111111\", 9: \"1101111\" } return segments[digit] def xor_bits(a, b): result = \"\" for i in range(7): if a[i] != b[i]: result += \"1\" else: result += \"0\" return result while True: n = int(input()) if n == -1: break current_state = \"0000000\" for _ in range(n): digit = int(input()) target_state = get_segments(digit) signal = xor_bits(current_state, target_state) print(signal) current_state = target_state"], "perturbed_original": ["# AOJ 0228: Seven Segments # Python3 2018.6.25 bal4u p = [[1,1,1,1,1,1,0], [0,1,1,0,0,0,0], [1,1,0,1,1,0,1], [1,1,1,1,0,0,1], [0,1,1,0,0,1,1], \\ [1,0,1,1,0,1,1], [1,0,1,1,1,1,1], [1,1,1,0,0,1,0], [1,1,1,1,1,1,1], [1,1,1,1,0,1,1]] while True: n =  i in range(n): d = int(input()) ans = '' for j  += '1' if k else '0' if k: a[j] = 1-a[j] print(ans)"], "original_ll": -1.0168429613113403, "sampled_ll": -0.7302873134613037, "all_perturbed_sampled_ll": [-1.4576159715652466], "all_perturbed_original_ll": [-1.476851224899292], "perturbed_sampled_ll": -1.4576159715652466, "perturbed_original_ll": -1.476851224899292, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(b,r,g,c,s,t){for(;~scanf(\"%d%d%d%d%d%d\",&b,&r,&g,&c,&s,&t)&&t;printf(\"%d\\n\",b*95+r*63+g*7+c*2+s*3-t*3+100));}", "sampled": "#include <stdio.h>\n\nint main() {\n    int b, r, g, c, s, t;\n    \n    while (1) {\n        scanf(\"%d %d %d %d %d %d\", &b, &r, &g, &c, &s, &t);\n        \n        if (b == 0 && r == 0 && g == 0 && c == 0 && s == 0 && t == 0) {\n            break;\n        }\n        \n        int medals = 100;\n        \n        // Big bonus games: 5 games each, 2 medals in, 15 medals out per game\n        int big_bonus_games = b * 5;\n        medals += big_bonus_games * (15 - 2);\n        \n        // Regular bonus games: 3 games each, 2 medals in, 15 medals out per game\n        int regular_bonus_games = r * 3;\n        medals += regular_bonus_games * (15 - 2);\n        \n        // Total bonus games\n        int bonus_games = big_bonus_games + regular_bonus_games;\n        \n        // Normal games\n        int normal_games = t - bonus_games;\n        \n        // For normal games, we need to account for:\n        // - Games that triggered bonuses (b + r games, cost 3 medals each, no payout from trigger itself)\n        // - Games with grapes (g games, cost 3 medals, get 15 medals)\n        // - Games with cherries (c games, cost 3 medals, get 3 medals)\n        // - Games with stars (s games, cost 3 medals first time, get 0 medals but next game is free)\n        // - Games that got nothing\n        \n        // Star games: first star costs 3, gets 0, then next game is free (costs 0)\n        // So s stars means s games cost 3 medals and s games cost 0 medals\n        // But we need to be careful about counting\n        \n        // Actually, let's think differently:\n        // - b games triggered big bonus: cost 3, no payout\n        // - r games triggered regular bonus: cost 3, no payout\n        // - g games got grapes: cost 3, payout 15\n        // - c games got cherries: cost 3, payout 3\n        // - s games got stars: cost 3, payout 0, but next game is free\n        // - remaining games got nothing: cost 3, payout 0\n        \n        // Total normal games played\n        // Some of these are free (after stars)\n        // Games that cost medals: normal_games - s (since s games following a star are free)\n        \n        medals -= (normal_games - s) * 3;  // Cost of normal games (excluding free games after stars)\n        medals += b * 0;  // Big bonus triggers give no payout\n        medals += r * 0;  // Regular bonus triggers give no payout\n        medals += g * 15; // Grape payouts in normal games\n        medals += c * 3;  // Cherry payouts in normal games\n        medals += s * 0;  // Star payouts (none)\n        \n        printf(\"%d\\n\", medals);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int b, r, g,  (b  && c == 0 && s == 0 && t == 0) { break; } int medals = 100; // Big bonus games: 5 games each, 2 medals in, 15 medals out per game int big_bonus_games = b *  bonus games: 3 games each, 2 medals in,  3; medals += regular_bonus_games * (15 - 2); // Total bonus games int bonus_games = big_bonus_games + regular_bonus_games; // Normal games int normal_games = t - bonus_games;  - Games that triggered bonuses (b + r games, cost 3 medals each, no payout from trigger itself) // - Games with grapes (g games, cost 3 medals, get 15 medals) // - Games with cherries (c games, cost 3 medals, get 3 medals) // - Games with stars (s games, cost 3 medals first time, get 0 medals but next game is free) // - Games that got  then next game is free (costs 0) // So s stars means s games cost 3 medals and s games cost 0 medals // But we need to be careful about counting // Actually, let's  3, no payout // - r games triggered regular  grapes: cost 3, payout 15 // - c games got cherries: cost 3, payout 3 // - s games got stars: cost 3, payout 0, but next game is free // - remaining  games played  that cost medals: normal_games - s (since s games following a star are free) medals -= (normal_games - s) * 3; // Cost of normal games (excluding free games after stars) medals += b * 0; // Big bonus triggers  bonus triggers give no payout medals += g * 15; // Grape payouts in normal games medals += c * 3; // Cherry payouts in normal games medals += s * 0; // Star payouts (none) printf(\"%d\\n\", medals); } return 0; }"], "perturbed_original": ["main(b,r,g,c,s,t){for(;~scanf(\"%d%d%d%d%d%d\",&b,&r,&g,&c,&s,&t)&&t;printf(\"%d\\n\",b*95+r*63+g*7+c*2+s*3-t*3+100));}"], "original_ll": -2.3237595558166504, "sampled_ll": -1.3557888269424438, "all_perturbed_sampled_ll": [-2.5165019035339355], "all_perturbed_original_ll": [-2.3237595558166504], "perturbed_sampled_ll": -2.5165019035339355, "perturbed_original_ll": -2.3237595558166504, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        for(;;) {\n         int b=sc.nextInt()*5,r=sc.nextInt()*3,g=sc.nextInt(),c=sc.nextInt(),s=sc.nextInt(),t=sc.nextInt();\n         if((b|r|g|c|s|t)==0) {\n             break;\n         }\n         System.out.println(100+b+b*18+r+r*20+g*7+c*2-(t-s)*3);\n        }\n    }\n}\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int b = sc.nextInt();\n            int r = sc.nextInt();\n            int g = sc.nextInt();\n            int c = sc.nextInt();\n            int s = sc.nextInt();\n            int t = sc.nextInt();\n            \n            if (b == 0 && r == 0 && g == 0 && c == 0 && s == 0 && t == 0) {\n                break;\n            }\n            \n            int medals = 100;\n            \n            // Big bonus games: 5 games each, spend 2 medals, get 15 medals\n            int bigBonusGames = b * 5;\n            medals += bigBonusGames * (15 - 2);\n            \n            // Regular bonus games: 3 games each, spend 2 medals, get 15 medals\n            int regularBonusGames = r * 3;\n            medals += regularBonusGames * (15 - 2);\n            \n            // Total bonus games\n            int totalBonusGames = bigBonusGames + regularBonusGames;\n            \n            // Normal games\n            int normalGames = t - totalBonusGames;\n            \n            // Calculate medals from normal games\n            // Grape in normal game: spend 3, get 15, net +12\n            medals += g * (15 - 3);\n            \n            // Cherry in normal game: spend 3, get 8, net +5\n            medals += c * (8 - 3);\n            \n            // Star in normal game: spend 3, get 0, but next game is free\n            // Net effect: -3 for star game, +3 for free game = 0\n            // But we need to count that star games are part of normal games\n            \n            // Games that cost 3 medals (normal games minus free games from stars)\n            int paidNormalGames = normalGames - s;\n            \n            // Games where nothing special happened\n            int noWinGames = paidNormalGames - g - c - s;\n            \n            // These games cost 3 medals with no return\n            medals -= noWinGames * 3;\n            \n            System.out.println(medals);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int b = sc.nextInt(); int r = sc.nextInt(); int g = sc.nextInt(); int c = sc.nextInt(); int s = sc.nextInt(); int t = sc.nextInt(); if (b == 0 && r == 0 && g == 0 && c == 0 && s == 0 && t == 0) { break; } int medals = 100; //   bigBonusGames * (15 - 2); // Regular bonus games:  regularBonusGames = r * 3; medals += regularBonusGames * (15 - 2); // Total bonus games int totalBonusGames = bigBonusGames + regularBonusGames; // Normal games int normalGames = t - totalBonusGames; // Calculate medals from normal games // Grape in normal game: spend 3, get 15, net +12 medals +=  spend 3, get 8, net +5 medals += c * (8 - 3); // Star in normal game: spend 3, get 0, but next game is  free game = 0 // But we  games // Games that cost 3 medals (normal games minus free games  where nothing special happened int noWinGames = paidNormalGames  3 medals with no return medals -= noWinGames * 3; System.out.println(medals); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); for(;;) { int b=sc.nextInt()*5,r=sc.nextInt()*3,g=sc.nextInt(),c=sc.nextInt(),s=sc.nextInt(),t=sc.nextInt(); if((b|r|g|c|s|t)==0) { break; } System.out.println(100+b+b*18+r+r*20+g*7+c*2-(t-s)*3); } } }"], "original_ll": -1.587196946144104, "sampled_ll": -1.2564232349395752, "all_perturbed_sampled_ll": [-2.1454453468322754], "all_perturbed_original_ll": [-1.7346726655960083], "perturbed_sampled_ll": -2.1454453468322754, "perturbed_original_ll": -1.7346726655960083, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    b,r,g,c,s,t=map(int,input().split())\n    if [b,r,g,c,s,t].count(0)==6:break\n    print(100+(b+r)*15+g*7+c*2+(b*5+r*3)*13-(t-(s+b*5+r*3))*3)", "sampled": "while True:\n    line = input().split()\n    b, r, g, c, s, t = map(int, line)\n    \n    if b == 0 and r == 0 and g == 0 and c == 0 and s == 0 and t == 0:\n        break\n    \n    medals = 100\n    \n    # Big bonus games: 5 games each\n    big_bonus_games = b * 5\n    # Regular bonus games: 3 games each\n    regular_bonus_games = r * 3\n    # Total bonus games\n    bonus_games = big_bonus_games + regular_bonus_games\n    # Normal games\n    normal_games = t - bonus_games\n    \n    # Bonus games: spend 2, get 15 (net +13 per game)\n    medals += bonus_games * (15 - 2)\n    \n    # Normal games cost 3 medals each\n    medals -= normal_games * 3\n    \n    # Grape in normal games: get 15\n    medals += g * 15\n    \n    # Cherry in normal games: get 8\n    medals += c * 8\n    \n    # Star games are free (refund 3 medals)\n    medals += s * 3\n    \n    print(medals)\n", "perturbed_sampled": ["while True: line = input().split() b, r, g, c, s, t = map(int, line) if b == 0 and r == 0 and g ==  t == 0: break medals = 100 # Big bonus games: 5 games each big_bonus_games = b * 5 # Regular bonus games: 3 games each regular_bonus_games = r * 3 # Total bonus games bonus_games = big_bonus_games + regular_bonus_games # Normal games normal_games = t - bonus_games # Bonus games: spend 2, get 15 (net +13 per  games cost 3 medals  games: get 15 medals  8 medals += c * 8 # Star games are free (refund 3 medals) medals += s * 3 print(medals)"], "perturbed_original": ["while 1: b,r,g,c,s,t=map(int,input().split()) if [b,r,g,c,s,t].count(0)==6:break print(100+(b+r)*15+g*7+c*2+(b*5+r*3)*13-(t-(s+b*5+r*3))*3)"], "original_ll": -2.167511463165283, "sampled_ll": -1.4815173149108887, "all_perturbed_sampled_ll": [-2.69423770904541], "all_perturbed_original_ll": [-2.3913190364837646], "perturbed_sampled_ll": -2.69423770904541, "perturbed_original_ll": -2.3913190364837646, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "short*p,v[][99];main(c,n,m,i,y){for(;m=scanf(\"%d %[^\\n] %[^\\n]\",&n,v,v+1)*n;printf(m>n?\"NA\\n\":\"%d\\n\",m))for(i=2;i--;m=c)for(c=0,y=n;y>1&c<m;y+=y==n|*p&2?2:*p&p[-1]&1?0:!++c-1)p=--y+v[c+i&1];}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 101\n#define INF 999999\n\nint n;\nint a[MAX_N], b[MAX_N];\nint ladder_top[2][MAX_N];\nint dist[2][MAX_N];\n\nint process_position(int building, int floor) {\n    if (floor > n) return floor;\n    \n    if (a[floor] == 0 || b[floor] == 0) {\n        int wall = (building == 0) ? a[floor] : b[floor];\n        if (wall == 0) return floor;\n        else if (wall == 1) return ladder_top[building][floor];\n        else return floor;\n    }\n    \n    int wall = (building == 0) ? a[floor] : b[floor];\n    \n    if (wall == 0) {\n        return floor;\n    } else if (wall == 1) {\n        return ladder_top[building][floor];\n    } else {\n        for (int f = floor - 1; f >= 1; f--) {\n            int w = (building == 0) ? a[f] : b[f];\n            if (w == 0) return f;\n            if (w == 1) return ladder_top[building][f];\n        }\n        return 1;\n    }\n}\n\nint main() {\n    while (scanf(\"%d\", &n) && n != 0) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &b[i]);\n        }\n        \n        for (int building = 0; building < 2; building++) {\n            for (int i = 1; i <= n; i++) {\n                int wall = (building == 0) ? a[i] : b[i];\n                if (wall == 1) {\n                    int top = i;\n                    while (top < n) {\n                        int next_wall = (building == 0) ? a[top + 1] : b[top + 1];\n                        if (next_wall == 1) top++;\n                        else break;\n                    }\n                    ladder_top[building][i] = top;\n                } else {\n                    ladder_top[building][i] = i;\n                }\n            }\n        }\n        \n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j <= n; j++) {\n                dist[i][j] = INF;\n            }\n        }\n        \n        int queue[MAX_N * 2][2];\n        int front = 0, rear = 0;\n        \n        int pos0 = process_position(0, 1);\n        int pos1 = process_position(1, 1);\n        \n        dist[0][pos0] = 1;\n        queue[rear][0] = 0;\n        queue[rear][1] = pos0;\n        rear++;\n        \n        dist[1][pos1] = 1;\n        queue[rear][0] = 1;\n        queue[rear][1] = pos1;\n        rear++;\n        \n        while (front < rear) {\n            int cur_building = queue[front][0];\n            int cur_floor = queue[front][1];\n            front++;\n            \n            int other_building = 1 - cur_building;\n            \n            for (int delta = 0; delta <= 2; delta++) {\n                int next_floor = cur_floor + delta;\n                int final_floor = process_position(other_building, next_floor);\n                \n                if (final_floor >= 1 && final_floor <= n) {\n                    if (dist[other_building][final_floor] > dist[cur_building][cur_floor] + 1) {\n                        dist[other_building][final_floor] = dist[cur_building][cur_floor] + 1;\n                        queue[rear][0] = other_building;\n                        queue[rear][1] = final_floor;\n                        rear++;\n                    }\n                }\n            }\n        }\n        \n        int result = INF;\n        if (dist[0][n] < result) result = dist[0][n];\n        if (dist[1][n] < result) result = dist[1][n];\n        \n        if (result == INF) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdbool.h> #define MAX_N 101 #define INF 999999  process_position(int building,  (a[floor] == 0 || b[floor] == 0) { int  (wall == 0) return floor; else if (wall  = (building == 0) ?  } else if (wall == 1) { return ladder_top[building][floor]; } else { for (int f = floor  == 0) return f; if (w == 1) return ladder_top[building][f]; } return 1; } } int main() { while (scanf(\"%d\", &n) && n != 0) { for (int i = 1; i <= n; i++) { scanf(\"%d\", &a[i]); }  scanf(\"%d\", &b[i]); } for (int building = 0; building < 2; building++) { for (int i = 1; i <= n; i++) { int wall = (building == 0) ? a[i] : b[i]; if (wall == 1) { int top = i; while (top < n) { int next_wall = (building == 0) ? a[top + 1] : b[top + 1];  top; } else { ladder_top[building][i] = i; } } } for (int i = 0; i < 2; i++) { for (int j = 0; j <= n; j++) { dist[i][j] = INF; } } int queue[MAX_N * 2][2]; int front = 0, rear = 0;  dist[0][pos0] = 1; queue[rear][0] = 0; queue[rear][1] = pos0; rear++; dist[1][pos1] = 1; queue[rear][0] = 1; queue[rear][1] = pos1; rear++; while (front < rear) { int cur_building = queue[front][0]; int cur_floor = queue[front][1]; front++; int other_building = 1 - cur_building; for (int delta = 0; delta <= 2; delta++) { int  if (final_floor >= 1 && final_floor <= n) { if (dist[other_building][final_floor] > dist[cur_building][cur_floor] + 1) { dist[other_building][final_floor] = dist[cur_building][cur_floor] + 1; queue[rear][0] = other_building; queue[rear][1] = final_floor; rear++;  < result) result = dist[0][n]; if (dist[1][n] < result) result = dist[1][n]; if (result == INF) { printf(\"NA\\n\"); } else { printf(\"%d\\n\", result); } } return 0; }"], "perturbed_original": ["short*p,v[][99];main(c,n,m,i,y){for(;m=scanf(\"%d %[^\\n] %[^\\n]\",&n,v,v+1)*n;printf(m>n?\"NA\\n\":\"%d\\n\",m))for(i=2;i--;m=c)for(c=0,y=n;y>1&c<m;y+=y==n|*p&2?2:*p&p[-1]&1?0:!++c-1)p=--y+v[c+i&1];}"], "original_ll": -3.7130024433135986, "sampled_ll": -0.5196746587753296, "all_perturbed_sampled_ll": [-1.1389800310134888], "all_perturbed_original_ll": [-3.7130024433135986], "perturbed_sampled_ll": -1.1389800310134888, "perturbed_original_ll": -3.7130024433135986, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    void run() {\n        for (;;) {\n            // 1 \u884c\u76ee \u30d3\u30eb\u306e\u968e\u6570 n(\u6574\u6570)\n            // 2 \u884c\u76ee 1 \u3064\u76ee\u306e\u30d3\u30eb a \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 a1 a2 ... an(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a)\n            // \u5404 ai \u306f\u3001i \u968e\u76ee\u306e\u58c1\u306e\u60c5\u5831\u3092\u8868\u3057\u3001\u610f\u5473\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3067\u3059\u3002\n            // 0:\u666e\u901a\u306e\u58c1\n            // 1:\u306f\u3057\u3054(i \u968e\u3068 i+1 \u968e\u306b\u307e\u305f\u304c\u308b)\n            // 2:\u3059\u3079\u308b\u58c1\n            // 3 \u884c\u76ee 2 \u3064\u76ee\u306e\u30d3\u30eb b \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 b1 b2 ... bn(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a)\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int fs[][] = new int[2][n];\n            for (int i = 0; i < n; i++) {\n                fs[0][i] = sc.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                fs[1][i] = sc.nextInt();\n            }\n            Queue<Data> q = new LinkedList<Data>();\n            int sfa = 0;\n            int sfb = 0;\n            if (fs[0][0] == 1)\n                while (sfa + 1 < n && fs[0][sfa + 1] == 1)\n                    sfa++;\n            if (fs[1][0] == 1)\n                while (sfb + 1 < n && fs[1][sfb + 1] == 1)\n                    sfb++;\n            q.add(new Data(0, sfa, 0));\n            q.add(new Data(1, sfb, 0));\n            Set<String> set = new HashSet<String>();\n            boolean na = true;\n            while (!q.isEmpty()) {\n                Data d = q.poll();\n                int b = d.b;\n                int f = d.f;\n                if (set.contains(b + \" \" + f))\n                    continue;\n                set.add(b + \" \" + f);\n                int t = d.t;\n                if (f == n - 1 && fs[b][n - 1] != 2) {\n                    System.out.println(t);\n                    na = false;\n                    break;\n                }\n                int nb = b ^ 1;\n                for (int i = 0; i < 3; i++) {\n                    // \u5411\u304b\u3044\u5074\u306e\u30d3\u30eb\u3078\u30b8\u30e3\u30f3\u30d7\u3059\u308b\u3068\u304d\u306b\u306f\u3001\n                    // \u540c\u3058\u968e\u30fb1\u3064\u4e0a\u306e\u968e\u30fb2 \u3064\u4e0a\u306e\u968e\u306e\u3001\u3044\u305a\u308c\u304b\u306b\u98db\u3073\u79fb\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n                    if (i + f >= n)\n                        continue;\n                    int nf = f + i;\n                    switch (fs[nb][i + f]) {\n                    case 0:\n                        q.add(new Data(nb, nf, t + 1));\n                        break;\n                    case 1:\n                        while (nf + 1 < n && fs[nb][nf + 1] == 1)\n                            nf++;\n                        q.add(new Data(nb, nf, t + 1));\n                        break;\n                    case 2:\n                        while (fs[nb][nf] == 2)\n                            nf--;\n                        q.add(new Data(nb, nf, t + 1));\n                        break;\n                    }\n                }\n\n            }\n            if (na)\n                System.out.println(\"NA\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n\nclass Data {\n    int b;\n    int f;\n    int t;\n\n    Data(int b, int f, int t) {\n        this.b = b;\n        this.f = f;\n        this.t = t;\n    }\n\n    public String toString() {\n        return b + \" \" + f + \" \" + t;\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class State {\n        int building; // 0 or 1\n        int floor;\n        int jumps;\n        \n        State(int building, int floor, int jumps) {\n            this.building = building;\n            this.floor = floor;\n            this.jumps = jumps;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] a = new int[n + 1];\n            int[] b = new int[n + 1];\n            \n            for (int i = 1; i <= n; i++) {\n                a[i] = sc.nextInt();\n            }\n            for (int i = 1; i <= n; i++) {\n                b[i] = sc.nextInt();\n            }\n            \n            int result = solve(n, a, b);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        sc.close();\n    }\n    \n    static int solve(int n, int[] a, int[] b) {\n        int[][] walls = {a, b};\n        boolean[][] visited = new boolean[2][n + 1];\n        Queue<State> queue = new LinkedList<>();\n        \n        // Start from floor 1 of either building\n        int floor0 = processFloor(0, 1, walls, n);\n        int floor1 = processFloor(1, 1, walls, n);\n        \n        if (floor0 != -1) {\n            queue.add(new State(0, floor0, 0));\n            visited[0][floor0] = true;\n        }\n        if (floor1 != -1) {\n            queue.add(new State(1, floor1, 0));\n            visited[1][floor1] = true;\n        }\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.floor == n) {\n                return curr.jumps;\n            }\n            \n            int otherBuilding = 1 - curr.building;\n            \n            // Jump to same floor, +1, or +2\n            for (int delta = 0; delta <= 2; delta++) {\n                int targetFloor = curr.floor + delta;\n                if (targetFloor > n) continue;\n                \n                int finalFloor = processFloor(otherBuilding, targetFloor, walls, n);\n                \n                if (finalFloor != -1 && !visited[otherBuilding][finalFloor]) {\n                    visited[otherBuilding][finalFloor] = true;\n                    queue.add(new State(otherBuilding, finalFloor, curr.jumps + 1));\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static int processFloor(int building, int floor, int[][] walls, int n) {\n        int[] wall = walls[building];\n        \n        if (wall[floor] == 0) {\n            return floor;\n        } else if (wall[floor] == 1) {\n            // Climb ladder to the top\n            int top = floor;\n            while (top < n && wall[top] == 1) {\n                top++;\n            }\n            return top;\n        } else { // wall[floor] == 2\n            // Slide down\n            int slideFloor = floor;\n            while (slideFloor > 1) {\n                slideFloor--;\n                if (wall[slideFloor] == 0) {\n                    return slideFloor;\n                } else if (wall[slideFloor] == 1) {\n                    // Find top of ladder\n                    int top = slideFloor;\n                    while (top < n && wall[top] == 1) {\n                        top++;\n                    }\n                    return top;\n                }\n                // If wall[slideFloor] == 2, continue sliding\n            }\n            // Slid all the way to floor 1 or below, cannot start here\n            return -1;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class State { int building; // 0 or 1 int floor; int  building; this.floor = floor; this.jumps = jumps; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[] a = new int[n + 1]; int[] b = new int[n + 1]; for (int  sc.nextInt(); } for (int i = 1;  result = solve(n, a, b); if (result == -1) { System.out.println(\"NA\"); } else { System.out.println(result); } } sc.close(); } static  1]; Queue<State> queue = new LinkedList<>(); // Start from floor 1 of either building int floor0 = processFloor(0, 1, walls, n); int floor1 = processFloor(1, 1, walls, n); if (floor0 != -1) { queue.add(new  -1) { queue.add(new State(1, floor1, 0)); visited[1][floor1] = true; } while (!queue.isEmpty()) { State curr = queue.poll(); if (curr.floor == n) { return curr.jumps; } int otherBuilding = 1 - curr.building; // Jump to same floor, +1, or +2 for (int delta = 0; delta <= 2; delta++) { int targetFloor = curr.floor + delta; if (targetFloor > n) continue; int finalFloor = processFloor(otherBuilding, targetFloor, walls, n); if  State(otherBuilding, finalFloor, curr.jumps + 1)); } } } return -1; } static int processFloor(int building, int floor, int[][] walls, int  { return floor; } else if (wall[floor] == 1) { // Climb ladder to the top int top = floor;   // Slide down int slideFloor = floor; while (slideFloor > 1) { slideFloor--; if (wall[slideFloor] == 0) { return slideFloor; } else if (wall[slideFloor] == 1) { // Find top of  wall[top] == 1) { top++; } return top; } // If wall[slideFloor] == 2,  1 or below, cannot start here return -1; } } }"], "perturbed_original": ["import java.util.HashSet; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner;  Scanner(System.in); void run() { for (;;) {  a \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 a1 a2  1:\u306f\u3057\u3054(i \u968e\u3068 i+1 \u968e\u306b\u307e\u305f\u304c\u308b) // 2:\u3059\u3079\u308b\u58c1 // 3 \u884c\u76ee 2 \u3064\u76ee\u306e\u30d3\u30eb b \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 b1 b2 ... bn(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a) int n = sc.nextInt(); if (n == 0) break; int fs[][] = new int[2][n]; for (int i = 0; i < n; i++) { fs[0][i] = sc.nextInt(); } for (int i = 0; i < n; i++) { fs[1][i] = sc.nextInt(); } Queue<Data> q = new LinkedList<Data>(); int sfa = 0; int sfb = 0; if (fs[0][0] == 1) while (sfa + 1 <  == 1) while (sfb + 1 <  sfa, 0)); q.add(new Data(1, sfb, 0)); Set<String> set = new HashSet<String>(); boolean na = true; while (!q.isEmpty()) { Data d = q.poll(); int b = d.b; int f = d.f;  \" \" + f); int t = d.t; if (f == n - 1 && fs[b][n - 1] != 2) { System.out.println(t); na = false; break; } int nb =  3; i++) { // \u5411\u304b\u3044\u5074\u306e\u30d3\u30eb\u3078\u30b8\u30e3\u30f3\u30d7\u3059\u308b\u3068\u304d\u306b\u306f\u3001 // \u540c\u3058\u968e\u30fb1\u3064\u4e0a\u306e\u968e\u30fb2 \u3064\u4e0a\u306e\u968e\u306e\u3001\u3044\u305a\u308c\u304b\u306b\u98db\u3073\u79fb\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002 if (i + f >=  < n && fs[nb][nf + 1] == 1) nf++; q.add(new Data(nb, nf, t + 1)); break; case 2: while (fs[nb][nf] == 2) nf--; q.add(new Data(nb, nf, t + 1)); break; } } } if (na) System.out.println(\"NA\"); } } public static void main(String[] args) { new Main().run(); } } class Data { int b; int f; int t; Data(int b, int f, int t) { this.b  String toString() { return b + \" \" + f + \" \" + t; } }"], "original_ll": -1.0258238315582275, "sampled_ll": -0.6350730657577515, "all_perturbed_sampled_ll": [-1.572609782218933], "all_perturbed_original_ll": [-1.8413411378860474], "perturbed_sampled_ll": -1.572609782218933, "perturbed_original_ll": -1.8413411378860474, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import Queue\nwhile True:\n    n = input()\n    if n==0:\n        break\n    a = []\n    nxt = [range(n) for i in xrange(2)]\n    for i in xrange(2):\n        a.append(map(int, raw_input().split()))\n    for i in xrange(2):\n        back = 0\n        for j in xrange(n):\n            if a[i][j]==2:\n                nxt[i][j] = back\n            else:\n                back = j\n        forw = n-1\n        for j in xrange(n-1,-1,-1):\n            if a[i][j]==1:\n                nxt[i][j] = forw\n            else:\n                forw = j-1\n    cost = [[10**9] * n for i in xrange(2)]\n    que = Queue.PriorityQueue()\n    que.put((0, 0, 0))\n    que.put((0, 1, 0))\n    ans = -1\n    while not que.empty():\n        co, sd, st = que.get()\n        if st==n-1:\n            ans = co\n            break\n        if cost[sd][st] < co:\n            continue\n        for i in xrange(3 if st+2<n else 2):\n            step = nxt[sd^1][st+i]\n            if co+1 < cost[sd^1][step]:\n                cost[sd^1][step] = co+1\n                que.put((co+1, sd^1, step))\n    print \"NA\" if ans==-1 else ans", "sampled": "from collections import deque\n\ndef solve(n, a, b):\n    # Preprocess ladders - find top of each ladder\n    def find_ladder_top(walls):\n        tops = list(range(n))\n        i = 0\n        while i < n:\n            if walls[i] == 1:\n                j = i\n                while j < n and walls[j] == 1:\n                    j += 1\n                for k in range(i, j):\n                    tops[k] = j - 1\n                i = j\n            else:\n                i += 1\n        return tops\n    \n    ladder_tops_a = find_ladder_top(a)\n    ladder_tops_b = find_ladder_top(b)\n    \n    # Function to find where we end up after landing on floor i of building side\n    def land_on(floor, side):\n        if side == 0:\n            walls = a\n            ladder_tops = ladder_tops_a\n        else:\n            walls = b\n            ladder_tops = ladder_tops_b\n        \n        if walls[floor] == 0:  # Normal wall\n            return floor\n        elif walls[floor] == 1:  # Ladder\n            return ladder_tops[floor]\n        else:  # walls[floor] == 2, sliding wall\n            # Slide down to normal wall or top of ladder\n            for f in range(floor - 1, -1, -1):\n                if walls[f] == 0:\n                    return f\n                elif walls[f] == 1:\n                    return ladder_tops[f]\n            return -1  # Should not happen as floor 0 is not sliding\n    \n    # BFS\n    queue = deque()\n    visited = set()\n    \n    # Start from floor 0 of either building\n    start_a = land_on(0, 0)\n    start_b = land_on(0, 1)\n    \n    if start_a >= 0:\n        queue.append((0, start_a, 0))  # (side, floor, jumps)\n        visited.add((0, start_a))\n    if start_b >= 0:\n        queue.append((1, start_b, 0))\n        visited.add((1, start_b))\n    \n    while queue:\n        side, floor, jumps = queue.popleft()\n        \n        # Check if we can reach rooftop\n        if floor == n - 1:\n            return jumps\n        \n        # Try jumping to other building\n        other_side = 1 - side\n        for delta in [0, 1, 2]:\n            next_floor = floor + delta\n            if next_floor < n:\n                final_floor = land_on(next_floor, other_side)\n                if final_floor >= 0 and (other_side, final_floor) not in visited:\n                    visited.add((other_side, final_floor))\n                    queue.append((other_side, final_floor, jumps + 1))\n    \n    return \"NA\"\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    result = solve(n, a, b)\n    print(result)\n", "perturbed_sampled": ["from collections import deque def solve(n, a, b): # Preprocess ladders - find top of each ladder def find_ladder_top(walls): tops = list(range(n)) i =  = i while  1 i = j else: i += 1 return tops ladder_tops_a = find_ladder_top(a) ladder_tops_b = find_ladder_top(b) # Function to find where we end up after landing on floor i of building side def land_on(floor, side): if side == 0: walls = a ladder_tops = ladder_tops_a else: walls = b ladder_tops = ladder_tops_b if walls[floor] == 0: # Normal wall return floor elif walls[floor] == 1: # Ladder return ladder_tops[floor] else: # walls[floor] == 2, sliding wall # Slide  in range(floor - 1, -1,   floor 0 is not sliding # BFS queue = deque() visited = set() # Start from floor 0 of either building start_a = land_on(0, 0) start_b = land_on(0, 1) if start_a >= 0: queue.append((0, start_a, 0)) # (side, floor, jumps) visited.add((0, start_a)) if start_b >= 0: queue.append((1, start_b, 0)) visited.add((1, start_b)) while queue: side, floor, jumps = queue.popleft()  n - 1: return jumps # Try  delta in [0, 1, 2]: next_floor = floor + delta if next_floor < n: final_floor = land_on(next_floor, other_side) if final_floor >= 0 and (other_side, final_floor) not in visited: visited.add((other_side, final_floor)) queue.append((other_side, final_floor, jumps + 1)) return  break a = list(map(int, input().split())) b = list(map(int, input().split())) result = solve(n, a, b) print(result)"], "perturbed_original": ["import Queue while True: n = input() if n==0: break a = [] nxt = [range(n) for i in xrange(2)] for i in xrange(2): a.append(map(int, raw_input().split())) for i in xrange(2): back = 0 for j in xrange(n): if a[i][j]==2: nxt[i][j] = back else: back = j forw = n-1 for j in xrange(n-1,-1,-1): if a[i][j]==1: nxt[i][j] = forw else: forw = j-1 cost = [[10**9] * n for i in xrange(2)] que = Queue.PriorityQueue() que.put((0,  que.empty(): co, sd,  cost[sd][st] < co: continue for i in xrange(3 if st+2<n else 2): step = nxt[sd^1][st+i] if co+1 < cost[sd^1][step]:  else ans"], "original_ll": -1.122815489768982, "sampled_ll": -0.8739228248596191, "all_perturbed_sampled_ll": [-1.728747010231018], "all_perturbed_original_ll": [-2.0019986629486084], "perturbed_sampled_ll": -1.728747010231018, "perturbed_original_ll": -2.0019986629486084, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "m[100],a[100],b[100],i,j,M,B;main(n){for(;scanf(\"%d\",&n)*n;puts(B?\"NG\":\"OK\")){for(i=n;i--;B=0)scanf(\"%d%d%d\",m+i,a+i,b+i);for(i=n;i--;B|=M>150)for(M=0,j=n;j--;)M+=a[i]>=a[j]&&a[i]<b[j]?m[j]:0;}}\nm[100],a[100],b[100],i,j,M,B;", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int time;\n    int weight;\n    int type; // 0 for start, 1 for end\n} Event;\n\nint compare(const void *a, const void *b) {\n    Event *ea = (Event *)a;\n    Event *eb = (Event *)b;\n    if (ea->time != eb->time) {\n        return ea->time - eb->time;\n    }\n    // If times are equal, process end events before start events\n    return ea->type - eb->type;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Event events[200];\n        int eventCount = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int m, a, b;\n            scanf(\"%d %d %d\", &m, &a, &b);\n            \n            events[eventCount].time = a;\n            events[eventCount].weight = m;\n            events[eventCount].type = 0;\n            eventCount++;\n            \n            events[eventCount].time = b;\n            events[eventCount].weight = m;\n            events[eventCount].type = 1;\n            eventCount++;\n        }\n        \n        qsort(events, eventCount, sizeof(Event), compare);\n        \n        int currentWeight = 0;\n        int broken = 0;\n        \n        for (int i = 0; i < eventCount; i++) {\n            if (events[i].type == 0) {\n                // Person starts crossing\n                currentWeight += events[i].weight;\n                if (currentWeight > 150) {\n                    broken = 1;\n                    break;\n                }\n            } else {\n                // Person finishes crossing\n                currentWeight -= events[i].weight;\n            }\n        }\n        \n        if (broken) {\n            printf(\"NG\\n\");\n        } else {\n            printf(\"OK\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int time; int weight; int type; // 0 for start, 1 for end } Event; int compare(const void *a, const void *b) { Event *ea = (Event *)a; Event *eb = (Event *)b; if (ea->time != eb->time) { return ea->time - eb->time; } // If times are equal, process end events before start events return ea->type - eb->type; }  && n != 0) { Event events[200]; int eventCount =  = 0; eventCount++; events[eventCount].time = b; events[eventCount].weight = m; events[eventCount].type = 1; eventCount++; } qsort(events, eventCount, sizeof(Event), compare); int currentWeight = 0; int broken = 0; for (int i = 0; i < eventCount; i++) { if  events[i].weight; if (currentWeight > 150) { broken = 1; break; } } else { // Person finishes crossing currentWeight -= events[i].weight; } } if (broken) { printf(\"NG\\n\"); } else { printf(\"OK\\n\"); } } return 0; }"], "perturbed_original": ["m[100],a[100],b[100],i,j,M,B;main(n){for(;scanf(\"%d\",&n)*n;puts(B?\"NG\":\"OK\")){for(i=n;i--;B=0)scanf(\"%d%d%d\",m+i,a+i,b+i);for(i=n;i--;B|=M>150)for(M=0,j=n;j--;)M+=a[i]>=a[j]&&a[i]<b[j]?m[j]:0;}} m[100],a[100],b[100],i,j,M,B;"], "original_ll": -2.29946231842041, "sampled_ll": -0.5535210967063904, "all_perturbed_sampled_ll": [-1.390129804611206], "all_perturbed_original_ll": [-2.307041645050049], "perturbed_sampled_ll": -1.390129804611206, "perturbed_original_ll": -2.307041645050049, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n//Dangerous Bridge\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tboolean[][] map = new boolean[n*2][250];\n\t\t\tint[] w = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tfor(int j=a;j<b;j++)map[i][j] = true;\n\t\t\t}\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<231;i++){\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(map[j][i])sum+=w[j];\n\t\t\t\t}\n\t\t\t\tif(sum>150){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(f?\"OK\":\"NG\");\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            List<Event> events = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                int m = sc.nextInt();\n                long a = sc.nextLong();\n                long b = sc.nextLong();\n                \n                events.add(new Event(a, m, true));\n                events.add(new Event(b, m, false));\n            }\n            \n            Collections.sort(events);\n            \n            int currentWeight = 0;\n            boolean broken = false;\n            \n            for (Event e : events) {\n                if (e.isEnter) {\n                    currentWeight += e.weight;\n                    if (currentWeight > 150) {\n                        broken = true;\n                        break;\n                    }\n                } else {\n                    currentWeight -= e.weight;\n                }\n            }\n            \n            System.out.println(broken ? \"NG\" : \"OK\");\n        }\n        \n        sc.close();\n    }\n    \n    static class Event implements Comparable<Event> {\n        long time;\n        int weight;\n        boolean isEnter;\n        \n        Event(long time, int weight, boolean isEnter) {\n            this.time = time;\n            this.weight = weight;\n            this.isEnter = isEnter;\n        }\n        \n        @Override\n        public int compareTo(Event other) {\n            if (this.time != other.time) {\n                return Long.compare(this.time, other.time);\n            }\n            // Exit events should come before enter events at the same time\n            if (this.isEnter != other.isEnter) {\n                return this.isEnter ? 1 : -1;\n            }\n            return 0;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; List<Event> events = new ArrayList<>(); for (int i  events.add(new Event(a, m, true)); events.add(new Event(b, m, false)); } Collections.sort(events); int currentWeight = 0; boolean broken = false; for (Event e : events)  150) { broken = true; break; } } else { currentWeight -= e.weight; } } System.out.println(broken ? \"NG\" : \"OK\");  time; int weight; boolean isEnter; Event(long time, int weight, boolean isEnter) { this.time = time; this.weight = weight; this.isEnter = isEnter; } @Override public int compareTo(Event other) { if (this.time != other.time) { return Long.compare(this.time, other.time); } // Exit events should come before enter events at the same time if (this.isEnter != other.isEnter) { return this.isEnter ? 1 : -1; } return 0; } } }"], "perturbed_original": ["=0; j++{ if(j==14){<extra_id_10>i=0;j>=d){ if(d==14){ void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){ int n = sc.nextInt(); if(n==0)break; boolean[][] map = new boolean[n*2][250]; int[] w = new int[n]; for(int i=0;i<n;i++){ w[i] = sc.nextInt(); int a = sc.nextInt(); int b = sc.nextInt(); for(int j=a;j<b;j++)map[i][j] =  = 0; for(int j=0;j<n;j++){ if(map[j][i])sum+=w[j]; } if(sum>150){ f = false; break; } } System.out.println(f?\"OK\":\"NG\"); } } }"], "original_ll": -0.9265027642250061, "sampled_ll": -0.5284178853034973, "all_perturbed_sampled_ll": [-1.4058337211608887], "all_perturbed_original_ll": [-1.880262017250061], "perturbed_sampled_ll": -1.4058337211608887, "perturbed_original_ll": -1.880262017250061, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n=input()\n    if n==0: break\n    d=[map(int,raw_input().split()) for i in range(n)]\n    w=max([sum([d2[0] for d2 in d if d2[1]<=d1[1]<d2[2]]) for d1 in d])\n    print \"OK\" if w<151 else \"NG\"", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    people = []\n    for _ in range(n):\n        m, a, b = map(int, input().split())\n        people.append((m, a, b))\n    \n    # Collect all time points\n    times = set()\n    for m, a, b in people:\n        times.add(a)\n        times.add(b)\n    \n    times = sorted(times)\n    \n    broken = False\n    for t in times:\n        total_weight = 0\n        for m, a, b in people:\n            if a <= t < b:\n                total_weight += m\n        if total_weight > 150:\n            broken = True\n            break\n    \n    if broken:\n        print(\"NG\")\n    else:\n        print(\"OK\")\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break people = [] for _ in range(n): m, a, b = map(int, input().split()) people.append((m, a, b)) # Collect all time points times =  total_weight = 0 for m, a, b in people: if a <= t < b: total_weight += m if total_weight > 150: broken = True break if broken: print(\"NG\") else: print(\"OK\")"], "perturbed_original": ["while 1: n=input() if n==0: break d=[map(int,raw_input().split()) for i in range(n)] w=max([sum([d2[0] for d2 in d if d2[1]<=d1[1]<d2[2]]) for d1 in d]) print \"OK\" if w<151 else \"NG\""], "original_ll": -1.7229571342468262, "sampled_ll": -0.8316839337348938, "all_perturbed_sampled_ll": [-1.8006960153579712], "all_perturbed_original_ll": [-1.9314976930618286], "perturbed_sampled_ll": -1.8006960153579712, "perturbed_original_ll": -1.9314976930618286, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "char z[];n,a;main(r){for(;scanf(\"%d\",&a)*a;puts(z+n))for(n=30;a;a=(r-a)/10)r=a%10,z[--n]=r+48;}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    long long n;\n    \n    while(scanf(\"%lld\", &n) == 1 && n != 0) {\n        if(n == 0) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        char result[100];\n        int idx = 0;\n        \n        long long num = n;\n        while(num != 0) {\n            long long remainder = num % (-10);\n            num = num / (-10);\n            \n            if(remainder < 0) {\n                remainder += 10;\n                num += 1;\n            }\n            \n            result[idx++] = '0' + remainder;\n        }\n        \n        for(int i = idx - 1; i >= 0; i--) {\n            printf(\"%c\", result[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { long long n; while(scanf(\"%lld\", &n) == 1 && n != 0) { if(n == 0) { printf(\"0\\n\"); continue; } char result[100]; int idx = 0;  long remainder = num %  remainder += 10; num += 1; } result[idx++] = '0' + remainder; } for(int i = idx - 1; i >= 0; i--) { printf(\"%c\", result[i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["char z[];n,a;main(r){for(;scanf(\"%d\",&a)*a;puts(z+n))for(n=30;a;a=(r-a)/10)r=a%10,z[--n]=r+48;}"], "original_ll": -3.2128729820251465, "sampled_ll": -0.6255590319633484, "all_perturbed_sampled_ll": [-1.405507206916809], "all_perturbed_original_ll": [-3.2128729820251465], "perturbed_sampled_ll": -1.405507206916809, "perturbed_original_ll": -3.2128729820251465, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint ss = sc.nextInt();\n\t\t\tif(ss == 0) break;\n\t\t\tboolean minus = false;\n\t\t\tif(ss < 0) minus = true;\n\t\t\tchar[] in = String.valueOf(ss).toCharArray();\n\t\t\tint[] ar0 = new int[32];\n\t\t\tint[] ar1 = new int[32];\n\t\t\tfor(int i = 0; i < in.length; i++) {\n\t\t\t\tif(in[in.length - i - 1] == '-') continue;\n\t\t\t\tar0[i] = in[in.length -1 - i] - '0';\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tif(!minus)\n\t\t\tfor(int i = 0; i < 32; i++) {\n\t\t\t\tif(ar0[i] == 0) continue;\n\t\t\t\tmax = i;\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\tar1[i] += ar0[i];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tar0[i+1] += ar0[i]/10;\n\t\t\t\t\t\tar1[i] += ar0[i] % 10;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tar0[i+1] += ar0[i] / 10;\n\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\tif(ar0[i] % 10 != 0)\n\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < 32; i++) {\n\t\t\t\t\tif(ar0[i] == 0) continue;\n\t\t\t\t\tif(i % 2 != 0) {\n\t\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\t\tar1[i] += ar0[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tar0[i+1] += ar0[i]/10;\n\t\t\t\t\t\t\tar1[i] += ar0[i] % 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tar0[i+1] += ar0[i] / 10;\n\t\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\t\tif(ar0[i] % 10 != 0)\n\t\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint check = 0;\n\t\t\tfor(int i = 0; i < 32; i++) {\n\t\t\t\tif(ar1[i] != 0) {\n\t\t\t\t\tcheck = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = check; i >= 0; i--) {\n\t\t\t\tSystem.out.print(ar1[i]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long A = sc.nextLong();\n            if (A == 0) break;\n            \n            if (A == 0) {\n                System.out.println(\"0\");\n                continue;\n            }\n            \n            StringBuilder result = new StringBuilder();\n            long num = A;\n            \n            while (num != 0) {\n                long remainder = num % (-10);\n                num = num / (-10);\n                \n                if (remainder < 0) {\n                    remainder += 10;\n                    num += 1;\n                }\n                \n                result.append(remainder);\n            }\n            \n            System.out.println(result.reverse().toString());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  = new Scanner(System.in); while (true) { long A = sc.nextLong(); if (A == 0) break; if (A == 0) { System.out.println(\"0\"); continue; } StringBuilder result = new StringBuilder(); long num = A; while (num != 0) { long remainder = num % (-10); num = num / (-10); if  } result.append(remainder); } System.out.println(result.reverse().toString()); } sc.close(); } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Arrays;  import java.io.*; public class  = new Scanner(System.in); while(true) { int ss = sc.nextInt(); if(ss == 0) break; boolean minus = false; if(ss < 0) minus  int[32];  < in.length; i++) { if(in[in.length - i - 1] == '-') continue; ar0[i] = in[in.length -1 - i] - '0'; } int max = 0; if(!minus) for(int i = 0; i < 32; i++) { if(ar0[i] == 0) continue; max = i; if(i % 2 == 0) { if(ar0[i] < 10) { ar1[i] += ar0[i]; } else { ar0[i+1] += ar0[i]/10; ar1[i] += ar0[i] % 10; } } else { if(ar0[i] < 10) { ar1[i] += 10 - ar0[i] % 10; ar0[i+1] += 1; } else { ar0[i+1] += ar0[i] / 10; ar1[i] += 10 - ar0[i] % 10; if(ar0[i] %  { for(int  < 10) { ar1[i] += ar0[i]; } else { ar0[i+1] += ar0[i]/10; ar1[i] += ar0[i] % 10; }  - ar0[i] % 10; ar0[i+1] +=  += 10 - ar0[i] % 10; if(ar0[i] % 10 != 0) ar0[i+1] += 1; } } } } int check = 0; for(int i = 0; i < 32; i++) { if(ar1[i] != 0) { check = i; } } for(int i = check; i >= 0; i--) { System.out.print(ar1[i]); } System.out.println(); } } }"], "original_ll": -0.49065208435058594, "sampled_ll": -0.6365665793418884, "all_perturbed_sampled_ll": [-1.464276671409607], "all_perturbed_original_ll": [-1.0501292943954468], "perturbed_sampled_ll": -1.464276671409607, "perturbed_original_ll": -1.0501292943954468, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n\tn = raw_input()[::-1]\n\tif n == \"0\": break\n\tans = \"\"\n\tm = 1 if n[-1] == \"-\" else 0\n\tfor i in range(0, len(n) - m, 2):\n\t\tif int(n[i]) > 0:\n\t\t\tif i < len(n) - 1 - m:\n\t\t\t\tans += str(10 - int(n[i])) + str(int(n[i + 1]) + 1)\n\t\t\telse:\n\t\t\t\tans += str(10 - int(n[i])) + \"1\"\n\t\telse:\n\t\t\tans += \"0\" + n[i + 1]\n\tif len(n) == 1 or (m == 0 and n[0] == \"0\"):\n\t\tans = int(\"2\"+\"0\"*len(n)) - int(ans[::-1]) \n\telse:\n\t\tans = int(ans[::-1])\n\tprint ans", "sampled": "import sys\n\ndef to_negadecimal(n):\n    if n == 0:\n        return \"0\"\n    \n    result = []\n    while n != 0:\n        if n > 0:\n            remainder = n % (-10)\n            n = n // (-10)\n            if remainder < 0:\n                remainder += 10\n                n += 1\n        else:\n            remainder = n % (-10)\n            n = n // (-10)\n            if remainder < 0:\n                remainder += 10\n                n += 1\n        result.append(str(remainder))\n    \n    return ''.join(reversed(result))\n\nfor line in sys.stdin:\n    a = int(line.strip())\n    if a == 0 and line.strip() == \"0\":\n        # Check if this is the last zero (terminator)\n        break\n    print(to_negadecimal(a))\n```\n\nWait, let me reconsider the termination condition:\n\n```python\nimport sys\n\ndef to_negadecimal(n):\n    if n == 0:\n        return \"0\"\n    \n    result = []\n    while n != 0:\n        remainder = n % (-10)\n        n = n // (-10)\n        if remainder < 0:\n            remainder += 10\n            n += 1\n        result.append(str(remainder))\n    \n    return ''.join(reversed(result))\n\nfor line in sys.stdin:\n    a = int(line.strip())\n    if a == 0:\n        break\n    print(to_negadecimal(a))\n", "perturbed_sampled": ["import sys def to_negadecimal(n): if n == 0: return \"0\" result  remainder = n % (-10) n = n // (-10) if remainder < 0: remainder += 10 n += 1 else: remainder = n % (-10) n = n // (-10) if remainder < 0: remainder += 10 n  = int(line.strip()) if a == 0 and line.strip() == \"0\": # Check if this is the last zero (terminator) break print(to_negadecimal(a)) ``` Wait, let me reconsider the termination condition: ```python import sys def to_negadecimal(n): if n == 0: return \"0\" result = [] while n != 0:  if  return ''.join(reversed(result)) for line in sys.stdin: a = int(line.strip()) if a == 0: break print(to_negadecimal(a))"], "perturbed_original": ["while 1: n = raw_input()[::-1]  1 if n[-1] == \"-\" else 0 for i in range(0, len(n) - m, 2): if int(n[i]) > 0: if  - int(n[i])) + str(int(n[i + 1]) + 1) else: ans += str(10 - int(n[i])) + \"1\" else: ans += \"0\" + n[i + 1] if len(n) == 1 or (m == 0 and n[0] == \"0\"): ans = int(\"2\"+\"0\"*len(n)) - int(ans[::-1]) else: ans = int(ans[::-1]) print ans"], "original_ll": -1.2315387725830078, "sampled_ll": -0.7549880743026733, "all_perturbed_sampled_ll": [-1.904929518699646], "all_perturbed_original_ll": [-1.7934198379516602], "perturbed_sampled_ll": -1.904929518699646, "perturbed_original_ll": -1.7934198379516602, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "W,H,m,c[10][10];\nDP[10][10][10][10][51];//\u008ec\u008b\u00e0[y\u008d\u00c0\u0095W][x\u008d\u00c0\u0095W][\u008d\u00b6\u0092[][\u0089E\u0092[][\u008e_\u0091f\u008ec\u0097\u00ca]\n#define Update(d,v) ((v)>(d)?d=(v):0)\nCalcO(o,x,y){//\u008e_\u0091f\u008ec\u0097\u00ca\u0082\u00cc\u008cv\u008eZ\n\tif(c[x][y]>0){\n\t\to+=c[x][y];\n\t\tif(o>m)\n\t\t\to=m;\n\t}\n\treturn o;\n}\nCalcF(f,x,y){//\u008ec\u008b\u00e0\u0082\u00cc\u008cv\u008eZ\n\tif(c[x][y]<0)\n\t\tf+=c[x][y];\n\treturn f;\n}\nmain(){\n\tint x,y,range,d,dx,f,o,xl,xr,fn,on,f0;\n\tfor(;scanf(\"%d%d%d%d%d\",&W,&H,&f0,&m,&o),W;){\n\t\tfor(y=0;y<H;y++)\n\t\t\tfor(x=0;x<W;x++)\n\t\t\t\tscanf(\"%d\",&c[x][y]);\n\t\tf0++;//\u008ec\u008b\u00e00\u0082\u00c5\u0082\u00e0DP\u0082\u00cd1\u0082\u00c6\u0082\u00b5\u0082\u00c4\u0081ANA\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00cc\u0082\u00f0\u0096h\u0082\u00ae\n\t\tfor(y=0,x=0;x<W;x++)\n\t\t\tDP[y][x][x][x][CalcO(o-1,x,y)]=CalcF(f0,x,y);\n\t\tfor(y=0;y<H-1;y++){\n\t\t\tfor(range=0;range<W;range++){//\u008d\u00b6\u0089E\u0082\u00c9\u008c@\u0082\u00e9\u008dL\u0082\u00b3\n\t\t\t\tfor(d=0;d<2;d++){//\u008c\u00bb\u008d\u00dd\u0088\u00ca\u0092ux\u0082\u00f0\u0089\u009d\u0095\u009c\u0082\u00b3\u0082\u00b9\u0082\u00e9\n\t\t\t\t\tfor(xl=0;xl<W-range;xl++){//\u008d\u00b6\u0092[\n\t\t\t\t\t\tfor(dx=0;dx<=range;dx++){//x\u0095\u00cf\u0088\u00ca\n\t\t\t\t\t\t\txr=xl+range;\n\t\t\t\t\t\t\tx=d?xr-dx:xl+dx;\n\t\t\t\t\t\t\t//printf(\"range=%d, d=%d, xl=%d, dx=%d, xr=%d, x=%d\\n\",range,d,xl,dx,xr,x);\n\t\t\t\t\t\t\tfor(o=m;o>0;o--){\n\t\t\t\t\t\t\t\tif(f=DP[y][x][xl][xr][o]){\n\t\t\t\t\t\t\t\t\tif(x>0){\n\t\t\t\t\t\t\t\t\t\tif(x==xl){//\u008d\u00b6\u0082\u00d6\u008c@\u0082\u00e9\n\t\t\t\t\t\t\t\t\t\t\tfn=CalcF(f,x-1,y);\n\t\t\t\t\t\t\t\t\t\t\ton=CalcO(o-1,x-1,y);\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x-1][x-1][xr][on],fn);\n\t\t\t\t\t\t\t\t\t\t}else{//\u008d\u00b6\u0082\u00d6\u0090i\u0082\u00de\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x-1][xl][xr][o-1],f);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(x<W-1){\n\t\t\t\t\t\t\t\t\t\tif(x==xr){//\u0089E\u0082\u00d6\u008c@\u0082\u00e9\n\t\t\t\t\t\t\t\t\t\t\tfn=CalcF(f,x+1,y);\n\t\t\t\t\t\t\t\t\t\t\ton=CalcO(o-1,x+1,y);\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x+1][xl][x+1][on],fn);\n\t\t\t\t\t\t\t\t\t\t}else{//\u0089E\u0082\u00d6\u0090i\u0082\u00de\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x+1][xl][xr][o-1],f);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//\u0089\u00ba\u0082\u00d6\u008c@\u0082\u00e9\n\t\t\t\t\t\t\t\t\tfn=CalcF(f,x,y+1);\n\t\t\t\t\t\t\t\t\ton=CalcO(o-1,x,y+1);\n\t\t\t\t\t\t\t\t\tUpdate(DP[y+1][x][x][x][on],fn);\n\t\t\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}//o\n\t\t\t\t\t\t}//dx\n\t\t\t\t\t}//xl\n\t\t\t\t}//d\n\t\t\t}//range\n\t\t}//y\n#if 0\n\t\tfor(y=0;y<H;y++){\n\t\t\tfor(x=0;x<W;x++){\n\t\t\t\tfor(o=m;o>0;o--){\n\t\t\t\t\tif(f=DP[y][x][x][x][o]){\n\t\t\t\t\t\tprintf(\"%4d \",f-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(o==0)\n\t\t\t\t\tprintf(\"---- \");\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n#endif\n\t\tfn=0;\n\t\tfor(x=0;x<W;x++){\n\t\t\tfor(o=m;o>0;o--){\n\t\t\t\tf=DP[H-1][x][x][x][o];\n\t\t\t\tif(f>fn)\n\t\t\t\t\tfn=f;\n\t\t\t}\n\t\t}\n\t\tprintf(fn?\"%d\\n\":\"NA\\n\",f0-fn);\n\t\tmemset(DP,0,sizeof(DP));\n\t}\n\tputs(\"\");\n\texit(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_W 10\n#define MAX_H 10\n#define MAX_O 50\n\nint W, H, f, m, o;\nint grid[MAX_W + 1][MAX_H + 1];\nint visited[MAX_W + 1][MAX_H + 1][MAX_O + 1];\nint cost[MAX_W + 1][MAX_H + 1][MAX_O + 1];\n\ntypedef struct {\n    int x, y, oxygen, c;\n} State;\n\nState queue[1000000];\nint front, rear;\n\nvoid enqueue(int x, int y, int oxygen, int c) {\n    queue[rear].x = x;\n    queue[rear].y = y;\n    queue[rear].oxygen = oxygen;\n    queue[rear].c = c;\n    rear++;\n}\n\nState dequeue() {\n    return queue[front++];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &W, &H);\n        if (W == 0 && H == 0) break;\n        \n        scanf(\"%d %d %d\", &f, &m, &o);\n        \n        for (int j = 1; j <= H; j++) {\n            for (int i = 1; i <= W; i++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        \n        memset(visited, 0, sizeof(visited));\n        for (int i = 0; i <= W; i++) {\n            for (int j = 0; j <= H; j++) {\n                for (int k = 0; k <= m; k++) {\n                    cost[i][j][k] = INT_MAX;\n                }\n            }\n        }\n        \n        front = 0;\n        rear = 0;\n        \n        for (int i = 1; i <= W; i++) {\n            if (grid[i][1] > 0) {\n                int new_o = o - 1 + grid[i][1];\n                if (new_o > m) new_o = m;\n                if (new_o > 0) {\n                    enqueue(i, 1, new_o, 0);\n                    cost[i][1][new_o] = 0;\n                }\n            } else {\n                int dig_cost = -grid[i][1];\n                if (o > 1) {\n                    enqueue(i, 1, o - 1, dig_cost);\n                    cost[i][1][o - 1] = dig_cost;\n                }\n            }\n        }\n        \n        int min_cost = INT_MAX;\n        \n        while (front < rear) {\n            State s = dequeue();\n            int x = s.x;\n            int y = s.y;\n            int oxy = s.oxygen;\n            int c = s.c;\n            \n            if (visited[x][y][oxy]) continue;\n            visited[x][y][oxy] = 1;\n            \n            if (y == H) {\n                if (c < min_cost) {\n                    min_cost = c;\n                }\n                continue;\n            }\n            \n            int dx[] = {-1, 1, 0};\n            int dy[] = {0, 0, 1};\n            \n            for (int d = 0; d < 3; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                \n                if (nx < 1 || nx > W || ny < 1 || ny > H) continue;\n                \n                if (grid[nx][ny] > 0) {\n                    int new_oxy = oxy - 1 + grid[nx][ny];\n                    if (new_oxy > m) new_oxy = m;\n                    if (new_oxy > 0 && !visited[nx][ny][new_oxy]) {\n                        if (cost[nx][ny][new_oxy] > c) {\n                            cost[nx][ny][new_oxy] = c;\n                            enqueue(nx, ny, new_oxy, c);\n                        }\n                    }\n                } else {\n                    int dig_cost = -grid[nx][ny];\n                    int new_cost = c + dig_cost;\n                    int new_oxy = oxy - 1;\n                    if (new_oxy > 0 && !visited[nx][ny][new_oxy]) {\n                        if (cost[nx][ny][new_oxy] > new_cost) {\n                            cost[nx][ny][new_oxy] = new_cost;\n                            enqueue(nx, ny, new_oxy, new_cost);\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (min_cost == INT_MAX || min_cost > f) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", min_cost);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  #define MAX_O 50  + 1]; int visited[MAX_W + 1][MAX_H + 1][MAX_O + 1]; int cost[MAX_W + 1][MAX_H + 1][MAX_O + 1]; typedef struct { int x, y, oxygen, c; } State; State queue[1000000]; int front, rear; void enqueue(int x, int y, int oxygen, int c) { queue[rear].x = x; queue[rear].y = y; queue[rear].oxygen = oxygen; queue[rear].c =  main() { while (1) { scanf(\"%d %d\", &W, &H); if (W == 0 && H == 0) break; scanf(\"%d %d %d\", &f, &m, &o);  for (int i = 1; i <= W; i++) { scanf(\"%d\", &grid[i][j]); } } memset(visited, 0, sizeof(visited)); for (int i = 0; i <= W; i++) { for (int j = 0; j <= H; j++) { for (int k = 0; k <= m; k++) { cost[i][j][k] = INT_MAX; } } } front = 0; rear = 0; for (int i = 1; i <= W; i++) { if (grid[i][1] > 0) { int new_o = o - 1 + grid[i][1]; if (new_o > m) new_o = m; if (new_o > 0) { enqueue(i, 1, new_o, 0); cost[i][1][new_o] = 0; } } else { int  o - 1, dig_cost); cost[i][1][o - 1] = dig_cost; } } } int min_cost = INT_MAX; while (front < rear) { State s = dequeue(); int x = s.x; int y = s.y; int oxy =  min_cost) { min_cost = c; } continue; } int dx[] =  (int d = 0; d < 3; d++) { int nx = x + dx[d]; int ny = y + dy[d];  < 1 || ny > H) continue; if (grid[nx][ny] > 0) { int new_oxy = oxy - 1 + grid[nx][ny]; if (new_oxy > m) new_oxy = m; if (new_oxy > 0 && !visited[nx][ny][new_oxy]) { if (cost[nx][ny][new_oxy] > c) { cost[nx][ny][new_oxy] = c; enqueue(nx,  = -grid[nx][ny]; int new_cost = c + dig_cost; int  !visited[nx][ny][new_oxy]) {  new_oxy, new_cost); } } } }  printf(\"NA\\n\"); } else { printf(\"%d\\n\", min_cost); } } return 0; }"], "perturbed_original": ["W,H,m,c[10][10]; DP[10][10][10][10][51];//\u008ec\u008b\u00e0[y\u008d\u00c0\u0095W][x\u008d\u00c0\u0095W][\u008d\u00b6\u0092[][\u0089E\u0092[][\u008e_\u0091f\u008ec\u0097\u00ca] #define Update(d,v) ((v)>(d)?d=(v):0) CalcO(o,x,y){//\u008e_\u0091f\u008ec\u0097\u00ca\u0082\u00cc\u008cv\u008eZ if(c[x][y]>0){ o+=c[x][y]; if(o>m) o=m; } return o; } CalcF(f,x,y){//\u008ec\u008b\u00e0\u0082\u00cc\u008cv\u008eZ if(c[x][y]<0) f+=c[x][y]; return f; } main(){ int x,y,range,d,dx,f,o,xl,xr,fn,on,f0; for(;scanf(\"%d%d%d%d%d\",&W,&H,&f0,&m,&o),W;){ for(y=0;y<H;y++) for(x=0;x<W;x++) scanf(\"%d\",&c[x][y]); f0++;//\u008ec\u008b\u00e00\u0082\u00c5\u0082\u00e0DP\u0082\u00cd1\u0082\u00c6\u0082\u00b5\u0082\u00c4\u0081ANA\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00cc\u0082\u00f0\u0096h\u0082\u00ae for(y=0,x=0;x<W;x++) DP[y][x][x][x][CalcO(o-1,x,y)]=CalcF(f0,x,y); for(y=0;y<H-1;y++){ for(range=0;range<W;range++){//\u008d\u00b6\u0089E\u0082\u00c9\u008c@\u0082\u00e9\u008dL\u0082\u00b3 for(d=0;d<2;d++){//\u008c\u00bb\u008d\u00dd\u0088\u00ca\u0092ux\u0082\u00f0\u0089\u009d\u0095\u009c\u0082\u00b3\u0082\u00b9\u0082\u00e9 for(xl=0;xl<W-range;xl++){//\u008d\u00b6\u0092[ for(dx=0;dx<=range;dx++){//x\u0095\u00cf\u0088\u00ca xr=xl+range; x=d?xr-dx:xl+dx; //printf(\"range=%d, d=%d, xl=%d, dx=%d, xr=%d, x=%d\\n\",range,d,xl,dx,xr,x); for(o=m;o>0;o--){ if(f=DP[y][x][xl][xr][o]){ if(x>0){ if(x==xl){//\u008d\u00b6\u0082\u00d6\u008c@\u0082\u00e9  on=CalcO(o-1,x+1,y);  } }//o }//dx }//xl }//d }//range }//y #if 0 for(y=0;y<H;y++){ for(x=0;x<W;x++){ for(o=m;o>0;o--){ if(f=DP[y][x][x][x][o]){ printf(\"%4d \",f-1); break; } } if(o==0) printf(\"---- \"); } puts(\"\"); } #endif fn=0; for(x=0;x<W;x++){  exit(0); }"], "original_ll": -1.5926307439804077, "sampled_ll": -0.4563538134098053, "all_perturbed_sampled_ll": [-1.1882418394088745], "all_perturbed_original_ll": [-2.3136022090911865], "perturbed_sampled_ll": -1.1882418394088745, "perturbed_original_ll": -2.3136022090911865, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n   \n   \npublic class Main {\n\tstatic int INF = 2 << 28;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tint f = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint o = sc.nextInt();\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][][] memo = new int[h][w][m+1];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tArrays.fill(memo[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Data> queue = new PriorityQueue<Data>();\n\t\t\tfor(int i = 0; i < w; i++) {\n\t\t\t\tboolean[] tmp = new boolean[w];\n\t\t\t\tif(map[0][i] > 0) {\n\t\t\t\t\tqueue.add(new Data(0,i,0,Math.min(m, o - 1 + map[0][i]),tmp));\n\t\t\t\t}\n\t\t\t\telse  {\n\t\t\t\t\tqueue.add(new Data(0,i,-map[0][i],o - 1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans = -1;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tData tmp = queue.poll();\n\t\t\t\t\n\t\t\t\tif(tmp.o <= 0) continue;\n\t\t\t\ttmp.al[tmp.x] = true;\n\t\t\t\t\n\t\t\t\tif(tmp.y == h-1) {\n\t\t\t\t\tans = tmp.c;\n\t\t\t\t\tqueue.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(tmp.c >= memo[tmp.y][tmp.x][tmp.o]) continue;\n\t\t\t\tmemo[tmp.y][tmp.x][tmp.o] = tmp.c;\n\t\t\t\t\n\t\t\t\tif(tmp.x != w-1) {\n\t\t\t\t\tif(tmp.al[tmp.x+1]) {\n\t\t\t\t\t\t    queue.add(new Data(tmp.y,tmp.x+1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(map[tmp.y][tmp.x+1] > 0 && tmp.o != 1) {\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x+1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x+1]),Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(map[tmp.y][tmp.x+1] < 0){\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x+1,tmp.c - map[tmp.y][tmp.x+1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp.x != 0) {\n\t\t\t\t\tif(tmp.al[tmp.x-1]) {\n\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x-1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(map[tmp.y][tmp.x-1] > 0 && tmp.o != 1) {\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x-1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x-1]),Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(map[tmp.y][tmp.x-1] < 0){\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x-1,tmp.c - map[tmp.y][tmp.x-1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp.y != h-1) {\n\t\t\t\t\tif(map[tmp.y+1][tmp.x] > 0 && tmp.o != 1) {\n\t\t\t\t\t\tqueue.add(new Data(tmp.y+1,tmp.x,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y+1][tmp.x]),new boolean[w]));\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[tmp.y+1][tmp.x] < 0){\n\t\t\t\t\t\tqueue.add(new Data(tmp.y+1,tmp.x,tmp.c - map[tmp.y+1][tmp.x],tmp.o-1,new boolean[w]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(ans == -1 || ans >= f) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic class Data implements Comparable<Data> {\n\t\tint y;\n\t\tint x;\n\t\tint c;\n\t\tint o;\n\t\tboolean[] al;\n\t\t\n\t\tData(int y, int x, int c, int o, boolean[] al) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.c = c;\n\t\t\tthis.o = o;\n\t\t\tthis.al = al;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.c - o.c;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class State implements Comparable<State> {\n        int x, y, oxygen, cost;\n        \n        State(int x, int y, int oxygen, int cost) {\n            this.x = x;\n            this.y = y;\n            this.oxygen = oxygen;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            int W = Integer.parseInt(parts[0]);\n            int H = Integer.parseInt(parts[1]);\n            \n            if (W == 0 && H == 0) break;\n            \n            parts = br.readLine().trim().split(\"\\\\s+\");\n            int f = Integer.parseInt(parts[0]);\n            int m = Integer.parseInt(parts[1]);\n            int o = Integer.parseInt(parts[2]);\n            \n            int[][] grid = new int[H][W];\n            for (int j = 0; j < H; j++) {\n                parts = br.readLine().trim().split(\"\\\\s+\");\n                for (int i = 0; i < W; i++) {\n                    grid[j][i] = Integer.parseInt(parts[i]);\n                }\n            }\n            \n            int result = solve(W, H, f, m, o, grid);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n    }\n    \n    static int solve(int W, int H, int f, int m, int o, int[][] grid) {\n        int[][][] dist = new int[H][W][m + 1];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                Arrays.fill(dist[i][j], Integer.MAX_VALUE);\n            }\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        \n        // Start from any cell in the first row\n        for (int x = 0; x < W; x++) {\n            int cost = 0;\n            int oxygen = o;\n            \n            if (grid[0][x] < 0) {\n                cost = -grid[0][x];\n            } else {\n                oxygen = Math.min(m, oxygen + grid[0][x]);\n            }\n            \n            if (cost <= f && oxygen > 0) {\n                pq.offer(new State(x, 0, oxygen, cost));\n                dist[0][x][oxygen] = cost;\n            }\n        }\n        \n        int[] dx = {-1, 1, 0};\n        int[] dy = {0, 0, 1};\n        \n        int minCost = Integer.MAX_VALUE;\n        \n        while (!pq.isEmpty()) {\n            State curr = pq.poll();\n            \n            if (curr.y == H - 1) {\n                minCost = Math.min(minCost, curr.cost);\n                continue;\n            }\n            \n            if (curr.cost > dist[curr.y][curr.x][curr.oxygen]) {\n                continue;\n            }\n            \n            for (int d = 0; d < 3; d++) {\n                int nx = curr.x + dx[d];\n                int ny = curr.y + dy[d];\n                \n                if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n                \n                int newOxygen = curr.oxygen - 1;\n                if (newOxygen <= 0) continue;\n                \n                int newCost = curr.cost;\n                \n                if (grid[ny][nx] < 0) {\n                    newCost += -grid[ny][nx];\n                } else {\n                    newOxygen = Math.min(m, newOxygen + grid[ny][nx]);\n                }\n                \n                if (newCost > f) continue;\n                \n                if (newCost < dist[ny][nx][newOxygen]) {\n                    dist[ny][nx][newOxygen] = newCost;\n                    pq.offer(new State(nx, ny, newOxygen, newCost));\n                }\n            }\n        }\n        \n        return minCost == Integer.MAX_VALUE ? -1 : minCost;\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  Comparable<State> { int x, y, oxygen, cost; State(int x, int y, int oxygen, int cost) { this.x = x; this.y = y; this.oxygen = oxygen; this.cost = cost; } @Override public int compareTo(State other) { return Integer.compare(this.cost, other.cost); } } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line;  line.trim().split(\"\\\\s+\"); int W = Integer.parseInt(parts[0]); int H = Integer.parseInt(parts[1]); if (W == 0 && H == 0) break; parts = br.readLine().trim().split(\"\\\\s+\"); int f = Integer.parseInt(parts[0]); int m = Integer.parseInt(parts[1]); int o = Integer.parseInt(parts[2]);  j < H; j++) { parts = br.readLine().trim().split(\"\\\\s+\"); for (int i = 0; i <  = solve(W, H, f, m, o, grid); if (result == -1) { System.out.println(\"NA\"); }  int H, int f, int m, int o, int[][] grid) { int[][][] dist = new int[H][W][m + 1]; for (int i = 0; i < H; i++) { for (int j = 0; j < W; j++) { Arrays.fill(dist[i][j], Integer.MAX_VALUE); } } PriorityQueue<State> pq = new PriorityQueue<>(); // Start from any cell in the first row for (int x = 0; x < W;  if (grid[0][x] < 0) { cost = -grid[0][x]; } else { oxygen = Math.min(m, oxygen + grid[0][x]); } if (cost <= f && oxygen > 0) { pq.offer(new State(x, 0, oxygen, cost)); dist[0][x][oxygen] = cost; } } int[] dx = {-1, 1, 0};  while (!pq.isEmpty()) { State curr = pq.poll(); if (curr.y == H - 1) { minCost = Math.min(minCost, curr.cost); continue; } if (curr.cost >  dx[d]; int ny = curr.y  || ny < 0 || ny >= H) continue; int newOxygen = curr.oxygen - 1; if (newOxygen  = Math.min(m, newOxygen + grid[ny][nx]); } if (newCost > f) continue; if (newCost < dist[ny][nx][newOxygen]) { dist[ny][nx][newOxygen] = newCost; pq.offer(new State(nx, ny, newOxygen, newCost)); } } } return minCost == Integer.MAX_VALUE ? -1 : minCost; } }"], "perturbed_original": ["import java.util.*; import java.math.*; import java.awt.geom.*; import java.io.*;  28; public static void main(String[] args) { Scanner sc =  break; int f = sc.nextInt(); int m = sc.nextInt(); int o = sc.nextInt(); int[][] map = new int[h][w]; for(int i =  j < w; j++) { map[i][j] = sc.nextInt(); } } int[][][] memo = new int[h][w][m+1]; for(int i = 0; i < h; i++) { for(int  } } PriorityQueue<Data> queue = new PriorityQueue<Data>(); for(int i  - 1,tmp)); } } int ans = -1; while(!queue.isEmpty()) { Data tmp = queue.poll(); if(tmp.o <= 0) continue; tmp.al[tmp.x] = true; if(tmp.y == h-1) { ans = tmp.c; queue.clear(); break; } if(tmp.c >= memo[tmp.y][tmp.x][tmp.o]) continue; memo[tmp.y][tmp.x][tmp.o] = tmp.c; if(tmp.x != w-1) { if(tmp.al[tmp.x+1]) { queue.add(new Data(tmp.y,tmp.x+1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length))); } else { if(map[tmp.y][tmp.x+1] > 0 && tmp.o != 1) { queue.add(new Data(tmp.y,tmp.x+1,tmp.c,Math.min(m, tmp.o -  - map[tmp.y][tmp.x+1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length))); } } } if(tmp.x != 0) { if(tmp.al[tmp.x-1]) { queue.add(new Data(tmp.y,tmp.x-1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length))); } else { if(map[tmp.y][tmp.x-1] > 0 && tmp.o != 1) { queue.add(new Data(tmp.y,tmp.x-1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x-1]),Arrays.copyOf(tmp.al,tmp.al.length))); } else if(map[tmp.y][tmp.x-1] < 0){ queue.add(new Data(tmp.y,tmp.x-1,tmp.c - map[tmp.y][tmp.x-1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length))); } } } if(tmp.y != h-1) { if(map[tmp.y+1][tmp.x] > 0 && tmp.o != 1) { queue.add(new Data(tmp.y+1,tmp.x,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y+1][tmp.x]),new boolean[w])); } else if(map[tmp.y+1][tmp.x] < 0){ queue.add(new Data(tmp.y+1,tmp.x,tmp.c -  >= f) { System.out.println(\"NA\"); } else { System.out.println(ans); } } } static class Data implements Comparable<Data> { int y; int x; int c; int o; boolean[] al; Data(int y, int x,  this.x = x; this.c = c; this.o = o; this.al = al; } @Override public int compareTo(Data o) { return this.c - o.c; } } }"], "original_ll": -0.5341481566429138, "sampled_ll": -0.4243590831756592, "all_perturbed_sampled_ll": [-1.1439067125320435], "all_perturbed_original_ll": [-1.0059716701507568], "perturbed_sampled_ll": -1.1439067125320435, "perturbed_original_ll": -1.0059716701507568, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "INF = 10 ** 20\n\ndef update_state(state, newx):\n  tmp = list(state)\n  tmp[newx] = 1\n  return tuple(tmp)\n\ndef get_co(x, y):\n  dc = do = 0\n  score = mp[y][x]\n  if score < 0:\n    dc = -score\n  else:\n    do = score\n  return dc, do\n\ndef minimum_cost(nowx, nowy, state, ox, goal, dic, w, m):\n  if (nowx, nowy, state, ox) in dic:\n    return dic[(nowx, nowy, state, ox)]\n  if nowy == goal:\n    return 0\n  if ox <= 1:\n    return INF\n  \n  ret = INF\n  \n  left = right = None\n  for i in range(nowx + 1, w):\n    if state[i] == 0:\n      right = i\n      break\n\n  for i in range(nowx - 1, -1, -1):\n    if state[i] == 0:\n      left = i\n      break\n\n  if left != None:\n    dc, do = get_co(left, nowy)\n    ret = min(ret, minimum_cost(left, nowy, update_state(state, left), min(ox + do - 1, m), goal, dic, w, m) + dc)\n    for i in range(left + 1, nowx):\n      ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic, w, m))\n  \n  if right != None:\n    dc, do = get_co(right, nowy)\n    ret = min(ret, minimum_cost(right, nowy, update_state(state, right), min(ox + do - 1, m), goal, dic, w, m) + dc)\n    for i in range(nowx + 1, right):\n      ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic, w, m))\n  \n  dc, do = get_co(nowx, nowy + 1)\n  ret = min(ret, minimum_cost(nowx, nowy + 1, tuple((1 if i == nowx else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m) + dc)\n  dic[(nowx, nowy, state, ox)] = ret\n  return ret\n\nwhile True:\n  w, h = map(int, input().split())\n  if w == 0:\n    break\n  f, m, o = map(int, input().split())\n  if o <= 1:\n    print(\"NA\")\n    continue\n  mp = [list(map(int, input().split())) for _ in range(h)]\n  dic = {}\n  ans = INF\n  for i in range(w):\n    dc, do = get_co(i, 0)\n    ans = min(ans, minimum_cost(i, 0, tuple(1 if i == j else 0 for j in range(w)), min(o + do - 1, m), h - 1, dic, w, m) + dc)\n  if ans > f:\n    print(\"NA\")\n  else:\n    print(ans)\n", "sampled": "import heapq\nfrom collections import defaultdict\n\ndef solve(W, H, f, m, o, grid):\n    # State: (x, y, oxygen, used_oxygen_cells)\n    # used_oxygen_cells is a frozenset of (x, y) tuples\n    \n    # Priority queue: (cost, x, y, oxygen, used_oxygen_cells)\n    pq = []\n    \n    # Start from any cell in the first row (y=0)\n    for x in range(W):\n        cell_value = grid[0][x]\n        if cell_value < 0:  #\u571f\n            cost = -cell_value\n            new_oxygen = o - 1\n            if new_oxygen >= 0 and cost <= f:\n                heapq.heappush(pq, (cost, x, 0, new_oxygen, frozenset()))\n        else:  # \u9178\u7d20\n            new_oxygen = min(m, o + cell_value) - 1\n            if new_oxygen >= 0:\n                heapq.heappush(pq, (0, x, 0, new_oxygen, frozenset([(x, 0)])))\n    \n    # Best cost for each state (x, y, oxygen, used_oxygen_cells)\n    visited = {}\n    \n    while pq:\n        cost, x, y, oxygen, used = heapq.heappop(pq)\n        \n        # Check if we reached the bottom\n        if y == H - 1 and oxygen > 0:\n            return cost\n        \n        # Skip if we've seen this state with better or equal cost\n        state = (x, y, oxygen, used)\n        if state in visited:\n            continue\n        visited[state] = cost\n        \n        # Try moving to adjacent cells: left, right, down\n        directions = []\n        if x > 0:\n            directions.append((x - 1, y))\n        if x < W - 1:\n            directions.append((x + 1, y))\n        if y < H - 1:\n            directions.append((x, y + 1))\n        \n        for nx, ny in directions:\n            cell_value = grid[ny][nx]\n            \n            if cell_value < 0:  # \u571f\n                dig_cost = -cell_value\n                new_cost = cost + dig_cost\n                new_oxygen = oxygen - 1\n                \n                if new_oxygen >= 0 and new_cost <= f:\n                    new_state = (nx, ny, new_oxygen, used)\n                    if new_state not in visited:\n                        heapq.heappush(pq, (new_cost, nx, ny, new_oxygen, used))\n            else:  # \u9178\u7d20\n                if (nx, ny) in used:\n                    # Already used this oxygen cell\n                    new_oxygen = oxygen - 1\n                    if new_oxygen >= 0:\n                        new_state = (nx, ny, new_oxygen, used)\n                        if new_state not in visited:\n                            heapq.heappush(pq, (cost, nx, ny, new_oxygen, used))\n                else:\n                    # Use oxygen from this cell\n                    new_oxygen = min(m, oxygen + cell_value) - 1\n                    if new_oxygen >= 0:\n                        new_used = used | frozenset([(nx, ny)])\n                        new_state = (nx, ny, new_oxygen, new_used)\n                        if new_state not in visited:\n                            heapq.heappush(pq, (cost, nx, ny, new_oxygen, new_used))\n    \n    return None\n\nwhile True:\n    line = input().split()\n    W, H = int(line[0]), int(line[1])\n    if W == 0 and H == 0:\n        break\n    \n    line = input().split()\n    f, m, o = int(line[0]), int(line[1]), int(line[2])\n    \n    grid = []\n    for _ in range(H):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    result = solve(W, H, f, m, o, grid)\n    if result is None:\n        print(\"NA\")\n    else:\n        print(result)\n", "perturbed_sampled": [" m, o, grid): # State: (x, y, oxygen, used_oxygen_cells) # used_oxygen_cells is a frozenset of (x, y) tuples # Priority queue: (cost, x, y, oxygen, used_oxygen_cells) pq = [] # Start from any cell in the first  cell_value < 0: #\u571f cost = -cell_value new_oxygen = o - 1 if new_oxygen >= 0 and cost <= f: heapq.heappush(pq, (cost, x, 0, new_oxygen, frozenset())) else: # \u9178\u7d20 new_oxygen = min(m, o + cell_value) - 1 if new_oxygen >= 0: heapq.heappush(pq, (0, x, 0, new_oxygen, frozenset([(x, 0)]))) # Best cost for each  cost, x, y, oxygen, used = heapq.heappop(pq) # Check if we reached the bottom if y == H - 1 and oxygen > 0: return cost # Skip if we've seen this state with better or equal cost state = (x, y, oxygen, used) if state in visited: continue visited[state] = cost # Try  if x > 0: directions.append((x  + 1, y)) if y < H - 1:  = -cell_value new_cost = cost + dig_cost new_oxygen = oxygen - 1 if new_oxygen >= 0 and new_cost <= f: new_state = (nx, ny, new_oxygen, used) if new_state not in visited:  (nx, ny) in used: # Already used this oxygen cell new_oxygen = oxygen - 1 if new_oxygen >= 0: new_state = (nx, ny, new_oxygen, used) if new_state not in visited: heapq.heappush(pq, (cost, nx, ny,  = min(m, oxygen + cell_value) -  not in visited: heapq.heappush(pq, (cost, nx, ny, new_oxygen, new_used)) return None while True: line = input().split() W, H  0: break line = input().split() f, m, o = int(line[0]), int(line[1]), int(line[2]) grid = [] for _ in range(H): row = list(map(int, input().split())) grid.append(row) result = solve(W, H, f, m, o, grid) if result is None: print(\"NA\") else: print(result)"], "perturbed_original": ["INF = 10 ** 20 def update_state(state, newx): tmp = list(state) tmp[newx] = 1 return tuple(tmp) def get_co(x, y): dc = do = 0 score  do = score return dc, do def minimum_cost(nowx, nowy, state, ox, goal, dic, w, m): if (nowx, nowy, state, ox) in dic: return dic[(nowx, nowy, state, ox)] if nowy == goal: return 0 if ox <= 1: return INF ret = INF left = right = None for i in  i break for i in range(nowx  i break if left != None: dc, do = get_co(left, nowy) ret = min(ret, minimum_cost(left,  + 1, nowx): ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic,  nowy) ret = min(ret, minimum_cost(right, nowy, update_state(state, right), min(ox + do - 1, m), goal, dic, w, m) + dc) for i in range(nowx + 1, right): ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic, w, m)) dc, do = get_co(nowx, nowy + 1) ret = min(ret, minimum_cost(nowx, nowy + 1, tuple((1 if i == nowx else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m) + dc) dic[(nowx, nowy, state, ox)] =  if w  o <= 1: print(\"NA\") continue mp = [list(map(int, input().split())) for _ in range(h)] dic = {} ans = INF  = min(ans, minimum_cost(i, 0, tuple(1 if i  do - 1, m), h - 1, dic, w, m) + dc) if ans > f: print(\"NA\") else: print(ans)"], "original_ll": -0.8410813808441162, "sampled_ll": -0.740057647228241, "all_perturbed_sampled_ll": [-1.6864607334136963], "all_perturbed_original_ll": [-1.8243319988250732], "perturbed_sampled_ll": -1.6864607334136963, "perturbed_original_ll": -1.8243319988250732, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}], "metrics": {"roc_auc": 0.7242055555555555, "fpr": [0.0, 0.0, 0.0, 0.0033333333333333335, 0.0033333333333333335, 0.005, 0.005, 0.006666666666666667, 0.006666666666666667, 0.01, 0.01, 0.011666666666666667, 0.011666666666666667, 0.013333333333333334, 0.013333333333333334, 0.015, 0.015, 0.021666666666666667, 0.021666666666666667, 0.023333333333333334, 0.023333333333333334, 0.02666666666666667, 0.02666666666666667, 0.028333333333333332, 0.028333333333333332, 0.03, 0.03, 0.03166666666666667, 0.03166666666666667, 0.03333333333333333, 0.03333333333333333, 0.03833333333333333, 0.03833333333333333, 0.04, 0.04, 0.041666666666666664, 0.041666666666666664, 0.043333333333333335, 0.043333333333333335, 0.045, 0.045, 0.04666666666666667, 0.04666666666666667, 0.04833333333333333, 0.04833333333333333, 0.05, 0.05, 0.051666666666666666, 0.051666666666666666, 0.05333333333333334, 0.05333333333333334, 0.055, 0.055, 0.056666666666666664, 0.056666666666666664, 0.058333333333333334, 0.058333333333333334, 0.06, 0.06, 0.06333333333333334, 0.06333333333333334, 0.065, 0.065, 0.06666666666666667, 0.06666666666666667, 0.07166666666666667, 0.07166666666666667, 0.075, 0.075, 0.07666666666666666, 0.07666666666666666, 0.07833333333333334, 0.07833333333333334, 0.08166666666666667, 0.08166666666666667, 0.08333333333333333, 0.08333333333333333, 0.085, 0.085, 0.08833333333333333, 0.08833333333333333, 0.09, 0.09, 0.09166666666666666, 0.09166666666666666, 0.09333333333333334, 0.09333333333333334, 0.09666666666666666, 0.09666666666666666, 0.09833333333333333, 0.09833333333333333, 0.10166666666666667, 0.10166666666666667, 0.105, 0.105, 0.10666666666666667, 0.10666666666666667, 0.10833333333333334, 0.10833333333333334, 0.11, 0.11, 0.115, 0.115, 0.11666666666666667, 0.11666666666666667, 0.11833333333333333, 0.11833333333333333, 0.12, 0.12, 0.12166666666666667, 0.12166666666666667, 0.125, 0.125, 0.13, 0.13, 0.13333333333333333, 0.13333333333333333, 0.14, 0.14, 0.14166666666666666, 0.14166666666666666, 0.145, 0.145, 0.14833333333333334, 0.14833333333333334, 0.15, 0.15, 0.15333333333333332, 0.15333333333333332, 0.16, 0.16, 0.16166666666666665, 0.16166666666666665, 0.165, 0.165, 0.16666666666666666, 0.16666666666666666, 0.16833333333333333, 0.16833333333333333, 0.17166666666666666, 0.17166666666666666, 0.175, 0.175, 0.17666666666666667, 0.17666666666666667, 0.18, 0.18, 0.18333333333333332, 0.18333333333333332, 0.18666666666666668, 0.18666666666666668, 0.18833333333333332, 0.18833333333333332, 0.19, 0.19, 0.19333333333333333, 0.19333333333333333, 0.2, 0.2, 0.20166666666666666, 0.20166666666666666, 0.20333333333333334, 0.20333333333333334, 0.205, 0.205, 0.20666666666666667, 0.20666666666666667, 0.20833333333333334, 0.20833333333333334, 0.21, 0.21, 0.21166666666666667, 0.21166666666666667, 0.21333333333333335, 0.21333333333333335, 0.215, 0.215, 0.21833333333333332, 0.21833333333333332, 0.22166666666666668, 0.22166666666666668, 0.22333333333333333, 0.22333333333333333, 0.225, 0.225, 0.22666666666666666, 0.22666666666666666, 0.23166666666666666, 0.23166666666666666, 0.23833333333333334, 0.23833333333333334, 0.24, 0.24, 0.245, 0.245, 0.24666666666666667, 0.24666666666666667, 0.24833333333333332, 0.24833333333333332, 0.25166666666666665, 0.25166666666666665, 0.255, 0.255, 0.25666666666666665, 0.25666666666666665, 0.2633333333333333, 0.2633333333333333, 0.265, 0.265, 0.26666666666666666, 0.26666666666666666, 0.2733333333333333, 0.2733333333333333, 0.2783333333333333, 0.2783333333333333, 0.28, 0.28, 0.2816666666666667, 0.2816666666666667, 0.285, 0.285, 0.2866666666666667, 0.2866666666666667, 0.29333333333333333, 0.29333333333333333, 0.295, 0.295, 0.2966666666666667, 0.2966666666666667, 0.3016666666666667, 0.3016666666666667, 0.30333333333333334, 0.30333333333333334, 0.305, 0.305, 0.30666666666666664, 0.30666666666666664, 0.30833333333333335, 0.30833333333333335, 0.31, 0.31, 0.31166666666666665, 0.31166666666666665, 0.31333333333333335, 0.31333333333333335, 0.31833333333333336, 0.31833333333333336, 0.32, 0.32, 0.3233333333333333, 0.3233333333333333, 0.325, 0.325, 0.32666666666666666, 0.32666666666666666, 0.3283333333333333, 0.3283333333333333, 0.33, 0.33, 0.33166666666666667, 0.33166666666666667, 0.3333333333333333, 0.3333333333333333, 0.335, 0.335, 0.33666666666666667, 0.33666666666666667, 0.3433333333333333, 0.3433333333333333, 0.345, 0.345, 0.3466666666666667, 0.3466666666666667, 0.35, 0.35, 0.355, 0.355, 0.3566666666666667, 0.3566666666666667, 0.35833333333333334, 0.35833333333333334, 0.3616666666666667, 0.3616666666666667, 0.36333333333333334, 0.36333333333333334, 0.36666666666666664, 0.36666666666666664, 0.36833333333333335, 0.36833333333333335, 0.37166666666666665, 0.37166666666666665, 0.37333333333333335, 0.37333333333333335, 0.37666666666666665, 0.37666666666666665, 0.385, 0.385, 0.3883333333333333, 0.3883333333333333, 0.3933333333333333, 0.3933333333333333, 0.395, 0.395, 0.4, 0.4, 0.405, 0.405, 0.41333333333333333, 0.41333333333333333, 0.415, 0.415, 0.42, 0.42, 0.4216666666666667, 0.4216666666666667, 0.425, 0.425, 0.4266666666666667, 0.4266666666666667, 0.42833333333333334, 0.42833333333333334, 0.43, 0.43, 0.43166666666666664, 0.43166666666666664, 0.43333333333333335, 0.43333333333333335, 0.43833333333333335, 0.43833333333333335, 0.44666666666666666, 0.44666666666666666, 0.4483333333333333, 0.4483333333333333, 0.45, 0.45, 0.455, 0.455, 0.45666666666666667, 0.45666666666666667, 0.4583333333333333, 0.4583333333333333, 0.46, 0.46, 0.465, 0.465, 0.4683333333333333, 0.4683333333333333, 0.47333333333333333, 0.47333333333333333, 0.4766666666666667, 0.4766666666666667, 0.47833333333333333, 0.47833333333333333, 0.4866666666666667, 0.4866666666666667, 0.48833333333333334, 0.48833333333333334, 0.49, 0.49, 0.495, 0.495, 0.5, 0.5, 0.505, 0.505, 0.5066666666666667, 0.5066666666666667, 0.51, 0.51, 0.515, 0.515, 0.5166666666666667, 0.5166666666666667, 0.5183333333333333, 0.5183333333333333, 0.5233333333333333, 0.5233333333333333, 0.5266666666666666, 0.5266666666666666, 0.5283333333333333, 0.5283333333333333, 0.53, 0.53, 0.5316666666666666, 0.5316666666666666, 0.5333333333333333, 0.5333333333333333, 0.535, 0.535, 0.54, 0.54, 0.5483333333333333, 0.5483333333333333, 0.5533333333333333, 0.5533333333333333, 0.5583333333333333, 0.5583333333333333, 0.5616666666666666, 0.5616666666666666, 0.5666666666666667, 0.5666666666666667, 0.57, 0.57, 0.5716666666666667, 0.5716666666666667, 0.5733333333333334, 0.5733333333333334, 0.5783333333333334, 0.5783333333333334, 0.5816666666666667, 0.5816666666666667, 0.5866666666666667, 0.5866666666666667, 0.5883333333333334, 0.5883333333333334, 0.5933333333333334, 0.5933333333333334, 0.595, 0.595, 0.5983333333333334, 0.5983333333333334, 0.6, 0.6, 0.605, 0.605, 0.6066666666666667, 0.6066666666666667, 0.6116666666666667, 0.6116666666666667, 0.6133333333333333, 0.6133333333333333, 0.615, 0.615, 0.635, 0.635, 0.645, 0.645, 0.6466666666666666, 0.6466666666666666, 0.65, 0.65, 0.6533333333333333, 0.6533333333333333, 0.6583333333333333, 0.6583333333333333, 0.66, 0.66, 0.6633333333333333, 0.6633333333333333, 0.6716666666666666, 0.6716666666666666, 0.7, 0.7, 0.7016666666666667, 0.7016666666666667, 0.7083333333333334, 0.7083333333333334, 0.72, 0.72, 0.7216666666666667, 0.7216666666666667, 0.735, 0.735, 0.7366666666666667, 0.7366666666666667, 0.7466666666666667, 0.7466666666666667, 0.755, 0.755, 0.7683333333333333, 0.7683333333333333, 0.7733333333333333, 0.7733333333333333, 0.775, 0.775, 0.7833333333333333, 0.7833333333333333, 0.7916666666666666, 0.7916666666666666, 0.81, 0.81, 0.815, 0.815, 0.825, 0.825, 0.8333333333333334, 0.8333333333333334, 0.835, 0.835, 0.845, 0.845, 0.8616666666666667, 0.8616666666666667, 0.9533333333333334, 0.9933333333333333, 0.9966666666666667, 0.9966666666666667, 1.0], "tpr": [0.0, 0.0016666666666666668, 0.01, 0.01, 0.011666666666666667, 0.011666666666666667, 0.045, 0.045, 0.04833333333333333, 0.04833333333333333, 0.058333333333333334, 0.058333333333333334, 0.06166666666666667, 0.06166666666666667, 0.06333333333333334, 0.06333333333333334, 0.06666666666666667, 0.06666666666666667, 0.08, 0.08, 0.08666666666666667, 0.08666666666666667, 0.09, 0.09, 0.09333333333333334, 0.09333333333333334, 0.09666666666666666, 0.09666666666666666, 0.105, 0.105, 0.10666666666666667, 0.10666666666666667, 0.11166666666666666, 0.11166666666666666, 0.12166666666666667, 0.12166666666666667, 0.12333333333333334, 0.12333333333333334, 0.13166666666666665, 0.13166666666666665, 0.13666666666666666, 0.13666666666666666, 0.14, 0.14, 0.14166666666666666, 0.14166666666666666, 0.14333333333333334, 0.14333333333333334, 0.15, 0.15, 0.16, 0.16, 0.16666666666666666, 0.16666666666666666, 0.17, 0.17, 0.17333333333333334, 0.17333333333333334, 0.18, 0.18, 0.18666666666666668, 0.18666666666666668, 0.19333333333333333, 0.19333333333333333, 0.195, 0.195, 0.2, 0.2, 0.21166666666666667, 0.21166666666666667, 0.215, 0.215, 0.22, 0.22, 0.22833333333333333, 0.22833333333333333, 0.23166666666666666, 0.23166666666666666, 0.23666666666666666, 0.23666666666666666, 0.245, 0.245, 0.25166666666666665, 0.25166666666666665, 0.255, 0.255, 0.25833333333333336, 0.25833333333333336, 0.26, 0.26, 0.26166666666666666, 0.26166666666666666, 0.27, 0.27, 0.27166666666666667, 0.27166666666666667, 0.27666666666666667, 0.27666666666666667, 0.2783333333333333, 0.2783333333333333, 0.2833333333333333, 0.2833333333333333, 0.2866666666666667, 0.2866666666666667, 0.2916666666666667, 0.2916666666666667, 0.2966666666666667, 0.2966666666666667, 0.3016666666666667, 0.3016666666666667, 0.31, 0.31, 0.31166666666666665, 0.31166666666666665, 0.325, 0.325, 0.3283333333333333, 0.3283333333333333, 0.33166666666666667, 0.33166666666666667, 0.335, 0.335, 0.3383333333333333, 0.3383333333333333, 0.3416666666666667, 0.3416666666666667, 0.345, 0.345, 0.35, 0.35, 0.3516666666666667, 0.3516666666666667, 0.355, 0.355, 0.3566666666666667, 0.3566666666666667, 0.35833333333333334, 0.35833333333333334, 0.36, 0.36, 0.365, 0.365, 0.36833333333333335, 0.36833333333333335, 0.37333333333333335, 0.37333333333333335, 0.37666666666666665, 0.37666666666666665, 0.37833333333333335, 0.37833333333333335, 0.405, 0.405, 0.4083333333333333, 0.4083333333333333, 0.41333333333333333, 0.41333333333333333, 0.41833333333333333, 0.41833333333333333, 0.42833333333333334, 0.42833333333333334, 0.43, 0.43, 0.44166666666666665, 0.44166666666666665, 0.44333333333333336, 0.44333333333333336, 0.4533333333333333, 0.4533333333333333, 0.455, 0.455, 0.45666666666666667, 0.45666666666666667, 0.47, 0.47, 0.48333333333333334, 0.48333333333333334, 0.485, 0.485, 0.4866666666666667, 0.4866666666666667, 0.48833333333333334, 0.48833333333333334, 0.49333333333333335, 0.49333333333333335, 0.495, 0.495, 0.5, 0.5, 0.5033333333333333, 0.5033333333333333, 0.505, 0.505, 0.5066666666666667, 0.5066666666666667, 0.5083333333333333, 0.5083333333333333, 0.51, 0.51, 0.52, 0.52, 0.5366666666666666, 0.5366666666666666, 0.54, 0.54, 0.5416666666666666, 0.5416666666666666, 0.545, 0.545, 0.5466666666666666, 0.5466666666666666, 0.5533333333333333, 0.5533333333333333, 0.555, 0.555, 0.56, 0.56, 0.5616666666666666, 0.5616666666666666, 0.5666666666666667, 0.5666666666666667, 0.5766666666666667, 0.5766666666666667, 0.5816666666666667, 0.5816666666666667, 0.5833333333333334, 0.5833333333333334, 0.585, 0.585, 0.5866666666666667, 0.5866666666666667, 0.59, 0.59, 0.5916666666666667, 0.5916666666666667, 0.5933333333333334, 0.5933333333333334, 0.6033333333333334, 0.6033333333333334, 0.605, 0.605, 0.6066666666666667, 0.6066666666666667, 0.6083333333333333, 0.6083333333333333, 0.6116666666666667, 0.6116666666666667, 0.6166666666666667, 0.6166666666666667, 0.6183333333333333, 0.6183333333333333, 0.62, 0.62, 0.6266666666666667, 0.6266666666666667, 0.6283333333333333, 0.6283333333333333, 0.63, 0.63, 0.64, 0.64, 0.6416666666666667, 0.6416666666666667, 0.645, 0.645, 0.6483333333333333, 0.6483333333333333, 0.6516666666666666, 0.6516666666666666, 0.6533333333333333, 0.6533333333333333, 0.6583333333333333, 0.6583333333333333, 0.66, 0.66, 0.665, 0.665, 0.6666666666666666, 0.6666666666666666, 0.6683333333333333, 0.6683333333333333, 0.67, 0.67, 0.6733333333333333, 0.6733333333333333, 0.675, 0.675, 0.68, 0.68, 0.6833333333333333, 0.6833333333333333, 0.6966666666666667, 0.6966666666666667, 0.7, 0.7, 0.7066666666666667, 0.7066666666666667, 0.715, 0.715, 0.7183333333333334, 0.7183333333333334, 0.72, 0.72, 0.725, 0.725, 0.73, 0.73, 0.7333333333333333, 0.7333333333333333, 0.7433333333333333, 0.7433333333333333, 0.745, 0.745, 0.75, 0.75, 0.7533333333333333, 0.7533333333333333, 0.7566666666666667, 0.7566666666666667, 0.7583333333333333, 0.7583333333333333, 0.76, 0.76, 0.7616666666666667, 0.7616666666666667, 0.7633333333333333, 0.7633333333333333, 0.7666666666666667, 0.7666666666666667, 0.7716666666666666, 0.7716666666666666, 0.7733333333333333, 0.7733333333333333, 0.7816666666666666, 0.7816666666666666, 0.785, 0.785, 0.79, 0.79, 0.7916666666666666, 0.7916666666666666, 0.7933333333333333, 0.7933333333333333, 0.8, 0.8, 0.8016666666666666, 0.8016666666666666, 0.8066666666666666, 0.8066666666666666, 0.81, 0.81, 0.815, 0.815, 0.82, 0.82, 0.825, 0.825, 0.8266666666666667, 0.8266666666666667, 0.8333333333333334, 0.8333333333333334, 0.8366666666666667, 0.8366666666666667, 0.8383333333333334, 0.8383333333333334, 0.8416666666666667, 0.8416666666666667, 0.8433333333333334, 0.8433333333333334, 0.845, 0.845, 0.8516666666666667, 0.8516666666666667, 0.8633333333333333, 0.8633333333333333, 0.8666666666666667, 0.8666666666666667, 0.8683333333333333, 0.8683333333333333, 0.87, 0.87, 0.8733333333333333, 0.8733333333333333, 0.875, 0.875, 0.8766666666666667, 0.8766666666666667, 0.8783333333333333, 0.8783333333333333, 0.88, 0.88, 0.885, 0.885, 0.8883333333333333, 0.8883333333333333, 0.89, 0.89, 0.8933333333333333, 0.8933333333333333, 0.895, 0.895, 0.8966666666666666, 0.8966666666666666, 0.8983333333333333, 0.8983333333333333, 0.9033333333333333, 0.9033333333333333, 0.905, 0.905, 0.91, 0.91, 0.9116666666666666, 0.9116666666666666, 0.915, 0.915, 0.9166666666666666, 0.9166666666666666, 0.92, 0.92, 0.9233333333333333, 0.9233333333333333, 0.925, 0.925, 0.9266666666666666, 0.9266666666666666, 0.9283333333333333, 0.9283333333333333, 0.93, 0.93, 0.9316666666666666, 0.9316666666666666, 0.9333333333333333, 0.9333333333333333, 0.935, 0.935, 0.9366666666666666, 0.9366666666666666, 0.9383333333333334, 0.9383333333333334, 0.94, 0.94, 0.9416666666666667, 0.9416666666666667, 0.9433333333333334, 0.9433333333333334, 0.945, 0.945, 0.9483333333333334, 0.9483333333333334, 0.95, 0.95, 0.9533333333333334, 0.9533333333333334, 0.955, 0.955, 0.96, 0.96, 0.9633333333333334, 0.9633333333333334, 0.965, 0.965, 0.9666666666666667, 0.9666666666666667, 0.9683333333333334, 0.9683333333333334, 0.97, 0.97, 0.9716666666666667, 0.9716666666666667, 0.9733333333333334, 0.9733333333333334, 0.975, 0.975, 0.9766666666666667, 0.9766666666666667, 0.9783333333333334, 0.9783333333333334, 0.98, 0.98, 0.9816666666666667, 0.9816666666666667, 0.985, 0.985, 0.9866666666666667, 0.9866666666666667, 0.99, 0.99, 0.9916666666666667, 0.9916666666666667, 0.9933333333333333, 0.9933333333333333, 0.995, 0.995, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 1.0, 1.0]}, "pr_metrics": {"pr_auc": 0.6851708444364168, "precision": [0.5, 0.5004170141784821, 0.5008347245409015, 0.5004177109440268, 0.5008361204013378, 0.501255230125523, 0.511528608027327, 0.5119658119658119, 0.5124037639007699, 0.5128424657534246, 0.5132819194515853, 0.5137221269296741, 0.5141630901287554, 0.5146048109965635, 0.5150472914875323, 0.5154905335628227, 0.5159345391903531, 0.5163793103448275, 0.5168248490077653, 0.5172711571675302, 0.5177182368193605, 0.5181660899653979, 0.5186147186147186, 0.5190641247833622, 0.5195143104943626, 0.5199652777777778, 0.5204170286707211, 0.5208695652173913, 0.5213228894691035, 0.5217770034843205, 0.5222319093286836, 0.5226876090750436, 0.5231441048034935, 0.5236013986013986, 0.5240594925634295, 0.5245183887915937, 0.5249780893952674, 0.525438596491228, 0.5258999122036875, 0.5263620386643234, 0.5268249780123131, 0.5272887323943662, 0.5277533039647577, 0.5282186948853616, 0.5286849073256841, 0.5291519434628975, 0.5296198054818745, 0.5300884955752212, 0.5305580159433126, 0.5310283687943262, 0.5314995563442768, 0.5319715808170515, 0.5324444444444445, 0.5329181494661922, 0.5333926981300089, 0.533868092691622, 0.5343443354148082, 0.5348214285714286, 0.5352993744414656, 0.535778175313059, 0.5362578334825425, 0.5367383512544803, 0.536322869955157, 0.5359066427289049, 0.5363881401617251, 0.5368705035971223, 0.5373537353735374, 0.5378378378378378, 0.5383228133453561, 0.5388086642599278, 0.5392953929539296, 0.5397830018083183, 0.5402714932126697, 0.5407608695652174, 0.5403445149592022, 0.5408348457350273, 0.5413260672116258, 0.5418181818181819, 0.5423111919927207, 0.5428051001821493, 0.5432999088422972, 0.5428832116788321, 0.54337899543379, 0.5429616087751371, 0.5434583714547118, 0.5439560439560439, 0.5444546287809349, 0.544954128440367, 0.5454545454545454, 0.5450367647058824, 0.5446182152713891, 0.5451197053406999, 0.5456221198156682, 0.5461254612546126, 0.5466297322253001, 0.5471349353049908, 0.547641073080481, 0.5472222222222223, 0.5477293790546802, 0.5482374768089053, 0.5487465181058496, 0.5483271375464684, 0.5479069767441861, 0.5484171322160148, 0.548928238583411, 0.5494402985074627, 0.5499533146591971, 0.5504672897196262, 0.5509822263797942, 0.5514981273408239, 0.5520149953139644, 0.5525328330206379, 0.5530516431924882, 0.5535714285714286, 0.5531514581373471, 0.5536723163841808, 0.5541941564561734, 0.5547169811320755, 0.5552407932011332, 0.555765595463138, 0.5553453169347209, 0.5558712121212122, 0.5563981042654028, 0.5569259962049335, 0.5574548907882241, 0.5579847908745247, 0.5575642245480494, 0.5580952380952381, 0.55767397521449, 0.558206106870229, 0.5587392550143266, 0.5592734225621415, 0.5588516746411484, 0.5593869731800766, 0.5599232981783318, 0.5604606525911708, 0.5609990393852066, 0.5615384615384615, 0.5620789220404235, 0.5626204238921002, 0.5631629701060752, 0.5627413127413128, 0.5632850241545894, 0.5638297872340425, 0.5643756050338818, 0.564922480620155, 0.565470417070805, 0.5650485436893203, 0.565597667638484, 0.566147859922179, 0.5666991236611489, 0.5672514619883041, 0.5678048780487804, 0.568359375, 0.5679374389051809, 0.5684931506849316, 0.5680705190989226, 0.5686274509803921, 0.5691854759568205, 0.5697445972495089, 0.5703048180924287, 0.5708661417322834, 0.5714285714285714, 0.571992110453649, 0.5725567620927937, 0.5721343873517787, 0.5727002967359051, 0.5722772277227722, 0.5728444003964321, 0.5734126984126984, 0.573982125124131, 0.5745526838966203, 0.5751243781094527, 0.5756972111553785, 0.576271186440678, 0.5758483033932136, 0.5754245754245755, 0.576, 0.5765765765765766, 0.5771543086172345, 0.5777331995987964, 0.5773092369477911, 0.5768844221105528, 0.5764587525150905, 0.5770392749244713, 0.5766129032258065, 0.5771947527749748, 0.5777777777777777, 0.5783619817997978, 0.5789473684210527, 0.5795339412360689, 0.5801217038539553, 0.5807106598984771, 0.5813008130081301, 0.5818921668362157, 0.5824847250509165, 0.583078491335372, 0.5836734693877551, 0.5842696629213483, 0.5848670756646217, 0.5854657113613101, 0.5860655737704918, 0.5866666666666667, 0.5862422997946611, 0.5858170606372045, 0.5864197530864198, 0.5870236869207003, 0.5876288659793815, 0.5882352941176471, 0.5888429752066116, 0.5884177869700103, 0.5890269151138716, 0.5896373056994819, 0.5892116182572614, 0.5887850467289719, 0.5893970893970893, 0.5889698231009365, 0.5895833333333333, 0.5901981230448383, 0.5908141962421712, 0.5903866248693835, 0.5910041841004184, 0.5916230366492147, 0.5911949685534591, 0.5918153200419727, 0.592436974789916, 0.5920084121976866, 0.5926315789473684, 0.5922023182297155, 0.5928270042194093, 0.5934530095036958, 0.5940803382663847, 0.5947089947089947, 0.5953389830508474, 0.5959703075291622, 0.5955414012738853, 0.5961742826780021, 0.5968085106382979, 0.597444089456869, 0.5980810234541578, 0.5987193169690501, 0.5993589743589743, 0.6, 0.6006423982869379, 0.6012861736334405, 0.601931330472103, 0.602577873254565, 0.603225806451613, 0.6027987082884823, 0.603448275862069, 0.6030204962243797, 0.603671706263499, 0.6032432432432432, 0.6038961038961039, 0.6045503791982665, 0.6052060737527115, 0.6047774158523345, 0.6054347826086957, 0.6050054406964092, 0.6056644880174292, 0.6063249727371864, 0.6069868995633187, 0.6065573770491803, 0.6072210065645515, 0.6067907995618839, 0.6074561403508771, 0.6081229418221734, 0.6076923076923076, 0.6072607260726073, 0.6079295154185022, 0.607497243660419, 0.6070640176600441, 0.6077348066298343, 0.6084070796460177, 0.6090808416389811, 0.6086474501108647, 0.609322974472808, 0.6088888888888889, 0.6084538375973304, 0.60913140311804, 0.6098104793756968, 0.6104910714285714, 0.6100558659217877, 0.610738255033557, 0.6114221724524076, 0.6109865470852018, 0.6105499438832772, 0.6101123595505618, 0.6107986501687289, 0.6114864864864865, 0.6121758737316798, 0.6117381489841986, 0.6124293785310735, 0.6119909502262444, 0.6115515288788222, 0.6111111111111112, 0.6118047673098751, 0.6113636363636363, 0.6120591581342435, 0.6127562642369021, 0.6123147092360319, 0.613013698630137, 0.6137142857142858, 0.61441647597254, 0.6139747995418099, 0.6146788990825688, 0.6153846153846154, 0.6149425287356322, 0.6144994246260069, 0.6152073732718893, 0.615916955017301, 0.6166281755196305, 0.6161849710982659, 0.6168981481481481, 0.6176129779837776, 0.6183294663573086, 0.6178861788617886, 0.6174418604651163, 0.6181606519208381, 0.6188811188811189, 0.6196032672112018, 0.6203271028037384, 0.6210526315789474, 0.6206088992974239, 0.6201641266119577, 0.6197183098591549, 0.6204465334900118, 0.6211764705882353, 0.6219081272084805, 0.6214622641509434, 0.6221959858323495, 0.6217494089834515, 0.6224852071005917, 0.6220379146919431, 0.6227758007117438, 0.6223277909738717, 0.6230677764565993, 0.6226190476190476, 0.6221692491060786, 0.6229116945107399, 0.6224611708482676, 0.6232057416267942, 0.6239520958083832, 0.6235011990407674, 0.6242496998799519, 0.625, 0.6257521058965102, 0.6253012048192771, 0.6248492159227985, 0.6256038647342995, 0.6251511487303507, 0.6246973365617433, 0.6242424242424243, 0.6237864077669902, 0.6233292831105711, 0.6228710462287105, 0.6224116930572473, 0.6231707317073171, 0.6227106227106227, 0.6222493887530562, 0.6217870257037944, 0.6213235294117647, 0.6220858895705521, 0.6228501228501229, 0.6236162361623616, 0.6231527093596059, 0.623921085080148, 0.6246913580246913, 0.6242274412855378, 0.625, 0.6245353159851301, 0.6240694789081885, 0.6248447204968944, 0.6256218905472637, 0.6264009962640099, 0.6259351620947631, 0.6267166042446941, 0.6275, 0.6282853566958698, 0.6278195488721805, 0.6273525721455459, 0.628140703517588, 0.6289308176100629, 0.6297229219143576, 0.6292559899117276, 0.6287878787878788, 0.6283185840707964, 0.6278481012658228, 0.6286438529784537, 0.6281725888324873, 0.6289707750952986, 0.628498727735369, 0.6280254777070063, 0.6275510204081632, 0.6283524904214559, 0.629156010230179, 0.6299615877080665, 0.6307692307692307, 0.631578947368421, 0.6311053984575835, 0.6306306306306306, 0.6301546391752577, 0.6309677419354839, 0.6304909560723514, 0.630012936610608, 0.6295336787564767, 0.6303501945525292, 0.6311688311688312, 0.6306892067620286, 0.6302083333333334, 0.6310299869621904, 0.6318537859007833, 0.6326797385620915, 0.6321989528795812, 0.6317169069462647, 0.631233595800525, 0.6320630749014454, 0.6328947368421053, 0.6324110671936759, 0.633245382585752, 0.6340819022457067, 0.6349206349206349, 0.6344370860927152, 0.6339522546419099, 0.6334661354581673, 0.6329787234042553, 0.6338215712383488, 0.6333333333333333, 0.6341789052069426, 0.6336898395721925, 0.6345381526104418, 0.6340482573726541, 0.6335570469798658, 0.6330645161290323, 0.6339165545087483, 0.6347708894878706, 0.6356275303643725, 0.6351351351351351, 0.6346414073071719, 0.6355013550135501, 0.6350067842605156, 0.6345108695652174, 0.6340136054421769, 0.6335149863760218, 0.6330150068212824, 0.6338797814207651, 0.6333789329685362, 0.6342465753424658, 0.635116598079561, 0.635989010989011, 0.6368638239339752, 0.6377410468319559, 0.6372413793103449, 0.6367403314917127, 0.636237897648686, 0.6371191135734072, 0.6380027739251041, 0.6388888888888888, 0.6383866481223922, 0.637883008356546, 0.6387726638772664, 0.638268156424581, 0.6391608391608392, 0.6386554621848739, 0.6395511921458625, 0.6390449438202247, 0.639943741209564, 0.6394366197183099, 0.6403385049365303, 0.6398305084745762, 0.6393210749646393, 0.6402266288951841, 0.6411347517730497, 0.640625, 0.6401137980085349, 0.6410256410256411, 0.6405135520684736, 0.64, 0.6394849785407726, 0.6404011461318052, 0.6413199426111909, 0.6422413793103449, 0.641726618705036, 0.6426512968299711, 0.6421356421356421, 0.6416184971098265, 0.6410998552821997, 0.6405797101449275, 0.6400580551523948, 0.6395348837209303, 0.6404657933042213, 0.641399416909621, 0.6423357664233577, 0.6432748538011696, 0.6442166910688141, 0.6436950146627566, 0.6431718061674009, 0.6441176470588236, 0.6450662739322534, 0.6460176991150443, 0.6454948301329394, 0.6449704142011834, 0.6444444444444445, 0.6454005934718101, 0.6463595839524517, 0.6473214285714286, 0.646795827123696, 0.6462686567164179, 0.6457399103139013, 0.6467065868263473, 0.6461769115442278, 0.6471471471471472, 0.6481203007518797, 0.6490963855421686, 0.6485671191553545, 0.648036253776435, 0.649016641452345, 0.65, 0.6494688922610015, 0.648936170212766, 0.6484018264840182, 0.6478658536585366, 0.6473282442748092, 0.6483180428134556, 0.6493108728943339, 0.6503067484662577, 0.6513056835637481, 0.6523076923076923, 0.6517719568567026, 0.6512345679012346, 0.6506955177743431, 0.6501547987616099, 0.6511627906976745, 0.6521739130434783, 0.6516329704510109, 0.6510903426791277, 0.6521060842433697, 0.6515625, 0.651017214397496, 0.6504702194357367, 0.6499215070643642, 0.64937106918239, 0.6488188976377953, 0.6482649842271293, 0.6477093206951027, 0.6487341772151899, 0.6497622820919176, 0.6492063492063492, 0.6486486486486487, 0.6496815286624203, 0.6491228070175439, 0.6485623003194888, 0.648, 0.6490384615384616, 0.6500802568218299, 0.6495176848874598, 0.6505636070853462, 0.65, 0.6494345718901454, 0.6504854368932039, 0.6515397082658023, 0.650974025974026, 0.6520325203252032, 0.6514657980456026, 0.6525285481239804, 0.6519607843137255, 0.6530278232405892, 0.6540983606557377, 0.6551724137931034, 0.6546052631578947, 0.6540362438220758, 0.6534653465346535, 0.6545454545454545, 0.6556291390728477, 0.6550580431177446, 0.6561461794019934, 0.6555740432612313, 0.655, 0.654424040066778, 0.6555183946488294, 0.6549413735343383, 0.6560402684563759, 0.6571428571428571, 0.6582491582491582, 0.6593591905564924, 0.6587837837837838, 0.6582064297800339, 0.6593220338983051, 0.6587436332767402, 0.6581632653061225, 0.6592844974446337, 0.658703071672355, 0.6581196581196581, 0.6592465753424658, 0.6586620926243568, 0.6597938144329897, 0.6592082616179001, 0.6586206896551724, 0.6580310880829016, 0.657439446366782, 0.6568457538994801, 0.65625, 0.6573913043478261, 0.6567944250871081, 0.6579406631762653, 0.6573426573426573, 0.658493870402802, 0.6578947368421053, 0.6572934973637962, 0.6566901408450704, 0.656084656084656, 0.657243816254417, 0.6566371681415929, 0.6578014184397163, 0.6589698046181173, 0.6583629893238434, 0.6595365418894831, 0.6589285714285714, 0.6583184257602862, 0.6577060931899642, 0.6588868940754039, 0.6600719424460432, 0.6612612612612613, 0.6606498194945848, 0.6600361663652803, 0.6612318840579711, 0.6606170598911071, 0.6618181818181819, 0.6612021857923497, 0.6624087591240876, 0.6617915904936015, 0.663003663003663, 0.6623853211009174, 0.6617647058823529, 0.6611418047882136, 0.6605166051660517, 0.6598890942698706, 0.6592592592592592, 0.660482374768089, 0.6598513011152416, 0.6610800744878957, 0.6604477611940298, 0.6616822429906543, 0.6610486891385767, 0.6604127579737336, 0.6616541353383458, 0.6629001883239172, 0.6641509433962264, 0.6635160680529301, 0.6647727272727273, 0.6641366223908919, 0.6653992395437263, 0.6647619047619048, 0.666030534351145, 0.6673040152963671, 0.6685823754789272, 0.6698656429942419, 0.6692307692307692, 0.6685934489402697, 0.667953667953668, 0.6692456479690522, 0.6686046511627907, 0.6679611650485436, 0.6673151750972762, 0.6666666666666666, 0.666015625, 0.6653620352250489, 0.6666666666666666, 0.6679764243614931, 0.6673228346456693, 0.6666666666666666, 0.66600790513834, 0.6673267326732674, 0.6666666666666666, 0.6679920477137177, 0.6673306772908366, 0.6666666666666666, 0.666, 0.6673346693386774, 0.6686746987951807, 0.670020120724346, 0.6693548387096774, 0.6707070707070707, 0.6720647773279352, 0.6734279918864098, 0.6747967479674797, 0.6741344195519349, 0.673469387755102, 0.6728016359918201, 0.6721311475409836, 0.6735112936344969, 0.6728395061728395, 0.6742268041237114, 0.6735537190082644, 0.6728778467908902, 0.6742738589211619, 0.6756756756756757, 0.6770833333333334, 0.6784968684759917, 0.6778242677824268, 0.6792452830188679, 0.6785714285714286, 0.6778947368421052, 0.679324894514768, 0.6807610993657506, 0.6800847457627118, 0.6794055201698513, 0.6787234042553192, 0.6780383795309168, 0.6773504273504274, 0.6766595289079229, 0.6759656652360515, 0.6752688172043011, 0.6745689655172413, 0.673866090712743, 0.6753246753246753, 0.6767895878524945, 0.6760869565217391, 0.6753812636165577, 0.6746724890829694, 0.6739606126914661, 0.6732456140350878, 0.6725274725274726, 0.6740088105726872, 0.673289183222958, 0.6747787610619469, 0.6740576496674058, 0.6755555555555556, 0.6770601336302895, 0.6785714285714286, 0.6778523489932886, 0.679372197309417, 0.6786516853932584, 0.6801801801801802, 0.6817155756207675, 0.6832579185520362, 0.6848072562358276, 0.6840909090909091, 0.683371298405467, 0.684931506849315, 0.6864988558352403, 0.6880733944954128, 0.6873563218390805, 0.6866359447004609, 0.6859122401847575, 0.6875, 0.6867749419953596, 0.6883720930232559, 0.6876456876456877, 0.6869158878504673, 0.6861826697892272, 0.687793427230047, 0.6870588235294117, 0.6886792452830188, 0.6903073286052009, 0.6895734597156398, 0.6912114014251781, 0.6928571428571428, 0.6921241050119332, 0.69377990430622, 0.6930455635491607, 0.6923076923076923, 0.691566265060241, 0.6908212560386473, 0.6900726392251816, 0.6893203883495146, 0.6885644768856448, 0.6878048780487804, 0.6894865525672371, 0.6887254901960784, 0.687960687960688, 0.687192118226601, 0.6864197530864198, 0.6856435643564357, 0.684863523573201, 0.6840796019900498, 0.683291770573566, 0.685, 0.6842105263157895, 0.6859296482412061, 0.6851385390428212, 0.6868686868686869, 0.6860759493670886, 0.6852791878172588, 0.6844783715012722, 0.6836734693877551, 0.6828644501278772, 0.6820512820512821, 0.6838046272493573, 0.6829896907216495, 0.6847545219638242, 0.6839378238341969, 0.6831168831168831, 0.6822916666666666, 0.6814621409921671, 0.680628272251309, 0.6797900262467191, 0.6789473684210526, 0.6807387862796834, 0.6798941798941799, 0.6816976127320955, 0.6808510638297872, 0.68, 0.679144385026738, 0.67828418230563, 0.6774193548387096, 0.6765498652291105, 0.6783783783783783, 0.6802168021680217, 0.6820652173913043, 0.6839237057220708, 0.6830601092896175, 0.6821917808219178, 0.6813186813186813, 0.6831955922865014, 0.6850828729281768, 0.6842105263157895, 0.6833333333333333, 0.6824512534818942, 0.6843575418994413, 0.6834733893557423, 0.6825842696629213, 0.6845070422535211, 0.6836158192090396, 0.6827195467422096, 0.6818181818181818, 0.6809116809116809, 0.68, 0.6790830945558739, 0.6781609195402298, 0.6772334293948127, 0.6763005780346821, 0.6753623188405797, 0.6744186046511628, 0.673469387755102, 0.672514619883041, 0.6715542521994134, 0.6705882352941176, 0.6696165191740413, 0.6715976331360947, 0.6735905044510386, 0.6726190476190477, 0.6746268656716418, 0.6766467065868264, 0.6756756756756757, 0.6746987951807228, 0.676737160120846, 0.6787878787878788, 0.6778115501519757, 0.676829268292683, 0.6758409785932722, 0.6779141104294478, 0.676923076923077, 0.6759259259259259, 0.6780185758513931, 0.6801242236024845, 0.6791277258566978, 0.678125, 0.677115987460815, 0.6792452830188679, 0.6813880126182965, 0.680379746835443, 0.6825396825396826, 0.6815286624203821, 0.6837060702875399, 0.6826923076923077, 0.684887459807074, 0.6870967741935484, 0.686084142394822, 0.685064935064935, 0.6872964169381107, 0.6862745098039216, 0.6885245901639344, 0.6907894736842105, 0.693069306930693, 0.695364238410596, 0.6943521594684385, 0.6933333333333334, 0.6923076923076923, 0.6946308724832215, 0.696969696969697, 0.6959459459459459, 0.6949152542372882, 0.6972789115646258, 0.6962457337883959, 0.6952054794520548, 0.697594501718213, 0.7, 0.698961937716263, 0.6979166666666666, 0.7003484320557491, 0.7027972027972028, 0.7017543859649122, 0.7007042253521126, 0.7031802120141343, 0.7021276595744681, 0.701067615658363, 0.7035714285714286, 0.7060931899641577, 0.7086330935251799, 0.7111913357400722, 0.7101449275362319, 0.7090909090909091, 0.7116788321167883, 0.7142857142857143, 0.7132352941176471, 0.7121771217712177, 0.7111111111111111, 0.7100371747211895, 0.7089552238805971, 0.7078651685393258, 0.706766917293233, 0.7056603773584905, 0.7083333333333334, 0.7110266159695817, 0.7137404580152672, 0.7126436781609196, 0.7153846153846154, 0.7181467181467182, 0.7170542635658915, 0.7159533073929961, 0.71484375, 0.7137254901960784, 0.7125984251968503, 0.7154150197628458, 0.7142857142857143, 0.7131474103585658, 0.712, 0.714859437751004, 0.7137096774193549, 0.7125506072874493, 0.7113821138211383, 0.7142857142857143, 0.7131147540983607, 0.7119341563786008, 0.7107438016528925, 0.7136929460580913, 0.7125, 0.7112970711297071, 0.7142857142857143, 0.7172995780590717, 0.7203389830508474, 0.7191489361702128, 0.717948717948718, 0.7167381974248928, 0.7198275862068966, 0.7186147186147186, 0.7217391304347827, 0.7205240174672489, 0.7192982456140351, 0.7180616740088106, 0.7212389380530974, 0.72, 0.7232142857142857, 0.726457399103139, 0.7252252252252253, 0.7239819004524887, 0.7227272727272728, 0.7214611872146118, 0.7201834862385321, 0.7235023041474654, 0.7268518518518519, 0.7255813953488373, 0.7289719626168224, 0.7276995305164319, 0.7311320754716981, 0.7345971563981043, 0.7333333333333333, 0.7320574162679426, 0.7355769230769231, 0.7342995169082126, 0.7330097087378641, 0.7365853658536585, 0.7352941176470589, 0.7339901477832512, 0.7326732673267327, 0.7313432835820896, 0.735, 0.7336683417085427, 0.7323232323232324, 0.7309644670050761, 0.7295918367346939, 0.7282051282051282, 0.7319587628865979, 0.7357512953367875, 0.734375, 0.7329842931937173, 0.7315789473684211, 0.7354497354497355, 0.7340425531914894, 0.732620320855615, 0.7365591397849462, 0.7351351351351352, 0.7336956521739131, 0.73224043715847, 0.7307692307692307, 0.7292817679558011, 0.7333333333333333, 0.7374301675977654, 0.7359550561797753, 0.7344632768361582, 0.7329545454545454, 0.7371428571428571, 0.735632183908046, 0.7341040462427746, 0.7383720930232558, 0.7368421052631579, 0.7352941176470589, 0.7337278106508875, 0.7321428571428571, 0.7305389221556886, 0.7289156626506024, 0.7272727272727273, 0.7317073170731707, 0.7361963190184049, 0.7345679012345679, 0.7329192546583851, 0.73125, 0.7358490566037735, 0.740506329113924, 0.7452229299363057, 0.7435897435897436, 0.7483870967741936, 0.7467532467532467, 0.7450980392156863, 0.743421052631579, 0.7417218543046358, 0.7466666666666667, 0.7449664429530202, 0.7432432432432432, 0.7414965986394558, 0.7397260273972602, 0.7448275862068966, 0.75, 0.7482517482517482, 0.7464788732394366, 0.7446808510638298, 0.7428571428571429, 0.7482014388489209, 0.7463768115942029, 0.7445255474452555, 0.75, 0.7481481481481481, 0.746268656716418, 0.7518796992481203, 0.75, 0.7480916030534351, 0.7461538461538462, 0.7441860465116279, 0.75, 0.7480314960629921, 0.746031746031746, 0.744, 0.7419354838709677, 0.7398373983739838, 0.7377049180327869, 0.743801652892562, 0.7416666666666667, 0.7394957983193278, 0.7372881355932204, 0.7350427350427351, 0.7413793103448276, 0.7391304347826086, 0.7456140350877193, 0.7433628318584071, 0.75, 0.7477477477477478, 0.7454545454545455, 0.7522935779816514, 0.75, 0.7476635514018691, 0.7452830188679245, 0.7523809523809524, 0.75, 0.7475728155339806, 0.7450980392156863, 0.7425742574257426, 0.74, 0.7474747474747475, 0.7448979591836735, 0.7525773195876289, 0.75, 0.7473684210526316, 0.7446808510638298, 0.7419354838709677, 0.7391304347826086, 0.7362637362637363, 0.7444444444444445, 0.7415730337078652, 0.7386363636363636, 0.735632183908046, 0.7441860465116279, 0.7529411764705882, 0.7619047619047619, 0.7590361445783133, 0.7682926829268293, 0.7654320987654321, 0.7625, 0.759493670886076, 0.7564102564102564, 0.7532467532467533, 0.7631578947368421, 0.76, 0.7567567567567568, 0.7671232876712328, 0.7638888888888888, 0.7605633802816901, 0.7714285714285715, 0.7681159420289855, 0.7647058823529411, 0.7761194029850746, 0.7878787878787878, 0.7846153846153846, 0.78125, 0.7777777777777778, 0.7741935483870968, 0.7868852459016393, 0.7833333333333333, 0.7796610169491526, 0.7758620689655172, 0.7719298245614035, 0.7678571428571429, 0.7636363636363637, 0.7592592592592593, 0.7547169811320755, 0.7692307692307693, 0.7843137254901961, 0.8, 0.8163265306122449, 0.8125, 0.8085106382978723, 0.8260869565217391, 0.8222222222222222, 0.8409090909090909, 0.8372093023255814, 0.8333333333333334, 0.8536585365853658, 0.85, 0.8461538461538461, 0.8421052631578947, 0.8378378378378378, 0.8333333333333334, 0.8285714285714286, 0.8529411764705882, 0.8787878787878788, 0.875, 0.8709677419354839, 0.9, 0.896551724137931, 0.8928571428571429, 0.8888888888888888, 0.8846153846153846, 0.88, 0.875, 0.8695652173913043, 0.8636363636363636, 0.8571428571428571, 0.85, 0.8421052631578947, 0.8333333333333334, 0.8235294117647058, 0.8125, 0.8, 0.7857142857142857, 0.7692307692307693, 0.75, 0.7272727272727273, 0.7, 0.7777777777777778, 0.75, 0.8571428571428571, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "recall": [1.0, 1.0, 1.0, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9966666666666667, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9916666666666667, 0.9916666666666667, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.9883333333333333, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.985, 0.985, 0.985, 0.985, 0.9833333333333333, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.98, 0.98, 0.98, 0.98, 0.98, 0.98, 0.9783333333333334, 0.9783333333333334, 0.9783333333333334, 0.9783333333333334, 0.9783333333333334, 0.9783333333333334, 0.9766666666666667, 0.9766666666666667, 0.975, 0.975, 0.975, 0.975, 0.9733333333333334, 0.9733333333333334, 0.9733333333333334, 0.9733333333333334, 0.9733333333333334, 0.9733333333333334, 0.9733333333333334, 0.9733333333333334, 0.9733333333333334, 0.9716666666666667, 0.9716666666666667, 0.9716666666666667, 0.9716666666666667, 0.9716666666666667, 0.9716666666666667, 0.97, 0.97, 0.97, 0.97, 0.97, 0.97, 0.97, 0.9683333333333334, 0.9683333333333334, 0.9666666666666667, 0.9666666666666667, 0.9666666666666667, 0.9666666666666667, 0.9666666666666667, 0.9666666666666667, 0.9666666666666667, 0.9666666666666667, 0.9666666666666667, 0.965, 0.965, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9616666666666667, 0.96, 0.96, 0.96, 0.96, 0.96, 0.9583333333333334, 0.9566666666666667, 0.955, 0.955, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9516666666666667, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9466666666666667, 0.945, 0.945, 0.9433333333333334, 0.9433333333333334, 0.9433333333333334, 0.9433333333333334, 0.9416666666666667, 0.9416666666666667, 0.9416666666666667, 0.94, 0.94, 0.94, 0.9383333333333334, 0.9383333333333334, 0.9366666666666666, 0.9366666666666666, 0.9366666666666666, 0.9366666666666666, 0.9366666666666666, 0.9366666666666666, 0.9366666666666666, 0.935, 0.935, 0.935, 0.935, 0.935, 0.935, 0.935, 0.935, 0.935, 0.935, 0.935, 0.935, 0.935, 0.9333333333333333, 0.9333333333333333, 0.9316666666666666, 0.9316666666666666, 0.93, 0.93, 0.93, 0.93, 0.9283333333333333, 0.9283333333333333, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.925, 0.925, 0.9233333333333333, 0.9233333333333333, 0.9233333333333333, 0.9216666666666666, 0.92, 0.92, 0.9183333333333333, 0.9166666666666666, 0.9166666666666666, 0.9166666666666666, 0.9166666666666666, 0.915, 0.915, 0.9133333333333333, 0.9116666666666666, 0.9116666666666666, 0.9116666666666666, 0.9116666666666666, 0.91, 0.91, 0.91, 0.9083333333333333, 0.9066666666666666, 0.905, 0.905, 0.905, 0.905, 0.9033333333333333, 0.9033333333333333, 0.9016666666666666, 0.9, 0.8983333333333333, 0.8983333333333333, 0.8966666666666666, 0.8966666666666666, 0.8966666666666666, 0.895, 0.895, 0.895, 0.895, 0.8933333333333333, 0.8933333333333333, 0.8933333333333333, 0.8916666666666667, 0.89, 0.89, 0.89, 0.89, 0.8883333333333333, 0.8883333333333333, 0.8883333333333333, 0.8883333333333333, 0.8866666666666667, 0.885, 0.885, 0.885, 0.885, 0.885, 0.885, 0.8833333333333333, 0.8816666666666667, 0.88, 0.88, 0.88, 0.88, 0.8783333333333333, 0.8783333333333333, 0.8766666666666667, 0.8766666666666667, 0.875, 0.875, 0.8733333333333333, 0.8733333333333333, 0.8716666666666667, 0.87, 0.87, 0.8683333333333333, 0.8683333333333333, 0.8683333333333333, 0.8666666666666667, 0.8666666666666667, 0.8666666666666667, 0.8666666666666667, 0.865, 0.8633333333333333, 0.8633333333333333, 0.8616666666666667, 0.86, 0.8583333333333333, 0.8566666666666667, 0.855, 0.8533333333333334, 0.8516666666666667, 0.8516666666666667, 0.85, 0.8483333333333334, 0.8466666666666667, 0.845, 0.845, 0.845, 0.845, 0.8433333333333334, 0.8433333333333334, 0.8433333333333334, 0.8416666666666667, 0.8416666666666667, 0.84, 0.8383333333333334, 0.8383333333333334, 0.8383333333333334, 0.8383333333333334, 0.8366666666666667, 0.8366666666666667, 0.8366666666666667, 0.8366666666666667, 0.835, 0.8333333333333334, 0.8333333333333334, 0.8333333333333334, 0.8333333333333334, 0.8316666666666667, 0.83, 0.8283333333333334, 0.8266666666666667, 0.8266666666666667, 0.825, 0.825, 0.8233333333333334, 0.8216666666666667, 0.82, 0.82, 0.82, 0.82, 0.82, 0.82, 0.8183333333333334, 0.8166666666666667, 0.815, 0.815, 0.8133333333333334, 0.8116666666666666, 0.81, 0.81, 0.81, 0.8083333333333333, 0.8066666666666666, 0.8066666666666666, 0.8066666666666666, 0.8066666666666666, 0.805, 0.8033333333333333, 0.8016666666666666, 0.8016666666666666, 0.8016666666666666, 0.8, 0.8, 0.8, 0.8, 0.7983333333333333, 0.7966666666666666, 0.795, 0.7933333333333333, 0.7933333333333333, 0.7916666666666666, 0.7916666666666666, 0.79, 0.79, 0.7883333333333333, 0.7866666666666666, 0.785, 0.785, 0.785, 0.785, 0.7833333333333333, 0.7816666666666666, 0.7816666666666666, 0.78, 0.7783333333333333, 0.7766666666666666, 0.775, 0.7733333333333333, 0.7733333333333333, 0.7716666666666666, 0.7716666666666666, 0.7716666666666666, 0.7716666666666666, 0.7716666666666666, 0.7716666666666666, 0.77, 0.7683333333333333, 0.7666666666666667, 0.7666666666666667, 0.7666666666666667, 0.7666666666666667, 0.765, 0.7633333333333333, 0.7633333333333333, 0.7616666666666667, 0.7616666666666667, 0.76, 0.76, 0.7583333333333333, 0.7583333333333333, 0.7566666666666667, 0.7566666666666667, 0.755, 0.7533333333333333, 0.7533333333333333, 0.7533333333333333, 0.7516666666666667, 0.75, 0.75, 0.7483333333333333, 0.7466666666666667, 0.745, 0.745, 0.745, 0.745, 0.7433333333333333, 0.7433333333333333, 0.7416666666666667, 0.74, 0.7383333333333333, 0.7366666666666667, 0.735, 0.7333333333333333, 0.7333333333333333, 0.7333333333333333, 0.7333333333333333, 0.7333333333333333, 0.7333333333333333, 0.7316666666666667, 0.73, 0.73, 0.73, 0.73, 0.7283333333333334, 0.7266666666666667, 0.725, 0.725, 0.725, 0.725, 0.7233333333333334, 0.7216666666666667, 0.72, 0.72, 0.7183333333333334, 0.7183333333333334, 0.7183333333333334, 0.7183333333333334, 0.7166666666666667, 0.715, 0.715, 0.715, 0.7133333333333334, 0.7116666666666667, 0.71, 0.7083333333333334, 0.7066666666666667, 0.7066666666666667, 0.7066666666666667, 0.7066666666666667, 0.7066666666666667, 0.7066666666666667, 0.705, 0.7033333333333334, 0.7016666666666667, 0.7, 0.7, 0.7, 0.6983333333333334, 0.6966666666666667, 0.6966666666666667, 0.695, 0.6933333333333334, 0.6916666666666667, 0.69, 0.6883333333333334, 0.6866666666666666, 0.685, 0.6833333333333333, 0.6833333333333333, 0.6833333333333333, 0.6816666666666666, 0.68, 0.68, 0.6783333333333333, 0.6766666666666666, 0.675, 0.675, 0.675, 0.6733333333333333, 0.6733333333333333, 0.6716666666666666, 0.67, 0.67, 0.67, 0.6683333333333333, 0.6683333333333333, 0.6666666666666666, 0.6666666666666666, 0.665, 0.665, 0.665, 0.665, 0.6633333333333333, 0.6616666666666666, 0.66, 0.66, 0.66, 0.6583333333333333, 0.6583333333333333, 0.6566666666666666, 0.655, 0.6533333333333333, 0.6533333333333333, 0.6516666666666666, 0.6516666666666666, 0.6516666666666666, 0.6516666666666666, 0.6516666666666666, 0.65, 0.6483333333333333, 0.6483333333333333, 0.6466666666666666, 0.645, 0.645, 0.6433333333333333, 0.6416666666666667, 0.6416666666666667, 0.64, 0.64, 0.6383333333333333, 0.6366666666666667, 0.635, 0.6333333333333333, 0.6316666666666667, 0.63, 0.63, 0.6283333333333333, 0.6283333333333333, 0.6266666666666667, 0.6266666666666667, 0.625, 0.6233333333333333, 0.6216666666666667, 0.62, 0.62, 0.6183333333333333, 0.6183333333333333, 0.6183333333333333, 0.6166666666666667, 0.6166666666666667, 0.615, 0.6133333333333333, 0.6116666666666667, 0.6116666666666667, 0.6116666666666667, 0.6116666666666667, 0.61, 0.6083333333333333, 0.6083333333333333, 0.6066666666666667, 0.6066666666666667, 0.605, 0.605, 0.6033333333333334, 0.6033333333333334, 0.6016666666666667, 0.6, 0.5983333333333334, 0.5966666666666667, 0.595, 0.5933333333333334, 0.5933333333333334, 0.5916666666666667, 0.5916666666666667, 0.59, 0.59, 0.5883333333333334, 0.5866666666666667, 0.5866666666666667, 0.5866666666666667, 0.5866666666666667, 0.585, 0.585, 0.5833333333333334, 0.5833333333333334, 0.5816666666666667, 0.5816666666666667, 0.5816666666666667, 0.5816666666666667, 0.5816666666666667, 0.58, 0.5783333333333334, 0.5766666666666667, 0.5766666666666667, 0.575, 0.5733333333333334, 0.5716666666666667, 0.57, 0.5683333333333334, 0.5666666666666667, 0.5666666666666667, 0.5666666666666667, 0.565, 0.5633333333333334, 0.5616666666666666, 0.5616666666666666, 0.56, 0.56, 0.5583333333333333, 0.5566666666666666, 0.555, 0.555, 0.555, 0.555, 0.5533333333333333, 0.5533333333333333, 0.5533333333333333, 0.5533333333333333, 0.5533333333333333, 0.5516666666666666, 0.55, 0.5483333333333333, 0.5466666666666666, 0.5466666666666666, 0.545, 0.545, 0.5433333333333333, 0.5416666666666666, 0.5416666666666666, 0.5416666666666666, 0.5416666666666666, 0.5416666666666666, 0.54, 0.54, 0.5383333333333333, 0.5366666666666666, 0.5366666666666666, 0.5366666666666666, 0.535, 0.5333333333333333, 0.5316666666666666, 0.53, 0.5283333333333333, 0.5266666666666666, 0.525, 0.5233333333333333, 0.5216666666666666, 0.52, 0.52, 0.52, 0.5183333333333333, 0.5166666666666667, 0.515, 0.5133333333333333, 0.5116666666666667, 0.51, 0.51, 0.5083333333333333, 0.5083333333333333, 0.5066666666666667, 0.5066666666666667, 0.5066666666666667, 0.5066666666666667, 0.505, 0.505, 0.5033333333333333, 0.5033333333333333, 0.5033333333333333, 0.5033333333333333, 0.5033333333333333, 0.5016666666666667, 0.5, 0.5, 0.5, 0.5, 0.49833333333333335, 0.49666666666666665, 0.495, 0.495, 0.49333333333333335, 0.49333333333333335, 0.49166666666666664, 0.49, 0.48833333333333334, 0.48833333333333334, 0.4866666666666667, 0.4866666666666667, 0.4866666666666667, 0.485, 0.485, 0.485, 0.48333333333333334, 0.48333333333333334, 0.4816666666666667, 0.48, 0.47833333333333333, 0.4766666666666667, 0.475, 0.47333333333333333, 0.4716666666666667, 0.47, 0.47, 0.4683333333333333, 0.4666666666666667, 0.465, 0.4633333333333333, 0.46166666666666667, 0.46, 0.4583333333333333, 0.45666666666666667, 0.45666666666666667, 0.455, 0.455, 0.4533333333333333, 0.4533333333333333, 0.45166666666666666, 0.45, 0.4483333333333333, 0.44666666666666666, 0.445, 0.44333333333333336, 0.44333333333333336, 0.44166666666666665, 0.44166666666666665, 0.44, 0.43833333333333335, 0.43666666666666665, 0.435, 0.43333333333333335, 0.43166666666666664, 0.43, 0.43, 0.42833333333333334, 0.42833333333333334, 0.4266666666666667, 0.425, 0.42333333333333334, 0.4216666666666667, 0.42, 0.41833333333333333, 0.41833333333333333, 0.41833333333333333, 0.41833333333333333, 0.41833333333333333, 0.4166666666666667, 0.415, 0.41333333333333333, 0.41333333333333333, 0.41333333333333333, 0.4116666666666667, 0.41, 0.4083333333333333, 0.4083333333333333, 0.4066666666666667, 0.405, 0.405, 0.4033333333333333, 0.40166666666666667, 0.4, 0.3983333333333333, 0.39666666666666667, 0.395, 0.3933333333333333, 0.39166666666666666, 0.39, 0.3883333333333333, 0.38666666666666666, 0.385, 0.38333333333333336, 0.38166666666666665, 0.38, 0.37833333333333335, 0.37833333333333335, 0.37833333333333335, 0.37666666666666665, 0.37666666666666665, 0.37666666666666665, 0.375, 0.37333333333333335, 0.37333333333333335, 0.37333333333333335, 0.37166666666666665, 0.37, 0.36833333333333335, 0.36833333333333335, 0.36666666666666664, 0.365, 0.365, 0.365, 0.36333333333333334, 0.3616666666666667, 0.36, 0.36, 0.36, 0.35833333333333334, 0.35833333333333334, 0.3566666666666667, 0.3566666666666667, 0.355, 0.355, 0.355, 0.35333333333333333, 0.3516666666666667, 0.3516666666666667, 0.35, 0.35, 0.35, 0.35, 0.35, 0.34833333333333333, 0.3466666666666667, 0.345, 0.345, 0.345, 0.3433333333333333, 0.3416666666666667, 0.3416666666666667, 0.34, 0.3383333333333333, 0.3383333333333333, 0.3383333333333333, 0.33666666666666667, 0.335, 0.335, 0.335, 0.3333333333333333, 0.33166666666666667, 0.33166666666666667, 0.33, 0.3283333333333333, 0.3283333333333333, 0.3283333333333333, 0.3283333333333333, 0.3283333333333333, 0.32666666666666666, 0.325, 0.325, 0.325, 0.3233333333333333, 0.32166666666666666, 0.32, 0.31833333333333336, 0.31666666666666665, 0.315, 0.31333333333333335, 0.31166666666666665, 0.31166666666666665, 0.31166666666666665, 0.31166666666666665, 0.31, 0.31, 0.31, 0.30833333333333335, 0.30666666666666664, 0.305, 0.30333333333333334, 0.3016666666666667, 0.3016666666666667, 0.3, 0.29833333333333334, 0.2966666666666667, 0.2966666666666667, 0.295, 0.29333333333333333, 0.2916666666666667, 0.2916666666666667, 0.29, 0.28833333333333333, 0.2866666666666667, 0.2866666666666667, 0.285, 0.2833333333333333, 0.2833333333333333, 0.2833333333333333, 0.2833333333333333, 0.2816666666666667, 0.28, 0.2783333333333333, 0.2783333333333333, 0.27666666666666667, 0.27666666666666667, 0.275, 0.2733333333333333, 0.27166666666666667, 0.27166666666666667, 0.27, 0.27, 0.27, 0.2683333333333333, 0.26666666666666666, 0.265, 0.2633333333333333, 0.26166666666666666, 0.26166666666666666, 0.26166666666666666, 0.26, 0.26, 0.25833333333333336, 0.25833333333333336, 0.25833333333333336, 0.25666666666666665, 0.255, 0.255, 0.25333333333333335, 0.25166666666666665, 0.25166666666666665, 0.25, 0.24833333333333332, 0.24666666666666667, 0.245, 0.245, 0.24333333333333335, 0.24166666666666667, 0.24, 0.23833333333333334, 0.23666666666666666, 0.23666666666666666, 0.23666666666666666, 0.235, 0.23333333333333334, 0.23166666666666666, 0.23166666666666666, 0.23, 0.22833333333333333, 0.22833333333333333, 0.22666666666666666, 0.225, 0.22333333333333333, 0.22166666666666668, 0.22, 0.22, 0.22, 0.21833333333333332, 0.21666666666666667, 0.215, 0.215, 0.21333333333333335, 0.21166666666666667, 0.21166666666666667, 0.21, 0.20833333333333334, 0.20666666666666667, 0.205, 0.20333333333333334, 0.20166666666666666, 0.2, 0.2, 0.2, 0.19833333333333333, 0.19666666666666666, 0.195, 0.195, 0.195, 0.195, 0.19333333333333333, 0.19333333333333333, 0.19166666666666668, 0.19, 0.18833333333333332, 0.18666666666666668, 0.18666666666666668, 0.185, 0.18333333333333332, 0.18166666666666667, 0.18, 0.18, 0.18, 0.17833333333333334, 0.17666666666666667, 0.175, 0.17333333333333334, 0.17333333333333334, 0.17166666666666666, 0.17, 0.17, 0.16833333333333333, 0.16666666666666666, 0.16666666666666666, 0.165, 0.16333333333333333, 0.16166666666666665, 0.16, 0.16, 0.15833333333333333, 0.15666666666666668, 0.155, 0.15333333333333332, 0.15166666666666667, 0.15, 0.15, 0.14833333333333334, 0.14666666666666667, 0.145, 0.14333333333333334, 0.14333333333333334, 0.14166666666666666, 0.14166666666666666, 0.14, 0.14, 0.13833333333333334, 0.13666666666666666, 0.13666666666666666, 0.135, 0.13333333333333333, 0.13166666666666665, 0.13166666666666665, 0.13, 0.12833333333333333, 0.12666666666666668, 0.125, 0.12333333333333334, 0.12333333333333334, 0.12166666666666667, 0.12166666666666667, 0.12, 0.11833333333333333, 0.11666666666666667, 0.115, 0.11333333333333333, 0.11166666666666666, 0.11166666666666666, 0.11, 0.10833333333333334, 0.10666666666666667, 0.10666666666666667, 0.10666666666666667, 0.10666666666666667, 0.105, 0.105, 0.10333333333333333, 0.10166666666666667, 0.1, 0.09833333333333333, 0.09666666666666666, 0.09666666666666666, 0.095, 0.09333333333333334, 0.09333333333333334, 0.09166666666666666, 0.09, 0.09, 0.08833333333333333, 0.08666666666666667, 0.08666666666666667, 0.08666666666666667, 0.085, 0.08333333333333333, 0.08166666666666667, 0.08, 0.08, 0.07833333333333334, 0.07666666666666666, 0.075, 0.07333333333333333, 0.07166666666666667, 0.07, 0.06833333333333333, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.065, 0.06333333333333334, 0.06333333333333334, 0.06166666666666667, 0.06166666666666667, 0.06, 0.058333333333333334, 0.058333333333333334, 0.056666666666666664, 0.055, 0.05333333333333334, 0.051666666666666666, 0.05, 0.04833333333333333, 0.04833333333333333, 0.04833333333333333, 0.04666666666666667, 0.045, 0.045, 0.043333333333333335, 0.041666666666666664, 0.04, 0.03833333333333333, 0.03666666666666667, 0.035, 0.03333333333333333, 0.03166666666666667, 0.03, 0.028333333333333332, 0.02666666666666667, 0.025, 0.023333333333333334, 0.021666666666666667, 0.02, 0.018333333333333333, 0.016666666666666666, 0.015, 0.013333333333333334, 0.011666666666666667, 0.011666666666666667, 0.01, 0.01, 0.01, 0.008333333333333333, 0.006666666666666667, 0.005, 0.0033333333333333335, 0.0016666666666666668, 0.0]}, "loss": 0.31482915556358315}