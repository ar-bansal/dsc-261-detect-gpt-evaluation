{"name": "perturbation_1_z", "predictions": {"real": [0.9675342738628387, 0.4341139793395996, 1.4434236288070679, 0.7159527242183685, 0.5670652389526367, 0.9769065976142883, 1.0987588167190552, 1.149868905544281, 0.4057260751724243, 1.2113355994224548, 0.9003669619560242, 0.08703505992889404, 0.0035740137100219727, 0.9245986938476562, -0.6086578369140625, -0.1404118537902832, 0.6082550287246704, 0.5452144145965576, 1.1166136264801025, 1.0253733396530151, 1.0295658111572266, 0.6705732047557831, 0.441484272480011, 0.7186174988746643, 0.5998725295066833, 0.9595376253128052, 0.8651707768440247, 1.4566185474395752, 0.4542720913887024, 1.9111721515655518, 0.8779178857803345, 0.6326396465301514, 0.9327622652053833, 1.6763989925384521, 1.1097634434700012, 0.7989476919174194, 0.41485607624053955, 0.7635453939437866, 0.7247549295425415, 0.7235105037689209, 1.341321885585785, 0.28014278411865234, -0.0634615421295166, 1.0129982233047485, 0.6013789176940918, 0.6400327086448669, 0.22591423988342285, 0.0, 0.657329797744751, 0.7876681089401245, 1.0238446593284607, 0.9167905449867249, 1.5642075836658478, 1.1316481828689575, 0.7589609622955322, 1.1554936170578003, 0.7583250999450684, 0.463600218296051, 1.0527631640434265, 0.6926772594451904, 0.5494189858436584, 0.8648827970027924, 1.0188438892364502, 1.0152572989463806, 0.5445461273193359, 1.065312147140503, 0.7358571290969849, 0.9010860919952393, 0.8706100583076477, 0.587492048740387, 0.9410347938537598, 1.4119407534599304, 1.1114424467086792, 0.6850517988204956, 1.0198122262954712, 0.6219372749328613, 1.0364050269126892, 0.9969824552536011, 0.6601834297180176, 0.6064695119857788, 0.6245913505554199, 0.3027597665786743, 0.8725653886795044, 0.9869194030761719, 0.6141086220741272, 0.9737332463264465, 1.3556760549545288, 0.17705512046813965, 2.4433565735816956, 1.0959638357162476, 0.43443867564201355, 0.6104954779148102, 0.20853161811828613, 0.11531811952590942, 0.8279033899307251, 0.8491941094398499, 0.4900277853012085, 1.0974279642105103, 0.6993027627468109, 0.5326025485992432, 1.0610425472259521, 1.0970897674560547, 0.0, 0.8668210506439209, 1.1771209239959717, 0.30479729175567627, 0.8358882367610931, 0.8991694450378418, 0.9734543561935425, 0.8323688507080078, 0.3387380838394165, 1.4545471668243408, 1.640842080116272, 1.7948814630508423, 1.3162389993667603, 0.7828366160392761, 1.164687693119049, 0.6591720581054688, 0.9534401297569275, 0.9454641938209534, 0.7952584028244019, 0.7382938265800476, 1.3554853796958923, 0.451062947511673, 1.1837674975395203, 0.6292623281478882, 1.085297703742981, 0.9633166193962097, 0.7968592047691345, 0.8200938701629639, 1.0733521580696106, 0.12277078628540039, 0.5025336742401123, 0.8596398830413818, 1.3229868412017822, 1.03900146484375, 0.7686306834220886, 0.8165733814239502, 0.4869575500488281, 1.3607426285743713, 0.937449038028717, 0.0, 1.011204719543457, 1.9345109462738037, 0.0, 0.19110983610153198, 0.6899192333221436, 0.29380351305007935, 0.5654723942279816, 1.03658789396286, 1.4087366461753845, 0.8445829749107361, 0.05805015563964844, 0.6407943367958069, 0.8229302167892456, 1.0171420574188232, 1.0695138573646545, 1.38886296749115, 1.263103425502777, 1.0838581919670105, 1.0098623037338257, 2.299497365951538, 0.28511959314346313, 1.3917027711868286, 0.2095167636871338, 1.0079320073127747, 0.5400891304016113, 0.9383017420768738, 0.4484812915325165, 0.9560826420783997, 0.879925549030304, 0.8637257814407349, 0.8766573071479797, 1.0158082246780396, 0.3953855037689209, 1.2509233951568604, 0.7705163955688477, 0.48538872599601746, 0.9204958379268646, 0.9810763597488403, 0.9602567553520203, 0.9027355909347534, 0.7591147422790527, 0.6367364525794983, 1.0395814180374146, 0.7606648802757263, 0.0, 0.8973590731620789, -0.053565025329589844, 0.7064063549041748, 0.999549150466919, 0.6077015399932861, 0.33084237575531006, 0.8439867198467255, 1.6159676909446716, 0.7949504852294922, 1.030906319618225, 1.1449249982833862, 0.5313664674758911, 0.6138388514518738, 0.7279865741729736, 0.8089573383331299, 0.8990998268127441, 0.30319440364837646, 0.429473340511322, 0.3704807758331299, 0.942326545715332, 0.18547344207763672, 1.1685612797737122, 0.4418293237686157, 0.8330119848251343, 0.4703673720359802, 1.231880784034729, 0.0, 1.0678980350494385, 0.5954681634902954, 0.3244417905807495, 0.2549927532672882, 0.10943388938903809, 0.5282824635505676, 0.5394680500030518, 0.6381905674934387, 0.5643630027770996, 1.1543315052986145, 0.879334568977356, 0.0, 1.166158139705658, 0.9197031855583191, 1.2289819717407227, 1.0114463567733765, 1.3665300607681274, 0.0, 0.9698574542999268, 0.5341124534606934, 1.1052441596984863, 0.879122257232666, 0.282751202583313, 1.2500474154949188, 0.9960472583770752, 0.31899702548980713, 0.8397152423858643, 1.0975284576416016, 1.0490094423294067, 0.776242733001709, 1.1124595403671265, 0.7511023283004761, 1.0158745050430298, 0.9695918560028076, 1.316148042678833, 1.0056114792823792, 0.6860718131065369, 1.3415451049804688, 0.47694122791290283, 1.405252993106842, 1.186375379562378, 0.9354063272476196, 1.1356453895568848, 1.1279762387275696, 0.7221877574920654, 0.5864818096160889, 0.5801900625228882, 0.585098385810852, 0.8220749497413635, -0.07846522331237793, 1.0341165959835052, 1.2052626609802246, 1.2134901881217957, 0.7293590307235718, 1.04317307472229, 1.1314446926116943, 0.25273388624191284, 0.48585838079452515, 0.6253836750984192, 0.8438469767570496, 0.6515229940414429, 0.9118708372116089, 0.32986724376678467, 1.2844817638397217, 1.3029744625091553, 0.10825932025909424, 0.6382604837417603, 0.8941011428833008, 0.4478842616081238, 1.1648446321487427, 0.9906959533691406, 0.5636829733848572, 0.9502181112766266, 0.9067279100418091, 1.4744563102722168, 0.9242812395095825, 1.0156553387641907, 0.49393510818481445, 0.9531092643737793, 1.0618542432785034, 0.9341431260108948, 0.9619081616401672, 0.7924169898033142, -0.21964168548583984, 0.7783368825912476, 0.7195443511009216, 0.8512364625930786, 0.9640365242958069, 0.6323933601379395, 0.21475213766098022, 0.3453601002693176, 0.9163925647735596, 0.7886548042297363, 1.2096887826919556, 1.4438765048980713, 0.6523085236549377, 0.8048737645149231, 0.8396664261817932, 0.4412437677383423, 0.8710412085056305, 1.037438690662384, 0.6502959132194519, 0.8743182420730591, 0.8552775382995605, 0.7944869995117188, 1.110754907131195, 1.3736062049865723, 0.32719898223876953, 0.8602249324321747, 0.9257042706012726, 0.935021698474884, 1.042683720588684, 1.0228321552276611, 0.9502249956130981, 1.064069390296936, 0.44996798038482666, 0.5401426553726196, 1.055353730916977, 1.4532190561294556, 1.02585107088089, 0.5860289335250854, 0.8703582286834717, 0.5394861400127411, 0.8117940425872803, 0.3889526128768921, 0.5878714919090271, 0.9590861201286316, 0.8937021493911743, 0.45843440294265747, 0.7272722721099854, 0.4503823518753052, 0.6426889896392822, 0.9452816247940063, 0.9411735534667969, 0.9700621962547302, 1.0015348196029663, 1.0241944789886475, 0.65648353099823, 0.7996722459793091, 0.957798182964325, 0.7506760954856873, 0.9552076458930969, 1.1397171020507812, 0.35434281826019287, 0.9404562711715698, 0.9484769105911255, 0.2917369604110718, 0.8755514025688171, 1.2277178764343262, -0.06015372276306152, 0.803787887096405, 0.935299277305603, 0.5097804069519043, 0.9742811918258667, 1.6027666330337524, 1.0810788869857788, 1.3121081590652466, 1.0736339092254639, 0.0, 0.8246666193008423, 1.1192435026168823, 0.9805777072906494, 0.8460667729377747, 1.1286776661872864, 0.8912957906723022, 0.6121513843536377, 0.6380001902580261, 0.8588278293609619, 1.003343641757965, 1.0321598052978516, 0.5030149221420288, 0.8130443394184113, 0.8478096723556519, 1.073908805847168, 0.9866763055324554, 0.8710597455501556, 0.899389922618866, 0.9549857676029205, 1.2459591627120972, 0.8136410117149353, 0.9934477806091309, 1.2476730346679688, 0.4781534671783447, 0.9156011343002319, 1.0610061883926392, 0.4111744165420532, 1.0735204219818115, 0.633974552154541, 0.6695684790611267, 0.6703815460205078, 1.4970413446426392, 0.3893584609031677, 1.1316604614257812, 1.62119722366333, 0.47945475578308105, 0.7157424092292786, 0.6986005306243896, 0.0, 0.8868468999862671, 0.5078917741775513, 0.9733483791351318, 1.0322909951210022, 0.7377462983131409, 0.8047810792922974, 1.11971116065979, 0.7750479578971863, 0.6685134172439575, 0.0, 1.2967658042907715, 0.6725177764892578, 1.082163691520691, 1.2811100482940674, 0.5265512466430664, 1.1051474213600159, 1.0049790143966675, 1.5177185535430908, 0.9594923257827759, 0.366152286529541, 0.0, 0.6427579522132874, 1.4904680252075195, 0.7520236372947693, 1.4953774809837341, 0.7926862239837646, 0.34186989068984985, 0.7164112329483032, 0.8512935638427734, 0.6224336624145508, 0.821968138217926, 0.22858238220214844, 0.0, 0.7990209460258484, 0.8410124778747559, 0.8671852350234985, 0.6317322254180908, 0.8076288104057312, 0.7150077819824219, 0.6826541423797607, 1.1015889644622803, 0.40234291553497314, 1.2339114546775818, 1.1447662115097046, 0.6263993978500366, 0.8465165495872498, 0.8329665660858154, 0.49580204486846924, 0.8051051795482635, 0.8366053104400635, 0.5719400644302368, 0.3984631896018982, 0.9731208086013794, 0.10321497917175293, 0.6830129623413086, 0.8139740228652954, 0.34865498542785645, 0.5867377519607544, 0.7095284461975098, 0.9143858551979065, 0.9989897012710571, 1.0886527299880981, 0.34663140773773193, 0.8380675315856934, 0.637432336807251, 0.0, 1.118345856666565, 1.1019412875175476, 0.0, 0.8367936611175537, 1.0602949857711792, 1.0527933835983276, 0.4849063754081726, 1.12041437625885, 0.0, 0.7469540238380432, 1.000442087650299, 1.0870599746704102, 1.0194552540779114, 1.476616621017456, 0.8994956612586975, 0.6115370988845825, 1.4963676929473877, 1.218904733657837, 0.7167190313339233, 0.9484859704971313, 0.3665085434913635, 1.023838460445404, 1.2435582876205444, 0.5881866216659546, 0.8194604218006134, 1.1009770631790161, 0.17900848388671875, 0.8580278754234314, 1.091399610042572, 0.8370623588562012, 0.8937491178512573, 1.121011734008789, 0.8471806049346924, 1.0518764853477478, 0.991978108882904, 0.781780481338501, 0.6967242360115051, 0.36024439334869385, 0.537532389163971, 0.7265061736106873, 1.1054853200912476, 0.6293492317199707, 0.9016972780227661, 0.928436279296875, 0.6687262058258057, 0.5598461627960205, 1.4853991270065308, 0.5459330081939697, 0.7566124200820923, 0.6473384499549866, 0.0, 0.6784492135047913, 0.904476523399353, 0.3187379837036133, 0.9991007447242737, 1.0949156284332275, 1.0219720005989075, 0.7076217532157898, 0.904975950717926, 0.7929689288139343, 1.0384478569030762, 1.2716657519340515, 0.7174787521362305, 0.9923850893974304, 1.078141987323761, 0.9999861121177673, 0.7676260471343994, 0.8958397507667542, 0.0, 0.8012416362762451, 0.8545935153961182, 0.45494651794433594, 0.585641622543335, 1.0869170427322388, 0.5210200548171997, 0.9575493931770325, 0.9563031196594238, 0.0, 0.7131368517875671, 0.9424743056297302, 1.1161271333694458, 1.106221854686737, 0.8392720222473145, 0.755673885345459, 0.8564995527267456, 1.623953104019165, 0.41662657260894775, 1.0235152840614319, 1.2023850679397583, 0.0, 1.1420845985412598, 1.056886911392212, 0.7445405721664429, 1.0312492847442627, 1.0832096338272095, 0.46491849422454834, 0.7851920127868652, 1.4361211061477661, 0.7740776538848877, 1.0787776708602905, 0.7609179019927979, 1.1253224611282349, 1.1925727128982544, 0.9231007099151611, 0.10404586791992188, 0.9648563265800476, 0.9182453155517578, 0.0, 0.09077644348144531, 0.25208139419555664, 0.0, 0.799118161201477, 1.1508539319038391, -0.0034637451171875, 0.6595412492752075, 0.9147007465362549, 0.0, 0.7491523623466492, 1.013299822807312, 0.6443086862564087, 0.8289681673049927, 0.9177295565605164], "samples": [0.8529259264469147, 0.5057049095630646, 0.20541781187057495, 1.4416148662567139, 1.5744864642620087, 1.1843695044517517, 1.507398098707199, 1.131658673286438, 1.4005741477012634, 1.8490498960018158, 1.1119891107082367, 1.2375006079673767, 0.8864195942878723, 1.023887813091278, 1.387969970703125, 1.1608765721321106, 0.8627135157585144, 0.4545072317123413, 0.9298427104949951, 1.2449560165405273, 0.8231074810028076, 0.9742865860462189, 1.1174632608890533, 1.0170000493526459, 1.0488569140434265, 0.8458667099475861, 0.9057776927947998, 1.0395336747169495, 0.9783627688884735, 1.9977843761444092, 1.4551845788955688, 1.3149195313453674, 1.2418516874313354, 0.9731923937797546, 1.0768593549728394, 1.2940138578414917, 1.5742681622505188, 1.4405264258384705, 1.201645016670227, 0.9585021436214447, 0.7500394880771637, 0.43758702278137207, 1.143941879272461, 1.336102455854416, 2.976929783821106, 1.2056951522827148, 1.0366719365119934, -0.3953080177307129, 0.9124011993408203, 1.001950204372406, 1.3711131811141968, 1.255988359451294, 1.0435923635959625, 1.895537793636322, 1.314746379852295, 1.3858734369277954, 1.490422010421753, 1.2319605946540833, 1.0709834396839142, 1.0296931862831116, 0.8500222861766815, 0.8633089065551758, 0.7517216801643372, 0.5973426997661591, 0.7582744657993317, 0.7534833550453186, 1.4292899370193481, 0.8565196990966797, 1.6889513731002808, 0.9880834221839905, 0.8387203812599182, 0.8689063787460327, 1.196320652961731, 1.0556448698043823, 1.5654043555259705, 1.2201364636421204, 1.06504887342453, 1.6971839666366577, 1.0606109499931335, 1.2789891958236694, 1.5939130783081055, 1.019915521144867, 1.1062359809875488, 1.0761471390724182, 1.2707298398017883, 0.9119691252708435, 1.4872933626174927, 0.7940756380558014, 0.8121425211429596, 1.1373310983181, 0.7386170029640198, 0.7366638779640198, 0.9272199869155884, 0.8536022007465363, 1.0868278741836548, 1.0764418244361877, 1.1292234361171722, 1.0468287765979767, 0.9578579068183899, 1.0338588654994965, 1.0313530266284943, 1.3824963569641113, 0.872421383857727, 1.0148603022098541, 1.1975279450416565, 0.8380201160907745, 0.774224728345871, 0.971618264913559, 0.7281442880630493, 0.8731034100055695, 1.2567030191421509, 0.9764507412910461, 1.4329899549484253, 0.3893320560455322, 0.8384308218955994, 1.2347512245178223, 1.6284347772598267, 0.8623928725719452, 0.8582783341407776, 1.0438616275787354, 1.0120673477649689, 0.6964767277240753, 0.9550416469573975, 0.7881603538990021, 1.0709102153778076, 0.15952444076538086, 0.7476969957351685, 1.4337358474731445, 2.250248670578003, 1.4343209862709045, 0.9509718418121338, 0.8894978761672974, 1.3145995736122131, 1.2346922159194946, 1.9657913446426392, 1.0391128659248352, 1.3309918642044067, 1.1648619771003723, 1.1918399930000305, 1.0357383489608765, 1.1190409064292908, 0.836578369140625, 0.8404815196990967, 1.4292725324630737, 0.9662595987319946, 0.9893660545349121, 1.4087608456611633, 1.144435554742813, 1.1569306254386902, 0.8156744837760925, 1.321726381778717, 1.110413908958435, 1.1287118792533875, 0.8976296186447144, 1.062657356262207, 1.1198421716690063, 1.0161840617656708, 0.8786897957324982, 1.7542880773544312, 0.9835880398750305, 1.4536423087120056, 0.8592661619186401, 0.7951596975326538, 1.0315455496311188, 1.12101411819458, 0.8196248412132263, 0.8652797937393188, 1.054548442363739, 0.88697749376297, 0.949589729309082, 0.9585500061511993, 0.8232362270355225, 1.1907543540000916, 1.3596271276474, 0.8729201555252075, 1.071085810661316, 1.8582596182823181, 1.0764618217945099, 0.8834316432476044, 1.066538393497467, 0.9478645026683807, 0.9893480539321899, 0.9857476353645325, 1.2192037105560303, 0.9332566857337952, 1.1030405163764954, 0.9604038596153259, 1.0174992084503174, 1.1785266399383545, 1.378656953573227, 1.3769251108169556, 1.4705383777618408, 1.6329204440116882, 1.123321920633316, 1.278282791376114, 1.1133297085762024, 1.1061509251594543, 1.586065411567688, 1.1457718312740326, 1.2959173917770386, 1.2949607372283936, 0.9815072417259216, 0.9670082628726959, 1.2241212129592896, 0.755566418170929, 1.0510097444057465, 1.0440362095832825, 1.4479633569717407, 0.8271380960941315, 0.827712893486023, 0.7748543918132782, 0.9599313735961914, 1.1307061910629272, 1.363644689321518, 1.0805095732212067, 1.2961220443248749, 0.6063719093799591, 0.39321279525756836, 0.7231005728244781, 0.7672064006328583, 0.8408477306365967, 1.1259644031524658, 0.8083745539188385, 0.9721885621547699, 1.0041770935058594, 0.7123362720012665, 1.0268937051296234, 1.047292023897171, 1.5116099119186401, 1.3099535703659058, 1.2117916941642761, 1.1383424997329712, 1.3429690599441528, 0.44267427921295166, 1.0430101156234741, 1.2758973240852356, 1.3947113752365112, 1.2979126274585724, 1.1832273602485657, 0.9444154500961304, 1.1340376138687134, 0.9807712435722351, 1.1275692880153656, 1.0850558876991272, 1.3175227046012878, 0.7208491563796997, 1.097944736480713, 0.8172440230846405, 1.560541808605194, 1.1803451180458069, 1.1194425821304321, 0.5638854503631592, 0.862931102514267, 0.6424274295568466, 0.852863073348999, 0.8730738759040833, 1.1534481048583984, 1.2646583318710327, 1.2251808941364288, 1.1586311757564545, 1.2207775712013245, 1.4642650485038757, 0.6934178471565247, 1.6070959568023682, 1.2029236257076263, 1.1622501015663147, 1.0178591907024384, 1.144686222076416, 0.9147392213344574, 1.3964107632637024, 0.5532572865486145, 0.3297010362148285, 0.6055576503276825, 1.2020054459571838, 1.2760998606681824, 1.9295859336853027, 1.02248877286911, 1.169407308101654, 1.6160135865211487, 0.9582526981830597, 1.4390228688716888, 1.3701010942459106, 1.2905145287513733, 0.9600683599710464, 1.0973927080631256, 0.8377088606357574, 1.0213370025157928, 1.448479413986206, 0.8403095602989197, 1.0200836956501007, 1.2276908457279205, 0.8672998547554016, 1.120166838169098, 1.567585289478302, 0.9916163682937622, 1.0201617777347565, 1.5411716103553772, 0.8379411399364471, 0.9477558434009552, 1.3532090783119202, 0.9559281170368195, 1.053919643163681, 0.9658528566360474, 0.7229523658752441, 0.8044129014015198, 0.6706948280334473, 0.9097616970539093, 1.4566434621810913, 1.7385242581367493, 1.4147457480430603, 0.8247554451227188, 1.1059548556804657, 0.8268752247095108, 0.799268439412117, 1.0419332683086395, 0.9386390447616577, 1.1610409617424011, 1.086219310760498, 1.0388480424880981, 1.231097161769867, 1.1245810389518738, 0.9515426158905029, 1.2184050977230072, 1.461515188217163, 0.8570387661457062, 0.8618440628051758, 1.2748527526855469, 1.0285005271434784, 0.868344247341156, 0.9836808443069458, 1.3097364902496338, 0.9887722134590149, 0.5322563648223877, 1.0184319019317627, 1.0004701018333435, 1.3635861277580261, 0.9752747714519501, 0.9857675135135651, 1.0132086873054504, 0.7148101925849915, 1.1545425653457642, 0.8006718158721924, 1.0857139229774475, 1.149266242980957, 0.99263134598732, 1.1143763065338135, 0.9801576733589172, 1.1398332715034485, 1.0989338755607605, 1.1564282178878784, 1.3005295395851135, 0.6439839601516724, 0.7235338687896729, 0.8429973125457764, 0.9317700862884521, 1.001697063446045, 1.4233765602111816, 0.9613679051399231, 0.9964255094528198, 0.90647292137146, 1.005348950624466, 1.1298015117645264, 1.4561989307403564, 0.9920948147773743, 1.0078504085540771, 1.2076544165611267, 1.789987564086914, 1.0777976512908936, 2.0758986473083496, 0.7441038489341736, 1.061108261346817, 0.7628712058067322, 0.9121143519878387, 0.8349050432443619, 1.0378723442554474, 0.9724976420402527, 0.7370599508285522, 1.0108268558979034, 0.7878102958202362, 0.7371566891670227, 0.9109106361865997, 1.0906514525413513, 1.1870468854904175, 1.3518016338348389, 0.9091551899909973, 0.9523926377296448, 1.1583973169326782, 0.9206507802009583, 1.0948404669761658, 1.166698396205902, 1.0124997198581696, 0.8368140459060669, 1.4834856390953064, 1.498880296945572, 1.2250829935073853, 1.2148810625076294, 1.2126126289367676, 0.8823343515396118, 1.4942421317100525, 0.9256031513214111, 0.889272928237915, 1.3742743730545044, 0.6016938090324402, 0.9887447655200958, 1.5126696825027466, 0.9513255059719086, 1.1373494863510132, 1.1077095866203308, 0.798034280538559, 0.9635941386222839, 1.0579608082771301, 1.4559235572814941, 1.0754950642585754, 1.1878879070281982, 1.0435146987438202, 0.8376574516296387, 1.3965629637241364, 1.0208409130573273, 0.8205122351646423, 0.6392541825771332, 0.7327892780303955, 0.7482945322990417, 1.1460624933242798, 1.0022385716438293, 1.0409880876541138, 1.2361476421356201, 1.03218674659729, 0.9833900928497314, 1.3512436747550964, 1.1372431516647339, 1.394677996635437, 0.8403681516647339, 1.0528742671012878, 1.3332899808883667, 1.20436429977417, 1.1307268738746643, 1.1911357641220093, 1.9327909350395203, 0.5774499773979187, 0.9108166694641113, 1.1206542253494263, 0.9806458652019501, 0.7982586920261383, 0.7107346653938293, 1.0023323595523834, 1.0869024097919464, 1.5550842881202698, 0.8843580484390259, 1.0369142591953278, 0.5995465517044067, 0.9266248345375061, 1.0034631490707397, 1.0700625479221344, 1.1413146257400513, 0.972477525472641, 1.5666688084602356, 0.7584727704524994, 1.2271729409694672, 1.0292862057685852, 0.9744523763656616, 0.710658848285675, 0.9796261489391327, 0.9037643671035767, 0.8176120817661285, 1.0920156240463257, 1.7169524729251862, 1.1282735466957092, 1.5660379528999329, 0.7645364701747894, 0.6831942200660706, 0.9613495171070099, 0.7981997728347778, 1.1176201701164246, 1.3201172351837158, 0.7996372878551483, 0.808937132358551, 1.0495854020118713, 0.9282508790493011, 0.8210325241088867, 1.688325822353363, 0.9565392732620239, 0.911357045173645, 1.0051629543304443, 0.8704531490802765, 0.8299993872642517, 1.2225008010864258, 0.6621831655502319, 0.7632022798061371, 1.2408968210220337, 1.0524151623249054, 0.7307416498661041, 1.4993159770965576, 1.013249546289444, 1.0147538483142853, 1.3660486936569214, 1.465353548526764, 1.2723110616207123, 1.270619511604309, 0.6968122124671936, 0.7856728136539459, 0.7296357750892639, 0.9517828226089478, 1.0575558841228485, 1.3119347095489502, 0.8989951610565186, 0.9552138149738312, 1.2195879220962524, 0.6827757954597473, 1.1106840372085571, 1.5703256726264954, 0.8969845473766327, 1.2129346132278442, 1.21039879322052, 1.08543461561203, 1.0296204090118408, 1.0861003398895264, 0.831900030374527, 1.0280442833900452, 1.08008873462677, 1.0599534511566162, 1.0052855014801025, 1.1400609016418457, 0.9063512086868286, 0.977436900138855, 1.425775408744812, 0.9338149428367615, 1.0620874464511871, 1.276374101638794, 0.8040273189544678, 0.9099959135055542, 1.35664564371109, 0.8454151153564453, 0.904128760099411, 1.2153361439704895, 0.8919941186904907, 1.1388567686080933, 1.3116604685783386, 0.8502611219882965, 0.8130005300045013, 1.171431839466095, 0.8228334784507751, 0.9189845323562622, 1.1514816284179688, 0.8479588478803635, 0.788049578666687, 0.8901025652885437, 0.9534531533718109, 1.1274343132972717, 1.226610243320465, 1.3362840414047241, 1.201720654964447, 1.0788536667823792, 1.782051920890808, 1.3556676506996155, 1.5398468971252441, 1.0900855660438538, 0.7343284487724304, 1.4182507991790771, 1.77902489900589, 1.006286859512329, 0.9044789671897888, 1.1621170043945312, 1.122858464717865, 1.8191744685173035, 1.3820903301239014, 1.1877601742744446, 1.0124077200889587, 0.7888047695159912, 1.0197077691555023, 0.8044729828834534, 0.8465508222579956, 0.9099937975406647, 1.2400931119918823, 0.8092277348041534, 0.9407586753368378, 0.9461730718612671, 1.4664563238620758, 1.437065750360489, 0.9756436347961426, 0.786941647529602, 1.5185102224349976, 1.4460205435752869, 1.222708523273468, 1.156987190246582, 0.765667736530304, 1.173143982887268, 1.3159515857696533, 1.3925431966781616, 0.8841061592102051, 1.158905565738678, 1.474137783050537, 1.092472106218338, 1.527939110994339, 1.1323158740997314, 1.2314286828041077, 1.7894319295883179, 1.2485778331756592, 0.8231095969676971, 0.9617939293384552, 1.3902267813682556]}, "info": {"pct_words_masked": 0.3, "span_length": 5, "n_perturbations": 1, "n_samples": 700}, "raw_results": [{"original": "#include <stdio.h>\nint main(void)\n{\n\tint a[10];\n\tint i;\n\tint MAX[3];\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(i = 0; i < 3; i++)\n\t{\n\t\tMAX[i] = 0;\n\t}\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tif(MAX[0] < a[i])\n\t\t{\n\t\t\tMAX[0] = a[i];\n\t\t}\n\t}\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tif(MAX[1] < a[i])\n\t\t{\n\t\t\tif(a[i] < MAX[0])\n\t\t\t{\n\t\t\t\tMAX[1] = a[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tif(MAX[2] < a[i])\n\t\t{\n\t\t\tif(a[i] < MAX[1])\n\t\t\t{\n\t\t\t\tMAX[2] = a[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%d\\n\", MAX[i]);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int heights[10];\n    int i, j;\n    \n    for (i = 0; i < 10; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n    \n    for (i = 0; i < 10; i++) {\n        for (j = i + 1; j < 10; j++) {\n            if (heights[i] < heights[j]) {\n                int temp = heights[i];\n                heights[i] = heights[j];\n                heights[j] = temp;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", heights[0]);\n    printf(\"%d\\n\", heights[1]);\n    printf(\"%d\\n\", heights[2]);\n    \n    return 0;\n}\n", "perturbed_sampled": [" int heights[10]; int i, j; for (i = 0; i < 10; i++) { scanf(\"%d\", &heights[i]); } for (i = 0; i < 10; i++) { for (j = i + 1; j < 10; j++) { if (heights[i]  = heights[i];  temp; } } } printf(\"%d\\n\",  return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int  < 10; i++) { scanf(\"%d\", &a[i]); } for(i = 0; i < 3; i++) {  = 0; i  < a[i]) { MAX[0] = a[i]; } } for(i = 0; i   MAX[0]) { MAX[1] = a[i]; } } } for(i = 0; i < 10; i++) { if(MAX[2] < a[i]) { if(a[i] < MAX[1]) { MAX[2] = a[i]; } } } for(i = 0; i < 3; i++) { printf(\"%d\\n\", MAX[i]); } return 0; }"], "original_ll": -0.3286745846271515, "sampled_ll": -0.3793737590312958, "all_perturbed_sampled_ll": [-1.2322996854782104], "all_perturbed_original_ll": [-1.2962088584899902], "perturbed_sampled_ll": -1.2322996854782104, "perturbed_original_ll": -1.2962088584899902, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class Main{\n\tpublic static void main(String[] a) throws Exception {\n\t\tint[] heights = new int[10];\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tBufferedReader height = new BufferedReader(new InputStreamReader(System.in));\t\n\t\t\theights[i] = Integer.parseInt(height.readLine());\n\t\t\tSystem.out.println(heights[i]);\n\t\t}\n\t\tArrays.sort(heights);\n\t\tSystem.out.println(heights[0]);\n\t\tSystem.out.println(heights[1]);\n\t\tSystem.out.println(heights[2]);\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Integer[] heights = new Integer[10];\n        \n        for (int i = 0; i < 10; i++) {\n            heights[i] = sc.nextInt();\n        }\n        \n        Arrays.sort(heights, Collections.reverseOrder());\n        \n        System.out.println(heights[0]);\n        System.out.println(heights[1]);\n        System.out.println(heights[2]);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  Scanner sc = new Scanner(System.in); Integer[] heights = new Integer[10]; for (int i = 0; i < 10; i++) { heights[i] = sc.nextInt(); } Arrays.sort(heights, Collections.reverseOrder()); System.out.println(heights[0]); System.out.println(heights[1]); System.out.println(heights[2]); sc.close(); } }"], "perturbed_original": ["public class Main{ public static   int[10]; for (int i = 0; i < 10; i++) { BufferedReader height = new BufferedReader(new InputStreamReader(System.in)); heights[i] = Integer.parseInt(height.readLine()); System.out.println(heights[i]); } Arrays.sort(heights); System.out.println(heights[0]); System.out.println(heights[1]); System.out.println(heights[2]); } }"], "original_ll": -0.8593831062316895, "sampled_ll": -0.49140146374702454, "all_perturbed_sampled_ll": [-0.9971063733100891], "all_perturbed_original_ll": [-1.293497085571289], "perturbed_sampled_ll": -0.9971063733100891, "perturbed_original_ll": -1.293497085571289, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\ne = sys.stdin.readlines()\ne = [int(i) for i in e]\nfor i in range(3):\n    m = max(e)\n    e.remove(m)\n    print (m)\n", "sampled": "heights = []\nfor _ in range(10):\n    heights.append(int(input()))\n\nheights.sort(reverse=True)\n\nfor i in range(3):\n    print(heights[i])\n", "perturbed_sampled": ["heights = [] for _ in range(10): heights.append(int(input())) heights.sort(reverse=True) for i in range(3): print(heights[i])"], "perturbed_original": ["import sys e = sys.stdin.readlines() e = [int(i) for  in range(3): m = max(e) e.remove(m) print (m)"], "original_ll": -1.6235491037368774, "sampled_ll": -0.7311930060386658, "all_perturbed_sampled_ll": [-0.9366108179092407], "all_perturbed_original_ll": [-3.0669727325439453], "perturbed_sampled_ll": -0.9366108179092407, "perturbed_original_ll": -3.0669727325439453, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main()\n{\nint N, i, a, b, c, max;\n\nscanf(\"%d\", &N);\n\nfor(i=0; i<N; i++){\nscanf(\"%d %d %d\", &a, &b, &c);\n\nif(a<=b && b<=c){\nmax = c;\nif(c*c==a*a+b*b){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(a<=c && c<=b){\nmax = b;\nif(b*b==a*a+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(b<=c && c<=a){\nmax = a;\nif(a*a==b*b+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(b<=a && a<=c){\nmax = c;\nif(c*c==a*a+b*b){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(c<=a && a<=b){\nmax = b;\nif(b*b==a*a+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(c<=b && b<=a){\nmax = a;\nif(a*a==b*b+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\n\n}\n\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        \n        int aa = a * a;\n        int bb = b * b;\n        int cc = c * c;\n        \n        if (aa + bb == cc || aa + cc == bb || bb + cc == aa) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n);  b, c; scanf(\"%d %d %d\", &a, &b, &c); int  int  int cc = c *  == cc || aa + cc == bb || bb + cc == aa) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main() { int  max; scanf(\"%d\",  %d %d\", &a, &b, &c); if(a<=b && b<=c){ max = c; if(c*c==a*a+b*b){ puts(\"YES\"); }else{ puts(\"NO\"); } }  }else{ puts(\"NO\"); } } else if(b<=c && c<=a){ max = a; if(a*a==b*b+c*c){ puts(\"YES\"); }else{ puts(\"NO\"); } } else if(b<=a && a<=c){ max = c; if(c*c==a*a+b*b){  else if(c<=a  if(b*b==a*a+c*c){ puts(\"YES\"); }else{ puts(\"NO\"); } } else if(c<=b && b<=a){ max = a; if(a*a==b*b+c*c){ puts(\"YES\"); }else{ puts(\"NO\"); } } } return 0; }"], "original_ll": -0.44192495942115784, "sampled_ll": -0.37493956089019775, "all_perturbed_sampled_ll": [-1.8165544271469116], "all_perturbed_original_ll": [-1.1578776836395264], "perturbed_sampled_ll": -1.8165544271469116, "perturbed_original_ll": -1.1578776836395264, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tScanner kb=new Scanner(System.in);\nint size=kb.nextInt();\nint a[][]=new int[size][3];\nint x,y,z;\nfor(int i=0;i<size;i++){\n\ta[i][0]=kb.nextInt();\n\ta[i][1]=kb.nextInt();\n\ta[i][2]=kb.nextInt();\n}\nfor(int i=0;i<size;i++){\nx=a[i][0];\ny=a[i][1];\nz=a[i][2];\nif(x*x+y*y==z*z||y*y+z*z==x*x||z*z+x*x==y*y){\n\tSystem.out.println(\"YES\");\n}else{\n\tSystem.out.println(\"NO\");\n}\n}\n\t}\n\n}", "sampled": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            int[] sides = new int[3];\n            sides[0] = sc.nextInt();\n            sides[1] = sc.nextInt();\n            sides[2] = sc.nextInt();\n            \n            Arrays.sort(sides);\n            \n            if (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; import java.util.Arrays; public class (); main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); <extra_id_3>i in sides){ ii<extra_id_4>, sides ) ; }<extra_id_5>;<extra_id_6>, int maxsides<extra_id_7>n = 0;<extra_id_8>< 8 ; ii<extra_id_9>{<extra_id_10>(<extra_id_11>, Math . sqrt<extra_id_12>( 1 +<extra_id_13>) ;<extra_id_14>; } public int d<extra_id_15>,<extra_id_16>i ,<extra_id_17>,<extra_id_18>if (<extra_id_19>\" \"<extra_id_20>j <<extra_id_21>int , int , int<extra_id_22>} }<extra_id_23>(<extra_id_24>Math . log i < n; i++)  sides[1] = sc.nextInt(); sides[2] = sc.nextInt(); Arrays.sort(sides); if (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main{ public static void main(String[] args) { // TODO ????????????????????????????????????????????? Scanner kb=new Scanner(System.in);  int x,y,z; for(int i=0;i<size;i++){  i=0;i<size;i++){ x=a[i][0]; y=a[i][1]; z=a[i][2]; if(x*x+y*y==z*z||y*y+z*z==x*x||z*z+x*x==y*y){ System.out.println(\"YES\"); }else{ System.out.println(\"NO\"); } } } }"], "original_ll": -0.7276204824447632, "sampled_ll": -0.3389137089252472, "all_perturbed_sampled_ll": [-1.9134001731872559], "all_perturbed_original_ll": [-1.2946857213974], "perturbed_sampled_ll": -1.9134001731872559, "perturbed_original_ll": -1.2946857213974, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N = int(input())\nfor i in range(N):\n    triangle = sorted([int(n) for n in input().split()])\n    if triangle[0]**2 + triangle[1]**2 == triangle[2]**2:\n        print('YES')\n    else:\n        print('NO')\n\n", "sampled": "n = int(input())\nfor _ in range(n):\n    sides = list(map(int, input().split()))\n    sides.sort()\n    if sides[0]**2 + sides[1]**2 == sides[2]**2:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["n = int(input()) for _ in range(n): sides  sides[0]**2 + sides[1]**2 == sides[2]**2: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["N = int(input())  = sorted([int(n) for n in input().split()]) if triangle[0]**2 + triangle[1]**2 == triangle[2]**2: print('YES') else: print('NO')"], "original_ll": -0.8837476372718811, "sampled_ll": -0.6795265078544617, "all_perturbed_sampled_ll": [-1.8638960123062134], "all_perturbed_original_ll": [-1.8606542348861694], "perturbed_sampled_ll": -1.8638960123062134, "perturbed_original_ll": -1.8606542348861694, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main( void )\n{\n    int a,b,c,d,e,f;\n    float x,y;\n    \n    while(scanf(\"%d %d %d %d %d %d\",&a,&b,&c,&d,&e,&f)!=-1){    \n        y = (float)( c*d -a*f ) / (b*d-a*e); \n        x = (float)( c*e -b*f ) / (a*e-b*d);\n        if(-0.0005<x && x<=0 ){\n            x = 0;\n        }\n        if(-0.0005<y && y<=0 ){\n            y = 0;\n        }\n        printf( \"%.3lf %.3f\\n\",x,y); \n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double a, b, c, d, e, f;\n    \n    while (scanf(\"%lf %lf %lf %lf %lf %lf\", &a, &b, &c, &d, &e, &f) != EOF) {\n        double x, y;\n        double det = a * e - b * d;\n        \n        x = (c * e - b * f) / det;\n        y = (a * f - c * d) / det;\n        \n        printf(\"%.3f %.3f\\n\", x, y);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  a, b, c, d, e, f;  %lf %lf\", &a, &b, &c, &d, &e, &f) != EOF) { double x, y; double det = a * e - b * d; x = (c * e  det; y = (a * f - c * d) /  } return 0; }"], "perturbed_original": ["#include <stdio.h> int main( void ) { int a,b,c,d,e,f; float x,y; while(scanf(\"%d %d %d %d  c*d -a*f ) / (b*d-a*e); x = (float)( c*e -b*f ) / (a*e-b*d); if(-0.0005<x  0; } if(-0.0005<y  0; } printf( \"%.3lf %.3f\\n\",x,y); } return 0; }"], "original_ll": -1.1125622987747192, "sampled_ll": -0.4869227707386017, "all_perturbed_sampled_ll": [-1.9943208694458008], "all_perturbed_original_ll": [-2.2113211154937744], "perturbed_sampled_ll": -1.9943208694458008, "perturbed_original_ll": -2.2113211154937744, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString t[], s;\n\t\t\tdouble a[] = new double[6];\n\t\t\twhile((s = reader.readLine())  != null) {\n\t\t\t\tt = s.split(\" \");\n\t\t\t\tfor(int i = 0;i < a.length;i++) {\n\t\t\t\t\ta[i] = Double.parseDouble(t[i]);\n\t\t\t\t}\n\t\t\t\tdouble z = a[0]*a[4]-a[1]*a[3];\n\t\t\t\tdouble x = (a[4]*a[2]-a[1]*a[5])/z;\n\t\t\t\tdouble y = (-a[3]*a[2]+a[0]*a[5])/z;\n\n\t\t\t\tif(x == -0.0)\n\t\t\t\t\tx = 0.0;\n\t\t\t\tif(y == -0.0)\n\t\t\t\t\ty = 0.0;\n\t\t\t\tSystem.out.printf(\"%4.3f %4.3f\\n\", x, y);\n\n\t\t\t}\n\n\t\t}\n\t\tcatch(IOException e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double a = sc.nextDouble();\n            double b = sc.nextDouble();\n            double c = sc.nextDouble();\n            double d = sc.nextDouble();\n            double e = sc.nextDouble();\n            double f = sc.nextDouble();\n            \n            double det = a * e - b * d;\n            double x = (c * e - b * f) / det;\n            double y = (a * f - c * d) / det;\n            \n            System.out.printf(\"%.3f %.3f%n\", x, y);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void  = new Scanner(System.in); while (sc.hasNext()) { double a = sc.nextDouble(); double  = sc.nextDouble(); double d = sc.nextDouble(); double  = a * e  x = (c * e - b * f) / det; double y = (a * f - c * d) / det; System.out.printf(\"%.3f %.3f%n\", x, y); } sc.close(); } }"], "perturbed_original": ["import java.io.*; class Main { public {<extra_id_5>]<extra_id_6>== -0.0 )<extra_id_7>Math .<extra_id_8>( a .<extra_id_9>+<extra_id_10>new ().POS<extra_id_11>= 0.0.0/4.0.3<extra_id_12>)<extra_id_13>int i<extra_id_14>) (<extra_id_15>] = null ; for<extra_id_16>1 ; i <<extra_id_17>.<extra_id_18>; i ++ )<extra_id_19>} t[], s; double a[] = new  null) { t = s.split(\" \"); for(int i =  = Double.parseDouble(t[i]); } double z = a[0]*a[4]-a[1]*a[3]; double x = (a[4]*a[2]-a[1]*a[5])/z; double y = (-a[3]*a[2]+a[0]*a[5])/z; if(x == -0.0) x = 0.0; if(y == -0.0) y = 0.0; System.out.printf(\"%4.3f %4.3f\\n\", x, y); } } catch(IOException e) { System.out.println(e); } } }"], "original_ll": -0.756742537021637, "sampled_ll": -0.4077526330947876, "all_perturbed_sampled_ll": [-1.5394113063812256], "all_perturbed_original_ll": [-1.906611442565918], "perturbed_sampled_ll": -1.5394113063812256, "perturbed_original_ll": -1.906611442565918, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor line in sys.stdin:\n    a,b,c,d,e,f = map(float, line.split())\n    print((c*e-b*f)/(a*e-b*d), (a*f-c*d)/(a*e-b*d))", "sampled": "import sys\n\nfor line in sys.stdin:\n    a, b, c, d, e, f = map(float, line.split())\n    \n    # Using Cramer's rule\n    # ax + by = c\n    # dx + ey = f\n    \n    det = a * e - b * d\n    \n    if det != 0:\n        x = (c * e - b * f) / det\n        y = (a * f - c * d) / det\n    else:\n        # This shouldn't happen as per problem statement (unique solution)\n        x = 0\n        y = 0\n    \n    print(f\"{x:.3f} {y:.3f}\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: a, b, c, d, e, f = map(float, line.split()) # Using Cramer's  + ey = f det = a * e - b * d if det != 0: x = (c * e - b  = (a * f - c * d) / det else: # This shouldn't happen as  = 0 print(f\"{x:.3f} {y:.3f}\")"], "perturbed_original": ["import sys for line in sys.stdin: a,b,c,d,e,f = map(float, line.split()) print((c*e-b*f)/(a*e-b*d), (a*f-c*d)/(a*e-b*d))"], "original_ll": -1.4522068500518799, "sampled_ll": -0.8963740468025208, "all_perturbed_sampled_ll": [-2.296948194503784], "all_perturbed_original_ll": [-1.8579329252243042], "perturbed_sampled_ll": -2.296948194503784, "perturbed_original_ll": -1.8579329252243042, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n    int a,b,c,tmp,tmp_a,tmp_b;\n    while(scanf(\"%d%d\", &a, &b)!=EOF){\n        c = 1;\n        if(b > a){tmp = a; a = b; b = tmp;}\n        tmp_a = a;\n        tmp_b = b;\n        for(int i=2; i<=tmp_b; i++){\n            while(tmp_b%i==0 && tmp_a%i==0){\n                c = c*i;\n                tmp_b = tmp_b / i;\n                tmp_a = tmp_a / i;\n            }\n        }\n        printf(\"%d %d\\n\", c, tmp_a*tmp_b*c);\n    }\n    return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint main() {\n    long long a, b;\n    while (scanf(\"%lld %lld\", &a, &b) != EOF) {\n        long long g = gcd(a, b);\n        long long lcm = (a / g) * b;\n        printf(\"%lld %lld\\n\", g, lcm);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> long long gcd(long long a, long long b) { while (b != 0) { long long temp lcm<extra_id_2>>> 20 );<extra_id_3>%, a, !<extra_id_4>floor(a<extra_id_5>+ g); lcm<extra_id_6>, g *<extra_id_7>}<extra_id_8>} return a; }<extra_id_9>} return b;<extra_id_10>floor; printf(\"%lld<extra_id_11>,<extra_id_12>b); } }<extra_id_13>> 0)<extra_id_14>{ printf(\"%lld %lld)\\n\",<extra_id_15>b); } // for<extra_id_16>a )<extra_id_17>(<extra_id_18>+<extra_id_19>} //return<extra_id_20>//return<extra_id_21>; % b; a = temp;  main() { long long a, b; while (scanf(\"%lld %lld\", &a, &b) != EOF) { long  long  g) * b; printf(\"%lld %lld\\n\", g, lcm); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int a,b,c,tmp,tmp_a,tmp_b; while(scanf(\"%d%d\", &a, &b)!=EOF){ c = 1; if(b > a){tmp = a; a = b; ,b*i; return 0; a; tmp_b =  while(tmp_b%i==0 && tmp_a%i==0){ c = c*i; tmp_b = tmp_b / i; tmp_a = tmp_a / i; } } printf(\"%d %d\\n\",  }"], "original_ll": -0.9382491707801819, "sampled_ll": -0.33897343277931213, "all_perturbed_sampled_ll": [-2.188023328781128], "all_perturbed_original_ll": [-2.1495847702026367], "perturbed_sampled_ll": -2.188023328781128, "perturbed_original_ll": -2.1495847702026367, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\npublic class Main{\n\t/*\n\tpublic static long findGcd(long f1, long f2){\n\t\tlong gcd = 1;\n\t\tlong max, min;\n\t\tif(f1 > f2){max = f1; min = f2;}\n\t\telse{max = f2; min = f1;}\n\t\tfor(long i=1; i<=(long)(Math.sqrt(min)+1); i++){\n\t\t\tif(min % i == 0){\n\t\t\t\tlong tmp = min / i;\n\t\t\t\tif((max % tmp) == 0){\n\t\t\t\t\tgcd = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn gcd;\n\t}\n\t*/\n\tstatic long findGcd(long x, long y){\n        for(long i=1; i<=x; i++){\n            if(y*i%x==0){\n                return y*i;\n            }\n        }\n        return 0;\n    }\n\t\n\tpublic static long findlcm(long f1, long f2){\n\t\tlong lcm = 0;\n\t\tlong max, min;\n\t\tif(f1 > f2){max = f1; min = f2;}\n\t\telse{max = f2; min = f1;}\n\t\tlong i=1;\n\t\twhile(lcm == 0){\n\t\t\tif((max * i)%min == 0){\n\t\t\t\tlcm = max * i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn lcm;\n\t}\n\t\n\tpublic static void main(String[] argv) throws NumberFormatException, IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\twhile((line = br.readLine()) != null){\n\t\t\tString[] lineArray = line.split(\" \");\n\t\t\tlong[] factor = {Long.parseLong(lineArray[0]), Long.parseLong(lineArray[1])};\n\t\t\tlong gcd = findGcd(factor[0], factor[1]);\n\t\t\tlong lcm = findlcm(factor[0], factor[1]);\n\t\t\tSystem.out.println(gcd + \" \" + lcm);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            long a = sc.nextLong();\n            long b = sc.nextLong();\n            \n            long gcd = gcd(a, b);\n            long lcm = (a / gcd) * b;\n            \n            System.out.println(gcd + \" \" + lcm);\n        }\n        \n        sc.close();\n    }\n    \n    static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc   long b = sc.nextLong(); long gcd = gcd(a, b); long lcm = (a / gcd) *  + lcm);  gcd(long a, long b) { while (b != 0) { long temp = b; b = a % b; a = temp; } return a; } }"], "perturbed_original": ["import java.io.*;  static long findGcd(long f1, long f2){ long gcd = 1; long max,  else{max = f2; min = f1;} for(long  tmp = min / i; if((max % tmp) == 0){ gcd = tmp; break; } } } return gcd; } */ static long  i=1; i<=x; i++){  return 0; } public static long findlcm(long f1, long f2){ long lcm = 0; long max, min; if(f1 > f2){max = f1; min = f2;} else{max  long i=1; while(lcm == 0){ if((max * i)%min  * i; } i++; } return lcm; } public static void main(String[] argv) throws NumberFormatException, IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while((line =  = line.split(\" \"); long[] factor = {Long.parseLong(lineArray[0]), Long.parseLong(lineArray[1])}; long gcd = findGcd(factor[0], factor[1]); long lcm = findlcm(factor[0], factor[1]); System.out.println(gcd + \" \" + lcm); } } }"], "original_ll": -0.6323391795158386, "sampled_ll": -0.3231864273548126, "all_perturbed_sampled_ll": [-1.4351755380630493], "all_perturbed_original_ll": [-1.5327061414718628], "perturbed_sampled_ll": -1.4351755380630493, "perturbed_original_ll": -1.5327061414718628, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\ntry:\n while 1:\n  a,b=map(int,input().split())\n  print(math.gcd(a,b),a*b// math.gcd(a, b))\nexcept:\n   pass\n ", "sampled": "import sys\nimport math\n\nfor line in sys.stdin:\n    a, b = map(int, line.split())\n    gcd = math.gcd(a, b)\n    lcm = (a * b) // gcd\n    print(gcd, lcm)\n", "perturbed_sampled": ["import  in sys.stdin: a, b = map(int, line.split()) gcd = math.gcd(a, b) lcm = (a * b) // gcd print(gcd, lcm)"], "perturbed_original": ["import math try: while 1: a,b=map(int,input().split()) print(math.gcd(a,b),a*b// math.gcd(a, b)) except: pass"], "original_ll": -1.8181451559066772, "sampled_ll": -0.8229323029518127, "all_perturbed_sampled_ll": [-2.0604329109191895], "all_perturbed_original_ll": [-1.9051802158355713], "perturbed_sampled_ll": -2.0604329109191895, "perturbed_original_ll": -1.9051802158355713, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio,h>\n#include<string.h>\nint main(){\nchar a[20];\nint l,i;\nscanf(\"%s\",a);\nl=strlen(a);\nfor(i=l-1;i>=0;i--)\nprintf(\"%c\",a[i]);\nreturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[21];\n    scanf(\"%s\", str);\n    int len = strlen(str);\n    for (int i = len - 1; i >= 0; i--) {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n", "perturbed_sampled": [" main() { char str[21];  strlen(str); for (int i = len - 1; i >= 0; i--) { printf(\"%c\", str[i]); } printf(\"\\n\"); return 0; }"], "perturbed_original": ["#include<stdio,h> #include<string.h> int main(){ char a[20]; int l,i; scanf(\"%s\",a); l=strlen(a); for(i=l-1;i>=0;i--) printf(\"%c\",a[i]); return 0; }"], "original_ll": -1.330481767654419, "sampled_ll": -0.5266357064247131, "all_perturbed_sampled_ll": [-1.4130553007125854], "all_perturbed_original_ll": [-1.334055781364441], "perturbed_sampled_ll": -1.4130553007125854, "perturbed_original_ll": -1.334055781364441, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n    public static void main (String [] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        char [] str = sc.next().toCharArray();\n        for(int x = str.length-1; x >= 0; x--) {\n            System.out.print(str[x]);\n        }\n\n        System.out.print(\"\\n\");\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        StringBuilder sb = new StringBuilder(str);\n        System.out.println(sb.reverse().toString());\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[]  new Scanner(System.in); String str = sc.next(); StringBuilder sb = new StringBuilder(str); System.out.println(sb.reverse().toString()); sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main { public static void main (String [] args) { Scanner sc = new Scanner(System.in); char [] str = sc.next().toCharArray();  >= 0;  } }"], "original_ll": -1.0031317472457886, "sampled_ll": -0.6778625845909119, "all_perturbed_sampled_ll": [-1.70175039768219], "all_perturbed_original_ll": [-1.9277304410934448], "perturbed_sampled_ll": -1.70175039768219, "perturbed_original_ll": -1.9277304410934448, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "print(input()[::-1])\n", "sampled": "s = input()\nprint(s[::-1])\n", "perturbed_sampled": ["s = input() print(s[::-1])"], "perturbed_original": ["print(input()[::-1])"], "original_ll": -5.913525104522705, "sampled_ll": -3.0255022048950195, "all_perturbed_sampled_ll": [-4.4134721755981445], "all_perturbed_original_ll": [-5.304867267608643], "perturbed_sampled_ll": -4.4134721755981445, "perturbed_original_ll": -5.304867267608643, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(){\n    int n,a=100000; scanf(\"%d\",&n);\n    while(n--){\n        a*=1.05;\n        if(a%1000>0) a=(a/1000+1)*1000;\n        else        a=a/1000*1000;\n    }\n    printf(\"%d\\n\",a);\n    exit(0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int debt = 100000;\n    \n    for (int i = 0; i < n; i++) {\n        debt = debt * 105 / 100;\n        if (debt % 1000 != 0) {\n            debt = (debt / 1000 + 1) * 1000;\n        }\n    }\n    \n    printf(\"%d\\n\", debt);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n); int debt  = 0; i < n; i++) {  / 100; if (debt % 1000 != 0) { debt =  * 1000; } } printf(\"%d\\n\", debt); return 0; }"], "perturbed_original": ["main(){ int n,a=100000; scanf(\"%d\",&n); while(n--){ a*=1.05; if(a%1000>0) a=(a/1000+1)*1000; else a=a/1000*1000; } printf(\"%d\\n\",a); exit(0); }"], "original_ll": -1.2363612651824951, "sampled_ll": -0.6074500679969788, "all_perturbed_sampled_ll": [-1.7683266401290894], "all_perturbed_original_ll": [-1.095949411392212], "perturbed_sampled_ll": -1.7683266401290894, "perturbed_original_ll": -1.095949411392212, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tdouble sum = 100000;   //????????????10??????\n\t\tint ??? = 0;\t\t\t//?????????????????\u00b1???\n\n\t\t??? = Integer.parseInt(br.readLine());\n\n\t\tfor(int i = 0; i < ???; i++){\n\t\t\tsum = sum * 1.05;\n\t\t\tsum = sum / 1000;\n\t\t\tsum = Math.ceil(sum) * 1000;\n\t\t}\n\n\t\tSystem.out.println(sum);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        long debt = 100000;\n        \n        for (int i = 0; i < n; i++) {\n            debt = (long) Math.ceil(debt * 1.05 / 1000.0) * 1000;\n        }\n        \n        System.out.println(debt);\n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); long debt = 100000; for (int i  i++) { debt = (long)  * 1000; } System.out.println(debt); sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class  main(String[] args) throws IOException{ BufferedReader br  sum = 100000; //????????????10?????? int ???  Integer.parseInt(br.readLine()); for(int i = 0; i < ???; i++){ sum = sum * 1.05; sum = sum / 1000; sum = Math.ceil(sum) * 1000; } System.out.println(sum); } }"], "original_ll": -1.1549588441848755, "sampled_ll": -0.6625598073005676, "all_perturbed_sampled_ll": [-1.525273323059082], "all_perturbed_original_ll": [-1.763213872909546], "perturbed_sampled_ll": -1.525273323059082, "perturbed_original_ll": -1.763213872909546, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "x = 100000\nfor i in range(int(input())):\n    x*=1.05\n    x+=999\n    x=x//1000*1000\nprint(x)", "sampled": "import math\n\nn = int(input())\ndebt = 100000\n\nfor _ in range(n):\n    debt = debt * 1.05\n    debt = math.ceil(debt / 1000) * 1000\n\nprint(int(debt))\n", "perturbed_sampled": [" debt = 100000 for _ in range(n): debt = debt * 1.05 debt = math.ceil(debt / 1000) * 1000 print(int(debt))"], "perturbed_original": ["x = 100000 for i in range(int(input())): x*=1.05 x+=999 x=x//1000*1000 print(x)"], "original_ll": -1.5169026851654053, "sampled_ll": -1.1356412172317505, "all_perturbed_sampled_ll": [-1.5901484489440918], "all_perturbed_original_ll": [-2.062117099761963], "perturbed_sampled_ll": -1.5901484489440918, "perturbed_original_ll": -2.062117099761963, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n \n#define MAX 1000000\n \nchar Prime[MAX];\n \nvoid PrimeSearch_Eratos( void ) //\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\n{\n    int i = 0, j = 0;\n \n    for( i = 0 ; i < MAX ; i ++ ) Prime[i] = 1;\n \n    Prime[0] = 0;\n    Prime[1] = 0;\n \n    for( i = 2 ; i <= sqrt( ( double )MAX ) + 1 ; i ++ ) //double\u306b\u30ad\u30e3\u30b9\u30c8\u3057\u306a\u3044\u3068\n    {                                                   //\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u304c\u306a\u3093\u305f\u3089\n        if( !Prime[i] ) continue;                       //\uff08\u3000\u309c\u0434\u309c\uff09\u30dd\u30ab\u30f3\n \n        for( j = i * 2 ; j <= MAX ; j += i )\n        {\n            Prime[j] = 0;\n        }\n    }\n \n    return ;\n}\n \nint main( void )\n{\n    int n = 0;\n \n    PrimeSearch_Eratos();\n \n    while( scanf( \"%d\", &n ) != EOF )\n    {\n        int i = 0;\n        int Count = 0;\n \n        for( i = 0 ; i <= n ; i ++ )\n        {\n            if( Prime[i] ) Count ++;\n        }\n \n        printf( \"%d\\n\", Count );\n    }\n \n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX 1000000\n\nint is_prime[MAX];\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int prime_count[MAX];\n    prime_count[0] = 0;\n    for (int i = 1; i < MAX; i++) {\n        prime_count[i] = prime_count[i-1] + is_prime[i];\n    }\n    \n    int n;\n    while (scanf(\"%d\", &n) != EOF) {\n        printf(\"%d\\n\", prime_count[n]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include  is_prime[MAX]; void sieve() { memset(is_prime, 1, sizeof(is_prime)); is_prime[0] = is_prime[1] =  2; i * i < MAX; i++) { if (is_prime[i])  i * i; j <  is_prime[j] = 0; } } }  int prime_count[MAX]; prime_count[0] = 0; for (int i = 1; i < MAX; i++) { prime_count[i] = prime_count[i-1] + is_prime[i]; } int n; while (scanf(\"%d\", &n) != EOF) { printf(\"%d\\n\", prime_count[n]); } return 0; }"], "perturbed_original": ["#include <stdio.h>  char Prime[MAX]; void PrimeSearch_Eratos( void ) //\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9 { int i = 0, j = 0; for( i = 0 ; i < MAX ; i ++ ) Prime[i] = 1; Prime[0]  for( i =  + 1 ; i ++ ) //double\u306b\u30ad\u30e3\u30b9\u30c8\u3057\u306a\u3044\u3068 {  //\uff08 \u309c\u0434\u309c\uff09\u30dd\u30ab\u30f3 for( j = i * 2 ; j <= MAX ; j += i  } } return ;  { int n = 0; PrimeSearch_Eratos(); while( scanf( \"%d\", &n ) != EOF ) { int i = 0; int Count = 0; for( i = 0 ; i <= n ; i ++ ) { if( Prime[i] ) Count ++; } printf(  0; }"], "original_ll": -1.041551113128662, "sampled_ll": -0.3592725992202759, "all_perturbed_sampled_ll": [-1.289115309715271], "all_perturbed_original_ll": [-2.1581647396087646], "perturbed_sampled_ll": -1.289115309715271, "perturbed_original_ll": -2.1581647396087646, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = in.readLine();\n\t\twhile (line != null) {\n\t\t\tStringTokenizer tk = new StringTokenizer(line);\n\t\t\tint n = Integer.parseInt(tk.nextToken());\n\t\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\t\tfor(int i = 2; i <= n; i++) {\n\t\t\t\tqueue.add(i);\n\t\t\t}\n\t\t\tint p = queue.remove();\n\t\t\tqueue.add(p);\n\t\t\tdo {\n\t\t\t\twhile (queue.element() != p) {\n\t\t\t\t\tint temp = queue.remove();\n\t\t\t\t\tif (temp % p != 0) {\n\t\t\t\t\t\tqueue.add(temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tqueue.add(queue.remove());\n\t\t\t\tp = queue.remove();\n\t\t\t\tqueue.add(p);\n\t\t\t} while (p != 2);\n\t\t\t\n\t\t\tint length = 0;\n\t\t\twhile (!queue.isEmpty()){\n\t\t\t\tlength ++;\n\t\t\t\tqueue.remove();\n\t\t\t}\n\t\t\tSystem.out.println(length);\n\t\t\tline = in.readLine();\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    private static final int MAX = 1000000;\n    private static boolean[] isPrime;\n    private static int[] primeCount;\n    \n    static {\n        isPrime = new boolean[MAX + 1];\n        primeCount = new int[MAX + 1];\n        \n        // Sieve of Eratosthenes\n        for (int i = 2; i <= MAX; i++) {\n            isPrime[i] = true;\n        }\n        \n        for (int i = 2; i * i <= MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= MAX; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        // Precompute prime counts\n        int count = 0;\n        for (int i = 0; i <= MAX; i++) {\n            if (i >= 2 && isPrime[i]) {\n                count++;\n            }\n            primeCount[i] = count;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            System.out.println(primeCount[n]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  private static final int MAX = 1000000; private static boolean[] isPrime; private static int[] primeCount; static { isPrime = new boolean[MAX + 1]; primeCount =  Sieve of Eratosthenes for (int i  i++) { isPrime[i] = true; } for (int i = 2; i * i <=  { for (int j = i * i; j <= MAX; j  false;  prime counts int count = 0; for (int i = 0; i <= MAX; i++) { if (i >=  } primeCount[i] = count; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextInt()) { int n  } }"], "perturbed_original": ["import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String line = in.readLine(); while (line != null) { StringTokenizer tk  = Integer.parseInt(tk.nextToken()); Queue<Integer> queue = new LinkedList<Integer>(); for(int i =   =  (queue.element() != p)  if (temp  queue.add(temp); } } queue.add(queue.remove()); p = queue.remove(); queue.add(p); } while (p != 2); int length = 0; while (!queue.isEmpty()){ length ++; queue.remove(); } System.out.println(length); line = in.readLine(); } } }"], "original_ll": -0.7013206481933594, "sampled_ll": -0.363680362701416, "all_perturbed_sampled_ll": [-1.6086363792419434], "all_perturbed_original_ll": [-1.7266939878463745], "perturbed_sampled_ll": -1.6086363792419434, "perturbed_original_ll": -1.7266939878463745, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nimport sys\n\nlst=[0 for _ in xrange(999999+1)]\n\ndef is_prime(num):\n  if num%2==0:\n      return 0\n  for x in range(3, int(num**0.5)+1,2):\n    if num % x==0:\n        return 0\n  return 1\n\nlst[1]=0\nlst[2]=1\nfor idx in range(3, len(lst)):\n  lst[idx] = is_prime(idx) + lst[idx-1]\n\nfor line in sys.stdin:\n  print lst[int(line)]", "sampled": "def sieve_of_eratosthenes(limit):\n    if limit < 2:\n        return []\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\nmax_n = 999999\nis_prime = sieve_of_eratosthenes(max_n)\nprime_count = [0] * (max_n + 1)\n\ncount = 0\nfor i in range(max_n + 1):\n    if is_prime[i]:\n        count += 1\n    prime_count[i] = count\n\nimport sys\nfor line in sys.stdin:\n    n = int(line.strip())\n    print(prime_count[n])\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): if limit < 2: return [] is_prime = [True]  = is_prime[1] = False for i in range(2, int(limit**0.5) + 1): if is_prime[i]: for j in range(i*i, limit +  return  = sieve_of_eratosthenes(max_n) prime_count = [0] * (max_n + 1) count = 0 for i in  count += 1 prime_count[i] = count import sys for line in sys.stdin: n = int(line.strip()) print(prime_count[n])"], "perturbed_original": ["import math import sys  def is_prime(num): if num%2==0: return  int(num**0.5)+1,2): if num % x==0: return 0 return 1 lst[1]=0 lst[2]=1 for idx in range(3, len(lst)): lst[idx] = is_prime(idx) + lst[idx-1] for line in sys.stdin: print lst[int(line)]"], "original_ll": -1.1764311790466309, "sampled_ll": -0.5249384641647339, "all_perturbed_sampled_ll": [-1.3480459451675415], "all_perturbed_original_ll": [-2.2059969902038574], "perturbed_sampled_ll": -1.3480459451675415, "perturbed_original_ll": -2.2059969902038574, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nint main(int argc, const char * argv[])\n{\n\n    double x1, y1, x2, y2, x3, y3;\n    double midx1, midx2, midy1, midy2;\n    double circlex, circley;\n    double slant1, slant2;\n    double slice1, slice2;\n    double radius;\n    int i;\n    int input;\n    \n    scanf(\"%d\", &input);\n    for (i = 0; i < input; i++) {\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3);\n        midx1 = (x1 + x2) / 2;\n        midy1 = (y1 + y2) / 2;\n        midx2 = (x1 + x3) / 2;\n        midy2 = (y1 + y3) / 2;\n        slant1 = - (x2 - x1) / (y2 - y1);\n        slant2 = - (x3 - x1) / (y3 - y1);\n        slice1 = midy1 - slant1 * midx1;\n        slice2 = midy2 - slant2 * midx2;\n        circlex = (slice2 - slice1) / (slant1 - slant2);\n        circley = slant1 * circlex + slice1;\n        \n        if (x2 == x1) {\n            circley = midy1;\n            circlex = (circley - slice2) / slant2;\n        }\n        else if (y2 == y1) {\n            circlex = midx1;\n            circley = slant2 * circlex + slice2;\n        }\n        if(x3 == x1) {\n            circley = midy2;\n            circlex = (circley - slice1) / slant1;\n        }\n        else if (y3 == y1) {\n            circlex = midx2;\n            circley = slant1 * circlex + slice1;\n        }\n        if (x2 == x1 && y3 == y1) {\n            circley = midy1;\n            circlex = midx2;\n        }\n        else if (x3 == x1 && y2 == y1){\n            circley = midy2;\n            circlex = midx1;\n        }\n        radius = sqrt((circlex - x1) * (circlex - x1) + (circley - y1) * (circley - y1));\n        printf(\"%0.3f %0.3f %0.3f\\n\", circlex, circley, radius);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        double x1, y1, x2, y2, x3, y3;\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3);\n        \n        double a = 2 * (x2 - x1);\n        double b = 2 * (y2 - y1);\n        double c = x2 * x2 - x1 * x1 + y2 * y2 - y1 * y1;\n        \n        double d = 2 * (x3 - x1);\n        double e = 2 * (y3 - y1);\n        double f = x3 * x3 - x1 * x1 + y3 * y3 - y1 * y1;\n        \n        double px = (c * e - b * f) / (a * e - b * d);\n        double py = (a * f - c * d) / (a * e - b * d);\n        \n        double r = sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));\n        \n        printf(\"%.3f %.3f %.3f\\n\", px, py, r);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int n; scanf(\"%d\", &n); while (n--) { double x1, y1, x2, y2, x3, y3; scanf(\"%lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3); double a = 2 * (x2 - x1); double b = 2 * (y2 - y1); double c = x2  x1 + y2 * y2 - y1 * y1; double d = 2 * (x3 - x1); double e = 2  x3 - x1 *  double px = (c * e  (a * e - b * d); double py = (a * f - c * d) / (a * e - b *   x1) + (py - y1) * (py -  py, r); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> int main(int argc, const char * argv[]) { double x1, y1, x2, y2, x3, y3; double midx1, midx2, midy1, midy2; double circlex, circley; double slant1, slant2;   0; i < input; i++) { scanf(\"%lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3); midx1 = (x1 + x2) / 2; midy1 = (y1 + y2) / 2; midx2 = (x1 + x3)  + y3) / 2; slant1 = - (x2 -  slant2 = - (x3 - x1) / (y3 - y1);  * midx1; slice2 = midy2 - slant2 * midx2;  / (slant1 - slant2); circley = slant1 * circlex + slice1; if (x2 == x1)  = (circley - slice2) / slant2; } else  circlex = midx1; circley = slant2 * circlex + slice2;  circley = midy2; circlex = (circley - slice1) / slant1; } else if (y3 == y1) { circlex = midx2; circley =  } if (x2 == x1 && y3  } else if (x3 == x1 && y2 == y1){ circley = midy2; circlex = midx1; } radius = sqrt((circlex - x1) * (circlex - x1) + (circley - y1) *  } return 0; }"], "original_ll": -0.4801560938358307, "sampled_ll": -0.2777218520641327, "all_perturbed_sampled_ll": [-1.2520084381103516], "all_perturbed_original_ll": [-1.1507292985916138], "perturbed_sampled_ll": -1.2520084381103516, "perturbed_original_ll": -1.1507292985916138, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tint n;\n\t\tdouble x1,x2,x3,y1,y2,y3,xp,yp,r,a1,a2,b1,b2,c1,c2,a,b;\n\t\tn=s.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx1=s.nextDouble();\n\t\t\ty1=s.nextDouble();\n\t\t\tx2=s.nextDouble();\n\t\t\ty2=s.nextDouble();\n\t\t\tx3=s.nextDouble();\n\t\t\ty3=s.nextDouble();\n\t\t\t\n\t\t\ta1=2*(x1-x2);//a\n\t\t\tb1=2*(y1-y2);//b\n\t\t\t//c\n\t\t\tc1=(x1*x1)-(x2*x2)+(y1*y1)-(y2*y2);\n\t\t\ta2=2*(x2-x3);//d\n\t\t\tb2=2*(y2-y3);//e\n\t\t\tc2=(x2*x2)-(x3*x3)+(y2*y2)-(y3*y3);\n\t\t\t\n\t\t\tif(c1*b2-b1*c2==0 ||a1*b2-a2*b1==0)xp=0;\n\t\t\telse\n\t\t\txp=(c1*b2-b1*c2)/(a1*b2-a2*b1);\n\t\t\tif(c1*a2-c2*a1==0 ||a2*b1-a1*b2==0)yp=0;\n\t\t\telse\n\t\t\typ=(c1*a2-c2*a1)/(a2*b1-a1*b2);\n\t\t\t\n\t\t\ta=xp-x1;\n\t\t\ta=a*a;\n\t\t\tb=yp-y1;\n\t\t\tb=b*b;\n\t\t\tr=Math.sqrt(a+b);\n\t\t\tif(r==0)\n\t\t\t\tr=0;\n\t\t\tSystem.out.printf(\"%.3f %.3f %.3f\\n\",xp,yp,r);\n\t\t}//for\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double x1 = sc.nextDouble();\n            double y1 = sc.nextDouble();\n            double x2 = sc.nextDouble();\n            double y2 = sc.nextDouble();\n            double x3 = sc.nextDouble();\n            double y3 = sc.nextDouble();\n            \n            double a = 2 * (x2 - x1);\n            double b = 2 * (y2 - y1);\n            double c = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2;\n            \n            double d = 2 * (x3 - x1);\n            double e = 2 * (y3 - y1);\n            double f = x1 * x1 - x3 * x3 + y1 * y1 - y3 * y3;\n            \n            double px = (b * f - e * c) / (b * d - e * a);\n            double py = (d * c - a * f) / (b * d - e * a);\n            \n            double r = Math.sqrt((x1 - px) * (x1 - px) + (y1 - py) * (y1 - py));\n            \n            System.out.printf(\"%.3f %.3f %.3f\\n\", px, py, r);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main {  { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i  x1 = sc.nextDouble(); double y1 = sc.nextDouble(); double x2 = sc.nextDouble(); double y2 = sc.nextDouble(); double x3 = sc.nextDouble();  a = 2 * (x2 - x1); double b = 2 *  = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2; double  - x1); double e = 2 * (y3 - y1); double f = x1 * x1 -  * y1 - y3 * y3; double px = (b * f - e * c) / (b * d - e  (d * c  (b * d - e * a); double r = Math.sqrt((x1 - px) * (x1 - px) + (y1  py));  }"], "perturbed_original": ["import java.util.Scanner; public class Main { public  n; double x1,x2,x3,y1,y2,y3,xp,yp,r,a1,a2,b1,b2,c1,c2,a,b; n=s.nextInt(); for(int i=0;i<n;i++){ x1=s.nextDouble(); y1=s.nextDouble(); x2=s.nextDouble(); y2=s.nextDouble(); x3=s.nextDouble(); y3=s.nextDouble(); a1=2*(x1-x2);//a b1=2*(y1-y2);//b //c c1=(x1*x1)-(x2*x2)+(y1*y1)-(y2*y2); a2=2*(x2-x3);//d b2=2*(y2-y3);//e c2=(x2*x2)-(x3*x3)+(y2*y2)-(y3*y3); if(c1*b2-b1*c2==0 ||a1*b2-a2*b1==0)xp=0; else xp=(c1*b2-b1*c2)/(a1*b2-a2*b1); if(c1*a2-c2*a1==0 ||a2*b1-a1*b2==0)yp=0;  b=b*b; r=Math.sqrt(a+b); if(r==0) r=0; System.out.printf(\"%.3f %.3f %.3f\\n\",xp,yp,r); }//for } }"], "original_ll": -0.6433263421058655, "sampled_ll": -0.2965103089809418, "all_perturbed_sampled_ll": [-1.4139735698699951], "all_perturbed_original_ll": [-1.0848106145858765], "perturbed_sampled_ll": -1.4139735698699951, "perturbed_original_ll": -1.0848106145858765, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# coding: utf-8\n\nimport math\n\nn = int(raw_input())\n\nfor i in range(n):\n\tdata = map(float, raw_input().split())\n\tx1 = data[0]\n\ty1 = data[1]\n\tx2 = data[2]\n\ty2 = data[3]\n\tx3 = data[4]\n\ty3 = data[5]\n\n\tk = 0.5 * ( (x3-x2)*(x3-x1) + (y3-y2)*(y3-y1) ) / ( (x2-x1)*(y3-y1) + (y2-y1)*(x3-x1) )\n\n\tx = 0.5 * (x1 + x2) - k * (y2 - y1)\n\ty = 0.5 * (y1 + y2) + k * (x2 - x1)\n\n\tr = math.sqrt( (x-x1)**2 + (y-y1)**2 )\n\n\tprint(\"{:.3f} {:.3f} {:.3f}\".format(x,y,r))", "sampled": "import math\n\ndef circumcircle(x1, y1, x2, y2, x3, y3):\n    # Calculate D (denominator)\n    D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    \n    # Calculate center coordinates\n    ux = ((x1**2 + y1**2) * (y2 - y3) + (x2**2 + y2**2) * (y3 - y1) + (x3**2 + y3**2) * (y1 - y2)) / D\n    uy = ((x1**2 + y1**2) * (x3 - x2) + (x2**2 + y2**2) * (x1 - x3) + (x3**2 + y3**2) * (x2 - x1)) / D\n    \n    # Calculate radius\n    r = math.sqrt((x1 - ux)**2 + (y1 - uy)**2)\n    \n    return ux, uy, r\n\nn = int(input())\nfor _ in range(n):\n    coords = list(map(float, input().split()))\n    x1, y1, x2, y2, x3, y3 = coords\n    px, py, r = circumcircle(x1, y1, x2, y2, x3, y3)\n    print(f\"{px:.3f} {py:.3f} {r:.3f}\")\n", "perturbed_sampled": ["import math def circumcircle(x1, y1, x2, y2, x3, y3): # Calculate D (denominator) D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) #  ((x1**2  y3) +   y3**2) * (y1 - y2)) / D uy = ((x1**2 + y1**2) * (x3 - x2) + (x2**2 +  + (x3**2  Calculate radius r = math.sqrt((x1 - ux)**2 + (y1 - uy)**2) return ux, uy, r n = int(input()) for _ in range(n): coords =  y2, x3, y3 = coords px, py, r = circumcircle(x1, y1, x2, y2, x3, y3) print(f\"{px:.3f} {py:.3f} {r:.3f}\")"], "perturbed_original": ["# coding: utf-8 import math n = int(raw_input()) for i in range(n): data = map(float, raw_input().split()) x1 = data[0] y1 = data[1] x2 = data[2] y2 = data[3] x3 = data[4] y3  (y3-y2)*(y3-y1) ) / ( (x2-x1)*(y3-y1)  0.5 * (x1 + x2) - k * (y2 - y1)  + y2)  x1) r = math.sqrt( (x-x1)**2 + (y-y1)**2 ) print(\"{:.3f} {:.3f} {:.3f}\".format(x,y,r))"], "original_ll": -0.6321696639060974, "sampled_ll": -0.3487136662006378, "all_perturbed_sampled_ll": [-1.3657137155532837], "all_perturbed_original_ll": [-1.3507871627807617], "perturbed_sampled_ll": -1.3657137155532837, "perturbed_original_ll": -1.3507871627807617, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid swap(int *a, int *b){\n  int t=*a;*a=*b;*b=t;\n}\n\nint main(void){\n  int w,n,i,l[31];\n  scanf(\"%d\\n\",&w);\n  scanf(\"%d\\n\",&n);\n  for(i=1;i<=w;i++){\n    l[i]=i;\n  }\n  for(i=0;i<n;i++) {\n    int a,b;\n    scanf(\"%d,%d\\n\",&a,&b);\n    swap(&l[a],&l[b]);\n  }\n  for(i=1;i<=w;i++){\n    printf(\"%d\\n\", l[i]);\n  }\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int w, n;\n    int lines[31];\n    \n    scanf(\"%d\", &w);\n    scanf(\"%d\", &n);\n    \n    // Initialize vertical lines with numbers 1 to w\n    for (int i = 1; i <= w; i++) {\n        lines[i] = i;\n    }\n    \n    // Process each horizontal line\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        scanf(\"%d,%d\", &a, &b);\n        \n        // Swap the values at positions a and b\n        int temp = lines[a];\n        lines[a] = lines[b];\n        lines[b] = temp;\n    }\n    \n    // Print the final state\n    for (int i = 1; i <= w; i++) {\n        printf(\"%d\\n\", lines[i]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int w, n; int lines[31]; scanf(\"%d\", &w); scanf(\"%d\", &n); // Initialize vertical lines with numbers 1 to w for (int i = 1; i <= w; i++) { lines[i] = i; } //  i < n; i++) { int a,  Swap the values at positions a and b int temp  lines[b] = temp; } // Print the final state for (int i = 1; i <= w; i++) { printf(\"%d\\n\", lines[i]); } return 0; }"], "perturbed_original": ["#include <stdio.h> void swap(int *a, int *b){ int t=*a;*a=*b;*b=t; } int main(void){  l[i]=i; } for(i=0;i<n;i++) { int a,b; scanf(\"%d,%d\\n\",&a,&b); swap(&l[a],&l[b]); } for(i=1;i<=w;i++){ printf(\"%d\\n\", l[i]); } return 0; }"], "original_ll": -0.8598865866661072, "sampled_ll": -0.6135058999061584, "all_perturbed_sampled_ll": [-1.662362813949585], "all_perturbed_original_ll": [-1.4597591161727905], "perturbed_sampled_ll": -1.662362813949585, "perturbed_original_ll": -1.4597591161727905, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class AOJ3_3{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint w = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tint[] values = new int[w];\n\t\tfor(int i=0;i<values.length;i++){\n\t\t\tvalues[i] = i + 1;\n\t\t}\n\t\tfor(int i = 0;i<n;i++){\n\t\t\tString str = sc.next();\n\t\t\tString[] ab = str.split(\",\");\n\t\t\tint a = Integer.parseInt(ab[0]) -1;\n\t\t\tint b = Integer.parseInt(ab[1]) -1;\n\t\t\tint temp = values[a];\n\t\t\tvalues[a] = values[b];\n\t\t\tvalues[b] = temp;\n\t\t}\n\t\tfor(int i = 0;i<w;i++){\n\t\t\tSystem.out.println(values[i]);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System);\n        \n        int w = sc.nextInt();\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        int[] lines = new int[w + 1];\n        for (int i = 1; i <= w; i++) {\n            lines[i] = i;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            \n            int temp = lines[a];\n            lines[a] = lines[b];\n            lines[b] = temp;\n        }\n        \n        for (int i = 1; i <= w; i++) {\n            System.out.println(lines[i]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  void main(String[] args) { Scanner sc = new Scanner(System); int w = sc.nextInt(); int n = sc.nextInt();  int[w + 1]; for (int i = 1; i <= w; i++) { lines[i] = i;  i++) { String line = sc.nextLine(); String[] parts = line.split(\",\"); int a = Integer.parseInt(parts[0]); int b = Integer.parseInt(parts[1]); int temp = lines[a]; lines[a] = lines[b]; lines[b] = temp; } for (int i = 1;  System.out.println(lines[i]); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class AOJ3_3{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int w = sc.nextInt();  values = new int[w]; for(int i=0;i<values.length;i++){ values[i] = i + 1; } for(int i = 0;i<n;i++){ String str = sc.next(); String[] ab = str.split(\",\"); int  b  = values[a]; values[a] = values[b]; values[b] =  0;i<w;i++){ System.out.println(values[i]); } } }"], "original_ll": -0.7398730516433716, "sampled_ll": -0.4858931005001068, "all_perturbed_sampled_ll": [-1.3317598104476929], "all_perturbed_original_ll": [-1.6994106769561768], "perturbed_sampled_ll": -1.3317598104476929, "perturbed_original_ll": -1.6994106769561768, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\n\ndef solve(w, n):\n    l = [i for i in range(1, w+1)]\n    for _ in range(n):\n        a, b = map(int, input().split(','))\n        l[a], l[b] = l[b], l[a]\n\n    print(*l, sep='\\n')\n\nif __name__ == '__main__':\n    w = int(input())\n    n = int(input())\n    solve(w, n)", "sampled": "w = int(input())\nn = int(input())\n\n# Initialize positions: position[i] = number at position i (0-indexed)\npositions = list(range(1, w + 1))\n\n# Process each horizontal line\nfor _ in range(n):\n    line = input().strip()\n    a, b = map(int, line.split(','))\n    # Swap the numbers at positions a-1 and b-1 (converting to 0-indexed)\n    positions[a-1], positions[b-1] = positions[b-1], positions[a-1]\n\n# Output the final positions\nfor num in positions:\n    print(num)\n", "perturbed_sampled": [" int(input()) # Initialize positions:  i (0-indexed) positions =  Process each horizontal line for _ in range(n): line = input().strip() a, b = map(int, line.split(',')) # Swap the numbers at positions a-1 and b-1 (converting to 0-indexed) positions[a-1], positions[b-1] = positions[b-1], positions[a-1] # Output the final positions for num in positions: print(num)"], "perturbed_original": ["# -*- coding: utf-8 -*- def solve(w, n): l = [i for i in range(1, w+1)] for _ in range(n): a, b   if __name__ == '__main__': w = int(input()) n = int(input()) solve(w, n)"], "original_ll": -0.9040843844413757, "sampled_ll": -1.1207647323608398, "all_perturbed_sampled_ll": [-2.0265424251556396], "all_perturbed_original_ll": [-1.7692551612854004], "perturbed_sampled_ll": -2.0265424251556396, "perturbed_original_ll": -1.7692551612854004, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main() {\n\tint i = 0, k = 0, n, car[100] = {0}, out[100] = {0};\n\twhile(scanf(\"%d\", &n)!= EOF) {\n\t\tif(n == 0) {\n\t\t\ti--;\n\t\t\tout[k] = car[i];\n\t\t\tk++;\n\t\t} else {\n\t\t\tcar[i] = n;\n\t\t\ti++;\n\t\t}\n\t}\n\tfor(i = 0; i < k; i++) printf(\"%d\\n\", out[i]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int stack[100];\n    int top = -1;\n    int input;\n    \n    while (scanf(\"%d\", &input) != EOF) {\n        if (input == 0) {\n            printf(\"%d\\n\", stack[top]);\n            top--;\n        } else {\n            top++;\n            stack[top] = input;\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int stack[100]; int top = -1; int input; while (scanf(\"%d\", &input) != EOF) { if (input == 0)  else { top++;  return 0; }"], "perturbed_original": ["#include <stdio.h> int main() { int i = 0, k = 0, n,  {0}; while(scanf(\"%d\", &n)!= EOF) { if(n == 0) { i--; out[k] =  car[i] = n; i++;  i < k; i++) printf(\"%d\\n\", out[i]); return 0; }"], "original_ll": -0.9140048027038574, "sampled_ll": -0.6154360175132751, "all_perturbed_sampled_ll": [-1.6549696922302246], "all_perturbed_original_ll": [-2.3706233501434326], "perturbed_sampled_ll": -1.6549696922302246, "perturbed_original_ll": -2.3706233501434326, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n \npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        Stack<Integer> stack = new Stack<Integer>();\n        while(sc.hasNextInt()){\n            int a=sc.nextInt();\n            if(a==0){\n                System.out.println(stack.pop());\n            }else{\n                stack.push(a);\n            }\n        }\n    }\n}", "sampled": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Stack<Integer> stack = new Stack<>();\n        \n        while (sc.hasNext()) {\n            int num = sc.nextInt();\n            if (num == 0) {\n                System.out.println(stack.pop());\n            } else {\n                stack.push(num);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  { public static void main(String[] args) { Scanner sc = new Scanner(System.in); Stack<Integer> stack = new Stack<>(); while (sc.hasNext()) { int num = sc.nextInt(); if (num == 0) { System.out.println(stack.pop()); }  sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); Stack<Integer> stack = new Stack<Integer>(); while(sc.hasNextInt()){ int a=sc.nextInt(); if(a==0){ System.out.println(stack.pop());  }"], "original_ll": -0.7556572556495667, "sampled_ll": -0.43813303112983704, "all_perturbed_sampled_ll": [-1.4164958000183105], "all_perturbed_original_ll": [-1.209929347038269], "perturbed_sampled_ll": -1.4164958000183105, "perturbed_original_ll": -1.209929347038269, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a = []\nwhile True:\n    s = int(input())\n    if s != 0:\n        a.append(s)\n    else:\n        print(a.pop())\n    if len(a) == 0:\n        break", "sampled": "import sys\n\nstack = []\nfor line in sys.stdin:\n    num = int(line.strip())\n    if num == 0:\n        print(stack.pop())\n    else:\n        stack.append(num)\n", "perturbed_sampled": ["import sys stack  sys.stdin: num = int(line.strip()) if num == 0: print(stack.pop()) else: stack.append(num)"], "perturbed_original": ["a = [] while True: s = int(input()) if s != 0:  == 0: break"], "original_ll": -1.2067081928253174, "sampled_ll": -1.1285371780395508, "all_perturbed_sampled_ll": [-3.12632155418396], "all_perturbed_original_ll": [-3.117880344390869], "perturbed_sampled_ll": -3.12632155418396, "perturbed_original_ll": -3.117880344390869, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main()\n{\n    int n, i;\n    long long int sum;\n    \n    while(scanf(\"%d\", &n) != EOF){\n    \tsum = 0;\n        for (i = n; i <= 600 - n; i += n){\n            sum += i * i;\n        }\n        sum *= n;\n        printf(\"%lld\\n\", sum);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int d;\n    while (scanf(\"%d\", &d) != EOF) {\n        long long area = 0;\n        for (int x = d; x <= 600 - d; x += d) {\n            area += (long long)d * x * x;\n        }\n        printf(\"%lld\\n\", area);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  (scanf(\"%d\", &d) != EOF) { long long area = 0; for (int x = d; x <= 600 - d; x +=  long)d * x * x; } printf(\"%lld\\n\", area); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main() { int n, i; long long int sum; while(scanf(\"%d\", &n) != EOF){  =  n; i += n){ sum += i * i; } sum *= n; printf(\"%lld\\n\", sum); } return 0; }"], "original_ll": -1.1410733461380005, "sampled_ll": -1.0447417497634888, "all_perturbed_sampled_ll": [-2.4999263286590576], "all_perturbed_original_ll": [-2.018991231918335], "perturbed_sampled_ll": -2.4999263286590576, "perturbed_original_ll": -2.018991231918335, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/**\n * \n * AOJ No. 0014 Integral\n * \n * @author \tyuichirw <y.iky917@gmail.com+>\n * @see\t\thttp://rose.u-aizu.ac.jp/onlinejudge/ProblemSet/description.jsp?id=0014&lang=jp\n */\n\nimport java.util.*;\npublic class Main {\n\t\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int d;\n\t\n\tstatic boolean read() {\n\t\tif(!sc.hasNextInt()) return false;\n\t\td = sc.nextInt();\n\t\treturn true;\n\t}\n\t\n\tstatic int solve() {\n\t\tint ans,n;\n\t\tans = 0; n = 600 / d;\n\t\tfor(int x = d; x < 600; x += d) {\n\t\t\tans += d * ((x * x));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int d = sc.nextInt();\n            long area = 0;\n            \n            for (int x = d; x < 600; x += d) {\n                area += (long) d * x * x;\n            }\n            \n            System.out.println(area);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while  sc.nextInt();  (int x = d; x < 600; x += d)  * x * x; } System.out.println(area); } sc.close(); } }"], "perturbed_original": ["/**  Integral * * @author  */ import java.util.*; public  sc = new Scanner(System.in); static int d; static boolean read() { if(!sc.hasNextInt()) return false; d =  int solve() { int ans,n; ans = 0; n = 600 / d; for(int x = d; x < 600; x += d) { ans += d * ((x * x)); } return ans; } public static void main(String[] args)  } }"], "original_ll": -1.6779203414916992, "sampled_ll": -0.8496086001396179, "all_perturbed_sampled_ll": [-2.1645281314849854], "all_perturbed_original_ll": [-2.3105599880218506], "perturbed_sampled_ll": -2.1645281314849854, "perturbed_original_ll": -2.3105599880218506, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\n\nimport sys\nimport math\n\ndef rectArea(h, w):\n    return h * w\n\n\nfor d in sys.stdin:\n    area = 0\n    d = int(d)\n    for i in range(0, 600, d):\n        area += rectArea(i*i, d)\n\n    print(area)", "sampled": "import sys\n\nfor line in sys.stdin:\n    d = int(line.strip())\n    s = 0\n    x = d\n    while x <= 600 - d:\n        s += d * (x * x)\n        x += d\n    print(s)\n", "perturbed_sampled": ["import sys for line in sys.stdin: d = int(line.strip()) s = 0 x = d while x  += d * (x * x) x += d print(s)"], "perturbed_original": ["#!/usr/bin/env python #-*- coding:utf-8 -*- import sys import math def rectArea(h, w): return h *  = int(d) for i in range(0, 600, d): area += rectArea(i*i, d) print(area)"], "original_ll": -1.5110434293746948, "sampled_ll": -1.6187463998794556, "all_perturbed_sampled_ll": [-2.860598087310791], "all_perturbed_original_ll": [-2.443805694580078], "perturbed_sampled_ll": -2.860598087310791, "perturbed_original_ll": -2.443805694580078, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\t__int64 a, b, sum;\n\tint keta;\n\tint n;\n\tint i;\n\t\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++){\n\t\tscanf(\"%I64u\", &a);\n\t\tscanf(\"%I64u\", &b);\n\t\tsum = a + b;\n\t\t\n\t\tketa = 1;\n\t\twhile (sum / 10 > 0){\n\t\t\tketa++;\n\t\t\tsum /= 10;\n\t\t}\n\t\t\n\t\tif (keta > 80){\n\t\t\tprintf(\"overflow\\n\");\n\t\t}\n\t\telse {\n\t\t\tsum = a + b;\n\t\t\tprintf(\"%I64u\\n\", sum);\n\t\t}\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid reverseString(char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        char temp = str[i];\n        str[i] = str[len - 1 - i];\n        str[len - 1 - i] = temp;\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    while (N--) {\n        char num1[105], num2[105], result[105];\n        scanf(\"%s %s\", num1, num2);\n        \n        int len1 = strlen(num1);\n        int len2 = strlen(num2);\n        \n        // Check if input has more than 80 digits\n        if (len1 > 80 || len2 > 80) {\n            printf(\"overflow\\n\");\n            continue;\n        }\n        \n        // Reverse the strings for easier addition\n        reverseString(num1);\n        reverseString(num2);\n        \n        int maxLen = (len1 > len2) ? len1 : len2;\n        int carry = 0;\n        int resultLen = 0;\n        \n        for (int i = 0; i < maxLen || carry; i++) {\n            int digit1 = (i < len1) ? (num1[i] - '0') : 0;\n            int digit2 = (i < len2) ? (num2[i] - '0') : 0;\n            \n            int sum = digit1 + digit2 + carry;\n            result[resultLen++] = (sum % 10) + '0';\n            carry = sum / 10;\n        }\n        \n        result[resultLen] = '\\0';\n        \n        // Check if result has more than 80 digits\n        if (resultLen > 80) {\n            printf(\"overflow\\n\");\n            continue;\n        }\n        \n        // Reverse result back\n        reverseString(result);\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  reverseString(char *str) {   i++) { char temp = str[i]; str[i] = str[len - 1 - i]; str[len - 1    { char num1[105], num2[105], result[105]; scanf(\"%s %s\", num1,  int len2  input has more than 80 digits if (len1 > 80 || len2 > 80) { printf(\"overflow\\n\"); continue; } // Reverse the strings for easier addition reverseString(num1); reverseString(num2); int maxLen = (len1 > len2) ? len1  0; int resultLen = 0; for (int i = 0; i < maxLen || carry; i++) { int digit1 = (i  '0') : 0; int digit2 = (i < len2) ? (num2[i] - '0') : 0; int sum =  result[resultLen++] = (sum % 10) + '0'; carry = sum / 10; } result[resultLen] = '\\0'; // Check if result has more than 80 digits if (resultLen > 80) { printf(\"overflow\\n\"); continue; } // Reverse result back reverseString(result); printf(\"%s\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> int );<extra_id_4>+ 1; fmt(\"%I64u\\n\", b);<extra_id_5>2; keta/=<extra_id_6>{<extra_id_7>keta/10> -10) { printf(\"%I64u\\n\",<extra_id_8>e* 10); } } if<extra_id_9>i ; } printf(\"%I64o\\n\",<extra_id_10>= b sum; int  scanf(\"%d\", &n); for (i = 0; i <  &b); sum = a + b; keta = 1; while (sum / 10 > 0){ keta++; sum /= 10; } if (keta > 80){ printf(\"overflow\\n\"); } else { sum = a + b; printf(\"%I64u\\n\",  }"], "original_ll": -0.926114559173584, "sampled_ll": -0.35227280855178833, "all_perturbed_sampled_ll": [-1.325465202331543], "all_perturbed_original_ll": [-2.602513551712036], "perturbed_sampled_ll": -1.325465202331543, "perturbed_original_ll": -2.602513551712036, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (sc.hasNext()) {\n\t\t\tString s1 = sc.next();\n\t\t\tString s2 = sc.next();\n\t\t\tif (s1.length() > 80 || s2.length() > 80)\n\t\t\t\tSystem.out.println(\"overflow\");\n\t\t\tBigInteger b = new BigInteger(s1).add(new BigInteger(s2));\n\t\t\tSystem.out.println(b.toString().length() > 80 ? \"overflow\" : b);\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\nimport java.math.BigInteger;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String a = sc.nextLine().trim();\n            String b = sc.nextLine().trim();\n            \n            if (a.length() > 80 || b.length() > 80) {\n                System.out.println(\"overflow\");\n                continue;\n            }\n            \n            BigInteger num1 = new BigInteger(a);\n            BigInteger num2 = new BigInteger(b);\n            BigInteger sum = num1.add(num2);\n            \n            String result = sum.toString();\n            if (result.length() > 80) {\n                System.out.println(\"overflow\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); for (int i = 0; i < n;  sc.nextLine().trim(); String b = sc.nextLine().trim(); if (a.length() > 80   = new BigInteger(a); BigInteger num2 =  num1.add(num2); String result = sum.toString(); if (result.length() > 80) { System.out.println(\"overflow\"); } else { System.out.println(result); } } sc.close(); } }"], "perturbed_original": ["import java.math.BigInteger; import java.util.Scanner; public class Main { public static  sc = new Scanner(System.in); while (sc.hasNext())  String s2 =  || s2.length() > 80) System.out.println(\"overflow\"); BigInteger b = new BigInteger(s1).add(new BigInteger(s2)); System.out.println(b.toString().length() > 80 ? \"overflow\" : b); } } }"], "original_ll": -0.7646723389625549, "sampled_ll": -0.449149489402771, "all_perturbed_sampled_ll": [-1.5260088443756104], "all_perturbed_original_ll": [-1.8744357824325562], "perturbed_sampled_ll": -1.5260088443756104, "perturbed_original_ll": -1.8744357824325562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = input()\n\nfor i in range(n):\n    a = input(),\n    b = input()\n    c = a + b\n    if len(a) > 80 or len(b) > 80 or len(c) > 80 :\n        print 'overflow'\n    else:\n        print a + b", "sampled": "N = int(input())\nfor _ in range(N):\n    a = input().strip()\n    b = input().strip()\n    \n    # Check if input integers have more than 80 digits\n    if len(a) > 80 or len(b) > 80:\n        print(\"overflow\")\n        continue\n    \n    # Convert to integers and calculate sum\n    num_a = int(a)\n    num_b = int(b)\n    result = num_a + num_b\n    \n    # Check if sum has more than 80 digits\n    if len(str(result)) > 80:\n        print(\"overflow\")\n    else:\n        print(result)\n", "perturbed_sampled": ["N = int(input()) for _ in range(N): a = input().strip() b = input().strip() # Check if input integers have  len(a) > 80 or len(b) > 80: print(\"overflow\") continue # Convert to integers and calculate sum num_a = int(a) num_b  than 80 digits if len(str(result)) > 80: print(\"overflow\") else: print(result)"], "perturbed_original": ["n = input() for i in range(n): a = input(), b = input()  if len(a) > 80 or len(b) > 80 or len(c) > 80 :  + b"], "original_ll": -1.420418381690979, "sampled_ll": -0.7767795324325562, "all_perturbed_sampled_ll": [-2.070793390274048], "all_perturbed_original_ll": [-2.2193660736083984], "perturbed_sampled_ll": -2.070793390274048, "perturbed_original_ll": -2.2193660736083984, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0016\nTresure hunt\n*/\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\ndouble x,y;\nint len,arg;\ndouble PAI=3.14159265;\n\nmain()\n{\n  x=0.0; y=0.0;\n  int argsum = 90; \n\n  while(EOF != scanf(\"%d,%d\",&len,&arg) && (len || arg))\n    {\n      x += cos(((double)argsum)*(PAI/180))*(double)len;\n      y += sin(((double)argsum)*(PAI/180))*(double)len;\n\n      //printf(\"%d:%d %d %d %d\\n\",(int)x,(int)y,argsum,len,arg);\n      argsum -= arg;\n    }\n  printf(\"%d\\n%d\\n\",(int)x,(int)y);\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int d, t;\n    double x = 0.0, y = 0.0;\n    double angle = 90.0; // Start facing north (90 degrees from east)\n    \n    while(1) {\n        scanf(\"%d,%d\", &d, &t);\n        if(d == 0 && t == 0) break;\n        \n        // Move d steps in current direction\n        double rad = angle * M_PI / 180.0;\n        x += d * cos(rad);\n        y += d * sin(rad);\n        \n        // Turn clockwise by t degrees (subtract from angle)\n        angle -= t;\n    }\n    \n    printf(\"%d\\n%d\\n\", (int)x, (int)y);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>   = 0.0, y = 0.0; double angle = 90.0; // Start facing  while(1)  == 0 && t == 0) break; // Move d steps in current direction double rad = angle * M_PI / 180.0; x += d * cos(rad); y += d * sin(rad); // Turn clockwise by t degrees (subtract from angle) angle  (int)y); return 0; }"], "perturbed_original": ["/* AizuOnline A0016 Tresure  <math.h> #include <float.h> double x,y; int len,arg; double PAI=3.14159265; main() { x=0.0; y=0.0; int argsum = 90;  += cos(((double)argsum)*(PAI/180))*(double)len; y += sin(((double)argsum)*(PAI/180))*(double)len; //printf(\"%d:%d %d %d %d\\n\",(int)x,(int)y,argsum,len,arg); argsum -= arg; } printf(\"%d\\n%d\\n\",(int)x,(int)y); return(0); }"], "original_ll": -1.6941131353378296, "sampled_ll": -0.8667120337486267, "all_perturbed_sampled_ll": [-2.4409801959991455], "all_perturbed_original_ll": [-2.108969211578369], "perturbed_sampled_ll": -2.4409801959991455, "perturbed_original_ll": -2.108969211578369, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tpublic static void main(String[] aegs){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint a = 0,c=0;\n\t\tString t = \"\";\n\t\tdouble counta =0,countb = 0;\n\t\tdouble rad = 90.0;\n\t\tdouble PI = Math.PI;\n\t\t\n\t\twhile(true){\n\t\t\n\t\t\ttry {\n\t\t\t\tt = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tString[] tt = t.split(\",\",0);\n\t\t\ta = Integer.parseInt(tt[0]);\n\t\t\tc = Integer.parseInt(tt[1]);\n\t\t\tif(a == 0 && c == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tcounta +=  (a * Math.sin(rad*PI/180d));\n\t\t\tcountb +=  (a * Math.cos(rad*PI/180d));\n\t\t\trad = rad - c;\n\t\t\t\n\t\t}\n\t\tSystem.out.println((int)countb);\n\t\tSystem.out.println((int)counta);\n\t\t\n\t}\n\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        double x = 0;\n        double y = 0;\n        double angle = 90; // Starting facing north (90 degrees from east)\n        \n        while (true) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int d = Integer.parseInt(parts[0].trim());\n            int t = Integer.parseInt(parts[1].trim());\n            \n            if (d == 0 && t == 0) {\n                break;\n            }\n            \n            // Move d steps in current direction\n            double radians = Math.toRadians(angle);\n            x += d * Math.cos(radians);\n            y += d * Math.sin(radians);\n            \n            // Turn clockwise by t degrees (subtract because clockwise is negative rotation)\n            angle -= t;\n        }\n        \n        System.out.println((int)x);\n        System.out.println((int)y);\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner  x = 0; double y  90; // Starting facing north (90 degrees from east) while (true) { String line = sc.nextLine();  d = Integer.parseInt(parts[0].trim()); int t = Integer.parseInt(parts[1].trim()); if (d == 0 && t == 0) { break; } // Move d steps in current direction double radians = Math.toRadians(angle); x +=  d * Math.sin(radians); // Turn clockwise by t degrees  rotation) angle -=  }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] aegs){ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int a = 0,c=0; String t = \"\";  double rad = 90.0; double PI = Math.PI; while(true){ try { t = br.readLine(); } catch (IOException e)  \u30d6\u30ed\u30c3\u30af e.printStackTrace();  a = Integer.parseInt(tt[0]); c = Integer.parseInt(tt[1]); if(a ==  (a * Math.sin(rad*PI/180d)); countb += (a * Math.cos(rad*PI/180d)); rad = rad - c; } System.out.println((int)countb); System.out.println((int)counta); } }"], "original_ll": -0.9656194448471069, "sampled_ll": -0.8754969239234924, "all_perturbed_sampled_ll": [-2.316023349761963], "all_perturbed_original_ll": [-1.7291648387908936], "perturbed_sampled_ll": -2.316023349761963, "perturbed_original_ll": -1.7291648387908936, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import turtle\nk = turtle.Turtle()\nk.speed(0)\nk.left(90)\nwhile True:\n    x = map(int,raw_input().split(\",\"))\n    if x[0] == 0 and x[1] == 0:\n        break\n    else:\n        k.fd(x[0])\n        k.right(x[1])\n        continue\nprint int(k.xcor())\nprint int(k.ycor())", "sampled": "import math\n\nx = 0.0\ny = 0.0\nangle = 90.0  # Starting direction: north (90 degrees from east)\n\nwhile True:\n    line = input().strip()\n    d, t = map(int, line.split(','))\n    \n    if d == 0 and t == 0:\n        break\n    \n    # Move d steps in current direction\n    x += d * math.cos(math.radians(angle))\n    y += d * math.sin(math.radians(angle))\n    \n    # Turn clockwise by t degrees (subtract because clockwise is negative)\n    angle -= t\n\nprint(int(x))\nprint(int(y))\n", "perturbed_sampled": ["import math =<extra_id_1>-<extra_id_2>t<extra_id_3>print(t 0.0 angle = 90.0 # Starting direction: north (90 degrees from east) while True: line = input().strip() d, t ) angle =<extra_id_4>#<extra_id_5>turn clockwise<extra_id_6>(x,<extra_id_7>,<extra_id_8>x , y<extra_id_9>d ) t =<extra_id_10>t - 1 ) t<extra_id_11>t<extra_id_12>,<extra_id_13>]<extra_id_14>] [<extra_id_15>0 for t in r<extra_id_16>0 == 0 and t == 0: break # Move d steps in current direction x += d * math.cos(math.radians(angle)) y += d * math.sin(math.radians(angle)) # Turn clockwise by t  print(int(x)) print(int(y))"], "perturbed_original": ["import turtle k = turtle.Turtle() k.speed(0) k.left(90) while True: x = map(int,raw_input().split(\",\")) if x[0] ==  break else: k.fd(x[0]) k.right(x[1]) continue print int(k.xcor()) print int(k.ycor())"], "original_ll": -1.1942418813705444, "sampled_ll": -1.1993738412857056, "all_perturbed_sampled_ll": [-2.4010188579559326], "all_perturbed_original_ll": [-1.918996810913086], "perturbed_sampled_ll": -2.4010188579559326, "perturbed_original_ll": -1.918996810913086, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n    int a[5],i,j,k;\n    int x=0;\n\n    for(i=0;i<5;i++){\n        scanf(\"%d\",&a[i]);\n        for(j=0;j<5;j++){\n            if(a[i]>a[j]){\n                x=a[i];\n                a[i]=a[j];\n                a[j]=x;\n            }\n        }\n    }\n    for(k=0;k<5;k++){\n        printf(\"%d \",a[k]);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int arr[5];\n    int i, j, temp;\n    \n    for(i = 0; i < 5; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    for(i = 0; i < 4; i++) {\n        for(j = i + 1; j < 5; j++) {\n            if(arr[i] < arr[j]) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    \n    for(i = 0; i < 5; i++) {\n        if(i > 0) printf(\" \");\n        printf(\"%d\", arr[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int arr[5]; int i, j, temp; for(i = 0;  scanf(\"%d\", &arr[i]); } for(i = 0; i < 4; i++) { for(j = i + 1; j  < arr[j]) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } for(i = 0; i <  0)  printf(\"\\n\"); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int a[5],i,j,k; int x=0; for(i=0;i<5;i++){ scanf(\"%d\",&a[i]); for(j=0;j<5;j++){ if(a[i]>a[j]){ x=a[i]; a[i]=a[j];  printf(\"%d \",a[k]); } return 0; }"], "original_ll": -0.7300270795822144, "sampled_ll": -0.3638063967227936, "all_perturbed_sampled_ll": [-1.3223085403442383], "all_perturbed_original_ll": [-1.4535375833511353], "perturbed_sampled_ll": -1.3223085403442383, "perturbed_original_ll": -1.4535375833511353, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Int implements Comparable<Int>{\n\tpublic int i;\n\tInt(int i){this.i = i;}\n\tpublic int compareTo (Int I){return I.i - this.i;}\n}\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\n\t\t//input\n\t\tScanner sc = new Scanner(System.in).useDelimiter(System.getProperty(\"line.separator\"));\n\t\tString[] s = sc.next().split(\"\\\\s\");\n\t\tInt[] ar = new Int[5];\n\t\tfor(int i=0;i<5;i++){ar[i] = new Int(Integer.parseInt(s[i]));}\n\t\t\n\t\t//calculation\n\t\tArrays.sort(ar);\n\t\t\n\t\t//output\n\t\tfor(int i=0;i<5;i++){\n\t\t\tSystem.out.print(ar[i].i);\n\t\t\tif(i < 4){System.out.print(\" \");}\n\t\t}\n\t\tSystem.out.println();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int[] arr = new int[5];\n        for (int i = 0; i < 5; i++) {\n            arr[i] = sc.nextInt();\n        }\n        Arrays.sort(arr);\n        for (int i = 4; i >= 0; i--) {\n            if (i == 4) {\n                System.out.print(arr[i]);\n            } else {\n                System.out.print(\" \" + arr[i]);\n            }\n        }\n        System.out.println();\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  Scanner sc = new Scanner(System.in); int[] arr = new int[5]; for (int i = 0; i < 5; i++) { arr[i] = sc.nextInt(); } Arrays.sort(arr); for (int i = 4; i >= 0; i--) { if (i == 4) { System.out.print(arr[i]);  + arr[i]); } } System.out.println(); sc.close(); } }"], "perturbed_original": ["import java.util.*; class Int implements Comparable<Int>{ public int i; Int(int i){this.i = i;} public int compareTo (Int I){return I.i - this.i;} } public class Main { public <extra_id_2>(<extra_id_3>=<extra_id_4>;<extra_id_5>this ) ; } //input Scanner sc = new Scanner(System.in).useDelimiter(System.getProperty(\"line.separator\")); String[] s = sc.next().split(\"\\\\s\"); Int[] ar  = new Int(Integer.parseInt(s[i]));} //calculation Arrays.sort(ar); //output for(int i=0;i<5;i++){  } System.out.println(); } }"], "original_ll": -0.9299836754798889, "sampled_ll": -0.3898261487483978, "all_perturbed_sampled_ll": [-1.1398656368255615], "all_perturbed_original_ll": [-2.271305561065674], "perturbed_sampled_ll": -1.1398656368255615, "perturbed_original_ll": -2.271305561065674, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a = map(int, raw_input().split())\na.sort()\na.reverse()\nprint \" \".join(map(str, a))", "sampled": "numbers = list(map(int, input().split()))\nnumbers.sort(reverse=True)\nprint(' '.join(map(str, numbers)))\n", "perturbed_sampled": ["numbers = list(map(int, input().split())) numbers.sort(reverse=True) print(' '.join(map(str, numbers)))"], "perturbed_original": ["a = map(int, raw_input().split()) a.sort() a.reverse() print \" \".join(map(str, a))"], "original_ll": -1.5471067428588867, "sampled_ll": -1.2694475650787354, "all_perturbed_sampled_ll": [-1.7070345878601074], "all_perturbed_original_ll": [-1.827249526977539], "perturbed_sampled_ll": -1.7070345878601074, "perturbed_original_ll": -1.827249526977539, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void)\n{\nint i,j;\n\nscanf(\"%d\",&i);\nj=1;\nfor(;i>0;i--){\nj*=i;\n}\nprintf(\"%d\\n\",j);\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    long long factorial = 1;\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i <= n; i++) {\n        factorial *= i;\n    }\n    \n    printf(\"%lld\\n\", factorial);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; long long factorial =  i = 1; i <= n; i++) { factorial *= i; } printf(\"%lld\\n\", factorial); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int i,j; scanf(\"%d\",&i); j=1; for(;i>0;i--){ j*=i; } printf(\"%d\\n\",j); return 0; }"], "original_ll": -1.554857850074768, "sampled_ll": -0.49363410472869873, "all_perturbed_sampled_ll": [-1.6375759840011597], "all_perturbed_original_ll": [-1.4913963079452515], "perturbed_sampled_ll": -1.6375759840011597, "perturbed_original_ll": -1.4913963079452515, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.math.*;\n\npublic class Main{\n    public static void main(String[] args){\n\tScanner in = new Scanner(System.in);\n\tint a = in.nextInt();\n\tlong b = 1;\n\n\tfor(int i = 1 ; i <= a ; i++){\n\t    b = b*i;\n\t}\n\tSystem.out.println(b);\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long factorial = 1;\n        for (int i = 2; i <= n; i++) {\n            factorial *= i;\n        }\n        System.out.println(factorial);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  n = sc.nextInt(); long  i = 2; i <= n; i++) { factorial *= i; } System.out.println(factorial); sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.math.*; public class Main{ public static void main(String[] args){ Scanner in  = in.nextInt(); long b = 1; for(int i = 1 ; i <=  b*i; } System.out.println(b); } }"], "original_ll": -0.9627333879470825, "sampled_ll": -0.4569930136203766, "all_perturbed_sampled_ll": [-1.7930954694747925], "all_perturbed_original_ll": [-1.975731611251831], "perturbed_sampled_ll": -1.7930954694747925, "perturbed_original_ll": -1.975731611251831, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "s=int(input())\nans=1\nfor i in range(1,s+1):\n    ans *= i\n\nprint(ans)", "sampled": "n = int(input())\nresult = 1\nfor i in range(1, n + 1):\n    result *= i\nprint(result)\n", "perturbed_sampled": ["n = int(input()) result = 1 for i in  *= i print(result)"], "perturbed_original": ["s=int(input()) ans=1 for i in range(1,s+1): ans *= i print(ans)"], "original_ll": -1.5674026012420654, "sampled_ll": -0.9496647119522095, "all_perturbed_sampled_ll": [-3.9265944957733154], "all_perturbed_original_ll": [-2.1687815189361572], "perturbed_sampled_ll": -3.9265944957733154, "perturbed_original_ll": -2.1687815189361572, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n  char ch[81];\n  int i;\n\n  gets(ch);\n  for(i = 0; ch[i] != '\\0'; ++i)\n    {\n      if('a' <= ch[i] && ch[i] <= 'z')\n\t{\n\t  ch[i] -= 32;\n\t}\n    }\n  puts(ch);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char c;\n    while ((c = getchar()) != EOF) {\n        putchar(toupper(c));\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <ctype.h> int main() { char c; while ((c = getchar())  return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void)  gets(ch); for(i = 0; ch[i] != '\\0'; ++i) { if('a' <= ch[i] && ch[i] <= 'z') { ch[i] -= 32;  }"], "original_ll": -0.8418545126914978, "sampled_ll": -0.750054121017456, "all_perturbed_sampled_ll": [-1.955749273300171], "all_perturbed_original_ll": [-1.4818872213363647], "perturbed_sampled_ll": -1.955749273300171, "perturbed_original_ll": -1.4818872213363647, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n\n        String input = s.nextLine();\n        System.out.println(input.toUpperCase());\n    }\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String text = sc.nextLine();\n        System.out.println(text.toUpperCase());\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args)  Scanner(System.in); String text = sc.nextLine(); System.out.println(text.toUpperCase()); sc.close(); } }"], "perturbed_original": [" { public static void main(String[] args) { Scanner s = new Scanner(System.in); String input = s.nextLine(); System.out.println(input.toUpperCase()); } }"], "original_ll": -0.935631513595581, "sampled_ll": -0.7259752154350281, "all_perturbed_sampled_ll": [-1.7626471519470215], "all_perturbed_original_ll": [-1.161545753479004], "perturbed_sampled_ll": -1.7626471519470215, "perturbed_original_ll": -1.161545753479004, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "print(input().upper())", "sampled": "print(input().upper())\n", "perturbed_sampled": ["print(input().upper())"], "perturbed_original": ["print(input().upper())"], "original_ll": -6.2531657218933105, "sampled_ll": -6.648473739624023, "all_perturbed_sampled_ll": [-6.2531657218933105], "all_perturbed_original_ll": [-6.2531657218933105], "perturbed_sampled_ll": -6.2531657218933105, "perturbed_original_ll": -6.2531657218933105, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nconst double eps = 1e-10;\n\nint n;\ndouble x1, x2, x3, x4;\ndouble y1, y2, y3, y4;\n\n//\u5897\u52a0\u7387\u3092\u898b\u308b\u65b9\u6cd5\nint solve1() {\n    double r1 = (y2-y1)/(x2-x1);\n    double r2 = (y4-y3)/(x4-x3);\n    return (fabs(r1-r2) < eps);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; ++i) {\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n\n        if(solve1()) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    double x1, y1, x2, y2, x3, y3, x4, y4;\n    double dx1, dy1, dx2, dy2;\n    double cross;\n    \n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n              &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n        \n        dx1 = x2 - x1;\n        dy1 = y2 - y1;\n        dx2 = x4 - x3;\n        dy2 = y4 - y3;\n        \n        cross = dx1 * dy2 - dy1 * dx2;\n        \n        if (fabs(cross) < 1e-9) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int n; double x1, y1, x2, y2, x3, y3,  dx2, dy2; double cross;  %lf %lf %lf  &x3, &y3, &x4, &y4); dx1 = x2 - x1; dy1 = y2 - y1;  dy2 = y4 - y3; cross = dx1 * dy2 - dy1 * dx2; if (fabs(cross) < 1e-9) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> const double eps = 1e-10; int n; double  y1, y2, y3, y4; //\u5897\u52a0\u7387\u3092\u898b\u308b\u65b9\u6cd5 int solve1() { double r1 = (y2-y1)/(x2-x1); double r2 = (y4-y3)/(x4-x3); return (fabs(r1-r2) < eps); } int main() { scanf(\"%d\", &n); for(int i=0;   &y2, &x3, &y3, &x4, &y4); if(solve1()) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } }"], "original_ll": -0.7197741270065308, "sampled_ll": -0.37489426136016846, "all_perturbed_sampled_ll": [-1.2872954607009888], "all_perturbed_original_ll": [-1.3771039247512817], "perturbed_sampled_ll": -1.2872954607009888, "perturbed_original_ll": -1.3771039247512817, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\n// AOJ 0021\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic final double EPS = 1e-8;\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tdouble[] x = new double[4], y = new double[4];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tx[j] = sc.nextDouble();\n\t\t\t\ty[j] = sc.nextDouble();\n\t\t\t}\n\t\t\t\n\t\t\tComplex \n\t\t\t\tp1 = new Complex(x[0], y[0]),\n\t\t\t\tp2 = new Complex(x[1], y[1]),\n\t\t\t\tp3 = new Complex(x[2], y[2]),\n\t\t\t\tp4 = new Complex(x[3], y[3]);\n\t\t\t\n\t\t\tif (!isCross(p1, p2, p3, p4)) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic boolean isCross(Complex p1, Complex p2, Complex p3, Complex p4) {\n\t\tdouble det = p1.sub(p2).crossProduct(p3.sub(p4));\n\t\tif (Math.abs(det) < Complex.EPS) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nclass Complex {\n\tstatic final double EPS = 1e-10;\n\t\n\tdouble re, im;\n\t\n\tComplex (double r, double i) {\n\t\tre = r; im = i;\n\t}\n\n\tdouble arg() {\n\t\treturn Math.atan2(im, re);\n\t}\n\t\n\tdouble abs2() {\n\t\treturn re * re + im * im;\n\t}\n\t\n\tdouble abs() {\n\t\treturn Math.sqrt(abs2());\n\t}\n\t\n\tdouble innerProdut(Complex o) {\n\t\treturn re * o.re + im * o.im;\n\t}\n\t\n\tdouble crossProduct(Complex o) {\n\t\treturn re * o.im - im * o.re;\n\t}\n\t\n\tstatic Complex polar(double theta, double r) {\n\t\treturn new Complex(r * Math.cos(theta), r * Math.sin(theta));\n\t}\n\t\n\tComplex conj() {\n\t\treturn new Complex(re, -im);\n\t}\n\t\n\tComplex add(Complex o) {\n\t\treturn new Complex(re + o.re, im + o.im);\n\t}\n\n\tComplex sub(Complex o) {\n\t\treturn new Complex(re - o.re, im - o.im);\n\t}\n\t\n\tComplex mul(Complex o) {\n\t\treturn new Complex(re * o.re - im * o.im, re * o.im + im * o.re);\n\t}\n\t\n\tComplex div(Complex o) {\n\t\treturn new Complex((re * o.re + im * o.im) / o.abs2(), (im * o.re - re * o.im) / o.abs2());\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double x1 = sc.nextDouble();\n            double y1 = sc.nextDouble();\n            double x2 = sc.nextDouble();\n            double y2 = sc.nextDouble();\n            double x3 = sc.nextDouble();\n            double y3 = sc.nextDouble();\n            double x4 = sc.nextDouble();\n            double y4 = sc.nextDouble();\n            \n            double dx1 = x2 - x1;\n            double dy1 = y2 - y1;\n            double dx2 = x4 - x3;\n            double dy2 = y4 - y3;\n            \n            double cross = dx1 * dy2 - dy1 * dx2;\n            \n            if (Math.abs(cross) < 1e-9) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i =  { double x1 = sc.nextDouble(); double y1  sc.nextDouble(); double y2 = sc.nextDouble(); double x3 = sc.nextDouble(); double y3 = sc.nextDouble(); double x4 = sc.nextDouble(); double y4 = sc.nextDouble(); double   y1; double dx2 = x4 - x3; double dy2 =  = dx1 * dy2 - dy1 * dx2; if (Math.abs(cross)  else { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; import static java.util.Arrays.*;  0021 public class Main { static Scanner sc = new Scanner(System.in); static int N; static final double EPS = 1e-8; public static void main(String[] args) { N = sc.nextInt(); double[] x = new double[4], y = new double[4]; for (int i  j =  { x[j] = sc.nextDouble(); y[j] = sc.nextDouble(); } Complex p1 = new Complex(x[0], y[0]), p2 = new Complex(x[1], y[1]), p3  = new Complex(x[3], y[3]); if (!isCross(p1, p2, p3, p4)) {  }  p1, Complex p2,  if (Math.abs(det) < Complex.EPS) { return false; } else { return true; } } } class Complex { static final double EPS = 1e-10; double re, im; Complex (double r, double i) { re = r; im  { return Math.atan2(im, re); } double abs2() { return re *  } double abs() {  o)  } double crossProduct(Complex o) { return re * o.im - im * o.re; } static Complex polar(double theta, double r) { return new Complex(r * Math.cos(theta), r * Math.sin(theta)); } Complex conj() {  return new Complex(re + o.re, im + o.im); } Complex sub(Complex o) { return new Complex(re - o.re, im - o.im); } Complex mul(Complex o) { return new Complex(re * o.re - im * o.im, re * o.im +  div(Complex o) { return new Complex((re * o.re + im  * o.re - re * o.im) / o.abs2()); } }"], "original_ll": -0.5198462009429932, "sampled_ll": -0.28433889150619507, "all_perturbed_sampled_ll": [-1.286289095878601], "all_perturbed_original_ll": [-1.3075143098831177], "perturbed_sampled_ll": -1.286289095878601, "perturbed_original_ll": -1.3075143098831177, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "ans = []\nn = input()\nfor i in range(n):\n    x1,y1,x2,y2,x3,y3,x4,y4 = map(float,raw_input().split())\n    if ((y2-y1)/(x2-x1) == (y4-y3)/(x4-x3)):\n        ans.append('YES')\n    else:\n        ans.append('NO')\nfor i in ans:\n    print i", "sampled": "n = int(input())\nfor _ in range(n):\n    coords = list(map(float, input().split()))\n    x1, y1, x2, y2, x3, y3, x4, y4 = coords\n    \n    # Direction vectors\n    dx1 = x2 - x1\n    dy1 = y2 - y1\n    dx2 = x4 - x3\n    dy2 = y4 - y3\n    \n    # Two lines are parallel if their direction vectors are parallel\n    # This means the cross product should be zero\n    cross = dx1 * dy2 - dy1 * dx2\n    \n    if abs(cross) < 1e-9:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["n = int(input()) for _ in range(n): coords = list(map(float, input().split())) x1, y1,  y4 = coords # Direction vectors dx1 = x2 - x1 dy1 =  = y4 - y3 # Two lines are parallel if their direction vectors are parallel # This means the cross product should be zero cross = dx1 * dy2 - dy1 * dx2 if  print(\"NO\")"], "perturbed_original": ["ans = [] n = input() for i in range(n): x1,y1,x2,y2,x3,y3,x4,y4 = map(float,raw_input().split()) if  ans.append('NO') for i in ans: print i"], "original_ll": -0.8097441792488098, "sampled_ll": -0.7387608289718628, "all_perturbed_sampled_ll": [-2.1098740100860596], "all_perturbed_original_ll": [-1.8335888385772705], "perturbed_sampled_ll": -2.1098740100860596, "perturbed_original_ll": -1.8335888385772705, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct\n{\n    double x;\n    double y;\n    double r;\n}circle;\n\nint main(void)\n{\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    while (datasets--) {\n        circle a, b;\n        scanf(\" %lf %lf %lf\", &(a.x), &(a.y), &(a.r));\n        scanf(\" %lf %lf %lf\", &(b.x), &(b.y), &(b.r));\n\n        double bigr, smallr;\n        if (a.r >=  b.r) {\n            bigr = a.r;\n            smallr = b.r;\n        } else {\n            bigr = b.r;\n            smallr = a.r;\n        }\n\n        double dist = pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n        dist = sqrt(dist);\n\n        int judge;\n        if (dist > bigr + smallr) {\n            judge = 0;\n        } else if (dist > bigr - smallr) {\n            judge = 1;\n        } else {\n            if (bigr == a.r) {\n                judge = 2;\n            } else {\n                judge = -2;\n            }\n        }\n\n        printf(\"%d\\n\", judge);\n    }\n\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        double xa, ya, ra, xb, yb, rb;\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &xa, &ya, &ra, &xb, &yb, &rb);\n        \n        double dist = sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n        \n        if (dist + rb < ra + 1e-9) {\n            printf(\"2\\n\");\n        } else if (dist + ra < rb + 1e-9) {\n            printf(\"-2\\n\");\n        } else if (dist < ra + rb + 1e-9 && dist + 1e-9 > fabs(ra - rb)) {\n            printf(\"1\\n\");\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int n; scanf(\"%d\", &n); while (n--) { double xa, ya, ra,  %lf  &ra, &xb, &yb, &rb); double dist = sqrt((xa - xb) * (xa - xb) + (ya  yb)); if (dist + rb <  } else if (dist + ra < rb + 1e-9)  (dist < ra + rb + 1e-9 && dist + 1e-9 > fabs(ra - rb))  printf(\"0\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> typedef struct { double x; double y; double r; }circle; int main(void)  a, b;  &(a.y), &(a.r)); scanf(\" %lf %lf  bigr, smallr; if (a.r >= b.r) { bigr = a.r; smallr = b.r; } else { bigr = b.r; smallr = a.r; } double dist = pow(a.x - b.x, 2) + pow(a.y - b.y, 2); dist = sqrt(dist); int judge; if (dist > bigr + smallr) { judge = 0; }  -  (bigr == a.r) { judge = 2; } else { judge = -2; } } printf(\"%d\\n\", judge); } return 0; }"], "original_ll": -0.6373117566108704, "sampled_ll": -0.5692116022109985, "all_perturbed_sampled_ll": [-1.8251999616622925], "all_perturbed_original_ll": [-1.5541023015975952], "perturbed_sampled_ll": -1.8251999616622925, "perturbed_original_ll": -1.5541023015975952, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        while (n-- > 0) {\n            Circle a = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n            Circle b = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n            double dx = b.x - a.x;\n            double dy = b.y - a.y;\n            double r = a.r + b.r;\n            double d = Math.sqrt(dx * dx + dy * dy);\n            if (d > r) {\n                System.out.println(0);\n            } else {\n                if (a.r < b.r && d + a.r < b.r) {\n                    System.out.println(-2);\n                } else if (a.r > b.r && d + b.r < a.r) {\n                    System.out.println(2);\n                } else {\n                    System.out.println(1);\n                }\n            }\n        }\n    }\n\n    static class Circle {\n        double x;\n        double y;\n        double r;\n\n        Circle(double x, double y, double r) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n        }\n    }\n}\n\n\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double xa = sc.nextDouble();\n            double ya = sc.nextDouble();\n            double ra = sc.nextDouble();\n            double xb = sc.nextDouble();\n            double yb = sc.nextDouble();\n            double rb = sc.nextDouble();\n            \n            double dist = Math.sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n            \n            if (dist + rb < ra || Math.abs(dist + rb - ra) < 1e-9) {\n                System.out.println(2);\n            } else if (dist + ra < rb || Math.abs(dist + ra - rb) < 1e-9) {\n                System.out.println(-2);\n            } else if (dist < ra + rb && dist > Math.abs(ra - rb)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  public static void main(String[] args)  Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i < n; i++) { double xa = sc.nextDouble(); double ya = sc.nextDouble(); double  =  double rb = sc.nextDouble(); double dist =  - xb) + (ya - yb) * (ya - yb)); if (dist + rb < ra || Math.abs(dist + rb - ra) < 1e-9)  (dist + ra < rb || Math.abs(dist + ra - rb) < 1e-9) { System.out.println(-2); } else if (dist < ra  Math.abs(ra - rb)) { System.out.println(1); } else { System.out.println(0); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { <extra_id_3>} { Scanner sc = new Scanner(System.in); <extra_id_4>(a<extra_id_5>a<extra_id_6>double ) (<extra_id_7>) > 0 )<extra_id_8>c . next ( )<extra_id_9>{ double dd<extra_id_10>= - a.d +<extra_id_11>double + ( ( a.y<extra_id_12>) > a .<extra_id_13>b . r ) {<extra_id_14>) ) { if<extra_id_15>= a.r ; this .<extra_id_16>+ a . r<extra_id_17>d + - b .<extra_id_18>) {<extra_id_19>d (n-- > 0) { Circle a = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble()); Circle b = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble()); double dx = b.x - a.x; double dy = b.y - a.y; double r = a.r  Math.sqrt(dx * dx + dy * dy); if (d  else {  d + a.r < b.r) { System.out.println(-2); } else if (a.r > b.r && d + b.r < a.r) { System.out.println(2); } else { System.out.println(1); } }  {  r; Circle(double x, double  = x; this.y = y; this.r = r; } } }"], "original_ll": -0.4733905494213104, "sampled_ll": -0.44923147559165955, "all_perturbed_sampled_ll": [-1.492823839187622], "all_perturbed_original_ll": [-2.037598133087158], "perturbed_sampled_ll": -1.492823839187622, "perturbed_original_ll": -2.037598133087158, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for a,b,r,c,d,s in[map(float,raw_input().split())for i in range(input())]:\n\td=(a-c)**2+(b-d)**2\n\tif d>(r+s)**2:print 0\n\telif d+min(r,s)>max(r,s):print 1\n\telif r>s:print 2\n\telse:print -2", "sampled": "import math\n\nn = int(input())\nfor _ in range(n):\n    xa, ya, ra, xb, yb, rb = map(float, input().split())\n    \n    # Calculate distance between centers\n    d = math.sqrt((xa - xb)**2 + (ya - yb)**2)\n    \n    # Check if B is in A\n    if d + rb <= ra:\n        print(2)\n    # Check if A is in B\n    elif d + ra <= rb:\n        print(-2)\n    # Check if circles intersect\n    elif d < ra + rb:\n        print(1)\n    # Circles do not overlap\n    else:\n        print(0)\n", "perturbed_sampled": ["import math n  range(n): xa, ya, ra, xb, yb, rb = map(float, input().split()) # Calculate distance between centers d  (ya - yb)**2) # Check if B is in A if d + rb <=  A is in B elif  print(-2) # Check if circles intersect elif d < ra + rb: print(1) # Circles do not overlap else: print(0)"], "perturbed_original": [" range(input())]: d=(a-c)**2+(b-d)**2 if d>(r+s)**2:print 0 elif d+min(r,s)>max(r,s):print 1 elif r>s:print 2 else:print -2"], "original_ll": -1.645774006843567, "sampled_ll": -0.7747495770454407, "all_perturbed_sampled_ll": [-2.6702873706817627], "all_perturbed_original_ll": [-2.7774221897125244], "perturbed_sampled_ll": -2.6702873706817627, "perturbed_original_ll": -2.7774221897125244, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nint main(){\n\tfloat v,t,y;\n\twhile(scanf(\"%f\",&v) != EOF){\n\t\tt = v / 9.8;\n\t\ty = t * t * 4.9;\n\t\tprintf(\"%d\\n\",(int)ceilf(y / 5.0) + 1);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double v;\n    while (scanf(\"%lf\", &v) != EOF) {\n        double t = v / 9.8;\n        double y = 4.9 * t * t;\n        int floor = (int)ceil((y + 5) / 5);\n        printf(\"%d\\n\", floor);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { double v; while (scanf(\"%lf\", &v)  = v / 9.8; double y = 4.9 *  = (int)ceil((y + 5) / 5); printf(\"%d\\n\", floor); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> int main(){ float v,t,y; while(scanf(\"%f\",&v) != EOF){ t = v / 9.8; y = t  / 5.0) + 1); } return 0; }"], "original_ll": -1.4823215007781982, "sampled_ll": -1.0034258365631104, "all_perturbed_sampled_ll": [-2.3181722164154053], "all_perturbed_original_ll": [-2.2412824630737305], "perturbed_sampled_ll": -2.3181722164154053, "perturbed_original_ll": -2.2412824630737305, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid doIt() {\n\t\twhile(true){\n\t\t\ttry{\n\t\t\t\tdouble v = sc.nextDouble();\n\t\t\t\tdouble t = v / 9.8;\n\t\t\t\tdouble y = 4.9 * t * t;\n\t\t\t\tint ans = (int) y / 5;\n\t\t\t\tdouble cnt = y % 5;\n\t\t\t\tif(cnt > 0){\n\t\t\t\t\tans++;\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t}\n\t\t\t}catch(Exception g){\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\t}\n    public static void main(String[] args) {\n    \tnew Main().doIt();\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double v = sc.nextDouble();\n            \n            // From v = 9.8t, we get t = v / 9.8\n            double t = v / 9.8;\n            \n            // Drop distance y = 4.9 * t^2\n            double y = 4.9 * t * t;\n            \n            // Height of floor N is 5*N - 5\n            // We need to find smallest N such that 5*N - 5 >= y\n            // 5*N >= y + 5\n            // N >= (y + 5) / 5\n            \n            int floor = (int) Math.ceil((y + 5) / 5.0);\n            \n            System.out.println(floor);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args)  Scanner(System.in); while (sc.hasNext()) { double v = sc.nextDouble(); // From v = 9.8t, we get t  t = v / 9.8; //  * t^2 double y = 4.9 * t * t; // Height of  5 // We need to find smallest  5 >= y // 5*N >= y + 5 // N >= (y + 5) / 5  + 5) / 5.0); System.out.println(floor); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { Scanner sc = new Scanner(System.in); void doIt() { while(true){ try{ double v = sc.nextDouble(); double t =  = 4.9 * t * t;  / 5; double cnt = y % 5; if(cnt > 0){ ans++; System.out.println(ans); }else{ System.out.println(ans); } }catch(Exception g){ System.exit(0); } }  } }"], "original_ll": -1.0901435613632202, "sampled_ll": -0.9343289136886597, "all_perturbed_sampled_ll": [-2.320202350616455], "all_perturbed_original_ll": [-2.2456371784210205], "perturbed_sampled_ll": -2.320202350616455, "perturbed_original_ll": -2.2456371784210205, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nimport math\nv=[]\nfor line in sys.stdin:\n    v.append(float(line))\nfor i in range(len(v)):\n    print math.ceil(v[i]**2/98+1),", "sampled": "import sys\nimport math\n\nfor line in sys.stdin:\n    v = float(line.strip())\n    \n    # From v = 9.8 * t, we get t = v / 9.8\n    t = v / 9.8\n    \n    # From y = 4.9 * t^2\n    y = 4.9 * t * t\n    \n    # Height of floor N is 5*N - 5\n    # We need 5*N - 5 >= y\n    # 5*N >= y + 5\n    # N >= (y + 5) / 5\n    \n    N = math.ceil((y + 5) / 5)\n    \n    print(N)\n", "perturbed_sampled": ["import sys import math for line in sys.stdin: v =  9.8 * t, we get t = v / 9.8 t = v / 9.8 # From  y = 4.9 *  of floor N is 5*N - 5 # We need 5*N -  >= y + 5 # N >= (y + 5) / 5 N = math.ceil((y + 5) / 5) print(N)"], "perturbed_original": ["import sys import math v=[] for line in sys.stdin: v.append(float(line)) for i in range(len(v)): print math.ceil(v[i]**2/98+1),"], "original_ll": -2.1340839862823486, "sampled_ll": -1.066253423690796, "all_perturbed_sampled_ll": [-2.556675434112549], "all_perturbed_original_ll": [-2.892409086227417], "perturbed_sampled_ll": -2.556675434112549, "perturbed_original_ll": -2.892409086227417, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n\tint A[4], B[4];\n\tint a, b;\n\tint hit, blow;\n\n\twhile( scanf(\"%d%d%d%d\",&A[0],&A[1],&A[2],&A[3]) != EOF ){\n\t\tscanf(\"%d%d%d%d\",&B[0],&B[1],&B[2],&B[3]);\n\n\t\thit=blow=0;\n\n\t\tfor( a=0; a<4; a++ ){\n\t\t\tfor( b=0; b<4; b++ ){\n\t\t\t\tif( A[a] == B[b] ){\n\t\t\t\t\t(a==b)? hit++ : blow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %d\\n\", hit, blow);\n\t}\n\n\treturn 0;\n}\n\t", "sampled": "#include <stdio.h>\n\nint main() {\n    int a[4], b[4];\n    \n    while(scanf(\"%d %d %d %d\", &a[0], &a[1], &a[2], &a[3]) != EOF) {\n        scanf(\"%d %d %d %d\", &b[0], &b[1], &b[2], &b[3]);\n        \n        int hit = 0, blow = 0;\n        \n        // Count hits\n        for(int i = 0; i < 4; i++) {\n            if(a[i] == b[i]) {\n                hit++;\n            }\n        }\n        \n        // Count blows\n        for(int i = 0; i < 4; i++) {\n            for(int j = 0; j < 4; j++) {\n                if(i != j && a[i] == b[j]) {\n                    blow++;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", hit, blow);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> <extra_id_3>== b [i] {<extra_id_4>== b[4] { blow++;<extra_id_5>}<extra_id_6>else<extra_id_7>}<extra_id_8>if(!i) { if(a.length<extra_id_9>|| a[3]<extra_id_10>&&<extra_id_11>1<extra_id_12>\"<extra_id_13>{ for(int i =<extra_id_14>& b[3] ==<extra_id_15>(<extra_id_16>1.0;<extra_id_17>i ++ )<extra_id_18> b[4]; while(scanf(\"%d %d %d %d\", &a[0], &a[1], &a[2], &a[3]) != EOF) { scanf(\"%d %d %d %d\", &b[0], &b[1], &b[2], &b[3]);  hits for(int i = 0; i < 4; i++) { if(a[i] == b[i]) { hit++; } } // Count blows for(int i = 0; i < 4;  j++) { if(i != j && a[i] == b[j]) { blow++; } } } printf(\"%d %d\\n\", hit, blow); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ int A[4], B[4]; int a, b; int hit, blow; while( scanf(\"%d%d%d%d\",&A[0],&A[1],&A[2],&A[3]) != EOF ){ scanf(\"%d%d%d%d\",&B[0],&B[1],&B[2],&B[3]); hit=blow=0; for( a=0; a<4; a++ ){ for( b=0; b<4; b++ ){ if( A[a] == B[b]  %d\\n\",  }"], "original_ll": -0.747734010219574, "sampled_ll": -0.3695306181907654, "all_perturbed_sampled_ll": [-1.6014912128448486], "all_perturbed_original_ll": [-1.211334228515625], "perturbed_sampled_ll": -1.6014912128448486, "perturbed_original_ll": -1.211334228515625, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint [] a = new int[4];\n\t\t\tint [] b = new int[4];\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i =0; i < 4; i++){\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint hit=0;\n\t\t\tint blow = 0;\n\t\t\tfor(int i =0; i < 4; i++){\n\t\t\t\tfor(int j =i; j < 4; j++){\n\t\t\t\t\tif(a[i] == b[j]){\n\t\t\t\t\t\tif(i == j)\n\t\t\t\t\t\t\thit++;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tblow++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(hit + \" \" + blow);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int[] a = new int[4];\n            int[] b = new int[4];\n            \n            for (int i = 0; i < 4; i++) {\n                a[i] = sc.nextInt();\n            }\n            for (int i = 0; i < 4; i++) {\n                b[i] = sc.nextInt();\n            }\n            \n            int hit = 0;\n            int blow = 0;\n            \n            for (int i = 0; i < 4; i++) {\n                if (a[i] == b[i]) {\n                    hit++;\n                } else {\n                    for (int j = 0; j < 4; j++) {\n                        if (i != j && a[i] == b[j]) {\n                            blow++;\n                            break;\n                        }\n                    }\n                }\n            }\n            \n            System.out.println(hit + \" \" + blow);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) {  int[] b = new int[4]; for (int i  i++) { a[i] = sc.nextInt();  i++) { b[i]  =  for (int i = 0; i < 4; i++) { if (a[i] == b[i]) { hit++; }  = 0; j < 4; j++) { if (i != j && a[i] == b[j]) { blow++; break; } } } } System.out.println(hit + \" \" + blow); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { private void doit() { Scanner sc = new Scanner(System.in);  new int[4];  int[4]; for(int i = 0; i < 4;  for(int i =0; i < 4; i++){ b[i] = sc.nextInt(); } int hit=0; int blow = 0; for(int i =0; i < 4;  < 4; j++){ if(a[i] == b[j]){ if(i == j) hit++;  \" + blow); } } public static void main(String[] args) { Main obj = new Main(); obj.doit(); } }"], "original_ll": -0.6021494269371033, "sampled_ll": -0.30800947546958923, "all_perturbed_sampled_ll": [-1.3789929151535034], "all_perturbed_original_ll": [-1.6549125909805298], "perturbed_sampled_ll": -1.3789929151535034, "perturbed_original_ll": -1.6549125909805298, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor i in sys.stdin:\n    arrA,arrB = [],[]\n    s = i.split()\n    for i in s:\n        arrA.append(int(i))\n    s = input().split()\n    for i in s:\n        arrB.append(int(i))\n    h,b = 0,0\n    for i in range(len(arrA)):\n        if arrA[i] == arrB[i]:\n            h += 1\n        else:\n            if arrB.count(arrA[i]) > 0:\n                b += 1\n    print(h,b)", "sampled": "import sys\n\nfor line in sys.stdin:\n    numbers = list(map(int, line.split()))\n    if len(numbers) < 8:\n        continue\n    \n    a = numbers[:4]\n    b = numbers[4:8]\n    \n    hit = 0\n    blow = 0\n    \n    for i in range(4):\n        if a[i] == b[i]:\n            hit += 1\n        elif b[i] in a:\n            blow += 1\n    \n    print(hit, blow)\n", "perturbed_sampled": ["import sys for line in sys.stdin: numbers = list(map(int,  b = numbers[4:8] hit = 0 blow = 0 for i in range(4): if a[i] == b[i]: hit += 1 elif b[i] in a: blow += 1 print(hit, blow)"], "perturbed_original": ["import sys for i in sys.stdin: arrA,arrB = [],[] s = i.split() for i in s: arrA.append(int(i)) s = input().split() for i in s: arrB.append(int(i)) h,b = 0,0 for i in range(len(arrA)): if arrA[i] == arrB[i]: h +=  print(h,b)"], "original_ll": -0.9464068412780762, "sampled_ll": -0.8604347109794617, "all_perturbed_sampled_ll": [-1.8901278972625732], "all_perturbed_original_ll": [-1.6390841007232666], "perturbed_sampled_ll": -1.8901278972625732, "perturbed_original_ll": -1.6390841007232666, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid fact(int ,int, int);\nvoid count(void);\n\nint a[10][10],i,j;\n\nint main(){\n  int x,y,size;\n\n  for(i = 0 ; i < 10 ; i++){\n    for(j = 0 ; j < 10 ; j++){\n      a[i][j] = 0;\n    }\n  }\n  while(scanf(\"%d,%d,%d\",&x,&y,&size) != 3){\n    fact(x,y,size);\n  }\n  count();\n  return 0;\n}\nvoid fact(int x, int y, int size){\n  int size1[2] = {1,-1};\n  int size2[2] = {2,-2};\n\n  a[y][x] += 1;\n  if(size == 1){\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size1[i] >= 0 || x+size1[i] <= 10)\n\ta[y][x+size1[i]] += 1;\n      if(y+size1[i] >= 0 || y+size1[i] <= 10)\n\ta[y+size1[i]][x] += 1;\n    }\n  }\n  if(size == 2){\n    for(i = 0 ; i < 2 ; i++){\n      for(j = 0 ; j < 2 ; j++){\n\tif(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10)\n\t  a[y+size1[i]][x+size1[j]] += 1;\n      }\n    }\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size1[i] >= 0 || x+size1[i] <= 10)\n\ta[y][x+size1[i]] += 1;\n      if(y+size1[i] >= 0 || y+size1[i] <= 10)\n\ta[y+size1[i]][x] += 1;\n    }\n  }\n  if(size == 3){\n    for(i = 0 ; i < 2 ; i++){\n      for(j = 0 ; j < 2 ; j++){\n\tif(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10)\n\t  a[y+size1[i]][x+size1[j]] += 1;\n      }\n    }\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size1[i] >= 0 || x+size1[i] <= 10)\n\ta[y][x+size1[i]] += 1;\n      if(y+size1[i] >= 0 || y+size1[i] <= 10)\n\ta[y+size1[i]][x] += 1;\n    }\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size2[i] >= 0 || x+size2[i] <= 10)\n\ta[y][x+size2[i]] += 1;\n      if(y+size2[i] >= 0 || y+size2[i] <= 10)\n\ta[y+size2[i]][x] += 1;\n    }\n  }\n}\nvoid count(void){\n  int sum = 0,x = 0;\n\n  for(i = 0 ; i < 10 ; i++){\n    for(j = 0 ; j < 10 ; j++){\n      if(a[i][j] == 0)\n\tsum++;\n      else if(x < a[i][j])\n\tx++;\n    }\n  }\n  printf(\"%d\\n%d\\n\",sum,x);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int grid[10][10];\n    memset(grid, 0, sizeof(grid));\n    \n    int x, y, s;\n    while (scanf(\"%d,%d,%d\", &x, &y, &s) == 3) {\n        // Small (s=1): only center point\n        if (s == 1) {\n            grid[y][x]++;\n        }\n        // Medium (s=2): center + adjacent (up, down, left, right)\n        else if (s == 2) {\n            grid[y][x]++;\n            if (y > 0) grid[y-1][x]++;\n            if (y < 9) grid[y+1][x]++;\n            if (x > 0) grid[y][x-1]++;\n            if (x < 9) grid[y][x+1]++;\n        }\n        // Large (s=3): center + all 8 surrounding cells + distance 2 in 4 directions\n        else if (s == 3) {\n            grid[y][x]++;\n            // 8 surrounding cells\n            if (y > 0) grid[y-1][x]++;\n            if (y < 9) grid[y+1][x]++;\n            if (x > 0) grid[y][x-1]++;\n            if (x < 9) grid[y][x+1]++;\n            if (y > 0 && x > 0) grid[y-1][x-1]++;\n            if (y > 0 && x < 9) grid[y-1][x+1]++;\n            if (y < 9 && x > 0) grid[y+1][x-1]++;\n            if (y < 9 && x < 9) grid[y+1][x+1]++;\n            // distance 2 in 4 directions\n            if (y > 1) grid[y-2][x]++;\n            if (y < 8) grid[y+2][x]++;\n            if (x > 1) grid[y][x-2]++;\n            if (x < 8) grid[y][x+2]++;\n        }\n    }\n    \n    int zero_count = 0;\n    int max_density = 0;\n    \n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (grid[i][j] == 0) {\n                zero_count++;\n            }\n            if (grid[i][j] > max_density) {\n                max_density = grid[i][j];\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", zero_count);\n    printf(\"%d\\n\", max_density);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  grid[10][10]; memset(grid, 0, sizeof(grid)); int  &x, &y, &s) == 3) { // Small (s=1): only center point if (s == 1) {  if (s  (y > 0) grid[y-1][x]++; if (y < 9) grid[y+1][x]++; if (x > 0) grid[y][x-1]++; if (x < 9) grid[y][x+1]++; } // Large (s=3): center + all 8 surrounding cells +  else if (s == 3) { grid[y][x]++; // 8 surrounding cells if (y > 0) grid[y-1][x]++; if (y < 9) grid[y+1][x]++; if (x > 0) grid[y][x-1]++;  if (y > 0 && x > 0) grid[y-1][x-1]++; if (y > 0 &&  (y < 9 && x > 0) grid[y+1][x-1]++; if (y < 9 && x <  in 4 directions if (y > 1) grid[y-2][x]++; if (y  > 1) grid[y][x-2]++; if (x < 8) grid[y][x+2]++; } } int zero_count = 0; int max_density = 0; for  < 10; i++) { for (int j = 0; j < 10;  0)  > max_density) { max_density = grid[i][j]; } } } printf(\"%d\\n\", zero_count); printf(\"%d\\n\", max_density); return 0; }"], "perturbed_original": ["#include <stdio.h> void fact(int ,int, int); void count(void); int a[10][10],i,j; int main(){ int x,y,size; for(i = 0 ; i < 10   j++){  } count(); return 0; } void fact(int x, int y, int size){ int  = {2,-2}; a[y][x] += 1;  0 ; i < 2 ; i++){ if(x+size1[i] >= 0 || x+size1[i] <= 10) a[y][x+size1[i]] += 1; if(y+size1[i]   } if(size == 2){ for(i = 0 ; i < 2 ; i++){ for(j  2  || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10) a[y+size1[i]][x+size1[j]] += 1; } } for(i = 0 ; i < 2 ; i++){ if(x+size1[i] >= 0 || x+size1[i] <= 10) a[y][x+size1[i]] += 1; if(y+size1[i] >= 0 || y+size1[i] <= 10)  = 0 ; i < 2 ; i++){ for(j = 0 ; j < 2 ; j++){ if(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10)  for(i = 0 ; i < 2 ; i++){ if(x+size1[i] >= 0 || x+size1[i] <= 10)  10) a[y+size1[i]][x] += 1; } for(i = 0  i++){ if(x+size2[i] >= 0 || x+size2[i] <=  >= 0 || y+size2[i] <= 10) a[y+size2[i]][x] += 1; } } } void count(void){ int sum = 0,x = 0; for(i = 0 ; i < 10 ; i++){ for(j = 0 ; j < 10 ; j++){ if(a[i][j] == 0) sum++; else  } printf(\"%d\\n%d\\n\",sum,x); }"], "original_ll": -0.390471875667572, "sampled_ll": -0.37035873532295227, "all_perturbed_sampled_ll": [-1.2203810214996338], "all_perturbed_original_ll": [-0.9398908615112305], "perturbed_sampled_ll": -1.2203810214996338, "perturbed_original_ll": -0.9398908615112305, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint[] area = new int[10 * 10];\n\n\t\tString str;\n\n\t\ttry {\n\t\t\twhile ((str = br.readLine()) != null) {\n\t\t\t\tString strArray[] = str.split(\",\");\n\t\t\t\tint x = Integer.parseInt(strArray[0]);\n\t\t\t\tint y = Integer.parseInt(strArray[1]);\n\t\t\t\tint size = Integer.parseInt(strArray[2]);\n\n\t\t\t\tint point = y * 10 + x;\n\n\t\t\t\tswitch (size) {\n\t\t\t\tcase 3:\n\t\t\t\t\tif (x < 8)\n\t\t\t\t\t\tarea[point + 2]++;\n\t\t\t\t\tif (x > 1)\n\t\t\t\t\t\tarea[point - 2]++;\n\t\t\t\t\tif (y < 8)\n\t\t\t\t\t\tarea[point + 20]++;\n\t\t\t\t\tif (y > 1)\n\t\t\t\t\t\tarea[point - 20]++;\n\t\t\t\tcase 2:\n\t\t\t\t\t// \u5de6\u4e0a\n\t\t\t\t\tif (x > 0 && y > 0)\n\t\t\t\t\t\tarea[point - 11]++;\n\t\t\t\t\t// \u53f3\u4e0a\n\t\t\t\t\tif (x < 9 && y > 0)\n\t\t\t\t\t\tarea[point - 9]++;\n\t\t\t\t\t// \u5de6\u4e0b\n\t\t\t\t\tif (y < 9 && x > 0)\n\t\t\t\t\t\tarea[point + 9]++;\n\t\t\t\t\t// \u53f3\u4e0b\n\t\t\t\t\tif (y < 9 && x < 9)\n\t\t\t\t\t\tarea[point + 11]++;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (x < 9)\n\t\t\t\t\t\tarea[point + 1]++;\n\t\t\t\t\tif (x > 0)\n\t\t\t\t\t\tarea[point - 1]++;\n\t\t\t\t\tif (y < 9)\n\t\t\t\t\t\tarea[point + 10]++;\n\t\t\t\t\tif (y > 1)\n\t\t\t\t\t\tarea[point - 10]++;\n\t\t\t\t\tarea[point]++;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (NumberFormatException e) {\n\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tArrays.sort(area);\n\t\tint blank = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tif (area[i] != 0) {\n\t\t\t\tblank = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// System.out.println(Arrays.binarySearch(area, 1));\n\t\tSystem.out.println(blank);\n\t\tSystem.out.println(area[99]);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int[][] paper = new int[10][10];\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int x = Integer.parseInt(parts[0]);\n            int y = Integer.parseInt(parts[1]);\n            int size = Integer.parseInt(parts[2]);\n            \n            dropInk(paper, x, y, size);\n        }\n        \n        int zeroCells = 0;\n        int maxDensity = 0;\n        \n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                if (paper[i][j] == 0) {\n                    zeroCells++;\n                }\n                maxDensity = Math.max(maxDensity, paper[i][j]);\n            }\n        }\n        \n        System.out.println(zeroCells);\n        System.out.println(maxDensity);\n        \n        sc.close();\n    }\n    \n    static void dropInk(int[][] paper, int x, int y, int size) {\n        if (size == 1) {\n            // Small: only center\n            if (isValid(x, y)) {\n                paper[y][x]++;\n            }\n        } else if (size == 2) {\n            // Medium: cross pattern with radius 1\n            int[][] offsets = {\n                {0, 0},\n                {-1, 0}, {1, 0}, {0, -1}, {0, 1}\n            };\n            for (int[] offset : offsets) {\n                int nx = x + offset[0];\n                int ny = y + offset[1];\n                if (isValid(nx, ny)) {\n                    paper[ny][nx]++;\n                }\n            }\n        } else if (size == 3) {\n            // Large: diamond pattern with radius 2\n            int[][] offsets = {\n                {0, 0},\n                {-1, 0}, {1, 0}, {0, -1}, {0, 1},\n                {-2, 0}, {2, 0}, {0, -2}, {0, 2},\n                {-1, -1}, {-1, 1}, {1, -1}, {1, 1}\n            };\n            for (int[] offset : offsets) {\n                int nx = x + offset[0];\n                int ny = y + offset[1];\n                if (isValid(nx, ny)) {\n                    paper[ny][nx]++;\n                }\n            }\n        }\n    }\n    \n    static boolean isValid(int x, int y) {\n        return x >= 0 && x < 10 && y >= 0 && y < 10;\n    }\n}\n", "perturbed_sampled": [" { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int[][] paper = new int[10][10]; while (sc.hasNext()) { String line = sc.nextLine(); String[] parts = line.split(\",\");  y =  }  maxDensity = 0; for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { if (paper[i][j] == 0) { zeroCells++; } maxDensity = Math.max(maxDensity, paper[i][j]); } } System.out.println(zeroCells);  dropInk(int[][] paper, int x, int y, int  1) { // Small: only center if (isValid(x, y)) { paper[y][x]++; } } else if (size == 2) { // Medium: cross pattern with radius 1 int[][] offsets = { {0, 0}, {-1, 0}, {1, 0},  for (int[] offset :  x + offset[0]; int ny = y + offset[1]; if (isValid(nx, ny)) {  if (size == 3) { // Large: diamond pattern with radius 2 int[][] offsets = { {0, 0}, {-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-2, 0}, {2, 0}, {0, -2}, {0, 2}, {-1, -1},  1} }; for (int[] offset : offsets)  = y + offset[1];  } }  return x >= 0 && x < 10 && y >= 0 && y < 10; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays;  static void main(String[] args) { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int[] area = new int[10 * 10]; String str; try { while ((str = br.readLine()) != null) { String strArray[] = str.split(\",\"); int x = Integer.parseInt(strArray[0]); int y = Integer.parseInt(strArray[1]); int size = Integer.parseInt(strArray[2]); int point = y * 10 + x; switch  + 2]++; if (x > 1) area[point - 2]++;  + 20]++; if (y  case 2: // \u5de6\u4e0a if (x > 0 && y > 0) area[point -  < 9 && y > 0) area[point - 9]++;  9 && x > 0)   x < 9) area[point + 11]++; case 1: if (x < 9) area[point +  area[point - 1]++; if (y  if (y > 1) area[point - 10]++; area[point]++; } } } catch (NumberFormatException e) { // TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af e.printStackTrace(); }  TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af e.printStackTrace(); }  for (int i = 0; i < 100; i++) { if (area[i] != 0) { blank = i; break;  System.out.println(blank); System.out.println(area[99]); } }"], "original_ll": -0.49560943245887756, "sampled_ll": -0.46376192569732666, "all_perturbed_sampled_ll": [-1.3270708322525024], "all_perturbed_original_ll": [-1.36049222946167], "perturbed_sampled_ll": -1.3270708322525024, "perturbed_original_ll": -1.36049222946167, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Cloth(object):\n    cell = None\n    x = 0\n    y = 0\n    def __init__(self, x, y):\n        self.cell = list([list([0 for i in range(y)]) for i in range(x)])\n        self.x = x\n        self.y = y\n    def check(self, x, y):\n        try:\n            self.cell[x][y] += 0\n            return True\n        except IndexError:\n            return False\n    def point(self, x, y):\n        try:\n            self.cell[x][y] += 1\n        except IndexError:\n            pass\n    def small(self, x, y):\n        if not self.check(x, y):\n            return\n        self.point(x, y + 1)\n        self.point(x - 1, y)\n        self.point(x, y)\n        self.point(x + 1, y)\n        self.point(x, y - 1)\n    def medium(self, x, y):\n        if not self.check(x, y):\n            return\n        self.small(x, y)\n        self.point(x + 1, y + 1)\n        self.point(x - 1, y + 1)\n        self.point(x + 1, y - 1)\n        self.point(x - 1, y - 1)\n    def large(self, x, y):\n        if not self.check(x, y):\n            return\n        self.medium(x, y)\n        self.point(x, y + 2)\n        self.point(x - 2, y)\n        self.point(x + 2, y)\n        self.point(x, y - 2)\ncloth = Cloth(10, 10)\nwhile True:\n    try:\n        (x, y, s) = map(lambda x:int(x)-1, raw_input().split(','))\n        if s == 0:\n            cloth.small(x, y)\n        elif s == 1:\n            cloth.medium(x, y)\n        elif s == 2:\n            cloth.large(x, y)\n    except EOFError:\n        break\nprint reduce(lambda x,y:x+y,map(lambda x:x.count(0),cloth.cell))\nprint max(map(max,cloth.cell))", "sampled": "import sys\n\n# Initialize 10x10 grid\ngrid = [[0 for _ in range(10)] for _ in range(10)]\n\n# Define ink patterns for each size relative to drop point\n# Size 1 (Small): just the center and 4 adjacent cells (cross pattern)\npatterns = {\n    1: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)],\n    2: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, 2), (0, -2), (2, 0), (-2, 0)],\n    3: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), \n        (0, 2), (0, -2), (2, 0), (-2, 0), (1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (0, 3), (0, -3), (3, 0), (-3, 0)]\n}\n\n# Read input and process drops\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    parts = line.split(',')\n    x = int(parts[0])\n    y = int(parts[1])\n    size = int(parts[2])\n    \n    # Apply ink pattern\n    for dx, dy in patterns[size]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < 10 and 0 <= ny < 10:\n            grid[ny][nx] += 1\n\n# Count cells with density 0 and find maximum density\nzero_count = 0\nmax_density = 0\n\nfor row in grid:\n    for cell in row:\n        if cell == 0:\n            zero_count += 1\n        max_density = max(max_density, cell)\n\nprint(zero_count)\nprint(max_density)\n", "perturbed_sampled": ["import sys # Initialize 10x10 grid grid = [[0 for _ in range(10)] for _ in range(10)] # Define ink patterns for each size relative  1 (Small): just the center   [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)], 2: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, 2), (0, -2), (2,  0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1),  -1), (0, 2), (0, -2), (2, 0), (-2, 0), (1, 2), (1,  (2, 1), (2, -1), (-2, 1), (-2, -1), (0, 3),  line = line.strip() if not line: continue parts = line.split(',') x = int(parts[0]) y = int(parts[1]) size = int(parts[2]) # Apply ink pattern for dx, dy in patterns[size]: nx, ny = x + dx, y + dy if 0 <= nx < 10 and  grid[ny][nx] += 1 # Count cells with density 0 and find maximum density zero_count =   in row: if cell == 0: zero_count += 1 max_density = max(max_density, cell) print(zero_count) print(max_density)"], "perturbed_original": ["class Cloth(object): cell = None x = 0 y = 0 def __init__(self, x,  i in range(y)]) for i in range(x)]) self.x = x self.y =  try: self.cell[x][y] += 0 return True except IndexError: return False  self.cell[x][y]   not self.check(x, y): return self.point(x, y + 1) self.point(x - 1, y) self.point(x, y) self.point(x + 1, y) self.point(x, y - 1) def medium(self, x, y): if not self.check(x, y): return self.small(x, y)  1) self.point(x - 1, y + 1) self.point(x + 1, y - 1) self.point(x -  large(self, x, y): if not self.check(x, y): return  2) self.point(x - 2, y) self.point(x + 2, y) self.point(x, y - 2) cloth = Cloth(10, 10) while True: try: (x, y, s) = map(lambda  s == 1: cloth.medium(x, y) elif s == 2: cloth.large(x, y) except EOFError:  print max(map(max,cloth.cell))"], "original_ll": -0.6114765405654907, "sampled_ll": -0.5842834115028381, "all_perturbed_sampled_ll": [-1.3360050916671753], "all_perturbed_original_ll": [-1.630320429801941], "perturbed_sampled_ll": -1.3360050916671753, "perturbed_original_ll": -1.630320429801941, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n \nint dayOfWeek(int year, int month, int day)\n{\n    if (month == 1 || month == 2) {\n        year--;\n        month += 12;\n    }\n    return (year + year / 4 - year / 100 + year / 400\n        + (13 * month + 8) / 5 + day) % 7;\n}\n \nint main()\n{\n    int m, d;\n    char *day[7] = {\n        \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\n    };\n     \n    while (1) {\n        scanf(\"%d%d\", &m, &d);\n        if (m == 0 || d == 0) break;\n        puts(day[dayOfWeek(2004, m, d)]);\n    }\n    return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nint main() {\n    int days_in_month[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    char *day_names[] = {\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"};\n    \n    int m, d;\n    while(1) {\n        scanf(\"%d %d\", &m, &d);\n        if(m == 0 && d == 0) break;\n        \n        int total_days = 0;\n        for(int i = 1; i < m; i++) {\n            total_days += days_in_month[i];\n        }\n        total_days += d - 1;\n        \n        int day_index = total_days % 7;\n        printf(\"%s\\n\", day_names[day_index]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int days_in_month[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; char *day_names[] = {\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\",  0 && d  = 0; for(int i = 1; i < m; i++) { total_days += days_in_month[i]; } total_days += d - 1; int day_index = total_days % 7; printf(\"%s\\n\", day_names[day_index]); } return 0; }"], "perturbed_original": ["#include <stdio.h> int dayOfWeek(int year, int month, int day) { if (month == 1 || month == 2) { year--; month += 12; } return (year + year / 4 - year / 100 +  * month + 8) / 5 + day) % 7; }  d;  \"Friday\", \"Saturday\" }; while (1) { scanf(\"%d%d\", &m, &d); if (m == 0 || d == 0)  return 0; }"], "original_ll": -0.7081373333930969, "sampled_ll": -0.44907310605049133, "all_perturbed_sampled_ll": [-1.0464158058166504], "all_perturbed_original_ll": [-1.7233946323394775], "perturbed_sampled_ll": -1.0464158058166504, "perturbed_original_ll": -1.7233946323394775, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid run(){\n\t\tint[] map={31,29,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] dp = new int [12];\n\t\tString[] str ={\n\t\t\t\t\"Monday\",\n\t\t\t\t\"Tuesday\",\n\t\t\t\t\"Wednesday\",\n\t\t\t\t\"Thursday\",\n\t\t\t\t\"Friday\",\n\t\t\t\t\"Monday\",\n\t\t\t\t\"Sunday\",\n\t\t};\n\t\tdp[0] = 2;\n\t\tfor(int i=1; i <12;i++){\n\t\t\tdp[i] = (dp[i-1] + map[i-1] +2)%7;\n\t\t}\n\t\tfor(;;){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(str[(dp[m-1]+n)%7]);\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int[] daysInMonth = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        String[] days = {\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"};\n        \n        while (true) {\n            int m = sc.nextInt();\n            int d = sc.nextInt();\n            \n            if (m == 0 && d == 0) {\n                break;\n            }\n            \n            int totalDays = 0;\n            for (int i = 1; i < m; i++) {\n                totalDays += daysInMonth[i];\n            }\n            totalDays += d - 1;\n            \n            System.out.println(days[totalDays % 7]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  static void main(String[] args) { Scanner sc = new  30, 31, 30, 31}; String[] days = {\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"}; while (true) { int m = sc.nextInt(); int d = sc.nextInt(); if (m == 0 && d == 0) { break; } int totalDays = 0; for (int i = 1; i < m; i++) { totalDays +=  - 1; System.out.println(days[totalDays % 7]); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.lang.*; import java.math.*; public class Main {  void run(){ int[] map={31,29,31,30,31,30,31,31,30,31,30,31}; int[] dp = new int [12]; String[] str ={ \"Monday\",  \"Sunday\", }; dp[0] = 2; for(int i=1; i <12;i++){ dp[i] = (dp[i-1] + map[i-1] +2)%7; }  if((m|n)==0){ break; } System.out.println(str[(dp[m-1]+n)%7]); } } public static void main(String[] args){ Main m = new Main(); m.run(); } }"], "original_ll": -0.8894072771072388, "sampled_ll": -0.4160982072353363, "all_perturbed_sampled_ll": [-1.174372673034668], "all_perturbed_original_ll": [-1.4339534044265747], "perturbed_sampled_ll": -1.174372673034668, "perturbed_original_ll": -1.4339534044265747, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "month, day = map(int, raw_input().split())\ndays = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\nyoubi = [\"Sunday\", \"Monday\", \"Tuesday\",\n         \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\nwhile month != 0:\n    Days = 0\n    for i in range(month - 1):\n        Days += days[i]\n    Days += day\n    print youbi[Days % 7]\n    month, day = map(int, raw_input().split())", "sampled": "days_of_week = [\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"]\ndays_in_month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nwhile True:\n    line = input().split()\n    m, d = int(line[0]), int(line[1])\n    \n    if m == 0 and d == 0:\n        break\n    \n    total_days = 0\n    for i in range(1, m):\n        total_days += days_in_month[i]\n    total_days += d - 1\n    \n    day_index = total_days % 7\n    print(days_of_week[day_index])\n", "perturbed_sampled": ["days_of_week =  \"Tuesday\", \"Wednesday\"] days_in_month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] while True: line = input().split() m, d = int(line[0]), int(line[1]) if m == 0 and d == 0: break total_days  range(1, m): total_days += days_in_month[i] total_days += d  % 7 print(days_of_week[day_index])"], "perturbed_original": ["month, day = map(int, raw_input().split()) days = [31, 29, 31, 30,  31, 30, 31] youbi = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",  0: Days = 0 for i in range(month - 1): Days += days[i] Days += day print youbi[Days  map(int, raw_input().split())"], "original_ll": -0.5738586187362671, "sampled_ll": -0.6477815508842468, "all_perturbed_sampled_ll": [-1.4012649059295654], "all_perturbed_original_ll": [-1.63917076587677], "perturbed_sampled_ll": -1.4012649059295654, "perturbed_original_ll": -1.63917076587677, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n  int countArray[101], number, mx_number = 0;\n  memset(countArray, 0, sizeof countArray);\n\n  while(scanf(\"%d\", &number)!=EOF){\n    ++countArray[number];\n  }\n\n  for(number = 100; number > 0; --number)\n    if(countArray[number] > countArray[mx_number])\n      mx_number = number;\n\n  for(number = 1; number <= mx_number; ++number)\n    if(countArray[number] == countArray[mx_number])\n      printf(\"%d\\n\", number);\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int count[101] = {0};\n    int num;\n    int maxCount = 0;\n    \n    while (scanf(\"%d\", &num) != EOF) {\n        count[num]++;\n        if (count[num] > maxCount) {\n            maxCount = count[num];\n        }\n    }\n    \n    for (int i = 1; i <= 100; i++) {\n        if (count[i] == maxCount) {\n            printf(\"%d\\n\", i);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int count[101] = {0}; int num; int maxCount = 0; while (scanf(\"%d\", &num) != EOF) { 0;<extra_id_12>++ ;<extra_id_13>++<extra_id_14>{<extra_id_15>= 0<extra_id_16>count[i] < = maxCount)<extra_id_17>count[i] >= 100 {  for (int i = 1; i <= 100; i++) { if (count[i] == maxCount) {  0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main() {  0; memset(countArray, 0, sizeof countArray); while(scanf(\"%d\", &number)!=EOF){ ++countArray[number]; } for(number = 100; number > 0; --number) if(countArray[number] > countArray[mx_number]) mx_number = number; for(number =  if(countArray[number] == countArray[mx_number]) printf(\"%d\\n\", number); return 0; }"], "original_ll": -0.906397819519043, "sampled_ll": -0.40704166889190674, "all_perturbed_sampled_ll": [-1.8363316059112549], "all_perturbed_original_ll": [-1.6422549486160278], "perturbed_sampled_ll": -1.8363316059112549, "perturbed_original_ll": -1.6422549486160278, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u30fb\u30b9\u30bf\u30d6\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString tmp = null;\n\t\tint cup = 0;\n\t\tint mun = 0;\n\t\tint ter = 0;\n\t\tString[] rrr;\n\t\tint st = 0,sr = 0;\n\t\tint mon = 0;\n\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\ttry {\n\t\t\t\ttmp = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp == null){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp.equals(\"\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tal.add(Integer.parseInt(tmp));\n\t\t}\n\t\t\n\t\t//System.out.println(al.toString());\n\t\tCollections.sort(al);\n\t\t//System.out.println(al.toString());\n\t\tArrayList<Integer> al2 = new ArrayList<Integer>();\n\t\tArrayList<Integer> al3 = new ArrayList<Integer>();\n\t\tint tmpr = 0;\n\t\t\n\t\tfor(int i=0;i<al.size();i++){\n\t\t\tif(tmpr ==0){\n\t\t\t\tal2.add(al.get(i));\n\t\t\t}\n\t\t\tif(al2.get(tmpr) < al.get(i)){\n\t\t\t\ttmpr++;\n\t\t\t\tal2.add(al.get(i));\n\t\t\t}\n\t\t}\n\t\tint aaa = 0;\n\t\tfor(int i=0;i<al2.size();i++){\n\t\t\ttmpr = 0;\n\t\t\tfor(int j=0;j<al.size();j++){\n\t\t\t\tif(al.get(j) == al2.get(i)){\n\t\t\t\t\ttmpr++;\n\t\t\t\t}\n\t\t\t\tal3.add(tmpr);\n\t\t\t\tif(aaa < tmpr){\n\t\t\t\t\taaa = tmpr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<al3.size();i++){\n\t\t\tif(aaa == al3.get(i)){\n\t\t\t\tSystem.out.println(al2.get(i));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Map<Integer, Integer> count = new HashMap<>();\n        \n        while (sc.hasNextInt()) {\n            int num = sc.nextInt();\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n        \n        int maxCount = 0;\n        for (int c : count.values()) {\n            maxCount = Math.max(maxCount, c);\n        }\n        \n        List<Integer> modes = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                modes.add(entry.getKey());\n            }\n        }\n        \n        Collections.sort(modes);\n        \n        for (int mode : modes) {\n            System.out.println(mode);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); Map<Integer, Integer> count = new  num = sc.nextInt(); count.put(num, count.getOrDefault(num, 0) +   Math.max(maxCount, c); } List<Integer> modes = new ArrayList<>(); for (Map.Entry<Integer, Integer> entry : count.entrySet()) { if (entry.getValue() == maxCount) { modes.add(entry.getKey()); } } Collections.sort(modes); for (int mode : modes) { System.out.println(mode); } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import  Main { public static void main(String[] args) { // TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u30fb\u30b9\u30bf\u30d6 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String tmp = null; int cup = 0; int mun = 0; int ter = 0; String[] rrr; int  int mon = 0; ArrayList<Integer> al =  tmp = br.readLine(); }  TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af  break;   al2 = new ArrayList<Integer>(); ArrayList<Integer> al3 = new ArrayList<Integer>(); int tmpr = 0; for(int i=0;i<al.size();i++){ if(tmpr ==0){ al2.add(al.get(i));  al2.add(al.get(i)); } } int aaa = 0; for(int i=0;i<al2.size();i++){ tmpr = 0; for(int j=0;j<al.size();j++){ if(al.get(j) == al2.get(i)){ tmpr++; } al3.add(tmpr); if(aaa < tmpr){ aaa = tmpr; } } } for(int i=0;i<al3.size();i++){ if(aaa  } }"], "original_ll": -0.6564191579818726, "sampled_ll": -0.304797887802124, "all_perturbed_sampled_ll": [-1.1613175868988037], "all_perturbed_original_ll": [-1.5575052499771118], "perturbed_sampled_ll": -1.1613175868988037, "perturbed_original_ll": -1.5575052499771118, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "num = [[0,i+1] for i in range(100)]\nwhile True:\n    try:\n        num[int(input())-1][0] += 1\n    except:\n        num.sort(reverse = True)\n        ans = []\n        for i in range(100):\n            if num[i][0] == num[0][0]:\n                ans.append(num[i][1])\n            else:\n                ans.sort()\n                for z in ans:\n                    print(z)\n                break\n        break\n", "sampled": "import sys\nfrom collections import Counter\n\nnumbers = []\nfor line in sys.stdin:\n    numbers.append(int(line.strip()))\n\ncounter = Counter(numbers)\nmax_count = max(counter.values())\nmode_values = sorted([num for num, count in counter.items() if count == max_count])\n\nfor val in mode_values:\n    print(val)\n", "perturbed_sampled": ["import sys from collections import Counter  in sys.stdin: numbers.append(int(line.strip())) counter = Counter(numbers)  sorted([num for num, count in counter.items() if count == max_count]) for val in mode_values: print(val)"], "perturbed_original": ["num = [[0,i+1] for i in range(100)] while True: try: num[int(input())-1][0] += 1 except:  [] for i in range(100): if num[i][0] == num[0][0]: ans.append(num[i][1]) else: ans.sort() for  break"], "original_ll": -0.9892707467079163, "sampled_ll": -1.0008443593978882, "all_perturbed_sampled_ll": [-2.689795732498169], "all_perturbed_original_ll": [-1.859880805015564], "perturbed_sampled_ll": -2.689795732498169, "perturbed_original_ll": -1.859880805015564, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void){\n\tint i=0,j,c,max=0,ans1=100,ans2=100,count=0;\n\tchar s[1000][33]={0};\n\tchar ch;\n\t\n\twhile(1){\n\t\tscanf(\"%c\",&ch);\n\t\tif(ch=='\\n')break;\n\t\tif(ch==' '){\n\t\t\tcount++;\n\t\t\ti=0;\n\t\t}\n\t\ts[count][i]=ch;\n\t\tif(max<1+i){\n\t\t\tmax=i+1;\n\t\t\tans2=count;\n\t\t}\n\t\tif(ch!=' ')i++;\n\t}\n\tmax=0;\n\tfor(i=0;i<count;i++){\n\t\tfor(j=i+1,c=0;j<count;j++){\n\t\t\tif(strcmp(s[i],s[j])==0){\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tif(max<c){\n\t\t\t\tmax=c;\n\t\t\t\tans1=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%s %s\\n\",s[ans1],s[ans2]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    char text[1001];\n    char words[100][33];\n    int count[100] = {0};\n    int wordCount = 0;\n    \n    fgets(text, sizeof(text), stdin);\n    \n    // Remove newline if present\n    int len = strlen(text);\n    if (len > 0 && text[len-1] == '\\n') {\n        text[len-1] = '\\0';\n    }\n    \n    // Parse words\n    char *token = strtok(text, \" \");\n    while (token != NULL) {\n        int found = -1;\n        for (int i = 0; i < wordCount; i++) {\n            if (strcmp(words[i], token) == 0) {\n                found = i;\n                break;\n            }\n        }\n        \n        if (found != -1) {\n            count[found]++;\n        } else {\n            strcpy(words[wordCount], token);\n            count[wordCount] = 1;\n            wordCount++;\n        }\n        \n        token = strtok(NULL, \" \");\n    }\n    \n    // Find most frequent word\n    int maxCount = 0;\n    int maxCountIndex = 0;\n    for (int i = 0; i < wordCount; i++) {\n        if (count[i] > maxCount) {\n            maxCount = count[i];\n            maxCountIndex = i;\n        }\n    }\n    \n    // Find longest word\n    int maxLen = 0;\n    int maxLenIndex = 0;\n    for (int i = 0; i < wordCount; i++) {\n        int len = strlen(words[i]);\n        if (len > maxLen) {\n            maxLen = len;\n            maxLenIndex = i;\n        }\n    }\n    \n    printf(\"%s %s\\n\", words[maxCountIndex], words[maxLenIndex]);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <ctype.h> int main() { char text[1001]; char words[100][33]; int count[100] = {0}; int  stdin); // Remove newline if present int len =  && text[len-1] == '\\n') { text[len-1] = '\\0';  \"); while (token != NULL) { int found = -1; for (int i = 0; i < wordCount; i++) { if (strcmp(words[i], token) == 0) { found = i; break; }  {   } token = strtok(NULL, \" \"); } //  maxCountIndex = 0; for (int i = 0; i < wordCount; i++) { if (count[i] > maxCount) { maxCount = count[i]; maxCountIndex =  longest word int maxLen = 0; int maxLenIndex = 0; for (int i = 0; i < wordCount; i++) { int len = strlen(words[i]); if (len >  maxLenIndex = i; } } printf(\"%s %s\\n\", words[maxCountIndex], words[maxLenIndex]); return 0; }"], "perturbed_original": ["#include  int i=0,j,c,max=0,ans1=100,ans2=100,count=0; char s[1000][33]={0}; char ch;  count++; i=0; } s[count][i]=ch; if(max<1+i){ max=i+1; ans2=count; } if(ch!=' ')i++; } max=0; for(i=0;i<count;i++){ for(j=i+1,c=0;j<count;j++){ if(strcmp(s[i],s[j])==0){ c++; } if(max<c){ max=c; ans1=i; } } } printf(\"%s %s\\n\",s[ans1],s[ans2]); return 0; }"], "original_ll": -0.9577261805534363, "sampled_ll": -0.36942654848098755, "all_perturbed_sampled_ll": [-1.357509970664978], "all_perturbed_original_ll": [-1.5452182292938232], "perturbed_sampled_ll": -1.357509970664978, "perturbed_original_ll": -1.5452182292938232, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.HashMap;\nimport java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\n\t\tString[] st = sc.nextLine().split(\" \");\n\t\t\n\t\tfor(int i = 0; i < st.length; i++)\n\t\t\tif(map.containsKey(st[i]))\n\t\t\t\tmap.put(st[i], map.get(st[i])+1);\n\t\t\telse\n\t\t\t\tmap.put(st[i], 1);\n\t\t\n\t\tString max = st[0];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < st.length-1; i++){\n\t\t\tif(map.get(st[i]) < map.get(st[i+1]))max = st[i+1];\n\t\t    if(st[i].length() < st[i+1].length())count = i+1;\n\t\t}\n\t\t\tSystem.out.println(max + \" \" + st[count]);\n\t\t\t\n\t\t\tsc.close();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] words = line.split(\" \");\n        \n        Map<String, Integer> frequency = new HashMap<>();\n        for (String word : words) {\n            frequency.put(word, frequency.getOrDefault(word, 0) + 1);\n        }\n        \n        String mostFrequent = \"\";\n        int maxFreq = 0;\n        for (Map.Entry<String, Integer> entry : frequency.entrySet()) {\n            if (entry.getValue() > maxFreq) {\n                maxFreq = entry.getValue();\n                mostFrequent = entry.getKey();\n            }\n        }\n        \n        String longest = \"\";\n        int maxLen = 0;\n        for (String word : words) {\n            if (word.length() > maxLen) {\n                maxLen = word.length();\n                longest = word;\n            }\n        }\n        \n        System.out.println(mostFrequent + \" \" + longest);\n    }\n}\n", "perturbed_sampled": [" { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String line =  \"); Map<String, Integer> frequency = new HashMap<>(); for (String word : words) { frequency.put(word, frequency.getOrDefault(word, 0) + 1); }  maxFreq = 0; for (Map.Entry<String, Integer> entry : frequency.entrySet())  { maxFreq = entry.getValue(); mostFrequent = entry.getKey(); }  int maxLen = 0; for (String word : words) { if (word.length() > maxLen) { maxLen = word.length();  System.out.println(mostFrequent + \" \" + longest); } }"], "perturbed_original": ["import java.util.HashMap; import java.util.Scanner; class \");<extra_id_2>\" {<extra_id_3>; }<extra_id_4>}<extra_id_5>(args){<extra_id_6>.<extra_id_7>; } } } args){ Scanner  Integer> map = new HashMap<String, Integer>(); String[] st = sc.nextLine().split(\" \"); for(int  st.length; i++) if(map.containsKey(st[i])) map.put(st[i], map.get(st[i])+1); else map.put(st[i], 1); String max = st[0]; int count = 0; for(int i = 0; i < st.length-1; i++){ if(map.get(st[i]) < map.get(st[i+1]))max = st[i+1]; if(st[i].length() < st[i+1].length())count = i+1; } System.out.println(max + \"  }"], "original_ll": -0.7484049797058105, "sampled_ll": -0.33789604902267456, "all_perturbed_sampled_ll": [-1.1766164302825928], "all_perturbed_original_ll": [-1.6894397735595703], "perturbed_sampled_ll": -1.1766164302825928, "perturbed_original_ll": -1.6894397735595703, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def solve():\n    text = input()\n    longest, length = '', 0\n    dic = {}\n    for word in text.split():\n        if word in dic.keys():\n            dic[word] += 1\n        else:\n            dic[word] = 1\n        \n        if length < len(word):\n            longest = word\n            length = len(word)\n    \n    target, cnt = '', 0\n    for k, v in dic.items():\n        if v > cnt:\n            target = k\n            cnt = v\n    print(target, longest)\n\nif __name__ == \"__main__\":\n    solve()\n\n", "sampled": "text = input().split()\nword_count = {}\nfor word in text:\n    word_count[word] = word_count.get(word, 0) + 1\n\nmost_frequent = max(word_count, key=word_count.get)\nlongest = max(text, key=len)\n\nprint(most_frequent, longest)\n", "perturbed_sampled": ["text = input().split() word_count = {} for word in text: word_count[word] = word_count.get(word, 0) + 1 most_frequent = max(word_count, key=word_count.get)  longest)"], "perturbed_original": ["def solve(): text = input() longest, length = '', 0 dic =  if word in dic.keys(): dic[word] += 1 else: dic[word] = 1 if length < len(word): longest =  cnt = '', 0 for k, v in dic.items():  = k cnt = v print(target, longest) if __name__ == \"__main__\": solve()"], "original_ll": -0.9420645833015442, "sampled_ll": -0.9495123624801636, "all_perturbed_sampled_ll": [-1.8184187412261963], "all_perturbed_original_ll": [-2.3540053367614746], "perturbed_sampled_ll": -1.8184187412261963, "perturbed_original_ll": -2.3540053367614746, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\n\nint val[10];\nint s;\n\nint getWay(int x, int n, int sum)\n{\n\tint ret = 0;\n\tint i;\n\t\n\tif (n == 0){\n\t\tif (sum == s){\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\t\n\tfor (i = x; i < 10; i++){\n\t\tif (val[i] == 0 && sum + i <= s){\n\t\t\tval[i] = 1;\n\t\t\tret += getWay(i, n - 1, i + sum);\n\t\t\tval[i] = 0;\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint main(void)\n{\n\twhile (1){\n\t\tint n;\n\t\t\n\t\tscanf(\"%d%d\", &n, &s);\n\t\tmemset(val, 0, sizeof(val));\n\t\t\n\t\tif (n == 0 && s == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", getWay(0, n, 0));\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n\nint count_combinations(int pos, int n, int s, int used) {\n    if (n == 0) {\n        return (s == 0) ? 1 : 0;\n    }\n    if (pos > 9 || s < 0) {\n        return 0;\n    }\n    \n    int result = 0;\n    // Don't use current digit\n    result += count_combinations(pos + 1, n, s, used);\n    // Use current digit\n    result += count_combinations(pos + 1, n - 1, s - pos, used);\n    \n    return result;\n}\n\nint main() {\n    int n, s;\n    \n    while (1) {\n        scanf(\"%d %d\", &n, &s);\n        if (n == 0 && s == 0) {\n            break;\n        }\n        \n        int result = count_combinations(0, n, s, 0);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int count_combinations(int pos, int n, int  (n == 0) { return (s == 0) ? 1 : 0; } if (pos > 9 || s < 0) { return  0; // Don't use current digit result += count_combinations(pos +  Use current digit result += count_combinations(pos +   int n, s; while (1) { scanf(\"%d %d\", &n, &s); if (n == 0 && s == 0) { break; } int result = count_combinations(0, n, s, 0); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": [" val[10]; int s; int getWay(int x,  int  if (n == 0){ if (sum == s){ return (1);  < 10; i++){ if (val[i] == 0 && sum + i <= s){ val[i] = 1; ret += getWay(i, n - 1, i + sum); val[i] = 0; } } return (ret); } int main(void) { while (1){ int n;  sizeof(val)); if (n == 0 && s == 0){ break; } printf(\"%d\\n\", getWay(0, n, 0)); } return (0); }"], "original_ll": -0.7298691272735596, "sampled_ll": -0.5468301773071289, "all_perturbed_sampled_ll": [-1.7431508302688599], "all_perturbed_original_ll": [-1.8413115739822388], "perturbed_sampled_ll": -1.7431508302688599, "perturbed_original_ll": -1.8413115739822388, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main {\n    public static void main(String args[]){\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try{\n            String line;\n            \n            while((line=br.readLine())!=null){\n                if(line.equals(\"\"))break;\n                String[] splited = line.split(\" \");\n                int n = Integer.parseInt(splited[0]);\n                s = Integer.parseInt(splited[1]);\n                if(n==0&&s==0)break;if(n>=10)System.out.println(\"0\");\n                    combis(1,n);\n                    System.out.println(count);\n                count=0;\n            }         \n        }catch(Exception e){e.printStackTrace();}\n        \n    }\n    static int[] com = new int[10];\n    static int count = 0,s=0;\n    static void combis(int st,int r){\n        if(st<=r){\n            for(int i=(st==1)? 0:com[st-1]+1;i<=9-r+st;i++){\n                com[st]=i;\n                combis(st+1,r);\n            }\n        }else{\n            //System.out.println(Arrays.toString(com));\n            int sum=0; for(int i=1;i<=r;i++) sum+=com[i];\n            if(sum==s)count++;\n        }\n        \n        }\n    static int _10Cn(int n){\n            int _n=1,d=1;\n            for(int i=1; i<=n;i++){\n                _n*=11-i; d*=i;\n            }\n            return _n/d;\n        }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int s = sc.nextInt();\n            \n            if (n == 0 && s == 0) {\n                break;\n            }\n            \n            int count = countCombinations(n, s, 0, 0);\n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n    \n    private static int countCombinations(int n, int s, int start, int depth) {\n        if (depth == n) {\n            return s == 0 ? 1 : 0;\n        }\n        \n        if (start > 9) {\n            return 0;\n        }\n        \n        int count = 0;\n        for (int i = start; i <= 9; i++) {\n            count += countCombinations(n, s - i, i + 1, depth + 1);\n        }\n        \n        return count;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  (true)  int s = sc.nextInt(); if (n == 0 && s == 0) { break; } int count = countCombinations(n, s, 0, 0); System.out.println(count); } sc.close(); } private static int countCombinations(int n, int s, int start, int depth) { if (depth == n)  ? 1 : 0;  int count = 0; for (int i = start; i <= 9; i++) { count  i + 1, depth + 1); } return count; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; public class Main { public static void main(String args[]){ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); try{ String  = line.split(\" \"); int n = Integer.parseInt(splited[0]); s = Integer.parseInt(splited[1]); if(n==0&&s==0)break;if(n>=10)System.out.println(\"0\"); combis(1,n); System.out.println(count); count=0; } }catch(Exception e){e.printStackTrace();} }  int[10]; static int count =  0:com[st-1]+1;i<=9-r+st;i++){ com[st]=i; combis(st+1,r); } }else{ //System.out.println(Arrays.toString(com)); int sum=0; for(int i=1;i<=r;i++) sum+=com[i]; if(sum==s)count++; } } static int _10Cn(int n){ int _n=1,d=1; for(int i=1;  _n/d; } }"], "original_ll": -1.1402502059936523, "sampled_ll": -0.4361085891723633, "all_perturbed_sampled_ll": [-1.4917534589767456], "all_perturbed_original_ll": [-1.825302004814148], "perturbed_sampled_ll": -1.4917534589767456, "perturbed_original_ll": -1.825302004814148, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nsys.setrecursionlimit(10000)\n\ndef solve(i,wa,use):\n    global ct,s,n\n    if wa==s and use==n:\n        ct+=1\n        return\n    if use>=n or i==10 or wa>s:\n        return\n    solve(i+1,wa,use)\n    solve(i+1,wa+i,use+1)\n\nwhile 1:\n    n,s=map(int,raw_input().split())\n    if n==0 and s==0:\n        break\n    ct=0\n    wa=0\n    solve(0,0,0)\n    print ct", "sampled": "from itertools import combinations\n\nwhile True:\n    n, s = map(int, input().split())\n    if n == 0 and s == 0:\n        break\n    \n    count = 0\n    for combo in combinations(range(10), n):\n        if sum(combo) == s:\n            count += 1\n    \n    print(count)\n", "perturbed_sampled": ["from itertools import combinations while True: n, s = map(int, input().split()) if n == 0 and s  0 for combo in combinations(range(10), n):  += 1 print(count)"], "perturbed_original": ["import sys sys.setrecursionlimit(10000) def solve(i,wa,use): global ct,s,n if wa==s and use==n: ct+=1 return  while 1: n,s=map(int,raw_input().split()) if n==0 and s==0: break ct=0 wa=0 solve(0,0,0) print ct"], "original_ll": -1.0525683164596558, "sampled_ll": -0.8878548741340637, "all_perturbed_sampled_ll": [-2.453259229660034], "all_perturbed_original_ll": [-2.072380542755127], "perturbed_sampled_ll": -2.453259229660034, "perturbed_original_ll": -2.072380542755127, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0031\nWeight\n*/\n#include <stdio.h>\n\n\nmain()\n{\n  int weight;\n  int fundou;\n  int flag;\n  \n  while(EOF !=scanf(\"%d\",&weight))\n    {\n      flag = 0;\n      for(fundou=1;fundou <= 512;fundou <<= 1)\n      { if(weight & fundou)\n        {\n          if(flag)\n            printf(\" \");\n          printf(\"%d\",fundou);\n          flag = 1;\n        }\n      }\n        printf(\"\\n\");\n    }\n\nreturn(0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int weight;\n    int weights[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};\n    \n    while(scanf(\"%d\", &weight) != EOF) {\n        int first = 1;\n        for(int i = 0; i < 10; i++) {\n            if(weight & (1 << i)) {\n                if(!first) {\n                    printf(\" \");\n                }\n                printf(\"%d\", weights[i]);\n                first = 0;\n            }\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["}<extra_id_2>;<extra_id_3>; return<extra_id_4>weights[15]; first<extra_id_5>* (1 <<<extra_id_6>if(weight & (1 << i))<extra_id_7>printf(\"%d\",<extra_id_8>weights[15]); first int weight; int weights[] = {1, 2, 4, 8, 16, } printf(\"%d\", weights[15]);<extra_id_9>first<extra_id_10>if(weight & (1<<i)) {<extra_id_11>*weights[15]; } else<extra_id_12>}<extra_id_13>weights[15]); }<extra_id_14>*/<extra_id_15>weight =<extra_id_16> while(scanf(\"%d\", &weight) != EOF) { int first = 1; for(int i = 0; i < 10; i++) { if(weight & (1 << i)) { if(!first) { printf(\" \"); } printf(\"%d\", weights[i]); first  } return 0; }"], "perturbed_original": ["/* AizuOnline A0031 Weight */ #include <stdio.h> main() { int weight; int fundou; int flag; while(EOF !=scanf(\"%d\",&weight)) { flag = 0; for(fundou=1;fundou <=  printf(\" \"); printf(\"%d\",fundou); flag = 1; } } printf(\"\\n\"); } return(0); }"], "original_ll": -1.8325436115264893, "sampled_ll": -0.5561484694480896, "all_perturbed_sampled_ll": [-1.77628493309021], "all_perturbed_original_ll": [-2.4544808864593506], "perturbed_sampled_ll": -1.77628493309021, "perturbed_original_ll": -2.4544808864593506, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n        public static void main(String[] args){\n                Scanner sc = new Scanner(System.in);\n                while(sc.hasNext()){\n                        String b = Integer.toString(sc.nextInt(), 2); \n                        String s = \"\"; \n                        for(int i = 0; i < b.length(); i++){\n                                if(b.charAt(b.length()-1-i) == '1'){\n                                        if(!s.equals(\"\")){\n                                                s += \" \";\n                                        }   \n                                        s += (int)Math.pow(2,i);\n                                }   \n                        }   \n                        System.out.println(s);\n                }   \n                sc.close();\n        }   \n}", "sampled": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int weight = sc.nextInt();\n            ArrayList<Integer> weights = new ArrayList<>();\n            \n            int[] powers = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};\n            \n            for (int i = 0; i < powers.length; i++) {\n                if ((weight & (1 << i)) != 0) {\n                    weights.add(powers[i]);\n                }\n            }\n            \n            for (int i = 0; i < weights.size(); i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(weights.get(i));\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; import java.util.ArrayList; public class Main { public static void main(String[] args) {  while (sc.hasNext()) { int weight =  ArrayList<>(); int[] powers = {1, 2,  (int i = 0; i < powers.length; i++) {  i)) != 0) { weights.add(powers[i]); } } for (int i = 0; i < weights.size(); i++) { if (i > 0) System.out.print(\" \"); System.out.print(weights.get(i)); } System.out.println(); } sc.close(); } }"], "perturbed_original": ["import  void  new Scanner(System.in); while(sc.hasNext()){ String b = Integer.toString(sc.nextInt(), 2); String s =  i < b.length(); i++){ if(b.charAt(b.length()-1-i) == '1'){ if(!s.equals(\"\")){ s += \" \"; } s += (int)Math.pow(2,i); } } System.out.println(s); } sc.close(); } }"], "original_ll": -0.9417181611061096, "sampled_ll": -0.47757869958877563, "all_perturbed_sampled_ll": [-1.5426275730133057], "all_perturbed_original_ll": [-1.9781231880187988], "perturbed_sampled_ll": -1.5426275730133057, "perturbed_original_ll": -1.9781231880187988, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#encoding=utf-8\nimport itertools as iter\nimport sys\nfor i in sys.stdin:\n    omori = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n    x = int(i)\n    for i in xrange(1,11):\n        for element in iter.combinations(omori,i):\n             if sum(element) == x:\n                 for k in xrange(len(element)):\n                     print element[k],\n                 print \"\"", "sampled": "import sys\n\nfor line in sys.stdin:\n    weight = int(line.strip())\n    weights = []\n    power = 0\n    \n    while weight > 0:\n        if weight & 1:\n            weights.append(2 ** power)\n        weight >>= 1\n        power += 1\n    \n    print(' '.join(map(str, weights)))\n", "perturbed_sampled": ["import sys for line in sys.stdin: weight = int(line.strip()) weights = [] power = 0 while weight > 0: if  power += 1 print(' '.join(map(str, weights)))"], "perturbed_original": ["#encoding=utf-8 import itertools as  in sys.stdin: omori = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512] x = int(i) for i in xrange(1,11): for element in iter.combinations(omori,i): if sum(element) == x: for k  \"\""], "original_ll": -1.4095820188522339, "sampled_ll": -1.1125847101211548, "all_perturbed_sampled_ll": [-2.8097686767578125], "all_perturbed_original_ll": [-2.406564474105835], "perturbed_sampled_ll": -2.8097686767578125, "perturbed_original_ll": -2.406564474105835, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint tyou=0, hisi=0;\n\tint a, b, c;\n\t\n\twhile(scanf(\"%d,%d,%d\", &a, &b, &c)!=EOF) {\n\t\tif(c*c==a*a+b*b) tyou++;\n\t\tif(a==b) hisi++;\n\t}\n\t\n\tprintf(\"%d\\n%d\\n\", tyou, hisi);\n\t\n\treturn 0;\n}\n", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[256];\n    int rectangles = 0;\n    int rhombuses = 0;\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int a, b, c;\n        if (sscanf(line, \"%d,%d,%d\", &a, &b, &c) == 3) {\n            // Check if it's a rectangle: a^2 + b^2 = c^2\n            if (a * a + b * b == c * c) {\n                rectangles++;\n            }\n            // Check if it's a rhombus: a = b\n            else if (a == b) {\n                rhombuses++;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", rectangles);\n    printf(\"%d\\n\", rhombuses);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() {  0; int rhombuses = 0;   (sscanf(line, \"%d,%d,%d\", &a, &b, &c) == 3) { // Check if it's a rectangle: a^2 + b^2 = c^2 if (a * a + b * b == c * c) { rectangles++; } // Check if it's a rhombus: a   } } printf(\"%d\\n\", rectangles); printf(\"%d\\n\", rhombuses); return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int tyou=0, hisi=0; int a, b, c; while(scanf(\"%d,%d,%d\", &a, &b,  hisi++; } printf(\"%d\\n%d\\n\", tyou, hisi); return 0; }"], "original_ll": -1.3021458387374878, "sampled_ll": -0.5449933409690857, "all_perturbed_sampled_ll": [-1.6056042909622192], "all_perturbed_original_ll": [-1.9623292684555054], "perturbed_sampled_ll": -1.6056042909622192, "perturbed_original_ll": -1.9623292684555054, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = null;\n\t\ttry {\n\t\t\tsc = new Scanner(System.in);\n\t\t\tint countRectangle = 0;\n\t\t\tint countRhombus = 0;\n\t\t\twhile (sc.hasNextLine()) {\n\t\t\t\tString[] input = sc.nextLine().split(\",\");\n\t\t\t\tint[] x = new int[3];\n\t\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\t\tx[i] = Integer.parseInt(input[i]);\n\t\t\t\tif (x[0] * x[0] + x[1] * x[1] == x[2] * x[2])\n\t\t\t\t\tcountRectangle++;\n\t\t\t\telse if (x[0] == x[1])\n\t\t\t\t\tcountRhombus++;\n\t\t\t}\n\t\t\tSystem.out.println(countRectangle);\n\t\t\tSystem.out.println(countRhombus);\n\t\t} finally {\n\t\t\tsc.close();\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int rectangles = 0;\n        int rhombuses = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            int c = Integer.parseInt(parts[2]);\n            \n            // Check if rectangle: a^2 + b^2 = c^2 (diagonal satisfies Pythagorean theorem)\n            if (a * a + b * b == c * c) {\n                rectangles++;\n            }\n            // Check if rhombus: all sides equal (a == b)\n            else if (a == b) {\n                rhombuses++;\n            }\n        }\n        \n        System.out.println(rectangles);\n        System.out.println(rhombuses);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["  args) { Scanner sc = new  int rhombuses = 0; while (sc.hasNextLine()) { String line = sc.nextLine().trim(); if (line.isEmpty()) break; String[] parts = line.split(\",\"); int a = Integer.parseInt(parts[0]); int b = Integer.parseInt(parts[1]); int c = Integer.parseInt(parts[2]); // Check if rectangle: a^2 + b^2 = c^2 (diagonal satisfies Pythagorean theorem) if  * b == c * c) { rectangles++; } // Check if rhombus: all sides equal (a == b) else if  sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String[] args)  try { sc =  0; while (sc.hasNextLine()) { String[] input = sc.nextLine().split(\",\");  for (int i = 0; i < 3; i++) x[i] = Integer.parseInt(input[i]); if (x[0] * x[0] + x[1] * x[1] == x[2] * x[2]) countRectangle++; else if (x[0] == x[1]) countRhombus++; } System.out.println(countRectangle); System.out.println(countRhombus); } finally { sc.close(); } } }"], "original_ll": -0.6085971593856812, "sampled_ll": -0.625332236289978, "all_perturbed_sampled_ll": [-1.9043214321136475], "all_perturbed_original_ll": [-1.21506667137146], "perturbed_sampled_ll": -1.9043214321136475, "perturbed_original_ll": -1.21506667137146, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nnum1=0                                          #\u9577\u65b9\u5f62\u306e\u6570                                                 \nnum2=0                                          #\u3072\u3057\u5f62\u306e\u6570\nwhile True:\n    try:\n        a,b,c=list(map(int, input().split(\",\")))\n    except:\n        break\n    \n    if pow(a,2)+pow(b,2)==pow(c,2):\n        num1+=1\n    elif a==b and a+b>c:\n        num2+=1\n\nprint(num1)\nprint(num2)\n\n", "sampled": "import sys\nimport math\n\nrectangle_count = 0\nrhombus_count = 0\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    \n    parts = line.split(',')\n    a, b, c = int(parts[0]), int(parts[1]), int(parts[2])\n    \n    # Check if it's a rectangle\n    # In a rectangle, the diagonal satisfies: c^2 = a^2 + b^2\n    if a * a + b * b == c * c:\n        rectangle_count += 1\n    \n    # Check if it's a rhombus\n    # In a rhombus, all sides are equal: a == b\n    if a == b:\n        rhombus_count += 1\n\nprint(rectangle_count)\nprint(rhombus_count)\n", "perturbed_sampled": ["import sys import math  0 for  line.strip() if not line: continue parts = line.split(',') a, b, c = int(parts[0]), int(parts[1]), int(parts[2]) # Check if  a rectangle, the diagonal satisfies: c^2 = a^2  a + b * b  += 1 # Check if it's a rhombus # In a rhombus, all sides are equal: a == b if a == b: rhombus_count += 1 print(rectangle_count) print(rhombus_count)"], "perturbed_original": ["import math num1=0 #\u9577\u65b9\u5f62\u306e\u6570 num2=0 #\u3072\u3057\u5f62\u306e\u6570 while  break if pow(a,2)+pow(b,2)==pow(c,2): num1+=1 elif a==b and a+b>c: num2+=1 print(num1) print(num2)"], "original_ll": -1.7513809204101562, "sampled_ll": -0.7385423183441162, "all_perturbed_sampled_ll": [-2.3324553966522217], "all_perturbed_original_ll": [-2.375972270965576], "perturbed_sampled_ll": -2.3324553966522217, "perturbed_original_ll": -2.375972270965576, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n\n\tint i,j,n,a[10],b,c,nflag;\n\n\tscanf(\"%d\",&n);\n\n\tfor(i=0;i<n;i++){\n\t\tnflag=0;\n\t\tfor(j=0;j<9;j++) scanf(\"%d \",&a[j]);\n\t\tscanf(\"%d\",&a[9]);\n\n\t\tb=a[0];\n\t\tc=0;\n\t\tfor(j=1;j<10;j++){\n\t\t\tif(b<a[j]) b=a[j];\n\t\t\telse if(c<a[j]) c=a[j];\n\t\t\telse{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\tnflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(nflag) continue;\n\t\tprintf(\"YES\\n\");\n\n\t}\n\n\n\n\treturn 0;\n\n}", "sampled": "#include <stdio.h>\n#include <stdbool.h>\n\nbool canArrange(int balls[10]) {\n    // Try all possible combinations of putting balls in B or C\n    // Use bitmask: 0 = put in B, 1 = put in C\n    for (int mask = 0; mask < (1 << 10); mask++) {\n        int b[10], c[10];\n        int bCount = 0, cCount = 0;\n        bool valid = true;\n        \n        // Distribute balls according to mask\n        for (int i = 0; i < 10; i++) {\n            if ((mask & (1 << i)) == 0) {\n                // Put in B\n                if (bCount > 0 && b[bCount - 1] > balls[i]) {\n                    valid = false;\n                    break;\n                }\n                b[bCount++] = balls[i];\n            } else {\n                // Put in C\n                if (cCount > 0 && c[cCount - 1] > balls[i]) {\n                    valid = false;\n                    break;\n                }\n                c[cCount++] = balls[i];\n            }\n        }\n        \n        if (valid) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        int balls[10];\n        for (int j = 0; j < 10; j++) {\n            scanf(\"%d\", &balls[j]);\n        }\n        \n        if (canArrange(balls)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdbool.h> bool canArrange(int balls[10]) { // Try all possible combinations of putting balls in B  B, 1 = put in C for (int mask = 0;  mask++) { int b[10], c[10]; int bCount =  Distribute balls according to mask for (int  10; i++)   if (bCount > 0 && b[bCount - 1] > balls[i]) { valid = false; break; } b[bCount++] = balls[i]; } else { // Put in C if (cCount >  > balls[i]) { valid = false; break; } c[cCount++] = balls[i]; } } if (valid)  return false; } int main() { int n; scanf(\"%d\", &n); for (int i = 0; i < n; i++) { int balls[10]; for (int j = 0; j < 10; j++) { scanf(\"%d\", &balls[j]); } if (canArrange(balls)) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int i,j,n,a[10],b,c,nflag; scanf(\"%d\",&n); for(i=0;i<n;i++){ nflag=0; for(j=0;j<9;j++) scanf(\"%d \",&a[j]); scanf(\"%d\",&a[9]); b=a[0]; c=0; for(j=1;j<10;j++){ if(b<a[j]) b=a[j]; else if(c<a[j]) c=a[j];  } if(nflag) continue; printf(\"YES\\n\"); } return 0; }"], "original_ll": -1.0201002359390259, "sampled_ll": -0.5068585276603699, "all_perturbed_sampled_ll": [-1.5267740488052368], "all_perturbed_original_ll": [-1.3228600025177002], "perturbed_sampled_ll": -1.5267740488052368, "perturbed_original_ll": -1.3228600025177002, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static final int N = 12;\n\tint[] a = new int[N];\n\tint small = 0;\n\tint big = 0;\n\t\n\tprivate int s=0;     //\u6570?\u7684\u4e2a\u6570\n\t\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.Sort();\n\t}\n\t\n\t\n\tprivate void Sort(){\t\n\n\t\tScanner sc = new Scanner(System.in);\n\t\ts = sc.nextInt();\n\t\t\n\t\twhile(s!= 0){\t\n\t\t\t\n\t\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t/*for (int m = 1; m <= 10; m++) {\n\t\t\t\tSystem.out.print(a[m]+ \" \");\n\t\t\t}*/\n\t\t\t\n\t\t\tif (a[1] > a[2]) {\n\t\t\t\tbig = a[1];\n\t\t\t\tsmall = a[2];\n\t\t\t}else {\n\t\t\t\tbig = a[2];\n\t\t\t\tsmall = a[1];\n\t\t\t}\n\t\t\t//System.out.println(big);\n\t\t\t\n\t\t\tfor (int j = 3; j <= 10; j++) {\n\t\t\t\tif (a[j] > big) {\n\t\t\t\t\tbig = a[j];\n\t\t\t\t}\n\t\t\t\tif (a[j] < big && a[j] > small) {\n\t\t\t\t\tsmall = a[j];\n\t\t\t\t}\n\t\t\t\tif (a[j] < small) {\n\t\t\t\t\tSystem.out.printf(\"%s\\n\",\"NO\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 10) {\n\t\t\t\t\tSystem.out.printf(\"%s\\n\",\"YES\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(s);\n\t\t\ts--;\n\t\t\t\t\n\t\t}\n\t\tsc.close();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[] balls;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            balls = new int[10];\n            for (int j = 0; j < 10; j++) {\n                balls[j] = sc.nextInt();\n            }\n            \n            if (canArrange(0, new ArrayList<>(), new ArrayList<>())) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        sc.close();\n    }\n    \n    static boolean canArrange(int index, List<Integer> b, List<Integer> c) {\n        if (index == 10) {\n            return true;\n        }\n        \n        int current = balls[index];\n        \n        // Try to put in B\n        boolean canPutInB = true;\n        if (!b.isEmpty() && b.get(b.size() - 1) > current) {\n            canPutInB = false;\n        }\n        \n        if (canPutInB) {\n            b.add(current);\n            if (canArrange(index + 1, b, c)) {\n                return true;\n            }\n            b.remove(b.size() - 1);\n        }\n        \n        // Try to put in C\n        boolean canPutInC = true;\n        if (!c.isEmpty() && c.get(c.size() - 1) > current) {\n            canPutInC = false;\n        }\n        \n        if (canPutInC) {\n            c.add(current);\n            if (canArrange(index + 1, b, c)) {\n                return true;\n            }\n            c.remove(c.size() - 1);\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int[] balls; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i < n; i++) { balls = new int[10]; for (int j = 0; j < 10; j++) {   { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } }  == 10) { return true; } int current  put in B boolean canPutInB = true; if  > current) { canPutInB =  b.add(current); if (canArrange(index + 1, b, c)) { return true; } b.remove(b.size() - 1); } // Try to put in C boolean canPutInC  c.get(c.size() - 1) > current) { canPutInC = false;  if (canArrange(index + 1, b, c)) { return true; } c.remove(c.size() - 1); } return false; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { private static final int N = 12; int[] a = new int[N]; int small = 0; int big = 0; private int s=0; //\u6570?\u7684\u4e2a\u6570 public static void main(String[] args) { Main m = new Main(); m.Sort(); } private void Sort(){ Scanner sc = new Scanner(System.in); s = sc.nextInt(); while(s!= 0){ for (int i = 1; i <= 10; i++) { a[i] = sc.nextInt(); } /*for (int m = 1; m <= 10; m++) { System.out.print(a[m]+ \" \"); }*/ if  = a[1]; small = a[2]; }else  3; j  (a[j] > big)  if (a[j]  small) { small = a[j];  { System.out.printf(\"%s\\n\",\"NO\"); break; } if (j  } } //System.out.println(s); s--; } sc.close(); } }"], "original_ll": -0.9099321365356445, "sampled_ll": -0.35531163215637207, "all_perturbed_sampled_ll": [-1.461547613143921], "all_perturbed_original_ll": [-1.782497525215149], "perturbed_sampled_ll": -1.461547613143921, "perturbed_original_ll": -1.782497525215149, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for data in range(input()):\n    dataset=map(int,raw_input().split(\" \"))\n    B,C=0,0\n    B=dataset.pop(0)\n    while len(dataset)!=0:\n        ball = dataset.pop(0)\n        if ball-B<0 or ball-C<0:\n            if ball-B<0 and ball-C<0:\n                print \"NO\"\n                break\n            elif ball-B<0:\n                C=ball\n            else:\n                B=ball\n        else:\n            if ball-B<ball-C:\n                B=ball\n            else:\n                C=ball\n    if(len(dataset)==0):\n        print \"YES\"", "sampled": "def can_sort(sequence):\n    def is_valid(b_stack, c_stack, index):\n        if index == 10:\n            return True\n        \n        ball = sequence[index]\n        \n        # Try putting in B\n        can_put_b = len(b_stack) == 0 or b_stack[-1] < ball\n        if can_put_b:\n            b_stack.append(ball)\n            if is_valid(b_stack, c_stack, index + 1):\n                return True\n            b_stack.pop()\n        \n        # Try putting in C\n        can_put_c = len(c_stack) == 0 or c_stack[-1] < ball\n        if can_put_c:\n            c_stack.append(ball)\n            if is_valid(b_stack, c_stack, index + 1):\n                return True\n            c_stack.pop()\n        \n        return False\n    \n    return is_valid([], [], 0)\n\nn = int(input())\nfor _ in range(n):\n    sequence = list(map(int, input().split()))\n    if can_sort(sequence):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["def can_sort(sequence): def is_valid(b_stack, c_stack, index): if index == 10: return True ball  in B can_put_b = len(b_stack) == 0 or b_stack[-1] < ball if can_put_b: b_stack.append(ball) if is_valid(b_stack, c_stack, index + 1): return True b_stack.pop() #  or c_stack[-1] < ball if can_put_c: c_stack.append(ball) if is_valid(b_stack, c_stack, index + 1): return True c_stack.pop() return False return is_valid([], [], 0)  in range(n): sequence =  else: print(\"NO\")"], "perturbed_original": ["for  B,C=0,0 B=dataset.pop(0) while len(dataset)!=0: ball = dataset.pop(0) if ball-B<0 or ball-C<0: if ball-B<0 and ball-C<0: print  else: B=ball else: if ball-B<ball-C: B=ball else: C=ball if(len(dataset)==0): print \"YES\""], "original_ll": -1.021568775177002, "sampled_ll": -0.7077993750572205, "all_perturbed_sampled_ll": [-1.7839465141296387], "all_perturbed_original_ll": [-2.008488178253174], "perturbed_sampled_ll": -1.7839465141296387, "perturbed_original_ll": -2.008488178253174, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nmain(){\n  int i,ans;\n  double l[10],km,k,v[2];\n  while(scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\",&l[0],&l[1],&l[2],&l[3],&l[4],&l[5],&l[6],&l[7],&l[8],&l[9],&v[0],&v[1])!=EOF){\n    km=l[0]+l[1]+l[2]+l[3]+l[4]+l[5]+l[6]+l[7]+l[8]+l[9];\n    k=km*v[0]/(v[0]+v[1]);\n    for(i=0;i>=0;i++){\n      k-=l[i];\n      if(k<=0){\n\tans=i+1;\n\ti=-2;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[256];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int l[10];\n        int v1, v2;\n        \n        sscanf(line, \"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\",\n               &l[0], &l[1], &l[2], &l[3], &l[4],\n               &l[5], &l[6], &l[7], &l[8], &l[9],\n               &v1, &v2);\n        \n        // Calculate total distance\n        int total = 0;\n        for (int i = 0; i < 10; i++) {\n            total += l[i];\n        }\n        \n        // Calculate cumulative distances from left\n        int cum[11];\n        cum[0] = 0;\n        for (int i = 0; i < 10; i++) {\n            cum[i + 1] = cum[i] + l[i];\n        }\n        \n        // Find meeting point\n        // Train 1 travels distance d1 = v1 * t\n        // Train 2 travels distance d2 = v2 * t\n        // d1 + d2 = total\n        // v1 * t + v2 * t = total\n        // t = total / (v1 + v2)\n        // d1 = v1 * total / (v1 + v2)\n        \n        double d1 = (double)v1 * total / (v1 + v2);\n        \n        // Find which section this is in\n        for (int i = 0; i < 10; i++) {\n            if (d1 <= cum[i + 1]) {\n                printf(\"%d\\n\", i + 1);\n                break;\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() <extra_id_11>i-1 );<extra_id_12>+ t * (v1<extra_id_13>v2 = v1) //<extra_id_14>//<extra_id_15>) / (v1 +<extra_id_16>) printf ( \" sscanf(line, \"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\", &l[0], &l[1], &l[2], &l[3], &l[4],  &v1, &v2); // Calculate total distance int total = 0; for (int i = 0; i < 10; i++) { total += l[i]; } // Calculate cumulative distances from left int cum[11]; cum[0] = 0; for (int i = 0; i  + l[i]; } // Find meeting  distance d1 = v1 * t // Train 2 travels distance d2 = v2 * t // d1 + d2 = total // v1 * t + v2 * t = total // t = total / (v1 + v2) // d1 = v1  v2) double  / (v1 + v2); // Find which section this is in for (int i = 0; i < 10;  cum[i + 1]) { printf(\"%d\\n\", i + 1);  0; }"], "perturbed_original": ["#include<stdio.h> main(){ int i,ans; double l[10],km,k,v[2]; while(scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\",&l[0],&l[1],&l[2],&l[3],&l[4],&l[5],&l[6],&l[7],&l[8],&l[9],&v[0],&v[1])!=EOF){  ans=i+1; i=-2; } } printf(\"%d\\n\",ans); } return 0; }"], "original_ll": -0.8298017382621765, "sampled_ll": -0.5888370871543884, "all_perturbed_sampled_ll": [-1.8595669269561768], "all_perturbed_original_ll": [-1.4439103603363037], "perturbed_sampled_ll": -1.8595669269561768, "perturbed_original_ll": -1.4439103603363037, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = null;\n\t\tint[] l = new int[10];\n\t\tint[] v = new int[2];\n\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tString[] data = line.trim().split(\",\");\n\t\t\tint distance = 0;\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tl[i] = Integer.parseInt(data[i]);\n\t\t\t\tdistance += l[i];\n\t\t\t}\n\t\t\tfor (int i = 0; i < 2; i++)\n\t\t\t\tv[i] = Integer.parseInt(data[i + 10]);\n\t\t\tdouble see = distance * ((double) v[0] / (v[1] + v[0]));\n\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif (see - l[i] > 0) {\n\t\t\t\t\tsee -= l[i];\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(i + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            line = line.trim();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            int[] lengths = new int[10];\n            for (int i = 0; i < 10; i++) {\n                lengths[i] = Integer.parseInt(parts[i].trim());\n            }\n            int v1 = Integer.parseInt(parts[10].trim());\n            int v2 = Integer.parseInt(parts[11].trim());\n            \n            // Calculate cumulative distances from station 0\n            int[] cumDist = new int[11];\n            cumDist[0] = 0;\n            for (int i = 0; i < 10; i++) {\n                cumDist[i + 1] = cumDist[i] + lengths[i];\n            }\n            int totalDistance = cumDist[10];\n            \n            // They meet when: distance1 + distance2 = totalDistance\n            // time is same for both: t = distance1 / v1 = distance2 / v2\n            // distance1 = v1 * t, distance2 = v2 * t\n            // v1 * t + v2 * t = totalDistance\n            // t = totalDistance / (v1 + v2)\n            // distance1 = v1 * totalDistance / (v1 + v2)\n            \n            double meetDistance = (double) v1 * totalDistance / (v1 + v2);\n            \n            // Find which section this distance falls into\n            int section = 1;\n            for (int i = 1; i <= 10; i++) {\n                if (meetDistance <= cumDist[i]) {\n                    section = i;\n                    break;\n                }\n            }\n            \n            System.out.println(section);\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*;  static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line;  line.trim(); if (line.isEmpty()) break; String[]  = new int[10]; for (int i = 0; i < 10; i++) { lengths[i]  = Integer.parseInt(parts[10].trim()); int v2 = Integer.parseInt(parts[11].trim()); // Calculate  int[] cumDist = new int[11]; cumDist[0] = 0; for (int i = 0; i < 10; i++) { cumDist[i + 1] = cumDist[i] +  cumDist[10]; // They meet  totalDistance  both: t = distance1 / v1 = distance2 / v2 // distance1 = v1  * t // v1 * t + v2 * t = totalDistance // t = totalDistance /  = v1 * totalDistance / (v1 + v2) double meetDistance = (double) v1 * totalDistance / (v1 + v2); // Find which section this distance falls into int section  = 1; i <= 10; i++) { if (meetDistance <= cumDist[i]) { section = i; break; } } System.out.println(section); } } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[]  br = new BufferedReader(new InputStreamReader(System.in)); String line = null; int[] l = new int[10]; int[] v = new int[2]; while ((line =  data = line.trim().split(\",\"); int distance = 0; for (int i = 0; i <  } for (int i = 0; i < 2; i++) v[i] = Integer.parseInt(data[i + 10]); double  v[0] / (v[1] + v[0])); for  if (see - l[i] > 0) { see -= l[i]; } else { System.out.println(i + 1); break; } } } } }"], "original_ll": -0.6467524170875549, "sampled_ll": -0.6440221667289734, "all_perturbed_sampled_ll": [-1.555991291999817], "all_perturbed_original_ll": [-1.6204856634140015], "perturbed_sampled_ll": -1.555991291999817, "perturbed_original_ll": -1.6204856634140015, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,v1,v2=map(int,input().split(\",\"))\n        kyo=0\n        for i in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10:\n            kyo +=i\n        v=v1+v2\n        x=kyo/v\n        ans=v1*x\n        flag=0\n        for j in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10:\n            if ans>0:\n                ans -=j\n                flag +=1\n            elif ans==0:\n                print(flag)\n                break\n            elif ans<0:\n                print(flag)\n                break\n    except:break\n\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    parts = line.strip().split(',')\n    lengths = list(map(int, parts[:10]))\n    v1, v2 = int(parts[10]), int(parts[11])\n    \n    total_length = sum(lengths)\n    \n    # Time when trains meet\n    t_meet = total_length / (v1 + v2)\n    \n    # Distance traveled by train from section 1 side\n    d1 = v1 * t_meet\n    \n    # Find which section this distance falls into\n    cumulative = 0\n    for i in range(10):\n        cumulative += lengths[i]\n        if d1 <= cumulative:\n            print(i + 1)\n            break\n", "perturbed_sampled": ["import sys for line in sys.stdin: parts = line.strip().split(',') lengths = list(map(int, parts[:10])) v1, v2 = int(parts[10]), int(parts[11]) total_length = sum(lengths) # Time  total_length / (v1  by  d1 = v1 * t_meet # Find which section this distance falls into cumulative =  cumulative += lengths[i] if d1 <= cumulative: print(i + 1) break"], "perturbed_original": ["while True:  in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10: kyo +=i v=v1+v2 x=kyo/v ans=v1*x flag=0 for j in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10: if ans>0: ans  print(flag) break elif ans<0: print(flag) break except:break"], "original_ll": -1.040817379951477, "sampled_ll": -1.2569373846054077, "all_perturbed_sampled_ll": [-2.7442307472229004], "all_perturbed_original_ll": [-2.396493434906006], "perturbed_sampled_ll": -2.7442307472229004, "perturbed_original_ll": -2.396493434906006, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\ndouble gaiseki(double x0,double y0,double x1,double y1,double x2,double y2){\nreturn(x0-x1)*(y0-y1)-(x0-x2)*(y0-y2);\n}\nint main(){\ndouble x0,y0,x1,y1,x2,y2,x3,y3;\nwhile (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3)!=EOF){\nif (gaiseki(x0,y0,x1,y1,x3,y3)>=0&&gaiseki(x1,y1,x2,y2,x3,y3)>=0&&gaiseki(x2,y2,x0,y0,x3,y3)>=0){\nprintf(\"YES\\n\");\n}else{\nprintf(\"NO\\n\");\n}\n}\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\ndouble cross(double ax, double ay, double bx, double by, double cx, double cy) {\n    return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);\n}\n\nint main() {\n    double xa, ya, xb, yb, xc, yc, xd, yd;\n    \n    while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\", \n                 &xa, &ya, &xb, &yb, &xc, &yc, &xd, &yd) == 8) {\n        \n        double c1 = cross(xa, ya, xb, yb, xc, yc);\n        double c2 = cross(xb, yb, xc, yc, xd, yd);\n        double c3 = cross(xc, yc, xd, yd, xa, ya);\n        double c4 = cross(xd, yd, xa, ya, xb, yb);\n        \n        if ((c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0) ||\n            (c1 < 0 && c2 < 0 && c3 < 0 && c4 < 0)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> double cross(double ax, double ay,  cx,  - ax) * (cy - ay) - (by - ay) * (cx - ax); } int main() { double xa, ya, xb, yb, xc, yc, xd, yd; while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\", &xa, &ya, &xb, &yb,  = cross(xa, ya, xb, yb, xc, yc); double c2 = cross(xb, yb, xc, yc, xd, yd); double c3 = cross(xc, yc, xd, yd, xa, ya); double c4 = cross(xd, yd, xa, ya, xb, yb);  c2 > 0 && c3 > 0 && c4 > 0) || (c1 < 0 &&  < 0 && c4 <  return 0; }"], "perturbed_original": ["#include  x1,double y1,double x2,double y2){ return(x0-x1)*(y0-y1)-(x0-x2)*(y0-y2); } int main(){ double x0,y0,x1,y1,x2,y2,x3,y3; while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3)!=EOF){ if (gaiseki(x0,y0,x1,y1,x3,y3)>=0&&gaiseki(x1,y1,x2,y2,x3,y3)>=0&&gaiseki(x2,y2,x0,y0,x3,y3)>=0){ printf(\"YES\\n\"); }else{ printf(\"NO\\n\"); } } return 0; }"], "original_ll": -0.6555150151252747, "sampled_ll": -0.35708603262901306, "all_perturbed_sampled_ll": [-1.1511616706848145], "all_perturbed_original_ll": [-0.8325701355934143], "perturbed_sampled_ll": -1.1511616706848145, "perturbed_original_ll": -0.8325701355934143, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;class Main{public static void main(String[]z){double[]b=new double[8];for(Scanner s=new Scanner(System.in);s.hasNext();System.out.println((f(b[0],b[1],b[4],b[5],b[6],b[7])>0&&f(b[4],b[5],b[0],b[1],b[2],b[3])>0&&f(b[2],b[3],b[6],b[7],b[0],b[1])>0&&f(b[6],b[7],b[2],b[3],b[4],b[5])>0)||(f(b[0],b[1],b[4],b[5],b[6],b[7])<0&&f(b[4],b[5],b[0],b[1],b[2],b[3])<0&&f(b[2],b[3],b[6],b[7],b[0],b[1])<0&&f(b[6],b[7],b[2],b[3],b[4],b[5])<0)?\"YES\":\"NO\")){z=s.next().split(\",\");for(int i=0;i<8;++i)b[i]=new Double(z[i]);}}static double f(double a,double b,double c,double d,double e,double f){return ((d-b)*e+(a-c)*f+c*b-a*d);}}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            \n            double xa = Double.parseDouble(parts[0]);\n            double ya = Double.parseDouble(parts[1]);\n            double xb = Double.parseDouble(parts[2]);\n            double yb = Double.parseDouble(parts[3]);\n            double xc = Double.parseDouble(parts[4]);\n            double yc = Double.parseDouble(parts[5]);\n            double xd = Double.parseDouble(parts[6]);\n            double yd = Double.parseDouble(parts[7]);\n            \n            double cross1 = crossProduct(xa, ya, xb, yb, xc, yc);\n            double cross2 = crossProduct(xb, yb, xc, yc, xd, yd);\n            double cross3 = crossProduct(xc, yc, xd, yd, xa, ya);\n            double cross4 = crossProduct(xd, yd, xa, ya, xb, yb);\n            \n            boolean allPositive = cross1 > 0 && cross2 > 0 && cross3 > 0 && cross4 > 0;\n            boolean allNegative = cross1 < 0 && cross2 < 0 && cross3 < 0 && cross4 < 0;\n            \n            if (allPositive || allNegative) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static double crossProduct(double x1, double y1, double x2, double y2, double x3, double y3) {\n        double v1x = x2 - x1;\n        double v1y = y2 - y1;\n        double v2x = x3 - x2;\n        double v2y = y3 - y2;\n        return v1x * v2y - v1y * v2x;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String line = sc.nextLine(); String[] parts = line.split(\",\"); double xa = Double.parseDouble(parts[0]); double ya = Double.parseDouble(parts[1]); double xb = Double.parseDouble(parts[2]); double yb = Double.parseDouble(parts[3]); double xc  Double.parseDouble(parts[5]); double xd = Double.parseDouble(parts[6]); double yd = Double.parseDouble(parts[7]); double cross1 = crossProduct(xa, ya, xb, yb, xc, yc); double cross2 = crossProduct(xb,  double cross3 = crossProduct(xc, yc,  cross4 = crossProduct(xd, yd, xa, ya, xb, yb); boolean allPositive = cross1 > 0 && cross2 > 0 && cross3 > 0 && cross4 > 0; boolean allNegative = cross1 < 0 &&  || allNegative) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); }  double y1, double x2, double y2, double x3, double  x2 - x1; double v1y = y2 - y1; double v2x  v2y  v1x * v2y - v1y * v2x; } }"], "perturbed_original": ["import java.util.*;class Main{public static void main(String[]z){double[]b=new double[8];for(Scanner s){if(s.d.contains(z.pop())&&s.elementAt(0)!=z)if(b[-a-c].length>0){b[a-c].length>1){b[b-c]=s.elements[a];if(b[d].length> f(double a,double b,double c,double d,double e,double f){return ((d-b)*e+(a-c)*f+c*b-a*d);}}"], "original_ll": -0.7121915221214294, "sampled_ll": -0.2333115041255951, "all_perturbed_sampled_ll": [-1.0454540252685547], "all_perturbed_original_ll": [-3.155548095703125], "perturbed_sampled_ll": -1.0454540252685547, "perturbed_original_ll": -3.155548095703125, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from __future__ import (division, absolute_import, print_function,\n                        unicode_literals)\nfrom sys import stdin\nfrom collections import namedtuple\nPoint = namedtuple('Point', 'x y')\n\ndef make_test(p1, p2):\n    if p1.x == p2.x:\n        gradient = p1.x\n        return lambda p: gradient > p.x\n    gradient = (p1.y - p2.y) / (p1.x - p2.x)\n    y_intercept = p1.y - gradient * p1.x\n    return lambda p: gradient * p.x + y_intercept > p.y\n\nfor line in stdin:\n    it = (float(s) for s in line.split(','))\n    A, B, C, D = (Point(next(it), next(it)) for _ in xrange(4))\n\n    f = make_test(A, C)\n    g = make_test(B, D)\n    if f(B) == f(D) or g(A) == g(C):\n        print('NO')\n    else:\n        print('YES')", "sampled": "import sys\n\ndef cross_product(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef is_convex(points):\n    n = len(points)\n    sign = None\n    \n    for i in range(n):\n        o = points[i]\n        a = points[(i + 1) % n]\n        b = points[(i + 2) % n]\n        \n        cp = cross_product(o, a, b)\n        \n        if cp != 0:\n            if sign is None:\n                sign = cp > 0\n            elif (cp > 0) != sign:\n                return False\n    \n    return True\n\nfor line in sys.stdin:\n    coords = list(map(float, line.strip().split(',')))\n    points = [(coords[i], coords[i+1]) for i in range(0, 8, 2)]\n    \n    if is_convex(points):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys def cross_product(o, a, b): return (a[0] - o[0])  (a[1] - o[1]) * (b[0]  = len(points) sign = None for i in range(n): o = points[i] a = points[(i  = points[(i + 2) % n] cp = cross_product(o, a,  if sign is None: sign = cp > 0 elif (cp > 0) != sign: return  in sys.stdin: coords = list(map(float, line.strip().split(','))) points = [(coords[i], coords[i+1]) for  if is_convex(points): print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["from __future__ import (division, absolute_import, print_function, unicode_literals) from sys import stdin from collections import namedtuple Point =  p2): if p1.x == p2.x:  gradient = (p1.y - p2.y) / (p1.x - p2.x) y_intercept = p1.y  lambda p: gradient * p.x + y_intercept > p.y for line in stdin: it = (float(s) for s in line.split(',')) A, B, C, D =   g = make_test(B, D) if f(B) == f(D) or g(A) == g(C): print('NO') else: print('YES')"], "original_ll": -0.9555858373641968, "sampled_ll": -0.49204567074775696, "all_perturbed_sampled_ll": [-1.629376769065857], "all_perturbed_original_ll": [-2.0515496730804443], "perturbed_sampled_ll": -1.629376769065857, "perturbed_original_ll": -2.0515496730804443, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\n#define X 8\n#define Y 8\n#define L 3\n#define M 2\n#define S 1\n\n\nint main(void)\n{\n        char ppr[X][Y];/*\u7d19*/\n        int x = 0, y = 0;\n        int i = 0, j = 0;\n        int size = 0;\n        int count = 0;\n        int max = 0;\n        int farst = 0;\n        int k = 0;\n        int h = 0;\n        char ans[4][2];\n\n        for(i = 0; i < X; i++)\n        {\n                for(j = 0;j < Y; j++)\n                {\n                        ppr[i][j] = '0';\n                }\n        }\n\n        for(i = 0; i < 4; i++)\n        {\n                for(j = 0;j < 2; j++)\n                {\n                        ans[i][j] = '0';\n                }\n        }\n\n        while(scanf(\"%s\", ppr[0]) != EOF)\n        {\n                for(i = 1; i < X; i++)\n                {\n                        scanf(\"%s\", ppr[i]);\n                }\n                for(i = 0; i < X; i++)\n                {\n                        for(j = 0; j < Y; j++)\n                        {\n                                if( ppr[i][j] == '1')\n                                {\n                                        ans[k][0] = j;\n                                        ans[k][1] = i;\n                                        k++;\n                                }\n                        }\n                }\n/*\n                for(i = 0;i < 4; i++)\n                {\n                        printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n                }\n*/\n                x = ans[0][0];\n                y = ans[0][1];\n                ans[0][0] -= x; ans[0][1] -= y;\n                ans[1][0] -= x; ans[1][1] -= y;\n                ans[2][0] -= x; ans[2][1] -= y;\n                ans[3][0] -= x; ans[3][1] -= y;\n                /*\n                for(i = 0;i < 4; i++)\n                {\n                        printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n                }*/\n\n                if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                   ans[1][0] ==  0 && ans[1][1] == 1 &&\n                   ans[2][0] ==  1 && ans[2][1] == 0 &&\n                   ans[3][0] ==  1 && ans[3][1] == 1 )\n                {\n                        printf(\"A\\n\");\n                }\n                else if(ans[0][0] == 0 &&ans[0][1] == 0 &&\n                   ans[1][0] ==  1 && ans[1][1] == 0 &&\n                   ans[2][0] ==  2 && ans[2][1] == 0 &&\n                   ans[3][0] ==  3 && ans[3][1] == 0 )\n                {\n                        printf(\"B\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                        ans[1][0] ==  0 && ans[1][1] == 1 &&\n                        ans[2][0] ==  0 && ans[2][1] == 2 &&\n                        ans[3][0] ==  0 && ans[3][1] == 3 )\n                {\n                        printf(\"C\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 1 &&\n                        ans[1][0] ==  1 && ans[1][1] == 0 &&\n                        ans[2][0] ==  1 && ans[2][1] == 1 &&\n                        ans[3][0] ==  2 && ans[3][1] == 0 )\n                {\n                        printf(\"D\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                        ans[1][0] ==  0 && ans[1][1] == 1 &&\n                        ans[2][0] ==  1 && ans[2][1] == 1 &&\n                        ans[3][0] ==  1 && ans[3][1] == 2 )\n                {\n                        printf(\"E\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                        ans[1][0] ==  1 && ans[1][1] == 0 &&\n                        ans[2][0] ==  1 && ans[2][1] == 1 &&\n                        ans[3][0] ==  2 && ans[3][1] == 1 )\n                {\n                        printf(\"F\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 1 &&\n                        ans[1][0] ==  0 && ans[1][1] == 2 &&\n                        ans[2][0] ==  1 && ans[2][1] == 0 &&\n                        ans[3][0] ==  1 && ans[3][1] == 1 )\n                {\n                        printf(\"G\\n\");\n                }\n\n\n        }\n\n        return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char grid[8][9];\n    \n    while(scanf(\"%s\", grid[0]) != EOF) {\n        for(int i = 1; i < 8; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        // Extract the shape pattern\n        int minR = 8, maxR = -1, minC = 8, maxC = -1;\n        for(int i = 0; i < 8; i++) {\n            for(int j = 0; j < 8; j++) {\n                if(grid[i][j] == '1') {\n                    if(i < minR) minR = i;\n                    if(i > maxR) maxR = i;\n                    if(j < minC) minC = j;\n                    if(j > maxC) maxC = j;\n                }\n            }\n        }\n        \n        int height = maxR - minR + 1;\n        int width = maxC - minC + 1;\n        \n        // Extract normalized pattern\n        int pattern[4][4] = {0};\n        for(int i = minR; i <= maxR; i++) {\n            for(int j = minC; j <= maxC; j++) {\n                if(grid[i][j] == '1') {\n                    pattern[i-minR][j-minC] = 1;\n                }\n            }\n        }\n        \n        // Check each shape\n        char result = '?';\n        \n        // Shape A: 2x2 square\n        if(height == 2 && width == 2 && \n           pattern[0][0] && pattern[0][1] && \n           pattern[1][0] && pattern[1][1]) {\n            result = 'A';\n        }\n        // Shape B: 1x4 horizontal\n        else if(height == 1 && width == 4 && \n                pattern[0][0] && pattern[0][1] && \n                pattern[0][2] && pattern[0][3]) {\n            result = 'B';\n        }\n        // Shape C: 4x1 vertical\n        else if(height == 4 && width == 1 && \n                pattern[0][0] && pattern[1][0] && \n                pattern[2][0] && pattern[3][0]) {\n            result = 'C';\n        }\n        // Shape D: 3x1 vertical\n        else if(height == 3 && width == 1 && \n                pattern[0][0] && pattern[1][0] && \n                pattern[2][0]) {\n            result = 'D';\n        }\n        // Shape E: zigzag\n        else if(height == 2 && width == 3 && \n                pattern[0][0] && pattern[0][1] && !pattern[0][2] &&\n                !pattern[1][0] && pattern[1][1] && pattern[1][2]) {\n            result = 'E';\n        }\n        // Shape F: reverse zigzag\n        else if(height == 2 && width == 3 && \n                !pattern[0][0] && pattern[0][1] && pattern[0][2] &&\n                pattern[1][0] && pattern[1][1] && !pattern[1][2]) {\n            result = 'F';\n        }\n        // Shape G: L-shape\n        else if(height == 2 && width == 2 && \n                pattern[0][0] && !pattern[0][1] && \n                pattern[1][0] && pattern[1][1]) {\n            result = 'G';\n        }\n        \n        printf(\"%c\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  grid[8][9]; while(scanf(\"%s\", grid[0]) != EOF) { for(int i = 1; i < 8; i++) { scanf(\"%s\",  shape pattern int minR =  = 8, maxC =  i < 8; i++) { for(int j = 0; j < 8; j++) { if(grid[i][j] == '1') { if(i  if(i > maxR) maxR = i; if(j < minC) minC = j; if(j > maxC) maxC = j; } } } int height = maxR - minR  maxC - minC + 1; // Extract normalized pattern int pattern[4][4] = {0}; for(int i = minR; i <=  = minC; j <= maxC; j++) { if(grid[i][j] == '1') { pattern[i-minR][j-minC] = 1; } }  // Shape A: 2x2 square if(height == 2 &&  && pattern[0][1] && pattern[1][0] && pattern[1][1]) { result = 'A'; } // Shape B: 1x4 horizontal else if(height == 1 && width == 4 && pattern[0][0] && pattern[0][1] && pattern[0][2] && pattern[0][3]) { result = 'B'; }  else if(height == 4 &&  && pattern[1][0] && pattern[2][0] && pattern[3][0]) { result = 'C'; } // Shape D: 3x1 vertical else if(height  1 && pattern[0][0]  // Shape E: zigzag else if(height  3 && pattern[0][0] && pattern[0][1] && !pattern[0][2] && !pattern[1][0] && pattern[1][1] &&  } // Shape F:  2 && width == 3  pattern[1][1] && !pattern[1][2]) { result = 'F'; } // Shape G: L-shape else if(height == 2 && width == 2 && pattern[0][0] && !pattern[0][1] && pattern[1][0] && pattern[1][1]) { result = 'G'; } printf(\"%c\\n\", result); } return 0; }"], "perturbed_original": ["#include<stdio.h> #define  #define  #define S 1 int main(void) { char ppr[X][Y];/*\u7d19*/ int x = 0, y = 0; int i = 0, j = 0; int size = 0; int count = 0; int max  0; int k = 0; int h  = 0; i  = 0;j < Y; j++)  } for(i = 0; i < 4; i++) { for(j = 0;j < 2; j++) { ans[i][j]  for(i = 1; i < X; i++) { scanf(\"%s\",  i < X; i++) { for(j = 0; j  ppr[i][j] == '1') { ans[k][0] = j; ans[k][1] = i; k++; } } } /* for(i = 0;i < 4; i++) { printf(\"%d %d\\n\",ans[i][0],ans[i][1]); } */ x = ans[0][0]; y = ans[0][1]; ans[0][0] -= x; ans[0][1] -= y; ans[1][0] -= x; ans[1][1] -= y; ans[2][0] -= x; ans[2][1]  ans[3][1] -= y; /* for(i = 0;i < 4; i++) { printf(\"%d %d\\n\",ans[i][0],ans[i][1]); }*/  == 0 && ans[1][0] == 0 && ans[1][1] == 1 && ans[2][0] == 1 && ans[2][1] == 0 && ans[3][0] == 1 && ans[3][1] == 1 ) { printf(\"A\\n\"); } else if(ans[0][0] == 0 &&ans[0][1] == 0  ans[1][1] == 0 && ans[2][0] == 2  ans[3][0] == 3 && ans[3][1] == 0 ) { printf(\"B\\n\"); } else if(ans[0][0] == 0 && ans[0][1] == 0 && ans[1][0] == 0 && ans[1][1] == 1  ans[2][1]   && ans[0][1] == 1 && ans[1][0] == 1 && ans[1][1] == 0  ans[3][0] == 2 && ans[3][1] == 0 ) { printf(\"D\\n\"); } else if(ans[0][0]  0  ans[1][1] == 1  ans[2][1] == 1 && ans[3][0]  } else if(ans[0][0] == 0 && ans[0][1] == 0 && ans[1][0] == 1 && ans[1][1] == 0 && ans[2][0] == 1 && ans[2][1] == 1 && ans[3][0] == 2 && ans[3][1] == 1 ) { printf(\"F\\n\"); } else if(ans[0][0] == 0 && ans[0][1] == 1  ans[1][1] == 2 && ans[2][0] == 1 && ans[2][1] == 0 && ans[3][0] == 1 && ans[3][1] == 1 ) { printf(\"G\\n\"); } } return 0; }"], "original_ll": -0.3708331882953644, "sampled_ll": -0.36075741052627563, "all_perturbed_sampled_ll": [-1.0993744134902954], "all_perturbed_original_ll": [-0.8052718639373779], "perturbed_sampled_ll": -1.0993744134902954, "perturbed_original_ll": -0.8052718639373779, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new java.util.Scanner(System.in);\n\n\n\tpublic static void main(String[] args) {\n\n\t\tint[][] num = new int[15][15];\n\t\tString str = \"\";\n\n\t\twhile (sc.hasNextLine()) {\n\t\t\t// ?????????\n\t\t\t//syokika(num);\n\t\t\tfor (int i = 0; i < 15; i++) {\n\t\t\t\tfor (int j = 0; j < 15; j++) {\n\t\t\t\t\tnum[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????\u00a8????????????????\u00b4?\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tstr = sc.next();\n\t\t\t\tString[] st = str.split(\"\");\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tnum[i][j] = Integer.parseInt(st[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????????\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (num[i][j] == 1 && num[i][j + 1] == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"A\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i + 1][j] == 1 && num[i + 2][j] == 1 && num[i + 3][j] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"B\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i][j + 3] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"C\");\n\t\t\t\t\t} else if (num[i][j + 1] == 1 && num[i + 1][j] == 1 && num[i][j + 1] == 1 && num[i + 2][j] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"D\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i + 1][j + 1] == 1\n\t\t\t\t\t\t\t&& num[i + 1][j + 2] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"E\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1\n\t\t\t\t\t\t\t&& num[i + 2][j + 1] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"F\");\n\t\t\t\t\t} else if (num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i + 1][j] == 1\n\t\t\t\t\t\t\t&& num[i + 1][j + 1] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"G\");\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String[][] grid = new String[8][8];\n            List<int[]> points = new ArrayList<>();\n            \n            for (int i = 0; i < 8; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < 8; j++) {\n                    grid[i][j] = String.valueOf(line.charAt(j));\n                    if (line.charAt(j) == '1') {\n                        points.add(new int[]{i, j});\n                    }\n                }\n            }\n            \n            if (points.size() == 0) break;\n            \n            // Normalize the shape\n            int minRow = Integer.MAX_VALUE;\n            int minCol = Integer.MAX_VALUE;\n            for (int[] p : points) {\n                minRow = Math.min(minRow, p[0]);\n                minCol = Math.min(minCol, p[1]);\n            }\n            \n            Set<String> normalized = new HashSet<>();\n            for (int[] p : points) {\n                normalized.add((p[0] - minRow) + \",\" + (p[1] - minCol));\n            }\n            \n            String result = identifyShape(normalized);\n            System.out.println(result);\n            \n            if (sc.hasNextLine()) {\n                String blank = sc.nextLine();\n            }\n        }\n        sc.close();\n    }\n    \n    static String identifyShape(Set<String> shape) {\n        // Define all shapes\n        Map<String, Set<String>> shapes = new HashMap<>();\n        \n        // A: 2x2 square\n        Set<String> a = new HashSet<>();\n        a.add(\"0,0\"); a.add(\"0,1\"); a.add(\"1,0\"); a.add(\"1,1\");\n        shapes.put(\"A\", a);\n        \n        // B: vertical line\n        Set<String> b = new HashSet<>();\n        b.add(\"0,0\"); b.add(\"1,0\"); b.add(\"2,0\"); b.add(\"3,0\");\n        shapes.put(\"B\", b);\n        \n        // C: horizontal line\n        Set<String> c = new HashSet<>();\n        c.add(\"0,0\"); c.add(\"0,1\"); c.add(\"0,2\"); c.add(\"0,3\");\n        shapes.put(\"C\", c);\n        \n        // D: L shape\n        Set<String> d = new HashSet<>();\n        d.add(\"0,0\"); d.add(\"1,0\"); d.add(\"2,0\"); d.add(\"2,1\");\n        shapes.put(\"D\", d);\n        \n        // E: Z shape\n        Set<String> e = new HashSet<>();\n        e.add(\"0,0\"); e.add(\"0,1\"); e.add(\"1,1\"); e.add(\"1,2\");\n        shapes.put(\"E\", e);\n        \n        // F: T shape\n        Set<String> f = new HashSet<>();\n        f.add(\"0,0\"); f.add(\"0,1\"); f.add(\"0,2\"); f.add(\"1,1\");\n        shapes.put(\"F\", f);\n        \n        // G: small L\n        Set<String> g = new HashSet<>();\n        g.add(\"0,0\"); g.add(\"1,0\"); g.add(\"1,1\");\n        shapes.put(\"G\", g);\n        \n        // Try all rotations and reflections\n        for (String key : shapes.keySet()) {\n            Set<String> pattern = shapes.get(key);\n            if (matchesWithTransformations(shape, pattern)) {\n                return key;\n            }\n        }\n        \n        return \"?\";\n    }\n    \n    static boolean matchesWithTransformations(Set<String> shape, Set<String> pattern) {\n        Set<String> current = pattern;\n        \n        for (int rotation = 0; rotation < 4; rotation++) {\n            if (matches(shape, current)) return true;\n            Set<String> reflected = reflect(current);\n            if (matches(shape, reflected)) return true;\n            current = rotate90(current);\n        }\n        \n        return false;\n    }\n    \n    static boolean matches(Set<String> shape, Set<String> pattern) {\n        Set<String> normalized = normalize(pattern);\n        return shape.equals(normalized);\n    }\n    \n    static Set<String> normalize(Set<String> pattern) {\n        int minRow = Integer.MAX_VALUE;\n        int minCol = Integer.MAX_VALUE;\n        \n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            minRow = Math.min(minRow, r);\n            minCol = Math.min(minCol, c);\n        }\n        \n        Set<String> result = new HashSet<>();\n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            result.add((r - minRow) + \",\" + (c - minCol));\n        }\n        \n        return result;\n    }\n    \n    static Set<String> rotate90(Set<String> pattern) {\n        Set<String> result = new HashSet<>();\n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            result.add(c + \",\" + (-r));\n        }\n        return normalize(result);\n    }\n    \n    static Set<String> reflect(Set<String> pattern) {\n        Set<String> result = new HashSet<>();\n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            result.add(r + \",\" + (-c));\n        }\n        return normalize(result);\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public  Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String[][] grid = new String[8][8]; List<int[]> points = new ArrayList<>(); for (int i = 0; i < 8; i++) { String line = sc.nextLine(); for (int j = 0; j < 8; j++) { grid[i][j] = String.valueOf(line.charAt(j)); if (line.charAt(j) == '1') { points.add(new int[]{i, j}); } } } if (points.size() == 0)  int minRow = Integer.MAX_VALUE; int minCol = Integer.MAX_VALUE; for (int[]  = Math.min(minRow,  } Set<String> normalized = new HashSet<>(); for (int[] p : points)  \",\"  String result = identifyShape(normalized);  blank  shape) { // Define all shapes Map<String, Set<String>> shapes = new  Set<String> a = new HashSet<>(); a.add(\"0,0\"); a.add(\"0,1\"); a.add(\"1,0\"); a.add(\"1,1\");  line Set<String> b = new HashSet<>(); b.add(\"0,0\"); b.add(\"1,0\"); b.add(\"2,0\"); b.add(\"3,0\"); shapes.put(\"B\", b); // C: horizontal line Set<String> c = new HashSet<>(); c.add(\"0,0\"); c.add(\"0,1\");  d.add(\"0,0\"); d.add(\"1,0\"); d.add(\"2,0\"); d.add(\"2,1\"); shapes.put(\"D\", d); // E: Z shape Set<String> e = new HashSet<>(); e.add(\"0,0\"); e.add(\"0,1\");  F: T shape Set<String> f = new HashSet<>(); f.add(\"0,0\"); f.add(\"0,1\"); f.add(\"0,2\"); f.add(\"1,1\"); shapes.put(\"F\", f); // G: small  shapes.put(\"G\", g); // Try all rotations and reflections for (String key : shapes.keySet()) { Set<String> pattern = shapes.get(key); if (matchesWithTransformations(shape,   boolean matchesWithTransformations(Set<String> shape, Set<String> pattern) { Set<String> current = pattern; for (int rotation = 0; rotation < 4; rotation++) { if (matches(shape, current)) return true; Set<String> reflected = reflect(current); if (matches(shape, reflected))  } return false; } static boolean matches(Set<String> shape, Set<String> pattern) { Set<String> normalized = normalize(pattern); return shape.equals(normalized); } static Set<String> normalize(Set<String> pattern) { int minRow = Integer.MAX_VALUE; int minCol = Integer.MAX_VALUE; for (String p : pattern) { String[] parts = p.split(\",\"); int r = Integer.parseInt(parts[0]); int c =  minCol  for (String p : pattern) { String[]  = Integer.parseInt(parts[0]); int c = Integer.parseInt(parts[1]); result.add((r -  - minCol)); } return result; } static Set<String> rotate90(Set<String> pattern) { Set<String> result = new HashSet<>(); for (String p : pattern) { String[] parts  Integer.parseInt(parts[0]);  } return normalize(result); } static  result = new HashSet<>(); for (String p : pattern) { String[] parts = p.split(\",\"); int r = Integer.parseInt(parts[0]); int c = Integer.parseInt(parts[1]); result.add(r + \",\" + (-c)); } return normalize(result); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { static Scanner sc =  main(String[] args) { int[][] num = new int[15][15]; String str = \"\"; while (sc.hasNextLine()) { // ????????? //syokika(num); for (int i = 0; i < 15; i++) { for (int j = 0; j < 15; j++)  } // ???????????\u00a8????????????????\u00b4? for (int i = 0; i  = str.split(\"\"); for (int j = 0; j < 8; j++) { num[i][j]  ???????????? for (int i = 0; i < 8; i++) { for (int j = 0; j < 8; j++) { if (num[i][j] == 1 && num[i][j + 1] == 1  1][j + 1] == 1) { System.out.println(\"A\"); } else if (num[i][j] == 1 && num[i + 1][j] == 1 &&  && num[i + 3][j] == 1) { System.out.println(\"B\"); } else if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i][j + 3] == 1) { System.out.println(\"C\"); } else if (num[i][j + 1] == 1 &&  && num[i][j + 1] == 1 && num[i + 2][j] == 1) { System.out.println(\"D\"); } else if (num[i][j]  num[i + 1][j + 1] ==  + 2]  else  num[i  num[i + 1][j + 1] == 1 && num[i + 2][j  System.out.println(\"F\"); } else if (num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i + 1][j] ==  + 1] == 1) {  } }"], "original_ll": -0.4332980811595917, "sampled_ll": -0.3636217713356018, "all_perturbed_sampled_ll": [-1.1002856492996216], "all_perturbed_original_ll": [-1.0437935590744019], "perturbed_sampled_ll": -1.1002856492996216, "perturbed_original_ll": -1.0437935590744019, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys;import re\nfor s in sys.stdin.read().split('\\n\\n'):print 'BCD F GAE'[len(re.findall('1.*1',s.replace('\\n',''))[0])%12-3]", "sampled": "import sys\n\ndef normalize_shape(points):\n    if not points:\n        return []\n    min_r = min(p[0] for p in points)\n    min_c = min(p[1] for p in points)\n    normalized = sorted([(r - min_r, c - min_c) for r, c in points])\n    return normalized\n\ndef get_shape_signature(grid):\n    points = []\n    for r in range(8):\n        for c in range(8):\n            if grid[r][c] == '1':\n                points.append((r, c))\n    return normalize_shape(points)\n\n# Define the shapes A-G\nshapes = {\n    'A': [(0, 0), (0, 1), (1, 0), (1, 1)],\n    'B': [(0, 0), (0, 1), (0, 2), (0, 3)],\n    'C': [(0, 0), (0, 1), (0, 2), (0, 3)],\n    'D': [(0, 0), (1, 0), (1, 1), (2, 1)],\n    'E': [(0, 0), (0, 1), (1, 0), (1, 1)],\n    'F': [(0, 1), (1, 0), (1, 1), (2, 0)],\n    'G': [(0, 0), (0, 1), (0, 2), (1, 1)]\n}\n\n# Generate all rotations and reflections for each shape\ndef get_all_orientations(points):\n    orientations = set()\n    pts = points[:]\n    \n    for _ in range(4):  # 4 rotations\n        orientations.add(tuple(normalize_shape(pts)))\n        # Rotate 90 degrees clockwise: (r, c) -> (c, -r)\n        pts = [(c, -r) for r, c in pts]\n    \n    # Mirror horizontally\n    pts = [(r, -c) for r, c in points]\n    for _ in range(4):  # 4 rotations of mirrored\n        orientations.add(tuple(normalize_shape(pts)))\n        pts = [(c, -r) for r, c in pts]\n    \n    return orientations\n\nshape_orientations = {}\nfor name, shape in shapes.items():\n    shape_orientations[name] = get_all_orientations(shape)\n\ndef identify_shape(grid):\n    sig = tuple(get_shape_signature(grid))\n    \n    for name, orientations in shape_orientations.items():\n        if sig in orientations:\n            return name\n    \n    return None\n\n# Read input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.rstrip('\\n'))\n\n# Process datasets\ni = 0\nwhile i < len(lines):\n    grid = []\n    while i < len(lines) and lines[i] != '':\n        grid.append(lines[i])\n        i += 1\n    \n    if len(grid) == 8:\n        result = identify_shape(grid)\n        print(result)\n    \n    i += 1  # Skip empty line\n", "perturbed_sampled": [" not points: return [] min_r = min(p[0] for p in points) min_c = min(p[1] for p in points) normalized = sorted([(r - min_r, c -  points]) return normalized def get_shape_signature(grid):  == '1': points.append((r, c)) return normalize_shape(points) # Define the shapes A-G shapes = { 'A': [(0, 0), (0, 1), (1, 0), (1, 1)], 'B': [(0, 0), (0, 1), (0, 2), (0, 3)], 'C':  2), (0, 3)], 'D': [(0, 0), (1, 0),  'F': [(0, 1), (1, 0), (1, 1), (2,  1), (0, 2), (1, 1)] } # Generate all rotations and reflections for each shape def get_all_orientations(points): orientations  for _ in range(4): # 4 rotations orientations.add(tuple(normalize_shape(pts))) # Rotate 90  (c, -r) pts = [(c, -r) for  Mirror horizontally pts = [(r, -c) for r, c in points] for _ in range(4):  orientations.add(tuple(normalize_shape(pts))) pts = [(c, -r) for r, c in pts] return orientations shape_orientations = {} for name, shape in shapes.items(): shape_orientations[name] = get_all_orientations(shape) def identify_shape(grid): sig = tuple(get_shape_signature(grid)) for name, orientations in shape_orientations.items(): if sig in orientations: return name return None # Read input lines = [] for line in sys.stdin: lines.append(line.rstrip('\\n')) # Process datasets i = 0  < len(lines) and lines[i] != '': grid.append(lines[i]) i  8: result = identify_shape(grid) print(result) i += 1 # Skip empty line"], "perturbed_original": ["import sys;import re for s in sys.stdin.read().split('\\n\\n'):print 'BCD F GAE'[len(re.findall('1.*1',s.replace('\\n',''))[0])%12-3]"], "original_ll": -2.989722967147827, "sampled_ll": -0.6562668085098267, "all_perturbed_sampled_ll": [-1.583486795425415], "all_perturbed_original_ll": [-3.1982545852661133], "perturbed_sampled_ll": -1.583486795425415, "perturbed_original_ll": -3.1982545852661133, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n  int tate[8][4],yoko[8][3];\n  int h,i,j,k,x=0,y=0;\n  for(i=0;i<9;i++){\n    if(i%2==0){\n      scanf(\"%1d%1d%1d%1d\",&yoko[i][0],&yoko[i][1],&yoko[i][2],&yoko[i][3]);\n      yoko[i][4]=0;   \n    }else{  \n      scanf(\"%1d%1d%1d%1d%1d\",&tate[i][0],&tate[i][1],&tate[i][2],&tate[i][3],&tate[i][4]);\n      tate[i][5]=0;\n    }\n  }\n\n  //printf(\"----------------------------------------\\n\");\n       for(k=0;k<=9;k++){\n       if(k%2==0){\n\t //printf(\"%d%d%d%d%d\\n\",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]);\n       }else{\n\t //printf(\"%d%d%d%d%d%d\\n\",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]);\n       }\n       }\n  \n\n \n  int sl=1;\n  printf(\"R\");\n  do{\n   \n    switch(sl){\n    case 1:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n\n      if(tate[y-1][x+1]==1&&y>0){\n\tx++;\n\ty--;\n\tsl=4;\n      }else if(yoko[y][x+1]==1&&x<3){\n\t//printf(\"ok\\n\");\n\tx++;\n\tsl=1;\n\t//printf(\"s=%d\",s);\n      }else if(tate[y+1][x+1]==1&&y<8){\n\tx++;\n\ty++;\n\t\n\tsl=2;\n      }\n      // printf(\"tate74=%d\\n\",tate[7][4]);\n\n      break;\n\n    case 2:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"%d %d\\n\",x+1,y+2);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n      if(yoko[y+1][x]==1&&x<3){\n\ty++;sl=1;\n      }else if(tate[y+2][x]==1&&y<8){\n\ty=y+2;sl=2;\n      }else if(yoko[y+1][x-1]==1&&x>0){\n\ty++;\n\tx--;\n\tsl=3;\n      }\n      break;\n\n\n    case 3:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n       if(tate[y+1][x]==1&&y<8){\n\tsl=2;y++;\n      }else if(yoko[y][x-1]==1&&x>0){\n\tx--;sl=3;\n      }else if(tate[y-1][x]==1&&y>0){\n\ty--;sl=4;\n      }\n      break;\n\n\n    case 4:\n      // printf(\"x=%d:y=%d\\n\",x,y);\n      if(yoko[y-1][x-1]==1&&x>0){\n\tx--;y--;sl=3;\n      }else if(tate[y-2][x]==1&&y>0){\n\ty=y-2;sl=4;\n      }else if(yoko[y-1][x]==1&&x<3){\n\ty--;sl=1;\n      }\n      break;\n\n\n    }\n    //printf(\"sl=%d\\n\",sl);\n    if(sl==1)printf(\"R\");\n    if(sl==2)printf(\"D\");\n    if(sl==3)printf(\"L\");\n    if(sl==4)printf(\"U\");\n    //printf(\"tate74=%d\\n\",tate[7][4]);\n    //printf(\"\\n\");\n   \n   \n  }while(x!=0||y!=0);\n  printf(\"\\n\");\n  return 0;\n  \n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char h[5][5]; // horizontal walls\n    char v[4][5]; // vertical walls\n    char input[10];\n    \n    // Read input\n    for (int i = 0; i < 9; i++) {\n        scanf(\"%s\", input);\n        if (i % 2 == 0) {\n            // horizontal walls\n            int row = i / 2;\n            strcpy(h[row], input);\n        } else {\n            // vertical walls\n            int row = i / 2;\n            strcpy(v[row], input);\n        }\n    }\n    \n    // Start at point A (0,0), facing right (east)\n    int x = 0, y = 0;\n    int dir = 0; // 0=East, 1=South, 2=West, 3=North\n    char dirChars[] = {'R', 'D', 'L', 'U'};\n    \n    // Direction vectors: dx[dir], dy[dir]\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, 1, 0, -1};\n    \n    char path[10000];\n    int pathLen = 0;\n    \n    // Right-hand rule: keep wall on right\n    do {\n        // Try to turn right first\n        int rightDir = (dir + 3) % 4; // turn right\n        int rightX = x + dx[rightDir];\n        int rightY = y + dy[rightDir];\n        \n        // Check if we can move right\n        int canMoveRight = 0;\n        if (rightX >= 0 && rightX <= 4 && rightY >= 0 && rightY <= 4) {\n            if (rightDir == 0 && rightX <= 4 && v[y][x] == '0') canMoveRight = 1;\n            else if (rightDir == 1 && rightY <= 4 && h[y][x] == '0') canMoveRight = 1;\n            else if (rightDir == 2 && rightX >= 0 && v[y][rightX] == '0') canMoveRight = 1;\n            else if (rightDir == 3 && rightY >= 0 && h[rightY][x] == '0') canMoveRight = 1;\n        }\n        \n        if (canMoveRight) {\n            dir = rightDir;\n            x = rightX;\n            y = rightY;\n            path[pathLen++] = dirChars[dir];\n        } else {\n            // Try to move forward\n            int fwdX = x + dx[dir];\n            int fwdY = y + dy[dir];\n            \n            int canMoveFwd = 0;\n            if (fwdX >= 0 && fwdX <= 4 && fwdY >= 0 && fwdY <= 4) {\n                if (dir == 0 && fwdX <= 4 && v[y][x] == '0') canMoveFwd = 1;\n                else if (dir == 1 && fwdY <= 4 && h[y][x] == '0') canMoveFwd = 1;\n                else if (dir == 2 && fwdX >= 0 && v[y][fwdX] == '0') canMoveFwd = 1;\n                else if (dir == 3 && fwdY >= 0 && h[fwdY][x] == '0') canMoveFwd = 1;\n            }\n            \n            if (canMoveFwd) {\n                x = fwdX;\n                y = fwdY;\n                path[pathLen++] = dirChars[dir];\n            } else {\n                // Turn left\n                dir = (dir + 1) % 4;\n            }\n        }\n    } while (!(x == 0 && y == 0 && dir == 0));\n    \n    path[pathLen] = '\\0';\n    printf(\"%s\\n\", path);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h>  // horizontal walls char v[4][5]; // vertical walls char input[10]; // Read input for (int i =  (i % 2 == 0) { // horizontal walls int row = i / 2; strcpy(h[row], input); } else { // vertical walls int row = i /  // Start at point A (0,0), facing right (east)  = 0; int dir = 0; // 0=East, 1=South, 2=West, 3=North  'L', 'U'}; // Direction vectors: dx[dir], dy[dir] int dx[] = {1, 0,  {0, 1, 0, -1}; char path[10000]; int pathLen = 0; // Right-hand rule: keep wall on right  turn right first int rightDir = (dir + 3) % 4; // turn right int rightX = x + dx[rightDir]; int rightY = y + dy[rightDir]; // Check if we can move right int canMoveRight  0 && rightY <= 4) { if (rightDir == 0 && rightX <= 4 && v[y][x]  else if (rightDir ==  && h[y][x] ==  if (rightDir == 2 && rightX >= 0 && v[y][rightX] == '0') canMoveRight = 1; else if (rightDir  '0') canMoveRight = 1; } if (canMoveRight) { dir = rightDir; x =  move forward int fwdX = x + dx[dir]; int fwdY = y + dy[dir]; int canMoveFwd = 0; if (fwdX >= 0 && fwdX <= 4 && fwdY >= 0 && fwdY <= 4) { if (dir  '0') canMoveFwd = 1; else if (dir == 1 && fwdY <= 4 && h[y][x] == '0') canMoveFwd = 1; else if (dir == 2 && fwdX >= 0 && v[y][fwdX]  else if (dir == 3 && fwdY >= 0 && h[fwdY][x] == '0') canMoveFwd = 1; } if (canMoveFwd) { x  path[pathLen++] = dirChars[dir]; } else { // Turn left dir = (dir + 1) % 4; } } }  y  0)); path[pathLen] = '\\0'; printf(\"%s\\n\", path); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int tate[8][4],yoko[8][3]; int h,i,j,k,x=0,y=0; for(i=0;i<9;i++){ if(i%2==0){ scanf(\"%1d%1d%1d%1d\",&yoko[i][0],&yoko[i][1],&yoko[i][2],&yoko[i][3]); yoko[i][4]=0; }else{ scanf(\"%1d%1d%1d%1d%1d\",&tate[i][0],&tate[i][1],&tate[i][2],&tate[i][3],&tate[i][4]); tate[i][5]=0; } } //printf(\"----------------------------------------\\n\"); for(k=0;k<=9;k++){ if(k%2==0){ //printf(\"%d%d%d%d%d\\n\",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]); }else{ //printf(\"%d%d%d%d%d%d\\n\",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]); } } int  if(yoko[y][x+1]==1&&x<3){  if(tate[y+1][x+1]==1&&y<8){ x++; y++; sl=2; } // printf(\"tate74=%d\\n\",tate[7][4]); break; case 2: //printf(\"x=%d:y=%d\\n\",x,y); //printf(\"%d %d\\n\",x+1,y+2); //printf(\"tate74=%d\\n\",tate[7][4]); if(yoko[y+1][x]==1&&x<3){ y++;sl=1; }else if(tate[y+2][x]==1&&y<8){ y=y+2;sl=2; }else if(yoko[y+1][x-1]==1&&x>0){ y++; x--; sl=3; } break; case 3: //printf(\"x=%d:y=%d\\n\",x,y); if(tate[y+1][x]==1&&y<8){ sl=2;y++; }else if(yoko[y][x-1]==1&&x>0){ x--;sl=3; }else if(tate[y-1][x]==1&&y>0){ y--;sl=4;  printf(\"x=%d:y=%d\\n\",x,y); if(yoko[y-1][x-1]==1&&x>0){ x--;y--;sl=3;  y--;sl=1; } break; } //printf(\"sl=%d\\n\",sl); if(sl==1)printf(\"R\"); if(sl==2)printf(\"D\"); if(sl==3)printf(\"L\"); if(sl==4)printf(\"U\"); //printf(\"tate74=%d\\n\",tate[7][4]); //printf(\"\\n\"); }while(x!=0||y!=0); printf(\"\\n\"); return 0; }"], "original_ll": -0.7322588562965393, "sampled_ll": -0.4883149564266205, "all_perturbed_sampled_ll": [-1.3419171571731567], "all_perturbed_original_ll": [-0.8475769758224487], "perturbed_sampled_ll": -1.3419171571731567, "perturbed_original_ll": -0.8475769758224487, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\n// AOJ 0037\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final double EPS = 1e-10;\n\tpublic static void main(String[] args) {\n\t\tchar[][] cs = new char[20][1000];\n\t\tfor (int i = 0; i < 20; i++) fill(cs[i], '0');\n\t\t\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tString buf = sc.next();\n\t\t\tfor (int j = 0; j < buf.length(); j++) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tcs[i + 1][j * 2 + 2] = buf.charAt(j);\n\t\t\t\t} else {\n\t\t\t\t\tcs[i + 1][j * 2 + 1] = buf.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tint[] dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n\t\tString[] str = {\"R\", \"D\", \"L\", \"U\"}; \n\t\tint x = 1, y = 1, d = 0;\n\t\twhile (!(x == 1 && y == 1 && d == 2)) {\n\t\t\tif (cs[y + dy[d]][x + dx[d]] == '1') {\n\t\t\t\tx += dx[d] * 2; \n\t\t\t\ty += dy[d] * 2;\n\t\t\t\tSystem.out.print(str[d]);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (cs[y + dy[(d - 1 + 4) % 4]][x + dx[(d - 1 + 4) % 4]] == '1') {\n\t\t\t\t\td = (d - 1 + 4) % 4;\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\td = (d + 1) % 4;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class State {\n        int row, col;\n        int dir; // 0=right, 1=down, 2=left, 3=up\n        \n        State(int row, int col, int dir) {\n            this.row = row;\n            this.col = col;\n            this.dir = dir;\n        }\n    }\n    \n    static int[][] horizontal = new int[5][4]; // 5 horizontal lines, 4 segments each\n    static int[][] vertical = new int[4][5]; // 4 vertical lines, 5 segments each\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Read horizontal walls\n        for (int i = 0; i < 5; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 4; j++) {\n                horizontal[i][j] = line.charAt(j) - '0';\n            }\n        }\n        \n        // Read vertical walls\n        for (int i = 0; i < 4; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 5; j++) {\n                vertical[i][j] = line.charAt(j) - '0';\n            }\n        }\n        \n        // Start at position (0,0), facing right (dir=0)\n        // Right hand is on the wall above (horizontal[0][0] = 1)\n        State state = new State(0, 0, 0);\n        StringBuilder result = new StringBuilder();\n        \n        do {\n            // Try to turn right first (right-hand rule)\n            int rightDir = (state.dir + 3) % 4; // Turn right\n            \n            if (canMove(state.row, state.col, rightDir)) {\n                // Turn right and move\n                state.dir = rightDir;\n                move(state, result);\n            } else if (canMove(state.row, state.col, state.dir)) {\n                // Move straight\n                move(state, result);\n            } else {\n                // Turn left\n                state.dir = (state.dir + 1) % 4;\n            }\n        } while (!(state.row == 0 && state.col == 0 && state.dir == 0));\n        \n        System.out.println(result.toString());\n    }\n    \n    static boolean canMove(int row, int col, int dir) {\n        if (dir == 0) { // Right\n            if (col >= 4) return false;\n            return vertical[col][row] == 0;\n        } else if (dir == 1) { // Down\n            if (row >= 4) return false;\n            return horizontal[row + 1][col] == 0;\n        } else if (dir == 2) { // Left\n            if (col <= 0) return false;\n            return vertical[col - 1][row] == 0;\n        } else { // Up\n            if (row <= 0) return false;\n            return horizontal[row][col] == 0;\n        }\n    }\n    \n    static void move(State state, StringBuilder result) {\n        if (state.dir == 0) { // Right\n            result.append('R');\n            state.col++;\n        } else if (state.dir == 1) { // Down\n            result.append('D');\n            state.row++;\n        } else if (state.dir == 2) { // Left\n            result.append('L');\n            state.col--;\n        } else { // Up\n            result.append('U');\n            state.row--;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {  row, col; int dir; // 0=right, 1=down, 2=left,  int dir) { this.row = row; this.col = col; this.dir = dir; } } static int[][] horizontal = new int[5][4]; // 5 horizontal lines, 4 segments each static int[][] vertical = new int[4][5]; // 4 vertical lines,  void main(String[] args) { Scanner sc = new Scanner(System.in); // Read horizontal walls for (int i = 0; i < 5; i++) { String line = sc.nextLine(); for  horizontal[i][j] = line.charAt(j) - '0';  walls for (int i = 0; i < 4; i++) {  (int j = 0; j < 5;  -  at position (0,0), facing right (dir=0) // Right hand is on the wall above (horizontal[0][0] = 1) State state = new State(0, 0, 0); StringBuilder result = new StringBuilder(); do { // Try to turn right first (right-hand rule) int rightDir = (state.dir  Turn right and move state.dir   { // Move straight move(state, result); } else { // Turn left state.dir = (state.dir + 1) % 4; } } while (!(state.row == 0 && state.col == 0 && state.dir == 0)); System.out.println(result.toString()); } static boolean canMove(int row, int col, int dir) { if (dir  if (col >= 4)  0;  1) { // Down if  return horizontal[row + 1][col] == 0; } else  // Left if (col <= 0) return false;  0; }  (row <= 0) return false; return horizontal[row][col] == 0; } } static void move(State state, StringBuilder result) { if (state.dir == 0) { //  if (state.dir == 1) { // Down result.append('D'); state.row++;  2) { // Left result.append('L'); state.col--; } else { // Up result.append('U'); state.row--; } } }"], "perturbed_original": ["import java.util.*;  java.lang.Math.*; // AOJ 0037 public class Main { static Scanner sc = new Scanner(System.in); static final double EPS = 1e-10; public static void main(String[]  i =   = 0; i < 9; i++) { String buf = sc.next(); for (int j = 0; j < buf.length(); j++) { if (i % 2 == 0) { cs[i + 1][j * 2 + 2] = buf.charAt(j); } else { cs[i + 1][j * 2 + 1] = buf.charAt(j); } } } int[] dx = {1, 0, -1, 0}, dy = {0, 1, 0,  \"D\", \"L\", \"U\"}; int x = 1, y = 1, d = 0; while (!(x == 1 && y == 1 && d == 2))  + dx[d]] == '1') { x += dx[d] * 2; y +=  else { if (cs[y + dy[(d - 1 + 4) % 4]][x + dx[(d - 1 + 4) %   4) % 4;  4; } } } System.out.println(); } }"], "original_ll": -0.708753228187561, "sampled_ll": -0.4425762891769409, "all_perturbed_sampled_ll": [-1.5294041633605957], "all_perturbed_original_ll": [-1.5366566181182861], "perturbed_sampled_ll": -1.5294041633605957, "perturbed_original_ll": -1.5366566181182861, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "path = [[[] for i in range(5)] for i in range(5)]\nfor i in range(9):\n    if i%2 == 0:\n        a = [int(i) for i in list(input())]\n        for j in range(4):\n            if a[j] == 1:\n                path[int(i/2)][j].append(\"R\")\n                path[int(i/2)][j+1].append(\"L\")\n    else:\n        a = [int(i) for i in list(input())]\n        for j in range(5):\n            if a[j] == 1:\n                path[int(i/2)][j].append(\"D\")\n                path[int(i/2)+1][j].append(\"U\")\n\nprev = \"R\"\np = \"R\"\nx = 0\ny = 0\nwhile(1):\n    if prev == \"R\":\n        if \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n    elif prev == \"L\":\n        if \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n    elif prev == \"U\":\n        if \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n    elif prev == \"D\":\n        if \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n    if x == 0 and y == 0:\n        break\nprint(p[1:])\n\n\n    \n\n", "sampled": "def solve():\n    # Read input\n    lines = []\n    for _ in range(9):\n        lines.append(input().strip())\n    \n    # Parse walls\n    # h_walls[i][j] = horizontal wall between row i and i+1, at column j\n    # v_walls[i][j] = vertical wall between column j and j+1, at row i\n    h_walls = []\n    v_walls = []\n    \n    for i in range(9):\n        if i % 2 == 0:  # horizontal walls\n            h_walls.append([int(c) for c in lines[i]])\n        else:  # vertical walls\n            v_walls.append([int(c) for c in lines[i]])\n    \n    # Start at point A (top-left corner, position (0, 0))\n    # Initial direction: facing right (since we start by going right with wall on right)\n    # Directions: 0=Right, 1=Down, 2=Left, 3=Up\n    pos = (0, 0)\n    direction = 0  # facing right\n    path = []\n    \n    # Direction vectors\n    dx = [1, 0, -1, 0]  # Right, Down, Left, Up\n    dy = [0, 1, 0, -1]\n    dir_chars = ['R', 'D', 'L', 'U']\n    \n    def has_wall(r, c, d):\n        \"\"\"Check if there's a wall when moving from (r,c) in direction d\"\"\"\n        if d == 0:  # Right\n            if c >= len(v_walls[0]):\n                return True\n            return v_walls[r][c] == 1\n        elif d == 1:  # Down\n            if r >= len(h_walls) - 1:\n                return True\n            return h_walls[r + 1][c] == 1\n        elif d == 2:  # Left\n            if c == 0:\n                return True\n            return v_walls[r][c - 1] == 1\n        else:  # Up (d == 3)\n            if r == 0:\n                return True\n            return h_walls[r][c] == 1\n    \n    while True:\n        # Try to turn right first (right-hand rule)\n        right_dir = (direction - 1) % 4\n        \n        # Check if we can go right\n        if not has_wall(pos[1], pos[0], right_dir):\n            # Turn right and move\n            direction = right_dir\n            pos = (pos[0] + dx[direction], pos[1] + dy[direction])\n            path.append(dir_chars[direction])\n        # Check if we can go straight\n        elif not has_wall(pos[1], pos[0], direction):\n            # Move straight\n            pos = (pos[0] + dx[direction], pos[1] + dy[direction])\n            path.append(dir_chars[direction])\n        else:\n            # Turn left\n            direction = (direction + 1) % 4\n            continue\n        \n        # Check if we're back at start\n        if pos == (0, 0) and len(path) > 0:\n            break\n    \n    print(''.join(path))\n\nsolve()\n", "perturbed_sampled": ["def solve(): # Read input lines = [] for _ in range(9): lines.append(input().strip()) # Parse walls # h_walls[i][j] = horizontal wall between row i and i+1, at column j # v_walls[i][j] = vertical wall between column j and j+1, at row i h_walls = [] v_walls = [] for i in range(9): if i % 2 == 0: # horizontal walls h_walls.append([int(c) for c in lines[i]])  for c in lines[i]]) # Start at point A (top-left corner, position (0, 0)) # Initial direction: facing right (since we  Directions: 0=Right, 1=Down, 2=Left, 3=Up pos = (0, 0) direction = 0 # facing right path =  =  Right, Down, Left, Up dy = [0,  def has_wall(r, c, d): \"\"\"Check if there's a wall  direction d\"\"\" if d == 0: # Right if c   if r >= len(h_walls) - 1: return True  1 elif d == 2: # Left if c == 0: return True return v_walls[r][c - 1] == 1 else: # Up (d == 3)  True return  # Try to turn right first (right-hand rule) right_dir = (direction - 1) % 4   pos[0], right_dir): #   + dx[direction], pos[1] + dy[direction]) path.append(dir_chars[direction]) # Check if we can go straight elif not has_wall(pos[1], pos[0], direction): # Move straight  pos[1] + dy[direction]) path.append(dir_chars[direction]) else: # Turn left direction = (direction + 1) % 4 continue # Check if we're back at start if pos == (0, 0) and len(path) > 0: break print(''.join(path)) solve()"], "perturbed_original": ["path = [[[] for i in range(5)] for i in range(5)] for i in range(9): if i%2 == 0: a  list(input())] for j in range(4): if a[j] == 1: path[int(i/2)][j].append(\"R\") path[int(i/2)][j+1].append(\"L\") else: a = [int(i) for i in list(input())] for j in range(5): if a[j] == 1: path[int(i/2)][j].append(\"D\") path[int(i/2)+1][j].append(\"U\") prev = \"R\" p = \"R\"  0 while(1): if prev == \"R\": if \"U\" in path[x][y]: x -= 1 prev = \"U\" p +=  y += 1 prev = \"R\" p += \"R\" elif \"D\" in path[x][y]: x += 1 prev  elif \"L\" in path[x][y]: y -=  += \"L\" elif prev == \"L\": if \"D\" in path[x][y]: x += 1 prev =   1 prev = \"L\" p += \"L\" elif \"U\" in path[x][y]: x -= 1 prev = \"U\" p += \"U\" elif \"R\" in path[x][y]: y += 1 prev = \"R\"   path[x][y]: y -= 1 prev  x -= 1 prev = \"U\" p += \"U\" elif \"R\" in path[x][y]: y += 1 prev = \"R\" p += \"R\" elif \"D\" in path[x][y]: x += 1 prev = \"D\" p  \"D\": if \"R\" in path[x][y]: y += 1 prev = \"R\" p += \"R\"  \"D\" p += \"D\" elif  1 prev = \"L\" p  path[x][y]: x -= 1  0 and y == 0: break print(p[1:])"], "original_ll": -0.3090987801551819, "sampled_ll": -0.690674364566803, "all_perturbed_sampled_ll": [-1.7671161890029907], "all_perturbed_original_ll": [-1.1582928895950317], "perturbed_sampled_ll": -1.7671161890029907, "perturbed_original_ll": -1.1582928895950317, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint isstraight(int[5]);\n\nint main(void) {\n\tint cards[5];\n\tint i,j,temp;\n\tint yaku;\n\tchar yakuname[7][11]={\"null\",\"one pair\",\"two pair\",\"three card\",\n\t\t\t\t\t\t\"straight\",\"full house\",\"four card\"};\n\twhile(1) {\n\t\tif(scanf(\"%d,%d,%d,%d,%d\",\n\t\t\t&cards[0],&cards[1],&cards[2],&cards[3],&cards[4])==-1)break;\n\t\tfor(i=4;i>0;i--) {\n\t\t\tfor(j=0;j<i;j++) {\n\t\t\t\tif(cards[j]>cards[j+1]) {\n\t\t\t\t\ttemp=cards[j];\n\t\t\t\t\tcards[j]=cards[j+1];\n\t\t\t\t\tcards[j+1]=temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tyaku=0;\n\t\tif(cards[1]==cards[2] && cards[2]==cards[3]) {\n\t\t\tif(cards[0]==cards[1] || cards[3]==cards[4])yaku=6;\n\t\t\telse yaku=3;\n\t\t} else if(cards[0]==cards[1] && cards[1]==cards[2]) {\n\t\t\tif(cards[3]==cards[4])yaku=5; else yaku=3;\n\t\t} else if(cards[2]==cards[3] && cards[3]==cards[4]) {\n\t\t\tif(cards[0]==cards[1])yaku=5; else yaku=3;\n\t\t} else if(isstraight(cards))yaku=4;\n\t\telse {\n\t\t\tfor(i=0;i<4;i++) {\n\t\t\t\tif(cards[i]==cards[i+1])yaku++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",yakuname[yaku]);\n\t}\n\treturn 0;\n}\n\nint isstraight(int cards[5]) {\n\tint i;\n\tfor(i=0;i<4;i++) {\n\t\tif(cards[i]+1!=cards[i+1])break;\n\t}\n\tif(i<4) {\n\t\tif(cards[0]==1 && cards[1]==10 && cards[2]==11 &&\n\t\t\tcards[3]==12 && cards[4]==13)return 1; else return 0;\n\t} else return 1;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    char line[100];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int cards[5];\n        sscanf(line, \"%d,%d,%d,%d,%d\", &cards[0], &cards[1], &cards[2], &cards[3], &cards[4]);\n        \n        // Count frequency of each card value\n        int count[14] = {0};\n        for (int i = 0; i < 5; i++) {\n            count[cards[i]]++;\n        }\n        \n        // Check for pairs, three of a kind, four of a kind\n        int pairs = 0, threes = 0, fours = 0;\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 2) pairs++;\n            else if (count[i] == 3) threes++;\n            else if (count[i] == 4) fours++;\n        }\n        \n        // Check for straight\n        qsort(cards, 5, sizeof(int), compare);\n        int is_straight = 0;\n        \n        // Normal straight\n        if (cards[1] == cards[0] + 1 && \n            cards[2] == cards[1] + 1 && \n            cards[3] == cards[2] + 1 && \n            cards[4] == cards[3] + 1) {\n            is_straight = 1;\n        }\n        \n        // A-2-3-4-5 straight\n        if (cards[0] == 1 && cards[1] == 2 && cards[2] == 3 && \n            cards[3] == 4 && cards[4] == 5) {\n            is_straight = 1;\n        }\n        \n        // 10-J-Q-K-A straight\n        if (cards[0] == 1 && cards[1] == 10 && cards[2] == 11 && \n            cards[3] == 12 && cards[4] == 13) {\n            is_straight = 1;\n        }\n        \n        // Determine the hand\n        if (fours > 0) {\n            printf(\"four card\\n\");\n        } else if (threes > 0 && pairs > 0) {\n            printf(\"full house\\n\");\n        } else if (is_straight) {\n            printf(\"straight\\n\");\n        } else if (threes > 0) {\n            printf(\"three card\\n\");\n        } else if (pairs == 2) {\n            printf(\"two pair\\n\");\n        } else if (pairs == 1) {\n            printf(\"one pair\\n\");\n        } else {\n            printf(\"null\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  void *a, const void *b) { return (*(int*)a - *(int*)b); } int main() { char line[100]; while (fgets(line, sizeof(line), stdin)) { int cards[5]; sscanf(line,  &cards[4]); // Count frequency of each card value int count[14] = {0}; for (int i = 0; i < 5; i++) { count[cards[i]]++; } // Check for pairs, three of a kind, four of a kind int  for (int i = 1; i <= 13; i++)  pairs++; else if (count[i] == 3) threes++; else if (count[i] == 4) fours++; } //  sizeof(int), compare); int is_straight = 0; // Normal straight   + 1 && cards[3] == cards[2] + 1 && cards[4]  is_straight = 1; } // A-2-3-4-5 straight  cards[2] ==  && cards[4] == 5) {  10-J-Q-K-A straight if (cards[0] == 1 && cards[1]  11 && cards[3] == 12 && cards[4] == 13) { is_straight = 1; } // Determine the hand if (fours > 0) { printf(\"four card\\n\"); } else if (threes >  { printf(\"full house\\n\"); } else if (is_straight) { printf(\"straight\\n\"); } else if (threes >  else if (pairs == 2) { printf(\"two pair\\n\"); } else if (pairs == 1) { printf(\"one pair\\n\"); } else { printf(\"null\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int isstraight(int[5]); int main(void) { int cards[5]; int  pair\",\"two pair\",\"three card\", \"straight\",\"full house\",\"four card\"}; while(1) { if(scanf(\"%d,%d,%d,%d,%d\", &cards[0],&cards[1],&cards[2],&cards[3],&cards[4])==-1)break; for(i=4;i>0;i--) { for(j=0;j<i;j++) { if(cards[j]>cards[j+1]) { temp=cards[j]; cards[j]=cards[j+1]; cards[j+1]=temp; } } } yaku=0; if(cards[1]==cards[2] && cards[2]==cards[3]) { if(cards[0]==cards[1] || cards[3]==cards[4])yaku=6; else yaku=3; } else if(cards[0]==cards[1] && cards[1]==cards[2])  { if(cards[0]==cards[1])yaku=5; else yaku=3;  for(i=0;i<4;i++) { if(cards[i]==cards[i+1])yaku++; } } printf(\"%s\\n\",yakuname[yaku]); } return 0; } int isstraight(int cards[5]) { int i; for(i=0;i<4;i++) { if(cards[i]+1!=cards[i+1])break; } if(i<4) {  && cards[3]==12 && cards[4]==13)return 1; else  1; }"], "original_ll": -0.6049731969833374, "sampled_ll": -0.3463745415210724, "all_perturbed_sampled_ll": [-1.4755979776382446], "all_perturbed_original_ll": [-1.095000982284546], "perturbed_sampled_ll": -1.4755979776382446, "perturbed_original_ll": -1.095000982284546, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tprivate static boolean checkFourCard(int[] group){\n\t\tboolean flag = false;\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(group[i] == 4){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\t\n\tprivate static boolean checkFullHouse(int[] group){\n\t\tboolean two=false, three=false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(group[i] == 2){\n\t\t\t\ttwo = true;\n\t\t\t}else if(group[i] == 3){\n\t\t\t\tthree = true;\n\t\t\t}\n\t\t}\n\t\tif(two && three){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate static boolean checkStraight(int[] group){\n\t\tboolean flag = false;\n\t\tint count = 0;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(group[i] == 1){\n\t\t\t\t//\u307e\u305f\u3044\u3060\u56de\u6570\n\t\t\t\tint over = 0;\n\t\t\t\tfor(int j=i; j<i+5; ++j){\n\t\t\t\t\tover += j/group.length;\n\t\t\t\t\tif(over > 1){\t//2\u307e\u3067\u884c\u3063\u305f\u3089\u3001\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint num = j%13;\n\t\t\t\t\tif(num == 0){ num = 13; }\n\t\t\t\t\tif(group[num] == 1){\n\t\t\t\t\t\t++count;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count == 5){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\tprivate static boolean checkThreeCard(int[] group){\n\t\tboolean flag = false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\t//main \u3067 else if \u3084\u3063\u3066\u3044\u308b\u304b\u3089\u5927\u4e08\u592b\u3060\u3051\u3069\u3001full house \u8aa4\u8a8d\u9632\u6b62\n\t\t\tif(group[i] == 2){\n\t\t\t\treturn false;\n\t\t\t}else if(group[i] == 3){\t\t//four card\u3082false\u3067\u5e30\u308b\u3002\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\t\n\tprivate static boolean checkTwoPair(int[] group){\n\t\tboolean flag = false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(flag){\t\t//one pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001\n\t\t\t\tif(group[i] == 2){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(group[i] == 2){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate static boolean checkOnePair(int[] group){\n\t\tboolean flag = false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(flag){\t\t//one pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001\n\t\t\t\tif(group[i] == 2 || group[i] == 3){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(group[i] == 2){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\t\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scan = new Scanner(System.in);\n\t\tint hand[] = new int [5];\n\t\t\n\t\twhile(scan.hasNext()){\n\t\t\tString[] str = scan.next().split(\",\");\n\t\t\tfor(int i=0; i<str.length; ++i){\n\t\t\t\thand[i] = Integer.parseInt(str[i]);\n\t\t\t}\n\t\t\t\n\t\t\tint group[] = new int [14];\t//\u6dfb\u5b57\u304c\u30ab\u30fc\u30c9\u30ca\u30f3\u30d0\u3068\u5bfe\u5fdc\u3002\uff10\u306f\u6b20\u756a\n\t\t\tArrays.fill(group, 0);\n\t\t\tfor(int i=0; i<hand.length; ++i){\n\t\t\t\t++group[hand[i]];\n\t\t\t}\n\t\t\t\n\t\t\tif(checkFourCard(group)){\n\t\t\t\tSystem.out.println(\"four card\");\n\t\t\t}else if(checkFullHouse(group)){\n\t\t\t\tSystem.out.println(\"full house\");\n\t\t\t}else if(checkStraight(group)){\n\t\t\t\tSystem.out.println(\"straight\");\n\t\t\t}else if(checkThreeCard(group)){\n\t\t\t\tSystem.out.println(\"three card\");\n\t\t\t}else if(checkTwoPair(group)){\n\t\t\t\tSystem.out.println(\"two pair\");\n\t\t\t}else if(checkOnePair(group)){\n\t\t\t\tSystem.out.println(\"one pair\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"null\");\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] cards = line.split(\",\");\n            int[] hand = new int[5];\n            for (int i = 0; i < 5; i++) {\n                hand[i] = Integer.parseInt(cards[i]);\n            }\n            \n            System.out.println(evaluateHand(hand));\n        }\n        \n        sc.close();\n    }\n    \n    static String evaluateHand(int[] hand) {\n        int[] count = new int[14];\n        for (int card : hand) {\n            count[card]++;\n        }\n        \n        // Check for four card\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 4) {\n                return \"four card\";\n            }\n        }\n        \n        // Check for full house\n        boolean hasThree = false;\n        boolean hasTwo = false;\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 3) hasThree = true;\n            if (count[i] == 2) hasTwo = true;\n        }\n        if (hasThree && hasTwo) {\n            return \"full house\";\n        }\n        \n        // Check for straight\n        if (isStraight(hand)) {\n            return \"straight\";\n        }\n        \n        // Check for three card\n        if (hasThree) {\n            return \"three card\";\n        }\n        \n        // Check for two pair\n        int pairCount = 0;\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 2) pairCount++;\n        }\n        if (pairCount == 2) {\n            return \"two pair\";\n        }\n        \n        // Check for one pair\n        if (pairCount == 1) {\n            return \"one pair\";\n        }\n        \n        return \"null\";\n    }\n    \n    static boolean isStraight(int[] hand) {\n        int[] sorted = hand.clone();\n        Arrays.sort(sorted);\n        \n        // Check normal straight\n        boolean isConsecutive = true;\n        for (int i = 1; i < 5; i++) {\n            if (sorted[i] != sorted[i-1] + 1) {\n                isConsecutive = false;\n                break;\n            }\n        }\n        if (isConsecutive) return true;\n        \n        // Check A-2-3-4-5\n        if (sorted[0] == 1 && sorted[1] == 2 && sorted[2] == 3 && sorted[3] == 4 && sorted[4] == 5) {\n            return true;\n        }\n        \n        // Check 10-J-Q-K-A\n        if (sorted[0] == 1 && sorted[1] == 10 && sorted[2] == 11 && sorted[3] == 12 && sorted[4] == 13) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String  break; String[] cards = line.split(\",\"); int[] hand = new  0; i < 5; i++) { hand[i] = Integer.parseInt(cards[i]); } System.out.println(evaluateHand(hand)); } sc.close(); } static String evaluateHand(int[] hand) { int[] count = new int[14]; for (int card : hand) { count[card]++; } // Check for four card for (int i =  { if (count[i] == 4) { return \"four card\"; } } // Check for  false; boolean hasTwo =  1; i <= 13; i++) { if (count[i] == 3) hasThree = true; if (count[i] == 2) hasTwo = true; } if (hasThree && hasTwo)  // Check for straight if (isStraight(hand)) {  for  return \"three card\";  0; for (int  13; i++) { if (count[i] == 2) pairCount++;  { return  for one pair  return \"one pair\"; } return \"null\"; } static boolean isStraight(int[] hand) { int[] sorted = hand.clone(); Arrays.sort(sorted); // Check normal straight boolean isConsecutive = true; for (int i = 1; i < 5; i++) { if (sorted[i] != sorted[i-1] + 1) { isConsecutive = false; break; } } if (isConsecutive) return  sorted[1] == 2 && sorted[2]  4 && sorted[4] == 5) {  10-J-Q-K-A if (sorted[0]  10 && sorted[2] == 11 && sorted[3] == 12 && sorted[4] == 13) { return true; } return false; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { private static boolean checkFourCard(int[] group){ boolean flag = false; for(int  4){ flag = true; } } return flag; } private static   = true; }else if(group[i] == 3){ three = true; } } if(two &&  false; } } private static boolean checkStraight(int[] group){ boolean flag = false; int count = 0; for(int i=1; i<group.length; ++i){ if(group[i] == 1){ //\u307e\u305f\u3044\u3060\u56de\u6570 int over = 0; for(int  j/group.length; if(over > 1){ //2\u307e\u3067\u884c\u3063\u305f\u3089\u3001 return false; }  == 0){ num = 13; } if(group[num] == 1){ ++count;  } } if(count ==  } } } return flag; } private static boolean checkThreeCard(int[] group){ boolean flag = false; for(int i=1; i<group.length; ++i){ //main \u3067 else if \u3084\u3063\u3066\u3044\u308b\u304b\u3089\u5927\u4e08\u592b\u3060\u3051\u3069\u3001full house \u8aa4\u8a8d\u9632\u6b62 if(group[i] == 2){ return false; }else if(group[i] == 3){ //four card\u3082false\u3067\u5e30\u308b\u3002 flag = true; } } return flag; } private static boolean checkTwoPair(int[] group){ boolean flag = false; for(int i=1; i<group.length; ++i){  == 2){ return  2){ flag = true; } } return false; } private static boolean checkOnePair(int[] group){   pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001 if(group[i] == 2 || group[i] == 3){ flag =  2){ flag = true; } } return flag; } /** * @param args */ public  // TODO Auto-generated method   int [5]; while(scan.hasNext()){ String[] str = scan.next().split(\",\"); for(int i=0;  } int group[] = new int [14]; //\u6dfb\u5b57\u304c\u30ab\u30fc\u30c9\u30ca\u30f3\u30d0\u3068\u5bfe\u5fdc\u3002\uff10\u306f\u6b20\u756a Arrays.fill(group, 0); for(int i=0; i<hand.length; ++i){  }else if(checkFullHouse(group)){ System.out.println(\"full  if(checkThreeCard(group)){ System.out.println(\"three card\"); }else if(checkTwoPair(group)){ System.out.println(\"two pair\"); }else if(checkOnePair(group)){ System.out.println(\"one pair\"); }else{ System.out.println(\"null\"); } } } }"], "original_ll": -0.7192032337188721, "sampled_ll": -0.3249523341655731, "all_perturbed_sampled_ll": [-1.3717811107635498], "all_perturbed_original_ll": [-1.8166311979293823], "perturbed_sampled_ll": -1.3717811107635498, "perturbed_original_ll": -1.8166311979293823, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nfor s in sys.stdin:\n    A = list(map(int, s.split(',')))\n    A.sort()\n    #print(A)\n\n    if (A[0] == A[1] == A[2] == A[3]) or (A[1] == A[2] == A[3] == A[4]):\n        print('four card')\n\n    # full house\n    elif (A[0] == A[1] == A[2]) and (A[3] == A[4]):\n        print('full house')\n    elif (A[0] == A[1]) and (A[2] == A[3] == A[4]):\n        print('full house')\n\n    # straight\n    elif A[0] == A[1] - 1 == A[2] - 2 == A[3] - 3 == A[4] - 4:\n        print('straight')\n    elif A[1] == 10 and A[2] == 11 and A[3] == 12 and A[4] == 13 and A[0] == 1:\n        print('straight')\n\n    # three card\n    elif (A[0] == A[1] == A[2]) or (A[1] == A[2] == A[3]) or (A[2] == A[3] == A[4]):\n        print('three card')\n\n    # two pair\n    elif ((A[0] == A[1]) and (A[2] == A[3])) or ((A[0] == A[1]) and (A[3] == A[4])) or ((A[1] == A[2]) and (A[3] == A[4])):\n        print('two pair')\n\n    # one pair\n    elif (A[0] == A[1]) or (A[1] == A[2]) or (A[2] == A[3]) or (A[3] == A[4]):\n        print('one pair')\n\n    else:\n        print('null')", "sampled": "import sys\nfrom collections import Counter\n\ndef get_hand_rank(cards):\n    counts = Counter(cards)\n    count_values = sorted(counts.values(), reverse=True)\n    \n    # Check for four card\n    if count_values[0] == 4:\n        return \"four card\"\n    \n    # Check for full house\n    if count_values[0] == 3 and count_values[1] == 2:\n        return \"full house\"\n    \n    # Check for straight\n    sorted_cards = sorted(cards)\n    is_straight = True\n    for i in range(4):\n        if sorted_cards[i+1] - sorted_cards[i] != 1:\n            is_straight = False\n            break\n    \n    if is_straight:\n        return \"straight\"\n    \n    # Check for A-2-3-4-5 straight\n    if sorted_cards == [1, 2, 3, 4, 5]:\n        return \"straight\"\n    \n    # Check for 10-J-Q-K-A straight\n    if sorted_cards == [1, 10, 11, 12, 13]:\n        return \"straight\"\n    \n    # Check for three card\n    if count_values[0] == 3:\n        return \"three card\"\n    \n    # Check for two pair\n    if count_values[0] == 2 and count_values[1] == 2:\n        return \"two pair\"\n    \n    # Check for one pair\n    if count_values[0] == 2:\n        return \"one pair\"\n    \n    return \"null\"\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        break\n    cards = list(map(int, line.split(',')))\n    print(get_hand_rank(cards))\n", "perturbed_sampled": ["import sys from collections import  Counter(cards) count_values = sorted(counts.values(), reverse=True) # Check for four card if count_values[0] == 4: return \"four card\" # Check for full house if count_values[0] == 3 and count_values[1] == 2: return \"full house\" # Check  is_straight = True for i  sorted_cards[i] !=  if is_straight: return \"straight\" # Check for  [1,  10-J-Q-K-A  10, 11, 12, 13]: return \"straight\" # Check for three card if count_values[0] == 3: return \"three card\" # Check for two pair if count_values[0] == 2 and count_values[1] == 2: return \"two pair\" # Check for one pair if count_values[0] == 2: return \"one  in sys.stdin: line = line.strip() if not line: break cards = list(map(int, line.split(','))) print(get_hand_rank(cards))"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys import os for s in sys.stdin: A = list(map(int, s.split(','))) A.sort() #print(A) if (A[0] == A[1] == A[2] == A[3]) or (A[1] == A[2] == A[3] ==  house  A[2]) and  elif (A[0] == A[1]) and (A[2] == A[3] == A[4]): print('full house') # straight elif A[0] == A[1] - 1 == A[2] - 2 == A[3] - 3 == A[4] - 4: print('straight') elif A[1] == 10 and A[2] == 11 and A[3] == 12 and A[4] == 13 and A[0]  card elif (A[0] == A[1] == A[2]) or (A[1] == A[2] == A[3]) or (A[2] == A[3] ==  A[1]) and (A[2] ==  or ((A[1] == A[2]) and (A[3] == A[4])): print('two pair') # one pair  (A[2] == A[3]) or (A[3] == A[4]): print('one pair') else: print('null')"], "original_ll": -0.39829304814338684, "sampled_ll": -0.5601951479911804, "all_perturbed_sampled_ll": [-1.5180530548095703], "all_perturbed_original_ll": [-1.0975958108901978], "perturbed_sampled_ll": -1.5180530548095703, "perturbed_original_ll": -1.0975958108901978, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\n\n\nint main(){\n  int i,j,k,l,al[]={0,1,5,7,11,17,19,23,25},n,clen;\n  char ci[257],ans[257];\n  fgets(ci,256,stdin);\n  n=atoi(ci);\n  for(i=0;i<n;i++){\n    fgets(ci,256,stdin);\n    clen=strlen(ci);\n    ans[clen]='\\0';\n    for(j=0;j<9;j++){\n      for(k=0;k<26;k++){\n\tfor(l=0;l<clen;l++){\n\t  if(isalpha(ci[l]))\n\t    ans[l]=(al[j]*((int)ci[l]-(int)'a')+k)%26+'a';\n\t  else\n\t    ans[l]=ci[l];\n\t}\n\tif(strstr(ans,\"that\")||strstr(ans,\"this\")){\n\t  printf(\"%s\",ans);\n\t  goto find;\n\t}\n      }\n    }\n  find:;\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint mod_inverse(int a, int m) {\n    for (int i = 1; i < m; i++) {\n        if ((a * i) % m == 1) return i;\n    }\n    return -1;\n}\n\nvoid decrypt(char *text, int alpha, int beta, char *result) {\n    int alpha_inv = mod_inverse(alpha, 26);\n    if (alpha_inv == -1) {\n        result[0] = '\\0';\n        return;\n    }\n    \n    int len = strlen(text);\n    for (int i = 0; i < len; i++) {\n        if (isalpha(text[i])) {\n            int c = text[i] - 'a';\n            int decoded = (alpha_inv * (c - beta + 26)) % 26;\n            if (decoded < 0) decoded += 26;\n            result[i] = decoded + 'a';\n        } else {\n            result[i] = text[i];\n        }\n    }\n    result[len] = '\\0';\n}\n\nint contains_word(char *text, char *word) {\n    int text_len = strlen(text);\n    int word_len = strlen(word);\n    \n    for (int i = 0; i <= text_len - word_len; i++) {\n        if (i > 0 && isalpha(text[i-1])) continue;\n        if (i + word_len < text_len && isalpha(text[i + word_len])) continue;\n        \n        int match = 1;\n        for (int j = 0; j < word_len; j++) {\n            if (text[i + j] != word[j]) {\n                match = 0;\n                break;\n            }\n        }\n        if (match) return 1;\n    }\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\\n\", &n);\n    \n    for (int t = 0; t < n; t++) {\n        char text[257];\n        fgets(text, 257, stdin);\n        int len = strlen(text);\n        if (text[len-1] == '\\n') text[len-1] = '\\0';\n        \n        char result[257];\n        int found = 0;\n        \n        for (int alpha = 1; alpha < 26 && !found; alpha++) {\n            if (gcd(alpha, 26) != 1) continue;\n            \n            for (int beta = 0; beta < 26 && !found; beta++) {\n                decrypt(text, alpha, beta, result);\n                \n                if (contains_word(result, \"that\") || contains_word(result, \"this\")) {\n                    printf(\"%s\\n\", result);\n                    found = 1;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <ctype.h> int gcd(int a, int b) { if (b == 0) return  b); } int mod_inverse(int a, int m) { for (int i = 1; i < m; i++) { if ((a * i) % m == 1) return i; } return -1; } void decrypt(char *text, int alpha, int beta, char  mod_inverse(alpha, 26); if (alpha_inv == -1)  } int len = strlen(text); for (int i = 0; i < len; i++) { if (isalpha(text[i])) { int c = text[i] - 'a'; int decoded = (alpha_inv * (c - beta + 26)) % 26; if (decoded < 0) decoded += 26; result[i] = decoded +  = text[i]; } } result[len] = '\\0'; }   int word_len = strlen(word); for (int i = 0; i <= text_len - word_len; i++) {  isalpha(text[i-1]))  < text_len && isalpha(text[i + word_len])) continue; int match = 1; for  < word_len; j++) {  if (match) return 1;  main() { int n;  = 0;  char text[257]; fgets(text,  strlen(text); if (text[len-1] == '\\n')  int found  = 1; alpha < 26 && !found; alpha++) { if (gcd(alpha, 26) != 1) continue; for (int beta = 0; beta < 26 && !found; beta++) { decrypt(text, alpha, beta, result); if (contains_word(result, \"that\") || contains_word(result, \"this\")) { printf(\"%s\\n\", result); found = 1; } } } } return 0; }"], "perturbed_original": ["/5;find:print(goto find; } i,j,k,l,al[]={0,1,5,7,11,17,19,23,25},n,clen; char ci[257],ans[257]; fgets(ci,256,stdin); n=atoi(ci); for(i=0;i<n;i++){ fgets(ci,256,stdin); clen=strlen(ci); ans[clen]='\\0'; for(j=0;j<9;j++){ for(k=0;k<26;k++){ for(l=0;l<clen;l++){ if(isalpha(ci[l])) ans[l]=(al[j]*((int)ci[l]-(int)'a')+k)%26+'a'; else ans[l]=ci[l]; } if(strstr(ans,\"that\")||strstr(ans,\"this\")){ printf(\"%s\",ans); goto find; } }  }"], "original_ll": -1.1490429639816284, "sampled_ll": -0.4386623203754425, "all_perturbed_sampled_ll": [-1.472521185874939], "all_perturbed_original_ll": [-1.6816455125808716], "perturbed_sampled_ll": -1.472521185874939, "perturbed_original_ll": -1.6816455125808716, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\n\n\n class Main{\n     \n    static  ArrayList<String> al=new ArrayList<String>();\n    static int A=1,B=0;\n    static char chars[]= new char[]{\n         'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',\n         'q','r','s','t','u','v','w','x','y','z'\n     };\n    static char getChar(int n){return chars[n];}\n    static int getCode(char c){return (int)c-(int)'a';}\n    static int F(int m){return (A*m+B)%26;}\n    static String replace(String str){\n        StringBuilder sb=new StringBuilder();\n        for(int i=0; i<str.length(); i++){\n           // System.out.println(str.charAt(i)+\" \"+F(getCode(str.charAt(i))));\n            char replaced = getChar(F(getCode(str.charAt(i))));\n            //System.out.println(replaced);\n            sb.append(replaced);\n        }        return new String(sb);\n    }\n    static void detectAB(){\n        A=1;B=0;\n        for(int a=1; a<30000;a+=2){\n            for(int b=0; b<26;b++){\n                A=a;B=b;\n                for(String str:al){\n                    String rep = replace(str);\n                    //System.out.println(rep);\n                    if(rep.equals(\"this\")||rep.equals(\"that\"))return;\n                }\n            }\n        }\n    }\n    \n     public static void main(String args[]){\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // System.out.println(getCode('a')+\"\"+getCode('b')+\"\"+getCode('z'));\n         //System.out.println(replace(\"abz\"));\n         //String line;\n         try{\n         int n=Integer.parseInt(br.readLine());\n         //int n=1;\n         //for(int i=0; i<n;i++){\n         String line;\n         while((line=br.readLine())!=null){\n             //System.out.println(\"aa\"+n);\n             al.clear();\n             \n             //System.out.println(line);\n             String split[]=line.split(\" \");\n             for(String str:split)if(str.length()==4)al.add(str);\n            detectAB();\n             System.out.print(replace(split[0]));\n            for(int j=1; j<split.length;j++){\n                System.out.print(\" \"+replace(split[j]));\n            }\n             System.out.println();\n         }\n         }catch(Exception e){}\n         \n     }\n     \n }", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String encrypted = sc.nextLine();\n            String decrypted = decrypt(encrypted);\n            System.out.println(decrypted);\n        }\n    }\n    \n    static String decrypt(String encrypted) {\n        // Try all possible alpha and beta values\n        for (int alpha = 1; alpha < 26; alpha++) {\n            if (gcd(alpha, 26) != 1) continue; // alpha must be coprime with 26\n            \n            for (int beta = 0; beta < 26; beta++) {\n                String decrypted = tryDecrypt(encrypted, alpha, beta);\n                if (decrypted != null && (decrypted.contains(\"that\") || decrypted.contains(\"this\"))) {\n                    return decrypted;\n                }\n            }\n        }\n        return encrypted;\n    }\n    \n    static String tryDecrypt(String encrypted, int alpha, int beta) {\n        // Find modular inverse of alpha\n        int alphaInv = modInverse(alpha, 26);\n        if (alphaInv == -1) return null;\n        \n        StringBuilder sb = new StringBuilder();\n        for (char c : encrypted.toCharArray()) {\n            if (c >= 'a' && c <= 'z') {\n                int y = c - 'a';\n                int x = (alphaInv * (y - beta + 26)) % 26;\n                if (x < 0) x += 26;\n                sb.append((char)('a' + x));\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n    \n    static int gcd(int a, int b) {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n    \n    static int modInverse(int a, int m) {\n        for (int x = 1; x < m; x++) {\n            if ((a * x) % m == 1) {\n                return x;\n            }\n        }\n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) {  int n = sc.nextInt(); sc.nextLine(); for (int i = 0; i < n; i++) { String encrypted = sc.nextLine(); String decrypted = decrypt(encrypted); System.out.println(decrypted); } } static String decrypt(String  possible alpha and beta values for (int alpha = 1; alpha < 26; alpha++) { if (gcd(alpha, 26) != 1) continue; // alpha must be coprime with 26 for (int beta = 0; beta  decrypted = tryDecrypt(encrypted, alpha, beta); if (decrypted  decrypted.contains(\"this\"))) { return decrypted; } } } return encrypted; } static String tryDecrypt(String encrypted, int alpha, int beta) { // Find modular inverse of alpha int alphaInv = modInverse(alpha, 26); if (alphaInv  >=  { int y = c - 'a'; int  - beta + 26)) % 26; if (x < 0) x += 26; sb.append((char)('a' + x)); } else {  a, int b)  return a; return gcd(b, a % b); } static int modInverse(int a, int m) { for  < m; x++) { if ((a * x) % m == 1) { return x; } } return -1; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; class Main{ static <extra_id_10>(A=0,B=1); //int n=0;<extra_id_11>[<extra_id_12>+ char1 A=1,B=0; static char  }; static char getChar(int n){return chars[n];} static int  F(int m){return (A*m+B)%26;} static String replace(String str){ StringBuilder sb=new StringBuilder(); for(int i=0; i<str.length();  sb.append(replaced); } return new String(sb);  for(int a=1; a<30000;a+=2){ for(int b=0; b<26;b++){ A=a;B=b; for(String str:al){ String rep = replace(str); //System.out.println(rep); if(rep.equals(\"this\")||rep.equals(\"that\"))return; } } } } public static void main(String args[]){ BufferedReader br = new  //String line; try{ int n=Integer.parseInt(br.readLine()); //int n=1; //for(int i=0; i<n;i++){ String line; while((line=br.readLine())!=null){ //System.out.println(\"aa\"+n); al.clear(); //System.out.println(line); String split[]=line.split(\" \"); for(String str:split)if(str.length()==4)al.add(str); detectAB(); System.out.print(replace(split[0]));  } System.out.println(); } }catch(Exception e){} } }"], "original_ll": -1.0700280666351318, "sampled_ll": -0.493753045797348, "all_perturbed_sampled_ll": [-1.5251060724258423], "all_perturbed_original_ll": [-2.131070613861084], "perturbed_sampled_ll": -1.5251060724258423, "perturbed_original_ll": -2.131070613861084, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for _ in[0]*int(input()):\n e=input()\n for i in range(1,26,2):\n  for j in range(26):\n   a=''.join([c,chr(((ord(c)-97)*i+j)%26+97)][c.islower()]for c in e)\n   if'that'in a or'this'in a:print(a);break\n", "sampled": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    if gcd(a, m) != 1:\n        return None\n    for i in range(1, m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef decrypt_char(c, alpha, beta):\n    if not c.isalpha():\n        return c\n    alpha_inv = mod_inverse(alpha, 26)\n    if alpha_inv is None:\n        return c\n    val = ord(c) - ord('a')\n    decrypted_val = (alpha_inv * (val - beta)) % 26\n    return chr(decrypted_val + ord('a'))\n\ndef decrypt_text(text, alpha, beta):\n    return ''.join(decrypt_char(c, alpha, beta) for c in text)\n\ndef try_decrypt(encrypted):\n    keywords = [\"that\", \"this\"]\n    \n    for alpha in range(1, 26):\n        if gcd(alpha, 26) != 1:\n            continue\n        \n        for beta in range(26):\n            decrypted = decrypt_text(encrypted, alpha, beta)\n            \n            for keyword in keywords:\n                if keyword in decrypted:\n                    return decrypted\n    \n    return encrypted\n\nn = int(input())\nfor _ in range(n):\n    encrypted = input()\n    print(try_decrypt(encrypted))\n", "perturbed_sampled": ["def gcd(a, b): while b: a, b = b, a % b return a def mod_inverse(a, m): if gcd(a, m) != 1: return None for  (a *  return  alpha, beta): if  = mod_inverse(alpha, 26) if alpha_inv is None: return c val =  (alpha_inv * (val - beta)) % 26 return chr(decrypted_val + ord('a')) def decrypt_text(text, alpha, beta): return ''.join(decrypt_char(c, alpha, beta) for c in text) def try_decrypt(encrypted): keywords = [\"that\", \"this\"] for alpha in  != 1: continue for beta in range(26): decrypted = decrypt_text(encrypted, alpha, beta) for keyword in keywords: if keyword  encrypted n = int(input())  = input() print(try_decrypt(encrypted))"], "perturbed_original": ["for _ in[0]*int(input()): e=input() for i in range(1,26,2): for j in range(26):  a or'this'in a:print(a);break"], "original_ll": -1.9936106204986572, "sampled_ll": -0.6307528018951416, "all_perturbed_sampled_ll": [-2.013249158859253], "all_perturbed_original_ll": [-3.090700387954712], "perturbed_sampled_ll": -2.013249158859253, "perturbed_original_ll": -3.090700387954712, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "d[4],e[9],f,k;char x[];z(){int b,c,a=e[f++];a>9?x[k++]=40,b=z(),x[k++]=a,c=z(),x[k++]=41,a=a-43?a-45?b*c:b-c:b+c:(x[k++]=a+48);return a;}y(o,n,i,j){if(i==7){f=k=0;if(z()==10){x[k]=0;puts(x);return 1;}return 0;}if(o)for(;j--;){e[i]=\"+-*\"[j];if(y(o-1,n+1,i+1,3))return 1;}if(n|i==6)for(j=4;j--;)if(e[i]=d[j]){d[j]=0;if(y(o,n-1,i+1,3))return 1;d[j]=e[i];}return 0;}main(){for(;scanf(\"%d%d%d%d\",d,d+1,d+2,d+3),f=*d;)y(3,0,0,3)||puts(\"0\");}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint nums[4];\nchar result[1025];\nint found;\n\nvoid generate(int depth, int count, int used, int values[], char* exprs[], int value, char* expr) {\n    if (found) return;\n    \n    if (count == 1) {\n        if (value == 10) {\n            strcpy(result, expr);\n            found = 1;\n        }\n        return;\n    }\n    \n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            int newValues[4];\n            char* newExprs[4];\n            int newCount = 0;\n            \n            for (int k = 0; k < count; k++) {\n                if (k != i && k != j) {\n                    newValues[newCount] = values[k];\n                    newExprs[newCount] = exprs[k];\n                    newCount++;\n                }\n            }\n            \n            char expr1[1025], expr2[1025], expr3[1025];\n            \n            // Addition\n            sprintf(expr1, \"(%s + %s)\", exprs[i], exprs[j]);\n            newValues[newCount] = values[i] + values[j];\n            newExprs[newCount] = expr1;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr1);\n            if (found) return;\n            \n            // Subtraction (i - j)\n            sprintf(expr2, \"(%s - %s)\", exprs[i], exprs[j]);\n            newValues[newCount] = values[i] - values[j];\n            newExprs[newCount] = expr2;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr2);\n            if (found) return;\n            \n            // Subtraction (j - i)\n            sprintf(expr3, \"(%s - %s)\", exprs[j], exprs[i]);\n            newValues[newCount] = values[j] - values[i];\n            newExprs[newCount] = expr3;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr3);\n            if (found) return;\n            \n            // Multiplication\n            sprintf(expr1, \"(%s * %s)\", exprs[i], exprs[j]);\n            newValues[newCount] = values[i] * values[j];\n            newExprs[newCount] = expr1;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr1);\n            if (found) return;\n        }\n    }\n}\n\nvoid permute(int pos, int used, int perm[]) {\n    if (found) return;\n    \n    if (pos == 4) {\n        int values[4];\n        char* exprs[4];\n        char exprBuf[4][10];\n        \n        for (int i = 0; i < 4; i++) {\n            values[i] = perm[i];\n            sprintf(exprBuf[i], \"%d\", perm[i]);\n            exprs[i] = exprBuf[i];\n        }\n        \n        generate(0, 4, 0, values, exprs, 0, \"\");\n        return;\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (!(used & (1 << i))) {\n            perm[pos] = nums[i];\n            permute(pos + 1, used | (1 << i), perm);\n            if (found) return;\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d %d\", &nums[0], &nums[1], &nums[2], &nums[3]);\n        \n        if (nums[0] == 0 && nums[1] == 0 && nums[2] == 0 && nums[3] == 0) {\n            break;\n        }\n        \n        found = 0;\n        result[0] = '\\0';\n        \n        int perm[4];\n        permute(0, 0, perm);\n        \n        if (found) {\n            printf(\"%s\\n\", result);\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  int found; void generate(int depth, int count, int used, int values[], char* exprs[], int value, char* expr) { if (found) return; if (count == 1) { if (value == 10) { strcpy(result, expr); found = 1; } return; } for   count; j++)  int newCount = 0; for (int k =  { if (k != i &&  = values[k];  } char expr1[1025], expr2[1025], expr3[1025]; //  values[i] + values[j]; newExprs[newCount] = expr1; generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr1); if  -  values[i] - values[j]; newExprs[newCount] = expr2; generate(depth + 1, newCount  newValues[newCount], expr2); if (found) return; // Subtraction (j - i) sprintf(expr3, \"(%s - %s)\", exprs[j], exprs[i]); newValues[newCount] = values[j] - values[i]; newExprs[newCount] = expr3; generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr3); if (found) return; // Multiplication sprintf(expr1, \"(%s * %s)\", exprs[i], exprs[j]); newValues[newCount] = values[i] * values[j]; newExprs[newCount] = expr1; generate(depth +  newValues, newExprs, newValues[newCount], expr1); if (found) return; } } } void permute(int pos, int used, int perm[]) { if (found) return; if (pos == 4) { int values[4]; char* exprs[4]; char exprBuf[4][10]; for (int i = 0; i < 4; i++) { values[i] = perm[i]; sprintf(exprBuf[i], \"%d\", perm[i]); exprs[i] = exprBuf[i]; }  0, \"\");  = 0; i < 4; i++) { if (!(used & (1 << i))) { perm[pos] = nums[i]; permute(pos + 1, used | (1 << i), perm); if (found) return; } } } int main() { while (1) { scanf(\"%d %d %d  if (nums[0] == 0 && nums[1]  0 && nums[3] == 0) { break; }  '\\0';  if (found) { printf(\"%s\\n\", result); } else { printf(\"0\\n\"); } } return 0; }"], "perturbed_original": ["d[4],e[9],f,k;char x[];z(){int b,c,a=e[f++];a>9?x[k++]=40,b=z(),x[k++]=a,c=z(),x[k++]=41,a=a-43?a-45?b*c:b-c:b+c:(x[k++]=a+48);return a;}y(o,n,i,j){if(i==7){f=k=0;if(z()==10){x[k]=0;puts(x);return 1;}return 0;}if(o)for(;j--;){e[i]=\"+-*\"[j];if(y(o-1,n+1,i+1,3))return 1;}if(n|i==6)for(j=4;j--;)if(e[i]=d[j]){d[j]=0;if(y(o,n-1,i+1,3))return 1;d[j]=e[i];}return 0;}main(){for(;scanf(\"%d%d%d%d\",d,d+1,d+2,d+3),f=*d;)y(3,0,0,3)||puts(\"0\");}"], "original_ll": -2.1893181800842285, "sampled_ll": -0.36061084270477295, "all_perturbed_sampled_ll": [-1.2330322265625], "all_perturbed_original_ll": [-2.1893181800842285], "perturbed_sampled_ll": -1.2330322265625, "perturbed_original_ll": -2.1893181800842285, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n  public static ArrayList<int[]> perm(int n){\n    int[] num = new int[n];\n    boolean[] flag = new boolean[n];\n    ArrayList<int[]> arrList = new ArrayList<int[]>();\n    permCalc(0,num,flag,arrList);\n    return arrList;\n  }\n\n  public static void permCalc(int rank, int[] num, boolean[] flag, ArrayList<int[]> arrList){\n    if (rank == num.length) {\n      arrList.add(num.clone());\n    }\n    else {\n      for (int i = 0; i < num.length; i++) {\n        if (!flag[i]) {\n          num[rank] = i;\n          flag[i] = true;\n          permCalc(rank+1,num,flag,arrList);\n          flag[i] = false;\n        }\n      }\n    }\n  }\n\n  public static int ope(int a, int b, int operand){\n    switch (operand) {\n      case 0:\n        return a+b;\n      case 1:\n        return a-b;\n      default:\n        return a*b;\n    }\n  }\n\n  public static String opeToStr(int operand){\n    switch (operand) {\n      case 0:\n        return \"+\";\n      case 1:\n        return \"-\";\n      default:\n        return \"*\";\n    }\n  }\n\n  public static String check(int[] num, int[] op){\n    int a = num[0];\n    int b = num[1];\n    int c = num[2];\n    int d = num[3];\n    if(ope(ope(ope(a,b,op[0]),c,op[1]),d,op[2]) == 10) {\n      return \"((\"+a+\" \"+opeToStr(op[0])+\" \"+b+\") \"+opeToStr(op[1])+\" \"+c+\") \"+opeToStr(op[2])+\" \"+d;\n    }\n    else if(ope(ope(a,b,op[0]),ope(c,d,op[2]),op[1]) == 10) {\n      return \"(\"+a+\" \"+opeToStr(op[0])+\" \"+b+\") \"+opeToStr(op[1])+\" (\"+c+\" \"+opeToStr(op[2])+\" \"+d+\")\";\n    }\n    else if(ope(ope(a,ope(b,c,op[1]),op[0]),d,op[2]) == 10) {\n      return \"(\"+a+\" \"+opeToStr(op[0])+\" (\"+b+\" \"+opeToStr(op[1])+\" \"+c+\")) \"+opeToStr(op[2])+\" \"+d;\n    }\n    else if(ope(a,ope(ope(b,c,op[1]),d,op[2]),op[0]) == 10) {\n      return a+\" \"+opeToStr(op[0])+\" ((\"+b+\" \"+opeToStr(op[1])+\" \"+c+\") \"+opeToStr(op[2])+\" \"+d+\")\";\n    }\n    else if(ope(a,ope(b,ope(c,d,op[2]),op[1]),op[0]) == 10) {\n      return a+\" \"+opeToStr(op[0])+\" (\"+b+\" \"+opeToStr(op[1])+\" (\"+c+\" \"+opeToStr(op[2])+\" \"+d+\"))\";\n    }\n    else {\n      return null;\n    }\n  }\n\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    ArrayList<int[]> arrList = perm(4);\n    int[][] operand = new int[27][];\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 3; j++) {\n        for (int k = 0; k < 3; k++) {\n          int[] temp = {i,j,k};\n          operand[9*i+3*j+k] = temp;\n        }\n      }\n    }\n    while(true) {\n      int[] num0 = new int[4];\n      for (int i = 0; i < 4; i++) {\n        num0[i] = sc.nextInt();\n      }\n      if (num0[0] == 0 && num0[1] == 0 && num0[2] == 0 && num0[3] == 0) {\n        break;\n      }\n      String chk = null;\n      search:\n      for (int i = 0; i < arrList.size(); i++) {\n        int[] num = {num0[arrList.get(i)[0]],num0[arrList.get(i)[1]],\n                     num0[arrList.get(i)[2]],num0[arrList.get(i)[3]]};\n        for (int j = 0; j < operand.length; j++) {\n          chk = check(num, operand[j]);\n          if (chk != null) {\n            break search;\n          }\n        }\n      }\n      if (chk == null) {\n        System.out.println(0);\n      }\n      else {\n        System.out.println(chk);\n      }\n    }\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Expr {\n        String str;\n        int val;\n        Expr(String s, int v) {\n            str = s;\n            val = v;\n        }\n    }\n    \n    static String result;\n    static boolean found;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int d = sc.nextInt();\n            \n            if (a == 0 && b == 0 && c == 0 && d == 0) break;\n            \n            int[] nums = {a, b, c, d};\n            result = null;\n            found = false;\n            \n            permute(nums, 0);\n            \n            if (result != null) {\n                System.out.println(result);\n            } else {\n                System.out.println(\"0\");\n            }\n        }\n    }\n    \n    static void permute(int[] nums, int start) {\n        if (found) return;\n        \n        if (start == nums.length) {\n            solve(nums);\n            return;\n        }\n        \n        for (int i = start; i < nums.length; i++) {\n            swap(nums, start, i);\n            permute(nums, start + 1);\n            swap(nums, start, i);\n            if (found) return;\n        }\n    }\n    \n    static void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    \n    static void solve(int[] nums) {\n        List<Expr> exprs = new ArrayList<>();\n        for (int num : nums) {\n            exprs.add(new Expr(String.valueOf(num), num));\n        }\n        \n        generate(exprs);\n    }\n    \n    static void generate(List<Expr> exprs) {\n        if (found) return;\n        \n        if (exprs.size() == 1) {\n            if (exprs.get(0).val == 10) {\n                result = exprs.get(0).str;\n                found = true;\n            }\n            return;\n        }\n        \n        for (int i = 0; i < exprs.size(); i++) {\n            for (int j = 0; j < exprs.size(); j++) {\n                if (i == j) continue;\n                \n                Expr e1 = exprs.get(i);\n                Expr e2 = exprs.get(j);\n                \n                char[] ops = {'+', '-', '*'};\n                \n                for (char op : ops) {\n                    int newVal = calc(e1.val, e2.val, op);\n                    String newStr = \"(\" + e1.str + \" \" + op + \" \" + e2.str + \")\";\n                    \n                    List<Expr> newExprs = new ArrayList<>();\n                    for (int k = 0; k < exprs.size(); k++) {\n                        if (k != i && k != j) {\n                            newExprs.add(exprs.get(k));\n                        }\n                    }\n                    newExprs.add(new Expr(newStr, newVal));\n                    \n                    generate(newExprs);\n                    if (found) return;\n                }\n            }\n        }\n    }\n    \n    static int calc(int a, int b, char op) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n        }\n        return 0;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Expr {  s,  } } static String result; static boolean  args) { Scanner sc = new Scanner(System.in); while (true)  int b = sc.nextInt(); int c = sc.nextInt(); int d = sc.nextInt(); if (a == 0 && b == 0 && c == 0 && d == 0) break;  null; found = false; permute(nums, 0); if (result != null) { System.out.println(result); } else { System.out.println(\"0\"); }  nums, int start) { if  } for (int i = start; i < nums.length; i++) { swap(nums,  1); swap(nums, start, i); if (found)  swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } static void solve(int[] nums) { List<Expr> exprs = new ArrayList<>(); for (int num : nums) { exprs.add(new Expr(String.valueOf(num), num)); } generate(exprs); } static void generate(List<Expr>  if (exprs.size() == 1) { if (exprs.get(0).val == 10) { result = exprs.get(0).str; found =  (int i  i++) { for (int j = 0; j < exprs.size(); j++) { if (i == j) continue; Expr e1 = exprs.get(i); Expr e2 = exprs.get(j); char[] ops = {'+', '-', '*'}; for (char  newVal = calc(e1.val, e2.val, op); String newStr = \"(\" + e1.str + \" \" + op + \" \"  0; k < exprs.size(); k++) { if (k != i && k != j) { newExprs.add(exprs.get(k)); } } newExprs.add(new Expr(newStr, newVal)); generate(newExprs); if (found) return; } }  a, int  (op) { case '+': return a + b; case '-': return a - b; case '*': return a * b; } return 0; } }"], "perturbed_original": ["import java.util.*; class Main{ public static  = new int[n]; boolean[] flag =  new ArrayList<int[]>(); permCalc(0,num,flag,arrList); return arrList; } public static void  flag, ArrayList<int[]> arrList){ if (rank == num.length) { arrList.add(num.clone()); } else { for (int i = 0; i < num.length; i++) { if (!flag[i]) { num[rank] = i; flag[i] =  } } } } public static int ope(int a, int b, int operand){ switch (operand) { case 0: return  } public static String opeToStr(int operand){ switch (operand) { case 0: return \"+\"; case 1: return \"-\"; default: return \"*\";  check(int[] num, int[] op){ int a = num[0]; int b =  return \"((\"+a+\" \"+opeToStr(op[0])+\" \"+b+\") \"+opeToStr(op[1])+\" \"+c+\") \"+opeToStr(op[2])+\" \"+d; } else if(ope(ope(a,b,op[0]),ope(c,d,op[2]),op[1])   \"+d+\")\"; } else if(ope(ope(a,ope(b,c,op[1]),op[0]),d,op[2]) ==  (\"+b+\"   return a+\" \"+opeToStr(op[0])+\" ((\"+b+\" \"+opeToStr(op[1])+\"  if(ope(a,ope(b,ope(c,d,op[2]),op[1]),op[0]) == 10) { return a+\" \"+opeToStr(op[0])+\" (\"+b+\" \"+opeToStr(op[1])+\" (\"+c+\" \"+opeToStr(op[2])+\" \"+d+\"))\"; } else { return null; } } public static void main(String[] args){ Scanner sc = new Scanner(System.in); ArrayList<int[]> arrList = perm(4); int[][] operand = new int[27][]; for (int i = 0;  for (int j = 0; j < 3; j++) { for (int k = 0; k < 3; k++) { int[] temp = {i,j,k}; operand[9*i+3*j+k] = temp; } } } while(true) {  for (int i = 0; i <  sc.nextInt(); } if (num0[0] == 0 &&  == 0)  = null; search: for (int i = 0; i < arrList.size(); i++) { int[] num = {num0[arrList.get(i)[0]],num0[arrList.get(i)[1]], num0[arrList.get(i)[2]],num0[arrList.get(i)[3]]}; for (int j = 0; j < operand.length; j++) { chk = check(num, operand[j]); if (chk != null) { break search; } } } if (chk == null) { System.out.println(0); } else { System.out.println(chk); } } } }"], "original_ll": -0.4100996255874634, "sampled_ll": -0.2919251620769501, "all_perturbed_sampled_ll": [-1.3067854642868042], "all_perturbed_original_ll": [-1.2769206762313843], "perturbed_sampled_ll": -1.3067854642868042, "perturbed_original_ll": -1.2769206762313843, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import *\ndef f(s):\n if sum(s)==10:return\"((({} + {}) + {}) + {})\".format(*s)\n for a,b,c,d in permutations(s):\n  for x,y,z in permutations('+-**',3):\n   for t in[f\"({a} {x} {b}) {y} ({c} {z} {d})\",f\"(({a} {x} {b}) {y} {c}) {z} {d}\",f\"({a} {x} ({b} {y} {c})) {z} {d}\"]:\n    if eval(t)==10:return'('+t+')'\n else:return 0\nfor e in iter(input,'0 0 0 0'):print(f(list(map(int,e.split()))))\n", "sampled": "from itertools import permutations, product\n\ndef evaluate(expr):\n    try:\n        return eval(expr)\n    except:\n        return None\n\ndef generate_expressions(nums):\n    operators = ['+', '-', '*']\n    \n    # Template patterns for 4 numbers with different parenthesizations\n    patterns = [\n        # No parentheses\n        \"{} {} {} {} {} {} {}\",\n        # One pair of parentheses\n        \"({} {} {}) {} {} {} {}\",\n        \"{} {} ({} {} {}) {} {}\",\n        \"{} {} {} {} ({} {} {})\",\n        # Two pairs of parentheses\n        \"({} {} {}) {} ({} {} {})\",\n        \"(({} {} {}) {} {}) {} {}\",\n        \"{} {} (({} {} {}) {} {})\",\n        \"({} {} ({} {} {})) {} {}\",\n        \"{} {} ({} {} ({} {} {}))\",\n        # Three pairs of parentheses\n        \"(({} {} {}) {} ({} {} {}))\",\n        \"((({} {} {}) {} {}) {} {})\",\n        \"({} {} (({} {} {}) {} {}))\",\n        \"({} {} ({} {} ({} {} {})))\",\n        \"{} {} ((({} {} {}) {} {}))\",\n        \"{} {} (({} {} ({} {} {})))\",\n        \"{} {} ({} {} (({} {} {})))\",\n        # More complex patterns\n        \"((({} {} {}) {} ({} {} {})))\",\n        \"(({} {} ({} {} {})) {} {})\",\n        \"({} {} (({} {} ({} {} {}))))\",\n        \"(({} {} {}) {} (({} {} {})))\",\n        \"((({} {} ({} {} {}))) {} {})\",\n        \"{} {} (((({} {} {})) {} {}))\",\n    ]\n    \n    for perm in permutations(nums):\n        for ops in product(operators, repeat=3):\n            for pattern in patterns:\n                try:\n                    # Interleave numbers and operators\n                    elements = []\n                    num_idx = 0\n                    op_idx = 0\n                    for char in pattern:\n                        if char == '{}':\n                            if num_idx < 4:\n                                elements.append(str(perm[num_idx]))\n                                num_idx += 1\n                            elif op_idx < 3:\n                                elements.append(ops[op_idx])\n                                op_idx += 1\n                    \n                    if num_idx == 4 and op_idx == 3:\n                        expr = pattern.format(perm[0], ops[0], perm[1], ops[1], perm[2], ops[2], perm[3])\n                        result = evaluate(expr)\n                        if result == 10:\n                            return expr\n                except:\n                    continue\n    \n    return None\n\ndef solve():\n    results = []\n    while True:\n        line = input().split()\n        nums = [int(x) for x in line]\n        \n        if nums == [0, 0, 0, 0]:\n            break\n        \n        expr = generate_expressions(nums)\n        if expr:\n            results.append(expr)\n        else:\n            results.append(\"0\")\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "perturbed_sampled": ["from itertools import permutations, product def evaluate(expr): try: return eval(expr) except: return None def generate_expressions(nums): operators = ['+', '-', '*'] # Template patterns for 4 numbers with different parenthesizations patterns = [ # No parentheses \"{} {} {} {}  pair of parentheses \"({} {}  \"{} {} ({} {} {}) {} {}\", \"{} {} {} {} ({} {} {})\", # Two pairs of  ({} {} {})\", \"(({} {} {}) {} {}) {} {}\", \"{} {} (({} {} {}) {} {})\", \"({} {} ({} {} {}))  {} ({} {} {}))\", # Three pairs of parentheses \"(({} {} {}) {} ({} {} {}))\", \"((({} {} {}) {} {}) {} {})\", \"({} {} (({} {} {}) {} {}))\", \"({}  {})))\", \"{} {} ((({} {} {}) {} {}))\", \"{} {} (({} {} ({} {} {})))\", \"{} {} ({} {} (({}  patterns  {}  {})) {} {})\", \"({} {} (({} {} ({} {} {}))))\", \"(({} {} {}) {} (({} {} {})))\", \"((({} {} ({} {} {}))) {}  {})) {} {}))\", ] for perm in permutations(nums): for  pattern in  and operators elements = []  pattern: if char == '{}': if num_idx < 4: elements.append(str(perm[num_idx])) num_idx += 1 elif op_idx < 3: elements.append(ops[op_idx]) op_idx  3: expr = pattern.format(perm[0], ops[0], perm[1], ops[1], perm[2], ops[2], perm[3]) result = evaluate(expr) if result == 10: return expr except:  True: line = input().split() nums = [int(x) for x  [0, 0, 0, 0]: break expr =  results.append(\"0\") for result in results: print(result) solve()"], "perturbed_original": ["from itertools import *  {}) + {}) + {})\".format(*s) for a,b,c,d in permutations(s): for x,y,z in permutations('+-**',3): for t  {z} {d})\",f\"(({a} {x} {b}) {y} {c}) {z} {d}\",f\"({a} {x} ({b} {y} {c})) {z}  for e in iter(input,'0 0 0 0'):print(f(list(map(int,e.split()))))"], "original_ll": -1.437110424041748, "sampled_ll": -0.7116956114768982, "all_perturbed_sampled_ll": [-1.9092235565185547], "all_perturbed_original_ll": [-2.6142313480377197], "perturbed_sampled_ll": -1.9092235565185547, "perturbed_original_ll": -2.6142313480377197, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void)\n{\n  int i,j;\n  int prime[70000];\n  int n;\n  for(i=0;i<60000;i++){\n    prime[i] = 1;\n  }\n  prime[0]=0;\n  scanf(\"%d\",&n);\n\n  for(i=1;i*i<=60000;i++){\n    if(prime[i]==1){\n      for(j=i+1;(i+1)*j<=60000;j++){\n\tprime[(i+1)*j-1]=0;\n      }\n    }\n  }\n\n  for(i=n-2;0<=i;i--){\n    if(prime[i]==1){\n      printf(\"%d \",i+1); break;\n    }\n  }\n\n  for(i=n;i<60000;i++){\n    if(prime[i]==1){\n      printf(\"%d\",i+1); break;\n    }\n  }\n  putchar('\\n');\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    \n    int sqrt_num = (int)sqrt(num);\n    for (int i = 3; i <= sqrt_num; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) != EOF) {\n        int smaller = n - 1;\n        int larger = n + 1;\n        \n        while (smaller >= 2 && !is_prime(smaller)) {\n            smaller--;\n        }\n        \n        while (!is_prime(larger)) {\n            larger++;\n        }\n        \n        printf(\"%d %d\\n\", smaller, larger);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" <math.h> bool is_prime(int num) {  2) return true; if (num % 2 == 0) return false; int sqrt_num = (int)sqrt(num); for (int i = 3; i <= sqrt_num; i += 2) { if (num % i == 0) return false;  main() { int n; while (scanf(\"%d\", &n) != EOF) { int smaller = n  n  2 && !is_prime(smaller)) { smaller--; } while (!is_prime(larger)) { larger++; } printf(\"%d %d\\n\", smaller, larger); } return 0; }"], "perturbed_original": ["#include<stdio.h> int  prime[70000]; int n; for(i=0;i<60000;i++){ prime[i]  for(i=1;i*i<=60000;i++){ if(prime[i]==1){ for(j=i+1;(i+1)*j<=60000;j++){ prime[(i+1)*j-1]=0; } } } for(i=n-2;0<=i;i--){ if(prime[i]==1){ printf(\"%d \",i+1); break; } } for(i=n;i<60000;i++){ if(prime[i]==1){ printf(\"%d\",i+1); break; } } putchar('\\n'); return 0; }"], "original_ll": -0.9172674417495728, "sampled_ll": -0.40369555354118347, "all_perturbed_sampled_ll": [-1.241715669631958], "all_perturbed_original_ll": [-1.222064733505249], "perturbed_sampled_ll": -1.241715669631958, "perturbed_original_ll": -1.222064733505249, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tfor(int i=n-1;i>=2;i--){\n\t\t\t\tboolean flag=true;\n\t\t\t\tfor(int j=2;j<Math.sqrt(i)+1;j++){\n\t\t\t\t\tif(i%j==0){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tSystem.out.print(i+\" \");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=n+1;i<50000;i++){\n\t\t\t\tboolean flag=true;\n\t\t\t\tfor(int j=2;j<Math.sqrt(i)+1;j++){\n\t\t\t\t\tif(i%j==0){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static boolean[] isPrime;\n    static final int MAX = 100001;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Sieve of Eratosthenes\n        isPrime = new boolean[MAX];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i < MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < MAX; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            \n            int smaller = 0;\n            for (int i = n - 1; i >= 2; i--) {\n                if (isPrime[i]) {\n                    smaller = i;\n                    break;\n                }\n            }\n            \n            int larger = 0;\n            for (int i = n + 1; i < MAX; i++) {\n                if (isPrime[i]) {\n                    larger = i;\n                    break;\n                }\n            }\n            \n            System.out.println(smaller + \" \" + larger);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { static boolean[] isPrime; static final int MAX = 100001; public static void main(String[] args)  Scanner(System.in); // Sieve of Eratosthenes isPrime = new boolean[MAX]; Arrays.fill(isPrime, true); isPrime[0] = isPrime[1] = false; for (int i = 2; i  for (int j = i * i; j < MAX; j += i) { isPrime[j] = false; } } } while (sc.hasNext()) { int n = sc.nextInt(); int smaller = 0; for (int i = n - 1; i >= 2; i--) { if (isPrime[i]) { smaller = i; break;  0; for (int i = n + 1; i  (isPrime[i]) { larger = i; break; } }  }"], "perturbed_original": ["import java.util.Scanner; public class  main(String[] args){ Scanner sc=new Scanner(System.in); while(sc.hasNext()){ int n=sc.nextInt(); for(int i=n-1;i>=2;i--){ boolean flag=true; for(int j=2;j<Math.sqrt(i)+1;j++){ if(i%j==0){ flag=false; break; } } if(flag){ System.out.print(i+\" \"); break; } } for(int  if(i%j==0){ flag=false; break; } } if(flag){  } }"], "original_ll": -0.4319078028202057, "sampled_ll": -0.3011228144168854, "all_perturbed_sampled_ll": [-1.0753475427627563], "all_perturbed_original_ll": [-1.2677960395812988], "perturbed_sampled_ll": -1.0753475427627563, "perturbed_original_ll": -1.2677960395812988, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\nr = 50000\nsqrt = int(math.sqrt(r))\np = [1]*r\np[0] = 0\nfor i in range(1,sqrt):\n    if p[i]:\n        for j in range(2*i+1,r,i+1):\n            p[j] = 0\n            \nwhile True:\n    try:\n        n = int(raw_input())\n        for i in range(n,50000):\n            if p[i] == 1:\n                lp = i+1\n                break\n        for i in range(n-2,0,-1):\n            if p[i] == 1:\n                sp = i+1\n                break\n        print sp, lp\n    except:\n        break", "sampled": "import sys\n\ndef sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\n# Precompute primes up to a reasonable limit\nMAX_LIMIT = 100000\nis_prime = sieve_of_eratosthenes(MAX_LIMIT)\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    \n    # Find largest prime less than n\n    smaller = n - 1\n    while smaller > 1 and not is_prime[smaller]:\n        smaller -= 1\n    \n    # Find smallest prime greater than n\n    larger = n + 1\n    while larger <= MAX_LIMIT and not is_prime[larger]:\n        larger += 1\n    \n    print(smaller, larger)\n", "perturbed_sampled": ["import sys def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0]  for j in range(i*i, limit +  return is_prime # Precompute primes  MAX_LIMIT = 100000 is_prime = sieve_of_eratosthenes(MAX_LIMIT) for line in sys.stdin: n = int(line.strip()) # Find largest prime less than n  while smaller > 1 and not is_prime[smaller]: smaller -= 1 # Find smallest prime greater than n larger = n + 1 while larger <= MAX_LIMIT and not is_prime[larger]: larger += 1 print(smaller, larger)"], "perturbed_original": ["import math  p[0] = 0 for i in range(1,sqrt): if p[i]: for j in range(2*i+1,r,i+1): p[j] = 0 while True: try: n = int(raw_input()) for i in range(n,50000): if p[i] ==  for i in range(n-2,0,-1): if p[i] == 1: sp = i+1 break print sp, lp except: break"], "original_ll": -1.0689048767089844, "sampled_ll": -0.4871263802051544, "all_perturbed_sampled_ll": [-1.4587446451187134], "all_perturbed_original_ll": [-1.9680743217468262], "perturbed_sampled_ll": -1.4587446451187134, "perturbed_original_ll": -1.9680743217468262, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(int argc, char *argv[]){\n  int prise,num;\n  long long int sum = 0;\n  int num_sum = 0;\n  int times = 0;\n  \n  while(scanf(\"%d,%d\",&prise,&num) != EOF){\n    sum += (long long int)(prise)*(long long int)(num);\n    num_sum += num;\n    ++times;\n  }\n\n  printf(\"%lld\\n%.0lf\\n\",sum,(double)(num_sum)/times);\n  \n  return 0;    \n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int price, quantity;\n    int total_sales = 0;\n    int total_quantity = 0;\n    int count = 0;\n    \n    while (scanf(\"%d,%d\", &price, &quantity) == 2) {\n        total_sales += price * quantity;\n        total_quantity += quantity;\n        count++;\n    }\n    \n    int average = (total_quantity + count / 2) / count;\n    \n    printf(\"%d\\n\", total_sales);\n    printf(\"%d\\n\", average);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  = 0; int total_quantity = 0; int count = 0; while (scanf(\"%d,%d\", &price, &quantity) == 2) { total_sales += price * quantity; total_quantity += quantity; count++; } int average = (total_quantity +  printf(\"%d\\n\", total_sales); printf(\"%d\\n\", average); return 0; }"], "perturbed_original": ["#include <stdio.h> int main(int argc, char *argv[]){ int prise,num; long long int  = 0; int times = 0; while(scanf(\"%d,%d\",&prise,&num) != EOF){ sum += (long  += num; ++times; } printf(\"%lld\\n%.0lf\\n\",sum,(double)(num_sum)/times); return 0; }"], "original_ll": -1.3890281915664673, "sampled_ll": -0.8700714111328125, "all_perturbed_sampled_ll": [-1.5982156991958618], "all_perturbed_original_ll": [-2.3624825477600098], "perturbed_sampled_ll": -1.5982156991958618, "perturbed_original_ll": -2.3624825477600098, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tint count = 0;\n\t\tint sum = 0;\n\t\tint sum2 = 0;\n\t\twhile(stdIn.hasNext()) {\n\t\t\tcount++;\n\t\t\tString[] in = stdIn.next().split(\",\");\n\t\t\tint a = Integer.parseInt(in[0]);\n\t\t\tint b = Integer.parseInt(in[1]);\n\t\t\tsum += a*b;\n\t\t\tsum2 += b;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\tdouble ave = sum2/(double)count*10;\n\t\tif(ave%10 >= 5) {\n\t\t\tave += 10-ave%10;\n\t\t}\n\t\telse {\n\t\t\tave -= (ave*10)%10;\n\t\t}\n\t\tave /=10;\n\t\t\n\t\tSystem.out.println((int)ave);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int totalAmount = 0;\n        int totalQuantity = 0;\n        int count = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            int price = Integer.parseInt(parts[0]);\n            int quantity = Integer.parseInt(parts[1]);\n            \n            totalAmount += price * quantity;\n            totalQuantity += quantity;\n            count++;\n        }\n        \n        int averageQuantity = (int) Math.round((double) totalQuantity / count);\n        \n        System.out.println(totalAmount);\n        System.out.println(averageQuantity);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main {  = 0; int totalQuantity = 0; int count = 0; while (sc.hasNextLine()) { String line = sc.nextLine(); if (line.isEmpty()) break; String[] parts = line.split(\",\"); int price = Integer.parseInt(parts[0]); int quantity =  quantity; totalQuantity += quantity; count++; } int averageQuantity = (int) Math.round((double) totalQuantity / count); System.out.println(totalAmount); System.out.println(averageQuantity); sc.close(); } }"], "perturbed_original": ["import java.io.*; import java.util.ArrayList; import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner stdIn = new Scanner(System.in); int  = 0; int sum2 = 0; while(stdIn.hasNext()) {  int a = Integer.parseInt(in[0]); int b = Integer.parseInt(in[1]); sum += a*b; sum2 +=   { ave += 10-ave%10; } else { ave -= (ave*10)%10; } ave /=10; System.out.println((int)ave); } }"], "original_ll": -0.8736165761947632, "sampled_ll": -0.4954199492931366, "all_perturbed_sampled_ll": [-1.368523359298706], "all_perturbed_original_ll": [-1.705985426902771], "perturbed_sampled_ll": -1.368523359298706, "perturbed_original_ll": -1.705985426902771, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# _*_ coding: utf-8 _*_\n\nsum = 0\ntotal = 0\ncnt = 0\n\nwhile True:\n\ts = input()\n\t\n\tif s == '':\n\t\tbreak\n\t\n\tlist = s.split(',')\n\tsum += int(list[0])*int(list[1])\n\ttotal += int(list[1])\n\tcnt += 1\n\nave = total / cnt + 0.5\n\nprint(sum)\nprint(int(ave))", "sampled": "import sys\n\ntotal_amount = 0\ntotal_quantity = 0\ncount = 0\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        price, quantity = map(int, line.split(','))\n        total_amount += price * quantity\n        total_quantity += quantity\n        count += 1\n\naverage_quantity = round(total_quantity / count)\n\nprint(total_amount)\nprint(average_quantity)\n", "perturbed_sampled": ["import sys total_amount = 0 total_quantity = 0 count = 0  = line.strip() if line: price, quantity = map(int, line.split(','))  total_quantity += quantity count += 1 average_quantity = round(total_quantity / count) print(total_amount) print(average_quantity)"], "perturbed_original": ["# _*_ coding: utf-8 _*_ sum = 0 total = 0 cnt = 0 while True: s = input() if s == '': break list = s.split(',') sum += int(list[0])*int(list[1]) total += int(list[1]) cnt +=  print(int(ave))"], "original_ll": -1.4167370796203613, "sampled_ll": -0.9002493619918823, "all_perturbed_sampled_ll": [-2.156952381134033], "all_perturbed_original_ll": [-1.7554751634597778], "perturbed_sampled_ll": -2.156952381134033, "perturbed_original_ll": -1.7554751634597778, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void) {\n    double i,max,min;\n    scanf(\"%lf\",&max);\n    min=max;\n    while(1) {\n        if(scanf(\"%lf\",&i) == -0){\n            break;\n        }\n        if(i < min){\n            min = i;\n        }\n        if(i > max){\n            max = i;\n        }\n    }\n    printf(\"%f\\n\",max-min);\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double height;\n    double max = -1;\n    double min = 1000001;\n    \n    while (scanf(\"%lf\", &height) == 1) {\n        if (height > max) {\n            max = height;\n        }\n        if (height < min) {\n            min = height;\n        }\n    }\n    \n    printf(\"%.1f\\n\", max - min);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  double max = -1; double min = 1000001; while  if (height > max) { max = height; } if (height < min) { min = height; } } printf(\"%.1f\\n\", max - min); return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { double i,max,min; scanf(\"%lf\",&max); min=max;  break; } if(i < min){  > max){ max = i; } } printf(\"%f\\n\",max-min); return 0; }"], "original_ll": -1.0607976913452148, "sampled_ll": -0.7518323063850403, "all_perturbed_sampled_ll": [-1.7282830476760864], "all_perturbed_original_ll": [-2.5153448581695557], "perturbed_sampled_ll": -1.7282830476760864, "perturbed_original_ll": -2.5153448581695557, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tdouble height = Double.MIN_VALUE,min = Double.MAX_VALUE;\n\t\twhile(scan.hasNext()) {\n\t\t\tdouble mount = scan.nextDouble();\n\t\t\tif(height < mount) {\n\t\t\t\theight = mount;\n\t\t\t}\n\t\t\tif(min > mount) {\n\t\t\t\tmin = mount;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(height - min);\n\t\tscan.close();\n\t}\n}\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        double max = Double.MIN_VALUE;\n        double min = Double.MAX_VALUE;\n        \n        while (sc.hasNextDouble()) {\n            double height = sc.nextDouble();\n            if (height > max) {\n                max = height;\n            }\n            if (height < min) {\n                min = height;\n            }\n        }\n        \n        double diff = max - min;\n        System.out.println(diff);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static = double.Parse(sc.currentByte().toString());<extra_id_2>;<extra_id_3>) {<extra_id_4>; float<extra_id_5>=<extra_id_6>Double .<extra_id_7>.<extra_id_8>{ return<extra_id_9>double<extra_id_10>System .<extra_id_11>.<extra_id_12>= Math . Ln<extra_id_13>i = 0 ; i<extra_id_14>]<extra_id_15>public<extra_id_16>\" \"<extra_id_17>)<extra_id_18>1<extra_id_19>\"<extra_id_20>=<extra_id_21>; i <<extra_id_22>{<extra_id_23>= \" \" ;<extra_id_24>return<extra_id_25>; } double max = Double.MIN_VALUE; double min = Double.MAX_VALUE; while (sc.hasNextDouble()) { double  > max) { max = height; } if (height < min) { min = height; } } double diff = max - min; System.out.println(diff); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class  main(String[] args) { Scanner scan =  Double.MIN_VALUE,min = Double.MAX_VALUE; while(scan.hasNext()) { double mount = scan.nextDouble(); if(height < mount) { height  mount) { min = mount; } } System.out.println(height - min); scan.close(); } }"], "original_ll": -0.8427823781967163, "sampled_ll": -0.5806533098220825, "all_perturbed_sampled_ll": [-2.013643264770508], "all_perturbed_original_ll": [-2.4836244583129883], "perturbed_sampled_ll": -2.013643264770508, "perturbed_original_ll": -2.4836244583129883, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "fir=0\nsec=0\n\nwhile True:\n        try:\n                a=raw_input()\n                if a >= fir:\n                        sec = fir\n                        fir = a\n                elif a >= sec:\n                        sec = a\n        except EOFError:\n                break\n\nprint fir-sec", "sampled": "import sys\n\nheights = []\nfor line in sys.stdin:\n    heights.append(float(line.strip()))\n\nprint(max(heights) - min(heights))\n", "perturbed_sampled": ["import sys heights = [] for line in sys.stdin: heights.append(float(line.strip())) print(max(heights) - min(heights))"], "perturbed_original": ["fir=0 sec=0 while True: try: a=raw_input() if a >=  = a elif a >= sec: sec = a except EOFError: break print fir-sec"], "original_ll": -1.22775399684906, "sampled_ll": -1.7717134952545166, "all_perturbed_sampled_ll": [-2.161045551300049], "all_perturbed_original_ll": [-3.0226354598999023], "perturbed_sampled_ll": -2.161045551300049, "perturbed_original_ll": -3.0226354598999023, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\tint ball[3];\n\tint x,y,temp;\n\tchar a,b;\n\tball[0]=1;ball[1]=0;ball[2]=0;\n\twhile(scanf(\"%c,%c\",&a,&b)!=EOF){\n\t\tswitch(a){\n\t\tcase 'A':x=0;break;\n\t\tcase 'B':x=1;break;\n\t\tcase 'C':x=2;break;\n\t\t}\n\t\tswitch(b){\n\t\tcase 'A':y=0;break;\n\t\tcase 'B':y=1;break;\n\t\tcase 'C':y=2;break;\n\t\t}\n\t\ttemp=ball[x];ball[x]=ball[y];ball[y]=temp;\n\t}\n\tif(ball[0]==1){\n\t\tprintf(\"A\\n\");\n\t}else if(ball[1]==1){\n\t\tprintf(\"B\\n\");\n\t}else{printf(\"C\\n\");}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    char ball = 'A';\n    char line[10];\n    \n    while (fgets(line, sizeof(line), stdin) != NULL) {\n        char pos1 = line[0];\n        char pos2 = line[2];\n        \n        if (ball == pos1) {\n            ball = pos2;\n        } else if (ball == pos2) {\n            ball = pos1;\n        }\n    }\n    \n    printf(\"%c\\n\", ball);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  line[10]; while (fgets(line, sizeof(line), stdin) != NULL) { char pos1 = line[0]; char  == pos1) { ball = pos2; } else if (ball == pos2) { ball = pos1; } } printf(\"%c\\n\", ball); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int ball[3]; int x,y,temp; char a,b; ball[0]=1;ball[1]=0;ball[2]=0; while(scanf(\"%c,%c\",&a,&b)!=EOF){ switch(a){ case 'A':x=0;break; case 'B':x=1;break; case 'C':x=2;break; } switch(b){ case 'A':y=0;break; case 'B':y=1;break; case <extra_id_6>printf(\"C\\n\");<extra_id_7>} }<extra_id_8>%c\\n\",EOF); break; } temp= printf(\"A\\n\");  0; }"], "original_ll": -0.7205878496170044, "sampled_ll": -0.9060739874839783, "all_perturbed_sampled_ll": [-1.7445048093795776], "all_perturbed_original_ll": [-2.0368268489837646], "perturbed_sampled_ll": -1.7445048093795776, "perturbed_original_ll": -2.0368268489837646, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s;\n\t\tString[] t;\n\t\tint[] location=new int[3];\n\t\tlocation[0]=1;\n\t\tlocation[1]=0;\n\t\tlocation[2]=0;\n\t\tint alt;\n\t\tint[] number=new int[2];\n\t\twhile((s=reader.readLine())!=null){\n\t\t\tif(s.isEmpty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(s==\"\"){break;}\n\t\t\tt=s.split(\",\");\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tif(t[i]==\"A\"){number[i]=0;}\n\t\t\t\t\telse if(t[i]==\"B\"){number[i]=1;}\n\t\t\t\t\telse if(t[i]==\"C\"){number[i]=2;}\t\n\t\t\t}\n\t\t\talt=location[number[0]];\n\t\t\tlocation[number[0]]=location[number[1]];\n\t\t\tlocation[number[1]]=alt;\n\t\t}\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tif(location[j]==1){\n\t\t\t\t\tswitch(j){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tSystem.out.println(\"A\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tSystem.out.println(\"B\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tSystem.out.println(\"C\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        char ball = 'A';\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] positions = line.split(\",\");\n            char pos1 = positions[0].charAt(0);\n            char pos2 = positions[1].charAt(0);\n            \n            if (ball == pos1) {\n                ball = pos2;\n            } else if (ball == pos2) {\n                ball = pos1;\n            }\n        }\n        \n        System.out.println(ball);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) {  while (sc.hasNextLine()) { String line = sc.nextLine().trim(); if  line.split(\",\"); char pos1 = positions[0].charAt(0); char pos2 = positions[1].charAt(0); if (ball == pos1) { ball = pos2;  pos2) { ball = pos1; } } System.out.println(ball); sc.close(); } }"], "perturbed_original": ["import java.io.*; public class Main{ public static void main(String[]  InputStreamReader(System.in)); String s; String[] t; int[] location=new int[3]; location[0]=1; location[1]=0; location[2]=0; int alt; int[] number=new  if(t[i]==\"A\"){number[i]=0;} else if(t[i]==\"B\"){number[i]=1;} else if(t[i]==\"C\"){number[i]=2;} } alt=location[number[0]]; location[number[0]]=location[number[1]]; location[number[1]]=alt; } for(int j=0;j<3;j++){ if(location[j]==1){ switch(j){ case 0: System.out.println(\"A\"); break; case  System.out.println(\"C\"); break; } } } } }"], "original_ll": -0.7438599467277527, "sampled_ll": -0.6557935476303101, "all_perturbed_sampled_ll": [-1.8905447721481323], "all_perturbed_original_ll": [-1.5266965627670288], "perturbed_sampled_ll": -1.8905447721481323, "perturbed_original_ll": -1.5266965627670288, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nimport itertools\n\nA = [1, 0, 0]\n\nfor s in sys.stdin:\n    s = s.strip()\n    a, b = s.split(',')\n\n    if a == 'A':\n        i = 0\n    elif a == 'B':\n        i = 1\n    elif a == 'C':\n        i = 2\n\n    if b == 'A':\n        j = 0\n    elif b == 'B':\n        j = 1\n    elif b == 'C':\n        j = 2\n\n    A[i], A[j] = A[j], A[i]\n\nif A[0] == 1:\n    print('A')\nelif A[1] == 1:\n    print('B')\nelse:\n    print('C')", "sampled": "import sys\n\nball_position = 'A'\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    pos1, pos2 = line.split(',')\n    \n    if ball_position == pos1:\n        ball_position = pos2\n    elif ball_position == pos2:\n        ball_position = pos1\n\nprint(ball_position)\n", "perturbed_sampled": ["import sys ball_position = 'A' for line in sys.stdin: line = line.strip() if not line: continue pos1, pos2  pos1:  == pos2: ball_position = pos1 print(ball_position)"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys import os import math import itertools A = [1, 0, 0] for s in sys.stdin: s = s.strip() a, b = s.split(',') if  0 elif  1 elif a == 'C': i = 2 if  0 elif b == 'B': j = 1 elif  A[j], A[i] if A[0] == 1: print('A') elif A[1] == 1: print('B') else: print('C')"], "original_ll": -0.6421764492988586, "sampled_ll": -1.114303469657898, "all_perturbed_sampled_ll": [-2.7427382469177246], "all_perturbed_original_ll": [-1.8068641424179077], "perturbed_sampled_ll": -2.7427382469177246, "perturbed_original_ll": -1.8068641424179077, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tfloat g;\n\t\n\tscanf(\"%f\", &g);\n\t\n\tif (g <= 48.00){\n\t\tprintf(\"light fly\\n\");\n\t}\n\telse if ((48.00 < g)&&(g <= 51.00)){\n\t\tprintf(\"fly\\n\");\n\t}\n\telse if ((51.00 < g)&&(g <= 54.00)){\n\t\tprintf(\"bantam\\n\");\n\t}\n\telse if ((54.00 < g)&&(g <= 57.00)){\n\t\tprintf(\"feather\\n\");\n\t}\n\telse if ((57.00 < g)&&(g <= 60.00)){\n\t\tprintf(\"light\\n\");\n\t}\n\telse if ((60.00 < g)&&(g <= 64.00)){\n\t\tprintf(\"light welter\\n\");\n\t}\n\telse if ((64.00 < g)&&(g <= 69.00)){\n\t\tprintf(\"welter\\n\");\n\t}\n\telse if ((69.00 < g)&&(g <= 75.00)){\n\t\tprintf(\"light middle\\n\");\n\t}\n\telse if ((75.00 < g)&&(g <= 81.00)){\n\t\tprintf(\"middle\\n\");\n\t}\n\telse if ((81.00 < g)&&(g <= 91.00)){\n\t\tprintf(\"light heavy\\n\");\n\t}\n\telse if (91.00 < g){\n\t\tprintf(\"heavy\\n\");\n\t}\n\t\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double w;\n    \n    while (scanf(\"%lf\", &w) != EOF) {\n        if (w <= 48.00) {\n            printf(\"light fly\\n\");\n        } else if (w <= 51.00) {\n            printf(\"fly\\n\");\n        } else if (w <= 54.00) {\n            printf(\"bantam\\n\");\n        } else if (w <= 57.00) {\n            printf(\"feather\\n\");\n        } else if (w <= 60.00) {\n            printf(\"light\\n\");\n        } else if (w <= 64.00) {\n            printf(\"light welter\\n\");\n        } else if (w <= 69.00) {\n            printf(\"welter\\n\");\n        } else if (w <= 75.00) {\n            printf(\"light middle\\n\");\n        } else if (w <= 81.00) {\n            printf(\"middle\\n\");\n        } else if (w <= 91.00) {\n            printf(\"light heavy\\n\");\n        } else {\n            printf(\"heavy\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double  EOF) {  printf(\"light fly\\n\"); } else if (w <= 51.00) { printf(\"fly\\n\"); } else if (w <= 54.00) { printf(\"bantam\\n\"); } else if (w <= 57.00) { printf(\"feather\\n\"); } else if (w  else if (w  } else if (w <= 69.00) { printf(\"welter\\n\"); } else if (w <= 75.00) { printf(\"light middle\\n\"); } else if (w <= 81.00) { printf(\"middle\\n\"); } else if  printf(\"heavy\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { float g; scanf(\"%f\", &g); if (g <= 48.00){ printf(\"light fly\\n\"); } else if ((48.00 < g)&&(g <= 51.00)){ printf(\"fly\\n\"); } else if ((51.00 < g)&&(g  if ((54.00 <  else if ((57.00 < g)&&(g <= 60.00)){ printf(\"light\\n\"); } else if ((60.00 < g)&&(g <= 64.00)){ printf(\"light welter\\n\"); } else if ((64.00 < g)&&(g <= 69.00)){  printf(\"light middle\\n\");  g)&&(g <= 81.00)){ printf(\"middle\\n\"); } else if ((81.00 < g)&&(g <= 91.00)){ printf(\"light heavy\\n\");  g){ printf(\"heavy\\n\"); } return (0); }"], "original_ll": -0.4703882932662964, "sampled_ll": -0.47650888562202454, "all_perturbed_sampled_ll": [-1.3389017581939697], "all_perturbed_original_ll": [-1.1295603513717651], "perturbed_sampled_ll": -1.3389017581939697, "perturbed_original_ll": -1.1295603513717651, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str;\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\twhile((str=br.readLine())!=null){\n\t\t\tlist.add(check(Double.parseDouble(str)));\n\t\t}\n\t\tfor(String d : list){\n\t\t\tSystem.out.println(d);\n\t\t}\n\t\t\n\t}\n\tpublic static String check(double weight){\n\t\tif(weight > 91.0){\n            return \"heavy\";\n        }\n        else if(weight > 81.0){\n            return \"light heavy\";\n        }\n        else if(weight > 75.0){\n            return \"middle\";\n        }\n        else if(weight > 69.0){\n            return \"light middle\";\n        }\n        else if(weight > 64.0){\n            return \"welter\";\n        }\n        else if(weight > 60.0){\n            return \"light welter\";\n        }\n        else if(weight > 57.0){\n            return \"light\";\n        }\n        else if(weight > 54.0){\n            return \"feather\";\n        }\n        else if(weight > 51.0){\n            return \"bantam\";\n        }\n        else if(weight > 48.0){\n            return \"fly\";\n        }\n        else{\n            return \"light fly\";\n        }\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double w = sc.nextDouble();\n            \n            if (w <= 48.00) {\n                System.out.println(\"light fly\");\n            } else if (w <= 51.00) {\n                System.out.println(\"fly\");\n            } else if (w <= 54.00) {\n                System.out.println(\"bantam\");\n            } else if (w <= 57.00) {\n                System.out.println(\"feather\");\n            } else if (w <= 60.00) {\n                System.out.println(\"light\");\n            } else if (w <= 64.00) {\n                System.out.println(\"light welter\");\n            } else if (w <= 69.00) {\n                System.out.println(\"welter\");\n            } else if (w <= 75.00) {\n                System.out.println(\"light middle\");\n            } else if (w <= 81.00) {\n                System.out.println(\"middle\");\n            } else if (w <= 91.00) {\n                System.out.println(\"light heavy\");\n            } else {\n                System.out.println(\"heavy\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main  args) { Scanner sc = new Scanner(System.in); while (sc.hasNext())  if (w  } else if  } else if (w <= 54.00) { System.out.println(\"bantam\"); } else if (w <= 57.00)  (w <= 60.00) { System.out.println(\"light\"); } else if (w <= 64.00) { System.out.println(\"light welter\"); } else if (w <= 69.00) {  <= 75.00) { System.out.println(\"light middle\"); } else if (w <= 81.00) { System.out.println(\"middle\"); } else if (w <= 91.00) { System.out.println(\"light heavy\"); } else { System.out.println(\"heavy\"); } } sc.close(); } }"], "perturbed_original": ["import  import java.util.ArrayList; public  main(String[] args) throws IOException{ BufferedReader br = new  list = new ArrayList<String>(); while((str=br.readLine())!=null){ list.add(check(Double.parseDouble(str))); } for(String d :  if(weight > 91.0){ return  81.0){ return \"light heavy\"; } else if(weight > 75.0){ return \"middle\"; } else if(weight > 69.0){ return \"light middle\"; } else if(weight >  if(weight > 60.0){ return \"light welter\"; } else if(weight > 57.0){ return \"light\"; } else if(weight > 54.0){ return \"feather\"; } else if(weight > 51.0){ return \"bantam\"; } else if(weight > 48.0){ return \"fly\"; } else{ return \"light fly\"; } } }"], "original_ll": -0.6428366303443909, "sampled_ll": -0.4415828585624695, "all_perturbed_sampled_ll": [-1.299861192703247], "all_perturbed_original_ll": [-1.5962767601013184], "perturbed_sampled_ll": -1.299861192703247, "perturbed_original_ll": -1.5962767601013184, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from decimal import Decimal\nimport sys\n\ndef classify(w):\n    if w <= Decimal(\"48.00\"):\n        return \"light fly\"\n    elif Decimal(\"48.00\") < w <= Decimal(\"51.00\"):\n        return \"fly\"\n    elif Decimal(\"51.00\") < w <= Decimal(\"54.00\"):\n        return \"bantam\"\n    elif Decimal(\"54.00\") < w <= Decimal(\"57.00\"):\n        return \"feather\"\n    elif Decimal(\"57.00\") < w <= Decimal(\"60.00\"):\n        return \"light\"\n    elif Decimal(\"60.00\") < w <= Decimal(\"64.00\"):\n        return \"light welter\"\n    elif Decimal(\"64.00\") < w <= Decimal(\"69.00\"):\n        return \"welter\"\n    elif Decimal(\"69.00\") < w <= Decimal(\"75.00\"):\n        return \"light middle\"\n    elif Decimal(\"75.00\") < w <= Decimal(\"81.00\"):\n        return \"middle\"\n    elif Decimal(\"81.00\") < w <= Decimal(\"91.00\"):\n        return \"light heavy\"\n    else:\n        return \"heavy\"\n    \n[print(classify(Decimal(j))) for j in [i for i in sys.stdin]]\n\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    w = float(line.strip())\n    \n    if w <= 48.00:\n        print(\"light fly\")\n    elif w <= 51.00:\n        print(\"fly\")\n    elif w <= 54.00:\n        print(\"bantam\")\n    elif w <= 57.00:\n        print(\"feather\")\n    elif w <= 60.00:\n        print(\"light\")\n    elif w <= 64.00:\n        print(\"light welter\")\n    elif w <= 69.00:\n        print(\"welter\")\n    elif w <= 75.00:\n        print(\"light middle\")\n    elif w <= 81.00:\n        print(\"middle\")\n    elif w <= 91.00:\n        print(\"light heavy\")\n    else:\n        print(\"heavy\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: w = float(line.strip()) if w <= 48.00: print(\"light fly\") elif w <= 51.00: print(\"fly\") elif w <= 54.00: print(\"bantam\") elif w <= 57.00: print(\"feather\") elif <extra_id_2>)<extra_id_3>print(\"light hundred\") elif<extra_id_4><= 80.00: print(\"heavy\")<extra_id_5>- 1 e12:<extra_id_6>elif w <= 64.00: print(\"light welter\") elif w <= 69.00: print(\"welter\") elif w <= <=<extra_id_7><=<extra_id_8><= 100.00:<extra_id_9>< <= 81.00: print(\"middle\") elif w <extra_id_10><=<extra_id_11>else:<extra_id_12>< - 2<extra_id_13>elif v <=<extra_id_14>w <= 80.00: print(\"light<extra_id_15>else: print(\"light\")<extra_id_16>if<extra_id_17>0.00<extra_id_18>) else<extra_id_19>5. print(\"heavy\")"], "perturbed_original": ["from decimal import Decimal import sys def classify(w): if   <= Decimal(\"51.00\"): return \"fly\" elif Decimal(\"51.00\") < w  Decimal(\"54.00\") <  elif Decimal(\"57.00\") < w <= Decimal(\"60.00\"): return \"light\" elif Decimal(\"60.00\") < w <= Decimal(\"64.00\"): return \"light welter\" elif Decimal(\"64.00\") < w <= Decimal(\"69.00\"): return \"welter\" elif Decimal(\"69.00\") < w <= Decimal(\"75.00\"): return  w <= Decimal(\"81.00\"): return \"middle\" elif Decimal(\"81.00\") < w <= Decimal(\"91.00\"): return \"light  for j in [i for i in sys.stdin]]"], "original_ll": -0.584625780582428, "sampled_ll": -0.668548583984375, "all_perturbed_sampled_ll": [-1.7124102115631104], "all_perturbed_original_ll": [-1.5300899744033813], "perturbed_sampled_ll": -1.7124102115631104, "perturbed_original_ll": -1.5300899744033813, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol0 0049: Blood Groups\n// 2017.7.29\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar *gets(char *);\n\n#define MAX 50\n\nint blood[MAX + 5];\nint cnt[5];\n\nint main()\n{\n\tchar buf[100], *p;\n\tint k, t;\n\n\tfor (k = 0; k <= MAX; k++) blood[k] = 0;\n\tfor (k = 1; k < 5; k++) cnt[k] = 0;\n\twhile (gets(buf) != NULL) {\n\t\tp = buf;\n\n\t\twhile (isspace(*p)) p++;\n\t\tk = *p++ - '0';\n\t\tif (isdigit(*p)) k = k * 10 + (*p++ - '0');\n\n\t\twhile (isspace(*p)) p++;  // ','\n\t\tp++;\n\n\t\twhile (isspace(*p)) p++;\n\t\tif (*p == 'A' && *(p + 1) == 'B') t = 3;\n\t\telse if (*p == 'B') t = 2;\n\t\telse if (*p == 'O') t = 4;\n\t\telse t = 1;\n\n\t\tif (blood[k] == 0) {\n\t\t\tblood[k] = t;\n\t\t\tcnt[t]++;\n\t\t} else if (blood[k] != t) while (1);\n\t}\n\tfor (k = 1; k < 5; k++) printf(\"%d\\n\", cnt[k]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int num;\n    char blood[10];\n    int countA = 0, countB = 0, countAB = 0, countO = 0;\n    \n    while (scanf(\"%d,%s\", &num, blood) == 2) {\n        if (strcmp(blood, \"A\") == 0) {\n            countA++;\n        } else if (strcmp(blood, \"B\") == 0) {\n            countB++;\n        } else if (strcmp(blood, \"AB\") == 0) {\n            countAB++;\n        } else if (strcmp(blood, \"O\") == 0) {\n            countO++;\n        }\n    }\n    \n    printf(\"%d\\n\", countA);\n    printf(\"%d\\n\", countB);\n    printf(\"%d\\n\", countAB);\n    printf(\"%d\\n\", countO);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int num; char  countB  countO = 0; while (scanf(\"%d,%s\", &num, blood) == 2) { if  countA++; } else if (strcmp(blood, \"B\") == 0) { countB++; } else if (strcmp(blood, \"AB\") == 0) { countAB++; } else if (strcmp(blood, \"O\") == 0) { countO++; }  printf(\"%d\\n\", countAB); printf(\"%d\\n\", countO); return 0; }"], "perturbed_original": ["// Aizu Vol0 0049: Blood Groups //  #include <ctype.h> char *gets(char *); #define  main() { char buf[100],  (k = 0; k <= MAX; k++) blood[k]  while (gets(buf) != NULL) { p = buf; while (isspace(*p)) p++; k = *p++ - '0'; if  10 + (*p++ - '0'); while (isspace(*p)) p++; // ',' p++; while (isspace(*p)) p++; if (*p == 'A' && *(p + 1) == 'B') t = 3; else if (*p == 'B') t = 2; else if (*p == 'O') t = 4; else t = 1; if (blood[k] == 0) { blood[k] = t; cnt[t]++; } else if  } for (k = 1; k < 5; k++) printf(\"%d\\n\", cnt[k]); return 0; }"], "original_ll": -1.0128161907196045, "sampled_ll": -0.3804785907268524, "all_perturbed_sampled_ll": [-1.3925459384918213], "all_perturbed_original_ll": [-1.8080745935440063], "perturbed_sampled_ll": -1.3925459384918213, "perturbed_original_ll": -1.8080745935440063, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint[] abo = {0,0,0,0};\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString tmp = null;\n\t\tint cup = 0;\n\t\tint mun = 0;\n\t\tint ter = 0;\n\t\tString[] rrr;\n\t\tint st = 0,sr = 0;\n\t\tint mon = 0;\n\t\tint syo=0,hisi=0;\n\t\t\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\ttry {\n\t\t\t\ttmp = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp == null){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp.equals(\"\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trrr = tmp.split(\",\");\n\t\t\t\n\t\t\tif(rrr[1].equals(\"A\")){\n\t\t\t\tabo[0]++;\n\t\t\t}else if(rrr[1].equals(\"B\")){\n\t\t\t\tabo[1]++;\n\t\t\t}else if(rrr[1].equals(\"AB\")){\n\t\t\t\tabo[2]++;\n\t\t\t}else if(rrr[1].equals(\"O\")){\n\t\t\t\tabo[3]++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(abo[0]);\n\t\tSystem.out.println(abo[1]);\n\t\tSystem.out.println(abo[2]);\n\t\tSystem.out.println(abo[3]);\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int countA = 0;\n        int countB = 0;\n        int countAB = 0;\n        int countO = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            String bloodType = parts[1];\n            \n            switch (bloodType) {\n                case \"A\":\n                    countA++;\n                    break;\n                case \"B\":\n                    countB++;\n                    break;\n                case \"AB\":\n                    countAB++;\n                    break;\n                case \"O\":\n                    countO++;\n                    break;\n            }\n        }\n        \n        System.out.println(countA);\n        System.out.println(countB);\n        System.out.println(countAB);\n        System.out.println(countO);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int countA  0;  (sc.hasNextLine()) { String line = sc.nextLine(); if (line.isEmpty()) break; String[] parts = line.split(\",\"); String bloodType = parts[1]; switch (bloodType) { case \"A\": countA++; break; case \"B\": countB++; break; case \"AB\":  break; } } System.out.println(countA); System.out.println(countB); System.out.println(countAB); System.out.println(countO); sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args){ int[] abo = {0,0,0,0}; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String tmp = null; int cup  0;  rrr;  0; int mon = 0; int syo=0,hisi=0; while(true){ try { tmp = br.readLine(); } catch (IOException e) { // TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af e.printStackTrace();  } if(tmp.equals(\"\")){ break; } rrr = tmp.split(\",\");  }else if(rrr[1].equals(\"AB\")){  } System.out.println(abo[0]); System.out.println(abo[1]); System.out.println(abo[2]); System.out.println(abo[3]); } }"], "original_ll": -0.8218650221824646, "sampled_ll": -0.4313839375972748, "all_perturbed_sampled_ll": [-1.12786066532135], "all_perturbed_original_ll": [-1.5601588487625122], "perturbed_sampled_ll": -1.12786066532135, "perturbed_original_ll": -1.5601588487625122, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\na = 0\nb = 0\nab = 0\no = 0\nfor i in sys.stdin.readlines():\n    if i.find(\",AB\") > -1:\n        ab += 1\n    elif i.find(\",B\") > -1:\n        b += 1\n    elif i.find(\",A\") >-1:\n        a += 1\n    else:\n        o += 1\nprint(a)\nprint(b)\nprint(ab)\nprint(o)", "sampled": "import sys\n\ncount = {'A': 0, 'B': 0, 'AB': 0, 'O': 0}\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        parts = line.split(',')\n        blood_type = parts[1]\n        count[blood_type] += 1\n\nprint(count['A'])\nprint(count['B'])\nprint(count['AB'])\nprint(count['O'])\n", "perturbed_sampled": ["import sys count =  line in sys.stdin: line = line.strip() if line: parts = line.split(',') blood_type = parts[1] count[blood_type] += 1 print(count['A']) print(count['B']) print(count['AB']) print(count['O'])"], "perturbed_original": ["import sys a  ab = 0 o = 0 for i in sys.stdin.readlines(): if i.find(\",AB\") > -1: ab  -1: b += 1 elif i.find(\",A\") >-1: a += 1 else: o += 1 print(a) print(b) print(ab) print(o)"], "original_ll": -0.9827123284339905, "sampled_ll": -0.773705244064331, "all_perturbed_sampled_ll": [-1.7287468910217285], "all_perturbed_original_ll": [-2.338197708129883], "perturbed_sampled_ll": -1.7287468910217285, "perturbed_original_ll": -2.338197708129883, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void){\n\tchar text[1002],i,n;\n\tfgets(text,1002,stdin);\n\tn=strlen(text);\n\tfor(i=0;i<n-5;i++){\n\t\tif(text[i]=='a' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){\n\t\t\ttext[i]='p';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h';\n\t\t}\n\t\telse if(text[i]=='p' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){\n\t\t\ttext[i]='a';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e';\n\t\t}\n\t\tif(text[i]=='A' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){\n\t\t\ttext[i]='P';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h';\n\t\t}\n\t\telse if(text[i]=='P' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){\n\t\t\ttext[i]='A';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e';\n\t\t}\n\t}\n\tprintf(\"%s\",text);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[1001];\n    char result[10001];\n    int i, j;\n    \n    fgets(line, sizeof(line), stdin);\n    \n    i = 0;\n    j = 0;\n    while (line[i] != '\\0' && line[i] != '\\n') {\n        if (strncmp(&line[i], \"apple\", 5) == 0) {\n            strcpy(&result[j], \"peach\");\n            j += 5;\n            i += 5;\n        } else if (strncmp(&line[i], \"peach\", 5) == 0) {\n            strcpy(&result[j], \"apple\");\n            j += 5;\n            i += 5;\n        } else {\n            result[j] = line[i];\n            j++;\n            i++;\n        }\n    }\n    result[j] = '\\0';\n    \n    printf(\"%s\\n\", result);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int  result[10001];   = 0; while (line[i] != '\\0' && line[i] !=  5) == 0) { strcpy(&result[j], \"peach\"); j += 5; i += 5; } else if (strncmp(&line[i], \"peach\", 5) == 0) { strcpy(&result[j], \"apple\"); j += 5; i += 5; } else { result[j] = line[i]; j++; i++; } } result[j] = '\\0'; printf(\"%s\\n\", result); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(void){ char text[1002],i,n; fgets(text,1002,stdin); n=strlen(text); for(i=0;i<n-5;i++){ if(text[i]=='a' && text[i+1]=='p' && text[i+2]=='p' &&  else if(text[i]=='p' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){ text[i]='a';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e'; } if(text[i]=='A' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){   && text[i+4]=='h'){ text[i]='A';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e'; } } printf(\"%s\",text); return 0; }"], "original_ll": -0.3317855894565582, "sampled_ll": -0.4642769992351532, "all_perturbed_sampled_ll": [-1.2524373531341553], "all_perturbed_original_ll": [-0.7828485369682312], "perturbed_sampled_ll": -1.2524373531341553, "perturbed_original_ll": -0.7828485369682312, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tStringBuilder ans = new StringBuilder();\n\t\twhile(in.hasNext()) {\n\t\t\tString x = in.next();\n\t\t\tif(x.contains(\"apple\"))\n\t\t\t\tans.append(x.replace(\"apple\",\"peach\")).append(\" \");\n\t\t\telse if(x.contains(\"peach\"))\n\t\t\t\tans.append(x.replace(\"peach\",\"apple\")).append(\" \");\n\t\t\telse\n\t\t\t\tans.append(x).append(\" \");\n\t\t}\n\t\tSystem.out.println(ans.toString().trim());\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        \n        String result = line.replace(\"apple\", \"TEMP\")\n                           .replace(\"peach\", \"apple\")\n                           .replace(\"TEMP\", \"peach\");\n        \n        System.out.println(result);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new  \"TEMP\") .replace(\"peach\", \"apple\") .replace(\"TEMP\", \"peach\"); System.out.println(result); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main  args) { Scanner in = new Scanner(System.in); StringBuilder ans = new StringBuilder(); while(in.hasNext()) { String x = in.next();  ans.append(x.replace(\"peach\",\"apple\")).append(\" \"); else ans.append(x).append(\" \"); } System.out.println(ans.toString().trim()); } }"], "original_ll": -0.6974615454673767, "sampled_ll": -1.0439963340759277, "all_perturbed_sampled_ll": [-2.1149065494537354], "all_perturbed_original_ll": [-1.881229043006897], "perturbed_sampled_ll": -2.1149065494537354, "perturbed_original_ll": -1.881229043006897, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nsent = map(str, raw_input().split(' '))\n\nfor i in range(len(sent)):\n    if sent[i] == 'apple' :\n        sent[i] = 'peach'\n    elif sent[i] == 'peach':\n        sent[i] = 'apple'\n\n    elif sent[i] == 'apple,' :\n        sent[i] = 'peach,'\n    elif sent[i] == 'peach,':\n        sent[i] = 'apple,'\n\n    elif sent[i] == 'apple.' :\n        sent[i] = 'peach.'\n    elif sent[i] == 'peach.':\n        sent[i] = 'apple.'\n\n    elif sent[i] == 'apple!' :\n        sent[i] = 'peach!'\n    elif sent[i] == 'peach!':\n        sent[i] = 'apple!'\n\n    elif sent[i] == 'apple?' :\n        sent[i] = 'peach?'\n    elif sent[i] == 'peach?':\n        sent[i] = 'apple?'\n\n \n\n\n\nfor sen in sent:\n    print sen,\n    ", "sampled": "s = input()\ns = s.replace('apple', '@TEMP@').replace('peach', 'apple').replace('@TEMP@', 'peach')\nprint(s)\n", "perturbed_sampled": ["s = input() s = s.replace('apple', '@TEMP@').replace('peach', 'apple').replace('@TEMP@', 'peach') print(s)"], "perturbed_original": ["sent = map(str, raw_input().split(' ')) for i in range(len(sent)): if sent[i] == 'apple' : sent[i] = 'peach' elif sent[i] == 'peach': sent[i] = 'apple' elif sent[i] == 'apple,' : sent[i] =  sent[i] == 'apple.' :  'apple.' elif sent[i] == 'apple!' : sent[i] = 'peach!' elif sent[i] == 'peach!': sent[i] = 'apple!' elif sent[i] == 'apple?' : sent[i] = 'peach?' elif sent[i] == 'peach?':  in sent: print sen,"], "original_ll": -0.6185399293899536, "sampled_ll": -2.121476888656616, "all_perturbed_sampled_ll": [-2.281001329421997], "all_perturbed_original_ll": [-1.2478022575378418], "perturbed_sampled_ll": -2.281001329421997, "perturbed_original_ll": -1.2478022575378418, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  long a,b,i,n;\n\n  while(scanf(\"%ld\",&n),n!=0){\n    a=0;\n    for(i=5;i<=n;i++){\n      b=i;\n      while(b>0){\n        if(b%5!=0) break;\n        a++;\n        b=b/5;\n      }\n    }\n    printf(\"%ld\\n\",a);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int count = 0;\n        int temp = n;\n        \n        while(temp >= 5) {\n            temp /= 5;\n            count += temp;\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int n; while(1) { scanf(\"%d\", &n); if(n == 0) break; int count = 0; int temp = n; while(temp >= 5) { temp /=  printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include <stdio.h> int  for(i=5;i<=n;i++){ b=i; while(b>0){ if(b%5!=0) break; a++; b=b/5; } } printf(\"%ld\\n\",a); } return 0; }"], "original_ll": -1.029948115348816, "sampled_ll": -0.6297503709793091, "all_perturbed_sampled_ll": [-1.3774473667144775], "all_perturbed_original_ll": [-2.115245819091797], "perturbed_sampled_ll": -1.3774473667144775, "perturbed_original_ll": -2.115245819091797, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Scanner;\npublic class Main {\n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakePrimeList();\n\t\twhile(true) {\n\t\t\tint a = stdIn.nextInt();\n\t\t\tif(a == 0) break;\n\t\t\tint c2 = 0;\n\t\t\tint c5 = 0;\n\t\t\tfor(int i = a; i >= 1; i--) {\n\t\t\t\tint[] ret = f(i);\n\t\t\t\tc2 += ret[0];\n\t\t\t\tc5 += ret[2];\n\t\t\t}\n\t\t\tint count = Math.min(c2, c5);\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tpublic static void makePrimeList() {\n\t\tboolean[] isntPrime = new boolean[20001];\n\t\tisntPrime[0] = isntPrime[1] = true;\n\t\tlist.add(2);\n\t\tfor(int i = 3; i < 20001; i+= 2) {\n\t\t\tif(!isntPrime[i]) {\n\t\t\t\tlist.add(i);\n\t\t\t\tfor(int j = i + i; j < 20001; j+= i) {\n\t\t\t\t\tisntPrime[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int[] f(int a) {\n\t\tint[] ret = new int[list.size()];\n\t\twhile(a > 1) {\n\t\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\t\tif(a % list.get(i) == 0) {\n\t\t\t\t\ta /= list.get(i);\n\t\t\t\t\tret[i]++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\t\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            int temp = n;\n            while (temp > 0) {\n                temp /= 5;\n                count += temp;\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[]   int n =  break; int count = 0; int temp = n; while (temp > 0) { temp /= 5; count += temp; } System.out.println(count); } sc.close(); } }"], "perturbed_original": [" java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import  Main { static ArrayList<Integer> list = new ArrayList<Integer>(); public static void main(String[] args) { Scanner stdIn = new Scanner(System.in); makePrimeList();  stdIn.nextInt(); if(a ==  0; for(int i = a; i >= 1; i--) { int[] ret = f(i); c2 += ret[0]; c5 += ret[2]; } int count = Math.min(c2, c5); System.out.println(count); } } public static void makePrimeList() {  isntPrime[0] = isntPrime[1] = true; list.add(2); for(int i = 3; i < 20001; i+= 2) {  = i + i; j < 20001; j+= i) { isntPrime[j] =  public static int[] f(int a) { int[] ret = new int[list.size()]; while(a > 1) {  < list.size(); i++) { if(a % list.get(i) == 0) { a /= list.get(i);  ret; } }"], "original_ll": -0.6294464468955994, "sampled_ll": -0.47968900203704834, "all_perturbed_sampled_ll": [-1.9134248495101929], "all_perturbed_original_ll": [-1.592763066291809], "perturbed_sampled_ll": -1.9134248495101929, "perturbed_original_ll": -1.592763066291809, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f(n):\n    for i in range(1,n):\n        n*=i\n    return n\n        \n        \nwhile True:\n    n=int(input())\n    if n==0:\n        break\n    else:\n        a=str(f(n))\n        s=0\n        l=len(a)\n        for i in range(l-1,-1,-1):\n            if a[i]==\"0\":\n                s+=1\n            else:\n                break\n        print(s)\n", "sampled": "import sys\n\ndef count_trailing_zeros(n):\n    count = 0\n    power_of_5 = 5\n    while power_of_5 <= n:\n        count += n // power_of_5\n        power_of_5 *= 5\n    return count\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    if n == 0:\n        break\n    print(count_trailing_zeros(n))\n", "perturbed_sampled": ["import sys def  = 5 while power_of_5 <= n: count += n // power_of_5 power_of_5 *= 5 return count for line in sys.stdin:  == 0: break print(count_trailing_zeros(n))"], "perturbed_original": ["def f(n): for i in range(1,n): n*=i return n while True: n=int(input()) if n==0:  for i in range(l-1,-1,-1): if a[i]==\"0\": s+=1 else: break print(s)"], "original_ll": -0.9292617440223694, "sampled_ll": -0.5974042415618896, "all_perturbed_sampled_ll": [-2.8476529121398926], "all_perturbed_original_ll": [-1.726120948791504], "perturbed_sampled_ll": -2.8476529121398926, "perturbed_original_ll": -1.726120948791504, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\n\nint main()\n{\n\tint n=0,d,sw;\n\tlong int i,j,k,s[1000],sum;\n\n\twhile(1)\n\t{\n\t\tn=1;\n\t\tsum=0;\n\t\tscanf(\"%d\",&d);\n\t\tif(!d)\n\t\t\tbreak;\n\t\ts[0]=2;\n\t\ts[1]=3;\n\t\tif(d<=2)\n\t\t{\n\t\t\tfor(i=0;i<d;i++)\n\t\t\t\tsum+=s[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum=5;\n\t\t\tfor(i=5;;i+=2)\n\t\t\t{\n\t\t\t\tsw=0;\n\t\t\t\tk=(long int)sqrt((double)i);\n\t\t\t\tfor(j=0;s[j]<=k;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i%s[j]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsw=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!sw)\n\t\t\t\t{\n\t\t\t\t\tn++;\n\t\t\t\t\tif(n<1000)\n\t\t\t\t\t\ts[n]=i;\n\t\t\t\t\tsum+=i;\n\t\t\t\t\tif(n==d-1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 10000\n#define MAX_PRIME 104730\n\nint is_prime[MAX_PRIME + 1];\nint primes[MAX_N];\nint prime_count = 0;\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i <= MAX_PRIME; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= MAX_PRIME; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n    \n    for (int i = 2; i <= MAX_PRIME && prime_count < MAX_N; i++) {\n        if (is_prime[i]) {\n            primes[prime_count++] = i;\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += primes[i];\n        }\n        printf(\"%lld\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> #define MAX_N 10000 #define MAX_PRIME 104730 int is_prime[MAX_PRIME + 1]; ) { var<extra_id_2>%s; int<extra_id_3>+ (i * n) 0; void sieve() { memset(is_prime, 1, sizeof(is_prime)); is_prime[0] = is_prime[1] = 0; for (int i = 2; i * i <= MAX_PRIME; i++) { if (is_prime[i]) { for (int j = i * i; j <= MAX_PRIME; j += i) <extra_id_4>&= ~0L;<extra_id_5>++<extra_id_6>0<extra_id_7>}<extra_id_8>} }<extra_id_9>is_prime.length = (is_prime.length/n) > 0);<extra_id_10>max(0, n) ==<extra_id_11>0){ return ; }<extra_id_12>(n);<extra_id_13>0) { switch<extra_id_14>case 0xffff : { case<extra_id_15>#include <stdio.h } } for (int i  && prime_count < MAX_N; i++) { if (is_prime[i]) {  } int main() { sieve(); int n; while (scanf(\"%d\", &n)  0) { long long sum = 0; for (int i = 0; i < n; i++)  0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h>  long int i,j,k,s[1000],sum; while(1) { n=1; sum=0; scanf(\"%d\",&d); if(!d) break; s[0]=2; s[1]=3; if(d<=2)  { sum=5; for(i=5;;i+=2) { sw=0; k=(long int)sqrt((double)i); for(j=0;s[j]<=k;j++) { if(i%s[j]==0)  if(!sw) { n++; if(n<1000) s[n]=i; sum+=i; if(n==d-1) break; } } } printf(\"%d\\n\",sum); } return 0; }"], "original_ll": -0.8601018190383911, "sampled_ll": -0.3442285656929016, "all_perturbed_sampled_ll": [-1.7785495519638062], "all_perturbed_original_ll": [-1.680195689201355], "perturbed_sampled_ll": -1.7785495519638062, "perturbed_original_ll": -1.680195689201355, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main{\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\tint[] p = new int[1000000];\n\tsetP(p);\n\twhile(kbd.hasNext()){\n\t    int n = kbd.nextInt();\n\t    if(n!=0) solve(p, n);\n\t}\n    }\n\n    static void solve(int[] p, int n){\n\tint sum=0, i;\n\tfor(i=0; p[i]<=n; i++){\n\t    if(p[i]!=-1) {\n\t\tsum+=i;\n\t\t//System.out.println(i);\n\t    }\n\t}\n\n\tSystem.out.println(sum);\n    }\n\n    static void setP(int[] p){\n\tint a=1, i, j;\n\tArrays.fill(p, 1);\n\tp[0] = -1;\n\tp[1] = -1;\n\tfor(i=2; i<p.length; i++){\n\t    if(p[i] == 1){\n\t\t//System.out.println(i+\" \"+a);\n\t\tp[i] = a;\n\t\ta++;\t\n\t    }\n\t    for(j=i+i; j<p.length; j+=i){\n\t\tp[j] = -1;\n\t    }\n\t}\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Pre-calculate primes up to a reasonable limit\n        // For n=10000, we need the 10000th prime\n        // The 10000th prime is approximately 104729\n        int limit = 110000;\n        boolean[] isPrime = new boolean[limit];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        // Sieve of Eratosthenes\n        for (int i = 2; i * i < limit; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < limit; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        // Collect primes in order\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < limit; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        // Pre-calculate cumulative sums\n        long[] cumulativeSum = new long[primes.size() + 1];\n        for (int i = 0; i < primes.size(); i++) {\n            cumulativeSum[i + 1] = cumulativeSum[i] + primes.get(i);\n        }\n        \n        // Process queries\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            System.out.println(cumulativeSum[n]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void  = new Scanner(System.in); // Pre-calculate primes up to a reasonable limit // For n=10000, we need the 10000th prime // The 10000th prime is approximately 104729 int limit = 110000; boolean[] isPrime = new  isPrime[1] = false;  (int i = 2; i  { if (isPrime[i]) { for (int j  < limit; j +=  } } }  List<Integer> primes = new ArrayList<>(); for (int i = 2; i < limit; i++) { if (isPrime[i]) { primes.add(i); } } // Pre-calculate cumulative sums long[] cumulativeSum = new  i = 0; i < primes.size(); i++) { cumulativeSum[i + 1] = cumulativeSum[i] + primes.get(i); } // Process queries while (true) {  System.out.println(cumulativeSum[n]); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ static Scanner kbd = new  args){ int[] p  int n =  } static void solve(int[] p, int n){ int sum=0, i; for(i=0; p[i]<=n; i++){ if(p[i]!=-1) { sum+=i; //System.out.println(i); } } System.out.println(sum); } static void setP(int[] p){ int a=1, i, j; Arrays.fill(p, 1);  -1; for(i=2; i<p.length;  \"+a); p[i] = a; a++; } for(j=i+i; j<p.length; j+=i){ p[j] = -1; } } } }"], "original_ll": -0.8661919236183167, "sampled_ll": -0.4598054885864258, "all_perturbed_sampled_ll": [-1.4107773303985596], "all_perturbed_original_ll": [-1.9395440816879272], "perturbed_sampled_ll": -1.4107773303985596, "perturbed_original_ll": -1.9395440816879272, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import *\nn=range(104730);a=list(n)\nfor i in range(2,321):a[i*2::i]=[0]*len(a[i*2::i])\np=list(compress(n,a))\nfor e in iter(input,'0'):print(sum(p[:int(e)+1])-1)\n", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    primes = [i for i in range(2, limit + 1) if is_prime[i]]\n    return primes\n\n# Pre-compute primes up to a sufficient limit\n# For n=10000, we need the 10000th prime\n# The 10000th prime is 104729\nprimes = sieve_of_eratosthenes(105000)\n\n# Pre-compute cumulative sums\ncumsum = [0]\nfor prime in primes:\n    cumsum.append(cumsum[-1] + prime)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(cumsum[n])\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit  = False for i in range(2, int(limit**0.5) + 1): if is_prime[i]:  + 1,  = [i for i  # Pre-compute primes up to a sufficient limit # For n=10000, we need the 10000th prime # The 10000th prime is 104729 primes = sieve_of_eratosthenes(105000) # Pre-compute cumulative sums cumsum = [0] for prime in primes: cumsum.append(cumsum[-1] + prime) while True: n = int(input()) if n == 0: break print(cumsum[n])"], "perturbed_original": ["from itertools import * n=range(104730);a=list(n) for i in range(2,321):a[i*2::i]=[0]*len(a[i*2::i]) p=list(compress(n,a)) for e in iter(input,'0'):print(sum(p[:int(e)+1])-1)"], "original_ll": -2.4989681243896484, "sampled_ll": -0.6432137489318848, "all_perturbed_sampled_ll": [-1.5327116250991821], "all_perturbed_original_ll": [-2.621738910675049], "perturbed_sampled_ll": -1.5327116250991821, "perturbed_original_ll": -2.621738910675049, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void) {\n\tint a,b,n;\n\tint sum;\n\tint i,j;\n\twhile(1) {\n\t\tif(scanf(\"%d %d %d\",&a,&b,&n)==-1)break;\n\t\ta-=a/b*b;\n\t\tsum=0;\n\t\tfor(i=1;i<=n;i++) {\n\t\t\ta*=10;\n\t\t\tfor(j=9;j>=0;j--) {\n\t\t\t\tif(b*j<=a)break;\n\t\t\t}\n\t\t\ta-=b*j;\n\t\t\tsum+=j;\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a, b, n;\n    \n    while (scanf(\"%d %d %d\", &a, &b, &n) == 3) {\n        int sum = 0;\n        int remainder = a % b;\n        \n        for (int i = 0; i < n; i++) {\n            remainder *= 10;\n            int digit = remainder / b;\n            sum += digit;\n            remainder = remainder % b;\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int a, b, n; while (scanf(\"%d  == 3) { int sum = 0; int remainder = a % b; for (int i = 0; i < n; i++) { remainder *= 10; int digit = remainder /  } printf(\"%d\\n\", sum); } return 0; }"], "perturbed_original": ["#include <stdio.h> int  sum; int i,j; while(1) { if(scanf(\"%d %d %d\",&a,&b,&n)==-1)break; a-=a/b*b; sum=0; for(i=1;i<=n;i++) { a*=10; for(j=9;j>=0;j--) { if(b*j<=a)break; } a-=b*j; sum+=j; } printf(\"%d\\n\",sum); } return 0; }"], "original_ll": -1.0060502290725708, "sampled_ll": -0.5422503352165222, "all_perturbed_sampled_ll": [-1.8568499088287354], "all_perturbed_original_ll": [-1.508583903312683], "perturbed_sampled_ll": -1.8568499088287354, "perturbed_original_ll": -1.508583903312683, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main{\n\tMain(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tint n = sc.nextInt();\n\t\t\tint s = 0;\n\t\t\tString str = Double.toString((a/b)) + \"0000000000\";\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\ts += Integer.parseInt(str.substring(i+2, i+3));\n\t\t\t}\n\t\t\tSystem.out.println(Integer.toString(s));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int n = sc.nextInt();\n            \n            int sum = 0;\n            int remainder = a % b;\n            \n            for (int i = 0; i < n; i++) {\n                remainder *= 10;\n                int digit = remainder / b;\n                sum += digit;\n                remainder = remainder % b;\n            }\n            \n            System.out.println(sum);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in);  = sc.nextInt(); int b = sc.nextInt(); int n  0; int remainder  (int i = 0; i < n; i++) { remainder *= 10; int digit = remainder / b; sum  % b; } System.out.println(sum); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public  = new Scanner(System.in); while(sc.hasNext()){ double a = sc.nextDouble(); double b = sc.nextDouble(); int n = sc.nextInt(); int s = 0; String str = Double.toString((a/b)) + \"0000000000\"; for(int i = 0; i < n; i++){ s += Integer.parseInt(str.substring(i+2, i+3));  static  } }"], "original_ll": -0.9605746269226074, "sampled_ll": -0.5062127113342285, "all_perturbed_sampled_ll": [-1.7409049272537231], "all_perturbed_original_ll": [-1.8202145099639893], "perturbed_sampled_ll": -1.7409049272537231, "perturbed_original_ll": -1.8202145099639893, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "t=10**9\nwhile 1:\n    try:\n        a,b,n=map(int,raw_input().split())\n        if b==0:\n            print 0\n            continue\n        f=a*t/b\n        f=str(f%t)\n        ans=0\n        for i in range(n):\n            ans+=int(f[i])\n        print ans\n    except:\n        break", "sampled": "import sys\n\nfor line in sys.stdin:\n    a, b, n = map(int, line.split())\n    s = 0\n    remainder = a % b\n    \n    for i in range(n):\n        remainder *= 10\n        digit = remainder // b\n        s += digit\n        remainder = remainder % b\n    \n    print(s)\n", "perturbed_sampled": ["import sys for line in sys.stdin: a,  s = 0 remainder = a % b for i in range(n): remainder *= 10 digit = remainder // b s += digit  print(s)"], "perturbed_original": ["t=10**9 while 1: try: a,b,n=map(int,raw_input().split()) if b==0: print 0 continue f=a*t/b f=str(f%t) ans=0 for i in  break"], "original_ll": -1.2677586078643799, "sampled_ll": -1.1094900369644165, "all_perturbed_sampled_ll": [-3.0752813816070557], "all_perturbed_original_ll": [-2.590745449066162], "perturbed_sampled_ll": -3.0752813816070557, "perturbed_original_ll": -2.590745449066162, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n  int k;\n  double a[11];\n  double sum;\n  while(scanf(\"%lf\",&a[1])!=EOF){\n    sum = a[1];\n    printf(\"test\");\n    for(k=2;k=10;k++){\n      if(k%2==0){\n        a[k] = a[k-1] * 2;\n      }else{\n        a[k] = a[k-1] / 3;\n      }\n      sum += a[k];\n    }\n    printf(\"%lf\\n\",sum);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double a;\n    while (scanf(\"%lf\", &a) != EOF) {\n        double sum = 0.0;\n        double current = a;\n        \n        for (int i = 1; i <= 10; i++) {\n            sum += current;\n            if (i % 2 == 0) {\n                current = current / 3.0;\n            } else {\n                current = current * 2.0;\n            }\n        }\n        \n        printf(\"%.8lf\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double a; while (scanf(\"%lf\", &a) != EOF) { double sum = 0.0; double current = a; for (int i = 1; i <= 10; i++) { sum += current; if (i %  = current /  = current  sum); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int k; double  = a[1]; printf(\"test\"); for(k=2;k=10;k++){ if(k%2==0){ a[k] = a[k-1]  a[k-1] / 3; } sum += a[k]; } printf(\"%lf\\n\",sum); } return 0; }"], "original_ll": -1.1180412769317627, "sampled_ll": -0.6366769671440125, "all_perturbed_sampled_ll": [-1.6757898330688477], "all_perturbed_original_ll": [-2.1570427417755127], "perturbed_sampled_ll": -1.6757898330688477, "perturbed_original_ll": -2.1570427417755127, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n    private static double calculation(double value){\n\tdouble sum = value;\n\tdouble[] values = new double[10];\n\tvalues[0] = value;\n\t\n\tfor(int i = 1; i < 10; ++i){\n\t    if(i%2 == 1){\n\t\tvalues[i] = values[i-1]*2.0;\n\t    } else {\n\t\tvalues[i] = values[i-1]/3.0;\n\t    }\n\t    sum += values[i];\n\t}\n\t\n\n\treturn sum;\n    }\n    \n    public static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\t\n\twhile(sc.hasNext()){\n\t    double value = sc.nextDouble();\n\t    System.out.printf(\"%f\\n\", calculation(value));\n\t}\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double a = sc.nextDouble();\n            double sum = 0;\n            double current = a;\n            \n            for (int i = 1; i <= 10; i++) {\n                sum += current;\n                if (i % 2 == 0) {\n                    current = current / 3.0;\n                } else {\n                    current = current * 2.0;\n                }\n            }\n            \n            System.out.printf(\"%.8f%n\", sum);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  (sc.hasNext()) { double a =  double current = a; for (int i = 1; i <= 10; i++)  (i % 2 == 0) { current  else { current = current * 2.0; } } System.out.printf(\"%.8f%n\", sum); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ private static double calculation(double value){ double sum = value; double[] values = new double[10]; values[0] = value;  < 10; ++i){ if(i%2 == 1){ values[i] = values[i-1]*2.0; } else { values[i] = values[i-1]/3.0; } sum += values[i]; } return sum;   = sc.nextDouble(); System.out.printf(\"%f\\n\", calculation(value)); } } }"], "original_ll": -0.8571709990501404, "sampled_ll": -0.5965708494186401, "all_perturbed_sampled_ll": [-1.9275627136230469], "all_perturbed_original_ll": [-1.625801682472229], "perturbed_sampled_ll": -1.9275627136230469, "perturbed_original_ll": -1.625801682472229, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    try:n=float(input())\n    except:break\n    s=n\n    for i in range(9):\n        n=n/3 if i%2 else n*2\n        s+=n\n    print(s)", "sampled": "import sys\n\nfor line in sys.stdin:\n    a = float(line.strip())\n    \n    terms = [a]\n    for i in range(1, 10):\n        if i % 2 == 1:  # odd index (2nd, 4th, 6th... terms)\n            terms.append(terms[-1] * 2)\n        else:  # even index (3rd, 5th, 7th... terms)\n            terms.append(terms[-1] / 3)\n    \n    s = sum(terms)\n    print(f\"{s:.8f}\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: a =  i in range(1, 10): if i % 2 == 1: # odd index (2nd, 4th, 6th... terms) terms.append(terms[-1] * 2) else: # even  terms.append(terms[-1] / 3) s = sum(terms) print(f\"{s:.8f}\")"], "perturbed_original": ["while 1: try:n=float(input()) except:break s=n for i in range(9): n=n/3 if i%2 else n*2 s+=n print(s)"], "original_ll": -1.2127773761749268, "sampled_ll": -0.9472917914390564, "all_perturbed_sampled_ll": [-2.1121537685394287], "all_perturbed_original_ll": [-2.029350757598877], "perturbed_sampled_ll": -2.1121537685394287, "perturbed_original_ll": -2.029350757598877, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint prime[50001];\nvoid set(void){\n    int i,o;\n    for(i=4;i<=5000;i+=2)\n        prime[i]=1;\n    for(i=3;i*i<=5000;i+=2){\n        if(prime[i]==0)\n            for(o=i*2;o<=5000;o+=i)\n                prime[o]=1;\n    }\n}\nint main(void){\n    int num,count,sum,i,o;\n    set();\n    for(;count=0,scanf(\"%d\",&num),num;){\n        for(i=2;i<=num;i++)\n            if(!prime[i]){\n                if(i>num)\n                     break;\n                for(o=2;o<=num;o++)\n                    if(!prime[o]){\n                        sum=i+o;\n                        if(sum == num){\n                            count++;\n                            break;\n                        }\n                        if(sum > num)\n                            break;\n                    }\n            }\n        printf(\"%d\\n\",count%2?(count/2+1):(count/2));\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 50001\n\nint is_prime[MAX];\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int count = 0;\n        for (int i = 2; i <= n / 2; i++) {\n            if (is_prime[i] && is_prime[n - i]) {\n                count++;\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  50001 int is_prime[MAX];  sizeof(is_prime)); is_prime[0] = is_prime[1] = 0; for (int i = 2; i * i < MAX; i++) { if  = i * i; j < MAX; j += i) { is_prime[j] = 0;  main() { sieve(); int n; while (scanf(\"%d\", &n) == 1 && n  = 0; for (int i = 2;  i++) { if (is_prime[i] && is_prime[n - i]) { count++; } } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include <stdio.h> int prime[50001]; void set(void){ int i,o; for(i=4;i<=5000;i+=2) prime[i]=1; for(i=3;i*i<=5000;i+=2){ if(prime[i]==0) for(o=i*2;o<=5000;o+=i) prime[o]=1; } }  for(;count=0,scanf(\"%d\",&num),num;){ for(i=2;i<=num;i++) if(!prime[i]){ if(i>num) break; for(o=2;o<=num;o++) if(!prime[o]){ sum=i+o; if(sum == num){ count++; break; } if(sum >  } return 0; }"], "original_ll": -0.988865852355957, "sampled_ll": -0.31437116861343384, "all_perturbed_sampled_ll": [-1.5062111616134644], "all_perturbed_original_ll": [-1.4758234024047852], "perturbed_sampled_ll": -1.5062111616134644, "perturbed_original_ll": -1.4758234024047852, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static boolean[] p=new boolean[50000];\n\tpublic static int counter(int n){\n\t\tint c=0,i,j;\n\t\tfor(i=2;i<=n/2;i++){\n\t\t\tif(p[i])\n\t\t\tfor(j=2;i+j<=n;j++){\n\t\t\t\tif(p[j]){\n\t\t\t\t\tif(i+j==n){\n\t\t\t\t\t\tc++;\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}//\n\t\treturn c;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,i,j;\n\t\tArrays.fill(p, true);\n\t\tfor(i=2;i<50000;i++){\n\t\t\tif(p[i])\n\t\t\tfor(j=2;i*j<50000;j++){\n\t\t\t\tp[i*j]=false;\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tSystem.out.println(counter(n));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static boolean[] isPrime;\n    static int MAX = 50001;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Sieve of Eratosthenes\n        isPrime = new boolean[MAX];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i < MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < MAX; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            for (int i = 2; i <= n / 2; i++) {\n                if (isPrime[i] && isPrime[n - i]) {\n                    count++;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  static int MAX = 50001; public static void main(String[] args)  Eratosthenes isPrime = new  (int i = 2; i * i < MAX; i++) { if (isPrime[i]) { for (int j = i * i; j < MAX; j += i) { isPrime[j] = false; } } } while (true) { int n = sc.nextInt(); if (n == 0) break;  (int i  / 2; i++) { if (isPrime[i] && isPrime[n - i]) { count++; } } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { public static boolean[] p=new boolean[50000]; public static int counter(int n){ int c=0,i,j; p[i*j]=true;<extra_id_3>[<extra_id_4>n]=true; } while(true){ n=sc.nextInt();<extra_id_5>if(j==0)<extra_id_6>} // c++; // System.out.println(i+\" \"+j); } } } }// <extra_id_7>Console . println(n); }<extra_id_8>) ; }<extra_id_9>System.out. void main(String[] args) { Scanner sc=new Scanner(System.in); int n,i,j;  p[i*j]=false; } } while(true){ n=sc.nextInt(); if(n==0) break; System.out.println(counter(n)); } } }"], "original_ll": -0.8087391257286072, "sampled_ll": -0.3037806749343872, "all_perturbed_sampled_ll": [-1.3395190238952637], "all_perturbed_original_ll": [-2.1694817543029785], "perturbed_sampled_ll": -1.3395190238952637, "perturbed_original_ll": -2.1694817543029785, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N=50000+1\np=[True]*N\np[0],p[1]=False,False\nfor i in xrange(2,int(N**0.5)+1):\n    if p[i]==True:\n        for j in xrange(i**2,N,i):\n            p[j]=False\nwhile True:\n    n=input()\n    if n==0:break\n    c=0\n    for i in xrange(n/2+1):\n        if p[i] and p[n-i]:c+=1\n    print c", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\nlimit = 50000\nis_prime = sieve_of_eratosthenes(limit)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = 0\n    for i in range(2, n // 2 + 1):\n        if is_prime[i] and is_prime[n - i]:\n            count += 1\n    \n    print(count)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in  is_prime[i]: for j in range(i*i, limit + 1, i): is_prime[j] = False return is_prime limit = 50000 is_prime  == 0: break count = 0 for i in range(2, n  is_prime[i] and is_prime[n - i]: count += 1 print(count)"], "perturbed_original": ["N=50000+1 p=[True]*N  if p[i]==True: for j in xrange(i**2,N,i): p[j]=False while True: n=input() if n==0:break c=0 for i in xrange(n/2+1): if p[i] and p[n-i]:c+=1 print c"], "original_ll": -0.7088199257850647, "sampled_ll": -0.35662907361984253, "all_perturbed_sampled_ll": [-1.4756699800491333], "all_perturbed_original_ll": [-1.6462689638137817], "perturbed_sampled_ll": -1.4756699800491333, "perturbed_original_ll": -1.6462689638137817, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N,main(){while(~scanf(\"%d\",&N))printf(\"%d\\n\",N*(N+1)/2+1);}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) != EOF) {\n        long long result = 1 + (long long)n * (n + 1) / 2;\n        printf(\"%lld\\n\", result);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while (scanf(\"%d\", &n) != EOF) { long long result = 1 +  1) / 2; printf(\"%lld\\n\", result); } return 0; }"], "perturbed_original": ["N,main(){while(~scanf(\"%d\",&N))printf(\"%d\\n\",N*(N+1)/2+1);}"], "original_ll": -2.0631284713745117, "sampled_ll": -0.7436593770980835, "all_perturbed_sampled_ll": [-1.5802377462387085], "all_perturbed_original_ll": [-2.0631284713745117], "perturbed_sampled_ll": -1.5802377462387085, "perturbed_original_ll": -2.0631284713745117, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n\tScanner s = new Scanner(System.in);\n\tint[] d = new int[10001];\n\td[0]=1;\n\td[1]=2;\n\tfor(int i=2 ; i<10001 ; i++)\n\t    d[i] = d[i-1]+i;\n\twhile(s.hasNext())\n\t    System.out.println(d[s.nextInt()]);\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            long result = (long) n * (n + 1) / 2 + 1;\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); long result = (long) n  } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main { public static void main(String[] args)  Scanner(System.in); int[] d = new int[10001]; d[0]=1; d[1]=2; for(int i=2 ;  d[i-1]+i; while(s.hasNext()) System.out.println(d[s.nextInt()]); } }"], "original_ll": -0.9500241279602051, "sampled_ll": -0.6218088865280151, "all_perturbed_sampled_ll": [-1.4622904062271118], "all_perturbed_original_ll": [-1.961228847503662], "perturbed_sampled_ll": -1.4622904062271118, "perturbed_original_ll": -1.961228847503662, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        a = int(input())\n        print(((a * a) + a + 2) / 2)\n    except EOFError:\n        break", "sampled": "import sys\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    result = 1 + n * (n + 1) // 2\n    print(result)\n", "perturbed_sampled": ["import  n = int(line.strip()) result = 1 + n * (n + 1) // 2 print(result)"], "perturbed_original": [" int(input()) print(((a * a) + a + 2) / 2) except EOFError: break"], "original_ll": -1.2230191230773926, "sampled_ll": -1.3409327268600464, "all_perturbed_sampled_ll": [-2.77020525932312], "all_perturbed_original_ll": [-3.1575300693511963], "perturbed_sampled_ll": -2.77020525932312, "perturbed_original_ll": -3.1575300693511963, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "i;main(){float A,a,B,b,C,c,D,d;for(;~scanf(\"%f\",&d+i*2);)if(++i==8)puts((A-B)*(C-D)+(a-b)*(c-d)?\"NO\":\"YES\",i=0);}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double xA, yA, xB, yB, xC, yC, xD, yD;\n    \n    while (scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n                 &xA, &yA, &xB, &yB, &xC, &yC, &xD, &yD) == 8) {\n        double dx1 = xB - xA;\n        double dy1 = yB - yA;\n        double dx2 = xD - xC;\n        double dy2 = yD - yC;\n        \n        double dot = dx1 * dx2 + dy1 * dy2;\n        \n        if (fabs(dot) < 1e-9) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { double xA, yA, xB, yB, xC, yC, xD, yD;  %lf %lf %lf %lf\", &xA, &yA, &xB, &yB, &xC, &yC, &xD, &yD)  double dy1 = yB -  - xC; double dy2 = yD - yC; double dot = dx1 * dx2 + dy1 * dy2; if (fabs(dot) < 1e-9) { printf(\"YES\\n\");  } return 0; }"], "perturbed_original": ["i;main(){float A,a,B,b,C,c,D,d;for(;~scanf(\"%f\",&d+i*2);)if(++i==8)puts((A-B)*(C-D)+(a-b)*(c-d)?\"NO\":\"YES\",i=0);}"], "original_ll": -2.8278112411499023, "sampled_ll": -0.4259226322174072, "all_perturbed_sampled_ll": [-1.3921822309494019], "all_perturbed_original_ll": [-2.8278112411499023], "perturbed_sampled_ll": -1.3921822309494019, "perturbed_original_ll": -2.8278112411499023, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main{\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        while(sc.hasNext()){\n            double[][]point=new double[4][2];\n            for(int i=0;i<4;i++){\n                point[i][0]=sc.nextDouble();\n                point[i][1]=sc.nextDouble();\n            }\n            double x1=point[1][0]-point[0][0],y1=point[1][1]-point[0][1],x2=point[3][0]-point[2][0],y2=point[3][1]-point[2][1];\n            System.out.println((x1*x2+y1*y2)==0?\"YES\":\"NO\");\n            \n        }\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double xA = sc.nextDouble();\n            double yA = sc.nextDouble();\n            double xB = sc.nextDouble();\n            double yB = sc.nextDouble();\n            double xC = sc.nextDouble();\n            double yC = sc.nextDouble();\n            double xD = sc.nextDouble();\n            double yD = sc.nextDouble();\n            \n            double dx1 = xB - xA;\n            double dy1 = yB - yA;\n            double dx2 = xD - xC;\n            double dy2 = yD - yC;\n            \n            double dotProduct = dx1 * dx2 + dy1 * dy2;\n            \n            if (Math.abs(dotProduct) < 1e-9) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { double xA =  double xB = sc.nextDouble(); double yB = sc.nextDouble(); double xC = sc.nextDouble(); double yC = sc.nextDouble(); double  = sc.nextDouble(); double dx1 = xB - xA; double dy1 = yB - yA; double  double dy2 = yD - yC; double dotProduct =  < 1e-9) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import  void main(String[] args) { Scanner sc=new Scanner(System.in); while(sc.hasNext()){ double[][]point=new double[4][2]; for(int i=0;i<4;i++){ point[i][0]=sc.nextDouble(); point[i][1]=sc.nextDouble(); } double x1=point[1][0]-point[0][0],y1=point[1][1]-point[0][1],x2=point[3][0]-point[2][0],y2=point[3][1]-point[2][1]; System.out.println((x1*x2+y1*y2)==0?\"YES\":\"NO\"); } } }"], "original_ll": -0.6098334193229675, "sampled_ll": -0.33978402614593506, "all_perturbed_sampled_ll": [-1.3291500806808472], "all_perturbed_original_ll": [-0.8009432554244995], "perturbed_sampled_ll": -1.3291500806808472, "perturbed_original_ll": -0.8009432554244995, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        xA,yA,xB,yB,xC,yC,xD,yD = map(float,raw_input().split())\n        if (100000*(yB-yA))*(100000*(yD-yC)) + (100000*(xB-xA))*(100000*(xD-xC)) < 1.e-10:\n            print \"YES\"\n        else:\n            print \"NO\"\n    except:\n        break", "sampled": "import sys\n\nfor line in sys.stdin:\n    coords = list(map(float, line.split()))\n    xa, ya, xb, yb, xc, yc, xd, yd = coords\n    \n    # Vector AB\n    vab_x = xb - xa\n    vab_y = yb - ya\n    \n    # Vector CD\n    vcd_x = xd - xc\n    vcd_y = yd - yc\n    \n    # Dot product\n    dot = vab_x * vcd_x + vab_y * vcd_y\n    \n    # Check if perpendicular (dot product is 0)\n    if abs(dot) < 1e-9:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys for line in sys.stdin:  ya, xb, yb, xc, yc, xd, yd = coords # Vector AB vab_x =  xd - xc vcd_y = yd - yc # Dot product dot = vab_x * vcd_x + vab_y * vcd_y # Check if perpendicular (dot product is 0) if abs(dot) < 1e-9: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["while  if (100000*(yB-yA))*(100000*(yD-yC)) + (100000*(xB-xA))*(100000*(xD-xC)) < 1.e-10: print \"YES\" else: print \"NO\" except: break"], "original_ll": -1.005983591079712, "sampled_ll": -0.742567241191864, "all_perturbed_sampled_ll": [-2.1513280868530273], "all_perturbed_original_ll": [-1.6959028244018555], "perturbed_sampled_ll": -2.1513280868530273, "perturbed_original_ll": -1.6959028244018555, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\n#include <stdlib.h>\n#include<string.h>\n#include<limits.h>\n\nint main(){\n\tdouble x[4],y[4];\n\tint i;\n\t\n\twhile(scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2],&x[3],&y[3])!=EOF){\n\t\n\t\tif(x[0]<=x[2] && x[1]>=x[2]){\n\t\t\tif((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t\telse if(x[0]<=x[3] && x[1]>=x[3]){\n\t\t\tif((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t\telse printf(\"NO\\n\");\n\t}\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2;\n    \n    while (scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n                  &xa1, &ya1, &xa2, &ya2, &xb1, &yb1, &xb2, &yb2) == 8) {\n        \n        if (xa2 >= xb1 && xb2 >= xa1 && ya2 >= yb1 && yb2 >= ya1) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2; while  %lf %lf %lf\", &xa1,  &xb2, &yb2) == 8) { if (xa2 >= xb1 && xb2 >= xa1 && ya2 >=  { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h> #include <stdlib.h> #include<string.h> #include<limits.h> int main(){ double x[4],y[4]; int i; while(scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2],&x[3],&y[3])!=EOF){ if(x[0]<=x[2] && x[1]>=x[2]){ if((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3]  else if(x[0]<=x[3] && x[1]>=x[3]){ if((y[0]<=y[2]  y[1]>=y[3]))printf(\"YES\\n\"); else printf(\"NO\\n\"); } else printf(\"NO\\n\"); } return 0; }"], "original_ll": -0.5573317408561707, "sampled_ll": -0.4627642333507538, "all_perturbed_sampled_ll": [-1.607199788093567], "all_perturbed_original_ll": [-0.85113525390625], "perturbed_sampled_ll": -1.607199788093567, "perturbed_original_ll": -0.85113525390625, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main {\n\tstatic double x1[]=new double[2];\n\tstatic double y1[]=new double[2];\n\tstatic double x2[]=new double[2];\n\tstatic double y2[]=new double[2];\n\tpublic static boolean check(double x,double y) {\n\t\tif(x1[0]<=x && x<=x1[1] && y1[0]<=y && y<=y1[1]){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static boolean check2(double x,double y) {\n\t\tif(x2[0]<=x && x<=x2[1] && y2[0]<=y && y<=y2[1]){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble tmp;\n\t\tint i,j;\n\t\twhile(sc.hasNext()){\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tx1[i]=sc.nextDouble();\n\t\t\t\ty1[i]=sc.nextDouble();\n\t\t\t}\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tx2[i]=sc.nextDouble();\n\t\t\t\ty2[i]=sc.nextDouble();\n\t\t\t}\n\t\t\tif(x1[1]<x1[0]){\n\t\t\t\ttmp=x1[1];\n\t\t\t\tx1[0]=x1[1];\n\t\t\t\tx1[1]=tmp;\n\t\t\t}\n\t\t\tif(y1[1]<y1[0]){\n\t\t\t\ttmp=y1[1];\n\t\t\t\ty1[0]=y1[1];\n\t\t\t\ty1[1]=tmp;\n\t\t\t}\n\t\t\tif(x2[1]<x2[0]){\n\t\t\t\ttmp=x2[1];\n\t\t\t\tx2[0]=x2[1];\n\t\t\t\tx2[1]=tmp;\n\t\t\t}\n\t\t\tif(y2[1]<y2[0]){\n\t\t\t\ttmp=y2[1];\n\t\t\t\ty2[0]=y2[1];\n\t\t\t\ty2[1]=tmp;\n\t\t\t}\n\t\t\tboolean f=false;\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t//System.out.println(f+\" \"+x2[i]+\" \"+y2[j]);\n\t\t\t\t\tif(f) break;\n\t\t\t\t\tf=check(x2[i],y2[j]);\n\t\t\t\t}\n\t\t\t}//\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t//System.out.println(f);\n\t\t\t\t\tif(f) break;\n\t\t\t\t\tf=check2(x1[i],y1[j]);\n\t\t\t\t}\n\t\t\t}//\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double xa1 = sc.nextDouble();\n            double ya1 = sc.nextDouble();\n            double xa2 = sc.nextDouble();\n            double ya2 = sc.nextDouble();\n            double xb1 = sc.nextDouble();\n            double yb1 = sc.nextDouble();\n            double xb2 = sc.nextDouble();\n            double yb2 = sc.nextDouble();\n            \n            boolean xOverlap = !(xa2 < xb1 || xb2 < xa1);\n            boolean yOverlap = !(ya2 < yb1 || yb2 < ya1);\n            \n            if (xOverlap && yOverlap) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in);  =  double xa2 = sc.nextDouble(); double ya2 = sc.nextDouble(); double xb1 = sc.nextDouble(); double  = sc.nextDouble(); double yb2 =  < xb1 || xb2 < xa1); boolean yOverlap = !(ya2 < yb1 || yb2 < ya1); if (xOverlap && yOverlap) { System.out.println(\"YES\"); } else {  }"], "perturbed_original": [" { static double x1[]=new double[2]; static double y1[]=new double[2]; static double x2[]=new double[2]; static double y2[]=new double[2]; public static boolean check(double  x<=x1[1] && y1[0]<=y && y<=y1[1]){ return true; } return false; } public static boolean  && x<=x2[1] && y2[0]<=y && y<=y2[1]){ return  public static void main(String[] args) { Scanner sc=new Scanner(System.in);   x2[i]=sc.nextDouble(); y2[i]=sc.nextDouble(); } if(x1[1]<x1[0]){ tmp=x1[1]; x1[0]=x1[1]; x1[1]=tmp; } if(y1[1]<y1[0]){ tmp=y1[1]; y1[0]=y1[1]; y1[1]=tmp;  } if(y2[1]<y2[0]){ tmp=y2[1]; y2[0]=y2[1]; y2[1]=tmp; } boolean f=false; for(i=0;i<2;i++){ for(j=0;j<2;j++){ //System.out.println(f+\" \"+x2[i]+\" \"+y2[j]); if(f) break; f=check(x2[i],y2[j]); } }// for(i=0;i<2;i++){ for(j=0;j<2;j++){ //System.out.println(f); if(f) break; f=check2(x1[i],y1[j]); } }// if(f){ System.out.println(\"YES\"); } else{ System.out.println(\"NO\"); } } } }"], "original_ll": -0.35558703541755676, "sampled_ll": -0.37563687562942505, "all_perturbed_sampled_ll": [-1.5325675010681152], "all_perturbed_original_ll": [-0.9210594296455383], "perturbed_sampled_ll": -1.5325675010681152, "perturbed_original_ll": -0.9210594296455383, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\n\nfor line in sys.stdin.readline():\n    xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2 = map(float, line.rstrip('\\n').split(' '))\n    if ((xb1<=xa1 and xa1<=xb2) or (xa1<=xb1 and xb1<=xa2)) and ((yb1<=ya2 and ya2<=yb2) or (ya1<=yb2 and yb2<=ya2)):\n        print 'YES'\n    else:\n        print 'NO'", "sampled": "import sys\n\nfor line in sys.stdin:\n    coords = []\n    coords.append(list(map(float, line.split())))\n    for _ in range(7):\n        coords.append(list(map(float, input().split())))\n    \n    xa1, ya1 = coords[0][0], coords[1][0]\n    xa2, ya2 = coords[2][0], coords[3][0]\n    xb1, yb1 = coords[4][0], coords[5][0]\n    xb2, yb2 = coords[6][0], coords[7][0]\n    \n    if xa2 >= xb1 and xb2 >= xa1 and ya2 >= yb1 and yb2 >= ya1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: coords = [] coords.append(list(map(float, line.split())))  input().split()))) xa1, ya1 = coords[0][0], coords[1][0]  xb1, yb1 = coords[4][0], coords[5][0] xb2, yb2 = coords[6][0], coords[7][0] if xa2 >= xb1 and xb2 >= xa1 and ya2  ya1: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["import sys for line in sys.stdin.readline(): xa1, ya1,  yb2 = map(float, line.rstrip('\\n').split(' ')) if ((xb1<=xa1 and xa1<=xb2) or (xa1<=xb1 and xb1<=xa2))  (ya1<=yb2 and yb2<=ya2)): print 'YES' else: print 'NO'"], "original_ll": -0.8934713006019592, "sampled_ll": -0.702441394329071, "all_perturbed_sampled_ll": [-1.5181158781051636], "all_perturbed_original_ll": [-1.9300591945648193], "perturbed_sampled_ll": -1.5181158781051636, "perturbed_original_ll": -1.9300591945648193, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main()\n{\n        int c1, c2, c3, i, cnt = 0;\n        int card[11];\n\n        for ( int i = 1 ; i < 11 ; i++ ) {\n                card[i] = 1;\n        }\n\n        while ( scanf( \"%d %d %d\", &c1, &c2, &c3 ) == 3 ) {\n                cnt = 0;\n                for ( i = 1 ; i < 11 ; i++ ) {\n                        if ( c1 != i && c2 != i && c3 != i ) {\n                                if ( c1 + c2 + i <= 20 ) {\n                                        cnt++;\n                                }\n                        }\n                }\n                if ( cnt >= 4 ) {\n                        printf( \"YES\\n\" );\n                } else {\n                        printf( \"NO\\n\" );\n                }\n        }\n        return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nint main() {\n    int c1, c2, c3;\n    \n    while (scanf(\"%d %d %d\", &c1, &c2, &c3) == 3) {\n        int current_sum = c1 + c2;\n        int max_allowed = 20 - current_sum;\n        \n        int count_valid = 0;\n        int count_total = 0;\n        \n        for (int i = 1; i <= 10; i++) {\n            if (i != c1 && i != c2 && i != c3) {\n                count_total++;\n                if (i <= max_allowed) {\n                    count_valid++;\n                }\n            }\n        }\n        \n        if (count_valid * 2 >= count_total) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int c1,  == 3) { int current_sum = c1 + c2; int max_allowed = 20 - current_sum; int count_valid =  1; i <= 10; i++) { if (i != c1 && i != c2 && i != c3) { count_total++; if  } } } if (count_valid * 2 >= count_total) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int main() { int c1, c2, c3, i, cnt = 0; int card[11]; for ( <extra_id_6>== 0 && cnt ==<extra_id_7>= 100; cnt++;<extra_id_8><= 22 ) { printf(<extra_id_9>}<extra_id_10>c3 < c2 + c1<extra_id_11>} i < 11 ; i++ ) { card[i] = 1; } <extra_id_12>{ printf( \"NO\\n\"<extra_id_13>} //println(\"c1<extra_id_14>c2 = c1 +<extra_id_15>c3 = e_8 ; // %d\", &c1, &c2,  { cnt  = 1 ; i < 11 ; i++ ) { if ( c1 != i && c2 != i && c3 != i ) { if ( c1 + c2 + i <= 20 ) { cnt++; } }   ); } else { printf( \"NO\\n\" ); } } return 0; }"], "original_ll": -0.781013548374176, "sampled_ll": -0.6711427569389343, "all_perturbed_sampled_ll": [-1.9928691387176514], "all_perturbed_original_ll": [-2.1897501945495605], "perturbed_sampled_ll": -1.9928691387176514, "perturbed_original_ll": -2.1897501945495605, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint count = 0;\n\t\t\tfor(int i=1;i<=10;i++){\n\t\t\t\tif(i!=a && i!=b && i!=c && a+b+i>20) count++;\n\t\t\t}\n\t\t\tif(count<=3) System.out.println(\"YES\");\n\t\t\telse System.out.println(\"NO\");\t\n\t\t}\n\t}\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int c1 = sc.nextInt();\n            int c2 = sc.nextInt();\n            int c3 = sc.nextInt();\n            \n            int currentSum = c1 + c2;\n            \n            // Count how many cards from remaining 7 cards would make sum <= 20\n            int count = 0;\n            for (int i = 1; i <= 10; i++) {\n                if (i != c1 && i != c2 && i != c3) {\n                    if (currentSum + i <= 20) {\n                        count++;\n                    }\n                }\n            }\n            \n            // Total remaining cards is 7 (10 - 3 known cards)\n            // Probability is count/7\n            // 50% or more means count/7 >= 0.5, which is count >= 3.5, so count >= 4\n            if (count * 2 >= 7) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  static void main(String[] args) {  while  sc.nextInt(); int c3 = sc.nextInt(); int currentSum = c1 + c2; // Count how many cards from remaining 7 cards would make sum <= 20 int count = 0; for (int i = 1; i <= 10; i++) { if (i != c1 && i != c2 && i != c3) { if (currentSum +  } } } //   // Probability is  means count/7 >= 0.5, which is count >= 3.5, so count >= 4 if (count * 2 >= 7) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main  args) { Scanner sc = new Scanner(System.in); while(sc.hasNext()){ int a = sc.nextInt(); int b = sc.nextInt();  i=1;i<=10;i++){ if(i!=a && i!=b && i!=c && a+b+i>20) count++; } if(count<=3) System.out.println(\"YES\"); else System.out.println(\"NO\"); } } }"], "original_ll": -0.84539395570755, "sampled_ll": -0.9197403192520142, "all_perturbed_sampled_ll": [-2.030154228210449], "all_perturbed_original_ll": [-1.6899769306182861], "perturbed_sampled_ll": -2.030154228210449, "perturbed_original_ll": -1.6899769306182861, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor x in sys.stdin:\n e=list(map(int,x.split()))\n print(['YES','NO'][len(set(range(1,21-sum(e[:2])))-set(e))/7<.5])\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    c1, c2, c3 = map(int, line.strip().split())\n    \n    current_sum = c1 + c2\n    used_cards = {c1, c2, c3}\n    \n    available_cards = []\n    for i in range(1, 11):\n        if i not in used_cards:\n            available_cards.append(i)\n    \n    valid_count = 0\n    for card in available_cards:\n        if current_sum + card <= 20:\n            valid_count += 1\n    \n    total_count = len(available_cards)\n    \n    if valid_count / total_count >= 0.5:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys for line in  map(int, line.strip().split()) current_sum = c1 + c2 used_cards = {c1, c2, c3} available_cards = [] for i in range(1, 11): if i not in used_cards: available_cards.append(i) valid_count = 0 for card in  1 total_count = len(available_cards) if valid_count / total_count >= 0.5: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["import sys for x in sys.stdin: e=list(map(int,x.split())) print(['YES','NO'][len(set(range(1,21-sum(e[:2])))-set(e))/7<.5])"], "original_ll": -3.1768813133239746, "sampled_ll": -0.9136961102485657, "all_perturbed_sampled_ll": [-2.042407989501953], "all_perturbed_original_ll": [-3.234931468963623], "perturbed_sampled_ll": -2.042407989501953, "perturbed_original_ll": -3.234931468963623, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint i,j,k;\n\tint team[100],score[100];\n\tint rank[100];\n\tint count,number,tmp1,tmp2,info;\n\t\n\tcount=0;\n\t//\u5165\u529b\n\tfor(i=0;i<100;i++)\n\t{\n\t\tscanf(\"%d,%d\",&team[i],&score[i]);\n\t\tif(team[i]+score[i]==0)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\t\n\t//\u4e26\u3073\u66ff\u3048\n\tfor(i=0;i<count;i++)\n\t{\n\t\tfor(j=count-1;j>i;j--)\n\t\t{\n\t\t\tif(score[i]<=score[j])\n\t\t\t{\n\t\t\t\ttmp1=score[i];\n\t\t\t\tscore[i]=score[j];\n\t\t\t\tscore[j]=tmp1;\n\t\t\t\t\n\t\t\t\ttmp1=team[i];\n\t\t\t\tteam[i]=team[j];\n\t\t\t\tteam[j]=tmp1;\n\t\t\t}\n\t\t}\n\t}\n\t//\u9806\u4f4d\u4ed8\u3051\n\tnumber=1;\n\trank[0]=number;\n\ttmp2=score[0];\n\tfor(i=1;i<count;i++)\n\t{\n\t\t//printf(\"%d %d\\n\",score[i],tmp2);\n\t\tif(score[i]!=tmp2)\n\t\t{\n\t\t\tnumber++;\n\t\t\ttmp2=score[i];\n\t\t}\n\t\trank[i]=number;\n\t}\n\t\n\t\n\t//\u554f\u3044\u5408\u308f\u305b\n\twhile(scanf(\"%d\",&info)!=EOF)\n\t{\n\t\tfor(i=0;i<count;i++)\n\t\t{\n\t\t\tif(info==team[i])\n\t\t\t\tprintf(\"%d\\n\",rank[i]);\n\t\t\t//printf(\"%d,%d\\n\",team[i],score[i]);\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int score;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    return tb->score - ta->score;\n}\n\nint main() {\n    Team teams[100];\n    int count = 0;\n    int id, score;\n    \n    while (1) {\n        scanf(\"%d,%d\", &id, &score);\n        if (id == 0 && score == 0) break;\n        teams[count].id = id;\n        teams[count].score = score;\n        count++;\n    }\n    \n    qsort(teams, count, sizeof(Team), compare);\n    \n    int query;\n    while (scanf(\"%d\", &query) != EOF) {\n        int target_score = -1;\n        for (int i = 0; i < count; i++) {\n            if (teams[i].id == query) {\n                target_score = teams[i].score;\n                break;\n            }\n        }\n        \n        int rank = 1;\n        int prev_score = -1;\n        int current_rank = 0;\n        \n        for (int i = 0; i < count; i++) {\n            if (teams[i].score != prev_score) {\n                current_rank++;\n                prev_score = teams[i].score;\n            }\n            if (teams[i].score == target_score) {\n                rank = current_rank;\n                break;\n            }\n        }\n        \n        printf(\"%d\\n\", rank);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef  score; } Team; int compare(const void *a, const void *b) { Team *ta = (Team *)a; Team *tb = (Team *)b; return tb->score - ta->score; } int main() {  while (1) { scanf(\"%d,%d\", &id, &score); if (id == 0 &&  =  } qsort(teams, count, sizeof(Team), compare); int query; while (scanf(\"%d\", &query) != EOF) { int target_score = -1; for (int i = 0; i < count; i++) { if (teams[i].id ==  break; } }  prev_score = -1; int current_rank = 0; for  < count; i++) { if (teams[i].score != prev_score) { current_rank++; prev_score = teams[i].score; } if (teams[i].score == target_score) {  } printf(\"%d\\n\", rank); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void)  int rank[100]; int count,number,tmp1,tmp2,info;  if(team[i]+score[i]==0) break; count++; } //\u4e26\u3073\u66ff\u3048 for(i=0;i<count;i++) { for(j=count-1;j>i;j--) { if(score[i]<=score[j]) { tmp1=score[i]; score[i]=score[j]; score[j]=tmp1; tmp1=team[i]; team[i]=team[j]; team[j]=tmp1; } } } //\u9806\u4f4d\u4ed8\u3051 number=1; rank[0]=number; tmp2=score[0]; for(i=1;i<count;i++) { //printf(\"%d %d\\n\",score[i],tmp2); if(score[i]!=tmp2) { number++; tmp2=score[i]; } rank[i]=number; } //\u554f\u3044\u5408\u308f\u305b while(scanf(\"%d\",&info)!=EOF) { for(i=0;i<count;i++) { if(info==team[i]) printf(\"%d\\n\",rank[i]);  }"], "original_ll": -0.6795074343681335, "sampled_ll": -0.42233705520629883, "all_perturbed_sampled_ll": [-1.3199666738510132], "all_perturbed_original_ll": [-1.3203017711639404], "perturbed_sampled_ll": -1.3199666738510132, "perturbed_original_ll": -1.3203017711639404, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString point[]= new String[100];\n\t\tint rank[]= new int[30];\n\t\tint n = 0;\n\t\tint count=0;\n\t\twhile(sc.hasNext()){\n\t\t\tString get = sc.next();\n\t\t\tif(get.equals(\"0,0\"))break;\n\t\t\tString str[] = get.split(\",\");\n\t\t\tpoint[n = Integer.parseInt(str[0])]=str[1];\n\t\t\trank[n= Integer.parseInt(str[1])-1]++;\n\t\t}\n\t\twhile(sc.hasNext()){\n\t\t\tcount=1;\n\t\t\tn = sc.nextInt();\n\t\t\tfor(int i = 29 ;i > Integer.parseInt(point[n]);i--){\n\t\t\t\tif(rank[i]>0)count++;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Map<Integer, Integer> teamScores = new HashMap<>();\n        \n        while (true) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int teamId = Integer.parseInt(parts[0]);\n            int score = Integer.parseInt(parts[1]);\n            \n            if (teamId == 0 && score == 0) {\n                break;\n            }\n            \n            teamScores.put(teamId, score);\n        }\n        \n        List<Integer> sortedScores = new ArrayList<>(teamScores.values());\n        Collections.sort(sortedScores, Collections.reverseOrder());\n        \n        Map<Integer, Integer> scoreToRank = new HashMap<>();\n        int rank = 1;\n        for (int score : sortedScores) {\n            if (!scoreToRank.containsKey(score)) {\n                scoreToRank.put(score, rank);\n                rank++;\n            }\n        }\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            int queryTeam = Integer.parseInt(line.trim());\n            int score = teamScores.get(queryTeam);\n            int teamRank = scoreToRank.get(score);\n            System.out.println(teamRank);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class   = new Scanner(System.in); Map<Integer, Integer> teamScores = new HashMap<>(); while (true) { String line = sc.nextLine(); String[] parts  Integer.parseInt(parts[0]); int score = Integer.parseInt(parts[1]); if (teamId == 0 && score == 0) { break; } teamScores.put(teamId, score); } List<Integer>  Collections.reverseOrder()); Map<Integer, Integer> scoreToRank = new HashMap<>(); int rank = 1; for (int score : sortedScores) {  rank++; } } while  sc.nextLine(); if (line.isEmpty()) break; int queryTeam = Integer.parseInt(line.trim()); int score = teamScores.get(queryTeam); int teamRank = scoreToRank.get(score); System.out.println(teamRank); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main{ public static void main(String args[]){ Scanner sc = new Scanner(System.in); String point[]= new String[100]; int rank[]= new  get = sc.next(); if(get.equals(\"0,0\"))break; String str[] = get.split(\",\"); point[n = Integer.parseInt(str[0])]=str[1]; rank[n= Integer.parseInt(str[1])-1]++; } while(sc.hasNext()){ count=1; n  29 ;i > Integer.parseInt(point[n]);i--){ if(rank[i]>0)count++; } System.out.println(count); } } }"], "original_ll": -1.2854968309402466, "sampled_ll": -0.5440812110900879, "all_perturbed_sampled_ll": [-1.606738567352295], "all_perturbed_original_ll": [-2.108427047729492], "perturbed_sampled_ll": -1.606738567352295, "perturbed_original_ll": -2.108427047729492, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "nums={}\nwhile True:\n    p,s=map(int,input().split(','))\n    if(p==0 and s==0):break\n    if not s in nums:\n        nums[s]=[]\n    nums[s].append(p)\n\nwhile True:\n    try:\n        q=int(input())\n        ans=len(nums)\n        for ns in nums.items():\n            if q in ns[1]:\n                print(ans)\n                break\n            ans-=1\n    except:\n        break", "sampled": "# Read team data\nteams = {}\nwhile True:\n    line = input().strip()\n    parts = line.split(',')\n    team_id = int(parts[0])\n    score = int(parts[1])\n    if team_id == 0 and score == 0:\n        break\n    teams[team_id] = score\n\n# Get unique scores and sort them in descending order\nunique_scores = sorted(set(teams.values()), reverse=True)\n\n# Create a mapping from score to rank\nscore_to_rank = {}\nfor i, score in enumerate(unique_scores):\n    score_to_rank[score] = i + 1\n\n# Process queries\nimport sys\nfor line in sys.stdin:\n    query = int(line.strip())\n    score = teams[query]\n    rank = score_to_rank[score]\n    print(rank)\n", "perturbed_sampled": ["# Read   parts = line.split(',') team_id = int(parts[0]) score  0  teams[team_id] = score # Get unique scores and sort them in descending  # Create a mapping from score to rank score_to_rank = {} for i, score in enumerate(unique_scores): score_to_rank[score] = i + 1 # Process queries import sys for line in sys.stdin: query = int(line.strip()) score = teams[query] rank = score_to_rank[score] print(rank)"], "perturbed_original": ["nums={} while True: p,s=map(int,input().split(',')) if(p==0 and s==0):break if not s in nums: nums[s]=[] nums[s].append(p) while True: try: q=int(input()) ans=len(nums) for ns in nums.items(): if  ans-=1 except: break"], "original_ll": -1.3787477016448975, "sampled_ll": -0.9182032346725464, "all_perturbed_sampled_ll": [-2.0380454063415527], "all_perturbed_original_ll": [-2.3958897590637207], "perturbed_sampled_ll": -2.0380454063415527, "perturbed_original_ll": -2.3958897590637207, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#define N 100\n\nvoid hanten(char str[],int n){\n  char t;\n  int i,j;\n    for (j=0;j<n/2;j++){\n      t=str[j];\n      str[j]=str[n-j-1];\n      str[n-j-1]=t;\n    }\n}\n\nint main()\n{\n  int i,j,cnt=0;\n  char str1[N],str2[N];\n  while (scanf(\"%s\",str1)!=EOF){\n    strcpy(str2,str1);\n    hanten(str1,strlen(str1));\n    if (strcmp(str1,str2)==0)\n      cnt++;\n  }\n  printf(\"%d\\n\",cnt);\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint isPalindrome(char *str) {\n    int len = strlen(str);\n    if (str[len-1] == '\\n') {\n        str[len-1] = '\\0';\n        len--;\n    }\n    \n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - 1 - i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char line[101];\n    int count = 0;\n    \n    while (fgets(line, sizeof(line), stdin) != NULL) {\n        if (isPalindrome(line)) {\n            count++;\n        }\n    }\n    \n    printf(\"%d\\n\", count);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int isPalindrome(char *str) { int len = strlen(str); if (str[len-1] == '\\n') { str[len-1] = '\\0'; len--;  0; i < len / 2; i++) {  1 - i]) { return 0; } }  { char line[101]; int count = 0; while (fgets(line, sizeof(line), stdin) != NULL) { if (isPalindrome(line)) { count++;  0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #define N 100 void hanten(char str[],int n){ char t; int i,j;  } } int main() {  (scanf(\"%s\",str1)!=EOF){ strcpy(str2,str1); hanten(str1,strlen(str1)); if (strcmp(str1,str2)==0) cnt++; } printf(\"%d\\n\",cnt); return 0; }"], "original_ll": -0.8853587508201599, "sampled_ll": -0.4585752785205841, "all_perturbed_sampled_ll": [-1.4747593402862549], "all_perturbed_original_ll": [-1.9548726081848145], "perturbed_sampled_ll": -1.4747593402862549, "perturbed_original_ll": -1.9548726081848145, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n    private static final Scanner scn = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int cnt = 0;\n        while(scn.hasNext()) {\n            String str = scn.next();\n            String rev = new String(new StringBuilder(str).reverse());\n            if(str.equals(rev)) {\n                cnt++;\n            }\n        }\n        System.out.println(cnt);\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (isPalindrome(line)) {\n                count++;\n            }\n        }\n        \n        System.out.println(count);\n        sc.close();\n    }\n    \n    static boolean isPalindrome(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in);  = sc.nextLine(); if (isPalindrome(line)) { count++; } } System.out.println(count); sc.close(); } static boolean isPalindrome(String s) { int left = 0;  1; while (left < right) { if (s.charAt(left) != s.charAt(right)) { return false; } left++;  }"], "perturbed_original": ["import java.util.*; public class Main { private static final Scanner scn = new Scanner(System.in); public static void main(String[] args) { int cnt = 0;  scn.next(); String rev =  cnt++; } } System.out.println(cnt); } }"], "original_ll": -0.8151882886886597, "sampled_ll": -0.3092479407787323, "all_perturbed_sampled_ll": [-1.1879377365112305], "all_perturbed_original_ll": [-2.2040512561798096], "perturbed_sampled_ll": -1.1879377365112305, "perturbed_original_ll": -2.2040512561798096, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef is_pal(s):\n    l = len(s)-1\n    for i in range(l/2):\n        if s[i] != s[l-1-i]:\n            return False\n    return True\n\ncount = 0\nfor line in sys.stdin:\n    if is_pal(line):\n        count += 1\nprint count", "sampled": "import sys\n\ncount = 0\nfor line in sys.stdin:\n    s = line.strip()\n    if s == s[::-1]:\n        count += 1\n\nprint(count)\n", "perturbed_sampled": ["import sys count = 0  = line.strip() if s == s[::-1]: count += 1 print(count)"], "perturbed_original": ["# -*- coding: utf-8 -*-   range(l/2): if s[i] != s[l-1-i]: return False return True count = 0 for line in sys.stdin: if is_pal(line): count += 1 print count"], "original_ll": -0.9505003094673157, "sampled_ll": -1.2730969190597534, "all_perturbed_sampled_ll": [-3.0273849964141846], "all_perturbed_original_ll": [-2.2136037349700928], "perturbed_sampled_ll": -3.0273849964141846, "perturbed_original_ll": -2.2136037349700928, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <ctype.h>\n\nint main()\n{\n        char str[81], tmp[6];\n        int num = 0, i, sum = 0;\n\n        while ( scanf( \"%s\", str ) == 1 ) {\n                i = 0;\n                while ( str[i] ) {\n                        if ( isdigit( str[i] ) ) {\n                                num = 0;\n                                while ( isdigit( str[i] ) ) {\n                                        num = 10 * num + ( str[i] - '0' );\n                                        i++;\n                                }\n                                sum = sum + num;\n                        } else {\n                                i++;\n                        }\n                }\n        }\n\n        printf( \"%d\\n\", sum );\n\n        return 0;\n}\n\n", "sampled": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    int sum = 0;\n    int num = 0;\n    int in_number = 0;\n    char c;\n    \n    while ((c = getchar()) != EOF) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n            in_number = 1;\n        } else {\n            if (in_number) {\n                sum += num;\n                num = 0;\n                in_number = 0;\n            }\n        }\n    }\n    \n    if (in_number) {\n        sum += num;\n    }\n    \n    printf(\"%d\\n\", sum);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <ctype.h>  = 0; int num = 0; int in_number = 0; char c; while ((c = getchar()) != EOF) { if (isdigit(c)) { num = num * 10  = 1; } else { if (in_number) { sum += num; num = 0;  sum += num; } printf(\"%d\\n\", sum); return 0; }"], "perturbed_original": ["#include <stdio.h>  char str[81], tmp[6]; int num  \"%s\", str ) == 1 ) { i = 0; while  ( isdigit( str[i] ) ) { num = 0; while ( isdigit( str[i] ) ) { num =  str[i] - '0' ); i++; } sum = sum + num; } else { i++; } } } printf( \"%d\\n\", sum ); return 0; }"], "original_ll": -0.7837428450584412, "sampled_ll": -0.4640091061592102, "all_perturbed_sampled_ll": [-1.4475971460342407], "all_perturbed_original_ll": [-1.8676010370254517], "perturbed_sampled_ll": -1.4475971460342407, "perturbed_original_ll": -1.8676010370254517, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = 0,sum = 0;\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] ch = sc.next().toCharArray();\n\t\tfor(int i = 0; i < ch.length; i++){\n\t\t\tif('0' <= ch[i] && ch[i] <= '9'){\n\t\t\t\tn = n * 10;\n\t\t\t\tn += ch[i] - '0';\n\t\t\t}else{\n\t\t\t\tsum += n;\n\t\t\t\tn = 0;\n\t\t\t}\n\t\t}\n\t\tsum += n;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t\tsc.close();\n\t}\n}", "sampled": "import java.util.*;\nimport java.util.regex.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int sum = 0;\n        Pattern pattern = Pattern.compile(\"\\\\d+\");\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            Matcher matcher = pattern.matcher(line);\n            \n            while (matcher.find()) {\n                sum += Integer.parseInt(matcher.group());\n            }\n        }\n        \n        System.out.println(sum);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.util.regex.*; public class Main { public static void  = new Scanner(System.in); int sum = 0; Pattern pattern = Pattern.compile(\"\\\\d+\"); while (sc.hasNextLine()) { String line = sc.nextLine();  (matcher.find()) { sum  sc.close(); } }"], "perturbed_original": [" public static void main(String[] args){ Scanner sc = new Scanner(System.in); int n = 0,sum = 0; while(sc.hasNext()){ char[]  = 0; i < ch.length; i++){ if('0' <= ch[i] && ch[i] <= '9'){ n = n * 10; n += ch[i] - '0'; }else{ sum +=  } sum +=  }"], "original_ll": -0.6309410333633423, "sampled_ll": -0.5350126624107361, "all_perturbed_sampled_ll": [-1.9886549711227417], "all_perturbed_original_ll": [-1.640803337097168], "perturbed_sampled_ll": -1.9886549711227417, "perturbed_original_ll": -1.640803337097168, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import re\nans = 0\nwhile True:\n    try:\n        line = input()\n    except:\n        print(ans)\n        break\n    ans += sum(map(int, re.findall(\"[0-9]+\", line)))", "sampled": "import sys\nimport re\n\ntotal = 0\nfor line in sys.stdin:\n    numbers = re.findall(r'\\d+', line)\n    for num in numbers:\n        total += int(num)\n\nprint(total)\n", "perturbed_sampled": ["import  0 for line in sys.stdin: numbers = re.findall(r'\\d+', line) for num in numbers: total += int(num) print(total)"], "perturbed_original": ["import re ans  line = input() except: print(ans) break ans += sum(map(int, re.findall(\"[0-9]+\", line)))"], "original_ll": -1.1135430335998535, "sampled_ll": -1.081687331199646, "all_perturbed_sampled_ll": [-1.9409534931182861], "all_perturbed_original_ll": [-3.4130403995513916], "perturbed_sampled_ll": -1.9409534931182861, "perturbed_original_ll": -3.4130403995513916, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\n#include <stdlib.h>\n#include<string.h>\n#include<limits.h>\n#include<time.h>\n\nvoid sosu(int n){\n\tint i,j,num[n];\n\t\n\tfor(i=2;i<=n;i++)num[i]=i;\n\tfor(i=2;i<=sqrt(n);i++){\n\t\tfor(j=2;j*i<=n;j++)num[j*i]=0;\n\t}\n}\n\nint main(){\n\tint number[10000]={0};\n\tint ac[10000]={0};\n\tint i,j,k,count;\n\t\n\tfor(i=0;scanf(\"%d,%d\",&number[i],&ac[i])!=EOF;i++);\n\tfor(j=i;scanf(\"%d,%d\",&number[j],&ac[j])!=EOF;j++);\n\tcount=j;\n\t\n\tfor(i=0;i<count;i++){\n\t\tfor(j=0;j<count;j++){\n\t\t\tif(number[i]<number[j]){\n\t\t\t\tk=number[i];\n\t\t\t\tnumber[i]=number[j];\n\t\t\t\tnumber[j]=k;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0,k=0;i<count;i++){\n\t\tfor(j=i;j<count;j++){\n\t\t\tif(number[i]==number[j] && i!=j)k++;\n\t\t}\n\t\ti+=k;\n\t\tif(k>=1)printf(\"%d %d\\n\",number[i],k+1);\n\t\tk=0;\n\t}\n\t\nreturn 0;\n\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int this_month[1001] = {0};\n    int last_month[1001] = {0};\n    int customer, day;\n    char line[100];\n    int reading_this_month = 1;\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        if (line[0] == '\\n' || strlen(line) <= 1) {\n            reading_this_month = 0;\n            continue;\n        }\n        \n        if (sscanf(line, \"%d,%d\", &customer, &day) == 2) {\n            if (reading_this_month) {\n                this_month[customer]++;\n            } else {\n                last_month[customer]++;\n            }\n        }\n    }\n    \n    for (int i = 1; i <= 1000; i++) {\n        if (this_month[i] > 0 && last_month[i] > 0) {\n            printf(\"%d %d\\n\", i, this_month[i] + last_month[i]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main()   customer, day; char  while (fgets(line, sizeof(line), stdin)) { if (line[0] == '\\n'  reading_this_month = 0; continue; } if (sscanf(line, \"%d,%d\", &customer, &day) == 2) { if (reading_this_month) { this_month[customer]++; } else  for (int i = 1; i <= 1000; i++) { if (this_month[i] > 0 && last_month[i] > 0) { printf(\"%d %d\\n\", i, this_month[i] + last_month[i]); } } return 0; }"], "perturbed_original": ["#include<stdio.h>  #include<time.h> void sosu(int n){ int i,j,num[n]; for(i=2;i<=n;i++)num[i]=i; for(i=2;i<=sqrt(n);i++){ for(j=2;j*i<=n;j++)num[j*i]=0; } } int main(){  for(i=0;i<count;i++){ for(j=0;j<count;j++){ if(number[i]<number[j]){ k=number[i]; number[i]=number[j]; number[j]=k; } } } for(i=0,k=0;i<count;i++){ for(j=i;j<count;j++){ if(number[i]==number[j] && i!=j)k++; } i+=k; if(k>=1)printf(\"%d %d\\n\",number[i],k+1); k=0; } return 0; }"], "original_ll": -0.9693806767463684, "sampled_ll": -0.7133219242095947, "all_perturbed_sampled_ll": [-1.5084816217422485], "all_perturbed_original_ll": [-1.2545002698898315], "perturbed_sampled_ll": -1.5084816217422485, "perturbed_original_ll": -1.2545002698898315, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.util.Map.Entry;\n\n//\u6587\u5b57\u64cd\u4f5c\nclass Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic void run() {\n\t\tHashtable<Integer,Integer> data1=new Hashtable<Integer, Integer>();\n\t\tHashtable<Integer,Integer> data2=new Hashtable<Integer, Integer>();\n\n\t\twhile(sc.hasNext()){\n\t\t\tString[] str=sc.nextLine().split(\",\");\n\t\t\tif(\"\".equals(str[0]))break;\n\t\t\tint[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])};\n\t\t\tif(data1.containsKey(vals[0])){\n\t\t\t\tdata1.put(vals[0],data1.get(vals[0])+1);\n\t\t\t}else{\n\t\t\t\tdata1.put(vals[0],1);\n\t\t\t}\n\t\t}\n\t\twhile(sc.hasNext()){\n\t\t\tString[] str=sc.nextLine().split(\",\");\n\t\t\tif(\"\".equals(str[0]))break;\n\t\t\tint[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])};\n\t\t\tif(data2.containsKey(vals[0])){\n\t\t\t\tdata2.put(vals[0],data2.get(vals[0])+1);\n\t\t\t}else{\n\t\t\t\tdata2.put(vals[0],1);\n\t\t\t}\n\t\t}\n\t\tArrayList<Entry<Integer,Integer>> data1list=new ArrayList<Entry<Integer,Integer>>(data1.entrySet());\n\t\tCollections.sort(data1list,new Comparator<Entry<Integer,Integer>>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Entry<Integer, Integer> o1,\n\t\t\t\t\tEntry<Integer, Integer> o2) {\n\t\t\t\treturn o1.getKey()-o2.getKey();\n\t\t\t}\n\t\t});\n\t\tfor(Entry<Integer,Integer> entry:data1list){\n\t\t\tif(data2.containsKey(entry.getKey())){\n\t\t\t\tln(entry.getKey()+\" \"+ (entry.getValue()+data2.get(entry.getKey())));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Map<Integer, Integer> thisMonth = new HashMap<>();\n        Map<Integer, Integer> lastMonth = new HashMap<>();\n        \n        // Read this month's data\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.trim().isEmpty()) {\n                break;\n            }\n            String[] parts = line.split(\",\");\n            int customer = Integer.parseInt(parts[0]);\n            thisMonth.put(customer, thisMonth.getOrDefault(customer, 0) + 1);\n        }\n        \n        // Read last month's data\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.trim().isEmpty()) {\n                break;\n            }\n            String[] parts = line.split(\",\");\n            int customer = Integer.parseInt(parts[0]);\n            lastMonth.put(customer, lastMonth.getOrDefault(customer, 0) + 1);\n        }\n        \n        // Find customers in both months\n        Set<Integer> commonCustomers = new HashSet<>(thisMonth.keySet());\n        commonCustomers.retainAll(lastMonth.keySet());\n        \n        // Sort and output\n        List<Integer> sortedCustomers = new ArrayList<>(commonCustomers);\n        Collections.sort(sortedCustomers);\n        \n        for (int customer : sortedCustomers) {\n            int total = thisMonth.get(customer) + lastMonth.get(customer);\n            System.out.println(customer + \" \" + total);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new  new HashMap<>(); Map<Integer, Integer> lastMonth =  month's data while (sc.hasNextLine()) { String  { break; } String[] parts = line.split(\",\"); int customer = Integer.parseInt(parts[0]); thisMonth.put(customer,  // Read last month's data while (sc.hasNextLine()) { String line = sc.nextLine(); if (line.trim().isEmpty()) { break; } String[] parts = line.split(\",\"); int customer = Integer.parseInt(parts[0]); lastMonth.put(customer, lastMonth.getOrDefault(customer, 0)  Set<Integer> commonCustomers = new HashSet<>(thisMonth.keySet()); commonCustomers.retainAll(lastMonth.keySet()); // Sort and output List<Integer> sortedCustomers = new ArrayList<>(commonCustomers); Collections.sort(sortedCustomers); for  + lastMonth.get(customer); System.out.println(customer + \" \" + total); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.util.Map.Entry; //\u6587\u5b57\u64cd\u4f5c class Main { Scanner sc = new Scanner(System.in); public void run() { Hashtable<Integer,Integer> data1=new Hashtable<Integer, Integer>(); Hashtable<Integer,Integer> data2=new Hashtable<Integer, Integer>(); i<extra_id_3>. print (<extra_id_4>= \"<extra_id_5>//\u5b58\u5728\u7ae0\u8ba1\u7b97<extra_id_6>entry1<extra_id_7>return (data2.entrySet().size();<extra_id_8>entry2.get(entry2.getKey())); i .<extra_id_9>)<extra_id_10>, int ]<extra_id_11>\" ) ; } }<extra_id_12>void ln(Object o)<extra_id_13>{<extra_id_14>; }  data1.put(vals[0],1); } } while(sc.hasNext()){ String[] str=sc.nextLine().split(\",\"); if(\"\".equals(str[0]))break; int[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])}; if(data2.containsKey(vals[0])){ data2.put(vals[0],data2.get(vals[0])+1); }else{ data2.put(vals[0],1); } } ArrayList<Entry<Integer,Integer>> data1list=new ArrayList<Entry<Integer,Integer>>(data1.entrySet()); Collections.sort(data1list,new Comparator<Entry<Integer,Integer>>() { @Override public int compare(Entry<Integer, Integer> o1, Entry<Integer,  } });  (entry.getValue()+data2.get(entry.getKey()))); } } } public static void main(String[]  public static void pr(Object o) { System.out.print(o); } public static void ln(Object o) {  ln() { System.out.println(); } }"], "original_ll": -0.6314448118209839, "sampled_ll": -0.4193880259990692, "all_perturbed_sampled_ll": [-1.450933575630188], "all_perturbed_original_ll": [-2.0231475830078125], "perturbed_sampled_ll": -1.450933575630188, "perturbed_original_ll": -2.0231475830078125, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nb=0\na=[{},{}]\nfor e in sys.stdin:\n if'\\n'==e:b=1\n else:c=int(e.split(',')[0]);a[b].setdefault(c,0);a[b][c]+=1\nfor k in sorted({*a[0]}&{*a[1]}):print(k,a[0][k]+a[1][k])\n", "sampled": "import sys\n\n# Read all input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.strip())\n\n# Find the empty line that separates this month and last month\nseparator_idx = -1\nfor i, line in enumerate(lines):\n    if line == '':\n        separator_idx = i\n        break\n\n# Parse this month's data\nthis_month = lines[:separator_idx]\nlast_month = lines[separator_idx + 1:]\n\n# Count transactions for each customer\nthis_month_customers = {}\nlast_month_customers = {}\n\nfor line in this_month:\n    if line:\n        parts = line.split(',')\n        customer_id = int(parts[0])\n        this_month_customers[customer_id] = this_month_customers.get(customer_id, 0) + 1\n\nfor line in last_month:\n    if line:\n        parts = line.split(',')\n        customer_id = int(parts[0])\n        last_month_customers[customer_id] = last_month_customers.get(customer_id, 0) + 1\n\n# Find customers who appear in both months\ncommon_customers = set(this_month_customers.keys()) & set(last_month_customers.keys())\n\n# Calculate total transactions and sort by customer ID\nresults = []\nfor customer_id in common_customers:\n    total_transactions = this_month_customers[customer_id] + last_month_customers[customer_id]\n    results.append((customer_id, total_transactions))\n\nresults.sort()\n\n# Output\nfor customer_id, total in results:\n    print(customer_id, total)\n", "perturbed_sampled": ["import sys  in sys.stdin:  line that separates this month and last month separator_idx  in enumerate(lines): if line == '': separator_idx = i break # Parse this month's data this_month = lines[:separator_idx] last_month = lines[separator_idx + 1:] # Count transactions for each customer this_month_customers = {} last_month_customers = {} for line in this_month: if line: parts = line.split(',') customer_id = int(parts[0]) this_month_customers[customer_id] = this_month_customers.get(customer_id, 0)  last_month: if line: parts = line.split(',')  last_month_customers.get(customer_id, 0) + 1 # Find customers who appear in both months common_customers = set(this_month_customers.keys()) & set(last_month_customers.keys()) # Calculate total transactions and sort by customer ID results = [] for customer_id  + last_month_customers[customer_id] results.append((customer_id, total_transactions)) results.sort() #  results: print(customer_id, total)"], "perturbed_original": ["import sys b=0 a=[{},{}] for e in sys.stdin: if'\\n'==e:b=1 else:c=int(e.split(',')[0]);a[b].setdefault(c,0);a[b][c]+=1 for k in sorted({*a[0]}&{*a[1]}):print(k,a[0][k]+a[1][k])"], "original_ll": -1.8674256801605225, "sampled_ll": -0.6689382791519165, "all_perturbed_sampled_ll": [-1.7899523973464966], "all_perturbed_original_ll": [-2.0769424438476562], "perturbed_sampled_ll": -1.7899523973464966, "perturbed_original_ll": -2.0769424438476562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nchar map[16][16] = {0};\n\nvoid delete_island(int x, int y)\n{\n\tif (map[x][y] == 0) return;\n\tmap[x][y] = 0;\n\tdelete_island(x - 1, y);\n\tdelete_island(x + 1, y);\n\tdelete_island(x, y - 1);\n\tdelete_island(x, y + 1);\n}\n\nint main(void)\n{\n\twhile (scanf(\"%s\", &map[0][1]) != EOF){\n\t\tint i, j;\n\t\tint count = 0;\n\t\t\n\t\tfor (i = 1; i < 12; i++) scanf(\"%s\", &map[i][1]);\n\t\tfor (i = 0; i < 12; i++){\n\t\t\tfor (j = 0; j < 12; j++) map[i][j + 1] -= '0';\n\t\t}\n\t\t\n\t\tfor (i = 0; i < 12; i++){\n\t\t\tfor (j = 0; j < 12; j++){\n\t\t\t\tif (map[i][j + 1] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tdelete_island(i, j + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", count);\n\t\tscanf(\"%*c\");\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint grid[12][12];\nint visited[12][12];\n\nvoid dfs(int i, int j) {\n    if (i < 0 || i >= 12 || j < 0 || j >= 12) return;\n    if (grid[i][j] == 0 || visited[i][j]) return;\n    \n    visited[i][j] = 1;\n    \n    dfs(i-1, j);\n    dfs(i+1, j);\n    dfs(i, j-1);\n    dfs(i, j+1);\n}\n\nint main() {\n    char line[100];\n    \n    while (1) {\n        int hasInput = 0;\n        \n        for (int i = 0; i < 12; i++) {\n            if (fgets(line, sizeof(line), stdin) == NULL) {\n                return 0;\n            }\n            \n            if (strlen(line) > 1 && line[0] != '\\n') {\n                hasInput = 1;\n                for (int j = 0; j < 12; j++) {\n                    grid[i][j] = line[j] - '0';\n                }\n            } else if (strlen(line) <= 1 || line[0] == '\\n') {\n                if (!hasInput) {\n                    i--;\n                    continue;\n                } else {\n                    return 0;\n                }\n            }\n        }\n        \n        if (!hasInput) break;\n        \n        memset(visited, 0, sizeof(visited));\n        \n        int islands = 0;\n        for (int i = 0; i < 12; i++) {\n            for (int j = 0; j < 12; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    dfs(i, j);\n                    islands++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", islands);\n        \n        while (fgets(line, sizeof(line), stdin) != NULL) {\n            if (line[0] != '\\n' && strlen(line) > 1) {\n                fseek(stdin, -(long)strlen(line), SEEK_CUR);\n                break;\n            }\n            if (feof(stdin)) return 0;\n        }\n        \n        if (feof(stdin)) break;\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int grid[12][12]; int  j) { if (i < 0 || i >= 12 || j < 0 || j >= 12) return; if (grid[i][j] == 0 || visited[i][j]) return; visited[i][j] = 1; dfs(i-1, j); dfs(i+1, j); dfs(i, j-1); dfs(i, j+1); } int main() { char line[100]; while (1) { int hasInput = 0; for (int i = 0; i < 12; i++) { if (fgets(line, sizeof(line), stdin) == NULL)  (strlen(line) > 1 && line[0] != '\\n') { hasInput = 1; for (int j = 0; j < 12; j++) { grid[i][j] = line[j]  if (strlen(line)  '\\n') { if (!hasInput) { i--; continue;  } }  0, sizeof(visited)); int islands = 0; for (int  12; i++) { for (int j = 0; j < 12; j++)  j); islands++; } } } printf(\"%d\\n\", islands); while (fgets(line,  if (line[0]  1) { fseek(stdin, -(long)strlen(line), SEEK_CUR); break; } if (feof(stdin)) return  } return 0; }"], "perturbed_original": ["#include <stdio.h> char map[16][16] = {0}; void delete_island(int x, int y) { if (map[x][y] ==  delete_island(x + 1, y); delete_island(x, y - 1); delete_island(x,  main(void) { while (scanf(\"%s\", &map[0][1]) != EOF){ int i, j; int  = 1; i < 12; i++) scanf(\"%s\", &map[i][1]); for (i = 0; i < 12; i++){ for (j =  map[i][j + 1] -= '0'; } for (i = 0;  (j = 0; j < 12;  == 1){ count++; delete_island(i, j + 1); } } } printf(\"%d\\n\", count); scanf(\"%*c\"); } return 0; }"], "original_ll": -0.6007340550422668, "sampled_ll": -0.44625216722488403, "all_perturbed_sampled_ll": [-1.2658770084381104], "all_perturbed_original_ll": [-1.6086660623550415], "perturbed_sampled_ll": -1.2658770084381104, "perturbed_original_ll": -1.6086660623550415, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u30fb\u30b9\u30bf\u30d6\n\t\tnew Main().run();\n\t}\n\t\n\tint filed[][]=new int[12][12];\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint count=0;\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tchar ch[]=sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\t\tfiled[i][j]=ch[j]-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\t\tif(filed[i][j]==1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tdfs(j,i,12,12);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n    int mx[]={-1,0,1,0};\n    int my[]={0,-1,0,1};\n\tvoid dfs(int x,int y,int w,int h){\n        int i,nx,ny;\n        for(i=0;i<4;i++){\n            nx=x+mx[i];\n            ny=y+my[i];\n            if(0<=nx && nx<w && 0<=ny && ny<h && filed[ny][nx]!=0){\n                filed[ny][nx]=0;\n                dfs(nx,ny,w,h);\n            }\n        }\n    }\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[][] grid;\n    static boolean[][] visited;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            grid = new int[12][12];\n            visited = new boolean[12][12];\n            \n            // Read 12 lines for the grid\n            boolean validInput = true;\n            for (int i = 0; i < 12; i++) {\n                if (!sc.hasNextLine()) {\n                    validInput = false;\n                    break;\n                }\n                String line = sc.nextLine().trim();\n                if (line.isEmpty()) {\n                    validInput = false;\n                    break;\n                }\n                for (int j = 0; j < 12 && j < line.length(); j++) {\n                    grid[i][j] = line.charAt(j) - '0';\n                }\n            }\n            \n            if (!validInput) {\n                break;\n            }\n            \n            // Count islands\n            int islands = 0;\n            for (int i = 0; i < 12; i++) {\n                for (int j = 0; j < 12; j++) {\n                    if (grid[i][j] == 1 && !visited[i][j]) {\n                        dfs(i, j);\n                        islands++;\n                    }\n                }\n            }\n            \n            System.out.println(islands);\n            \n            // Skip empty line between datasets\n            if (sc.hasNextLine()) {\n                String line = sc.nextLine();\n                // If the line is not empty, we need to check if it's the start of next dataset\n                if (!line.trim().isEmpty()) {\n                    // This is the first line of next dataset\n                    grid = new int[12][12];\n                    visited = new boolean[12][12];\n                    \n                    // Process this first line\n                    for (int j = 0; j < 12 && j < line.length(); j++) {\n                        grid[0][j] = line.charAt(j) - '0';\n                    }\n                    \n                    // Read remaining 11 lines\n                    for (int i = 1; i < 12; i++) {\n                        if (!sc.hasNextLine()) break;\n                        line = sc.nextLine().trim();\n                        if (line.isEmpty()) break;\n                        for (int j = 0; j < 12 && j < line.length(); j++) {\n                            grid[i][j] = line.charAt(j) - '0';\n                        }\n                    }\n                    \n                    // Count islands\n                    islands = 0;\n                    for (int i = 0; i < 12; i++) {\n                        for (int j = 0; j < 12; j++) {\n                            if (grid[i][j] == 1 && !visited[i][j]) {\n                                dfs(i, j);\n                                islands++;\n                            }\n                        }\n                    }\n                    \n                    System.out.println(islands);\n                    \n                    // Skip empty line\n                    if (sc.hasNextLine()) {\n                        sc.nextLine();\n                    }\n                }\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static void dfs(int x, int y) {\n        visited[x][y] = true;\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if (nx >= 0 && nx < 12 && ny >= 0 && ny < 12 && \n                grid[nx][ny] == 1 && !visited[nx][ny]) {\n                dfs(nx, ny);\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  grid; static boolean[][] visited; static int[] dx  static int[] dy = {0, 0, -1, 1}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { grid = new int[12][12]; visited = new boolean[12][12]; // Read 12 lines for the grid boolean validInput = true; for (int i = 0; i <  { validInput = false; break; } String line =  0; j < 12 && j < line.length(); j++) { grid[i][j]  } if (!validInput) { break; } // Count islands int  i = 0; i < 12; i++) { for  < 12; j++) { if (grid[i][j] == 1 && !visited[i][j]) { dfs(i, j); islands++; }  empty line between datasets if (sc.hasNextLine()) { String line = sc.nextLine(); // If the line is not empty, we need to check if it's the  (!line.trim().isEmpty()) { //  of next dataset grid = new int[12][12]; visited = new boolean[12][12]; // Process this first line for (int j = 0; j < 12  { grid[0][j] = line.charAt(j) - '0'; } // Read remaining 11 lines  { if (!sc.hasNextLine()) break; line = sc.nextLine().trim(); if  = 0; j  line.length(); j++) { grid[i][j] = line.charAt(j) - '0'; } } // Count islands islands = 0; for (int i = 0; i < 12; i++) { for (int j = 0; j < 12; j++) { if (grid[i][j] == 1 && !visited[i][j])  Skip empty line if (sc.hasNextLine()) { sc.nextLine(); }  = true; for (int i = 0; i < 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if (nx >= 0 && nx < 12  ny < 12 && grid[nx][ny] == 1 && !visited[nx][ny]) { dfs(nx, ny); } } } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static  } int filed[][]=new int[12][12]; void run(){ Scanner sc=new Scanner(System.in); while(sc.hasNext()){  ch[]=sc.next().toCharArray(); for(int j=0;j<12;j++){ filed[i][j]=ch[j]-'0'; } } for(int i=0;i<12;i++){  } } } System.out.println(count); } } int mx[]={-1,0,1,0}; int my[]={0,-1,0,1}; void dfs(int x,int y,int w,int h){ int i,nx,ny; for(i=0;i<4;i++){ nx=x+mx[i]; ny=y+my[i]; if(0<=nx && nx<w && 0<=ny && ny<h && filed[ny][nx]!=0){ filed[ny][nx]=0; dfs(nx,ny,w,h); } } } }"], "original_ll": -0.6422930955886841, "sampled_ll": -0.3691549301147461, "all_perturbed_sampled_ll": [-1.234434723854065], "all_perturbed_original_ll": [-1.1823822259902954], "perturbed_sampled_ll": -1.234434723854065, "perturbed_original_ll": -1.1823822259902954, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Depth_First_Search_stack:\n    def __init__(self, map):\n        self.map = map\n        self.num_island = 0\n        self.stack = []\n        self.start_point = None\n\n    def get_start_point(self):\n        get_start = False\n        for i in range(12):\n            for j in range(12):\n                if self.map[i][j] == '1':\n                    self.start_point = [i, j]\n                    get_start = True\n        return get_start\n\n    def check(self, new_r, new_c):\n        return 0<=new_r<12 and 0<=new_c<12 and self.map[new_r][new_c] == '1'\n\n    def search(self, r, c):\n        while self.stack:\n            r, c = self.stack.pop()\n            self.map[r][c] = '0'\n            for (i, j) in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n                if self.check(r+i, c+j):\n                    self.stack.append([r+i, c+j])\n\n    def run(self):\n        while self.get_start_point():\n            r, c = self.start_point\n            self.stack.append([r, c])\n            self.search(r, c)\n            self.num_island += 1\n\nif __name__ == '__main__':\n    while 1:\n        map = []\n        for i in range(12):\n            row = [x for x in input()]\n            map.append(row)\n\n        if len(map[0]) != 12:\n            break\n\n        DFS = Depth_First_Search_stack(map)\n        DFS.run()\n        print(DFS.num_island)\n\n        empty = input()", "sampled": "import sys\nfrom collections import deque\n\ndef count_islands(grid):\n    rows = 12\n    cols = 12\n    visited = [[False] * cols for _ in range(rows)]\n    count = 0\n    \n    def bfs(start_r, start_c):\n        queue = deque([(start_r, start_c)])\n        visited[start_r][start_c] = True\n        \n        while queue:\n            r, c = queue.popleft()\n            # Check 4 directions: up, down, left, right\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == 1:\n                    visited[nr][nc] = True\n                    queue.append((nr, nc))\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1 and not visited[i][j]:\n                bfs(i, j)\n                count += 1\n    \n    return count\n\ndef main():\n    lines = []\n    for line in sys.stdin:\n        lines.append(line.rstrip('\\n'))\n    \n    datasets = []\n    current_dataset = []\n    \n    for line in lines:\n        if line == '':\n            if current_dataset:\n                datasets.append(current_dataset)\n                current_dataset = []\n        else:\n            current_dataset.append(line)\n    \n    if current_dataset:\n        datasets.append(current_dataset)\n    \n    for dataset in datasets:\n        grid = []\n        for line in dataset:\n            row = [int(c) for c in line]\n            grid.append(row)\n        \n        result = count_islands(grid)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from collections import deque def count_islands(grid): rows = 12 cols = 12 visited  _ in range(rows)] count = 0 def bfs(start_r,  visited[start_r][start_c] = True while queue: r, c = queue.popleft() # Check 4 directions: up, down, left, right for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < rows  cols and not visited[nr][nc] and grid[nr][nc] ==  range(rows): for j in range(cols): if grid[i][j] == 1 and not visited[i][j]: bfs(i, j) count += 1 return count def main(): lines = [] for line in sys.stdin: lines.append(line.rstrip('\\n')) datasets =  line == '': if current_dataset: datasets.append(current_dataset) current_dataset = [] else: current_dataset.append(line) if  datasets:  in dataset:  in line] grid.append(row) result = count_islands(grid) print(result) if __name__ == \"__main__\": main()"], "perturbed_original": ["class Depth_First_Search_stack: def __init__(self, map): self.map = map self.num_island  self.start_point = None def get_start_point(self): get_start = False for i in range(12): for j in range(12): if self.map[i][j] == '1': self.start_point = [i, j] get_start  check(self, new_r, new_c): return 0<=new_r<12 and 0<=new_c<12 and self.map[new_r][new_c] == '1' def  r, c = self.stack.pop() self.map[r][c] = '0' for (i, j) in [[1, 0], [0, 1], [-1, 0], [0, -1]]: if self.check(r+i, c+j): self.stack.append([r+i, c+j])  c]) self.search(r, c) self.num_island += 1 if __name__ == '__main__':  for i  for x in input()] map.append(row) if len(map[0]) != 12: break  empty = input()"], "original_ll": -0.6992121338844299, "sampled_ll": -0.3730326294898987, "all_perturbed_sampled_ll": [-1.4275810718536377], "all_perturbed_original_ll": [-1.6375138759613037], "perturbed_sampled_ll": -1.4275810718536377, "perturbed_original_ll": -1.6375138759613037, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x,y;\n} xy_t;\n\nint qsort_comp(const void* x,const void* y) {\n\tconst xy_t* a=(const xy_t*)x;\n\tconst xy_t* b=(const xy_t*)y;\n\tif((a->x)>(b->x))return 1;\n\tif((a->x)<(b->x))return -1;\n\tif((a->y)>(b->y))return 1;\n\tif((a->y)<(b->y))return -1;\n\treturn 0;\n}\n\nint zahyou_num;\nxy_t zahyou[100];\n\nint th_up_n;\nint th_down_n;\nxy_t th_up[100];\nxy_t th_down[100];\n\nint main(void) {\n\tint i;\n\twhile(1) {\n\t\tscanf(\"%d\",&zahyou_num);\n\t\tif(zahyou_num==0)break;\n\t\tfor(i=0;i<zahyou_num;i++) {\n\t\t\tscanf(\"%lf,%lf\",&zahyou[i].x,&zahyou[i].y);\n\t\t}\n\t\tqsort(zahyou,zahyou_num,sizeof(xy_t),qsort_comp);\n\t\t//sita no totu-ho\n\t\tth_down_n=1;\n\t\tth_down[0].x=zahyou[0].x;\n\t\tth_down[0].y=zahyou[0].y;\n\t\tfor(i=1;i<zahyou_num;i++) {\n\t\t\t//if(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\twhile(th_down_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_down[th_down_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_down[th_down_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_down[th_down_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_down[th_down_n-1].x==th_down[th_down_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_down[th_down_n-1].y<th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else if(th_down[th_down_n-1].y>th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_down[th_down_n-1].y-th_down[th_down_n-2].y)/\n\t\t\t\t\t\t   (th_down[th_down_n-1].x-th_down[th_down_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_down_n--;\n\t\t\t\t}\n\t\t\t//}\n\t\t\tth_down[th_down_n].x=zahyou[i].x;\n\t\t\tth_down[th_down_n].y=zahyou[i].y;\n\t\t\tth_down_n++;\n\t\t}\n\t\t//ue no totu-ho\n\t\tth_up_n=1;\n\t\tth_up[0].x=zahyou[zahyou_num-1].x;\n\t\tth_up[0].y=zahyou[zahyou_num-1].y;\n\t\tfor(i=zahyou_num-2;i>=0;i--) {\n\t\t\t//if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\twhile(th_up_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_up[th_up_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_up[th_up_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_up[th_up_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_up[th_up_n-1].x==th_up[th_up_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_up[th_up_n-1].y<th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else if(th_up[th_up_n-1].y>th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_up[th_up_n-1].y-th_up[th_up_n-2].y)/\n\t\t\t\t\t\t   (th_up[th_up_n-1].x-th_up[th_up_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_up_n--;\n\t\t\t\t}\n\t\t\t//}\n\t\t\tth_up[th_up_n].x=zahyou[i].x;\n\t\t\tth_up[th_up_n].y=zahyou[i].y;\n\t\t\tth_up_n++;\n\t\t}\n\t\tprintf(\"%d\\n\",zahyou_num-(th_down_n+th_up_n-2));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross(Point O, Point A, Point B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nint convexHull(Point points[], int n, int hull[]) {\n    int k = 0;\n    \n    // Find bottommost point (or leftmost in case of tie)\n    int minIdx = 0;\n    for (int i = 1; i < n; i++) {\n        if (points[i].y < points[minIdx].y || \n            (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {\n            minIdx = i;\n        }\n    }\n    \n    // Start from bottommost point\n    int current = minIdx;\n    do {\n        hull[k++] = current;\n        int next = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == current) continue;\n            \n            if (next == current) {\n                next = i;\n            } else {\n                double cp = cross(points[current], points[next], points[i]);\n                if (cp < 0 || (cp == 0 && \n                    (pow(points[i].x - points[current].x, 2) + pow(points[i].y - points[current].y, 2)) >\n                    (pow(points[next].x - points[current].x, 2) + pow(points[next].y - points[current].y, 2)))) {\n                    next = i;\n                }\n            }\n        }\n        current = next;\n    } while (current != minIdx);\n    \n    return k;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Point points[100];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf,%lf\", &points[i].x, &points[i].y);\n        }\n        \n        if (n == 3) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        int hull[100];\n        int hullSize = convexHull(points, n, hull);\n        \n        printf(\"%d\\n\", n - hullSize);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> typedef struct { double x, y; }  return (A.x - O.x) * (B.y - O.y)   convexHull(Point points[], int n, int hull[]) { int k = 0; // Find bottommost point (or leftmost in case of tie) int minIdx =  1; i < n; i++) {  (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {  //  current = minIdx; do { hull[k++] = current; int  i = 0; i < n; i++) { if (i == current) continue; if (next ==  cp = cross(points[current], points[next], points[i]); if (cp  0 && (pow(points[i].x - points[current].x, 2) + pow(points[i].y - points[current].y, 2)) > (pow(points[next].x - points[current].x, 2) + pow(points[next].y - points[current].y, 2)))) { next = i; } } } current = next; } while (current != minIdx); return k; } int main() { int n; while (scanf(\"%d\", &n) == 1 && n != 0) { Point points[100]; for (int i = 0; i < n; i++) { scanf(\"%lf,%lf\", &points[i].x, &points[i].y); } if (n ==  = convexHull(points, n, hull); printf(\"%d\\n\", n - hullSize); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> typedef struct { double x,y; } xy_t; int qsort_comp(const  const xy_t* b=(const xy_t*)y; if((a->x)>(b->x))return 1; if((a->x)<(b->x))return -1; if((a->y)>(b->y))return 1; if((a->y)<(b->y))return -1; return 0; } int zahyou_num; xy_t zahyou[100]; int th_up_n; int th_down_n; xy_t th_up[100]; xy_t  i; while(1) { scanf(\"%d\",&zahyou_num); if(zahyou_num==0)break; for(i=0;i<zahyou_num;i++) { scanf(\"%lf,%lf\",&zahyou[i].x,&zahyou[i].y); } qsort(zahyou,zahyou_num,sizeof(xy_t),qsort_comp); //sita no totu-ho th_down_n=1; th_down[0].x=zahyou[0].x; th_down[0].y=zahyou[0].y; for(i=1;i<zahyou_num;i++) { //if(zahyou[i].y<th_down[th_down_n-1].y) { while(th_down_n>1) { double k1,k2; if(zahyou[i].x==th_down[th_down_n-1].x) { //INF if(zahyou[i].y<th_down[th_down_n-1].y) { k1=-1e+200; } else if(zahyou[i].y>th_down[th_down_n-1].y) { k1=1e+200; } else k1=0; } else { k1=(zahyou[i].y-th_down[th_down_n-1].y)/ (zahyou[i].x-th_down[th_down_n-1].x); } if(th_down[th_down_n-1].x==th_down[th_down_n-2].x) { //INF if(th_down[th_down_n-1].y<th_down[th_down_n-2].y) { k2=-1e+200; } else if(th_down[th_down_n-1].y>th_down[th_down_n-2].y) {  else  th_down_n--; } //} th_down[th_down_n].x=zahyou[i].x; th_down[th_down_n].y=zahyou[i].y; th_down_n++;  th_up[0].x=zahyou[zahyou_num-1].x; th_up[0].y=zahyou[zahyou_num-1].y;  k1=1e+200; } else if(zahyou[i].y>th_up[th_up_n-1].y) { k1=-1e+200; } else k1=0; } else { k1=(zahyou[i].y-th_up[th_up_n-1].y)/ (zahyou[i].x-th_up[th_up_n-1].x);  { k2=1e+200; } else if(th_up[th_up_n-1].y>th_up[th_up_n-2].y) { k2=-1e+200; } else k2=0; } else { k2=(th_up[th_up_n-1].y-th_up[th_up_n-2].y)/ (th_up[th_up_n-1].x-th_up[th_up_n-2].x); } if(k1>=k2)break; th_up_n--; } //}  } return 0; }"], "original_ll": -0.3329019248485565, "sampled_ll": -0.4406387209892273, "all_perturbed_sampled_ll": [-1.3276162147521973], "all_perturbed_original_ll": [-0.781383216381073], "perturbed_sampled_ll": -1.3276162147521973, "perturbed_original_ll": -0.781383216381073, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\t\n\tclass Point{\n\t\tpublic double x,y;\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t\t\n\t\tpublic Point(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\t\n\tdouble getTheta(Point p,Point p0){\n\t\tdouble theta=Math.acos((p.x-p0.x)/Math.hypot(p.x-p0.x,p.y-p0.y));\n\t\tif(p.y<p0.y)theta=Math.PI*2-theta;\n\t\treturn theta;\n\t}\n\t\n\tint solve(Point[] points){\n\t\tPoint start=points[0];\n\t\tfor(Point v:points){\n\t\t\tif(v.y<start.y)start=v;\n\t\t}\n\t\tPoint p0=start;\n\t\tint n=0;\n\t\tdouble prev=0;\n\t\tdo{\n\t\t\tdouble min=Math.PI*3;\n\t\t\tPoint next=p0;\n\t\t\tfor(Point p: points){\n\t\t\t\tdouble theta=getTheta(p,p0);\n\t\t\t\tif(theta>=prev&&theta<min){\n\t\t\t\t\tmin=theta;\n\t\t\t\t\tnext=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp0=next;\n\t\t\tprev=min;\n\t\t\t++n;\n\t\t}while(p0!=start);\n\t\treturn points.length-n;\n\t}\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in).useDelimiter(\",|\\r\\n|\\n\");\n\t\t\n\t\tint n;\n\t\tPoint[] points;\n\t\twhile((n=ni())!=0){\n\t\t\tpoints=new Point[n];\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tpoints[i]=new Point(nd(),nd());\n\t\t\t}\n\t\t\tSystem.out.println(solve(points));\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            Point[] points = new Point[n];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\",\");\n                double x = Double.parseDouble(parts[0]);\n                double y = Double.parseDouble(parts[1]);\n                points[i] = new Point(x, y);\n            }\n            \n            List<Integer> hull = convexHull(points);\n            System.out.println(n - hull.size());\n        }\n    }\n    \n    static List<Integer> convexHull(Point[] points) {\n        int n = points.length;\n        if (n < 3) {\n            List<Integer> result = new ArrayList<>();\n            for (int i = 0; i < n; i++) result.add(i);\n            return result;\n        }\n        \n        // Find the bottommost point (or leftmost in case of tie)\n        int start = 0;\n        for (int i = 1; i < n; i++) {\n            if (points[i].y < points[start].y || \n                (points[i].y == points[start].y && points[i].x < points[start].x)) {\n                start = i;\n            }\n        }\n        \n        List<Integer> hull = new ArrayList<>();\n        int current = start;\n        \n        do {\n            hull.add(current);\n            int next = (current + 1) % n;\n            \n            for (int i = 0; i < n; i++) {\n                if (i == current) continue;\n                double cross = crossProduct(points[current], points[next], points[i]);\n                if (cross > 0) {\n                    next = i;\n                } else if (cross == 0) {\n                    // Collinear points - choose the farthest one\n                    if (distance(points[current], points[i]) > distance(points[current], points[next])) {\n                        next = i;\n                    }\n                }\n            }\n            \n            current = next;\n        } while (current != start);\n        \n        return hull;\n    }\n    \n    static double crossProduct(Point o, Point a, Point b) {\n        return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n    }\n    \n    static double distance(Point a, Point b) {\n        double dx = a.x - b.x;\n        double dy = a.y - b.y;\n        return dx * dx + dy * dy;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class Point { double x, y;  = y; } } public static void main(String[] args) throws IOException { BufferedReader  = br.readLine()) != null) { int n = Integer.parseInt(line.trim()); if (n == 0) break; Point[] points = new Point[n]; for (int  n; i++) { String[]  = Double.parseDouble(parts[0]); double y = Double.parseDouble(parts[1]); points[i] = new Point(x, y); } List<Integer> hull  convexHull(Point[] points) {  (n < 3) { List<Integer> result  i = 0; i < n; i++) result.add(i); return result; } // Find the bottommost point (or leftmost in case of  for (int i = 1; i < n; i++) { if (points[i].y < points[start].y || (points[i].y == points[start].y && points[i].x < points[start].x)) { start =  = new ArrayList<>(); int current = start; do {  for (int i = 0; i < n; i++) { if (i == current) continue; double cross = crossProduct(points[current], points[next], points[i]); if (cross > 0) { next =  == 0) { // Collinear points -  (distance(points[current], points[i]) > distance(points[current], points[next])) { next = i; } } } current = next; } while (current != start); return hull; }  a, Point b) { return (a.x -   (b.x - o.x); } static double distance(Point a, Point b) { double dx = a.x - b.x; double dy = a.y - b.y; return dx * dx + dy * dy; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { Scanner sc; class  } public Point(double x,double y){ this.x=x;  p,Point p0){ double theta=Math.acos((p.x-p0.x)/Math.hypot(p.x-p0.x,p.y-p0.y)); if(p.y<p0.y)theta=Math.PI*2-theta; return theta; } int solve(Point[] points){ Point start=points[0]; for(Point v:points){ if(v.y<start.y)start=v;  p: points){ double theta=getTheta(p,p0); if(theta>=prev&&theta<min){ min=theta; next=p; } } p0=next; prev=min; ++n; }while(p0!=start); return points.length-n; } double nd(){ return sc.nextDouble(); } int ni(){ return sc.nextInt(); } void io(){ sc=new Scanner(System.in).useDelimiter(\",|\\r\\n|\\n\"); int  Point[n]; for(int i=0;i<n;++i){ points[i]=new Point(nd(),nd()); } System.out.println(solve(points)); } sc.close(); } public static void main(String[] args) { // TODO Auto-generated method stub new Main().io(); } }"], "original_ll": -0.7825383543968201, "sampled_ll": -0.3424190282821655, "all_perturbed_sampled_ll": [-1.2920087575912476], "all_perturbed_original_ll": [-1.7386209964752197], "perturbed_sampled_ll": -1.2920087575912476, "perturbed_original_ll": -1.7386209964752197, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f(x,y,x1,y1,x2,y2):\n    if x1 <= x2:\n        return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1\n    else:\n        return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1)\n\ndef DC(a):\n    if len(a) > 3:\n        # Divide\n        la = a[:len(a)/2]\n        ra = a[len(a)/2:]\n        # Conquer\n        la,ra = DC(la),DC(ra)\n        while f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0 and len(ra) > 1:\n            ra.pop(0)\n        while f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0 and len(la) > 1:\n            la.pop(-1)\n        return la+ra\n    else:\n        return a\n\nwhile True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(map(float, raw_input().split(\",\")))\n    p = sorted(p, key = lambda x: x[0])\n    print n - len(DC(p))", "sampled": "def cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef convex_hull(points):\n    points = sorted(points)\n    if len(points) <= 1:\n        return points\n    \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    points = []\n    for _ in range(n):\n        line = input().strip()\n        x, y = map(float, line.split(','))\n        points.append((x, y))\n    \n    hull = convex_hull(points)\n    hull_set = set(hull)\n    \n    count = 0\n    for p in points:\n        if p not in hull_set:\n            count += 1\n    \n    print(count)\n", "perturbed_sampled": ["def cross(o, a, b): return (a[0] - o[0]) * (b[1]  o[1]) * (b[0] - o[0]) def convex_hull(points): points = sorted(points)  points lower = [] for p in points: while len(lower) >= 2 and cross(lower[-2], lower[-1],  upper = [] for p in reversed(points): while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) return lower[:-1] + upper[:-1] while True: n = int(input())    x, y = map(float, line.split(',')) points.append((x, y)) hull = convex_hull(points) hull_set = set(hull) count = 0 for p in points:  count += 1 print(count)"], "perturbed_original": ["def f(x,y,x1,y1,x2,y2): if x1 <= x2: return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1 else: return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1) def DC(a): if len(a) > 3: # Divide la = a[:len(a)/2] ra = a[len(a)/2:] # Conquer la,ra = DC(la),DC(ra) while f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1])  > 0 and len(la) > 1: la.pop(-1) return la+ra else: return a  if n == 0: break p = [] for i in range(n): p.append(map(float,  print n - len(DC(p))"], "original_ll": -0.7144041657447815, "sampled_ll": -0.3761083781719208, "all_perturbed_sampled_ll": [-1.3346583843231201], "all_perturbed_original_ll": [-1.5943297147750854], "perturbed_sampled_ll": -1.3346583843231201, "perturbed_original_ll": -1.5943297147750854, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint i, j;\nint flag;\nint n;\nint m;\nint atari;\nint d;\nchar amida[11][31];\nint temp[10], keep[10];\n\nint check_amida(void){\n\tint k, l;\n\tfor (k = 0; k < d; k++){\n\t\tfor (l = 0; l < n - 1; l++){\n\t\t\tif (amida[k][l] == '1'){\n\t\t\t\ttemp[l] += temp[l + 1];\n\t\t\t\ttemp[l + 1] = temp[l] - temp[l + 1];\n\t\t\t\ttemp[l] -= temp[l + 1];\n\t\t\t}\n\t\t}\n\t}\n\tif (temp[atari - 1] == m){\n\t\treturn (1);\n\t}\n\telse {\n\t\treturn (0);\n\t}\n}\n\nint ins_amida(int a, int b){\n\tint res;\n\tamida[a][b] = '1';\n\tres = check_amida();\n\tamida[a][b] = '0';\n\t\n\treturn (res);\n}\n\nint main(void)\n{\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tif (!n){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\ttemp[i] = i + 1;\n\t\t\tkeep[i] = i + 1;\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &atari);\n\t\tscanf(\"%d\", &d);\n\t\t\n\t\tfor (i = 0; i < d; i++){\n\t\t\tscanf(\"%s\", amida[i]);\n\t\t\tgetchar();\n\t\t}\n\t\t\n\t\tflag = 0;\n\t\t\n\t\tif (check_amida() == 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tflag = 1;\n\t\t}\n\t\tif (flag == 0){\n\t\t\tfor (i = 0; i < d; i++){\n\t\t\t\tfor (j = 0; j < n - 1; j++){\n\t\t\t\t\tmemcpy(temp, keep, sizeof(keep));\n\t\t\t\t\tif (amida[i][j] == '1'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (j > 0){\n\t\t\t\t\t\tif (amida[i][j - 1] == '1'){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j != n - 2){\n\t\t\t\t\t\tif (amida[i][j + 1] == '1'){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ins_amida(i, j) == 1){\n\t\t\t\t\t\tprintf(\"%d %d\\n\", i + 1, j + 1);\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag == 1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag == 0){\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint n, m, target, d;\nint amida[31][10];\n\nint trace(int start, int skipRow, int skipCol) {\n    int pos = start;\n    for (int row = 1; row <= d; row++) {\n        if (row == skipRow && skipCol == pos && amida[row][pos] == 0) {\n            pos++;\n        } else if (row == skipRow && skipCol == pos - 1 && amida[row][pos - 1] == 0) {\n            pos--;\n        } else if (pos > 1 && amida[row][pos - 1] == 1) {\n            pos--;\n        } else if (pos < n && amida[row][pos] == 1) {\n            pos++;\n        }\n    }\n    return pos;\n}\n\nint canAdd(int row, int col) {\n    if (amida[row][col] == 1) return 0;\n    if (col > 1 && amida[row][col - 1] == 1) return 0;\n    if (col < n - 1 && amida[row][col + 1] == 1) return 0;\n    return 1;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        scanf(\"%d\", &m);\n        scanf(\"%d\", &target);\n        scanf(\"%d\", &d);\n        \n        for (int i = 1; i <= d; i++) {\n            char line[11];\n            scanf(\"%s\", line);\n            for (int j = 0; j < n - 1; j++) {\n                amida[i][j + 1] = line[j] - '0';\n            }\n        }\n        \n        int result = trace(m, -1, -1);\n        if (result == target) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        int found = 0;\n        for (int row = 1; row <= d && !found; row++) {\n            for (int col = 1; col < n && !found; col++) {\n                if (canAdd(row, col)) {\n                    int res = trace(m, row, col);\n                    if (res == target) {\n                        printf(\"%d %d\\n\", row, col);\n                        found = 1;\n                    }\n                }\n            }\n        }\n        \n        if (!found) {\n            printf(\"1\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int n, m, target, d; int amida[31][10]; int trace(int  { int pos = start; for  && skipCol == pos && amida[row][pos] == 0) { pos++; } else if (row == skipRow && skipCol == pos - 1 && amida[row][pos - 1] == 0)    pos--; } else if (pos < n && amida[row][pos] == 1) { pos++; } } return pos; } int  return 0; if (col > 1 && amida[row][col - 1] == 1) return 0; if (col < n - 1 &&  return 0; return 1; } int main() { while (1) { scanf(\"%d\", &n); if (n == 0) break; scanf(\"%d\", &m); scanf(\"%d\", &target); scanf(\"%d\", &d); for (int i = 1; i <= d; i++) { char line[11]; scanf(\"%s\", line); for (int  n - 1; j++) { amida[i][j + 1] = line[j]  result = trace(m, -1, -1); if (result == target) { printf(\"0\\n\"); continue; } int found = 0; for (int row = 1; row <= d && !found; row++) { for (int col = 1; col < n &&  = trace(m, row, col); if (res ==  col); found = 1; }  { printf(\"1\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include  d; char amida[11][31]; int temp[10], keep[10]; int check_amida(void){ int k, l; for (k = 0; k < d; k++){ for (l = 0; l < n - 1; l++){  += temp[l + 1]; temp[l + 1] = temp[l] -   } if (temp[atari - 1] ==  { return (0); } } int ins_amida(int a, int b){ int res; amida[a][b] = '1'; res = check_amida(); amida[a][b] = '0'; return (res); }  = 0; i < n; i++){ temp[i] = i + 1; keep[i] = i + 1; } scanf(\"%d\", &m); scanf(\"%d\", &atari);  0; i < d; i++){ scanf(\"%s\", amida[i]); getchar(); } flag = 0; if (check_amida() == 1){ printf(\"0\\n\"); flag = 1; } if (flag  0; i  = 0; j < n - 1; j++){ memcpy(temp, keep, sizeof(keep)); if (amida[i][j] == '1'){ continue; } if (j > 0){ if  continue; } } if (j != n - 2){ if (amida[i][j + 1] == '1'){ continue; } } if (ins_amida(i,  i + 1, j + 1); flag = 1; break; } } if (flag == 1){ break; } } } if (flag == 0){ printf(\"1\\n\"); } } return (0); }"], "original_ll": -0.6479200124740601, "sampled_ll": -0.5696433782577515, "all_perturbed_sampled_ll": [-1.392879605293274], "all_perturbed_original_ll": [-1.511645793914795], "perturbed_sampled_ll": -1.392879605293274, "perturbed_original_ll": -1.511645793914795, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tString string;\n\t\t\n\t\twhile(!(string = reader.readLine()).equals(\"0\")){\n\t\t\tint n = Integer.valueOf(string);\n\t\t\tint m = Integer.valueOf(reader.readLine()) - 1;\n\t\t\tint a = Integer.valueOf(reader.readLine()) - 1;\n\t\t\tint d = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint node[][] = new int[n - 1][d];\n\t\t\tfor(int i = 0; i < d; i++){\n\t\t\t\tstring = reader.readLine();\n\t\t\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\t\t\tnode[j][i] = string.charAt(j) - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(doing(node, n, m, d) == a){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tboolean judge = false;\n\t\t\t\tx : for(int i = 0; i < d; i++){\n\t\t\t\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\t\t\t\tif(j + 1 < n && j - 1 >= 0)\n\t\t\t\t\t\tif(node[j][i] == 0){\n\t\t\t\t\t\t\tnode[j][i] = 1;\n\t\t\t\t\t\t\tif(doing(node, n, m, d) == a){\n\t\t\t\t\t\t\t\tSystem.out.println((i + 1) + \" \" + (j + 1));\n\t\t\t\t\t\t\t\tjudge = true;\n\t\t\t\t\t\t\t\tbreak x;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnode[j][i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!judge) System.out.println(1);\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t}\n\t\n\tpublic static int doing(int node[][], int n, int s, int d){\n\t\tfor(int i = 0; i < d; i++){\n\t\t\tif(s > 0 && node[s - 1][i] == 1) s--;\n\t\t\telse if(s < n - 1 && node[s][i] == 1) s++;\n\t\t}\n\t\treturn s;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int m = sc.nextInt();\n            int target = sc.nextInt();\n            int d = sc.nextInt();\n            \n            int[][] ladder = new int[d][n - 1];\n            for (int i = 0; i < d; i++) {\n                String line = sc.next();\n                for (int j = 0; j < n - 1; j++) {\n                    ladder[i][j] = line.charAt(j) - '0';\n                }\n            }\n            \n            // Check if we can reach without adding\n            int result = traverse(ladder, m - 1, d, n);\n            if (result == target - 1) {\n                System.out.println(0);\n                continue;\n            }\n            \n            // Try adding one horizontal line\n            boolean found = false;\n            for (int row = 0; row < d; row++) {\n                for (int col = 0; col < n - 1; col++) {\n                    if (canAddLine(ladder, row, col, n)) {\n                        ladder[row][col] = 1;\n                        int newResult = traverse(ladder, m - 1, d, n);\n                        if (newResult == target - 1) {\n                            System.out.println((row + 1) + \" \" + (col + 1));\n                            found = true;\n                            ladder[row][col] = 0;\n                            break;\n                        }\n                        ladder[row][col] = 0;\n                    }\n                }\n                if (found) break;\n            }\n            \n            if (!found) {\n                System.out.println(1);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static int traverse(int[][] ladder, int start, int d, int n) {\n        int pos = start;\n        for (int row = 0; row < d; row++) {\n            // Check left\n            if (pos > 0 && ladder[row][pos - 1] == 1) {\n                pos--;\n            }\n            // Check right\n            else if (pos < n - 1 && ladder[row][pos] == 1) {\n                pos++;\n            }\n        }\n        return pos;\n    }\n    \n    static boolean canAddLine(int[][] ladder, int row, int col, int n) {\n        if (ladder[row][col] == 1) {\n            return false;\n        }\n        \n        // Check if adjacent positions have lines\n        if (col > 0 && ladder[row][col - 1] == 1) {\n            return false;\n        }\n        if (col < n - 2 && ladder[row][col + 1] == 1) {\n            return false;\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0)  int target = sc.nextInt(); int d = sc.nextInt(); int[][] ladder =  (int i = 0; i < d; i++)  for (int j = 0; j <  ladder[i][j] = line.charAt(j) - '0'; } }  reach without adding int result  == target - 1) { System.out.println(0); continue; } // Try adding  row = 0; row < d; row++) { for (int  n - 1; col++) { if (canAddLine(ladder, row, col, n)) { ladder[row][col] = 1; int newResult = traverse(ladder, m - 1,  target - 1) { System.out.println((row + 1) + \" \" + (col + 1)); found = true; ladder[row][col] = 0; break; }  if (found) break; } if (!found) { System.out.println(1); } } sc.close(); } static int traverse(int[][] ladder, int start, int d, int n) { int pos = start; for (int  d; row++) { // Check left if  - 1] == 1)  < n - 1 && ladder[row][pos]  } return pos; } static boolean canAddLine(int[][] ladder, int row, int col, int n) { if (ladder[row][col] == 1) { return false; } // Check if adjacent positions have lines if (col >  == 1) { return false; } if (col  ladder[row][col + 1] == 1) { return false; } return true; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main{ public static void  = new InputStreamReader(System.in); BufferedReader reader = new BufferedReader(isr); String string;  = Integer.valueOf(string); int m = Integer.valueOf(reader.readLine()) - 1; int a = Integer.valueOf(reader.readLine()) - 1; int d  new int[n - 1][d]; for(int i = 0; i < d; i++){ string = reader.readLine(); for(int j = 0; j < n - 1; j++){ node[j][i] = string.charAt(j) - '0'; } }  a){ System.out.println(0);   = 0; j < n - 1; j++){ if(j + 1  1 >= 0) if(node[j][i] == 0){ node[j][i] = 1; if(doing(node, n, m, d) == a){ System.out.println((i + 1) + \" \" + (j + 1)); judge = true; break x; } node[j][i] = 0; } } } if(!judge) System.out.println(1); } } reader.close(); } public static int doing(int node[][], int n, int s, int d){ for(int  d; i++){ if(s  1][i] == 1) s--; else if(s < n - 1 && node[s][i] ==  } }"], "original_ll": -0.7000569701194763, "sampled_ll": -0.510989248752594, "all_perturbed_sampled_ll": [-1.7017436027526855], "all_perturbed_original_ll": [-1.576714277267456], "perturbed_sampled_ll": -1.7017436027526855, "perturbed_original_ll": -1.576714277267456, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nimport itertools\n\n\ndef one_step(lo,lis):\n    nu = [ e for e in lis ]\n    for j in xrange(len(nu)):\n        if lo[0][j] == 1:\n            nu[j],nu[j+1] = nu[j+1],nu[j]\n    return lo[1:],nu\n\n\ndef solve(lo,lis):\n    if len(lo) == 0:\n        return lis\n    nu = [ e for e in lis]\n    lo2,nu2 = one_step(lo,nu)\n    return solve(lo2,nu2)\n\nn = input()\nm = input()\nstar = input()\nd = input()\nlis = range(n+1)\nlots = []\nfor i in xrange(d):\n    lots.append([0]+[ 1 if e == '1' else 0 for e in list(raw_input()) ] +[0])\n\nif solve(lots,lis)[star] == m: print 0;exit()\nfor i in xrange(d):\n    for j in xrange(1,n):\n        if lots[0][j-1] == 0 and lots[0][j] == 0 and lots[0][j+1] == 0:\n            lots[0][j] = 1\n            if solve(lots,lis)[star] == m: print i+1,j;exit()\n            lots[0][j] = 0\n    lots,lis = one_step(lots,lis)\nprint 1", "sampled": "def follow_amida(n, start, lines):\n    pos = start\n    for line in lines:\n        if pos > 1 and line[pos-2] == 1:\n            pos -= 1\n        elif pos < n and line[pos-1] == 1:\n            pos += 1\n    return pos\n\ndef can_add_line(lines, level, bridge_pos):\n    # Check if we can add a horizontal line at level between bridge_pos and bridge_pos+1\n    line = lines[level]\n    \n    # Check if there's already a line there\n    if line[bridge_pos] == 1:\n        return False\n    \n    # Check left neighbor\n    if bridge_pos > 0 and line[bridge_pos-1] == 1:\n        return False\n    \n    # Check right neighbor\n    if bridge_pos < len(line) - 1 and line[bridge_pos+1] == 1:\n        return False\n    \n    return True\n\ndef solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        m = int(input())\n        target = int(input())\n        d = int(input())\n        \n        lines = []\n        for _ in range(d):\n            line_str = input().strip()\n            line = [int(c) for c in line_str]\n            lines.append(line)\n        \n        # Check if already reaches target without adding any line\n        result = follow_amida(n, m, lines)\n        if result == target:\n            print(0)\n            continue\n        \n        # Try adding one line at each possible position\n        found = False\n        for level in range(d):\n            for bridge_pos in range(n-1):\n                if can_add_line(lines, level, bridge_pos):\n                    # Make a copy and add the line\n                    new_lines = [line[:] for line in lines]\n                    new_lines[level][bridge_pos] = 1\n                    \n                    # Check if this reaches target\n                    result = follow_amida(n, m, new_lines)\n                    if result == target:\n                        print(level + 1, bridge_pos + 1)\n                        found = True\n                        break\n            if found:\n                break\n        \n        if not found:\n            print(1)\n\nsolve()\n", "perturbed_sampled": ["def follow_amida(n, start, lines): pos = start for line in lines: if pos > 1 and line[pos-2]  elif pos  1: pos += 1 return pos def can_add_line(lines, level, bridge_pos): # Check  horizontal line at level between bridge_pos and bridge_pos+1 line = lines[level] # Check if there's already a line there if line[bridge_pos] == 1: return False # Check left neighbor if  == 1: return False # Check right neighbor if   False return True def solve(): while True: n = int(input()) if n == 0: break m = int(input()) target = int(input()) d = int(input()) lines = [] for _ in range(d): line_str = input().strip() line = [int(c) for c in line_str] lines.append(line) # Check if already reaches target without adding  m, lines) if result == target: print(0) continue # Try adding one line at each  for level in  # Make a copy and add the line new_lines = [line[:]  = 1 #  new_lines) if result == target: print(level + 1, bridge_pos + 1)  found: break if not found: print(1) solve()"], "perturbed_original": ["import sys import itertools def one_step(lo,lis): nu = [ e for e in lis ] for j in xrange(len(nu)):   solve(lo,lis): if len(lo) == 0: return lis nu = [ e for e in lis] lo2,nu2 = one_step(lo,nu) return solve(lo2,nu2) n = input() m = input() star  lis = range(n+1) lots  0 for e in list(raw_input()) ] +[0]) if solve(lots,lis)[star] == m: print 0;exit() for i in xrange(d): for j in xrange(1,n): if lots[0][j-1] == 0 and lots[0][j] == 0 and lots[0][j+1] == 0: lots[0][j] = 1 if  lots[0][j] = 0 lots,lis = one_step(lots,lis) print 1"], "original_ll": -1.2507563829421997, "sampled_ll": -0.7855983972549438, "all_perturbed_sampled_ll": [-2.1452255249023438], "all_perturbed_original_ll": [-2.2665646076202393], "perturbed_sampled_ll": -2.1452255249023438, "perturbed_original_ll": -2.2665646076202393, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint num[10]={1,2,3,4,5,6,7,8,9,0}, dp[11][331];\n#define exch(A,B) {int t; t=A, A=B, B=t;}\n\n/* k\u0095\u00b6\u008e\u009a\u0096\u00da\u0082\u00f0\u008c\u0088\u0082\u00df\u0082\u00e9, s\u0082\u00c9\u0082\u00cd\u0082\u00bb\u0082\u00cc\u008e\u009e\u0093_\u0082\u00c5\u0082\u00cc\u0098a\u0082\u00f0\u0083\u0081\u0083\u0082 */\nvoid solve(int k, int s){\n     int i, j, ts;\n\n     for(i=k; i<10; i++){\n\t  exch(num[i],num[k]);\n\n\t  /* n=k\u0082\u00c5\u0082\u00ccs\u0082\u00f0\u008bL\u0098^ */\n\t  ts=s;\n\t  ts+=num[k]*(k+1);\n\t  dp[k+1][ts]++;\n\n\t  if(k<9) solve(k+1,ts);\n\n\t  exch(num[i],num[k]);\n     }\n}\n\nint main(int argc, char *argv[]){\n     int n, s;\n\n     solve(0,0);\n     \n     while(~scanf(\"%d %d\",&n,&s))\n\t  printf(\"%d\\n\",(n<=10 && s<=330)?dp[n][s]:0);\n\n     return 0;\n}", "sampled": "#include <stdio.h>\n\nint n, s;\nint count;\nint used[10];\nint seq[11];\n\nvoid solve(int pos, int sum) {\n    if (pos > n) {\n        if (sum == s) {\n            count++;\n        }\n        return;\n    }\n    \n    for (int i = 0; i <= 9; i++) {\n        if (!used[i]) {\n            used[i] = 1;\n            seq[pos] = i;\n            solve(pos + 1, sum + pos * i);\n            used[i] = 0;\n        }\n    }\n}\n\nint main() {\n    while (scanf(\"%d %d\", &n, &s) == 2) {\n        count = 0;\n        for (int i = 0; i <= 9; i++) {\n            used[i] = 0;\n        }\n        solve(1, 0);\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int n, s; int count; int used[10]; int seq[11]; void solve(int pos, int sum) { if (pos > n)  { count++; } return; } for (int i = 0;  sum + pos * i); used[i] = 0; }  while (scanf(\"%d %d\", &n, &s) == 2) { count = 0; for (int i = 0; i <= 9; i++) { used[i] = 0; } solve(1, 0); printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include <stdio.h> int num[10]={1,2,3,4,5,6,7,8,9,0}, dp[11][331]; #define exch(A,B) {int t; t=A, A=B,  void solve(int k, int s){ int  i++){ exch(num[i],num[k]); /* n=k\u0082\u00c5\u0082\u00ccs\u0082\u00f0\u008bL\u0098^ */ ts=s; ts+=num[k]*(k+1); dp[k+1][ts]++; if(k<9) solve(k+1,ts);  argc, char *argv[]){ int n, s; solve(0,0); while(~scanf(\"%d %d\",&n,&s)) printf(\"%d\\n\",(n<=10 && s<=330)?dp[n][s]:0); return 0; }"], "original_ll": -1.7130074501037598, "sampled_ll": -0.5045537948608398, "all_perturbed_sampled_ll": [-1.3774739503860474], "all_perturbed_original_ll": [-2.1083929538726807], "perturbed_sampled_ll": -1.3774739503860474, "perturbed_original_ll": -2.1083929538726807, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * Combination of Number Sequences\n */\npublic class Main {\n\n\tstatic int count;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint s = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tcount = 0;\n\t\t\tsolve(0, n, 1, s);\n\t\t\tSystem.out.println(count);\n\n\t\t}\n\n\t}\n\n\tstatic void solve(int p, int n, int a, int s) {\n\n\t\tif (p > 9 || n <= 0 || p * a > s) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (n == 1 && p * a == s) {\n\t\t\t++count;\n\t\t} else {\n\t\t\tsolve(p + 1, n - 1, a + 1, s - p * a);\n\t\t\tsolve(p + 1, n, a, s);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int n, s;\n    static int count;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            n = sc.nextInt();\n            s = sc.nextInt();\n            \n            count = 0;\n            boolean[] used = new boolean[10];\n            solve(1, 0, used);\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n    \n    static void solve(int pos, int sum, boolean[] used) {\n        if (pos > n) {\n            if (sum == s) {\n                count++;\n            }\n            return;\n        }\n        \n        for (int i = 0; i <= 9; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                solve(pos + 1, sum + pos * i, used);\n                used[i] = false;\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int n, s;  void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) {  sc.nextInt(); count = 0; boolean[] used = new boolean[10];  solve(int pos, int sum, boolean[] used) { if (pos >  s) { count++; } return; } for (int i = 0; i <= 9; i++) { if (!used[i]) { used[i] = true; solve(pos  * i, used); used[i] = false; } } } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; /** * Combination of Number Sequences */ public class Main { static int count; public static void main(String[] args)  = new BufferedReader(new InputStreamReader(System.in));  ((line = br.readLine()) != null && !line.isEmpty()) { int n = Integer.parseInt(line.substring(0,  Integer.parseInt(line.substring(line.indexOf('  s); System.out.println(count); } } static void solve(int p, int n, int a, int s) { if (p > 9 || n <= 0 || p * a >  (n == 1 && p * a == s) { ++count; } else { solve(p + 1, n - 1,  p *  a, s); } } }"], "original_ll": -0.7200961112976074, "sampled_ll": -0.5139693021774292, "all_perturbed_sampled_ll": [-1.5850551128387451], "all_perturbed_original_ll": [-1.9710195064544678], "perturbed_sampled_ll": -1.5850551128387451, "perturbed_original_ll": -1.9710195064544678, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport sys\nimport itertools\n\n\ntable = [[], [], [], [], [], [], [], [], [], [], []]\n\ndef solv(n, s):\n    if s > 330:\n        return 0\n    dp = table[n]\n    if dp:\n        return dp[s]\n    else:\n        for i in xrange(331):\n            dp.append(0)\n        for p in itertools.permutations(xrange(10), n):\n            s0 = foo(p, n)\n            dp[s0] += 1\n        return dp[s]\n\n\ndef foo(perm, n):\n    return sum(map(lambda x, y: x * y, xrange(1, n+1), perm))\n\n\nfor line in sys.stdin:\n    n, s = map(int, line.split(' '))\n    print solv(n, s)", "sampled": "import sys\nfrom itertools import permutations\n\ndef count_combinations(n, s):\n    count = 0\n    # Generate all permutations of n numbers from 0-9\n    for perm in permutations(range(10), n):\n        # Calculate the weighted sum\n        weighted_sum = sum((i + 1) * perm[i] for i in range(n))\n        if weighted_sum == s:\n            count += 1\n    return count\n\nfor line in sys.stdin:\n    n, s = map(int, line.strip().split())\n    print(count_combinations(n, s))\n", "perturbed_sampled": ["import sys from  s): count = 0 # Generate all permutations of  perm in permutations(range(10), n): # Calculate the weighted sum weighted_sum = sum((i + 1) * perm[i] for i in range(n)) if weighted_sum ==  count for line in sys.stdin: n, s = map(int, line.strip().split()) print(count_combinations(n, s))"], "perturbed_original": ["import sys import itertools table = [[], [], [],  [], [], []] def solv(n, s): if s > 330: return 0 dp  in xrange(331): dp.append(0) for p in itertools.permutations(xrange(10), n): s0 = foo(p, n)  def foo(perm, n): return sum(map(lambda x, y: x * y, xrange(1, n+1), perm)) for line in sys.stdin: n, s = map(int, line.split(' ')) print solv(n, s)"], "original_ll": -1.309814214706421, "sampled_ll": -0.8504071831703186, "all_perturbed_sampled_ll": [-2.7086668014526367], "all_perturbed_original_ll": [-2.0803306102752686], "perturbed_sampled_ll": -2.7086668014526367, "perturbed_original_ll": -2.0803306102752686, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid bomb(int field[8][8],int x,int y);\n\nint main(){\n\tint i,j,k,n;\n\tint field[8][8];\n\tchar line[9];\n\tint x,y;\n\t\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\t\t\n\t\tfor(j=0;j<8;j++){\n\t\t\tscanf(\"%s\",line);\n\t\t\tfor(k=0;k<8;k++){\n\t\t\t\tfield[j][k] = line[k] - '0';\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&x);\n\t\tscanf(\"%d\",&y);\n\t\tx--; y--;\n\t\t\n\t\tbomb(field,y,x);\n\t\t\n\t\tprintf(\"Data %d:\\n\",i);\n\t\tfor(j=0;j<8;j++){\n\t\t\tfor(k=0;k<8;k++){\n\t\t\t\tprintf(\"%d\",field[j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nvoid bomb(int field[8][8],int x,int y){\n\tint i;\n\tfield[x][y] = 0;\n\tfor(i=1;i<=3&&x-i>=0;i++){\n\t\tif(field[x-i][y] == 1){\n\t\t\tfield[x-i][y] = 0;\n\t\t\tbomb(field,x-i,y);\n\t\t}\n\t}\n\tfor(i=1;i<=3&&x+i<8;i++){\n\t\tif(field[x+i][y] == 1){\n\t\t\tfield[x+i][y] = 0;\n\t\t\tbomb(field,x+i,y);\n\t\t}\n\t}\n\tfor(i=1;i<=3&&y-i>=0;i++){\n\t\tif(field[x][y-i] == 1){\n\t\t\tfield[x][y-i] = 0;\n\t\t\tbomb(field,x,y-i);\n\t\t}\n\t}\n\tfor(i=1;i<=3&&y+i<8;i++){\n\t\tif(field[x][y+i] == 1){\n\t\t\tfield[x][y+i] = 0;\n\t\t\tbomb(field,x,y+i);\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint grid[8][8];\nint exploded[8][8];\n\nvoid explode(int x, int y) {\n    if (x < 0 || x >= 8 || y < 0 || y >= 8) return;\n    if (exploded[y][x]) return;\n    if (grid[y][x] == 0) return;\n    \n    exploded[y][x] = 1;\n    \n    // Explode bombs in range (3 squares in each direction)\n    for (int i = 1; i <= 3; i++) {\n        if (x - i >= 0) explode(x - i, y);\n        if (x + i < 8) explode(x + i, y);\n        if (y - i >= 0) explode(x, y - i);\n        if (y + i < 8) explode(x, y + i);\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int dataset = 1; dataset <= n; dataset++) {\n        // Read the grid\n        for (int i = 0; i < 8; i++) {\n            char line[10];\n            scanf(\"%s\", line);\n            for (int j = 0; j < 8; j++) {\n                grid[i][j] = line[j] - '0';\n            }\n        }\n        \n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--; y--; // Convert to 0-indexed\n        \n        // Initialize exploded array\n        memset(exploded, 0, sizeof(exploded));\n        \n        // Start the chain reaction\n        explode(x, y);\n        \n        // Output\n        printf(\"Data %d:\\n\", dataset);\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                if (exploded[i][j]) {\n                    printf(\"0\");\n                } else {\n                    printf(\"%d\", grid[i][j]);\n                }\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int grid[8][8]; int exploded[8][8]; void explode(int x, int y) { if (x < 0 || x >= 8 || y < 0 || y >=  if (grid[y][x] == 0) return; exploded[y][x] = 1; // Explode bombs in range (3 squares in each direction) for (int i = 1; i <= 3; i++) { if (x  - i, y); if (x + i < 8) explode(x + i,  >= 0) explode(x, y - i); if (y  y + i); } } int main() { int n; scanf(\"%d\",  1; dataset <= n; dataset++) { // Read the grid for (int i = 0; i < 8; i++) {  (int j = 0; j < 8; j++) { grid[i][j] = line[j] - '0'; }  %d\", &x, &y); x--; y--; // Convert to 0-indexed // Initialize exploded array  y); // Output printf(\"Data %d:\\n\", dataset); for (int i = 0; i < 8; i++) { for (int j = 0; j  else   }"], "perturbed_original": ["#include  y); int main(){ int  int x,y; scanf(\"%d\",&n); for(i=1;i<=n;i++){ for(j=0;j<8;j++){ scanf(\"%s\",line); for(k=0;k<8;k++){ field[j][k]  } scanf(\"%d\",&x); scanf(\"%d\",&y); x--; y--; bomb(field,y,x); printf(\"Data %d:\\n\",i); for(j=0;j<8;j++){ for(k=0;k<8;k++){ printf(\"%d\",field[j][k]); }  } void bomb(int field[8][8],int x,int y){ int i; field[x][y] = 0; for(i=1;i<=3&&x-i>=0;i++){ if(field[x-i][y]  bomb(field,x-i,y); } } for(i=1;i<=3&&x+i<8;i++){ if(field[x+i][y] == 1){ field[x+i][y] = 0; bomb(field,x+i,y); } } for(i=1;i<=3&&y-i>=0;i++){ if(field[x][y-i] == 1){ field[x][y-i] = 0; bomb(field,x,y-i); } } for(i=1;i<=3&&y+i<8;i++){ if(field[x][y+i] == 1){ field[x][y+i] = 0; bomb(field,x,y+i); } } }"], "original_ll": -0.45498475432395935, "sampled_ll": -0.4754079282283783, "all_perturbed_sampled_ll": [-1.5518697500228882], "all_perturbed_original_ll": [-0.9403734803199768], "perturbed_sampled_ll": -1.5518697500228882, "perturbed_original_ll": -0.9403734803199768, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tint[][] map;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint sets = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor (int index = 0; index < sets; index++) {\n\t\t\tsc.nextLine();\n\t\t\t\n\t\t\tmap = new int[8][8];\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\tmap[j][i] = line.charAt(j) - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer[]> boms = new LinkedList<Integer[]>();\n\t\t\tInteger[] xy = new Integer[2];\n\t\t\txy[0] = Integer.parseInt(sc.nextLine()) - 1;\n\t\t\txy[1] = Integer.parseInt(sc.nextLine()) - 1;\n\t\t\tmap[xy[0]][xy[1]] = 0;\n\t\t\tboms.add(xy);\n\t\t\t\n\t\t\twhile (boms.isEmpty() == false) {\n\t\t\t\txy = boms.pop();\n\t\t\t\t\n\t\t\t\tint tx = xy[0];\n\t\t\t\tint ty = xy[1];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = -3; i < 4; i++) {\n\t\t\t\t\tif ((tx + i) < 0) continue;\n\t\t\t\t\tif ((tx + i) > 7) break;\n\t\t\t\t\t\n\t\t\t\t\tif (map[tx + i][ty] == 1) {\n\t\t\t\t\t\tmap[tx + i][ty] = 0;\n\t\t\t\t\t\txy[0] = tx + i;\n\t\t\t\t\t\txy[1] = ty;\n\t\t\t\t\t\tboms.add(xy);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = -3; i < 4; i++) {\n\t\t\t\t\tif ((ty + i) < 0) continue;\n\t\t\t\t\tif ((ty + i) > 7) break;\t\n\t\t\t\t\t\n\t\t\t\t\tif (map[tx][ty + i] == 1) {\n\t\t\t\t\t\tmap[tx][ty + i] = 0;\n\t\t\t\t\t\txy[0] = tx;\n\t\t\t\t\t\txy[1] = ty + i;\n\t\t\t\t\t\tboms.add(xy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"Data \" + (index + 1) + \":\");\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\tSystem.out.print(map[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int dataSet = 1; dataSet <= n; dataSet++) {\n            sc.nextLine(); // empty line\n            \n            int[][] grid = new int[8][8];\n            for (int y = 0; y < 8; y++) {\n                String line = sc.nextLine();\n                for (int x = 0; x < 8; x++) {\n                    grid[y][x] = line.charAt(x) - '0';\n                }\n            }\n            \n            int startX = sc.nextInt() - 1;\n            int startY = sc.nextInt() - 1;\n            sc.nextLine();\n            \n            // BFS to explode bombs\n            Queue<int[]> queue = new LinkedList<>();\n            boolean[][] exploded = new boolean[8][8];\n            \n            queue.offer(new int[]{startX, startY});\n            exploded[startY][startX] = true;\n            \n            while (!queue.isEmpty()) {\n                int[] pos = queue.poll();\n                int x = pos[0];\n                int y = pos[1];\n                \n                // Check up to 3 cells in each direction\n                for (int dy = -3; dy <= 3; dy++) {\n                    int ny = y + dy;\n                    if (ny >= 0 && ny < 8 && grid[ny][x] == 1 && !exploded[ny][x]) {\n                        exploded[ny][x] = true;\n                        queue.offer(new int[]{x, ny});\n                    }\n                }\n                \n                for (int dx = -3; dx <= 3; dx++) {\n                    int nx = x + dx;\n                    if (nx >= 0 && nx < 8 && grid[y][nx] == 1 && !exploded[y][nx]) {\n                        exploded[y][nx] = true;\n                        queue.offer(new int[]{nx, y});\n                    }\n                }\n            }\n            \n            // Update grid\n            for (int y = 0; y < 8; y++) {\n                for (int x = 0; x < 8; x++) {\n                    if (exploded[y][x]) {\n                        grid[y][x] = 0;\n                    }\n                }\n            }\n            \n            // Output\n            System.out.println(\"Data \" + dataSet + \":\");\n            for (int y = 0; y < 8; y++) {\n                for (int x = 0; x < 8; x++) {\n                    System.out.print(grid[y][x]);\n                }\n                System.out.println();\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[]  new Scanner(System.in);  1; dataSet <= n; dataSet++) { sc.nextLine(); // empty line int[][] grid = new int[8][8];  y < 8; y++) { String line = sc.nextLine(); for (int x = 0; x < 8; x++) { grid[y][x] = line.charAt(x) - '0'; } } int startX = sc.nextInt() - 1; int startY = sc.nextInt() - 1; sc.nextLine();  Queue<int[]> queue = new LinkedList<>(); boolean[][] exploded =  exploded[startY][startX] = true; while (!queue.isEmpty()) { int[] pos = queue.poll(); int x = pos[0]; int y = pos[1]; // Check up to 3 cells in each direction for (int dy = -3; dy <= 3; dy++) { int ny = y + dy; if  == 1 && !exploded[ny][x]) { exploded[ny][x] = true;  -3; dx <= 3; dx++) { int nx = x + dx; if (nx >= 0 && nx < 8 && grid[y][nx] == 1 && !exploded[y][nx]) { exploded[y][nx] = true; queue.offer(new int[]{nx, y}); } } } // Update grid for (int y = 0; y < 8; y++) { for (int x = 0; x < 8; x++)  = 0; }  \":\"); for (int y = 0; y <  < 8;  } } sc.close(); } }"], "perturbed_original": ["import java.util.LinkedList; import java.util.Scanner; public class Main { private Scanner sc; int[][] map; public static void main(String[] args) { new Main(); } public Main() { sc = new Scanner(System.in); int sets  = 0;  sc.nextLine(); map = new int[8][8]; for  < map.length; i++) { String line = sc.nextLine(); for (int j = 0; j < map.length; j++) { map[j][i]  } LinkedList<Integer[]>  xy = new Integer[2]; xy[0] = Integer.parseInt(sc.nextLine())  - 1;  (boms.isEmpty() == false) { xy = boms.pop(); int tx = xy[0]; int  if ((tx  if ((tx + i) > 7) break; if (map[tx + i][ty] == 1) { map[tx + i][ty] = 0; xy[0] = tx + i; xy[1] = ty; boms.add(xy); } } for (int i = -3; i < 4; i++) { if ((ty + i) < 0) continue; if ((ty + i) > 7) break; if (map[tx][ty  map[tx][ty + i] = 0; xy[0]  + i; boms.add(xy); } } } System.out.println(\"Data \" + (index + 1) + \":\"); for (int i  i++) { for (int j = 0; j < map.length; j++) { System.out.print(map[j][i]); } System.out.println(); } } } }"], "original_ll": -0.4823695719242096, "sampled_ll": -0.35795655846595764, "all_perturbed_sampled_ll": [-1.241388201713562], "all_perturbed_original_ll": [-1.4028654098510742], "perturbed_sampled_ll": -1.241388201713562, "perturbed_original_ll": -1.4028654098510742, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def bomb(x,y):\n    s=M[y]\n    if s[x]==\"0\":return\n    M[y]=s[:x]+\"0\"+s[x+1:]\n    R=[-3,-2,-1,1,2,3]\n    for e in R:\n        bomb(x+e,y)\n        bomb(x,y+e)\n    return\n\nA=range(3,11)\nM=[\"00000000000000\" for i in range(14)]\nz=\"000\"\nn=input()\nfor i in range(n):\n    s=raw_input()\n    for j in A:\n        M[j]=z+raw_input()+z\n    x=input()+2\n    y=input()+2\n    bomb(x,y)\n    print \"Data %d:\" %(i+1)\n    for j in A:\n        print M[j][3:-3]", "sampled": "from collections import deque\n\ndef solve():\n    n = int(input())\n    \n    for dataset_num in range(1, n + 1):\n        # Read empty line\n        input()\n        \n        # Read 8x8 grid\n        grid = []\n        for i in range(8):\n            line = input().strip()\n            grid.append([int(c) for c in line])\n        \n        # Read starting position\n        x = int(input())\n        y = int(input())\n        \n        # Convert to 0-indexed\n        x -= 1\n        y -= 1\n        \n        # BFS to simulate chain explosions\n        exploded = [[False] * 8 for _ in range(8)]\n        queue = deque()\n        \n        # Start explosion at (x, y)\n        if grid[y][x] == 1:\n            queue.append((x, y))\n            exploded[y][x] = True\n        \n        while queue:\n            cx, cy = queue.popleft()\n            \n            # Explosion affects 3 squares in each direction (up, down, left, right)\n            directions = []\n            # Up\n            for dy in range(1, 4):\n                if cy - dy >= 0:\n                    directions.append((cx, cy - dy))\n            # Down\n            for dy in range(1, 4):\n                if cy + dy < 8:\n                    directions.append((cx, cy + dy))\n            # Left\n            for dx in range(1, 4):\n                if cx - dx >= 0:\n                    directions.append((cx - dx, cy))\n            # Right\n            for dx in range(1, 4):\n                if cx + dx < 8:\n                    directions.append((cx + dx, cy))\n            \n            for nx, ny in directions:\n                if grid[ny][nx] == 1 and not exploded[ny][nx]:\n                    exploded[ny][nx] = True\n                    queue.append((nx, ny))\n        \n        # Remove exploded bombs from grid\n        for i in range(8):\n            for j in range(8):\n                if exploded[i][j]:\n                    grid[i][j] = 0\n        \n        # Output result\n        print(f\"Data {dataset_num}:\")\n        for row in grid:\n            print(''.join(map(str, row)))\n\nsolve()\n", "perturbed_sampled": ["from collections import deque def solve(): n = int(input()) for dataset_num in range(1, n + 1): # Read empty line input() # Read 8x8 grid grid =   c in line]) #  int(input()) y = int(input()) # Convert to 0-indexed x -= 1 y -= 1 # BFS to  [[False] * 8 for _ in range(8)] queue = deque() # Start explosion at (x, y) if   cx, cy = queue.popleft() # Explosion affects  directions = [] # Up for dy in range(1, 4): if cy - dy >= 0: directions.append((cx, cy - dy)) # Down for  dy)) # Left for  cx - dx >= 0: directions.append((cx - dx, cy)) # Right for dx in range(1, 4): if cx + dx < 8: directions.append((cx + dx, cy)) for nx, ny in directions: if grid[ny][nx]  exploded[ny][nx] = True queue.append((nx, ny)) # Remove exploded bombs from grid for i in range(8): for j in range(8): if exploded[i][j]: grid[i][j] = 0 # Output result print(f\"Data {dataset_num}:\") for row in grid: print(''.join(map(str, row))) solve()"], "perturbed_original": ["def bomb(x,y): s=M[y] if s[x]==\"0\":return M[y]=s[:x]+\"0\"+s[x+1:] R=[-3,-2,-1,1,2,3] for e in R:  for i in range(14)] z=\"000\" n=input() for i in range(n): s=raw_input() for j in A: M[j]=z+raw_input()+z x=input()+2 y=input()+2 bomb(x,y) print  in A: print M[j][3:-3]"], "original_ll": -1.4506884813308716, "sampled_ll": -0.6286031603813171, "all_perturbed_sampled_ll": [-1.6951415538787842], "all_perturbed_original_ll": [-2.431764841079712], "perturbed_sampled_ll": -1.6951415538787842, "perturbed_original_ll": -2.431764841079712, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#define INF 1000000\n\nint cost[100][100];\nint mincost[100];\nchar used[100];\nint V;\n\nint min(int a, int b){\n\tif (a > b){\n\t\treturn (b);\n\t}\n\treturn (a);\n}\n\nint prim(void)\n{\n\tint i;\n\tint res;\n\tint u, v;\n\t\n\tfor (i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = 0;\n\t}\n\t\n\tmincost[0] = 0;\n\tres = 0;\n\t\n\twhile (1){\n\t\tv = -1;\n\t\tfor (u = 0; u < V; u++){\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\t\n\t\tfor (u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn (res);\n}\n\nint main(void)\n{\n\tint num, from, to, dist;\n\tint i,j;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &V);\n\t\tif (V == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tfor (j = 0; j < num; j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &dist);\n\t\t\tcost[from][to] = cost[to][from] = (dist / 100) - 1;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", prim());\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100\n#define MAX_M 5000\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint parent[MAX_N];\nEdge edges[MAX_M];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    if (px != py) {\n        parent[px] = py;\n    }\n}\n\nint compare(const void *a, const void *b) {\n    Edge *ea = (Edge *)a;\n    Edge *eb = (Edge *)b;\n    return ea->w - eb->w;\n}\n\nint main() {\n    int n, m;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        scanf(\"%d\", &m);\n        \n        for (int i = 0; i < m; i++) {\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            edges[i].u = a;\n            edges[i].v = b;\n            edges[i].w = d;\n        }\n        \n        qsort(edges, m, sizeof(Edge), compare);\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        int total_lanterns = 0;\n        int edges_used = 0;\n        \n        for (int i = 0; i < m && edges_used < n - 1; i++) {\n            int u = edges[i].u;\n            int v = edges[i].v;\n            int w = edges[i].w;\n            \n            if (find(u) != find(v)) {\n                unite(u, v);\n                edges_used++;\n                total_lanterns += (w / 100 - 1);\n            }\n        }\n        \n        printf(\"%d\\n\", total_lanterns);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> #define MAX_N  struct { int u, v, w; } Edge; int parent[MAX_N]; Edge edges[MAX_M]; int find(int x) { if (parent[x] != x)  return parent[x]; } void unite(int x, int y) { int px = find(x); int py = find(y); if (px != py) {  int compare(const void *a, const void *b) { Edge *ea = (Edge *)a; Edge *eb = (Edge *)b; return ea->w -  int n, m; while (scanf(\"%d\", &n) == 1  scanf(\"%d\", &m); for (int i = 0; i < m; i++) { int a, b, d; scanf(\"%d,%d,%d\", &a, &b, &d); edges[i].u = a; edges[i].v = b; edges[i].w  sizeof(Edge), compare); for (int i = 0; i < n;  0; int edges_used = 0; for (int i = 0; i < m && edges_used < n - 1; i++) {  w  edges_used++; total_lanterns += (w / 100 - 1); } } printf(\"%d\\n\", total_lanterns); } return 0; }"], "perturbed_original": [" int cost[100][100]; int mincost[100]; char  a,  b){ return (b); } return (a); } int prim(void) { int i; int res; int u, v; for (i = 0; i < V; i++){ mincost[i] = INF;  = 0; res = 0; while (1){ v = -1; for (u = 0; u <  mincost[u] < mincost[v])){ v =  == -1){ break; } used[v] = 1; res += mincost[v]; for (u = 0; u < V; u++){  } return  int num, from, to,  scanf(\"%d\", &V); if (V == 0){ break; } scanf(\"%d\", &num); for (i = 0; i < num; i++){ for (j = 0; j < num; j++){ cost[i][j] = INF; } } for (i = 0; i < num; i++){ scanf(\"%d,%d,%d\",  cost[to][from] = (dist / 100) - 1; } printf(\"%d\\n\", prim()); } return (0); }"], "original_ll": -0.5208573937416077, "sampled_ll": -0.36521008610725403, "all_perturbed_sampled_ll": [-1.3130745887756348], "all_perturbed_original_ll": [-1.481114149093628], "perturbed_sampled_ll": -1.3130745887756348, "perturbed_original_ll": -1.481114149093628, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = 0, m = 0, a = 0, b = 0, c = 0;\n\t\t\n\t\twhile(!(sb.append(reader.readLine())).equals(\"0\")){\n\t\t\tn = Integer.valueOf(sb.toString());\n\t\t\tm = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint map[][] = new int[n][n];\n\t\t\tboolean visit[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tsb.setLength(0);\n\t\t\t\tsb.append(reader.readLine());\n\t\t\t\ta = Integer.valueOf(sb.toString().split(\",\")[0]);\n\t\t\t\tb = Integer.valueOf(sb.toString().split(\",\")[1]);\n\t\t\t\tc = (Integer.valueOf(sb.toString().split(\",\")[2]) - 100) / 100;\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tvisit[0] = true;\n\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\tm = 1 << 29;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(map[0][i] < m && !visit[i]){\n\t\t\t\t\t\tm = map[0][i];\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisit[b] = true;\n\t\t\t\tc += map[0][b];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tmap[0][i] = Math.min(map[0][i], map[b][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t\tsb.setLength(0);\n\t\t}\n\t\treader.close();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, dist;\n        Edge(int to, int dist) {\n            this.to = to;\n            this.dist = dist;\n        }\n    }\n    \n    static class UnionFind {\n        int[] parent, rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        void union(int x, int y) {\n            int px = find(x);\n            int py = find(y);\n            if (px == py) return;\n            \n            if (rank[px] < rank[py]) {\n                parent[px] = py;\n            } else if (rank[px] > rank[py]) {\n                parent[py] = px;\n            } else {\n                parent[py] = px;\n                rank[px]++;\n            }\n        }\n        \n        boolean connected(int x, int y) {\n            return find(x) == find(y);\n        }\n    }\n    \n    static class MSTEdge implements Comparable<MSTEdge> {\n        int u, v, dist;\n        MSTEdge(int u, int v, int dist) {\n            this.u = u;\n            this.v = v;\n            this.dist = dist;\n        }\n        \n        public int compareTo(MSTEdge other) {\n            return this.dist - other.dist;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int m = sc.nextInt();\n            sc.nextLine();\n            \n            List<MSTEdge> edges = new ArrayList<>();\n            \n            for (int i = 0; i < m; i++) {\n                String line = sc.nextLine();\n                String[] parts = line.split(\",\");\n                int a = Integer.parseInt(parts[0]);\n                int b = Integer.parseInt(parts[1]);\n                int d = Integer.parseInt(parts[2]);\n                edges.add(new MSTEdge(a, b, d));\n            }\n            \n            // Kruskal's algorithm to find MST\n            Collections.sort(edges);\n            UnionFind uf = new UnionFind(n);\n            \n            int totalLanterns = 0;\n            \n            for (MSTEdge edge : edges) {\n                if (!uf.connected(edge.u, edge.v)) {\n                    uf.union(edge.u, edge.v);\n                    // Calculate lanterns needed for this edge\n                    // Distance is in meters, lanterns are every 100m\n                    // First lantern at 100m from one end, last at 100m from other end\n                    // For distance d, we need (d/100 - 1) lanterns\n                    int lanterns = edge.dist / 100 - 1;\n                    totalLanterns += lanterns;\n                }\n            }\n            \n            System.out.println(totalLanterns);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { static  dist; Edge(int to, int dist) { this.to = to; this.dist = dist; } } static class UnionFind { int[] parent, rank; UnionFind(int n) { parent = new int[n]; rank = new int[n];  i < n; i++) { parent[i] = i; } }  (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } void union(int  px  find(y); if (px ==  rank[py]) { parent[px] = py; } else if (rank[px] > rank[py]) { parent[py] = px;  px; rank[px]++; } } boolean connected(int x, int y) { return find(x)  class  u, v, dist; MSTEdge(int u, int v, int dist) { this.u = u; this.v = v; this.dist = dist; } public int compareTo(MSTEdge other) { return this.dist - other.dist; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0)  sc.nextLine(); List<MSTEdge> edges = new ArrayList<>(); for (int i = 0; i < m; i++) { String line = sc.nextLine();  b = Integer.parseInt(parts[1]); int d = Integer.parseInt(parts[2]); edges.add(new MSTEdge(a,   : edges) { if (!uf.connected(edge.u, edge.v)) { uf.union(edge.u, edge.v); // Calculate lanterns needed for this edge // Distance is in meters, lanterns are every 100m // First lantern at 100m from one end, last at 100m from other end // For distance  1) lanterns int lanterns = edge.dist / 100 - 1; totalLanterns += lanterns; } } System.out.println(totalLanterns); } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; public class Main{ public static void main(String[] args)throws IOException{ InputStreamReader  reader = new BufferedReader(isr); StringBuilder sb  = 0,  0, b = 0, c = 0; while(!(sb.append(reader.readLine())).equals(\"0\")){ n =  map[][] = new int[n][n];  for(int i = 0;i < n; i++)  i = 0; i < m; i++){ sb.setLength(0); sb.append(reader.readLine()); a = Integer.valueOf(sb.toString().split(\",\")[0]); b = Integer.valueOf(sb.toString().split(\",\")[1]); c = (Integer.valueOf(sb.toString().split(\",\")[2]) - 100) / 100; map[a][b] = map[b][a] = c; } c = 0; visit[0] = true; for(int  n - 1; x++){ m   n; i++){ if(map[0][i] < m && !visit[i]){ m  } } visit[b] = true; c += map[0][b]; for(int i = 0; i < n; i++){ map[0][i] = Math.min(map[0][i], map[b][i]); } } System.out.println(c); sb.setLength(0); } reader.close(); } }"], "original_ll": -0.6081327199935913, "sampled_ll": -0.41740942001342773, "all_perturbed_sampled_ll": [-1.4067574739456177], "all_perturbed_original_ll": [-1.5108683109283447], "perturbed_sampled_ll": -1.4067574739456177, "perturbed_original_ll": -1.5108683109283447, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n  n=int(input())\n  if not n:break\n  X={0}\n  Y=set(range(n))-X\n  s=0\n  l=[tuple(map(int,input().split(\",\"))) for _ in range(int(input()))]\n\n  while Y:\n    cd=[i for i in l if (i[0] in X and i[1] in Y) or (i[0] in Y and i[1] in X)]\n    cd=sorted(cd,key=lambda x:x[2])[0]\n    if cd[0] in X and cd[1] in Y:\n      X.add(cd[1])\n      Y=Y-X\n    elif cd[0] in Y and cd[1] in X:\n      X.add(cd[0])\n      Y=Y-X\n    s+=int(cd[2]/100-1)\n  print(s)\n", "sampled": "import sys\nfrom collections import defaultdict\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    px, py = find(parent, x), find(parent, y)\n    if px == py:\n        return False\n    if rank[px] < rank[py]:\n        px, py = py, px\n    parent[py] = px\n    if rank[px] == rank[py]:\n        rank[px] += 1\n    return True\n\ndef kruskal_mst(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n    edges.sort(key=lambda x: x[2])\n    mst_edges = []\n    \n    for a, b, d in edges:\n        if union(parent, rank, a, b):\n            mst_edges.append((a, b, d))\n            if len(mst_edges) == n - 1:\n                break\n    \n    return mst_edges\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    m = int(input())\n    edges = []\n    \n    for _ in range(m):\n        line = input().strip()\n        a, b, d = map(int, line.split(','))\n        edges.append((a, b, d))\n    \n    # Find MST\n    mst_edges = kruskal_mst(n, edges)\n    \n    # Calculate total lanterns needed\n    total_lanterns = 0\n    for a, b, d in mst_edges:\n        # Distance between two sites is d meters\n        # Lanterns are placed every 100m\n        # First lantern is 100m from site a, last is 100m from site b\n        # So number of lanterns = d/100 - 1\n        lanterns = d // 100 - 1\n        total_lanterns += lanterns\n    \n    print(total_lanterns)\n", "perturbed_sampled": ["import sys from collections import defaultdict def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): px, py = find(parent, x), find(parent, y) if px == py:  py, px parent[py] = px if rank[px] == rank[py]: rank[px] += 1 return  = list(range(n)) rank = [0] * n edges.sort(key=lambda x: x[2]) mst_edges = [] for a, b, d in edges: if union(parent, rank,  if len(mst_edges) == n - 1: break return mst_edges while True: n = int(input()) if n  int(input()) edges = [] for _ in range(m): line  = map(int, line.split(',')) edges.append((a, b, d)) # Find MST  total_lanterns = 0 for a, b, d in mst_edges: # Distance between two sites  are placed every 100m # First lantern is 100m from site a, last is 100m from site b # So number of lanterns =  1 total_lanterns += lanterns print(total_lanterns)"], "perturbed_original": ["while 1: n=int(input()) if not n:break X={0} Y=set(range(n))-X s=0 l=[tuple(map(int,input().split(\",\"))) for _ in range(int(input()))] while  l if (i[0] in X and i[1] in  cd=sorted(cd,key=lambda x:x[2])[0] if cd[0] in X and cd[1] in Y: X.add(cd[1]) Y=Y-X elif cd[0] in Y and cd[1] in X: X.add(cd[0]) Y=Y-X s+=int(cd[2]/100-1) print(s)"], "original_ll": -1.1023685932159424, "sampled_ll": -0.6044744849205017, "all_perturbed_sampled_ll": [-1.5902221202850342], "all_perturbed_original_ll": [-1.8614833354949951], "perturbed_sampled_ll": -1.5902221202850342, "perturbed_original_ll": -1.8614833354949951, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid timePrint(int time);\n\nint main(void){\n  int t, h, s;\n  int time;\n\n  scanf(\"%d%d%d\", &t, &h, &s);\n  while(!(t == -1 && h == -1 && s == -1)){\n    time = t*3600 + h*60 + s;\n    timePrint(7200-time);\n    timePrint(7200-time/3);\n    scanf(\"%d%d%d\", &t, &h, &s);\n  }\n  return 0;\n}\n\nvoid timePrint(int time){\n  printf(\"%02d:\", time/3600);\n  time %= 3600;\n  printf(\"%02d:\", time/60);\n  time %= 60;\n  printf(\"%02d\\n\", time);\n  return;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int T, H, S;\n    \n    while(1) {\n        scanf(\"%d %d %d\", &T, &H, &S);\n        \n        if(T == -1 && H == -1 && S == -1) {\n            break;\n        }\n        \n        // Convert current time to seconds\n        int current_seconds = T * 3600 + H * 60 + S;\n        \n        // Total tape is 120 minutes = 7200 seconds\n        int total_seconds = 120 * 60;\n        \n        // Remaining seconds\n        int remaining_seconds = total_seconds - current_seconds;\n        \n        // Standard mode: remaining time as is\n        int std_hours = remaining_seconds / 3600;\n        int std_minutes = (remaining_seconds % 3600) / 60;\n        int std_seconds = remaining_seconds % 60;\n        \n        // 3x mode: 3 times the remaining time\n        int triple_total_seconds = remaining_seconds * 3;\n        int triple_hours = triple_total_seconds / 3600;\n        int triple_minutes = (triple_total_seconds % 3600) / 60;\n        int triple_seconds = triple_total_seconds % 60;\n        \n        printf(\"%02d:%02d:%02d\\n\", std_hours, std_minutes, std_seconds);\n        printf(\"%02d:%02d:%02d\\n\", triple_hours, triple_minutes, triple_seconds);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int T, H, S;  &T, &H,  H == -1 && S == -1) { break; } // Convert current time to seconds int current_seconds = T * 3600 +  // Total tape is 120  total_seconds = 120 * 60; // Remaining seconds int remaining_seconds = total_seconds - current_seconds; // Standard mode: remaining time as is int std_hours = remaining_seconds / 3600; int std_minutes = (remaining_seconds % 3600) / 60; int std_seconds = remaining_seconds % 60; // 3x mode: 3 times the remaining time int triple_total_seconds = remaining_seconds * 3; int  int triple_minutes   % 60; printf(\"%02d:%02d:%02d\\n\", std_hours,  triple_seconds); } return 0; }"], "perturbed_original": ["#include <stdio.h>  int t, h, s; int time; scanf(\"%d%d%d\", &t, &h, &s); while(!(t == -1 && h  -1)){ time = t*3600  timePrint(7200-time/3); scanf(\"%d%d%d\", &t, &h, &s); } return 0; } void timePrint(int time){ printf(\"%02d:\", time/3600); time %= 3600; printf(\"%02d:\", time/60); time %= 60; printf(\"%02d\\n\", time); return; }"], "original_ll": -0.7608142495155334, "sampled_ll": -0.6194192171096802, "all_perturbed_sampled_ll": [-1.8386229276657104], "all_perturbed_original_ll": [-1.3975507020950317], "perturbed_sampled_ll": -1.8386229276657104, "perturbed_original_ll": -1.3975507020950317, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tint s = scanner.nextInt();\n\t\t\tif (h == -1 && m == -1 && s == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint sc = 7200 - (h * 3600 + m * 60 + s);\n\t\t\tint sc3 = sc * 3;\n\t\t\tSystem.out.println(String.format(\"%02d:%02d:%02d\", sc / 3600,\n\t\t\t\t\tsc / 60 % 60, sc % 60));\n\t\t\tSystem.out.println(String.format(\"%02d:%02d:%02d\", sc3 / 3600,\n\t\t\t\t\tsc3 / 60 % 60, sc3 % 60));\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int h = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            \n            if (h == -1 && m == -1 && s == -1) {\n                break;\n            }\n            \n            // Convert current counter to seconds\n            int usedSeconds = h * 3600 + m * 60 + s;\n            \n            // Total tape capacity in seconds (120 minutes)\n            int totalSeconds = 120 * 60;\n            \n            // Remaining seconds\n            int remainingSeconds = totalSeconds - usedSeconds;\n            \n            // Standard recording mode (remaining time as is)\n            int stdHours = remainingSeconds / 3600;\n            int stdMinutes = (remainingSeconds % 3600) / 60;\n            int stdSeconds = remainingSeconds % 60;\n            \n            // 3x recording mode (remaining time * 3)\n            int tripleSeconds = remainingSeconds * 3;\n            int tripleHours = tripleSeconds / 3600;\n            int tripleMinutes = (tripleSeconds % 3600) / 60;\n            int tripleSecs = tripleSeconds % 60;\n            \n            System.out.printf(\"%02d:%02d:%02d%n\", stdHours, stdMinutes, stdSeconds);\n            System.out.printf(\"%02d:%02d:%02d%n\", tripleHours, tripleMinutes, tripleSecs);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc  { int h = sc.nextInt(); int m = sc.nextInt(); int s  -1   counter to seconds int usedSeconds = h * 3600 + m * 60 + s; // Total tape capacity in seconds (120 minutes) int totalSeconds = 120 * 60; //  totalSeconds - usedSeconds; // Standard recording  int stdHours = remainingSeconds / 3600; int stdMinutes =  int stdSeconds = remainingSeconds % 60; // 3x recording mode (remaining time  remainingSeconds * 3; int tripleHours = tripleSeconds / 3600; int tripleMinutes = (tripleSeconds % 3600) / 60; int tripleSecs = tripleSeconds % 60; System.out.printf(\"%02d:%02d:%02d%n\", stdHours, stdMinutes, stdSeconds); System.out.printf(\"%02d:%02d:%02d%n\", tripleHours, tripleMinutes, tripleSecs); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (true) { int h = scanner.nextInt(); int m = scanner.nextInt(); int s = scanner.nextInt(); if  == -1 && s == -1) { break; } int sc = 7200  m * 60 + s); int sc3 =  60 % 60,  / 3600, sc3 / 60 % 60, sc3 % 60)); } } }"], "original_ll": -0.5527768135070801, "sampled_ll": -0.6878414750099182, "all_perturbed_sampled_ll": [-1.6210981607437134], "all_perturbed_original_ll": [-1.5923582315444946], "perturbed_sampled_ll": -1.6210981607437134, "perturbed_original_ll": -1.5923582315444946, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#!/usr/bin/python\n# coding: utf-8\n\nwhile True:\n    h, m, s = map(int, raw_input().split())\n    if h == m == s == -1:\n        break\n\n    full = 2 * 3600\n    rest = full - (h * 3600 + m * 60 + s)\n\n    h = int(rest / 3600)\n    m = int((rest - h * 3600) / 60)\n    s = rest - h * 3600 - m * 60 \n\n    th = int(rest / 1200)\n    tm = int((rest - th * 1200) / 20)\n    ts = (rest - th * 1200 - tm * 20) * 3\n\n    print \"{:02d}:{:02d}:{:02d}\".format(h, m, s)\n    print \"{:02d}:{:02d}:{:02d}\".format(th, tm, ts)", "sampled": "while True:\n    T, H, S = map(int, input().split())\n    if T == -1 and H == -1 and S == -1:\n        break\n    \n    # Convert current counter to seconds\n    current_seconds = T * 3600 + H * 60 + S\n    \n    # Total tape capacity in seconds (120 minutes)\n    total_seconds = 120 * 60\n    \n    # Remaining tape in seconds\n    remaining_seconds = total_seconds - current_seconds\n    \n    # Standard recording: remaining time is as is\n    std_hours = remaining_seconds // 3600\n    std_minutes = (remaining_seconds % 3600) // 60\n    std_seconds = remaining_seconds % 60\n    \n    # 3x recording: can record 3 times the remaining tape time\n    triple_total_seconds = remaining_seconds * 3\n    triple_hours = triple_total_seconds // 3600\n    triple_minutes = (triple_total_seconds % 3600) // 60\n    triple_seconds = triple_total_seconds % 60\n    \n    print(f\"{std_hours:02d}:{std_minutes:02d}:{std_seconds:02d}\")\n    print(f\"{triple_hours:02d}:{triple_minutes:02d}:{triple_seconds:02d}\")\n", "perturbed_sampled": ["while True: T,  if T == -1 and H == -1 and S == -1: break # Convert current counter to seconds  + S #  (120  60 # Remaining tape in seconds remaining_seconds = total_seconds - current_seconds # Standard recording: remaining time is  // 3600 std_minutes = (remaining_seconds % 3600) //  60 # 3x recording: can record 3 times the remaining tape time triple_total_seconds = remaining_seconds * 3 triple_hours = triple_total_seconds // 3600 triple_minutes = (triple_total_seconds % 3600) // 60 triple_seconds = triple_total_seconds % 60 print(f\"{std_hours:02d}:{std_minutes:02d}:{std_seconds:02d}\") print(f\"{triple_hours:02d}:{triple_minutes:02d}:{triple_seconds:02d}\")"], "perturbed_original": ["#!/usr/bin/python # coding: utf-8 while True: h, m, s = map(int, raw_input().split()) if h == m == s ==  * 3600 rest = full - (h * 3600 + m * 60 + s) h =  3600) / 60) s = rest - h * 3600 - m * 60 th = int(rest / 1200) tm = int((rest - th * 1200) / 20) ts  1200 -  print \"{:02d}:{:02d}:{:02d}\".format(h, m, s) print \"{:02d}:{:02d}:{:02d}\".format(th, tm, ts)"], "original_ll": -0.6480379700660706, "sampled_ll": -0.8599873185157776, "all_perturbed_sampled_ll": [-1.963027834892273], "all_perturbed_original_ll": [-1.4087028503417969], "perturbed_sampled_ll": -1.963027834892273, "perturbed_original_ll": -1.4087028503417969, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(n){while(~scanf(\"%d\",&n)){float x=1,y=0,r,t;for(;--n>0;x=t)r=hypot(x,y),t=x-y/r,y+=x/r;n+2&&printf(\"%f\\n%f\\n\",x,y);}}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != -1) {\n        double x = 1.0, y = 0.0;\n        double wx = 0.0, wy = 0.0;\n        \n        for (int i = 2; i <= n; i++) {\n            double dx = wx - x;\n            double dy = wy - y;\n            double dist = sqrt(dx * dx + dy * dy);\n            \n            double ux = dx / dist;\n            double uy = dy / dist;\n            \n            double rx = -uy;\n            double ry = ux;\n            \n            x = x + rx;\n            y = y + ry;\n        }\n        \n        printf(\"%.2f\\n%.2f\\n\", x, y);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int n; while (scanf(\"%d\", &n) == 1 && n != -1) { double x  double wx = 0.0, wy = 0.0;  {  x; double dy = wy - y; double dist = sqrt(dx * dx + dy * dy); double ux = dx / dist; double uy = dy / dist;   x + rx; y = y + ry; } printf(\"%.2f\\n%.2f\\n\", x, y); } return 0; }"], "perturbed_original": ["main(n){while(~scanf(\"%d\",&n)){float x=1,y=0,r,t;for(;--n>0;x=t)r=hypot(x,y),t=x-y/r,y+=x/r;n+2&&printf(\"%f\\n%f\\n\",x,y);}}"], "original_ll": -2.558379650115967, "sampled_ll": -0.6859150528907776, "all_perturbed_sampled_ll": [-1.6463189125061035], "all_perturbed_original_ll": [-2.558379650115967], "perturbed_sampled_ll": -1.6463189125061035, "perturbed_original_ll": -2.558379650115967, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble x, y;\n\t\tint n;\n\n\t\tn = sc.nextInt();\n\t\twhile (n != -1) {\n\t\t\tx = 1.0;\n\t\t\ty = 0.0;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (x == 0.0) {\n\t\t\t\t\tif (0 < y) {\n\t\t\t\t\t\tx -= 1.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx += 1.0;\n\t\t\t\t\t}\n\t\t\t\t} else if (y == 0.0) {\n\t\t\t\t\tif (0 < x) {\n\t\t\t\t\t\ty += 1.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty -= 1.0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdouble theta = Math.atan2(y, x) + Math.PI / 2;\n\t\t\t\t\tx += Math.cos(theta);\n\t\t\t\t\ty += Math.sin(theta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(x);\n\t\t\tSystem.out.println(y);\n\t\t\tn = sc.nextInt();\n\t\t}\t\t\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == -1) break;\n            \n            // Start at position (1, 0) - 1m east of the well at (0, 0)\n            double x = 1.0;\n            double y = 0.0;\n            \n            // Initial direction: facing the well (west)\n            double dx = -1.0;\n            double dy = 0.0;\n            \n            // Process steps 2 to n\n            for (int i = 2; i <= n; i++) {\n                // Turn right 90 degrees\n                double newDx = dy;\n                double newDy = -dx;\n                dx = newDx;\n                dy = newDy;\n                \n                // Move 1m forward\n                x += dx;\n                y += dy;\n                \n                // Face the well again\n                double dist = Math.sqrt(x * x + y * y);\n                dx = -x / dist;\n                dy = -y / dist;\n            }\n            \n            System.out.printf(\"%.2f\\n%.2f\\n\", x, y);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  = sc.nextInt();  // Start at position (1, 0) - 1m east of the well at (0, 0) double x = 1.0; double y = 0.0; // Initial direction: facing the well  double dy = 0.0; // Process steps 2 to n for (int i  i++) { // Turn right 90 degrees double newDx = dy; double newDy = -dx; dx = newDx; dy = newDy; // Move 1m forward x += dx; y += dy; // Face  dx = -x / dist; dy = -y / dist; } System.out.printf(\"%.2f\\n%.2f\\n\", x, y); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String args[])  Scanner(System.in); double x, y; int n; n = sc.nextInt(); while (n != -1) { x =  i < n; i++) { if (x == 0.0) { if (0 <  } else  } else if (y == 0.0) { if (0 < x) { y += 1.0; } else { y -= 1.0; } } else { double theta = Math.atan2(y, x) + Math.PI / 2; x += Math.cos(theta); y += Math.sin(theta); } } System.out.println(x); System.out.println(y);  }"], "original_ll": -0.6165692210197449, "sampled_ll": -0.8555433750152588, "all_perturbed_sampled_ll": [-1.8730425834655762], "all_perturbed_original_ll": [-1.5139282941818237], "perturbed_sampled_ll": -1.8730425834655762, "perturbed_original_ll": -1.5139282941818237, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for e in iter(input,'-1'):\n z=1\n for _ in[0]*~-int(e):d=z*1j;z+=d/abs(d)\n print(z.real)\n print(z.imag)\n", "sampled": "import math\n\ndef solve(n):\n    # Start at position (1, 0) - 1m east of the well\n    x, y = 1.0, 0.0\n    \n    # Initial direction: facing the well (west)\n    # We'll track the angle we're facing\n    \n    for step in range(2, n + 1):\n        # Calculate direction to well from current position\n        dx_to_well = -x\n        dy_to_well = -y\n        angle_to_well = math.atan2(dy_to_well, dx_to_well)\n        \n        # Turn right 90 degrees from facing the well\n        new_angle = angle_to_well - math.pi / 2\n        \n        # Move 1m in that direction\n        x += math.cos(new_angle)\n        y += math.sin(new_angle)\n    \n    return x, y\n\nwhile True:\n    n = int(input())\n    if n == -1:\n        break\n    \n    x, y = solve(n)\n    print(f\"{x:.2f}\")\n    print(f\"{y:.2f}\")\n", "perturbed_sampled": ["import   1m east of the well x, y = 1.0, 0.0 # Initial direction: facing the well  angle we're facing for step in range(2, n + 1):  from current position dx_to_well = -x dy_to_well = -y angle_to_well = math.atan2(dy_to_well, dx_to_well) # Turn right 90 degrees from facing the well new_angle = angle_to_well - math.pi  in that direction x += math.cos(new_angle) y += math.sin(new_angle) return x, y while  n == -1: break x, y = solve(n) print(f\"{x:.2f}\") print(f\"{y:.2f}\")"], "perturbed_original": ["for e in iter(input,'-1'): z=1 for _ in[0]*~-int(e):d=z*1j;z+=d/abs(d) print(z.real) print(z.imag)"], "original_ll": -2.970486879348755, "sampled_ll": -1.1308629512786865, "all_perturbed_sampled_ll": [-2.309389591217041], "all_perturbed_original_ll": [-2.916921854019165], "perturbed_sampled_ll": -2.309389591217041, "perturbed_original_ll": -2.916921854019165, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#define LENGTH 1001\n\nint main(void)\n{\n  char st[LENGTH];\n  int i, j, k, l, m, check, fix, count, kosuu, decimal=1;\n  int a, b, t=0;\n  char ch;\n\n  i = 0;\n  while(scanf(\"%1c\",&ch)!=EOF)\n    {\n      st[i] = ch;\n      i++;\n    }\n  st[i+1] = 0;\n  st[i+2] = 0;\n  st[i+3] = 0;\n\n  k = strlen(st);\n\n\n  /*\n  printf(\"k = %d\\n\",strlen(st));\n\n  for(i=0;i<=strlen(st);i++)\n    {\n      printf(\"st[%d] %d\\n\",i,st[i]); \n      }\n  */\n\n  j = 1;\n  count = 1;\n  kosuu = 0;\n\n  i = 0;\n  t = 0;\n  while(1)\n    {\n      if(st[i]=='@')\n\t{\n\t  kosuu = st[i+1]-48;\n\t  for(j=0;j<=kosuu-1;j++)\n\t    {\n\t      printf(\"%c\",st[i+2]);\n\t    }\n\t  i = i + 3;\n\t}\n      else if(st[i]==10)\n\t{\n\t  printf(\"\\n\");\n\t  i++;\n\t}\n      else if(st[i]==0)\n\t{\n\t  break;\n\t}\n      else\n\t{\n\t  printf(\"%c\",st[i]);\n\t  i++;\n\t}\n    }\n  printf(\"\\n\");\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    char line[256];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int len = strlen(line);\n        if (len > 0 && line[len-1] == '\\n') {\n            line[len-1] = '\\0';\n            len--;\n        }\n        \n        int i = 0;\n        while (i < len) {\n            if (line[i] == '@') {\n                i++;\n                int count = line[i] - '0';\n                i++;\n                char ch = line[i];\n                for (int j = 0; j < count; j++) {\n                    putchar(ch);\n                }\n                i++;\n            } else {\n                putchar(line[i]);\n                i++;\n            }\n        }\n        putchar('\\n');\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <ctype.h> int main() { char line[256]; while  len = strlen(line); if (len > 0 && line[len-1]  '\\0'; len--; } int i = 0; while  (line[i] == '@') { i++; int count = line[i]  = line[i]; for (int j = 0;  putchar(ch); } i++; } else { putchar(line[i]); i++; } } putchar('\\n'); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #define LENGTH 1001 int main(void) { char st[LENGTH]; int i, j, k, l, m, check, fix, count, kosuu, decimal=1; int a, b, t=0; char ch; i = 0; while(scanf(\"%1c\",&ch)!=EOF) { st[i]   = strlen(st); /* printf(\"k = %d\\n\",strlen(st)); for(i=0;i<=strlen(st);i++) { printf(\"st[%d] %d\\n\",i,st[i]); } */ j = 1; count = 1; kosuu = 0; i = 0; t  { kosuu   3; } else if(st[i]==10) { printf(\"\\n\"); i++; } else if(st[i]==0) { break; } else { printf(\"%c\",st[i]); i++; } } printf(\"\\n\"); return 0; }"], "original_ll": -1.0701336860656738, "sampled_ll": -0.4814278185367584, "all_perturbed_sampled_ll": [-1.8600847721099854], "all_perturbed_original_ll": [-1.7765400409698486], "perturbed_sampled_ll": -1.8600847721099854, "perturbed_original_ll": -1.7765400409698486, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.FileInputStream;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) throws Exception{\n        while(hasNext()){\n            StringBuilder s = new StringBuilder(NLine());\n            StringBuilder ans=new StringBuilder();\n            if(s.length()==0)return;\n            for (int i = 0; i < s.length(); i++) {\n                if(s.charAt(i)=='@'){\n                    i++;\n                    int len = s.charAt(i)-'0';\n                    i++;\n                    for (int j = 0; j < len; j++) {\n                        ans.append(s.charAt(i));\n                    }\n                } else {\n                    ans.append(s.charAt(i));\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n\n    \n    static int c=0;\n    static int NI(){\n        return (int)NL();\n    }\n    \n    static long NL(){\n        try {\n            long r = 0;\n            skip();\n            if(c=='-') return -NL();\n            for(;'0'<=c&&c<='9';c=System.in.read())\n                r = r * 10 + c - '0';\n            return r;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    \n    static char NC(){\n        try {\n            skip();\n            return (char)c;\n        } catch (Exception e) {\n            return 0;\n        }\n    }\n    \n    static String NS(){\n        StringBuilder sb=new StringBuilder();\n        try {\n            skip();\n            for(;!isSkip();){\n                sb.append((char)c);\n                c=System.in.read();\n            }\n            return sb.toString();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n    \n    static String NLine(){\n        StringBuilder sb=new StringBuilder();\n        try {\n            for(;c!='\\n'&&c!='\\r';){\n                sb.append((char)c);\n                c=System.in.read();\n//                System.out.println(c);\n            }\n            c=System.in.read();\n            return sb.toString();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n    \n    static void skip(){\n        try{\n            while(isSkip()){\n                c=System.in.read();\n            }\n        } catch (Exception e){}\n        \n    }\n    \n    static boolean hasNext(){\n        skip();\n        return c!=-1;\n    }\n    \n    static boolean isSkip(){\n        return 0 <= c && c <= ' ';\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            StringBuilder result = new StringBuilder();\n            \n            int i = 0;\n            while (i < line.length()) {\n                if (line.charAt(i) == '@') {\n                    // Found @ symbol, next character is count, character after that is the character to repeat\n                    i++; // move past @\n                    int count = line.charAt(i) - '0'; // get the count digit\n                    i++; // move to the character to repeat\n                    char charToRepeat = line.charAt(i);\n                    \n                    // Append the character 'count' times\n                    for (int j = 0; j < count; j++) {\n                        result.append(charToRepeat);\n                    }\n                    i++; // move past the repeated character\n                } else {\n                    // Regular character, just append it\n                    result.append(line.charAt(i));\n                    i++;\n                }\n            }\n            \n            System.out.println(result.toString());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  public static void main(String[] args) { Scanner sc  { String line = sc.nextLine(); StringBuilder result = new StringBuilder(); int i = 0; while (i <  is count, character after that is the character to repeat i++; // move past @  '0'; // get the count digit i++; // move to the character to repeat char charToRepeat = line.charAt(i); // Append the character 'count' times for (int j = 0; j < count; j++) { result.append(charToRepeat); } i++; // move past the repeated character } else { // Regular character, just append it result.append(line.charAt(i));  sc.close(); } }"], "perturbed_original": ["import java.io.FileInputStream; import java.util.Scanner; public class Main { /** * @param args */ public static void main(String[] args) throws Exception{ while(hasNext()){ StringBuilder s  StringBuilder(); if(s.length()==0)return; for  if(s.charAt(i)=='@'){ i++;  for (int j = 0; j < len;  else { ans.append(s.charAt(i)); } } System.out.println(ans); } } static  return (int)NL(); } static long NL(){ try { long r = 0; skip(); if(c=='-') return -NL(); for(;'0'<=c&&c<='9';c=System.in.read()) r = r * 10  r; } catch  } } static char NC(){ try { skip();  e) { return 0; } } static  try { skip(); for(;!isSkip();){ sb.append((char)c); c=System.in.read(); } return sb.toString(); } catch (Exception e) { return \"\"; } } static String NLine(){ StringBuilder sb=new StringBuilder(); try  System.out.println(c);  catch (Exception e) { return \"\"; } } static void skip(){ try{ while(isSkip()){ c=System.in.read(); } } catch (Exception e){} } static boolean hasNext(){ skip(); return c!=-1; } static boolean isSkip(){ return 0 <= c && c <= ' '; } }"], "original_ll": -0.8130732774734497, "sampled_ll": -0.6543360948562622, "all_perturbed_sampled_ll": [-2.0312612056732178], "all_perturbed_original_ll": [-1.8126224279403687], "perturbed_sampled_ll": -2.0312612056732178, "perturbed_original_ll": -1.8126224279403687, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\n\ndef method(l):\n    return l if l.find('@') < 0 else method(l.replace(l[l.find('@'):l.find('@')+3], l[l.find('@')+2]*int(l[l.find('@')+1])))\n\nif __name__ == '__main__':\n    for line in sys.stdin:\n        print(method(line))", "sampled": "import sys\nimport re\n\nfor line in sys.stdin:\n    line = line.rstrip('\\n')\n    result = []\n    i = 0\n    while i < len(line):\n        if line[i] == '@':\n            # Find the digit(s) after @\n            j = i + 1\n            while j < len(line) and line[j].isdigit():\n                j += 1\n            count = int(line[i+1:j])\n            # The character to repeat is at position j\n            if j < len(line):\n                char = line[j]\n                result.append(char * count)\n                i = j + 1\n            else:\n                i = j\n        else:\n            result.append(line[i])\n            i += 1\n    print(''.join(result))\n", "perturbed_sampled": ["import sys import re for line in sys.stdin: line = line.rstrip('\\n') result = [] i = 0 while i < len(line): if line[i] == '@': # Find the digit(s) after @ j = i + 1 while j < len(line) and line[j].isdigit(): j += 1 count =  repeat is at position j if  line[j] result.append(char * count) i =  i += 1 print(''.join(result))"], "perturbed_original": ["import sys def method(l): return l  method(l.replace(l[l.find('@'):l.find('@')+3], l[l.find('@')+2]*int(l[l.find('@')+1]))) if __name__ == '__main__': for line in sys.stdin: print(method(line))"], "original_ll": -1.6962916851043701, "sampled_ll": -0.8367400169372559, "all_perturbed_sampled_ll": [-2.3072783946990967], "all_perturbed_original_ll": [-2.3039932250976562], "perturbed_sampled_ll": -2.3072783946990967, "perturbed_original_ll": -2.3039932250976562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\nint main(){\n\tint i=0,j;\n\tdouble x[20],y[20],s=0;\n    //\u5024\u306e\u8aad\u307f\u8fbc\u307f\n    \n    while(scanf(\"%lf,%lf\\n\",&x[i],&y[i]) !=EOF) {\n    \t\t//scanf(\"%lf%lf\",&x[i],&y[i]);\n    \t\ti++;\n    \t}\n    \tj=i\n    \tfor(i=1;i<j;i++){\n    \t\ts+=(x[i]*y[i+1]-x[i+1]*y[i]);\n    \t}\n        s+=(x[i]*y[0]-x[0]*y[i]);\n    \tprintf(\"%0.6lf\\n\",fabs(s)/2.0);\n    \n    return 0;\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x[20], y[20];\n    int n = 0;\n    char c;\n    \n    while (scanf(\"%lf,%lf\", &x[n], &y[n]) == 2) {\n        n++;\n        while ((c = getchar()) != '\\n' && c != EOF);\n        if (c == EOF) break;\n    }\n    \n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        area += x[i] * y[j] - x[j] * y[i];\n    }\n    area = fabs(area) / 2.0;\n    \n    printf(\"%.6f\\n\", area);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { double x[20], <extra_id_2>(<extra_id_3>y [31]; } double<extra_id_4>y [15]; double area =<extra_id_5>double area = 0.0;<extra_id_6>+=<extra_id_7>y[15]; if ((c=-(c=(c)^=(c(-1)*(c(2)))^-1); area =<extra_id_8>if ((c==EOF)<extra_id_9>0;<extra_id_10>) y[n] =<extra_id_11>if<extra_id_12>{ char c; while (scanf(\"%lf,%lf\", &x[n], &y[n]) == 2) { n++; while ((c = getchar()) != '\\n' && c != EOF); if (c  area = 0.0; for (int i = 0; i < n; i++) { int j =  area += x[i] * y[j] - x[j] * y[i]; } area = fabs(area)  0; }"], "perturbed_original": ["#include <stdio.h> #include  double x[20],y[20],s=0; //\u5024\u306e\u8aad\u307f\u8fbc\u307f while(scanf(\"%lf,%lf\\n\",&x[i],&y[i]) !=EOF) { //scanf(\"%lf%lf\",&x[i],&y[i]); i++; } j=i for(i=1;i<j;i++){ s+=(x[i]*y[i+1]-x[i+1]*y[i]); } s+=(x[i]*y[0]-x[0]*y[i]); printf(\"%0.6lf\\n\",fabs(s)/2.0); return 0; }"], "original_ll": -1.2834644317626953, "sampled_ll": -0.5375872254371643, "all_perturbed_sampled_ll": [-2.1705076694488525], "all_perturbed_original_ll": [-1.6143068075180054], "perturbed_sampled_ll": -2.1705076694488525, "perturbed_original_ll": -1.6143068075180054, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tdouble[] x = new double[20];\n\t\tdouble[] y = new double[20];\n\t\tint i = 0;\n\t\tString string;\n\t\t\n\t\twhile((string = reader.readLine()) != null){\n\t\t\tx[i] = Double.valueOf(string.split(\",\")[0]);\n\t\t\ty[i] = Double.valueOf(string.split(\",\")[1]);\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tdouble a = Math.hypot(x[1] - x[0], y[1] - y[0]);\n\t\tdouble b = Math.hypot(x[2] - x[0], y[2] - y[0]);\n\t\tdouble c = Math.hypot(x[2] - x[1], y[2] - y[1]);\n\t\tdouble z = (a + b + c) / 2;\n\t\tdouble S = Math.sqrt(z * (z - a) * (z - b) * (z - c));\n\t\tfor(int j = 2; j < i - 1; j++){\n\t\t\ta = Math.hypot(x[j] - x[0], y[j] - y[0]);\n\t\t\tb = Math.hypot(x[j + 1] - x[0], y[j + 1] - y[0]);\n\t\t\tc = Math.hypot(x[j + 1] - x[j], y[j + 1] - y[j]);\n\t\t\tz = (a + b + c) / 2;\n\t\t\tS += Math.sqrt(z * (z - a) * (z - b) * (z - c));\n\t\t}\n\t\tSystem.out.println(S);\n\t}\n}", "sampled": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ArrayList<Double> x = new ArrayList<>();\n        ArrayList<Double> y = new ArrayList<>();\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) continue;\n            \n            String[] parts = line.split(\",\");\n            x.add(Double.parseDouble(parts[0]));\n            y.add(Double.parseDouble(parts[1]));\n        }\n        \n        int n = x.size();\n        double area = 0.0;\n        \n        for (int i = 0; i < n; i++) {\n            int j = (i + 1) % n;\n            area += x.get(i) * y.get(j);\n            area -= x.get(j) * y.get(i);\n        }\n        \n        area = Math.abs(area) / 2.0;\n        \n        System.out.printf(\"%.6f\\n\", area);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; import java.util.ArrayList; public class Main { public static void main(String[] args) { Scanner  x =  new ArrayList<>(); while (sc.hasNext()) { String line = sc.nextLine().trim(); if  line.split(\",\"); x.add(Double.parseDouble(parts[0])); y.add(Double.parseDouble(parts[1])); } int n = x.size(); double area = 0.0; for (int i = 0; i < n; i++) { int  % n; area += x.get(i) *  y.get(i); } area = Math.abs(area) / 2.0; System.out.printf(\"%.6f\\n\", area); sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main{   InputStreamReader(System.in);  double[] x = new double[20]; double[] y = new double[20]; int i = 0; String  y[i] = Double.valueOf(string.split(\",\")[1]); i++; } double a = Math.hypot(x[1] - x[0], y[1] - y[0]); double b = Math.hypot(x[2] - x[0], y[2] - y[0]); double c = Math.hypot(x[2] - x[1], y[2] - y[1]); double z = (a +  double S =  * (z - b) * (z - c)); for(int j = 2; j < i - 1; j++){ a = Math.hypot(x[j] - x[0], y[j] - y[0]); b = Math.hypot(x[j + 1] - x[0], y[j  = Math.hypot(x[j  + 1] - y[j]); z = (a + b + c) / 2; S += Math.sqrt(z * (z - a) * (z  c)); } System.out.println(S); } }"], "original_ll": -0.369960218667984, "sampled_ll": -0.4304264485836029, "all_perturbed_sampled_ll": [-1.553748369216919], "all_perturbed_original_ll": [-1.2139469385147095], "perturbed_sampled_ll": -1.553748369216919, "perturbed_original_ll": -1.2139469385147095, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "i = 0\nx = []\ny = []\nwhile 1:\n    try:\n        a,b = map(float,input().split(\",\"))\n        x.append(a)\n        y.append(b)\n    except EOFError:\n        break\n\nS = 0\nfor i in range(len(x)-2):\n    a = ((x[0]-x[i+1]) ** 2 + (y[0]-y[i+1]) ** 2) ** 0.5\n    b = ((x[0]-x[i+2]) ** 2 + (y[0]-y[i+2]) ** 2) ** 0.5\n    c = ((x[i+1]-x[i+2]) ** 2 + (y[i+1]-y[i+2]) ** 2) ** 0.5\n    z = (a + b + c)/2\n    S += (z * (z - a) * (z - b) * (z - c)) ** 0.5\nprint(S)\n", "sampled": "import sys\nimport math\n\ndef polygon_area(points):\n    n = len(points)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    area = abs(area) / 2.0\n    return area\n\npoints = []\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        x, y = map(float, line.split(','))\n        points.append((x, y))\n\narea = polygon_area(points)\nprint(f\"{area:.6f}\")\n", "perturbed_sampled": ["import sys  = len(points) area = 0.0 for i in range(n): j =  area += points[i][0] * points[j][1] area -= points[j][0] * points[i][1] area = abs(area) / 2.0 return area points =  line = line.strip() if line: x, y = map(float, line.split(',')) points.append((x, y)) area = polygon_area(points) print(f\"{area:.6f}\")"], "perturbed_original": ["i = 0 x = [] y = [] while 1: try: a,b = map(float,input().split(\",\")) x.append(a) y.append(b) except EOFError: <extra_id_5>)<extra_id_6>print(S)[0]<extra_id_7>in x[i+1]: a =<extra_id_8>]<extra_id_9>d = x [<extra_id_10>2 ) ) y<extra_id_11>] =<extra_id_12>= [ ] y.append<extra_id_13>1<extra_id_14>floor ( x<extra_id_15>x<extra_id_16>. append<extra_id_17>( c //<extra_id_18>i + i in range(len(x)-2): a = ((x[0]-x[i+1]) ** 2 +  b = ((x[0]-x[i+2]) ** 2 + (y[0]-y[i+2])  = ((x[i+1]-x[i+2])  2) ** 0.5 z  c)/2 S += (z * (z - a) * (z - b) * (z - c)) ** 0.5 print(S)"], "original_ll": -0.5600886940956116, "sampled_ll": -0.4200994670391083, "all_perturbed_sampled_ll": [-1.6983822584152222], "all_perturbed_original_ll": [-2.176056385040283], "perturbed_sampled_ll": -1.6983822584152222, "perturbed_original_ll": -2.176056385040283, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nint main(int argc,char* argv[]){\n  \n  for(;;){\n    int q;\n    double x;\n\n    scanf(\"%d\",&q);\n    if(q == -1){break;}\n    \n    x = q/2;\n    while(!(fabs(x*x*x - q) < 0.00001*q)){\n      x = x - (x*x*x-q)/(3*x*x);\n    }\n\n    printf(\"%lf\\n\",x);\n  }\n\n  return 0;\n  \n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double q;\n    \n    while(1) {\n        scanf(\"%lf\", &q);\n        if(q == -1) break;\n        \n        double x = q / 2.0;\n        \n        while(fabs(x * x * x - q) >= 0.00001 * q) {\n            x = x - (x * x * x - q) / (3 * x * x);\n        }\n        \n        printf(\"%.6f\\n\", x);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { double q; while(1) { scanf(\"%lf\", &q); if(q == -1) break;  2.0; while(fabs(x * x * x -  { x = x - (x * x *  * x * x); } printf(\"%.6f\\n\", x); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> int main(int argc,char* argv[]){ for(;;){ int q; double x; scanf(\"%d\",&q); if(q == -1){break;} x =  0.00001*q)){ x  printf(\"%lf\\n\",x); } return 0; }"], "original_ll": -1.3982172012329102, "sampled_ll": -0.8093869090080261, "all_perturbed_sampled_ll": [-1.9227166175842285], "all_perturbed_original_ll": [-2.1931676864624023], "perturbed_sampled_ll": -1.9227166175842285, "perturbed_original_ll": -2.1931676864624023, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-5;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tdouble q = sc.nextDouble();\n\t\t\tif( q == 0 ) { System.out.println(0.00000); continue; }\n\t\t\tif( q == -1 ) break;\n\t\t\tdouble x = q / 2;\n\t\t\twhile( abs( x*x*x - q) >= EPS * q ) {\n\t\t\t\tx = f(x, q);\n\t\t\t}\n\t\t\tdebug(EPS*q);\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n\t\n\tdouble f(double x, double q) {\n\t\treturn x - (x*x*x - q) / ( 3 * x*x);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int q = sc.nextInt();\n            if (q == -1) break;\n            \n            double x = q / 2.0;\n            \n            while (Math.abs(x * x * x - q) >= 0.00001 * q) {\n                x = x - (x * x * x - q) / (3 * x * x);\n            }\n            \n            System.out.printf(\"%.6f\\n\", x);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) {  (q == -1) break; double x  (Math.abs(x * x * x - q) >= 0.00001 * q) { x = x - (x * x * x - q) / (3 * x * x); } System.out.printf(\"%.6f\\n\", x); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import static java.lang.Math.*; import static java.util.Arrays.*; public class Main { int INF = 1 << 28; double EPS = 1e-5; void run() { Scanner sc = new Scanner(System.in); for(;;) { double  == 0 ) { System.out.println(0.00000); continue; } if( q  x = q / 2; while( abs( x*x*x - q) >= EPS * q ) { x =  } } double f(double x, double  (x*x*x - q)  } public static void main(String[] args) { new  { // System.err.println(Arrays.deepToString(os)); } }"], "original_ll": -1.1372607946395874, "sampled_ll": -0.6905351281166077, "all_perturbed_sampled_ll": [-1.796686053276062], "all_perturbed_original_ll": [-2.1681671142578125], "perturbed_sampled_ll": -1.796686053276062, "perturbed_original_ll": -2.1681671142578125, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True :\n    q = int(input())\n    if q == -1 :\n        break\n    \n    n = 1\n    x = q / 2\n    while True :\n        if abs(x**3 - q) < (0.00001 * q) :\n            break\n        x = x - (x**3 - q) / (3 * x**2)\n    \n    print('{:.6f}'.format(x))\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    q = int(line.strip())\n    if q == -1:\n        break\n    \n    x = q / 2.0\n    \n    while abs(x**3 - q) >= 0.00001 * q:\n        x = x - (x**3 - q) / (3 * x**2)\n    \n    print(f\"{x:.6f}\")\n", "perturbed_sampled": ["import sys  = int(line.strip()) if q == -1: break x = q / 2.0 while abs(x**3 - q) >=  x - (x**3 - q) / (3 * x**2) print(f\"{x:.6f}\")"], "perturbed_original": [" int(input()) if q == -1 : break n = 1 x = q / 2 while True : if abs(x**3 -  : break x = x - (x**3 - q) / (3 * x**2) print('{:.6f}'.format(x))"], "original_ll": -1.173939824104309, "sampled_ll": -1.235925316810608, "all_perturbed_sampled_ll": [-2.821990728378296], "all_perturbed_original_ll": [-2.3188648223876953], "perturbed_sampled_ll": -2.821990728378296, "perturbed_original_ll": -2.3188648223876953, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\n  double x1,y1,x2,y2,xq,yq,x,y;\n  double a,b,A,B,cx,cy;\n\n  while(~scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\",&x1,&y1,&x2,&y2,&xq,&yq)){\n    \n    if(y1==0 && y2==0){\n      printf(\"%lf %lf\\n\",xq,-yq);\n      continue;\n    }\n    if(xx1==0 && x2==0){\n      printf(\"%lf %lf\\n\",-xq,yq);\n      continue;\n    }\n    a=(y2-y1)?(x2-x1)/(y2-y1):0;\n    b=y2-a*x2;\n\n    A=a?-1/a:0;\n    B=yq-A*xq;\n\n    cx=(a-A)?(B-b)/(a-A):0;\n    cy=A*cx+B;\n\n    x=2*cx-xq;\n    y=2*cy-yq;\n\n    printf(\"%lf %lf\\n\",x,y);\n  }\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double x1, y1, x2, y2, xq, yq;\n    \n    while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\", &x1, &y1, &x2, &y2, &xq, &yq) == 6) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        \n        double a = dx * dx + dy * dy;\n        double t = ((xq - x1) * dx + (yq - y1) * dy) / a;\n        \n        double px = x1 + t * dx;\n        double py = y1 + t * dy;\n        \n        double rx = 2 * px - xq;\n        double ry = 2 * py - yq;\n        \n        printf(\"%.6f %.6f\\n\", rx, ry);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  x2, y2, xq, yq; while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\", &x1, &y1, &x2, &y2, &xq, &yq) == 6) { double dx = x2 - x1; double dy = y2 - y1; double a = dx * dx +  =  +  / a; double px = x1 + t * dx; double py = y1 + t * dy; double rx = 2 * px - xq;  py - yq; printf(\"%.6f  0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ double x1,y1,x2,y2,xq,yq,x,y; double a,b,A,B,cx,cy; while(~scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\",&x1,&y1,&x2,&y2,&xq,&yq)){ if(y1==0 && y2==0){ printf(\"%lf %lf\\n\",xq,-yq); continue;  b=y2-a*x2; A=a?-1/a:0; B=yq-A*xq; cx=(a-A)?(B-b)/(a-A):0; cy=A*cx+B; x=2*cx-xq; y=2*cy-yq; printf(\"%lf %lf\\n\",x,y); } return 0; }"], "original_ll": -1.0862812995910645, "sampled_ll": -0.4900423586368561, "all_perturbed_sampled_ll": [-1.6358141899108887], "all_perturbed_original_ll": [-1.6176477670669556], "perturbed_sampled_ll": -1.6358141899108887, "perturbed_original_ll": -1.6176477670669556, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(in.hasNext())new AOJ0081().doIt();\n\t}\n\n\tclass AOJ0081{\n\t\t//p0-p1\u306e\u76f4\u7dda\u304c\u3042\u308b\u3068\u304d\u306b\u76f4\u7ddap2\u304b\u3089\u76f4\u7dda\u3089\u3057\u305f\u3068\u304dp0-p1\u4e0a\u306e\u5782\u76f4\u306a\u70b9\u3092\u6c42\u3081\u308b\u3002\n\t\tprivate Point2D projection(Line2D l,Point2D p2){\n\t\t\tdouble kyori = l.getP1().distance(l.getP2());\n\t\t\tdouble angle = angle(l.getP1(),l.getP2(), p2);\n\t\t\tdouble t = l.getP1().distance(p2) * Math.cos(angle);\n\t\t\tPoint2D result = new Point2D.Double(l.getP1().getX()+(l.getP2().getX()-l.getP1().getX())*t/kyori,\n\t\t\t\t\tl.getP1().getY()+(l.getP2().getY()-l.getP1().getY())*t/kyori);\n\t\t\treturn result;\n\t\t}\n\t\tprivate double angle(Point2D p0, Point2D p1, Point2D p2){\n\t\t\treturn Math.atan2(p2.getY()-p0.getY(),p2.getX()-p0.getX())-\n\t\t\t\t\tMath.atan2(p1.getY()-p0.getY(),p1.getX()-p0.getX());\n\t\t}\n\t\t\n\t\t\n\t\tvoid doIt(){\n\t\t\tString input[] = in.next().split(\",\");\n\t\t\tdouble a[] = new double[input.length];\n\t\t\tfor(int i=0;i<a.length;i++)a[i] = Double.parseDouble(input[i]);\n\t\t\tLine2D l = new Line2D.Double(a[0], a[1], a[2], a[3]);\n\t\t\tPoint2D p = new Point2D.Double(a[4],a[5]);\n\t\t\tPoint2D result = projection(l, p);\n\t\t\t double dx = result.getX()-p.getX();\n             double dy = result.getY()-p.getY();\n             double tx = dx+result.getX();\n             double ty = dy+result.getY();\n             System.out.printf(\"%.9f %.9f\\n\",tx,ty);\n\t\t}\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            \n            double x1 = Double.parseDouble(parts[0]);\n            double y1 = Double.parseDouble(parts[1]);\n            double x2 = Double.parseDouble(parts[2]);\n            double y2 = Double.parseDouble(parts[3]);\n            double xq = Double.parseDouble(parts[4]);\n            double yq = Double.parseDouble(parts[5]);\n            \n            // Direction vector of the line P1P2\n            double dx = x2 - x1;\n            double dy = y2 - y1;\n            \n            // Vector from P1 to Q\n            double qx = xq - x1;\n            double qy = yq - y1;\n            \n            // Project Q onto the line P1P2\n            // Parameter t for the projection point\n            double t = (qx * dx + qy * dy) / (dx * dx + dy * dy);\n            \n            // Projection point H on the line\n            double hx = x1 + t * dx;\n            double hy = y1 + t * dy;\n            \n            // R is the reflection of Q across H\n            double rx = 2 * hx - xq;\n            double ry = 2 * hy - yq;\n            \n            System.out.printf(\"%.6f %.6f%n\", rx, ry);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public  Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String line = sc.nextLine(); String[] parts =  double y1   // Direction vector of the line P1P2 double dx = x2 - x1; double dy = y2 - y1; // Vector from P1 to Q double qx = xq - x1; double qy = yq - y1; // Project Q onto the line P1P2 // Parameter t for the projection point double t = (qx * dx +  *  // Projection  double hx = x1 + t * dx; double hy = y1 + t * dy; // R is the reflection of Q across  * hx - xq; double ry = 2 * hy - yq; System.out.printf(\"%.6f %.6f%n\", rx, ry); } sc.close(); } }"], "perturbed_original": ["import java.awt.geom.Line2D; import java.awt.geom.Point2D;  {  public static void main(String[] args) { new Main(); } public Main() { while(in.hasNext())new AOJ0081().doIt(); } class AOJ0081{ //p0-p1\u306e\u76f4\u7dda\u304c\u3042\u308b\u3068\u304d\u306b\u76f4\u7ddap2\u304b\u3089\u76f4\u7dda\u3089\u3057\u305f\u3068\u304dp0-p1\u4e0a\u306e\u5782\u76f4\u306a\u70b9\u3092\u6c42\u3081\u308b\u3002 private Point2D projection(Line2D l,Point2D p2){ double kyori = l.getP1().distance(l.getP2()); double angle = angle(l.getP1(),l.getP2(), p2); double t = l.getP1().distance(p2) * Math.cos(angle); Point2D result = new Point2D.Double(l.getP1().getX()+(l.getP2().getX()-l.getP1().getX())*t/kyori, l.getP1().getY()+(l.getP2().getY()-l.getP1().getY())*t/kyori); return  p0, Point2D p1, Point2D  void   for(int i=0;i<a.length;i++)a[i] = Double.parseDouble(input[i]); Line2D l = new Line2D.Double(a[0], a[1], a[2], a[3]); Point2D p =  projection(l, p); double dx = result.getX()-p.getX(); double dy = result.getY()-p.getY(); double tx = dx+result.getX(); double ty = dy+result.getY(); System.out.printf(\"%.9f %.9f\\n\",tx,ty); } } }"], "original_ll": -0.9384642243385315, "sampled_ll": -0.517986536026001, "all_perturbed_sampled_ll": [-1.8139039278030396], "all_perturbed_original_ll": [-1.5523030757904053], "perturbed_sampled_ll": -1.8139039278030396, "perturbed_original_ll": -1.5523030757904053, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfrom math import complex as C\nfor e in sys.stdin:\n a,b,c,d,e,f=map(float,e.split(','))\n z,w,q=C(a,b),C(c,d),C(e,f)\n w-=z\n z+=(w/abs(w))**2*(q-z).conjugate()\n print(z.real,z.imag)\n", "sampled": "import sys\n\ndef reflect_point(x1, y1, x2, y2, xq, yq):\n    # Vector along the line P1P2\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    # Vector from P1 to Q\n    qx = xq - x1\n    qy = yq - y1\n    \n    # Project Q onto the line P1P2\n    # t = dot(PQ, P1P2) / dot(P1P2, P1P2)\n    t = (qx * dx + qy * dy) / (dx * dx + dy * dy)\n    \n    # Point on the line closest to Q\n    px = x1 + t * dx\n    py = y1 + t * dy\n    \n    # Reflect Q across the line\n    rx = 2 * px - xq\n    ry = 2 * py - yq\n    \n    return rx, ry\n\nfor line in sys.stdin:\n    coords = list(map(float, line.strip().split(',')))\n    x1, y1, x2, y2, xq, yq = coords\n    rx, ry = reflect_point(x1, y1, x2, y2, xq, yq)\n    print(f\"{rx:.6f} {ry:.6f}\")\n", "perturbed_sampled": ["import sys def reflect_point(x1, y1, x2, y2, xq, yq): # Vector along the line P1P2 dx = x2  - y1 # Vector from P1 to Q qx = xq - x1 qy = yq - y1 # Project Q onto the line P1P2 # t = dot(PQ, P1P2) / dot(P1P2, P1P2)  + qy * dy) / (dx *  # Point on the  =  py = y1 + t * dy # Reflect Q across the line rx = 2 * px - xq ry  yq  in sys.stdin: coords = list(map(float, line.strip().split(','))) x1, y1, x2, y2, xq, yq = coords rx, ry = reflect_point(x1,  print(f\"{rx:.6f} {ry:.6f}\")"], "perturbed_original": ["import sys from math  e in sys.stdin: a,b,c,d,e,f=map(float,e.split(',')) z,w,q=C(a,b),C(c,d),C(e,f) w-=z z+=(w/abs(w))**2*(q-z).conjugate() print(z.real,z.imag)"], "original_ll": -2.2443127632141113, "sampled_ll": -0.5288609266281128, "all_perturbed_sampled_ll": [-1.8238216638565063], "all_perturbed_original_ll": [-2.972299337387085], "perturbed_sampled_ll": -1.8238216638565063, "perturbed_original_ll": -2.972299337387085, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <limits.h>\n\nstatic int units[8];\nstatic int waitings[8];\n\nvoid setup() {\n\tunits[0] = 4;\n\tunits[1] = 1;\n\tunits[2] = 4;\n\tunits[3] = 1;\n\tunits[4] = 2;\n\tunits[5] = 1;\n\tunits[6] = 2;\n\tunits[7] = 1;\n}\n\nint scan_waitings() {\n\treturn scanf(\"%d %d %d %d %d %d %d %d\",\n\t\t\t&waitings[0], &waitings[1], &waitings[2], &waitings[3],\n\t\t\t&waitings[4], &waitings[5], &waitings[6], &waitings[7]);\n}\n\nint count_passengers(int offset) {\n\tint sum = 0;\n\tint i;\n\tfor (i = 0; i < 8; i++) {\n\t\tsum += (units[(i + offset) % 8] > waitings[i]) ? waitings[i] : units[(i + offset) % 8];\n\t}\n\treturn sum;\n}\n\nvoid print_result(int offset) {\n\tint i;\n\tfor (i = 0; i < 8; i++) {\n\t\tprintf(\"%d\", units[(i + offset) % 8]);\n\t\tif (i < 7) {\n\t\t\tprintf(\" \");\n\t\t} else {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}\n\nint main() {\n\tint offset = 0;\n\tint max = 0;\n\tint count = 0;\n\tint max_offset = 0;\n\tchar str[9];\n\tint num = INT_MAX;\n\tsetup();\n\n\twhile (scan_waitings() > 0) {\n\t\tmax = 0;\n\t\tcount = 0;\n\t\tmax_offset = 0;\n\t\tnum = INT_MAX;\n\t\tfor (offset = 0; offset < 8; offset++) {\n\t\t\tcount = count_passengers(offset);\n\t\t\tsprintf(str, \"%d%d%d%d%d%d%d%d\",\n\t\t\t\t\t\tunits[(0 + offset) % 8],\n\t\t\t\t\t\tunits[(1 + offset) % 8],\n\t\t\t\t\t\tunits[(2 + offset) % 8],\n\t\t\t\t\t\tunits[(3 + offset) % 8],\n\t\t\t\t\t\tunits[(4 + offset) % 8],\n\t\t\t\t\t\tunits[(5 + offset) % 8],\n\t\t\t\t\t\tunits[(6 + offset) % 8],\n\t\t\t\t\t\tunits[(7 + offset) % 8]\n\t\t\t\t\t\t);\n\t\t\tif (count > max) {\n//\t\t\t\tprintf(\"\u65b0\u8a18\u9332   offset = %d, \u914d\u7f6e = %d\\n\", offset, atoi(str));\n\t\t\t\tnum = atoi(str);\n\t\t\t\tmax_offset = offset;\n\t\t\t\tmax = count;\n\t\t\t} else if (count == max) {\n\t\t\t\tprintf(\"\u30bf\u30a4\u8a18\u9332 offset = %d, \u914d\u7f6e = %d\\n\", offset, atoi(str));\n\t\t\t\tif (num > atoi(str)) {\n\t\t\t\t\tmax = count;\n\t\t\t\t\tnum = atoi(str);\n\t\t\t\t\tmax_offset = offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprint_result(max_offset);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int p[8];\n    int rides[8] = {4, 1, 4, 1, 2, 1, 2, 1}; // Initial configuration\n    \n    while (scanf(\"%d %d %d %d %d %d %d %d\", &p[0], &p[1], &p[2], &p[3], &p[4], &p[5], &p[6], &p[7]) == 8) {\n        int best_rotation = 0;\n        int min_left = 1000000;\n        long long min_value = 99999999;\n        \n        // Try all 8 rotations\n        for (int rot = 0; rot < 8; rot++) {\n            int left = 0;\n            long long value = 0;\n            \n            // Calculate how many customers can't ride and the resulting value\n            for (int i = 0; i < 8; i++) {\n                int ride_pos = (i - rot + 8) % 8;\n                int capacity = rides[ride_pos];\n                int customers = p[i];\n                \n                if (customers > capacity) {\n                    left += customers - capacity;\n                }\n                \n                value = value * 10 + capacity;\n            }\n            \n            // Update best if this is better\n            if (left < min_left || (left == min_left && value < min_value)) {\n                min_left = left;\n                min_value = value;\n                best_rotation = rot;\n            }\n        }\n        \n        // Output the best configuration\n        for (int i = 0; i < 8; i++) {\n            int ride_pos = (i - best_rotation + 8) % 8;\n            if (i > 0) printf(\" \");\n            printf(\"%d\", rides[ride_pos]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int p[8]; int rides[8] = {4, 1, 4, 1,  Initial configuration while  %d %d %d\", &p[0], &p[1], &p[2], &p[3], &p[4], &p[5], &p[6], &p[7]) == 8) {  min_left = 1000000; long long min_value = 99999999; // Try  rot = 0; rot < 8; rot++) { int left = 0; long long value = 0; // Calculate how many customers can't ride and the resulting value for (int i = 0; i < 8; i++) { int ride_pos = (i - rot + 8) %  { left += customers  capacity; } // Update  if  == min_left && value < min_value)) { min_left = left; min_value = value;  // Output the best configuration for (int i = 0; i < 8; i++) { int ride_pos = (i - best_rotation + 8) % 8; if (i > 0) printf(\" \"); printf(\"%d\", rides[ride_pos]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <limits.h> static int units[8];  units[1] = 1; units[2] = 4; units[3] = 1; units[4] = 2; units[5] = 1; units[6] = 2; units[7] = 1; }  %d %d %d %d %d %d %d\", &waitings[0], &waitings[1], &waitings[2], &waitings[3], &waitings[4], &waitings[5],  offset) { int  for (i = 0; i < 8; i++) { sum += (units[(i + offset) % 8] > waitings[i]) ?  % 8]; } return sum; } void print_result(int offset) { int i; for (i = 0; i < 8; i++) { printf(\"%d\", units[(i + offset) %   { printf(\"\\n\"); } } }  = 0; int count =  = INT_MAX; setup(); while (scan_waitings() > 0) { max = 0; count = 0; max_offset = 0; num = INT_MAX; for (offset = 0; offset  = count_passengers(offset);   % 8], units[(2 + offset) % 8], units[(3 + offset) % 8], units[(4 + offset) % 8], units[(5 + offset) % 8], units[(6  + offset) % 8] ); if (count > max) { // printf(\"\u65b0\u8a18\u9332 offset = %d, \u914d\u7f6e = %d\\n\", offset,  = offset; max = count; } else if (count == max) { printf(\"\u30bf\u30a4\u8a18\u9332 offset = %d, \u914d\u7f6e = %d\\n\", offset, atoi(str)); if (num > atoi(str)) { max = count; num = atoi(str); max_offset = offset; } } } print_result(max_offset); } return 0; }"], "original_ll": -0.6256103515625, "sampled_ll": -0.6897754073143005, "all_perturbed_sampled_ll": [-1.6712826490402222], "all_perturbed_original_ll": [-1.4345676898956299], "perturbed_sampled_ll": -1.6712826490402222, "perturbed_original_ll": -1.4345676898956299, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Main {\n    \n    public static void main( final String[] args ) {\n\t\n\tfinal Scanner stdin = new Scanner( System.in );\n\tfinal int[] ls = { 4, 1, 4, 1, 2, 1, 2, 1 };\n\t\n\twhile ( stdin.hasNextInt() ) {\n\t    final int[] ps = new int[8];\n\t    for ( int i = 0; i < 8; i++ ) {\n\t\tps[i] = stdin.nextInt();\n\t    }\n\t    \n\t    final int[] ans = new int[8];\t    \n\t    int maxPeople = 0;\n\t    for ( int i = 0; i < 8; i++ ) {\n\t\tfinal int p = ip( ps, ls );\n\t\tif ( p > maxPeople ) {\n\t\t    maxPeople = p;\n\t\t    System.arraycopy( ls, 0, ans, 0, 8 );\n\t\t}\n\t\tnext( ls );\n\t    }\n\t    System.out.print( ans[0] );\n\t    for ( int i = 1; i < 8; i++ ) {\n\t\tSystem.out.print( \" \" + ans[i] );\n\t    }\n\t    System.out.println();\n\t}\n    }\n    \n    static void next( int[] a ) {\n\tfinal int front = a[0];\n\tfor ( int i = 0; i < 7; i++ ) {\n\t    a[i] = a[i + 1];\n\t}\n\ta[7] = front;\n    }\n\n    static int ip( int[] ps, int[] ls ) {\n\tint sum = 0;\n\tfor ( int i = 0; i < ps.length; i++ ){\n\t    sum += min( ls[i], ps[i] );\n\t}\n\treturn sum;\n    }    \n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int[] people = new int[8];\n            for (int i = 0; i < 8; i++) {\n                people[i] = sc.nextInt();\n            }\n            \n            int[] rides = {4, 1, 4, 1, 2, 1, 2, 1};\n            \n            int minUnserved = Integer.MAX_VALUE;\n            int[] bestArrangement = new int[8];\n            \n            for (int rotation = 0; rotation < 8; rotation++) {\n                int[] currentArrangement = new int[8];\n                for (int i = 0; i < 8; i++) {\n                    currentArrangement[i] = rides[(i - rotation + 8) % 8];\n                }\n                \n                int unserved = 0;\n                for (int i = 0; i < 8; i++) {\n                    unserved += Math.max(0, people[i] - currentArrangement[i]);\n                }\n                \n                if (unserved < minUnserved) {\n                    minUnserved = unserved;\n                    bestArrangement = currentArrangement.clone();\n                } else if (unserved == minUnserved) {\n                    if (isSmaller(currentArrangement, bestArrangement)) {\n                        bestArrangement = currentArrangement.clone();\n                    }\n                }\n            }\n            \n            for (int i = 0; i < 8; i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(bestArrangement[i]);\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean isSmaller(int[] a, int[] b) {\n        for (int i = 0; i < 8; i++) {\n            if (a[i] < b[i]) return true;\n            if (a[i] > b[i]) return false;\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int[] people =  = 0; i < 8; i++) { people[i] = sc.nextInt(); } int[] rides = {4, 1, 4, 1, 2, 1, 2,  int[] bestArrangement = new int[8];  rotation < 8; rotation++) { int[] currentArrangement = new int[8]; for (int i = 0; i < 8; i++) {  + 8)  =  i++) { unserved += Math.max(0, people[i] - currentArrangement[i]);  { minUnserved = unserved; bestArrangement = currentArrangement.clone(); } else if (unserved ==  { bestArrangement = currentArrangement.clone(); } } } for (int i = 0; i < 8;  0) System.out.print(\" \"); System.out.print(bestArrangement[i]); } System.out.println(); } sc.close(); } private static boolean isSmaller(int[] a, int[] b) { for (int i = 0; i < 8; i++) {  b[i]) return false; } return false; } }"], "perturbed_original": ["import java.util.*; import java.io.*; import static java.lang.Math.*; class Main { public static void main( final String[] args ) { final Scanner stdin = new  ls = { 4, 1, 4, 1, 2, 1, 2, 1 }; while ( stdin.hasNextInt() ) { final int[] ps = new int[8]; for ( int i = 0; i < 8; i++ ) { ps[i] = stdin.nextInt(); } final int[] ans = new int[8]; int maxPeople  i = 0; i < 8; i++ ) { final int p =  ( p > maxPeople ) { maxPeople = p; System.arraycopy( ls, 0, ans, 0, 8 ); } next( ls ); } System.out.print( ans[0] ); for ( int i = 1; i <  \" \" +  final int front =  = 0; i < 7; i++ ) { a[i] = a[i + 1];  static int  ) { int sum = 0; for ( int i = 0; i < ps.length; i++ ){ sum  }"], "original_ll": -0.6981613636016846, "sampled_ll": -0.4170468747615814, "all_perturbed_sampled_ll": [-1.3840551376342773], "all_perturbed_original_ll": [-1.5972611904144287], "perturbed_sampled_ll": -1.3840551376342773, "perturbed_original_ll": -1.5972611904144287, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\np=['41412121','41212141','21414121','21214141','14141212','14121214','12141412','12121414']\ng=lambda x:list(map(int,x))\nfor e in sys.stdin:\n d={}\n for f in p:d[sum(s-t for s,t in zip(g(e.split()),g(f))if s>t)]=f\n print(*list(d[min(d)]))\n", "sampled": "import sys\nfrom itertools import permutations\n\ndef solve(passengers):\n    # Define the vehicles: 4, 4, 2, 2, 1, 1, 1, 1\n    vehicles = [4, 4, 2, 2, 1, 1, 1, 1]\n    \n    min_unable = float('inf')\n    best_arrangement = None\n    \n    # Generate all unique permutations of vehicles\n    seen = set()\n    for perm in permutations(vehicles):\n        if perm in seen:\n            continue\n        seen.add(perm)\n        \n        # Calculate unable to ride\n        unable = 0\n        for i in range(8):\n            if passengers[i] > perm[i]:\n                unable += passengers[i] - perm[i]\n        \n        # Check if this is better\n        if unable < min_unable:\n            min_unable = unable\n            best_arrangement = perm\n        elif unable == min_unable:\n            # Compare lexicographically\n            if perm < best_arrangement:\n                best_arrangement = perm\n    \n    return best_arrangement\n\n# Read all input\nlines = []\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        lines.append(line)\n\n# Process each dataset\nfor line in lines:\n    passengers = list(map(int, line.split()))\n    result = solve(passengers)\n    print(' '.join(map(str, result)))\n", "perturbed_sampled": ["import sys from itertools import permutations def solve(passengers): # Define the vehicles: 4, 4, 2, 2, 1, 1, 1, 1 vehicles = [4, 4, 2, 2, 1, 1,  best_arrangement = None # Generate all unique permutations of vehicles seen = set() for perm in permutations(vehicles): if perm in seen: continue seen.add(perm) # Calculate unable to ride unable = 0 for i in range(8): if passengers[i] > perm[i]: unable += passengers[i] - perm[i] # Check if this is better if unable < min_unable: min_unable = unable best_arrangement = perm elif  lexicographically if   [] for line in sys.stdin: line = line.strip() if line:  passengers = list(map(int,  '.join(map(str, result)))"], "perturbed_original": ["import sys p=['41412121','41212141','21414121','21214141','14141212','14121214','12141412','12121414'] g=lambda x:list(map(int,x)) for e  in p:d[sum(s-t for s,t in zip(g(e.split()),g(f))if s>t)]=f print(*list(d[min(d)]))"], "original_ll": -1.6581324338912964, "sampled_ll": -0.7800477743148804, "all_perturbed_sampled_ll": [-2.00416898727417], "all_perturbed_original_ll": [-1.9613268375396729], "perturbed_sampled_ll": -2.00416898727417, "perturbed_original_ll": -1.9613268375396729, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int a,b,c,d,t=0;\n  char s;\n  while(scanf(\"%d %d %d\",&a,&b,&c)!=EOF){\n    if(a<=1868 && b<=9 && c<8){\n      printf(\"pre-meiji\\n\");\n      d=1;\n      t=1;\n    }\n    else if(a<=1912){\n      if(a!=1912){\n\tprintf(\"meiji \");\n\ta=a-1868+1;\n\td=0;\n\tt=1;\n      }\n      else if(a==1912){\n\tif(b<7){\n\t  printf(\"meiji \");\n\t  a=a-1868+1;\n\t  d=0;\n\t  t=1;\n\t}\n\telse if(b>=7){\n\t  if(c<30){\n\t    printf(\"meiji \");\n\t    a=a-1868+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t}\n      }\n    }\n    if(a<=1926 && t==0){\n      if(a!=1926){\n\tprintf(\"taisyo \");\n\ta=a-1912+1;\n\td=0;\n\tt=1;\n      }\n      else if(a==1926){\n\tif(b<12){\n\t  printf(\"taisyo \");\n\t  a=a-1912+1;\n\t  d=0;\n\t  t=1;\n\t}\n\telse if(b==12){\n\t  if(c<25){\n\t    printf(\"taisyo \");\n\t    a=a-1912+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t  if(c>=25){\n\t    printf(\"showa \");\n\t    a=a-1926+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t}\n      }\n    }\n    if(a<=1989 && t==0){\n      if(a!=1989){\n\tprintf(\"showa \");\n\ta=a-1926+1;\n\td=0;\n\tt=1;\n      }\n      else if(a==1989){\n\tif(b==1){\n\t  if(c<8){\n\t    printf(\"showa \");\n\t    a=a-1926+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t}\n      }\n    }\n    if(a>=1989 && t==0){\n      if(a!=1989){\n      printf(\"heisei \");\n      a=a-1989+1;\n      d=0;\n    }\n      else if(a==1989){\n\tif(b!=1){\n\t  printf(\"heisei \");\n\t  a=a-1989+1;\n\t  d=0;\n\t}\n\telse if(b==1){\n\t  if(c>=8){\n\t  printf(\"heisei \");\n\t  a=a-1989+1;\n\t  d=0;\n\t  }\n\t}\n      }\n    }\n    if(d==0){\n      printf(\"%d %d %d\\n\",a,b,c);\n    }\n  }\n  return (0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int year, month, day;\n    \n    while (scanf(\"%d %d %d\", &year, &month, &day) != EOF) {\n        if (year < 1868 || (year == 1868 && month < 9) || (year == 1868 && month == 9 && day < 8)) {\n            printf(\"pre-meiji\\n\");\n        }\n        else if (year < 1912 || (year == 1912 && month < 7) || (year == 1912 && month == 7 && day <= 29)) {\n            printf(\"meiji %d %d %d\\n\", year - 1868 + 1, month, day);\n        }\n        else if (year < 1926 || (year == 1926 && month < 12) || (year == 1926 && month == 12 && day <= 24)) {\n            printf(\"taisho %d %d %d\\n\", year - 1912 + 1, month, day);\n        }\n        else if (year < 1989 || (year == 1989 && month == 1 && day <= 7)) {\n            printf(\"showa %d %d %d\\n\", year - 1926 + 1, month, day);\n        }\n        else {\n            printf(\"heisei %d %d %d\\n\", year - 1989 + 1, month, day);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  year, month, day; while (scanf(\"%d %d %d\", &year, &month, &day) != EOF) { if (year < 1868 || (year == 1868 && month < 9) || (year == 1868 && month == 9 && day < 8)) { printf(\"pre-meiji\\n\"); } else if  == 1912 && month < 7) || (year == 1912 && month  29)) {  - 1868 + 1,  (year  1926 && month < 12) || (year == 1926 && month == 12 && day <= 24)) { printf(\"taisho  1912 + 1,  (year ==  && day <= 7)) { printf(\"showa %d %d %d\\n\", year - 1926 + 1, month, day); } else { printf(\"heisei %d %d %d\\n\", year - 1989 + 1, month, day); } } return 0; }"], "perturbed_original": ["#include<stdio.h>   printf(\"pre-meiji\\n\");  if(a!=1912){ printf(\"meiji \"); a=a-1868+1; d=0; t=1; } else if(a==1912){ if(b<7){ printf(\"meiji \"); a=a-1868+1; d=0; t=1; } else if(b>=7){ if(c<30){ printf(\"meiji \"); a=a-1868+1; d=0; t=1; } } } } if(a<=1926 && t==0){  t=1; } else if(a==1926){ if(b<12){ printf(\"taisyo \"); a=a-1912+1; d=0; t=1; } else  d=0; t=1; } if(c>=25){ printf(\"showa \"); a=a-1926+1; d=0; t=1; } }  if(a!=1989){ printf(\"showa \");  if(a==1989){ if(b==1){ if(c<8){ printf(\"showa \"); a=a-1926+1; d=0; t=1; } } } } if(a>=1989 && t==0){ if(a!=1989){ printf(\"heisei \"); a=a-1989+1; d=0; } else if(a==1989){ if(b!=1){ printf(\"heisei \"); a=a-1989+1; d=0; } else if(b==1){ if(c>=8){ printf(\"heisei \"); a=a-1989+1; d=0; } } } } if(d==0){ printf(\"%d %d %d\\n\",a,b,c); } } return (0); }"], "original_ll": -0.6027581095695496, "sampled_ll": -0.44209176301956177, "all_perturbed_sampled_ll": [-1.1976581811904907], "all_perturbed_original_ll": [-1.0322314500808716], "perturbed_sampled_ll": -1.1976581811904907, "perturbed_original_ll": -1.0322314500808716, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nclass Main\n{\n    public static void main(String args[])throws IOException\n    {\n\tBufferedReader input=new BufferedReader(new InputStreamReader(System.in));\n\tString str;\n\twhile((str=input.readLine())!=null)\n\t    {\n\t\tString str_ary[]=str.split(\" \");\n\t\tint x[]=new int[3];\n\t\tfor(int i=0;i<3;i++)\n\t\t    {\n\t\t\tx[i]=Integer.parseInt(str_ary[i]);\n\t\t\t\n\t\t    }\n\t\tif((x[0]<1868) \n\t\t   || ((x[0]==1868) && (x[1]<9))\n\t\t   || ((x[0]==1868) && (x[1]==9) && (x[2]<8)))System.out.println(\"pre-meiji\");\n\t\tif(((1869<=x[0]) && (x[0]<=1911))\n\t\t   || (x[0]==1868) && (9<=x[1]) && (8<=x[2])\n\t\t   \n\t\t   || (x[0]==1912 && x[1]==7 && x[2]<=29)\n\t\t   || (x[0]==1912) && x[1]<=7)System.out.println(\"meiji\");\n\t\tif(((1913<=x[0]) && (x[0]<=1925))\n\t\t   || ((x[0]==1912) && (7<=x[1]) && (30<=x[2]))\n\t\t   || (x[0]==1926 && x[1]==12 && x[2]<=24)\n\t\t   || ((x[0]==1912) && (7<=x[1]))\n\t\t   )System.out.println(\"taisho\");\n\t\tif(((1927<=x[0]) && (x[0]<=1988))\n\t\t   || ((x[0]==1926) && (12==x[1]) && (25<=x[2]))\n\t\t   || ((x[0]==1989) && (x[1]==1) && (x[2]<=7))\n\t\t   \n\t\t   \n)System.out.println(\"showa\");\n\t\tif((1989==x[0]) && (1<=x[1]) && (8<=x[2])\n\t\t   || 1990<=x[0]\n\t\t   || (1989==x[0]) && (1<x[1]))System.out.println(\"heisei\");\n\t    }\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int year = sc.nextInt();\n            int month = sc.nextInt();\n            int day = sc.nextInt();\n            \n            // Convert to comparable format (YYYYMMDD)\n            int date = year * 10000 + month * 100 + day;\n            \n            // Define era boundaries\n            int meijiStart = 18680908;\n            int meijiEnd = 19120729;\n            int taishoStart = 19120730;\n            int taishoEnd = 19261224;\n            int showaStart = 19261225;\n            int showaEnd = 19890107;\n            int heiseiStart = 19890108;\n            \n            if (date < meijiStart) {\n                System.out.println(\"pre-meiji\");\n            } else if (date >= meijiStart && date <= meijiEnd) {\n                int eraYear = year - 1868 + 1;\n                System.out.println(\"meiji \" + eraYear + \" \" + month + \" \" + day);\n            } else if (date >= taishoStart && date <= taishoEnd) {\n                int eraYear = year - 1912 + 1;\n                System.out.println(\"taisho \" + eraYear + \" \" + month + \" \" + day);\n            } else if (date >= showaStart && date <= showaEnd) {\n                int eraYear = year - 1926 + 1;\n                System.out.println(\"showa \" + eraYear + \" \" + month + \" \" + day);\n            } else if (date >= heiseiStart) {\n                int eraYear = year - 1989 + 1;\n                System.out.println(\"heisei \" + eraYear + \" \" + month + \" \" + day);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext())  int month = sc.nextInt(); int day = sc.nextInt(); // Convert to comparable format (YYYYMMDD) int date = year *  + day; // Define era  int meijiEnd = 19120729; int taishoStart = 19120730; int taishoEnd = 19261224; int showaStart = 19261225; int showaEnd =  if (date < meijiStart) { System.out.println(\"pre-meiji\"); } else if (date >= meijiStart && date <= meijiEnd) { int  + eraYear + \" \" + month  }  && date  = year - 1912 + 1; System.out.println(\"taisho \" + eraYear + \" \" + month + \" \" + day); } else if  <= showaEnd) { int eraYear = year - 1926 + 1; System.out.println(\"showa \"  + month + \" \" + day); } else if (date >= heiseiStart) { int eraYear = year   \" + month + \" \" + day); } } sc.close(); } }"], "perturbed_original": [" public static void main(String args[])throws IOException { BufferedReader input=new BufferedReader(new InputStreamReader(System.in)); String str; while((str=input.readLine())!=null) { String str_ary[]=str.split(\" \"); int x[]=new int[3]; for(int i=0;i<3;i++) { x[i]=Integer.parseInt(str_ary[i]);  (x[1]<9)) || ((x[0]==1868) && (x[1]==9) && (x[2]<8)))System.out.println(\"pre-meiji\"); if(((1869<=x[0]) && (x[0]<=1911))  (8<=x[2]) || (x[0]==1912 && x[1]==7 && x[2]<=29) || (x[0]==1912) && x[1]<=7)System.out.println(\"meiji\"); if(((1913<=x[0])  (x[0]==1926 && x[1]==12 && x[2]<=24) || ((x[0]==1912) && (7<=x[1])) )System.out.println(\"taisho\"); if(((1927<=x[0]) && (x[0]<=1988)) || ((x[0]==1926) && (12==x[1]) && (25<=x[2]))  (x[2]<=7)) )System.out.println(\"showa\"); if((1989==x[0]) && (1<=x[1]) && (8<=x[2]) || 1990<=x[0] || (1989==x[0]) && (1<x[1]))System.out.println(\"heisei\"); } } }"], "original_ll": -0.8536616563796997, "sampled_ll": -0.4157615005970001, "all_perturbed_sampled_ll": [-1.4667712450027466], "all_perturbed_original_ll": [-1.2241424322128296], "perturbed_sampled_ll": -1.4667712450027466, "perturbed_original_ll": -1.2241424322128296, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from datetime import datetime\ndef era(f):\n    meiji_st  = datetime(1868, 9, 8)\n    taisho_st = datetime(1912, 7,30)\n    showa_st  = datetime(1926,12,25)\n    heisei_st = datetime(1989, 1, 8)\n\n    y,m,d = f\n    dt = datetime(y,m,d)\n    if dt > heisei_st:\n        ret = \"heisei %d %d %d\" % (dt.year - heisei_st.year+1,dt.month,dt.day) \n    elif dt > showa_st:\n        ret = \"showa %d %d %d\" % (dt.year - showa_st.year+1,dt.month,dt.day) \n    elif dt > taisho_st:\n        ret = \"taisho %d %d %d\" % (dt.year - taisho_st.year+1,dt.month,dt.day) \n    elif dt > meiji_st:\n        ret = \"meiji %d %d %d\" % (dt.year - meiji_st.year+1,dt.month,dt.day) \n    else:\n       ret = \"pre-meiji\"\n\n    return(ret)\n\nwhile True:\n    try:\n        f = map(int, input().strip().split())\n        print(era(f))\n    except EOFError:\n        break", "sampled": "import sys\n\ndef to_wareki(year, month, day):\n    # Convert date to comparable format (YYYYMMDD)\n    date = year * 10000 + month * 100 + day\n    \n    # Era boundaries in YYYYMMDD format\n    meiji_start = 18680908\n    meiji_end = 19120729\n    taisho_start = 19120730\n    taisho_end = 19261224\n    showa_start = 19261225\n    showa_end = 19890107\n    heisei_start = 19890108\n    \n    if date < meiji_start:\n        return \"pre-meiji\"\n    elif date <= meiji_end:\n        wareki_year = year - 1868 + 1\n        return f\"meiji {wareki_year} {month} {day}\"\n    elif date <= taisho_end:\n        wareki_year = year - 1912 + 1\n        return f\"taisho {wareki_year} {month} {day}\"\n    elif date <= showa_end:\n        wareki_year = year - 1926 + 1\n        return f\"showa {wareki_year} {month} {day}\"\n    else:\n        wareki_year = year - 1989 + 1\n        return f\"heisei {wareki_year} {month} {day}\"\n\nfor line in sys.stdin:\n    parts = line.strip().split()\n    year = int(parts[0])\n    month = int(parts[1])\n    day = int(parts[2])\n    print(to_wareki(year, month, day))\n", "perturbed_sampled": ["import sys def to_wareki(year, month, day): # Convert  date = year * 10000 + month * 100 + day # Era boundaries in YYYYMMDD format meiji_start = 18680908 meiji_end = 19120729 taisho_start = 19120730 taisho_end = 19261224 showa_start  heisei_start = 19890108 if date < meiji_start: return \"pre-meiji\" elif date <= meiji_end: wareki_year = year - 1868 + 1 return f\"meiji {wareki_year}  taisho_end: wareki_year = year  f\"taisho {wareki_year} {month} {day}\" elif date <= showa_end: wareki_year = year - 1926 +  year - 1989 + 1 return  line  year = int(parts[0]) month = int(parts[1]) day = int(parts[2]) print(to_wareki(year, month, day))"], "perturbed_original": ["from datetime import datetime def era(f): meiji_st  = datetime(1912, 7,30) showa_st = datetime(1926,12,25) heisei_st  = f dt = datetime(y,m,d) if dt > heisei_st: ret  % (dt.year  showa_st: ret = \"showa %d %d %d\" % (dt.year - showa_st.year+1,dt.month,dt.day) elif dt > taisho_st: ret = \"taisho %d %d %d\" % (dt.year - taisho_st.year+1,dt.month,dt.day) elif dt  %d %d %d\" % (dt.year - meiji_st.year+1,dt.month,dt.day) else: ret = \"pre-meiji\" return(ret) while True: try: f  EOFError: break"], "original_ll": -0.6804536581039429, "sampled_ll": -0.5960653424263, "all_perturbed_sampled_ll": [-1.6401015520095825], "all_perturbed_original_ll": [-1.622780203819275], "perturbed_sampled_ll": -1.6401015520095825, "perturbed_original_ll": -1.622780203819275, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<stdlib.h>\nint main(void){\n\tint n,m,i,j;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=j=0;i++<n;j%=i){j+=m;}\n\t\tprintf(\"%d\\n\",j+1);\n\t}\n\treturn 0; \n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n, m;\n    \n    while(1) {\n        scanf(\"%d %d\", &n, &m);\n        if(n == 0 && m == 0) break;\n        \n        int people[1000];\n        for(int i = 0; i < n; i++) {\n            people[i] = i + 1;\n        }\n        \n        int count = n;\n        int pos = n - 1;\n        \n        while(count > 1) {\n            int steps = m % count;\n            if(steps == 0) steps = count;\n            \n            pos = (pos + steps) % count;\n            \n            for(int i = pos; i < count - 1; i++) {\n                people[i] = people[i + 1];\n            }\n            count--;\n            \n            if(count > 0) {\n                pos = pos % count;\n            }\n        }\n        \n        printf(\"%d\\n\", people[0]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() {  scanf(\"%d %d\", &n, &m); if(n == 0 && m ==  i = 0; i < n; i++)  1; } int count = n; int pos =  1) { int steps = m % count; if(steps == 0) steps = count; pos = (pos  i = pos; i < count - 1; i++) { people[i] = people[i + 1]; } count--; if(count > 0) { pos = pos % count; } }  }"], "perturbed_original": ["#include<stdio.h> #include<stdlib.h> int main(void){ int n,m,i,j; while(scanf(\"%d\",&n)!=EOF){ scanf(\"%d\",&m); for(i=j=0;i++<n;j%=i){j+=m;} printf(\"%d\\n\",j+1); } return 0; }"], "original_ll": -1.5473483800888062, "sampled_ll": -0.5520979166030884, "all_perturbed_sampled_ll": [-2.000061273574829], "all_perturbed_original_ll": [-1.7328218221664429], "perturbed_sampled_ll": -2.000061273574829, "perturbed_original_ll": -1.7328218221664429, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main ( String[] args ) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tArrayList<Integer> List;\n\t\twhile ( true ) {\n\t\t\tint remove = 0;\n\t\t\tList = new ArrayList<Integer>();\n\t\t\tint size = sc.nextInt();\n\t\t\tint space = sc.nextInt();\n\t\t\tif ( size == 0 && space == 0 ) break;\n\t\t\tspace--;\n\t\t\tfor ( int i = 1; i <= size; i++ )\n\t\t\t\tList.add(i);\n\t\t\twhile ( List.size() != 1 ) {\n\t\t\t\tremove += space;\n\t\t\t\twhile ( remove >= List.size() )\n\t\t\t\t\tremove -= List.size();\n\t\t\t\tList.remove(remove);\n\t\t\t}\n\t\t\tSystem.out.println(List.get(0));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) {\n                break;\n            }\n            \n            ArrayList<Integer> people = new ArrayList<>();\n            for (int i = 1; i <= n; i++) {\n                people.add(i);\n            }\n            \n            int currentIndex = 0;\n            \n            while (people.size() > 1) {\n                currentIndex = (currentIndex + m - 1) % people.size();\n                people.remove(currentIndex);\n                if (currentIndex == people.size() && people.size() > 0) {\n                    currentIndex = 0;\n                }\n            }\n            \n            System.out.println(people.get(0));\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); int m = sc.nextInt(); if (n == 0  break; } ArrayList<Integer> people = new ArrayList<>(); for (int i = 1; i <= n; i++) { people.add(i); } int currentIndex = 0; while (people.size() > 1) { currentIndex = (currentIndex + m - 1) %  0)  } System.out.println(people.get(0)); } sc.close(); } }"], "perturbed_original": ["import java.io.*; import  public static void main ( String[] args ) { Scanner sc = new Scanner(System.in); ArrayList<Integer> List; while ( true ) { int remove = 0; List = new ArrayList<Integer>(); int size = sc.nextInt(); int space = sc.nextInt(); if ( size == 0  break; space--;  i++ ) List.add(i); while ( List.size() != 1 ) { remove += space; while  remove -= List.size(); List.remove(remove); } System.out.println(List.get(0)); } } }"], "original_ll": -0.816221296787262, "sampled_ll": -0.42495784163475037, "all_perturbed_sampled_ll": [-1.2520959377288818], "all_perturbed_original_ll": [-1.9847825765609741], "perturbed_sampled_ll": -1.2520959377288818, "perturbed_original_ll": -1.9847825765609741, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n  n,m=map(int,raw_input().split())\n  if n==0==m:break\n  p=0\n  for i in range(2,n+1):p=(p+m)%i\n  print p+1", "sampled": "def find_winner(n, m):\n    people = list(range(1, n + 1))\n    current = 0\n    \n    while len(people) > 1:\n        current = (current + m - 1) % len(people)\n        people.pop(current)\n        if current == len(people) and len(people) > 0:\n            current = 0\n    \n    return people[0]\n\nwhile True:\n    n, m = map(int, input().split())\n    if n == 0 and m == 0:\n        break\n    print(find_winner(n, m))\n", "perturbed_sampled": ["def find_winner(n, m): people = list(range(1, n + 1)) current = 0 while len(people)  current == len(people) and len(people) > 0: current = 0 return people[0] while True: n, m = map(int, input().split()) if n == 0 and m == 0: break print(find_winner(n, m))"], "perturbed_original": ["while 1: n,m=map(int,raw_input().split()) if n==0==m:break p=0 for i in range(2,n+1):p=(p+m)%i print p+1"], "original_ll": -1.157636284828186, "sampled_ll": -0.5510858297348022, "all_perturbed_sampled_ll": [-1.3787987232208252], "all_perturbed_original_ll": [-1.5994656085968018], "perturbed_sampled_ll": -1.3787987232208252, "perturbed_original_ll": -1.5994656085968018, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(int argc,char* argv[]){\n  int i;\n  int graph[101];\n\n  for(;;){\n    int from = -1,to = -1,odd_num = 0;\n\n    for(i = 1; i <= 100; i++){\n      graph[i] = -1;\n    }\n\n    while(scanf(\"%d %d\",&from,&to) != EOF){\n      if(from == 0 && to == 0){\n\tbreak;\n      }else{\n\tgraph[to] = (graph[to] == -1) ? 1 : graph[to]+1;\n\tgraph[from] = (graph[from] == -1) ? 1 : graph[from]+1;\n      }\n    }\n\n    if(from != 0 || to != 0){\n      break;\n    }\n\n    for(i = 1; i <= 100; i++){\n      if(graph[i] == -1){break;}\n      if(graph[i]%2 == 1){odd_num++;}\n    }\n\n    if(odd_num == 0 || odd_num == 2){\n      printf(\"OK\\n\");\n    }else{\n      printf(\"NG\\n\");\n    }\n  }\n\n  return 0;\n  \n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAXN 105\n\nint adj[MAXN][MAXN];\nint n;\nint visited[MAXN];\nint path[MAXN];\nint pathlen;\nint found;\n\nvoid dfs(int u, int goal) {\n    if (found) return;\n    if (u == goal) {\n        found = 1;\n        return;\n    }\n    \n    for (int v = 1; v <= n; v++) {\n        if (adj[u][v] > 0 && !visited[v]) {\n            visited[v] = 1;\n            path[pathlen++] = v;\n            \n            for (int i = 0; i < adj[u][v]; i++) {\n                dfs(v, goal);\n                if (found) return;\n            }\n            \n            pathlen--;\n            visited[v] = 0;\n        }\n    }\n}\n\nint canReach(int start, int goal, int avoid) {\n    memset(visited, 0, sizeof(visited));\n    visited[start] = 1;\n    visited[avoid] = 1;\n    \n    pathlen = 0;\n    path[pathlen++] = start;\n    found = 0;\n    \n    dfs(start, goal);\n    return found;\n}\n\nint main() {\n    int a, b;\n    \n    while (1) {\n        memset(adj, 0, sizeof(adj));\n        n = 0;\n        \n        int first = 1;\n        while (1) {\n            if (scanf(\"%d %d\", &a, &b) != 2) return 0;\n            if (a == 0 && b == 0) break;\n            \n            adj[a][b]++;\n            adj[b][a]++;\n            \n            if (a > n) n = a;\n            if (b > n) n = b;\n            first = 0;\n        }\n        \n        if (first) break;\n        \n        memset(visited, 0, sizeof(visited));\n        visited[1] = 1;\n        pathlen = 0;\n        path[pathlen++] = 1;\n        found = 0;\n        \n        dfs(1, 2);\n        \n        if (!found) {\n            printf(\"NG\\n\");\n            continue;\n        }\n        \n        int ok = 1;\n        for (int i = 1; i < pathlen - 1; i++) {\n            int v = path[i];\n            if (!canReach(1, v, 2) || !canReach(v, 2, 1)) {\n                ok = 0;\n                break;\n            }\n        }\n        \n        if (ok) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAXN 105 int adj[MAXN][MAXN]; int n; int visited[MAXN]; int path[MAXN]; int pathlen; int found; = 0 { if (found) return; if  =  <= n; v++) { if (adj[u][v] > 0 && !visited[v]) { visited[v] = 1; path[pathlen++] = v; for  < adj[u][v]; i++) { dfs(v, goal); if (found) return; } pathlen--; visited[v] = 0;  start, int goal, int avoid) { memset(visited, 0, sizeof(visited)); visited[start] = 1; visited[avoid] = 1; pathlen = 0; path[pathlen++] = start; found = 0; dfs(start, goal);  0, sizeof(adj)); n = 0; int first = 1; while (1) { if (scanf(\"%d %d\", &a,  if (a  0) break; adj[a][b]++; adj[b][a]++; if (a > n) n = a; if (b > n) n = b; first =  = 1; pathlen = 0; path[pathlen++] = 1; found = 0; dfs(1, 2); if (!found) { printf(\"NG\\n\"); continue; } int ok = 1; for (int  pathlen  v = path[i]; if (!canReach(1, v, 2) || !canReach(v, 2, 1)) { ok = 0; break; } } if (ok) { printf(\"OK\\n\"); } else { printf(\"NG\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(int argc,char* argv[]){ int i; int graph[101]; for(;;){ int from = -1,to = -1,odd_num = 0; for(i = 1; i <= 100; i++){ graph[i] = -1; } while(scanf(\"%d %d\",&from,&to) != EOF){  graph[to] = (graph[to]  graph[to]+1; graph[from] = (graph[from] == -1)  } if(from != 0 || to !=  1; i <= 100; i++){ if(graph[i] == -1){break;} if(graph[i]%2 == 1){odd_num++;} } if(odd_num == 0 || odd_num == 2){ printf(\"OK\\n\");  0; }"], "original_ll": -0.8550257682800293, "sampled_ll": -0.49819353222846985, "all_perturbed_sampled_ll": [-1.273047924041748], "all_perturbed_original_ll": [-1.6880377531051636], "perturbed_sampled_ll": -1.273047924041748, "perturbed_original_ll": -1.6880377531051636, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n/*answer*/\n    int a, b;\n    int[] count;\n    int i, n;\n\n    count = new int[100];\n    for(;sc.hasNext();){\n      for(i = 0;i < 100;i++)count[i] = 0;\n      n = 0;\n      for(;;){\n        a = sc.nextInt();\n        b = sc.nextInt();\n        if(a == 0 && b == 0)break;\n        count[a - 1]++; count[b - 1]++;\n      }\n\n      for(i = 0;i < 2;i++)if(count[i] % 2 == 0)n = 1;\n      for(i = 2;i < 100;i++)if(count[i] % 2 != 0)n = 1;\n\n      if(n == 1)out.println(\"NG\");\n      else out.println(\"OK\");\n    }\n\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to;\n        int id;\n        Edge(int to, int id) {\n            this.to = to;\n            this.id = id;\n        }\n    }\n    \n    static List<List<Edge>> graph;\n    static int[] edgeCount;\n    static boolean[] visited;\n    static boolean[] edgeUsed;\n    static int start = 1, goal = 2;\n    static boolean found;\n    static List<Integer> path;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            Map<String, Integer> edges = new HashMap<>();\n            List<int[]> edgeList = new ArrayList<>();\n            Set<Integer> nodes = new HashSet<>();\n            \n            while (true) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                if (a == 0 && b == 0) break;\n                \n                nodes.add(a);\n                nodes.add(b);\n                edgeList.add(new int[]{a, b});\n                \n                String key = Math.min(a, b) + \"-\" + Math.max(a, b);\n                edges.put(key, edges.getOrDefault(key, 0) + 1);\n            }\n            \n            int maxNode = 0;\n            for (int node : nodes) {\n                maxNode = Math.max(maxNode, node);\n            }\n            \n            graph = new ArrayList<>();\n            for (int i = 0; i <= maxNode; i++) {\n                graph.add(new ArrayList<>());\n            }\n            \n            edgeCount = new int[edgeList.size()];\n            int edgeId = 0;\n            for (int[] edge : edgeList) {\n                int a = edge[0];\n                int b = edge[1];\n                graph.get(a).add(new Edge(b, edgeId));\n                graph.get(b).add(new Edge(a, edgeId));\n                edgeId++;\n            }\n            \n            visited = new boolean[maxNode + 1];\n            edgeUsed = new boolean[edgeList.size()];\n            found = false;\n            path = new ArrayList<>();\n            \n            dfs(start, new ArrayList<>());\n            \n            if (found) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NG\");\n            }\n        }\n        sc.close();\n    }\n    \n    static void dfs(int current, List<Integer> currentPath) {\n        if (found) return;\n        \n        if (current == goal) {\n            // Check if all edges are used exactly once\n            boolean allUsed = true;\n            for (boolean used : edgeUsed) {\n                if (!used) {\n                    allUsed = false;\n                    break;\n                }\n            }\n            if (allUsed) {\n                found = true;\n                path = new ArrayList<>(currentPath);\n            }\n            return;\n        }\n        \n        visited[current] = true;\n        currentPath.add(current);\n        \n        for (Edge edge : graph.get(current)) {\n            if (!edgeUsed[edge.id]) {\n                edgeUsed[edge.id] = true;\n                dfs(edge.to, currentPath);\n                edgeUsed[edge.id] = false;\n                if (found) return;\n            }\n        }\n        \n        currentPath.remove(currentPath.size() - 1);\n        visited[current] = false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Edge { int to; int id; Edge(int to, int   static List<List<Edge>> graph; static int[] edgeCount; static boolean[] visited; static boolean[] edgeUsed; static int start = 1, goal  static List<Integer> path; public static void main(String[] args) { Scanner sc  { Map<String, Integer> edges   (true) { int a = sc.nextInt(); int b = sc.nextInt(); if (a == 0 && b == 0) break; nodes.add(a); nodes.add(b); edgeList.add(new int[]{a, b}); String key  + Math.max(a, b); edges.put(key, edges.getOrDefault(key, 0) +  0; for (int node : nodes) { maxNode = Math.max(maxNode, node); } graph = new ArrayList<>(); for (int i = 0; i <= maxNode; i++) { graph.add(new ArrayList<>()); } edgeCount = new int[edgeList.size()]; int  edge : edgeList) { int a = edge[0]; int b  graph.get(b).add(new Edge(a, edgeId));  boolean[maxNode + 1]; edgeUsed = new boolean[edgeList.size()]; found = false; path = new ArrayList<>(); dfs(start, new ArrayList<>());  else { System.out.println(\"NG\"); } } sc.close(); } static void dfs(int current, List<Integer> currentPath) { if (found) return; if (current == goal) { // Check if all edges are used exactly once boolean allUsed = true; for (boolean  if (allUsed) { found = true; path = new ArrayList<>(currentPath); } return; } visited[current] = true; currentPath.add(current); for (Edge edge : graph.get(current)) { if (!edgeUsed[edge.id]) { edgeUsed[edge.id] =  false; if (found) return; }  = false; } }"], "perturbed_original": ["public class Main{ public void run(java.io.InputStream in, java.io.PrintStream out){ java.util.Scanner sc = new java.util.Scanner(in); /*answer*/ int a, b; int[] count; int i, n; count = new int[100]; for(;sc.hasNext();){ for(i = 0;i < 100;i++)count[i] = 0; n = 0; for(;;){ a = sc.nextInt(); b  && b == 0)break; count[a - 1]++; count[b - 1]++; } for(i = 0;i < 2;i++)if(count[i]  if(n == 1)out.println(\"NG\"); else out.println(\"OK\"); } sc.close(); } public static void main(String[] args){ (new Main()).run(System.in, System.out); } }"], "original_ll": -0.9335508942604065, "sampled_ll": -0.43664228916168213, "all_perturbed_sampled_ll": [-1.3965736627578735], "all_perturbed_original_ll": [-1.4039182662963867], "perturbed_sampled_ll": -1.3965736627578735, "perturbed_original_ll": -1.4039182662963867, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfrom collections import defaultdict\ndata_list = []\n\nfor line in sys.stdin:\n    data_list.append(list(map(int, line.split())))\n\ndef is_half_euler_graph(node_list):\n\n    for node in node_list:\n        odd_num_counter = 0\n        for dic_value in node.values():\n            if dic_value % 2 != 0:\n                odd_num_counter = odd_num_counter + 1\n\n        if odd_num_counter == 2:\n            print(\"OK\")\n        else :\n            print(\"NG\")\n\n\nif __name__ == '__main__' :\n    node_data_lists = []\n    tmp_list = []\n    count_lists = []\n    tmp_dic = {}\n    tmp_dic = defaultdict(int)\n\n    for i in range(0, len(data_list)):\n        if data_list[i][0] == 0 and data_list[i][1] == 0:\n            node_data_lists.append(tmp_list[:])\n            tmp_list.clear()\n        else :\n            tmp_list.append(data_list[i])\n\n    for node_data_list in node_data_lists :\n        tmp_dic.clear()\n        for i in range(0, len(node_data_list)):\n            tmp_dic[node_data_list[i][0]] += 1\n            tmp_dic[node_data_list[i][1]] += 1\n\n        count_lists.append(tmp_dic.copy())\n    is_half_euler_graph(count_lists)\n\n", "sampled": "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    datasets = []\n    current_edges = []\n    \n    for line in sys.stdin:\n        line = line.strip()\n        if not line:\n            continue\n        a, b = map(int, line.split())\n        if a == 0 and b == 0:\n            if current_edges:\n                datasets.append(current_edges)\n                current_edges = []\n        else:\n            current_edges.append((a, b))\n    \n    return datasets\n\ndef can_reach(graph, start, end, excluded_edge=None):\n    \"\"\"BFS to check if we can reach end from start, optionally excluding an edge\"\"\"\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                # Check if this edge should be excluded\n                if excluded_edge:\n                    edge = tuple(sorted([node, neighbor]))\n                    if edge == excluded_edge:\n                        continue\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\ndef check_conditions(edges):\n    # Build adjacency list (undirected graph)\n    graph = defaultdict(list)\n    edge_set = set()\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        edge_set.add(tuple(sorted([a, b])))\n    \n    # Condition 1: There must be a path from 1 to 2\n    if not can_reach(graph, 1, 2):\n        return False\n    \n    # Condition 2: Every road must be on some path from 1 to 2\n    for edge in edge_set:\n        a, b = edge\n        # Remove this edge temporarily and check if we can still reach 2 from 1\n        if not can_reach(graph, 1, 2, excluded_edge=edge):\n            # This edge is essential, so condition 2 is satisfied for this edge\n            continue\n        else:\n            # This edge is not essential, condition 2 fails\n            return False\n    \n    # Condition 3: Every intersection (except 1 and 2) must be on some path from 1 to 2\n    all_nodes = set()\n    for a, b in edges:\n        all_nodes.add(a)\n        all_nodes.add(b)\n    \n    for node in all_nodes:\n        if node == 1 or node == 2:\n            continue\n        \n        # Check if node is on some path from 1 to 2\n        # Node is on a path from 1 to 2 if:\n        # - we can reach node from 1, AND\n        # - we can reach 2 from node\n        if can_reach(graph, 1, node) and can_reach(graph, node, 2):\n            # Additionally, we need to check if removing this node disconnects 1 and 2\n            # But a simpler check: node is critical if there's no path from 1 to 2 avoiding it\n            \n            # For now, just check basic reachability\n            # Actually, we need to verify the node is on SOME path, not ALL paths\n            # If we can reach it from 1 and reach 2 from it, it's on some path\n            continue\n        else:\n            return False\n    \n    return True\n\ndef solve():\n    datasets = read_input()\n    \n    for edges in datasets:\n        if check_conditions(edges):\n            print(\"OK\")\n        else:\n            print(\"NG\")\n\nsolve()\n", "perturbed_sampled": ["import sys from collections import defaultdict, deque def read_input(): datasets = [] current_edges = [] for line in sys.stdin: line = line.strip() if not line: continue a, b  == 0: if current_edges: datasets.append(current_edges) current_edges = [] else: current_edges.append((a, b)) return datasets def  to check if we can reach end from start, optionally excluding an  = deque([start]) visited.add(start) while queue: node = queue.popleft()  True for neighbor in graph[node]: if neighbor not in visited: # Check  excluded if excluded_edge: edge = tuple(sorted([node, neighbor])) if edge == excluded_edge: continue visited.add(neighbor) queue.append(neighbor) return False def check_conditions(edges): # Build adjacency list (undirected graph) graph = defaultdict(list) edge_set = set() for a, b in edges: graph[a].append(b) graph[b].append(a)   2):  Every road must be on some path from 1 to  a, b = edge # Remove this edge  from 1 if not can_reach(graph, 1, 2, excluded_edge=edge): # This  2 is satisfied for this edge  2 fails return False  (except 1 and 2) must be on some path from 1 to 2 all_nodes = set() for a, b in edges: all_nodes.add(a) all_nodes.add(b) for node in all_nodes: if node == 1 or node == 2: continue # Check if node is on some path from 1 to 2 # Node is on a path from 1 to 2 if: # - we can reach node from 1, AND # - we can reach 2 from node if can_reach(graph, 1,  to check if removing this node  But a simpler check: node is critical if there's no path from 1 to 2 avoiding it # For now, just check basic reachability # Actually, we need to verify the node is on SOME path, not ALL paths # If we can  reach   False return True def solve(): datasets = read_input() for edges in datasets: if check_conditions(edges): print(\"OK\") else: print(\"NG\") solve()"], "perturbed_original": ["import sys from collections import defaultdict data_list = [] for line  is_half_euler_graph(node_list): for node in node_list:  in node.values(): if dic_value % 2 != 0: odd_num_counter = odd_num_counter + 1  else : print(\"NG\") if __name__  [] tmp_list = [] count_lists = [] tmp_dic = {} tmp_dic = defaultdict(int) for i in range(0, len(data_list)): if data_list[i][0] ==  node_data_lists.append(tmp_list[:]) tmp_list.clear() else : tmp_list.append(data_list[i]) for node_data_list in  in range(0, len(node_data_list)): tmp_dic[node_data_list[i][0]] += 1 tmp_dic[node_data_list[i][1]] += 1 count_lists.append(tmp_dic.copy()) is_half_euler_graph(count_lists)"], "original_ll": -0.9857255220413208, "sampled_ll": -0.8424849510192871, "all_perturbed_sampled_ll": [-1.9731911420822144], "all_perturbed_original_ll": [-2.21760630607605], "perturbed_sampled_ll": -1.9731911420822144, "perturbed_original_ll": -2.21760630607605, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "double*q,a[99],b;char s[9];main(){for(q=a;~scanf(\"%s\",s);getchar()<14&&printf(\"%f\\n\",*q)){!sscanf(s,\"%lf\",q+1)?b=*q--,*q=*s-47?*s-42?*s-45?*q+b:*q-b:*q*b:*q/b:*++q;}}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_STACK 1000\n\ndouble stack[MAX_STACK];\nint top = -1;\n\nvoid push(double val) {\n    stack[++top] = val;\n}\n\ndouble pop() {\n    return stack[top--];\n}\n\nint is_operator(char *token) {\n    return (strlen(token) == 1 && (token[0] == '+' || token[0] == '-' || \n            token[0] == '*' || token[0] == '/'));\n}\n\ndouble calculate(double a, double b, char op) {\n    switch(op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return a / b;\n    }\n    return 0;\n}\n\nint main() {\n    char line[1000];\n    \n    while(fgets(line, sizeof(line), stdin)) {\n        if(line[0] == '\\n') break;\n        \n        top = -1;\n        char *token = strtok(line, \" \\n\");\n        \n        while(token != NULL) {\n            if(is_operator(token)) {\n                double b = pop();\n                double a = pop();\n                double result = calculate(a, b, token[0]);\n                push(result);\n            } else {\n                double num = atof(token);\n                push(num);\n            }\n            token = strtok(NULL, \" \\n\");\n        }\n        \n        printf(\"%f\\n\", stack[0]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> <extra_id_3>in, stack[0])<extra_id_4>}<extra_id_5>stack[0] {<extra_id_6>; return stack[0];<extra_id_7>==<extra_id_8>(line[0] == '\\n')<extra_id_9>= stack[0]; stack[0] =<extra_id_10>= 0; if( !is_operator(stack[top])) {<extra_id_11>= stack[top]<extra_id_12>} } int MAX_STACK 1000 double stack[MAX_STACK]; int top = -1; void push(double val) { stack[++top] = val; } double pop() { return   || token[0] == '-' || token[0] == '*' ||  calculate(double a, double b, char op)  return a + b; case '-': return a - b; case '*': return a * b; case '/': return a / b; } return 0; } int  sizeof(line), stdin)) { if(line[0] == '\\n') break; top = -1; char *token  != NULL) { if(is_operator(token)) { double b = pop(); double a = pop(); double result = calculate(a, b, token[0]); push(result); } else { double num = atof(token); push(num); } token  printf(\"%f\\n\", stack[0]); } return 0; }"], "perturbed_original": ["double*q,a[99],b;char s[9];main(){for(q=a;~scanf(\"%s\",s);getchar()<14&&printf(\"%f\\n\",*q)){!sscanf(s,\"%lf\",q+1)?b=*q--,*q=*s-47?*s-42?*s-45?*q+b:*q-b:*q*b:*q/b:*++q;}}"], "original_ll": -2.8481545448303223, "sampled_ll": -0.433257132768631, "all_perturbed_sampled_ll": [-1.796901822090149], "all_perturbed_original_ll": [-2.8481545448303223], "perturbed_sampled_ll": -1.796901822090149, "perturbed_original_ll": -2.8481545448303223, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc;\n\n\tstatic final int INF=1<<28;\n\tstatic final double EPS=1e-9;\n\n\tvoid run(){\n\t\tsc=new Scanner(System.in);\n\t\tfor(; sc.hasNext();){\n\t\t\tScanner c=new Scanner(sc.nextLine());\n\t\t\tLinkedList<Double> stack=new LinkedList<Double>();\n\t\t\tfor(; c.hasNext();){\n\t\t\t\tString s=c.next();\n\t\t\t\tif(Character.isDigit(s.charAt(0))){\n\t\t\t\t\tstack.addFirst(Double.parseDouble(s));\n\t\t\t\t}else{\n\t\t\t\t\tdouble d2=stack.removeFirst();\n\t\t\t\t\tdouble d1=stack.removeFirst();\n\t\t\t\t\tdouble d=0;\n//\t\t\t\t\tdouble d1=0,d2=0,d=0;\n\t\t\t\t\tswitch(s.charAt(0)){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\td=d1+d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\td=d1-d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\td=d1*d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\td=d1/d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstack.addFirst(d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble ans=stack.removeFirst();\n\t\t\tprintln(ans+\"\");\n\t\t}\n\t\tsc.close();\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line == null || line.trim().isEmpty()) {\n                break;\n            }\n            \n            String[] tokens = line.trim().split(\"\\\\s+\");\n            Stack<Double> stack = new Stack<>();\n            \n            for (String token : tokens) {\n                if (token.equals(\"+\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a + b);\n                } else if (token.equals(\"-\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a - b);\n                } else if (token.equals(\"*\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a * b);\n                } else if (token.equals(\"/\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a / b);\n                } else {\n                    stack.push(Double.parseDouble(token));\n                }\n            }\n            \n            System.out.printf(\"%.6f%n\", stack.pop());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public  void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine())  if (line == null || line.trim().isEmpty()) { break; } String[] tokens = line.trim().split(\"\\\\s+\"); Stack<Double>  (String token : tokens) { if (token.equals(\"+\")) { double b = stack.pop(); double a = stack.pop(); stack.push(a + b);  double b = stack.pop(); double a =  else if (token.equals(\"*\")) { double b = stack.pop(); double a =  else if (token.equals(\"/\")) { double b = stack.pop();  / b); } else { stack.push(Double.parseDouble(token)); } } System.out.printf(\"%.6f%n\", stack.pop()); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.lang.*;  static java.lang.Math.*; import static java.util.Arrays.*; public class Main{ Scanner sc; static final int INF=1<<28; static final double EPS=1e-9; void run(){ sc=new Scanner(System.in); for(;  stack=new LinkedList<Double>(); for(; c.hasNext();){ String s=c.next(); if(Character.isDigit(s.charAt(0))){  d1=stack.removeFirst(); double d=0; // double d1=0,d2=0,d=0; switch(s.charAt(0)){ case '+': d=d1+d2; break; case '-': d=d1-d2; break; case '*': d=d1*d2;  double ans=stack.removeFirst(); println(ans+\"\"); } sc.close(); } void print(String s){ System.out.print(s); } void println(String s){ System.out.println(s); } public  Main().run(); } }"], "original_ll": -0.7493289709091187, "sampled_ll": -0.29866430163383484, "all_perturbed_sampled_ll": [-1.3791738748550415], "all_perturbed_original_ll": [-1.8172270059585571], "perturbed_sampled_ll": -1.3791738748550415, "perturbed_original_ll": -1.8172270059585571, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor l in sys.stdin:\n  t=l.split()\n  l=[]\n  for i in t:\n    try:\n      j=int(i)\n      l.append(j)\n    except:\n      b=l.pop()\n      a=l.pop()\n      l.append(eval(\"a\"+i+\"b\"))\n  print(\"{:.6f}\".format(l[0]))\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    tokens = line.strip().split()\n    stack = []\n    \n    for token in tokens:\n        if token in ['+', '-', '*', '/']:\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+':\n                result = a + b\n            elif token == '-':\n                result = a - b\n            elif token == '*':\n                result = a * b\n            elif token == '/':\n                result = a / b\n            stack.append(result)\n        else:\n            stack.append(float(token))\n    \n    print(f\"{stack[0]:.6f}\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: tokens =   in ['+', '-', '*', '/']: b = stack.pop() a = stack.pop() if token == '+': result = a + b elif   == '*': result = a * b elif token == '/': result = a / b stack.append(result) else: stack.append(float(token)) print(f\"{stack[0]:.6f}\")"], "perturbed_original": [" sys.stdin: t=l.split() l=[] for i in t: try: j=int(i) l.append(j) except: b=l.pop() a=l.pop() l.append(eval(\"a\"+i+\"b\")) print(\"{:.6f}\".format(l[0]))"], "original_ll": -1.53563392162323, "sampled_ll": -0.47061148285865784, "all_perturbed_sampled_ll": [-1.7667335271835327], "all_perturbed_original_ll": [-2.1311020851135254], "perturbed_sampled_ll": -1.7667335271835327, "perturbed_original_ll": -2.1311020851135254, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main()\n{\n  unsigned char *a = \"\\n ',-.?ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  unsigned char *b[] = {\n    \"101\",\"101\",\"000000\",\"000011\",\"10010001\",\"010001\",\"000001\",\"100101\",\n    \"10011010\",\"0101\",\"0001\",\"110\",\"01001\",\"10011011\",\"010000\",\"0111\",\n    \"10011000\",\"0110\",\"00100\",\"10011001\",\"10011110\",\"00101\",\"111\",\n    \"10011111\",\"1000\",\"00110\",\"00111\",\"10011100\",\"10011101\",\"000010\",\n    \"10010010\",\"10010011\",\"10010000\"\n  };\n  unsigned char *c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?\";\n  unsigned char d[4096];\n  unsigned char *p;\n  int i,j,k;\n  i = 0;\n  while((k = getc(stdin)) != '\\n'){\n    j = 0;\n    while(*(a + j) != k) j++;\n    p = b[j];\n    while(*p) d[i++] = *p++;\n  }\n  while(i % 5) d[i++] = '0';\n  d[i] = '\\0';\n  i = 0;\n  while(d[i]) {\n    k = 0;\n    j = 4;\n    do {\n      k |= (d[i++] == '1') << j;\n    } while(j--);\n    putc(*(c + k),stdout);\n  }\n  putc('\\n',stdout);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char *encode1[] = {\n        \"101\", \"000000\", \"000011\", \"10010001\", \"010001\", \"000001\",\n        \"100101\", \"10011010\", \"0101\", \"0001\", \"110\", \"01001\",\n        \"10011011\", \"010000\", \"0111\", \"10011000\", \"0110\", \"00100\",\n        \"10011001\", \"10011110\", \"00101\", \"111\", \"10011111\", \"1000\",\n        \"00110\", \"00111\", \"10011100\", \"10011101\", \"000010\", \"10010010\",\n        \"10010011\", \"10010000\"\n    };\n    \n    char *decode2[] = {\n        \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\",\n        \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\",\n        \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\",\n        \"Y\", \"Z\", \" \", \".\", \",\", \"-\", \"'\", \"?\"\n    };\n    \n    char input[1024];\n    \n    while (fgets(input, sizeof(input), stdin)) {\n        int len = strlen(input);\n        if (len > 0 && input[len-1] == '\\n') {\n            input[len-1] = '\\0';\n            len--;\n        }\n        \n        char binary[10000] = \"\";\n        \n        for (int i = 0; i < len; i++) {\n            char c = input[i];\n            int idx = -1;\n            \n            if (c == ' ') idx = 0;\n            else if (c == '\\'') idx = 1;\n            else if (c == ',') idx = 2;\n            else if (c == '-') idx = 3;\n            else if (c == '.') idx = 4;\n            else if (c == '?') idx = 5;\n            else if (c >= 'A' && c <= 'Z') idx = c - 'A' + 6;\n            \n            if (idx >= 0) {\n                strcat(binary, encode1[idx]);\n            }\n        }\n        \n        int blen = strlen(binary);\n        if (blen % 5 != 0) {\n            int pad = 5 - (blen % 5);\n            for (int i = 0; i < pad; i++) {\n                strcat(binary, \"0\");\n            }\n            blen = strlen(binary);\n        }\n        \n        char result[10000] = \"\";\n        for (int i = 0; i < blen; i += 5) {\n            char chunk[6];\n            strncpy(chunk, binary + i, 5);\n            chunk[5] = '\\0';\n            \n            int val = 0;\n            for (int j = 0; j < 5; j++) {\n                val = val * 2 + (chunk[j] - '0');\n            }\n            \n            strcat(result, decode2[val]);\n        }\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  char *encode1[] = { \"101\", \"000000\", \"000011\", \"10010001\", \"010001\", \"000001\", \"100101\", \"10011010\", \"0101\", \"0001\",  \"10011000\", \"0110\", \"00100\", \"10011001\", \"10011110\", \"00101\", \"111\", \"10011111\", \"1000\", \"00110\", \"00111\", \"10011100\", \"10011101\", \"000010\", \"10010010\", \"10010011\", \"10010000\" }; char *decode2[] = { \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\",  \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \" \", \".\", \",\", \"-\", \"'\", \"?\" }; char input[1024]; while (fgets(input, sizeof(input), stdin)) { int len = strlen(input); if (len > 0  } char binary[10000] = \"\"; for (int  c = input[i]; int idx = -1;  if (c == '\\'') idx = 1; else if (c == ',') idx = 2; else if (c  else if (c == '.') idx  == '?') idx  <= 'Z') idx = c - 'A' + 6; if  encode1[idx]); } } int blen = strlen(binary); if (blen % 5 != 0) { int pad = 5 - (blen % 5); for (int i = 0; i < pad; i++) {  strlen(binary); } char  i = 0; i < blen; i += 5) { char chunk[6]; strncpy(chunk, binary + i, 5); chunk[5] = '\\0'; int val = 0; for (int j = 0; j < 5; j++) {  + (chunk[j] - '0'); } strcat(result, decode2[val]); } printf(\"%s\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main() { unsigned  { \"101\",\"101\",\"000000\",\"000011\",\"10010001\",\"010001\",\"000001\",\"100101\", \"10011010\",\"0101\",\"0001\",\"110\",\"01001\",\"10011011\",\"010000\",\"0111\", \"10011000\",\"0110\",\"00100\",\"10011001\",\"10011110\",\"00101\",\"111\", \"10011111\",\"1000\",\"00110\",\"00111\",\"10011100\",\"10011101\",\"000010\", \"10010010\",\"10010011\",\"10010000\" }; unsigned char *c  d[4096]; unsigned char  0; while((k = getc(stdin)) != '\\n'){ j = 0;  j++; p = b[j]; while(*p) d[i++] = *p++; } while(i % 5) d[i++] = '0'; d[i] = '\\0'; i = 0; while(d[i]) { k = 0; j = 4; do {  << j; } while(j--); putc(*(c + k),stdout); } putc('\\n',stdout); return 0; }"], "original_ll": -0.9931159019470215, "sampled_ll": -0.4950203597545624, "all_perturbed_sampled_ll": [-1.1013922691345215], "all_perturbed_original_ll": [-1.317557692527771], "perturbed_sampled_ll": -1.1013922691345215, "perturbed_original_ll": -1.317557692527771, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) throws java.io.IOException{\n        Scanner scan = new Scanner(System.in);\n        HashMap<Character,String> ep =new HashMap<Character,String>();\n        HashMap<String,Character> dp =new HashMap<String,Character>();\n\n\t\tep.put(' ', \"101\");\n\t\tep.put('\\'', \"000000\");\n\t\tep.put(',', \"000011\");\n\t\tep.put('-', \"10010001\");\n\t\tep.put('.', \"010001\");\n\t\tep.put('?', \"000001\");\n\t\tep.put('A', \"100101\");\n\t\tep.put('B', \"10011010\");\n\t\tep.put('C', \"0101\");\n\t\tep.put('D', \"0001\");\n\t\tep.put('E', \"110\");\n\t\tep.put('F', \"01001\");\n\t\tep.put('G', \"10011011\");\n\t\tep.put('H', \"010000\");\n\t\tep.put('I', \"0111\");\n\t\tep.put('J', \"10011000\");\n\t\tep.put('K', \"0110\");\n\t\tep.put('L', \"00100\");\n\t\tep.put('M', \"10011001\");\n\t\tep.put('N', \"10011110\");\n\t\tep.put('O', \"00101\");\n\t\tep.put('P', \"111\");\n\t\tep.put('Q', \"10011111\");\n\t\tep.put('R', \"1000\");\n\t\tep.put('S', \"00110\");\n\t\tep.put('T', \"00111\");\n\t\tep.put('U', \"10011100\");\n\t\tep.put('V', \"10011101\");\n\t\tep.put('W', \"000010\");\n\t\tep.put('X', \"10010010\");\n\t\tep.put('Y', \"10010011\");\n\t\tep.put('Z', \"10010000\");\n        \n\t\tdp.put(\"00000\", 'A');\n\t\tdp.put(\"00001\", 'B');\n\t\tdp.put(\"00010\", 'C');\n\t\tdp.put(\"00011\", 'D');\n\t\tdp.put(\"00100\", 'E');\n\t\tdp.put(\"00101\", 'F');\n\t\tdp.put(\"00110\", 'G');\n\t\tdp.put(\"00111\", 'H');\n\t\tdp.put(\"01000\", 'I');\n\t\tdp.put(\"01001\", 'J');\n\t\tdp.put(\"01010\", 'K');\n\t\tdp.put(\"01011\", 'L');\n\t\tdp.put(\"01100\", 'M');\n\t\tdp.put(\"01101\", 'N');\n\t\tdp.put(\"01110\", 'O');\n\t\tdp.put(\"01111\", 'P');\n\t\tdp.put(\"10000\", 'Q');\n\t\tdp.put(\"10001\", 'R');\n\t\tdp.put(\"10010\", 'S');\n\t\tdp.put(\"10011\", 'T');\n\t\tdp.put(\"10100\", 'U');\n\t\tdp.put(\"10101\", 'V');\n\t\tdp.put(\"10110\", 'W');\n\t\tdp.put(\"10111\", 'X');\n\t\tdp.put(\"11000\", 'Y');\n\t\tdp.put(\"11001\", 'Z');\n\t\tdp.put(\"11010\", ' ');\n\t\tdp.put(\"11011\", '.');\n\t\tdp.put(\"11100\", ',');\n\t\tdp.put(\"11101\", '-');\n\t\tdp.put(\"11110\", '\\'');\n\t\tdp.put(\"11111\", '?');\n        \n        while(scan.hasNext()){\n        \tchar [] line= scan.nextLine().toCharArray();\n        \tString tmp=\"\";\n        \tfor(int i=0;i<line.length;i++)\n        \t\ttmp+=ep.get(line[i]);\n        \tString [] splitedCode =new String[tmp.length()/5+1];\n        \tfor(int i=0;i<splitedCode.length;i++){\t\n        \t\tif(i==(splitedCode.length-1))\n        \t\t\tsplitedCode[i]=tmp.substring(5*i,tmp.length());\n        \t\telse splitedCode[i]=tmp.substring(5*i,5*i+5);\n        \t}\n        \t\tif(tmp.length()%5!=0)\n        \tfor(int i=0;i<(5-tmp.length()%5);i++)\n        \t\tsplitedCode[splitedCode.length-1]+=\"0\";\n        \t\n        \tStringBuilder sb = new StringBuilder();\n        \tfor(int i=0;i<splitedCode.length;i++)\n        \t\tsb.append(dp.get(splitedCode[i]));\n        \tSystem.out.println(sb);\n        }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Map<Character, String> encode1 = new HashMap<>();\n        encode1.put(' ', \"101\");\n        encode1.put('\\'', \"000000\");\n        encode1.put(',', \"000011\");\n        encode1.put('-', \"10010001\");\n        encode1.put('.', \"010001\");\n        encode1.put('?', \"000001\");\n        encode1.put('A', \"100101\");\n        encode1.put('B', \"10011010\");\n        encode1.put('C', \"0101\");\n        encode1.put('D', \"0001\");\n        encode1.put('E', \"110\");\n        encode1.put('F', \"01001\");\n        encode1.put('G', \"10011011\");\n        encode1.put('H', \"010000\");\n        encode1.put('I', \"0111\");\n        encode1.put('J', \"10011000\");\n        encode1.put('K', \"0110\");\n        encode1.put('L', \"00100\");\n        encode1.put('M', \"10011001\");\n        encode1.put('N', \"10011110\");\n        encode1.put('O', \"00101\");\n        encode1.put('P', \"111\");\n        encode1.put('Q', \"10011111\");\n        encode1.put('R', \"1000\");\n        encode1.put('S', \"00110\");\n        encode1.put('T', \"00111\");\n        encode1.put('U', \"10011100\");\n        encode1.put('V', \"10011101\");\n        encode1.put('W', \"000010\");\n        encode1.put('X', \"10010010\");\n        encode1.put('Y', \"10010011\");\n        encode1.put('Z', \"10010000\");\n        \n        Map<String, Character> encode2 = new HashMap<>();\n        encode2.put(\"00000\", 'A');\n        encode2.put(\"00001\", 'B');\n        encode2.put(\"00010\", 'C');\n        encode2.put(\"00011\", 'D');\n        encode2.put(\"00100\", 'E');\n        encode2.put(\"00101\", 'F');\n        encode2.put(\"00110\", 'G');\n        encode2.put(\"00111\", 'H');\n        encode2.put(\"01000\", 'I');\n        encode2.put(\"01001\", 'J');\n        encode2.put(\"01010\", 'K');\n        encode2.put(\"01011\", 'L');\n        encode2.put(\"01100\", 'M');\n        encode2.put(\"01101\", 'N');\n        encode2.put(\"01110\", 'O');\n        encode2.put(\"01111\", 'P');\n        encode2.put(\"10000\", 'Q');\n        encode2.put(\"10001\", 'R');\n        encode2.put(\"10010\", 'S');\n        encode2.put(\"10011\", 'T');\n        encode2.put(\"10100\", 'U');\n        encode2.put(\"10101\", 'V');\n        encode2.put(\"10110\", 'W');\n        encode2.put(\"10111\", 'X');\n        encode2.put(\"11000\", 'Y');\n        encode2.put(\"11001\", 'Z');\n        encode2.put(\"11010\", ' ');\n        encode2.put(\"11011\", '.');\n        encode2.put(\"11100\", ',');\n        encode2.put(\"11101\", '-');\n        encode2.put(\"11110\", '\\'');\n        encode2.put(\"11111\", '?');\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            \n            StringBuilder binary = new StringBuilder();\n            for (char c : line.toCharArray()) {\n                binary.append(encode1.get(c));\n            }\n            \n            while (binary.length() % 5 != 0) {\n                binary.append('0');\n            }\n            \n            StringBuilder result = new StringBuilder();\n            for (int i = 0; i < binary.length(); i += 5) {\n                String chunk = binary.substring(i, i + 5);\n                result.append(encode2.get(chunk));\n            }\n            \n            System.out.println(result.toString());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public  Scanner sc = new Scanner(System.in); Map<Character, String> encode1 = new HashMap<>(); encode1.put(' ', \"101\"); encode1.put('\\'', \"000000\"); encode1.put(',', \"000011\");  \"10011010\"); encode1.put('C', \"0101\"); encode1.put('D', \"0001\"); encode1.put('E', \"110\"); encode1.put('F', \"01001\"); encode1.put('G', \"10011011\"); encode1.put('H', \"010000\"); encode1.put('I', \"0111\"); encode1.put('J', \"10011000\"); encode1.put('K', \"0110\"); encode1.put('L',  encode1.put('O', \"00101\"); encode1.put('P', \"111\"); encode1.put('Q', \"10011111\"); encode1.put('R', \"1000\"); encode1.put('S', \"00110\"); encode1.put('T', \"00111\"); encode1.put('U', \"10011100\"); encode1.put('V', \"10011101\"); encode1.put('W', \"000010\"); encode1.put('X', \"10010010\"); encode1.put('Y', \"10010011\"); encode1.put('Z', \"10010000\"); Map<String, Character> encode2 = new HashMap<>();   encode2.put(\"00111\", 'H'); encode2.put(\"01000\", 'I'); encode2.put(\"01001\", 'J'); encode2.put(\"01010\", 'K'); encode2.put(\"01011\", 'L'); encode2.put(\"01100\", 'M'); encode2.put(\"01101\",  encode2.put(\"10000\", 'Q'); encode2.put(\"10001\", 'R'); encode2.put(\"10010\", 'S'); encode2.put(\"10011\", 'T'); encode2.put(\"10100\",  encode2.put(\"10111\", 'X'); encode2.put(\"11000\", 'Y');  encode2.put(\"11011\",  encode2.put(\"11110\", '\\''); encode2.put(\"11111\", '?'); while (sc.hasNextLine()) { String line = sc.nextLine(); StringBuilder binary = new StringBuilder(); for (char c : line.toCharArray()) { binary.append(encode1.get(c)); } while (binary.length() % 5 != 0) { binary.append('0'); } StringBuilder   < binary.length(); i += 5) { String chunk = binary.substring(i, i + 5); result.append(encode2.get(chunk)); } System.out.println(result.toString()); } sc.close(); } }"], "perturbed_original": ["import  args) throws java.io.IOException{ Scanner scan = new Scanner(System.in); HashMap<Character,String> ep =new HashMap<Character,String>(); HashMap<String,Character> dp =new HashMap<String,Character>(); ep.put(' ', \"101\"); ep.put('\\'', \"000000\"); ep.put(',', \"000011\"); ep.put('-', \"10010001\"); ep.put('.', \"010001\");  \"0001\"); ep.put('E', \"110\"); ep.put('F', \"01001\"); ep.put('G', \"10011011\"); ep.put('H', \"010000\"); ep.put('I', \"0111\"); ep.put('J', \"10011000\"); ep.put('K', \"0110\"); ep.put('L', \"00100\"); ep.put('M', \"10011001\"); ep.put('N', \"10011110\");  \"10011111\"); ep.put('R', \"1000\");  \"10011100\"); ep.put('V', \"10011101\"); ep.put('W', \"000010\"); ep.put('X', \"10010010\");  'C'); dp.put(\"00011\", 'D'); dp.put(\"00100\", 'E'); dp.put(\"00101\", 'F'); dp.put(\"00110\", 'G'); dp.put(\"00111\", 'H'); dp.put(\"01000\", 'I'); dp.put(\"01001\", 'J'); dp.put(\"01010\", 'K'); dp.put(\"01011\", 'L'); dp.put(\"01100\", 'M'); dp.put(\"01101\", 'N'); dp.put(\"01110\", 'O'); dp.put(\"01111\", 'P'); dp.put(\"10000\", 'Q'); dp.put(\"10001\", 'R'); dp.put(\"10010\", 'S'); dp.put(\"10011\", 'T'); dp.put(\"10100\", 'U'); dp.put(\"10101\", 'V'); dp.put(\"10110\", 'W'); dp.put(\"10111\", 'X'); dp.put(\"11000\", 'Y'); dp.put(\"11001\", 'Z');  dp.put(\"11100\", ','); dp.put(\"11101\", '-');  char [] line= scan.nextLine().toCharArray(); String tmp=\"\"; for(int i=0;i<line.length;i++) tmp+=ep.get(line[i]); String [] splitedCode =new String[tmp.length()/5+1]; for(int i=0;i<splitedCode.length;i++){ if(i==(splitedCode.length-1)) splitedCode[i]=tmp.substring(5*i,tmp.length()); else splitedCode[i]=tmp.substring(5*i,5*i+5); } if(tmp.length()%5!=0) for(int i=0;i<(5-tmp.length()%5);i++) splitedCode[splitedCode.length-1]+=\"0\"; StringBuilder sb = new StringBuilder();  } }"], "original_ll": -0.4184757173061371, "sampled_ll": -0.2833854556083679, "all_perturbed_sampled_ll": [-0.6765982508659363], "all_perturbed_original_ll": [-0.6734684705734253], "perturbed_sampled_ll": -0.6765982508659363, "perturbed_original_ll": -0.6734684705734253, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nd={' ':'101',\"'\":'000000',',':'000011','-':'10010001','.':'010001','?':'000001','A':'100101','B':'10011010','C':'0101','D':'0001','E':'110',\n'F':'01001','G':'10011011','H':'010000','I':'0111','J':'10011000','K':'0110','L':'00100','M':'10011001','N':'10011110','O':'00101','P':'111',\n'Q':'10011111','R':'1000','S':'00110','T':'00111','U':'10011100','V':'10011101','W':'000010','X':'10010010','Y':'10010011','Z':'10010000'}\nfor e in sys.stdin:\n a=''.join(d[c]for c in e[:-1])\n a+='0'*(-len(a)%5)\n print(''.join(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?\"[int(a[i*5:i*5+5],2)]for i in range(len(a)//5)))\n", "sampled": "import sys\n\n# First encoding table (character to binary code)\nencode1 = {\n    ' ': '101',\n    \"'\": '000000',\n    ',': '000011',\n    '-': '10010001',\n    '.': '010001',\n    '?': '000001',\n    'A': '100101',\n    'B': '10011010',\n    'C': '0101',\n    'D': '0001',\n    'E': '110',\n    'F': '01001',\n    'G': '10011011',\n    'H': '010000',\n    'I': '0111',\n    'J': '10011000',\n    'K': '0110',\n    'L': '00100',\n    'M': '10011001',\n    'N': '10011110',\n    'O': '00101',\n    'P': '111',\n    'Q': '10011111',\n    'R': '1000',\n    'S': '00110',\n    'T': '00111',\n    'U': '10011100',\n    'V': '10011101',\n    'W': '000010',\n    'X': '10010010',\n    'Y': '10010011',\n    'Z': '10010000'\n}\n\n# Second encoding table (5-bit binary to character)\nencode2 = {\n    '00000': 'A',\n    '00001': 'B',\n    '00010': 'C',\n    '00011': 'D',\n    '00100': 'E',\n    '00101': 'F',\n    '00110': 'G',\n    '00111': 'H',\n    '01000': 'I',\n    '01001': 'J',\n    '01010': 'K',\n    '01011': 'L',\n    '01100': 'M',\n    '01101': 'N',\n    '01110': 'O',\n    '01111': 'P',\n    '10000': 'Q',\n    '10001': 'R',\n    '10010': 'S',\n    '10011': 'T',\n    '10100': 'U',\n    '10101': 'V',\n    '10110': 'W',\n    '10111': 'X',\n    '11000': 'Y',\n    '11001': 'Z',\n    '11010': ' ',\n    '11011': '.',\n    '11100': ',',\n    '11101': '-',\n    '11110': \"'\",\n    '11111': '?'\n}\n\nfor line in sys.stdin:\n    line = line.rstrip('\\n')\n    \n    # Step 1: Convert each character to its binary code\n    binary_string = ''.join(encode1[c] for c in line)\n    \n    # Step 2: Pad with zeros to make length multiple of 5\n    remainder = len(binary_string) % 5\n    if remainder != 0:\n        binary_string += '0' * (5 - remainder)\n    \n    # Step 3: Split into chunks of 5 and convert using second table\n    result = ''\n    for i in range(0, len(binary_string), 5):\n        chunk = binary_string[i:i+5]\n        result += encode2[chunk]\n    \n    print(result)\n", "perturbed_sampled": ["import sys # First encoding table (character to binary code) encode1 =  '000000', ',': '000011', '-': '10010001', '.': '010001', '?': '000001', 'A': '100101', 'B': '10011010', 'C':   '010000', 'I': '0111', 'J': '10011000', 'K': '0110', 'L': '00100', 'M': '10011001', 'N':  'S': '00110', 'T': '00111', 'U': '10011100', 'V': '10011101', 'W': '000010', 'X': '10010010', 'Y': '10010011', 'Z': '10010000' } # Second encoding table (5-bit binary to character) encode2 = { '00000':   'F', '00110': 'G', '00111': 'H', '01000': 'I', '01001': 'J', '01010': 'K', '01011': 'L',  'O', '01111':  '10010': 'S', '10011': 'T', '10100': 'U', '10101': 'V', '10110': 'W', '10111': 'X', '11000': 'Y', '11001': 'Z', '11010': ' ', '11011': '.',  \"'\", '11111': '?'  line = line.rstrip('\\n') # Step 1: Convert each  binary_string = ''.join(encode1[c] for c  Pad with zeros to make length multiple of 5 remainder =  != 0: binary_string += '0' * (5 - remainder) # Step 3: Split into chunks of 5 and convert using second table result = '' for i in range(0, len(binary_string), 5): chunk = binary_string[i:i+5] result += encode2[chunk] print(result)"], "perturbed_original": ["import sys d={' ':'101',\"'\":'000000',',':'000011','-':'10010001','.':'010001','?':'000001','A':'100101','B':'10011010','C':'0101','D':'0001','E':'110', 'F':'01001','G':'10011011','H':'010000','I':'0111','J':'10011000','K':'0110','L':'00100','M':'10011001','N':'10011110','O':'00101','P':'111', 'Q':'10011111','R':'1000','S':'00110','T':'00111','U':'10011100','V':'10011101','W':'000010','X':'10010010','Y':'10010011','Z':'10010000'} for e in  a+='0'*(-len(a)%5) print(''.join(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?\"[int(a[i*5:i*5+5],2)]for i in range(len(a)//5)))"], "original_ll": -1.0132534503936768, "sampled_ll": -0.4180665910243988, "all_perturbed_sampled_ll": [-1.141167163848877], "all_perturbed_original_ll": [-1.1226873397827148], "perturbed_sampled_ll": -1.141167163848877, "perturbed_original_ll": -1.1226873397827148, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????\u00b0???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned long\t\tI4;\ntypedef unsigned long \tU4;\n\n/* ?????\u00b0?????? */\n#define MAXOFNUM_ROW \t99\t\t\t\t\t/* ?????\u00b0????????\u00a7??? */\n#define MAXOFSUM_COLUMN\t(MAXOFNUM_ROW+1)/2\t/* ?????\u00b0????????\u00a7??? */\n\n/* ??\u00b0?????????????????\u00b0 */\nU1 mu1InputNum[MAXOFNUM_ROW][MAXOFSUM_COLUMN];\t/* ??\\??????????????\u00b0??????????\u00b4????????????? */\n\n/* \n??\u00a2??\u00b0??????u1ReadData\n???????????\\???????????????????????????????????\u00b0???????????? \n?????\u00b0???\n?????????\n????????????U1 ??\\?????????????????\u00b0\n*/\nU1 u1ReadData();\n\n/*\n??\u00a2??\u00b0??????u2SearchMax\n???????????\u00a8????????????????????\u00a7?????\u00a7???????????????\n?????\u00b0???\n????\u00ac\u00ac1?????\u00b0????????\u00b0\n????????????U2 ?????\u00a7???\n*/\nU2 u2SearchMax(U1 u1NumOfRow);\n\n/*\n??\u00a2??\u00b0??????\n?????????2????????\u00b0??????????????\u00a7????????\u00b0????????????\n?????\u00b0???\n????\u00ac\u00ac1?????\u00b0?????\u00b0???1\n????\u00ac\u00ac2?????\u00b0?????\u00b0???2\n????????????U2 ??\u00a7??????????????\u00b0???\n*/\nU2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2);\n\nVD main(void)\n{\n\tU1 u1NumOfRow;\t\t\t\t\t\t/* ?????????????????\u00b0 */\n\tU2 u2MaxOfSum;\t\t\t\t\t\t/* ???????????\u00a7??? */\n\t\n\tu1NumOfRow = u1ReadData();\t\t\t\t/* ??????1 ??\\??????????????????????????? */\n\tu2MaxOfSum = u2SearchMax(u1NumOfRow);\t/* ??????2 ?????\u00a7????????\u00a2??? */\n\tprintf(\"%d\\n\",u2MaxOfSum);\t\t\t\t/* ??????3 ?????\u00a7????????\u00a8????????? */\n}\n\nU1 u1ReadData()\n{\n\tU1 u1NumOfRow;\t\t/* ?????????????????\u00b0 */\n\tU1 u1NumOfColumn;\t/* ?????????????????\u00b0 */\n\tU1 u1TmpChar;\t\t/* ','????????????'\\n'???????\u00b4????????????\u00b0 */\n\tI1 i1ReturnScanf;\t/* scanf??\u00a2??\u00b0???????????????????\u00b4????????????\u00b0 */\n\t\n\tU1 u1OnlyNumCnt;\n\t\n\tu1NumOfRow = 0;\n\tu1NumOfColumn = 0;\n\tu1OnlyNumCnt = 0;\n\t\n\twhile(u1OnlyNumCnt != 2){\n\t\tscanf(\"%d%c\",&mu1InputNum[u1NumOfRow][u1NumOfColumn],&u1TmpChar);\n\t\tif(u1TmpChar == ','){\n\t\t\tu1NumOfColumn++;\n\t\t\tu1TmpChar = 0;\n\t\t}\n\t\telse{\n\t\t\tif(u1NumOfColumn == 0){\n\t\t\t\tu1OnlyNumCnt++;\n\t\t\t}\n\t\t\tu1NumOfRow++;\n\t\t\tu1NumOfColumn = 0;\n\t\t}\n\t}\n\treturn u1NumOfRow;\n}\n\n\nU2 u2SearchMax(U1 u1NumOfRow)\n{\n\tU2 mu2work[MAXOFNUM_ROW][MAXOFSUM_COLUMN];\t/* ?\u00a8???????????????????????\u00b4????????????? */\n\tU1 u1RowCnt;\t\t/* ?????\u00b0???????????? */\n\tU1 u1ColumnCnt;\t\t/* ?????\u00b0???????????? */\n\tU1 u1HalfNumOfRow;\t/* ?????\u00b0????????? */\n\tU2 u2Num1;\t\t\t/* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */\n\tU2 u2Num2;\t\t\t/* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */\n\t\n\tu1HalfNumOfRow = u1NumOfRow/2+1;\n\t\n\t/* ??\\?????????????????????mu2work?????????????????? */\n\tfor(u1RowCnt = 0; u1RowCnt < u1NumOfRow; u1RowCnt++){\n\t\tfor(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){\n\t\t\tif(u1RowCnt >= u1HalfNumOfRow){\n\t\t\t\tif(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt];\n\t\t}\n\t}\n\t\n\tfor(u1RowCnt = 1; u1RowCnt < u1NumOfRow; u1RowCnt++){\n\t\tfor(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){\n\t\t\t/* ????????\u00a2?????\u00a8???????\u00b4???\u00b0????\u00a8????????????\u00b4??? */\n\t\t\tif(u1RowCnt < u1HalfNumOfRow){\t\t\t\t\n\t\t\t\tif(u1ColumnCnt == 0){\n\t\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][0];\n\t\t\t\t}\n\t\t\t\telse if(u1ColumnCnt == u1RowCnt){\n\t\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][u1RowCnt-1];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tu2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt-1];\n\t\t\t\t\tu2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt];\n\t\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* ????????\u00a2?????\u00a8???????\u00b4???\u00b0????\u00a8????????????\u00b4??? */\n\t\t\telse{\n\t\t\t\tif(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tu2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt];\n\t\t\t\tu2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt+1];\n\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2);\n\t\t\t}\n\t\t}\n\t}\n\treturn mu2work[u1NumOfRow-1][0];\n}\n\nU2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2)\n{\n\tU2 u2Rtn;\t/* ????????????????\u00b4????????????\u00b0 */\n\t\n\tif(u2Num1 >= u2Num2){\n\t\tu2Rtn = u2Num1;\n\t}else{\n\t\tu2Rtn = u2Num2;\n\t}\t\n\treturn u2Rtn;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    int diamond[200][100];\n    int dp[200][100];\n    int rows = 0;\n    char line[1000];\n    \n    // Read input\n    while (fgets(line, sizeof(line), stdin)) {\n        int len = strlen(line);\n        if (len > 0 && line[len-1] == '\\n') {\n            line[len-1] = '\\0';\n        }\n        \n        int col = 0;\n        char *token = strtok(line, \",\");\n        while (token != NULL) {\n            diamond[rows][col] = atoi(token);\n            col++;\n            token = strtok(NULL, \",\");\n        }\n        rows++;\n    }\n    \n    // Find the middle row (widest part)\n    int maxRow = 0;\n    for (int i = 0; i < rows; i++) {\n        if (i > maxRow) {\n            maxRow = i;\n        }\n    }\n    \n    // Initialize dp\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < 100; j++) {\n            dp[i][j] = -1;\n        }\n    }\n    \n    // Start with first element\n    dp[0][0] = diamond[0][0];\n    \n    // Determine middle row\n    int mid = rows / 2;\n    \n    // Process upper half (expanding)\n    for (int i = 0; i < mid; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (dp[i][j] != -1) {\n                // Move to left-down diagonal\n                if (dp[i+1][j] < dp[i][j] + diamond[i+1][j]) {\n                    dp[i+1][j] = dp[i][j] + diamond[i+1][j];\n                }\n                // Move to right-down diagonal\n                if (dp[i+1][j+1] < dp[i][j] + diamond[i+1][j+1]) {\n                    dp[i+1][j+1] = dp[i][j] + diamond[i+1][j+1];\n                }\n            }\n        }\n    }\n    \n    // Process lower half (contracting)\n    for (int i = mid; i < rows - 1; i++) {\n        int width = rows - i - 1;\n        for (int j = 0; j <= width; j++) {\n            if (dp[i][j] != -1) {\n                // Move to left-down diagonal\n                if (j > 0) {\n                    if (dp[i+1][j-1] < dp[i][j] + diamond[i+1][j-1]) {\n                        dp[i+1][j-1] = dp[i][j] + diamond[i+1][j-1];\n                    }\n                }\n                // Move to right-down diagonal\n                if (j < width) {\n                    if (dp[i+1][j] < dp[i][j] + diamond[i+1][j]) {\n                        dp[i+1][j] = dp[i][j] + diamond[i+1][j];\n                    }\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", dp[rows-1][0]);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h>  int diamond[200][100]; int dp[200][100]; int rows = 0; char line[1000]; // Read input while (fgets(line, sizeof(line), stdin)) { int len = strlen(line); if (len > 0 && line[len-1] == '\\n') { line[len-1] = '\\0'; }  *token = strtok(line, \",\"); while (token != NULL) { diamond[rows][col] = atoi(token); col++; token = strtok(NULL,  Find the middle row (widest part) int maxRow = 0; for (int i = 0; i < rows; i++) {  for (int i = 0; i < rows;  = 0; j < 100; j++) { dp[i][j] = -1; } } // Start with first element dp[0][0] = diamond[0][0]; // Determine middle row int mid = rows / 2; // Process upper half (expanding) for (int i = 0; i < mid; i++) { for  if (dp[i][j] != -1) { // Move to left-down diagonal  diamond[i+1][j]) { dp[i+1][j] = dp[i][j]  to right-down  + diamond[i+1][j+1]) { dp[i+1][j+1] = dp[i][j] + diamond[i+1][j+1]; } } } } //  (int i = mid; i < rows  width =  for (int j  j++) { if (dp[i][j] != -1) { // Move to left-down diagonal if (j > 0) { if (dp[i+1][j-1] < dp[i][j] + diamond[i+1][j-1]) { dp[i+1][j-1] = dp[i][j] + diamond[i+1][j-1]; } } // Move to right-down diagonal if (j < width) { if (dp[i+1][j] < dp[i][j]  } } } } printf(\"%d\\n\", dp[rows-1][0]); return 0; }"], "perturbed_original": ["/* ????????????????????????????????????????????? */ #include <stdio.h> /* ?????\u00b0???????????? */ typedef void VD; typedef signed char I1;  signed short I2; typedef  long I4; typedef unsigned long U4;  99 /* ?????\u00b0????????\u00a7??? */ #define MAXOFSUM_COLUMN (MAXOFNUM_ROW+1)/2 /*  U1 mu1InputNum[MAXOFNUM_ROW][MAXOFSUM_COLUMN]; /*  ?????\u00b0??? ????????? ????????????U1 ??\\?????????????????\u00b0 */ U1 u1ReadData(); /* ??\u00a2??\u00b0??????u2SearchMax ???????????\u00a8????????????????????\u00a7?????\u00a7??????????????? ?????\u00b0??? ????\u00ac\u00ac1?????\u00b0????????\u00b0 ????????????U2 ?????\u00a7??? */ U2 u2SearchMax(U1 u1NumOfRow); /* ??\u00a2??\u00b0?????? ?????????2????????\u00b0??????????????\u00a7????????\u00b0???????????? ?????\u00b0??? ????\u00ac\u00ac1?????\u00b0?????\u00b0???1 ????\u00ac\u00ac2?????\u00b0?????\u00b0???2 ????????????U2 ??\u00a7??????????????\u00b0??? */ U2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2); VD   ???????????\u00a7??? */ u1NumOfRow = u1ReadData(); /* ??????1 ??\\??????????????????????????? */ u2MaxOfSum = u2SearchMax(u1NumOfRow); /*  ??????3 ?????\u00a7????????\u00a8????????? */ } U1 u1ReadData() { U1 u1NumOfRow; /* ?????????????????\u00b0 */ U1 u1NumOfColumn; /* ?????????????????\u00b0 */ U1 u1TmpChar; /* ','????????????'\\n'???????\u00b4????????????\u00b0 */ I1 i1ReturnScanf; /* scanf??\u00a2??\u00b0???????????????????\u00b4????????????\u00b0 */ U1 u1OnlyNumCnt; u1NumOfRow = 0; u1NumOfColumn =  != 2){ scanf(\"%d%c\",&mu1InputNum[u1NumOfRow][u1NumOfColumn],&u1TmpChar); if(u1TmpChar == ','){ u1NumOfColumn++;  if(u1NumOfColumn  u1NumOfColumn = 0;  U2 u2SearchMax(U1  ?\u00a8???????????????????????\u00b4????????????? */ U1 u1RowCnt; /* ?????\u00b0???????????? */  */ U2 u2Num1; /* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */ U2 u2Num2; /* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */ u1HalfNumOfRow = u1NumOfRow/2+1; /*  u1RowCnt < u1NumOfRow; u1RowCnt++){ for(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){ if(u1RowCnt >= u1HalfNumOfRow){ if(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){ break; } } mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]; } } for(u1RowCnt =  for(u1ColumnCnt = 0; u1ColumnCnt <=  if(u1RowCnt < u1HalfNumOfRow){ if(u1ColumnCnt == 0){ mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][0]; } else if(u1ColumnCnt == u1RowCnt){ mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][u1RowCnt-1]; }  = mu2work[u1RowCnt-1][u1ColumnCnt]; mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2); } } /* ????????\u00a2?????\u00a8???????\u00b4???\u00b0????\u00a8????????????\u00b4??? */ else{ if(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){  u2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt+1]; mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2); } } } return mu2work[u1NumOfRow-1][0]; } U2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2) { U2 u2Rtn; /* ????????????????\u00b4????????????\u00b0 */ if(u2Num1 >= u2Num2){ u2Rtn = u2Num1; }else{ u2Rtn = u2Num2; } return u2Rtn; }"], "original_ll": -0.8803245425224304, "sampled_ll": -0.44342878460884094, "all_perturbed_sampled_ll": [-1.2106351852416992], "all_perturbed_original_ll": [-1.408607006072998], "perturbed_sampled_ll": -1.2106351852416992, "perturbed_original_ll": -1.408607006072998, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] now, next;\n\tint[] dp1, dp2;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] str = sc.next().split(\",\");\n\t\tnow = new int[str.length+4];\n\t\tnow[2] = Integer.parseInt(str[0]);\n\t\tdp1 = new int[51];\n\t\tdp2 = new int[51];\n\t\tdp1[1] = now[2]; \n\t\tfor(;sc.hasNext();) {\n\t//\t\tdebug(dp1);\n\t\t\tstr = sc.next().split(\",\");\n\t\t\tdp2 = dp1.clone();\n\t//\t\tif(str[0].equals(\"0\")) break;\n\t\t\tnext = new int[str.length+4];\n\t\t\tfor(int i=0;i<str.length;i++) next[i+2] = Integer.parseInt(str[i]);\n\t//\t\tdebug(next);\n\t\t\tfor(int i=2;i<=str.length+1;i++) {\n\t\t\t\tif(now.length < next.length) dp1[i-1] = max( dp2[i-2] + next[i], dp2[i-1] + next[i]);\n\t\t\t\telse dp1[i-1] = max( dp2[i-1] + next[i], dp2[i] + next[i]);\n\t\t\t}\n\t\t\tnow = next.clone();\n\t\t}\n\t\tSystem.out.println(dp1[1]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<List<Integer>> diamond = new ArrayList<>();\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            List<Integer> row = new ArrayList<>();\n            if (line.contains(\",\")) {\n                String[] parts = line.split(\",\");\n                for (String part : parts) {\n                    row.add(Integer.parseInt(part));\n                }\n            } else {\n                row.add(Integer.parseInt(line));\n            }\n            diamond.add(row);\n        }\n        \n        int n = diamond.size();\n        int mid = n / 2;\n        \n        List<List<Integer>> dp = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            List<Integer> row = new ArrayList<>();\n            for (int j = 0; j < diamond.get(i).size(); j++) {\n                row.add(Integer.MIN_VALUE);\n            }\n            dp.add(row);\n        }\n        \n        dp.get(0).set(0, diamond.get(0).get(0));\n        \n        for (int i = 0; i < n - 1; i++) {\n            int currSize = diamond.get(i).size();\n            int nextSize = diamond.get(i + 1).size();\n            \n            if (nextSize > currSize) {\n                for (int j = 0; j < currSize; j++) {\n                    if (dp.get(i).get(j) != Integer.MIN_VALUE) {\n                        dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j), \n                            dp.get(i).get(j) + diamond.get(i + 1).get(j)));\n                        dp.get(i + 1).set(j + 1, Math.max(dp.get(i + 1).get(j + 1), \n                            dp.get(i).get(j) + diamond.get(i + 1).get(j + 1)));\n                    }\n                }\n            } else {\n                for (int j = 0; j < currSize; j++) {\n                    if (dp.get(i).get(j) != Integer.MIN_VALUE) {\n                        if (j > 0) {\n                            dp.get(i + 1).set(j - 1, Math.max(dp.get(i + 1).get(j - 1), \n                                dp.get(i).get(j) + diamond.get(i + 1).get(j - 1)));\n                        }\n                        if (j < nextSize) {\n                            dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j), \n                                dp.get(i).get(j) + diamond.get(i + 1).get(j)));\n                        }\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp.get(n - 1).get(0));\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  main(String[] args) { Scanner sc = new Scanner(System.in); List<List<Integer>> diamond  { String line = sc.nextLine().trim(); if  new ArrayList<>();  = line.split(\",\"); for (String part : parts) { row.add(Integer.parseInt(part)); } } else { row.add(Integer.parseInt(line)); } diamond.add(row); }  mid = n / 2; List<List<Integer>> dp = new ArrayList<>(); for (int i = 0; i < n; i++) { List<Integer> row = new ArrayList<>(); for (int j = 0; j < diamond.get(i).size(); j++) { row.add(Integer.MIN_VALUE); } dp.add(row);  i = 0; i < n - 1; i++) { int currSize = diamond.get(i).size(); int nextSize = diamond.get(i + 1).size(); if (nextSize >  = 0; j < currSize; j++) { if (dp.get(i).get(j) !=  Math.max(dp.get(i + 1).get(j), dp.get(i).get(j) + diamond.get(i + 1).get(j))); dp.get(i + 1).set(j +  1), dp.get(i).get(j) + diamond.get(i + 1).get(j  else { for (int j = 0; j < currSize; j++) {  if (j > 0) { dp.get(i + 1).set(j - 1, Math.max(dp.get(i + 1).get(j - 1), dp.get(i).get(j) + diamond.get(i + 1).get(j - 1))); } if (j < nextSize) {  } } } System.out.println(dp.get(n - 1).get(0)); } }"], "perturbed_original": ["import java.util.*; import static java.lang.Math.*;  = 1 << 28; int[] now, next; int[] dp1, dp2; void run() { Scanner sc = new Scanner(System.in); String[] str = sc.next().split(\",\"); now =  dp1 = new int[51]; dp2 = new int[51];  // debug(dp1); str = sc.next().split(\",\"); dp2 =  i=0;i<str.length;i++) next[i+2] = Integer.parseInt(str[i]);  if(now.length < next.length) dp1[i-1] = max( dp2[i-2] + next[i], dp2[i-1] + next[i]); else dp1[i-1] = max( dp2[i-1] + next[i], dp2[i] + next[i]); } now = next.clone(); } System.out.println(dp1[1]); } public static void main(String[] args) { new Main().run(); } void debug(Object... os) { System.err.println(Arrays.deepToString(os)); } }"], "original_ll": -0.9576488733291626, "sampled_ll": -0.3150087594985962, "all_perturbed_sampled_ll": [-1.1558564901351929], "all_perturbed_original_ll": [-1.4971169233322144], "perturbed_sampled_ll": -1.1558564901351929, "perturbed_original_ll": -1.4971169233322144, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def path(mx,w,h):\n\tif h < c/2:\n\t\tif w > 0:\n\t\t\tmx[h][w] = max(mx[h-1][w],mx[h-1][w-1]) + inp[h][w]\n\t\telse:\n\t\t\tmx[h][w] = mx[h-1][w] + inp[h][w]\n\telse:\n\t\tif w < len(inp[h])-1:\n\t\t\tmx[h][w] = max(mx[h-1][w],mx[h-1][w+1]) + inp[h][w]\n\t\telse:\n\t\t\tmx[h][w] = mx[h-1][w] + inp[h][w]\n\treturn mx\n\t\nc = 0\ninp = []\nwhile True:\n\ttry:\n\t\tinp.append(map(int, raw_input().split(\",\")))\n\t\tc += 1\n\texcept:\n\t\tmx = [[0 for i in range((c+1)/2)] for i in range(c)]\n\t\tmx[0][0] = inp[0][0]\n\t\tfor h in range(1,c):\n\t\t\tfor w in range(len(inp[h])):\n\t\t\t\tmx = path(mx,w,h)\n\t\tprint mx[c-1][0]\n\t\tbreak", "sampled": "import sys\n\nlines = []\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        lines.append(line)\n\n# Parse the diamond\ndiamond = []\nfor line in lines:\n    if ',' in line:\n        diamond.append(list(map(int, line.split(','))))\n    else:\n        diamond.append([int(line)])\n\nn = len(diamond)\nmid = n // 2\n\n# Dynamic programming\ndp = [[float('-inf')] * len(row) for row in diamond]\ndp[0][0] = diamond[0][0]\n\n# Process upper half (expanding)\nfor i in range(1, mid + 1):\n    for j in range(len(diamond[i])):\n        # Can come from position j-1 or j in previous row\n        if j > 0:\n            dp[i][j] = max(dp[i][j], dp[i-1][j-1] + diamond[i][j])\n        if j < len(diamond[i-1]):\n            dp[i][j] = max(dp[i][j], dp[i-1][j] + diamond[i][j])\n\n# Process lower half (contracting)\nfor i in range(mid + 1, n):\n    for j in range(len(diamond[i])):\n        # Can come from position j or j+1 in previous row\n        if j < len(diamond[i-1]):\n            dp[i][j] = max(dp[i][j], dp[i-1][j] + diamond[i][j])\n        if j + 1 < len(diamond[i-1]):\n            dp[i][j] = max(dp[i][j], dp[i-1][j+1] + diamond[i][j])\n\nprint(dp[n-1][0])\n", "perturbed_sampled": ["import sys lines = [] for line in sys.stdin: line = line.strip() if line: lines.append(line) # Parse the diamond diamond = [] for line in lines: if ',' in line: diamond.append(list(map(int, line.split(',')))) else: diamond.append([int(line)]) n = len(diamond) mid = n // 2 # Dynamic programming dp  row in diamond] dp[0][0] = diamond[0][0] # Process upper half (expanding)  + 1): for j in range(len(diamond[i])): # Can come from position j-1 or j in previous row if j  dp[i-1][j-1] + diamond[i][j]) if  max(dp[i][j], dp[i-1][j] + diamond[i][j]) #  i in range(mid +  range(len(diamond[i])):   row if j < len(diamond[i-1]): dp[i][j]  if j + 1 < len(diamond[i-1]): dp[i][j] = max(dp[i][j], dp[i-1][j+1] + diamond[i][j]) print(dp[n-1][0])"], "perturbed_original": ["def path(mx,w,h):  w > 0: mx[h][w] = max(mx[h-1][w],mx[h-1][w-1]) + inp[h][w] else: mx[h][w]  if w < len(inp[h])-1: mx[h][w] = max(mx[h-1][w],mx[h-1][w+1]) + inp[h][w] else: mx[h][w] = mx[h-1][w] + inp[h][w] return mx c = 0 inp = [] while True: try: inp.append(map(int, raw_input().split(\",\"))) c  [[0 for i in range((c+1)/2)] for i in range(c)] mx[0][0] = inp[0][0] for h in range(1,c): for w  print mx[c-1][0] break"], "original_ll": -0.7648698687553406, "sampled_ll": -0.5933178663253784, "all_perturbed_sampled_ll": [-1.7192822694778442], "all_perturbed_original_ll": [-1.4030604362487793], "perturbed_sampled_ll": -1.7192822694778442, "perturbed_original_ll": -1.4030604362487793, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// AOJ0090 Overlaps of Seals\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_N\t(200)\n\n\nint main(void)\n{\n    int n;\n\tdouble circle[MAX_N][2];\n    double d;\n    int flag[MAX_N][MAX_N];\n    int overlap[MAX_N][MAX_N];\n    int max_overlap;\n\tint i, j, k;\n\tint num[MAX_N], max[MAX_N], min[MAX_N];\n    int cont_flag;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// \u0093\u00fc\u0097\u00cd\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%lf,%lf\", &circle[i][0], &circle[i][1]);\n\t\t}\n\t\t\n\t\t// \u008fd\u0082\u00c8\u0082\u00e8\u0083e\u0081[\u0083u\u0083\u008b\u008d\u00ec\u0090\u00ac\n\t\tmemset(flag, 0, sizeof(flag));\n\t\tfor (i = 0; i < n; i++){\n\t\t\tfor (j = i; j < n; j++){\n\t\t\t\tif (i == j){\n\t\t\t\t\tflag[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td = (circle[i][0] - circle[j][0]) * (circle[i][0] - circle[j][0]) +\n\t\t\t\t\t    (circle[i][1] - circle[j][1]) * (circle[i][1] - circle[j][1]);\n\t\t\t\t\tif (d <= 4.0){\n\t\t\t\t\t\tflag[i][j] = flag[j][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n                    // \u0092[\u0082\u00c1\u0082\u00b1\u0082\u00cc\u008d\u00ed\u008f\u009c\n        max_overlap = 1;\n        do {\n\t\t\tfor (i = 0; i < n; i++){\n                num[i] = 0;\n\t\t\t\tfor (j = 0; j < n; j++){\n\t\t\t\t\tnum[i] += flag[i][j];\n\t\t\t\t}\n   \t\t\t}\n\n            cont_flag = 0;\n\t\t\tfor (i = 0; i < n; i++){\n                if (num[i] == 2){\n                    max_overlap = 2;\n                }\n\t\t\t\tif (num[i] == 1 || num[i] == 2){\n\t\t\t\t\tfor (j = 0; j < n; j++){\n\t\t\t\t\t\tflag[i][j] = flag[j][i] = 0; \n\t\t\t\t\t}\n                    cont_flag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (cont_flag == 1);\n\n        \n\t\tmemset(overlap, 0, sizeof(overlap));\n        for (i = 0; i < n; i++){\n            if (num[i] > 0){\n                for (j = 0; j < n; j++){\n                    if (flag[i][j] == 1){\n                        for (k = j + 1; k < n; k++){\n                            if (flag[i][k] == 1){\n                                if (flag[j][k] == 1){\n                                    overlap[i][j]++;\n                                    overlap[i][k]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (i = 0; i < n; i++){\n            max[i] = 0;\n            min[i] = 1000;\n        }\n        for (i = 0; i < n; i++){\n            for (j = 0; j < n; j++){\n                if (max[i] < overlap[i][j]){\n                    max[i] = overlap[i][j];\n                }\n                if (overlap[i][j] > 0 && min[i] > overlap[i][j]){\n                    min[i] = overlap[i][j];\n                }\n            }\n//            printf(\"<%d %d-%d>\", i, min[i], max[i]);\n        }\n\n        for (i = 0; i < n; i++){\n            for (j = 0; j < n; j++){\n//                printf(\"[%d]\",overlap[i][j]);\n                if (overlap[i][j] < overlap[i][i] || max[i] == min[i]){\n                    if (max_overlap < overlap[i][j]){\n                        max_overlap = overlap[i][j];\n                    }\n                }\n            }\n//            printf(\"\\n\");\n        }\n        \n        printf(\"%d\\n\", max_overlap + 1);\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\n#define MAX_N 100\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint main() {\n    int n;\n    Point stickers[MAX_N];\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf,%lf\", &stickers[i].x, &stickers[i].y);\n        }\n        \n        int maxOverlap = 1;\n        \n        // Check all pairs of stickers\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double dx = stickers[i].x - stickers[j].x;\n                double dy = stickers[i].y - stickers[j].y;\n                double dist = sqrt(dx * dx + dy * dy);\n                \n                // If circles overlap or touch\n                if (dist <= 2.0 + EPS) {\n                    // Find intersection points\n                    if (dist < EPS) continue; // Same center (shouldn't happen)\n                    \n                    // Calculate intersection points\n                    double a = dist / 2.0;\n                    double h = sqrt(1.0 - a * a);\n                    \n                    double mx = (stickers[i].x + stickers[j].x) / 2.0;\n                    double my = (stickers[i].y + stickers[j].y) / 2.0;\n                    \n                    double px1 = mx + h * (stickers[j].y - stickers[i].y) / dist;\n                    double py1 = my - h * (stickers[j].x - stickers[i].x) / dist;\n                    \n                    double px2 = mx - h * (stickers[j].y - stickers[i].y) / dist;\n                    double py2 = my + h * (stickers[j].x - stickers[i].x) / dist;\n                    \n                    // Check point 1\n                    int count1 = 0;\n                    for (int k = 0; k < n; k++) {\n                        double d = sqrt((px1 - stickers[k].x) * (px1 - stickers[k].x) + \n                                      (py1 - stickers[k].y) * (py1 - stickers[k].y));\n                        if (d <= 1.0 + EPS) count1++;\n                    }\n                    if (count1 > maxOverlap) maxOverlap = count1;\n                    \n                    // Check point 2\n                    int count2 = 0;\n                    for (int k = 0; k < n; k++) {\n                        double d = sqrt((px2 - stickers[k].x) * (px2 - stickers[k].x) + \n                                      (py2 - stickers[k].y) * (py2 - stickers[k].y));\n                        if (d <= 1.0 + EPS) count2++;\n                    }\n                    if (count2 > maxOverlap) maxOverlap = count2;\n                }\n            }\n            \n            // Check center of each sticker\n            int count = 0;\n            for (int k = 0; k < n; k++) {\n                double d = sqrt((stickers[i].x - stickers[k].x) * (stickers[i].x - stickers[k].x) + \n                              (stickers[i].y - stickers[k].y) * (stickers[i].y - stickers[k].y));\n                if (d <= 1.0 + EPS) count++;\n            }\n            if (count > maxOverlap) maxOverlap = count;\n        }\n        \n        printf(\"%d\\n\", maxOverlap);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #define MAX_N 100 #define EPS 1e-9 typedef struct { double x, y; } Point; int main() { int n; Point stickers[MAX_N]; while (scanf(\"%d\", &n) == 1 && n != 0) { for (int i  i++) { scanf(\"%lf,%lf\", &stickers[i].x, &stickers[i].y); } int maxOverlap =  i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { double dx = stickers[i].x - stickers[j].x; double dy  dist = sqrt(dx * dx + dy * dy); // If circles overlap or touch if (dist <= 2.0 + EPS) { // Find intersection points if (dist < EPS) continue; // Same center (shouldn't happen) // Calculate intersection points double a  a * a); double mx  2.0; double my = (stickers[i].y + stickers[j].y) /  + h * (stickers[j].y - stickers[i].y) / dist; double py1 = my - h * (stickers[j].x - stickers[i].x) / dist; double px2 =  - stickers[i].y) / dist; double py2 = my +  / dist; // Check point 1 int count1 = 0; for (int k = 0; k < n; k++)  - stickers[k].x)  (py1 - stickers[k].y) * (py1 - stickers[k].y)); if (d <= 1.0 + EPS) count1++; } if (count1 > maxOverlap) maxOverlap =  int count2 = 0; for (int k = 0; k < n; k++) { double d = sqrt((px2 - stickers[k].x) * (px2 - stickers[k].x) + (py2 - stickers[k].y) * (py2 - stickers[k].y)); if   int count = 0;  k < n; k++)  - stickers[k].x)  (stickers[i].y - stickers[k].y) * (stickers[i].y - stickers[k].y)); if (d <= 1.0 + EPS) count++; } if  count; } printf(\"%d\\n\", maxOverlap); } return 0; }"], "perturbed_original": ["// AOJ0090 Overlaps of Seals #include <stdio.h> #include <string.h> #define MAX_N (200) int main(void) { int n; double circle[MAX_N][2]; double d; int flag[MAX_N][MAX_N]; int overlap[MAX_N][MAX_N]; int max_overlap; int i, j, k; int num[MAX_N],  (1){ scanf(\"%d\", &n); if (n == 0){ break; } // \u0093\u00fc\u0097\u00cd for (i = 0; i < n; i++){ scanf(\"%lf,%lf\", &circle[i][0], &circle[i][1]); } //  (i =  for (j =  if (i  } else { d = (circle[i][0] - circle[j][0]) * (circle[i][0]  circle[j][1]) * (circle[i][1] - circle[j][1]); if (d <= 4.0){ flag[i][j] = flag[j][i]  } // \u0092[\u0082\u00c1\u0082\u00b1\u0082\u00cc\u008d\u00ed\u008f\u009c max_overlap =  = 0; i < n; i++){ num[i] = 0; for (j = 0; j < n; j++){ num[i] += flag[i][j]; } } cont_flag = 0; for (i =  if (num[i] == 2){ max_overlap = 2; }   = 0; j  flag[j][i] = 0; } cont_flag = 1; } } } while (cont_flag == 1); memset(overlap,  0; i < n; i++){ if (num[i] > 0){ for (j = 0; j < n; j++){ if (flag[i][j] == 1){ for (k = j + 1; k < n; k++){ if (flag[i][k] == 1){ if (flag[j][k] == 1){ overlap[i][j]++; overlap[i][k]++; } }  for (i = 0; i < n; i++){ max[i] = 0; min[i] = 1000; } for (i = 0; i < n; i++){ for (j  overlap[i][j]){ max[i]  > overlap[i][j]){ min[i] = overlap[i][j]; } } // printf(\"<%d %d-%d>\",  (i = 0; i < n; i++){ for (j = 0; j < n; j++){ // printf(\"[%d]\",overlap[i][j]); if (overlap[i][j] < overlap[i][i]  (max_overlap < overlap[i][j]){ max_overlap = overlap[i][j]; }  printf(\"%d\\n\", max_overlap + 1); } return (0); }"], "original_ll": -0.8038548231124878, "sampled_ll": -0.36275777220726013, "all_perturbed_sampled_ll": [-1.1711323261260986], "all_perturbed_original_ll": [-1.3682178258895874], "perturbed_sampled_ll": -1.1711323261260986, "perturbed_original_ll": -1.3682178258895874, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scanner = new Scanner(System.in);\n\t\t\n\t\tfor(; ;)\n\t\t{\n\t\t\tint n = scanner.nextInt();\n\t\t\tif(n == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint max_len = 0;\n\t\t\tfloat[] x = new float[n];\n\t\t\tfloat[] y = new float[n];\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tString[] input = scanner.next().split(\",\");\n\t\t\t\t\n\t\t\t\tx[i] = Float.parseFloat(input[0]);\n\t\t\t\ty[i] = Float.parseFloat(input[1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(float px=0; px<=10; px+=0.001)\n\t\t\t{\n\t\t\t\tfor(float py=0; py<=10; py+=0.001)\n\t\t\t\t{\n\t\t\t\t\tint len = 0;\n\t\t\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif((px-x[i])*(px-x[i])+(py-y[i])*(py-y[i]) <= 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(max_len < len)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax_len = len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max_len);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n        double dist(Point p) {\n            return Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            Point[] stickers = new Point[n];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\",\");\n                double x = Double.parseDouble(parts[0]);\n                double y = Double.parseDouble(parts[1]);\n                stickers[i] = new Point(x, y);\n            }\n            \n            int maxOverlap = 1;\n            \n            // Check all pairs of stickers and find intersection points\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    double d = stickers[i].dist(stickers[j]);\n                    if (d <= 2.0) {\n                        // Find intersection points\n                        List<Point> testPoints = getIntersectionPoints(stickers[i], stickers[j]);\n                        for (Point p : testPoints) {\n                            int count = 0;\n                            for (int k = 0; k < n; k++) {\n                                if (stickers[k].dist(p) <= 1.0 + 1e-9) {\n                                    count++;\n                                }\n                            }\n                            maxOverlap = Math.max(maxOverlap, count);\n                        }\n                    }\n                }\n                // Also check the center of each sticker\n                int count = 0;\n                for (int k = 0; k < n; k++) {\n                    if (stickers[k].dist(stickers[i]) <= 1.0 + 1e-9) {\n                        count++;\n                    }\n                }\n                maxOverlap = Math.max(maxOverlap, count);\n            }\n            \n            System.out.println(maxOverlap);\n        }\n    }\n    \n    static List<Point> getIntersectionPoints(Point c1, Point c2) {\n        List<Point> points = new ArrayList<>();\n        double d = c1.dist(c2);\n        \n        if (d > 2.0 + 1e-9) return points;\n        \n        double r = 1.0;\n        double a = (r * r - r * r + d * d) / (2 * d);\n        double h = Math.sqrt(Math.max(0, r * r - a * a));\n        \n        double cx = c1.x + a * (c2.x - c1.x) / d;\n        double cy = c1.y + a * (c2.y - c1.y) / d;\n        \n        double px1 = cx + h * (c2.y - c1.y) / d;\n        double py1 = cy - h * (c2.x - c1.x) / d;\n        \n        double px2 = cx - h * (c2.y - c1.y) / d;\n        double py2 = cy + h * (c2.x - c1.x) / d;\n        \n        points.add(new Point(px1, py1));\n        if (h > 1e-9) {\n            points.add(new Point(px2, py2));\n        }\n        \n        return points;\n    }\n}\n", "perturbed_sampled": ["import  Main { static class Point { double x, y; Point(double x, double y) { this.x =  double dist(Point p) { return Math.sqrt((x - p.x) *  - p.y) * (y  static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { int n = Integer.parseInt(line.trim()); if (n == 0) break; Point[] stickers = new Point[n]; for (int i = 0;  double x = Double.parseDouble(parts[0]); double  new Point(x, y); }  Check all pairs  = 0; i < n; i++) { for (int j =  n; j++) { double d =  { // Find intersection points List<Point> testPoints = getIntersectionPoints(stickers[i], stickers[j]); for (Point p  = 0; for (int k = 0; k <  <= 1.0 + 1e-9) { count++; } } maxOverlap = Math.max(maxOverlap, count); } } } // Also  sticker int count = 0; for (int k = 0; k < n; k++) { if (stickers[k].dist(stickers[i]) <= 1.0 + 1e-9) { count++; } } maxOverlap = Math.max(maxOverlap, count); } System.out.println(maxOverlap); } } static List<Point>  List<Point> points = new ArrayList<>(); double d = c1.dist(c2); if (d > 2.0 + 1e-9) return points; double r = 1.0; double a = (r * r - r * r + d *  double h = Math.sqrt(Math.max(0, r * r - a * a)); double cx = c1.x + a * (c2.x - c1.x) / d; double cy = c1.y + a * (c2.y - c1.y) / d; double px1 = cx + h *  double py1 =   px2 = cx - h * (c2.y  py2 =  points.add(new Point(px1, py1)); if (h > 1e-9) { points.add(new Point(px2, py2)); } return points; } }"], "perturbed_original": [" { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); for(; ;) { int n = scanner.nextInt(); if(n ==  x = new float[n]; float[]  i=0; i<n; i++) { String[] input =   px<=10; px+=0.001) { for(float py=0; py<=10; py+=0.001) { int len = 0; for(int i=0; i<n; i++) { if((px-x[i])*(px-x[i])+(py-y[i])*(py-y[i]) <= 1) { len ++; } } if(max_len < len) { max_len = len; } } } System.out.println(max_len); } } }"], "original_ll": -0.529978334903717, "sampled_ll": -0.41768375039100647, "all_perturbed_sampled_ll": [-1.3898723125457764], "all_perturbed_original_ll": [-1.6843098402023315], "perturbed_sampled_ll": -1.3898723125457764, "perturbed_original_ll": -1.6843098402023315, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\ndef overlap(p1, p2, d):\n    return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 <= d\n\ndef intersection(o1,o2):\n    a  = 2*(o2[0] - o1[0])\n    b  = 2*(o2[1] - o1[1])\n    c  = (o1[0] - o2[0])*(o1[0] + o2[0]) + (o1[1] - o2[1])*(o1[1] + o2[1])\n    a2 = a**2 + b**2\n    b2 = a*c + a*b*o1[1] - b**2*o1[0]\n    c2 = b**2*(o1[0]**2 + o1[1]**2 - 1) + c**2 + 2*b*c*o1[1]\n    x1 = (-b2 + math.sqrt(b2**2 - a2*c2))/a2\n    x2 = (-b2 - math.sqrt(b2**2 - a2*c2))/a2\n    if abs(b) < 10e-6:\n        y1 = (o1[1] + o2[1])/2\n        y2 = (o1[1] + o2[1])/2\n    else:\n        y1 = -(a*x1 + c)/b\n        y2 = -(a*x2 + c)/b\n    if abs(b2**2 - a2*c2) < 10e-6:\n        return [x1, y1], [None, None]\n    else:\n        return [x1, y1], [x2, y2]\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(list(map(float, input().split(\",\"))))\n    ans = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if not overlap(p[i], p[j], 4):\n                continue\n            elif overlap(p[i], p[j], 10e-6):\n                continue\n            p1, p2 = intersection(p[i], p[j])\n            cnt1 = 0\n            cnt2 = 0\n            for k in range(n):\n                if overlap(p1, p[k], 1):\n                    cnt1 += 1\n                if p2[0] != None and overlap(p2, p[k], 1):\n                    cnt2 += 1\n            ans = max([ans, cnt1, cnt2])\n    print(ans)\n\n", "sampled": "import sys\nfrom math import sqrt\n\ndef distance(p1, p2):\n    return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef circles_overlap(c1, c2):\n    return distance(c1, c2) <= 2.0\n\ndef max_overlap(circles):\n    if not circles:\n        return 0\n    \n    n = len(circles)\n    if n == 1:\n        return 1\n    \n    max_count = 1\n    \n    # Check overlaps at each circle center\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if circles_overlap(circles[i], circles[j]):\n                count += 1\n        max_count = max(max_count, count)\n    \n    # Check intersection points of pairs of circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            if circles_overlap(circles[i], circles[j]):\n                # Find intersection points\n                x1, y1 = circles[i]\n                x2, y2 = circles[j]\n                \n                d = distance(circles[i], circles[j])\n                \n                if d == 0:\n                    continue\n                \n                if d <= 2.0:\n                    # Calculate intersection points\n                    a = d / 2.0\n                    h = sqrt(1.0 - a * a) if a <= 1.0 else 0\n                    \n                    mx = (x1 + x2) / 2.0\n                    my = (y1 + y2) / 2.0\n                    \n                    dx = (x2 - x1) / d\n                    dy = (y2 - y1) / d\n                    \n                    # Two intersection points\n                    points = []\n                    if h > 0:\n                        points.append((mx + h * dy, my - h * dx))\n                        points.append((mx - h * dy, my + h * dx))\n                    else:\n                        points.append((mx, my))\n                    \n                    for point in points:\n                        count = 0\n                        for k in range(n):\n                            if distance(point, circles[k]) <= 1.0 + 1e-9:\n                                count += 1\n                        max_count = max(max_count, count)\n    \n    return max_count\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    circles = []\n    for _ in range(n):\n        line = input().strip()\n        x, y = map(float, line.split(','))\n        circles.append((x, y))\n    \n    print(max_overlap(circles))\n", "perturbed_sampled": ["import sys from math import sqrt def distance(p1, p2): return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def circles_overlap(c1,  2.0 def max_overlap(circles): if not circles: return 0 n = len(circles) if  max_count = 1 # Check overlaps at each circle center for i in  j in range(n): if circles_overlap(circles[i],  = max(max_count,  of pairs of circles for  in range(i + 1, n): if circles_overlap(circles[i], circles[j]): # Find intersection points x1, y1 = circles[i] x2, y2 = circles[j] d = distance(circles[i], circles[j]) if d == 0: continue  Calculate intersection points a = d / 2.0 h = sqrt(1.0 - a * a) if a <= 1.0 else 0 mx = (x1 + x2) /  y2) /  x1) /  y1) / d # Two intersection points points = [] if h > 0: points.append((mx + h * dy, my - h * dx)) points.append((mx - h * dy, my + h * dx)) else: points.append((mx, my)) for point in points: count =  if distance(point, circles[k]) <= 1.0 + 1e-9: count += 1 max_count = max(max_count, count) return max_count while True: n =  for  input().strip() x, y  print(max_overlap(circles))"], "perturbed_original": ["import math def overlap(p1, p2, d): return  - p2[1])**2 <= d def  o1[0]) b = 2*(o2[1] - o1[1]) c = (o1[0] -  - o2[1])*(o1[1] + o2[1]) a2  - b**2*o1[0] c2 = b**2*(o1[0]**2 + o1[1]**2  2*b*c*o1[1] x1 = (-b2 + math.sqrt(b2**2 - a2*c2))/a2 x2 = (-b2 - math.sqrt(b2**2 - a2*c2))/a2 if abs(b) < 10e-6: y1 = (o1[1] + o2[1])/2 y2 = (o1[1] + o2[1])/2 else: y1 = -(a*x1 + c)/b y2 = -(a*x2 + c)/b if abs(b2**2 - a2*c2) < 10e-6: return [x1, y1], [None, None] else: return [x1, y1], [x2, y2] while True:  == 0: break p = [] for  ans = 0 for i in  in  not overlap(p[i], p[j], 4): continue elif overlap(p[i], p[j], 10e-6): continue p1, p2  0 cnt2 = 0 for k in range(n): if overlap(p1, p[k], 1): cnt1 += 1 if p2[0] != None and overlap(p2, p[k], 1): cnt2  cnt1, cnt2]) print(ans)"], "original_ll": -0.680182933807373, "sampled_ll": -0.597815990447998, "all_perturbed_sampled_ll": [-1.6019930839538574], "all_perturbed_original_ll": [-1.559517502784729], "perturbed_sampled_ll": -1.6019930839538574, "perturbed_original_ll": -1.559517502784729, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "z[4000],*a=z,*b=z+2000,m,i,j,t,u;main(n){for(;scanf(\"%d\",&n)*n++;m=!printf(\"%d\\n\",m))for(i=n;i--;j=a,a=b,b=j)for(j=n;j--;t>m?m=t:0)t=b[j]=n+~i&&getchar()>45?1+fmin(u=a[j],fmin(t,u)):0;}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    char grid[1001][1001];\n    int dp[1001][1001];\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        // Read the grid\n        for(int i = 0; i < n; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        // Initialize dp array\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                dp[i][j] = 0;\n            }\n        }\n        \n        // Build dp array\n        int maxSize = 0;\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == '.') {\n                    if(i == 0 || j == 0) {\n                        dp[i][j] = 1;\n                    } else {\n                        int min = dp[i-1][j];\n                        if(dp[i][j-1] < min) min = dp[i][j-1];\n                        if(dp[i-1][j-1] < min) min = dp[i-1][j-1];\n                        dp[i][j] = min + 1;\n                    }\n                    if(dp[i][j] > maxSize) {\n                        maxSize = dp[i][j];\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", maxSize);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; char grid[1001][1001]; int dp[1001][1001]; while(scanf(\"%d\", &n) == 1 && n != 0) {  i = 0; i < n; i++) { scanf(\"%s\", grid[i]); } // Initialize dp array for(int i =  { for(int j = 0; j < n; j++) { dp[i][j] = 0; } } //  = 0; for(int i = 0; i < n; i++) { for(int j = 0;  if(grid[i][j] == '.') { if(i  0) { dp[i][j]  int min = dp[i-1][j]; if(dp[i][j-1] < min) min = dp[i][j-1]; if(dp[i-1][j-1] < min) min = dp[i-1][j-1]; dp[i][j]  if(dp[i][j] >  } } } } printf(\"%d\\n\", maxSize); } return 0; }"], "perturbed_original": ["z[4000],*a=z,*b=z+2000,m,i,j,t,u;main(n){for(;scanf(\"%d\",&n)*n++;m=!printf(\"%d\\n\",m))for(i=n;i--;j=a,a=b,b=j)for(j=n;j--;t>m?m=t:0)t=b[j]=n+~i&&getchar()>45?1+fmin(u=a[j],fmin(t,u)):0;}"], "original_ll": -2.9673879146575928, "sampled_ll": -0.34700897336006165, "all_perturbed_sampled_ll": [-1.0593452453613281], "all_perturbed_original_ll": [-2.9673879146575928], "perturbed_sampled_ll": -1.0593452453613281, "perturbed_original_ll": -2.9673879146575928, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\nclass Main {\n\tprivate static String check = \".\";\n\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\n\t\ttry {\n\t\t\twhile (!(buf = br.readLine()).equals(\"0\")) {\n\t\t\t\tint n = Integer.parseInt(buf);\n\t\t\t\tint mat[][] = new int[n][n];\n\t\t\t\tString str[] = new String[n];\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tstr[i] = br.readLine();\n\t\t\t\t\tfor (int j=0;j<n;j++) {\n\t\t\t\t\t\tif (str[i].charAt(j)=='.') mat[i][j] = 0;\n\t\t\t\t\t\telse if (str[i].charAt(j)=='*') mat[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max = 0;\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tif (str[i].indexOf(check)>=0) {\n\t\t\t\t\t\tfor (int j=0;j<n;j++) {\n\t\t\t\t\t\t\tint d = Square(mat,i,j,n);\n\t\t\t\t\t\t\tif (max<d) {\n\t\t\t\t\t\t\t\tmax = d;\n\t\t\t\t\t\t\t\tcheck = \".\";\n\t\t\t\t\t\t\t\tfor (int k=0;k<max;k++) check = check+\".\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static int Square(int[][] m,int x,int y,int n) {\n\t\tint c = 0;\n\t\tboolean end = false;\n\t\twhile (x+c<n&&y+c<n) {\n\t\t\tfor (int i=y;i<=y+c;i++) {\n\t\t\t\tif (m[i][x+c]==1) {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i=x+c;i>=x;i--) {\n\t\t\t\tif (m[y+c][i]==1) {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc++;\n\t\t}\n\t\treturn c;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            sc.nextLine();\n            \n            char[][] grid = new char[n][n];\n            for (int i = 0; i < n; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            \n            int[][] dp = new int[n][n];\n            int maxSize = 0;\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (grid[i][j] == '.') {\n                        if (i == 0 || j == 0) {\n                            dp[i][j] = 1;\n                        } else {\n                            dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;\n                        }\n                        maxSize = Math.max(maxSize, dp[i][j]);\n                    } else {\n                        dp[i][j] = 0;\n                    }\n                }\n            }\n            \n            System.out.println(maxSize);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args)  Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; sc.nextLine(); char[][] grid = new char[n][n]; for (int i  i++) { String line = sc.nextLine(); for (int j = 0; j < n;  } } int[][] dp = new int[n][n]; int maxSize = 0; for (int i = 0; i < n; i++) {  j < n; j++)  { if  == 0) {  { dp[i][j] = Math.min(Math.min(dp[i-1][j],  maxSize = Math.max(maxSize, dp[i][j]); } else { dp[i][j] = 0; } } } System.out.println(maxSize); } sc.close(); } }"], "perturbed_original": ["import java.io.*; class Main { private static String check = \".\"; public static void main(String  new  { while (!(buf = br.readLine()).equals(\"0\")) { int n = Integer.parseInt(buf); int mat[][] = new int[n][n]; String str[] = new String[n]; for (int i=0;i<n;i++) { str[i] = br.readLine(); for (int j=0;j<n;j++) { if (str[i].charAt(j)=='.') mat[i][j] = 0; else if (str[i].charAt(j)=='*') mat[i][j] = 1; } } int max =  if (str[i].indexOf(check)>=0) { for  = Square(mat,i,j,n); if (max<d) { max = d; check =  = check+\".\"; } } } } System.out.println(max); } } catch (Exception e) { e.printStackTrace(); } } public static int Square(int[][] m,int  c = 0; boolean end =  (int i=y;i<=y+c;i++) { if (m[i][x+c]==1) { return c;   c; } } c++; } return c; } }"], "original_ll": -0.6793728470802307, "sampled_ll": -0.26850929856300354, "all_perturbed_sampled_ll": [-1.295403003692627], "all_perturbed_original_ll": [-1.8455309867858887], "perturbed_sampled_ll": -1.295403003692627, "perturbed_original_ll": -1.8455309867858887, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while(1):\n    n = int(input())\n    if n == 0:\n        break\n    a = [0 for i in range(n)]\n    b = [[0 for i in range(n)] for j in range(n)]\n    c_ = [[2000 for i in range(n)] for j in range(n)]\n    c = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        a[i] = [0 if i == \".\" else 1 for i in list(input())]\n        count = 0\n        for j in range(n)[::-1]:\n            if a[i][j] == 0:\n                count += 1\n                b[i][j] = count\n            else:\n                count = 0\n                b[i][j] = count\n                \n    for col in range(n):\n        for i in range(n):\n            for j in range(i,n):\n                if b[j][col] < c_[i][col]:\n                    c_[i][col] = b[j][col]\n                l = j-i+1\n                if c_[i][col] < l:\n                    break\n                c[i][col] = l\n    \n    print(max([max(i) for i in c]))\n\n", "sampled": "import sys\n\ndef max_square(n, grid):\n    if n == 0:\n        return 0\n    \n    # Create DP table\n    dp = [[0] * n for _ in range(n)]\n    max_side = 0\n    \n    # Initialize first row and column\n    for i in range(n):\n        if grid[i][0] == '.':\n            dp[i][0] = 1\n            max_side = 1\n    \n    for j in range(n):\n        if grid[0][j] == '.':\n            dp[0][j] = 1\n            max_side = 1\n    \n    # Fill DP table\n    for i in range(1, n):\n        for j in range(1, n):\n            if grid[i][j] == '.':\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n    \n    return max_side\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    grid = []\n    for _ in range(n):\n        grid.append(input().strip())\n    \n    result = max_square(n, grid)\n    print(result)\n", "perturbed_sampled": ["import sys def max_square(n, grid):  0 # Create DP table dp = [[0] * n for _ in range(n)] max_side = 0 # Initialize first row and column for i in range(n): if grid[i][0]  max_side = 1 for j in range(n): if grid[0][j] == '.': dp[0][j] = 1 max_side = 1 #  in range(1, n): for j in range(1, n): if grid[i][j] == '.': dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) +  return max_side while True: n = int(input()) if n == 0: break grid =  grid) print(result)"], "perturbed_original": ["while(1): n  0: break a = [0 for i in range(n)] b = [[0 for i  range(n)] c_ = [[2000 for i in range(n)] for j in range(n)] c = [[0 for i in range(n)] for j in range(n)]  =   list(input())] count = 0 for  1 b[i][j] = count else: count = 0 b[i][j] = count for col in range(n): for i in range(n): for j in range(i,n): if b[j][col] < c_[i][col]: c_[i][col] = b[j][col] l = j-i+1 if c_[i][col] < l: break c[i][col] = l print(max([max(i) for i in c]))"], "original_ll": -0.7963653206825256, "sampled_ll": -0.41151222586631775, "all_perturbed_sampled_ll": [-1.4588042497634888], "all_perturbed_original_ll": [-1.7160685062408447], "perturbed_sampled_ll": -1.4588042497634888, "perturbed_original_ll": -1.7160685062408447, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n\tint before,after;\n\tint i;\n\tint flag = 0;\n\twhile(scanf(\"%d %d\",&before,&after)){\n\t\tif(before == 0 && after == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = before;i <= after;i++){\n\t\t\tif(i % 4 == 0){\n\t\t\t\tif(i % 100 != 0){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tprintf(\"%d\\n\",i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i % 4 == 0){\n\t\t\t\tif(i % 400 == 0){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tprintf(\"%d\\n\",i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag == 0){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\tprintf(\"\\n\\n\");\n\t\tflag = 0;\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint isLeapYear(int year) {\n    if (year % 400 == 0) return 1;\n    if (year % 100 == 0) return 0;\n    if (year % 4 == 0) return 1;\n    return 0;\n}\n\nint main() {\n    int a, b;\n    int first = 1;\n    \n    while (1) {\n        scanf(\"%d %d\", &a, &b);\n        if (a == 0 && b == 0) break;\n        \n        if (!first) {\n            printf(\"\\n\");\n        }\n        first = 0;\n        \n        int found = 0;\n        for (int year = a; year <= b; year++) {\n            if (isLeapYear(year)) {\n                printf(\"%d\\n\", year);\n                found = 1;\n            }\n        }\n        \n        if (!found) {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int isLeapYear(int if (!found)<extra_id_1>printf(\"NA\\n\"); }<extra_id_2>first) { printf(\"\\n\"); first =<extra_id_3>0; for(int year = a;<extra_id_4><= b; year++) { if<extra_id_5><=<extra_id_6>) printf(\"%d\\n\",<extra_id_7>if (!found) {<extra_id_8>(first) ) break;<extra_id_9>} printf(\"NA\\n\");<extra_id_10>printf(\"%d\\n\"<extra_id_11>-1; 400 == 0) if (first)<extra_id_12>printf(\"\\n 100 ==  % 4 == 0) return 1; return 0; } int  int first = 1; while (1) { scanf(\"%d %d\", &a, &b); if (a == 0 && b == 0) break; if (!first) { printf(\"\\n\");  found = 0; for (int year = a; year <= b; year++) { if (isLeapYear(year)) { printf(\"%d\\n\", year);  if (!found) { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int before,after; int i; int flag = 0; while(scanf(\"%d %d\",&before,&after)){ if(before == 0 && after == %500<extra_id_3>if(flag==0){<extra_id_4>} for(i<extra_id_5>= 0;i<10;i++){ printf(\"%d\\n\",i); }<extra_id_6>if(-flag!=0){ printf(\"%d\\n\",i); } if(i before;i %400!=0){<extra_id_7>i =<extra_id_8>; } printf(\"%d\\n\",i); 100 != 0){ flag = 1; printf(\"%d\\n\",i); } } if(i  % 400 == 0){ flag = 1; printf(\"%d\\n\",i); } } } if(flag == 0){ printf(\"NA\\n\"); } printf(\"\\n\\n\"); flag = 0; } return 0; }"], "original_ll": -0.748376727104187, "sampled_ll": -0.4099724292755127, "all_perturbed_sampled_ll": [-1.9215823411941528], "all_perturbed_original_ll": [-1.9773586988449097], "perturbed_sampled_ll": -1.9215823411941528, "perturbed_original_ll": -1.9773586988449097, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nclass Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n\n        while (!(line = br.readLine()).equals(\"0 0\")) {\n            String[] input = line.split(\" \");\n            int a = Integer.parseInt(input[0]);\n            int b = Integer.parseInt(input[1]);\n            StringBuilder sb = new StringBuilder();\n\n            boolean isNA = true;\n\n            for (int now = a; now <= b; now++) {\n                if (now % 4 == 0) {\n                    if(now % 100 == 0){\n                        if(now % 400 == 0){\n                            sb.append(now).append(\"\\n\");\n                            if (isNA)   isNA = false;\n                        }\n                    }else{\n                        sb.append(now).append(\"\\n\");\n                        if (isNA)   isNA = false;\n                    }\n                }\n            }\n\n            if (isNA) {\n                sb.append(\"NA\").append(\"\\n\");\n            }\n\n            System.out.println(sb);\n        }\n\n    }\n}\n", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        boolean first = true;\n        \n        while (true) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            \n            if (a == 0 && b == 0) {\n                break;\n            }\n            \n            if (!first) {\n                System.out.println();\n            }\n            first = false;\n            \n            boolean found = false;\n            for (int year = a; year <= b; year++) {\n                if (isLeapYear(year)) {\n                    System.out.println(year);\n                    found = true;\n                }\n            }\n            \n            if (!found) {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean isLeapYear(int year) {\n        if (year % 400 == 0) {\n            return true;\n        }\n        if (year % 100 == 0) {\n            return false;\n        }\n        if (year % 4 == 0) {\n            return true;\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  args) { Scanner sc = new Scanner(System.in); boolean first = true; while (true) { int a = sc.nextInt(); int b = sc.nextInt(); if (a == 0 && b == 0) { break; }  first = false; boolean  year = a; year <= b; year++) { if (isLeapYear(year)) { System.out.println(year); found  (!found) { System.out.println(\"NA\"); }   (year % 400 == 0) { return true; } if (year % 100 ==  if (year % 4 == 0) { return true; } return false; } }"], "perturbed_original": ["import java.io.IOException; import java.io.BufferedReader; import java.io.InputStreamReader; class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while (!(line = br.readLine()).equals(\"0  line.split(\" \"); int a  Integer.parseInt(input[1]); StringBuilder sb =   now++) { if (now % 4 == 0) { if(now % 100 == 0){ if(now  if (isNA) isNA = false; } }else{ sb.append(now).append(\"\\n\"); if (isNA) isNA = false; } } } if (isNA) { sb.append(\"NA\").append(\"\\n\"); } System.out.println(sb); } } }"], "original_ll": -0.639552116394043, "sampled_ll": -0.364399790763855, "all_perturbed_sampled_ll": [-1.6743533611297607], "all_perturbed_original_ll": [-1.6509984731674194], "perturbed_sampled_ll": -1.6743533611297607, "perturbed_original_ll": -1.6509984731674194, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    a,b=map(int,raw_input().split(\" \"))\n    if a==0 and b==0:\n        break\n    uruu=[]\n    for i in [year for year in range(b+1) if year >=a]:\n        if i%4==0 and i%100!=0 or i%400==0:\n            uruu.append(str(i))\n    if len(uruu)!=0:\n        print '\\n'.join(uruu)\n    else:\n        print \"NA\"\n    print ''", "sampled": "def is_leap_year(year):\n    if year % 400 == 0:\n        return True\n    if year % 100 == 0:\n        return False\n    if year % 4 == 0:\n        return True\n    return False\n\nfirst_dataset = True\n\nwhile True:\n    a, b = map(int, input().split())\n    if a == 0 and b == 0:\n        break\n    \n    if not first_dataset:\n        print()\n    first_dataset = False\n    \n    leap_years = []\n    for year in range(a, b + 1):\n        if is_leap_year(year):\n            leap_years.append(year)\n    \n    if leap_years:\n        for year in leap_years:\n            print(year)\n    else:\n        print(\"NA\")\n", "perturbed_sampled": ["def is_leap_year(year): if year % 400 == 0: return True if year % 100 == 0: return False if year % 4  False first_dataset  if a ==  break if not first_dataset: print() first_dataset = False leap_years = [] for year in range(a, b + 1): if is_leap_year(year): leap_years.append(year) if leap_years: for year in leap_years: print(year) else: print(\"NA\")"], "perturbed_original": ["while True: a,b=map(int,raw_input().split(\" \"))  uruu=[] for i in [year for year in range(b+1) if year >=a]: if i%4==0 and i%100!=0 or  '\\n'.join(uruu) else: print \"NA\" print ''"], "original_ll": -1.1694852113723755, "sampled_ll": -0.542375385761261, "all_perturbed_sampled_ll": [-1.754167079925537], "all_perturbed_original_ll": [-2.536015272140503], "perturbed_sampled_ll": -1.754167079925537, "perturbed_original_ll": -2.536015272140503, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "int main(){double a,b;scanf(\"%lf%lf\",&a,&b);printf(\"%.8f\\n\",a*b*0.3025);return 0;}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    \n    double area_m2 = a * b;\n    double area_tsubo = area_m2 / 3.305785;\n    \n    printf(\"%.6f\\n\", area_tsubo);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int a, b; scanf(\"%d %d\", &a, &b); double area_m2 = a * b; double  printf(\"%.6f\\n\", area_tsubo); return 0; }"], "perturbed_original": ["int main(){double a,b;scanf(\"%lf%lf\",&a,&b);printf(\"%.8f\\n\",a*b*0.3025);return 0;}"], "original_ll": -1.7246594429016113, "sampled_ll": -1.174204707145691, "all_perturbed_sampled_ll": [-2.312547206878662], "all_perturbed_original_ll": [-1.7246594429016113], "perturbed_sampled_ll": -2.312547206878662, "perturbed_original_ll": -1.7246594429016113, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tString[] input = new Scanner(System.in).nextLine().split(\" \");\n\t\t\n\t\tfloat a = Float.parseFloat(input[0]);\n\t\tfloat b = Float.parseFloat(input[1]);\n\t\t\n\t\tSystem.out.printf(\"%1$.6f\\n\", a*b/3.305785);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        \n        double area = a * b;\n        double tsubo = area / 3.305785;\n        \n        System.out.println(tsubo);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void  = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); double area = a  area / 3.305785; System.out.println(tsubo); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { String[] input  a = Float.parseFloat(input[0]); float b = Float.parseFloat(input[1]); System.out.printf(\"%1$.6f\\n\", a*b/3.305785); } }"], "original_ll": -1.2508490085601807, "sampled_ll": -1.0565663576126099, "all_perturbed_sampled_ll": [-2.3995354175567627], "all_perturbed_original_ll": [-2.2207064628601074], "perturbed_sampled_ll": -2.3995354175567627, "perturbed_original_ll": -2.2207064628601074, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a, b = map(int, input().split())\nprint(a * b / 3.305785)", "sampled": "a, b = map(int, input().split())\narea_m2 = a * b\ntsubo = area_m2 / 3.305785\nprint(tsubo)\n", "perturbed_sampled": ["a, b = map(int, input().split()) area_m2 = a * b tsubo = area_m2 / 3.305785 print(tsubo)"], "perturbed_original": ["a, b = map(int, input().split()) print(a * b / 3.305785)"], "original_ll": -1.8834068775177002, "sampled_ll": -1.8334237337112427, "all_perturbed_sampled_ll": [-2.2760980129241943], "all_perturbed_original_ll": [-2.4175193309783936], "perturbed_sampled_ll": -2.2760980129241943, "perturbed_original_ll": -2.4175193309783936, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int wo, ws, n;\n  int i;\n\n  scanf ( \"%d%d%d\", &n, &wo, &ws );\n  for ( i = 1; i < n; ++i )\n  {\n    int o, s;\n\n    scanf ( \"%d%d\", &o, &s );\n    if ( s > ws\n      || ( s == ws && o < wo ) )\n    {\n      wo = o;\n      ws = s;\n    }\n  }\n\n  printf ( \"%d %d\\n\", wo, ws );\n\n  return ( EXIT_SUCCESS );\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int max_count = -1;\n    int winner_id = 100000;\n    \n    for (int i = 0; i < n; i++) {\n        int a, v;\n        scanf(\"%d %d\", &a, &v);\n        \n        if (v > max_count || (v == max_count && a < winner_id)) {\n            max_count = v;\n            winner_id = a;\n        }\n    }\n    \n    printf(\"%d %d\\n\", winner_id, max_count);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n); int max_count  100000; for (int i = 0; i < n; i++) { int a, v;  (v > max_count ||  < winner_id)) { max_count = v; winner_id = a; } } printf(\"%d %d\\n\", winner_id, max_count); return 0; }"], "perturbed_original": [" main ( int argc, char *argv[ ] ) { int wo, ws,  \"%d%d%d\", &n, &wo, &ws ); for ( i =   scanf ( \"%d%d\", &o, &s ); if ( s > ws ||  o < wo ) ) { wo = o; ws = s; } } printf ( \"%d %d\\n\", wo, ws ); return ( EXIT_SUCCESS ); }"], "original_ll": -0.9576864242553711, "sampled_ll": -0.634984016418457, "all_perturbed_sampled_ll": [-1.6779941320419312], "all_perturbed_original_ll": [-2.0629305839538574], "perturbed_sampled_ll": -1.6779941320419312, "perturbed_original_ll": -2.0629305839538574, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt(),x = 0,y,max = 0;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx = Math.max(x, (y = sc.nextInt()));\n\t\t\tif(y == x)max = i + 1;\n\t\t}\n\t\tSystem.out.println(max + \" \" + x);\n\t\t\n\t\tsc.close();\n\t\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        int winnerNumber = 0;\n        int maxCount = -1;\n        \n        for (int i = 0; i < n; i++) {\n            int participantNumber = sc.nextInt();\n            int count = sc.nextInt();\n            \n            if (count > maxCount || (count == maxCount && participantNumber < winnerNumber)) {\n                maxCount = count;\n                winnerNumber = participantNumber;\n            }\n        }\n        \n        System.out.println(winnerNumber + \" \" + maxCount);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  public static void main(String[] args) { Scanner sc  = sc.nextInt(); int winnerNumber = 0; int maxCount = -1; for (int i = 0; i < n; i++) { int participantNumber = sc.nextInt(); int count = sc.nextInt(); if (count >  && participantNumber < winnerNumber)) { maxCount = count;  System.out.println(winnerNumber + \" \" + maxCount); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner;  main(String[] args){ Scanner sc = new Scanner(System.in); int  = 0; for(int i = 0; i < n; i++){ x = Math.max(x, (y = sc.nextInt())); if(y  1; } System.out.println(max + \" \" + x); sc.close(); } }"], "original_ll": -1.1142160892486572, "sampled_ll": -0.5537645220756531, "all_perturbed_sampled_ll": [-1.8296618461608887], "all_perturbed_original_ll": [-1.9933383464813232], "perturbed_sampled_ll": -1.8296618461608887, "perturbed_original_ll": -1.9933383464813232, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n=input()\nx=[0]*(n+1)\nfor i in range(n):\n  a,v=map(int, raw_input().split())\n  x[a]=v\nm=max(x)\nprint x.index(m), m", "sampled": "n = int(input())\nmax_count = -1\nwinner_id = float('inf')\n\nfor _ in range(n):\n    a, v = map(int, input().split())\n    if v > max_count or (v == max_count and a < winner_id):\n        max_count = v\n        winner_id = a\n\nprint(winner_id, max_count)\n", "perturbed_sampled": ["n = int(input()) max_count = -1 winner_id = float('inf') for  = map(int, input().split()) if v > max_count or (v == max_count and a  winner_id = a print(winner_id, max_count)"], "perturbed_original": ["n=input() x=[0]*(n+1) for i in range(n): a,v=map(int, raw_input().split()) x[a]=v m=max(x) print x.index(m), m"], "original_ll": -1.905624508857727, "sampled_ll": -1.0605190992355347, "all_perturbed_sampled_ll": [-2.455230474472046], "all_perturbed_original_ll": [-2.18837571144104], "perturbed_sampled_ll": -2.455230474472046, "perturbed_original_ll": -2.18837571144104, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint n;\n\tint i, j, k, l;\n\tint c;\n\t\n\twhile (scanf(\"%d\", &n) != EOF){\n\t\tc = 0;\n\t\tfor (i = 0; i <= 1000; i++){\n\t\t\tfor (j = 0; j <= 1000; j++){\n\t\t\t\tfor (k = 0; k <= 1000; k++){\n\t\t\t\t\tfor (l = 0; l <= 1000; l++){\n\t\t\t\t\t\tif (i + j + k + l == n){\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) != EOF) {\n        long long count = 0;\n        for (int a = 0; a <= 1000 && a <= n; a++) {\n            for (int b = 0; b <= 1000 && a + b <= n; b++) {\n                for (int c = 0; c <= 1000 && a + b + c <= n; c++) {\n                    int d = n - a - b - c;\n                    if (d >= 0 && d <= 1000) {\n                        count++;\n                    }\n                }\n            }\n        }\n        printf(\"%lld\\n\", count);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() {  != EOF) {  for (int a = 0; a <= 1000 && a <= n; a++) { for (int b = 0; b <= 1000 && a +  for (int c = 0; c <= 1000 && a + b + c <=  = n - a - b - c; if (d >= 0 && d <= 1000) { count++;  count); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int n; int i, j, k, l; int  EOF){ c = 0; for (i = 0; i <= 1000; i++){ for (j = 0;  (k = 0; k <= 1000;  l <= 1000; l++){ if (i + j + k + l  } } } printf(\"%d\\n\", c); } return (0); }"], "original_ll": -0.47624602913856506, "sampled_ll": -0.3889685571193695, "all_perturbed_sampled_ll": [-1.686881184577942], "all_perturbed_original_ll": [-1.7262934446334839], "perturbed_sampled_ll": -1.686881184577942, "perturbed_original_ll": -1.7262934446334839, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Sum of 4 Integers II\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tint[][] dp = new int[5][4001];\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = 0; j <= 1000; j++) {\n\t\t\t\tdp[i][i * j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tdp[i][0] = 1;\n\t\t}\n\n\t\tfor (int i = 2; i <= 4; i++) {\n\t\t\tfor (int j = 1; j <= 1000; j++) {\n\t\t\t\tdp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n\t\t\t}\n\t\t}\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tSystem.out.println(dp[4][parseInt(line)]);\n\t\t} // end while\n\t} // end main\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Precompute all possible sums for two numbers (a+b and c+d)\n        Map<Integer, Integer> sumCount = new HashMap<>();\n        for (int i = 0; i <= 1000; i++) {\n            for (int j = 0; j <= 1000; j++) {\n                int sum = i + j;\n                sumCount.put(sum, sumCount.getOrDefault(sum, 0) + 1);\n            }\n        }\n        \n        while (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            long count = 0;\n            \n            // For each possible sum of a+b, check if n-(a+b) exists as c+d\n            for (Map.Entry<Integer, Integer> entry : sumCount.entrySet()) {\n                int sum1 = entry.getKey();\n                int count1 = entry.getValue();\n                int sum2 = n - sum1;\n                \n                if (sumCount.containsKey(sum2)) {\n                    count += (long) count1 * sumCount.get(sum2);\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); // Precompute all possible sums for  Map<Integer, Integer> sumCount = new HashMap<>(); for (int i = 0; i <= 1000; i++) { for (int  1000; j++) { int sum =  0) + 1); } } while (sc.hasNextInt()) { int n = sc.nextInt(); long count = 0; // For each possible sum of a+b, check if  (Map.Entry<Integer, Integer> entry : sumCount.entrySet()) { int sum1 = entry.getKey(); int count1 = entry.getValue(); int sum2 = n -  +=   }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import static java.lang.Integer.parseInt; /** * Sum of 4 Integers II */ public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; int[][] dp = new int[5][4001]; for (int i = 1; i <= 4;  = 0; j  * j] = 1; } } for (int  4; i++) { dp[i][0] = 1; } for (int i = 2; i <= 4; i++) { for (int j = 1;  dp[i][j] = dp[i - 1][j] +  while ((line = br.readLine()) !=  } // end  }"], "original_ll": -0.6368560791015625, "sampled_ll": -0.5122713446617126, "all_perturbed_sampled_ll": [-1.6954987049102783], "all_perturbed_original_ll": [-1.6329033374786377], "perturbed_sampled_ll": -1.6954987049102783, "perturbed_original_ll": -1.6329033374786377, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    try:\n        n = input(); p = min(2000, n);\n        print (p+1)*(p+2)*(3*n-2*p+3)/6\n    except EOFError:\n        break", "sampled": "import sys\nfrom collections import defaultdict\n\ndef count_combinations(n):\n    # Count all possible sums of two numbers (a+b)\n    sum_count = defaultdict(int)\n    \n    # Calculate all possible sums a+b where 0 <= a, b <= 1000\n    for a in range(min(n+1, 1001)):\n        for b in range(min(n+1, 1001)):\n            if a + b <= n:\n                sum_count[a + b] += 1\n    \n    # For each sum of c+d, find how many a+b sums match to make n\n    result = 0\n    for c in range(min(n+1, 1001)):\n        for d in range(min(n+1, 1001)):\n            if c + d <= n:\n                needed = n - (c + d)\n                if needed in sum_count:\n                    result += sum_count[needed]\n    \n    return result\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    print(count_combinations(n))\n", "perturbed_sampled": ["import sys from collections import defaultdict def count_combinations(n): # Count all possible sums of two numbers (a+b) sum_count  <= 1000 for a in range(min(n+1, 1001)): for b in range(min(n+1, 1001)):  n: sum_count[a + b] += 1 # For  how many a+b sums match to make n result = 0 for c in range(min(n+1, 1001)): for d in range(min(n+1, 1001)): if c + d <= n: needed = n - (c  sum_count: result += sum_count[needed] return result for line in sys.stdin: n = int(line.strip()) print(count_combinations(n))"], "perturbed_original": ["while 1: try: n = input(); p = min(2000, n); print (p+1)*(p+2)*(3*n-2*p+3)/6 except EOFError: break"], "original_ll": -1.7867523431777954, "sampled_ll": -0.8459447622299194, "all_perturbed_sampled_ll": [-1.7903602123260498], "all_perturbed_original_ll": [-2.1057493686676025], "perturbed_sampled_ll": -1.7903602123260498, "perturbed_original_ll": -2.1057493686676025, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// AOJ 0098: Maximum Sum Sequence II \n// 2017.8.15 bal4u@uu\n// 2017.11.1 retry\n\n#include <stdio.h>\n\nint a[102][102];\nint s[102][102];\n\nchar buf[1000], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, r, c, k, ans;\n\n\tfgets(p=buf, 10, stdin), n = getint();\n\tfor (r = 0; r < n; r++) {\n\t\tfgets(p=buf, sizeof(buf), stdin);\n\t\tfor (c = 0; c < n; c++, p++) {\n\t\t\tif (*p == '-') p++, a[r][c] = -getint();\n\t\t\telse                a[r][c] =  getint();\n\t\t}\n\t}\n\n\tfor (r = 0; r < n; r++)\n\t\tfor (c = 0; c < n; c++)\n\t\t\ts[r][c+1] += s[r][c] + a[r][c];\n\n\tans = s[0][1];\n\tfor (c = 0; c < n; c++) for (k = c+1; k <= n; k++) {\n\t\tint t = 0;\n\t\tfor (r = 0; r < n; r++) {\n\t\t\tif (t < 0) t  = s[r][k] - s[r][c];\n\t\t\telse       t += s[r][k] - s[r][c];\n\t\t\tif (t > ans) ans = t;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int a[100][100];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n    \n    int max_sum = a[0][0];\n    \n    for (int top = 0; top < n; top++) {\n        int col_sum[100] = {0};\n        \n        for (int bottom = top; bottom < n; bottom++) {\n            for (int j = 0; j < n; j++) {\n                col_sum[j] += a[bottom][j];\n            }\n            \n            int current_sum = 0;\n            for (int j = 0; j < n; j++) {\n                current_sum += col_sum[j];\n                if (current_sum > max_sum) {\n                    max_sum = current_sum;\n                }\n                if (current_sum < 0) {\n                    current_sum = 0;\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", max_sum);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n); int a[100][100];  i < n; i++) { for (int j = 0; j < n;  } int max_sum = a[0][0]; for (int  n; top++)  for (int bottom =  {  j < n; j++) { col_sum[j] += a[bottom][j]; } int current_sum = 0; for (int j = 0; j < n; j++) { current_sum +=  { max_sum = current_sum; } if (current_sum < 0) { current_sum = 0; } } } } printf(\"%d\\n\", max_sum); return 0; }"], "perturbed_original": ["// AOJ 0098: Maximum  bal4u@uu // 2017.11.1 retry #include <stdio.h> int a[102][102]; int s[102][102]; char buf[1000], *p; int getint() { int n = 0; while (*p >=  (n<<1) + (*p++ & 0xf); return n; } int main() { int n, r, c, k,  =  r < n; r++) { fgets(p=buf, sizeof(buf), stdin); for (c = 0; c < n; c++, p++) { if (*p == '-')  a[r][c] = getint(); } } for (r = 0; r < n; r++)  < n; c++) s[r][c+1] +=  s[0][1]; for (c = 0; c < n; c++)  <= n; k++) { int t  0; r < n; r++) { if (t < 0) t  t += s[r][k] - s[r][c]; if (t > ans) ans = t; } } printf(\"%d\\n\", ans); return 0; }"], "original_ll": -1.0139570236206055, "sampled_ll": -0.3286702632904053, "all_perturbed_sampled_ll": [-1.4627078771591187], "all_perturbed_original_ll": [-1.8536722660064697], "perturbed_sampled_ll": -1.4627078771591187, "perturbed_original_ll": -1.8536722660064697, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class\nMain\n{\n  public void\n  run (\n    final java.util.Scanner sc,\n    final java.io.PrintStream out\n    )\n  {\n    int[ ][ ] a;\n    int N;\n    int i, j, k, l;\n    int res;\n\n    N = sc.nextInt ( );\n    a = new int[ N ][ N + 1 ];\n    for ( i = 0; i < N; ++i )\n    for ( j = 1; j <= N ; ++j )\n      a[ i ][ j ] = sc.nextInt ( );\n\n    for ( i = 0; i < N; ++i )\n    for ( j = 1; j <= N; ++j )\n      a[ i ][ j ] += a[ i ][ j - 1 ];\n\n    res = a[ 0 ][ 1 ];\n    for ( i = 0; i < N; ++i )\n    for ( j = i + 1; j <= N; ++j )\n    {\n      for ( k = 0; k < N; ++k )\n      {\n        int t = 0;\n\n        for ( l = k; l < N; ++l )\n        {\n          t += a[ l ][ j ] - a[ l ][ i ];\n          res = Math.max ( res, t );\n        }\n      }\n    }\n\n    out.println ( res );\n  }\n\n  public static void\n  main (\n    String[ ] args\n    )\n  {\n    ( new Main ( ) ).run ( new java.util.Scanner ( System.in ), System.out );\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] a = new int[n][n];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                a[i][j] = sc.nextInt();\n            }\n        }\n        \n        long maxSum = Long.MIN_VALUE;\n        \n        for (int top = 0; top < n; top++) {\n            int[] colSum = new int[n];\n            \n            for (int bottom = top; bottom < n; bottom++) {\n                for (int col = 0; col < n; col++) {\n                    colSum[col] += a[bottom][col];\n                }\n                \n                long currentSum = 0;\n                long maxEndingHere = Long.MIN_VALUE;\n                \n                for (int col = 0; col < n; col++) {\n                    currentSum += colSum[col];\n                    maxEndingHere = Math.max(maxEndingHere, currentSum);\n                    if (currentSum < 0) {\n                        currentSum = 0;\n                    }\n                }\n                \n                maxSum = Math.max(maxSum, maxEndingHere);\n            }\n        }\n        \n        System.out.println(maxSum);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] a = new  0; i  (int j =  { a[i][j] = sc.nextInt(); } } long maxSum = Long.MIN_VALUE; for  < n; top++) { int[] colSum = new int[n]; for (int bottom  col = 0; col < n; col++) { colSum[col] += a[bottom][col]; } long currentSum = 0; long maxEndingHere = Long.MIN_VALUE; for (int col = 0; col < n; col++) { currentSum += colSum[col]; maxEndingHere = Math.max(maxEndingHere, currentSum); if (currentSum < 0) { currentSum = 0; } }  }"], "perturbed_original": ["public class  ( final java.util.Scanner sc, final java.io.PrintStream out ) { int[ ][ ] a; int N; int i, j, k, l; int res; N =  new int[ N ][ N +  = 0; i < N; ++i ) for (  N ; ++j ) a[ i ][ j ] = sc.nextInt ( ); for ( i = 0; i <  j = 1; j <= N; ++j ) a[ i ][ j ] += a[ i ][ j - 1 ]; res =  for ( i = 0; i < N; ++i )  + 1;  = 0; k < N; ++k ) { int t = 0; for ( l = k; l < N; ++l ) { t += a[ l ][ j  i ]; res = Math.max ( res, t ); } }  } public  ] args ) { ( new Main  java.util.Scanner ( System.in ), System.out ); } }"], "original_ll": -0.6675134897232056, "sampled_ll": -0.32110852003097534, "all_perturbed_sampled_ll": [-1.3018797636032104], "all_perturbed_original_ll": [-1.7650419473648071], "perturbed_sampled_ll": -1.3018797636032104, "perturbed_original_ll": -1.7650419473648071, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0098\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\ndef calc_points(n, array):\n    # \u53f3\u4e0b\u304b\u3089(x, y)\u307e\u3067\u306e\u9577\u65b9\u5f62\u306b\u542b\u307e\u308c\u308b\u5024\u306e\u548c\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for y in range(n - 1, -1, -1):\n        for x in range(n - 1, -1, -1):\n            dp[y][x] = dp[y+1][x] + dp[y][x+1] - dp[y+1][x+1] + array[y][x]\n    return dp\n\n\ndef solve(n, array):\n    ans = []\n    dp = calc_points(n, array)\n\n    for sy in range(n + 1):\n        for sx in range(n + 1):\n            for ey in range(sy, n + 1):\n                for ex in range(sx, n + 1):\n                    s1 = dp[sy][sx] #  \u53f3\u4e0b\u304b\u3089\u59cb\u70b9\u307e\u3067\n                    s2 = dp[sy][ex] #  \u91cd\u306a\u308a\u90e8\u5206\n                    s3 = dp[ey][sx] #  \u91cd\u306a\u308a\u90e8\u5206\n                    s4 = dp[ey][ex] #  \u91cd\u306a\u308a\u306e\u91cd\u306a\u308a\u90e8\u5206\n                    s = s1 - s2 -s3 + s4 #  (sx, sy) - (ex, ey) \u9577\u65b9\u5f62\u306e\u7f8e\u5473\u3057\u3055\u30dd\u30a4\u30f3\u30c8\n                    # area = abs(sy - ey) * abs(sx - ex) #  \u9577\u65b9\u5f62\u306e\u9762\u7a4d\n                    ans.append(s)\n    return max(ans)\n\n\ndef main(args):\n    array = []\n    # n = 3\n    # array.append([1, -2, 3])\n    # array.append([-4, 5, 6])\n    # array.append([7, 8, -9])\n\n    n = int(input())\n    for _ in range(n):\n        array.append([int(x) for x in input().split()])\n    ans = solve(n, array)\n    print(ans)\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n", "sampled": "def max_subarray_sum(arr):\n    if not arr:\n        return 0\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\nn = int(input())\nmatrix = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    matrix.append(row)\n\nmax_sum = float('-inf')\n\nfor top in range(n):\n    temp = [0] * n\n    for bottom in range(top, n):\n        for col in range(n):\n            temp[col] += matrix[bottom][col]\n        current_max = max_subarray_sum(temp)\n        max_sum = max(max_sum, current_max)\n\nprint(max_sum)\n", "perturbed_sampled": ["def max_subarray_sum(arr): if not arr: return 0 max_sum = float('-inf') current_sum =  current_sum = max(num, current_sum + num)   = [] for _ in range(n): row = list(map(int, input().split())) matrix.append(row) max_sum = float('-inf') for top in  n for bottom in range(top, n): for col in range(n): temp[col] += matrix[bottom][col] current_max = max_subarray_sum(temp) max_sum = max(max_sum, current_max) print(max_sum)"], "perturbed_original": ["# -*- coding: utf-8  sys from sys  def calc_points(n, array): # \u53f3\u4e0b\u304b\u3089(x, y)\u307e\u3067\u306e\u9577\u65b9\u5f62\u306b\u542b\u307e\u308c\u308b\u5024\u306e\u548c dp  1) for _ in range(n + 1)] for y in range(n - 1, -1, -1): for x in   return  = [] dp = calc_points(n, array) for sy in range(n + 1): for sx in range(n + 1): for ey in range(sy, n + 1): for ex  s1 = dp[sy][sx] # \u53f3\u4e0b\u304b\u3089\u59cb\u70b9\u307e\u3067 s2 = dp[sy][ex] # \u91cd\u306a\u308a\u90e8\u5206 s3 = dp[ey][sx] #  \u91cd\u306a\u308a\u306e\u91cd\u306a\u308a\u90e8\u5206 s  + s4 # (sx, sy) - (ex, ey) \u9577\u65b9\u5f62\u306e\u7f8e\u5473\u3057\u3055\u30dd\u30a4\u30f3\u30c8 # area = abs(sy - ey) * abs(sx - ex) # \u9577\u65b9\u5f62\u306e\u9762\u7a4d ans.append(s) return max(ans) def main(args): array = [] # n = 3 # array.append([1, -2, 3]) # array.append([-4, 5, 6]) # array.append([7, 8, -9]) n = int(input()) for _ in range(n): array.append([int(x)  = solve(n, array) print(ans) if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -0.844601035118103, "sampled_ll": -0.47501662373542786, "all_perturbed_sampled_ll": [-1.6025859117507935], "all_perturbed_original_ll": [-1.8936104774475098], "perturbed_sampled_ll": -1.6025859117507935, "perturbed_original_ll": -1.8936104774475098, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <assert.h>\nint main(void){\n\tint i,x,n,q,a,v,aaa=0,vvv=0,vv[9000],f[1000001],next[1000001],prev[1000001];\n\tscanf(\"%d %d\",&n,&q);\n\tfor(i=0;i<=n;i++){f[i]=0;prev[i]=0;next[i]=0;}\n\tfor(i=0;i<9000;i++)vv[i]=0;\n\tfor(;q>0;q--){\n\t\tscanf(\"%d %d\",&a,&v);\n\n\t\tx=f[a];\n\n\t\tif(x>0){\n\t\t\tif(vv[x]==a){\n\t\t\t\tif(next[a]>0){vv[x]=next[a];}\n\t\t\t\telse vv[x]=0;\n\t\t\t}\n\t\t\tnext[prev[a]]=next[a];\n\t\t\tprev[next[a]]=prev[a];\n\t\t\tprev[0]=0;next[0]=0;\n\t\t}\n\n\t\tf[a]+=v;x+=v;\n\t\t\n\t\tif(x>0){\n\t\t\tif(a<vv[x] || vv[x]==0){\n\t\t\t\tprev[a]=0;\n\t\t\t\tnext[a]=vv[x];\n\t\t\t\tprev[vv[x]]=a;\n\t\t\t\tprev[0]=0;\n\t\t\t\tvv[x]=a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti=vv[x];\n\t\t\t\twhile(a>next[i] && next[i]>0){i=next[i];assert(i>0 && i<=n);}\n\t\t\t\tprev[a]=i;\n\t\t\t\tnext[a]=next[i];\n\t\t\t\tprev[next[i]]=a;\n\t\t\t\tnext[i]=a;\n\t\t\t\tprev[0]=0;\n\t\t\t}\n\t\t}else{prev[a]=0;next[a]=0;}\n\t\t\n\t\tif(v>0){if(x>vvv || (x==vvv && a<aaa)){vvv=x;aaa=a;}}\n\t\telse if(a==aaa){\n\t\t\ti=vvv;\n\t\t\t//for(i=vvv; vv[i]<1 && i>0 ;i--){assert(i>0 && i<9000);}\n\t\t\tvvv=i;\n\t\t\t//aaa=vv[i];\n\t\t}\n\t\tprintf(\"%d %d\\n\",aaa,vvv);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    long long *counts = (long long *)calloc(n + 1, sizeof(long long));\n    \n    int max_id = 1;\n    long long max_count = 0;\n    \n    for (int i = 0; i < q; i++) {\n        int a, v;\n        scanf(\"%d %d\", &a, &v);\n        \n        counts[a] += v;\n        \n        max_id = 1;\n        max_count = counts[1];\n        for (int j = 2; j <= n; j++) {\n            if (counts[j] > max_count) {\n                max_count = counts[j];\n                max_id = j;\n            }\n        }\n        \n        printf(\"%d %lld\\n\", max_id, max_count);\n    }\n    \n    free(counts);\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int main() {  *counts = (long long *)calloc(n +  = 1; long long max_count = 0; for (int i = 0; i < q; i++) { int a, v; scanf(\"%d %d\", &a, &v); counts[a] += v; max_id = 1; max_count = counts[1];  j <=  > max_count) { max_count = counts[j]; max_id = j; } } printf(\"%d %lld\\n\", max_id, max_count); } free(counts); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <assert.h> int main(void){  for(i=0;i<9000;i++)vv[i]=0; for(;q>0;q--){ scanf(\"%d %d\",&a,&v); x=f[a]; if(x>0){ if(vv[x]==a){ if(next[a]>0){vv[x]=next[a];} else vv[x]=0;  f[a]+=v;x+=v; if(x>0){ if(a<vv[x] || vv[x]==0){ prev[a]=0; next[a]=vv[x]; prev[vv[x]]=a; prev[0]=0; vv[x]=a; } else{ i=vv[x];  prev[a]=i; next[a]=next[i]; prev[next[i]]=a; next[i]=a; prev[0]=0; } }else{prev[a]=0;next[a]=0;} if(v>0){if(x>vvv || (x==vvv && a<aaa)){vvv=x;aaa=a;}} else if(a==aaa){  ;i--){assert(i>0 && i<9000);} vvv=i; //aaa=vv[i]; } printf(\"%d %d\\n\",aaa,vvv); } return 0; }"], "original_ll": -1.116189956665039, "sampled_ll": -0.5146515965461731, "all_perturbed_sampled_ll": [-1.5997074842453003], "all_perturbed_original_ll": [-1.892432689666748], "perturbed_sampled_ll": -1.5997074842453003, "perturbed_original_ll": -1.892432689666748, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class\nMain\n{\n  public void\n  run (\n    final java.util.Scanner sc,\n    final java.io.PrintStream out\n    )\n  {\n    Pair[ ] heap;\n    int[ ]  paeh;\n    int n, q;\n    int i;\n    \n    n = sc.nextInt ( );\n    q = sc.nextInt ( );\n\n    heap = new Pair[ n ];\n    paeh = new int[ n + 1 ];\n    for ( i = 1; i <= n; ++i )\n    {\n      paeh[ i ] = i - 1;\n      heap[ paeh[ i ] ] = new Pair ( i, 0 );\n    }\n\n    for ( ; q > 0; --q )\n    {\n      int a, v, b;\n\n      a = sc.nextInt ( );\n      v = sc.nextInt ( );\n      b = heap[ heap.length - 1 ].index;\n\n      swap ( heap, paeh[ a ], paeh[ b ] );\n      swap ( paeh, a, heap[ paeh[ a ] ].index );\n      for ( ; ; )\n      {\n        if ( paeh[ b ] * 2 + 2 < heap.length - 1\n          && heap[ paeh[ b ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] * 2 + 1 ] ) < 0\n          && heap[ paeh[ b ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] ] ) < 0 )\n        {\n          swap ( heap, paeh[ b ], paeh[ b ] * 2 + 2 );\n          swap ( paeh, b, heap[ paeh[ b ] ].index );\n        }\n        else if ( paeh[ b ] * 2 + 1 < heap.length - 1\n               && heap[ paeh[ b ] * 2 + 1 ].compareTo ( heap[ paeh[ b ] ] ) < 0 )\n        {\n          swap ( heap, paeh[ b ], paeh[ b ] * 2 + 1 );\n          swap ( paeh, b, heap[ paeh[ b ] ].index );\n        }\n        else break ;\n      }\n      heap[ paeh[ a ] ].value += v;\n      for ( ; ; )\n      {\n        if ( paeh[ a ] > 0\n          && heap[ paeh[ a ] ].compareTo ( heap[ ( paeh[ a ] - 1 ) / 2 ] ) < 0 )\n        {\n          swap ( heap, paeh[ a ], ( paeh[ a ] - 1 ) / 2 );\n          swap ( paeh, a, heap[ paeh[ a ] ].index );\n        }\n        else break ;\n      }\n      System.out.println ( heap[ 0 ].index + \" \" + heap[ 0 ].value );\n    }\n  }\n\n  private static void\n  swap (\n    int[ ] a,\n    int i,\n    int j\n    )\n  {\n    final int t = a[ i ];\n    a[ i ] = a[ j ];\n    a[ j ] = t;\n  }\n\n  private static <T> void\n  swap (\n    T[ ] a,\n    int i,\n    int j\n    )\n  {\n    final T t = a[ i ];\n    a[ i ] = a[ j ];\n    a[ j ] = t;\n  }\n\n  public static void\n  main (\n    final String[ ] args\n    )\n  {\n    ( new Main ( ) ).run ( new java.util.Scanner ( System.in ), System.out );\n  }\n\n  private class\n  Pair\n  implements Comparable<Pair>\n  {\n    public final int index;\n    public       int value;\n\n    public\n    Pair (\n      final int index,\n      final int value\n      )\n    {\n      this.index = index;\n      this.value = value;\n    }\n\n    public int\n    compareTo (\n      final Pair obj\n      )\n    {\n      if ( this.value == obj.value )\n        return ( this.index - obj.index );\n      return ( obj.value - this.value );\n    }\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int q = sc.nextInt();\n        \n        Map<Integer, Integer> counts = new HashMap<>();\n        \n        for (int i = 0; i < q; i++) {\n            int a = sc.nextInt();\n            int v = sc.nextInt();\n            \n            counts.put(a, counts.getOrDefault(a, 0) + v);\n            \n            int maxCount = Integer.MIN_VALUE;\n            int maxParticipant = Integer.MAX_VALUE;\n            \n            for (int participant = 1; participant <= n; participant++) {\n                int count = counts.getOrDefault(participant, 0);\n                if (count > maxCount || (count == maxCount && participant < maxParticipant)) {\n                    maxCount = count;\n                    maxParticipant = participant;\n                }\n            }\n            \n            System.out.println(maxParticipant + \" \" + maxCount);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int q  = new HashMap<>(); for (int i =  { int a = sc.nextInt(); int  0) + v); int maxCount = Integer.MIN_VALUE; int maxParticipant = Integer.MAX_VALUE; for (int participant = 1; participant <= n; participant++) {   (count == maxCount && participant < maxParticipant)) { maxCount = count;  System.out.println(maxParticipant + \" \" + maxCount); } sc.close(); } }"], "perturbed_original": ["public class Main { public void run ( final java.util.Scanner sc, final java.io.PrintStream out  int[ ] paeh; int n, q; int i; n = sc.nextInt ( ); q = sc.nextInt ( ); heap = new  new int[ n + 1 ]; for ( i  ++i ) { paeh[ i ] = i - 1; heap[ paeh[ i  ( i, 0 ); } for ( ;  { int a, v, b; a = sc.nextInt ( ); v = sc.nextInt ( ); b = heap[  ( heap, paeh[ a  heap[ paeh[ a ] ].index ); for ( ; ; ) { if ( paeh[ b ] * 2 + 2 < heap.length -  2 ].compareTo ( heap[ paeh[ b ] * 2 + 1 ] ) < 0  * 2 + 2 ].compareTo ( heap[ paeh[ b ] ] ) < 0 ) { swap ( heap, paeh[ b ], paeh[ b ] * 2 +  b, heap[ paeh[  else if ( paeh[ b ] * 2 + 1 < heap.length - 1 && heap[ paeh[ b ] * 2 +  < 0 ) { swap ( heap,  ]  swap ( paeh, b, heap[ paeh[ b ] ].index ); } else break ; } heap[ paeh[ a ] ].value += v; for  if  0 &&  a ] - 1 ) / 2 ] ) < 0 ) { swap ( heap, paeh[ a ], ( paeh[ a ] -  swap ( paeh, a, heap[ paeh[ a ] ].index );  System.out.println ( heap[ 0 ].index + \" \" + heap[ 0 ].value ); } } private static void swap ( int[ ] a, int i, int j ) { final int t  j ]; a[  private static  ] a, int i, int j ) { final T t = a[ i ]; a[ i ] = a[ j ]; a[ j ] = t; } public static void main ( final String[ ] args ) { ( new Main ( ) ).run  ), System.out ); } private  public final  public Pair ( final int index, final  = index; this.value = value; } public int compareTo ( final Pair obj ) { if ( this.value == obj.value ) return ( this.index - obj.index ); return ( obj.value - this.value ); } } }"], "original_ll": -0.5393235683441162, "sampled_ll": -0.5077760815620422, "all_perturbed_sampled_ll": [-1.82529878616333], "all_perturbed_original_ll": [-1.6517831087112427], "perturbed_sampled_ll": -1.82529878616333, "perturbed_original_ll": -1.6517831087112427, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0099\n\"\"\"\nimport sys\nimport bisect\n\n\n\ndef main(args):\n    #data = [(1, 4), (2, 5), (1, 3), (3, 6), (2, 7)]\n    #data = [(1, 4), (2, 5), (2, -3),(3, 4), (1, -1)]\n    fisher, event = [int(x) for x in input().split(' ')]\n    fishes = [0 for _ in range(fisher + 1)]\n\n    winner = 9999999999\n    max_fish = -1\n    for _ in range(event):\n        id, fish = [int(x) for x in input().strip().split(' ')]\n        fishes[id] += fish\n        if fish > 0:\n            if fishes[id] > max_fish:\n                max_fish = fishes[id]\n                winner = id\n            elif fishes[id] == max_fish:\n                winner = min(winner, id)\n            else:\n                pass\n        else:\n            max_fish = max(fishes)\n            winner = fishes.index(max_fish)\n        print('{} {}'.format(winner, max_fish))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])", "sampled": "n, q = map(int, input().split())\ncounts = [0] * (n + 1)\n\nfor _ in range(q):\n    a, v = map(int, input().split())\n    counts[a] += v\n    \n    max_count = max(counts[1:n+1])\n    for i in range(1, n + 1):\n        if counts[i] == max_count:\n            print(i, max_count)\n            break\n", "perturbed_sampled": ["n, q = map(int, input().split()) counts = [0] * (n + 1)   += v max_count = max(counts[1:n+1]) for i in range(1, n + 1): if counts[i] == max_count: print(i, max_count) break"], "perturbed_original": ["# -*- coding: utf-8 -*- \"\"\" http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0099 \"\"\" import sys import bisect def main(args): #data = [(1, 4), (2, 5), (1,  #data = [(1, 4),  (1, -1)] fisher, event = [int(x) for x in  for _ in range(fisher + 1)] winner = 9999999999 max_fish = -1 for _ in range(event): id, fish = [int(x) for x  fish if fish > 0: if fishes[id] > max_fish:  max_fish: winner = min(winner, id) else: pass else: max_fish = max(fishes) winner = fishes.index(max_fish) print('{} {}'.format(winner, max_fish)) if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -0.9914648532867432, "sampled_ll": -0.7045387029647827, "all_perturbed_sampled_ll": [-1.4253878593444824], "all_perturbed_original_ll": [-1.7425671815872192], "perturbed_sampled_ll": -1.4253878593444824, "perturbed_original_ll": -1.7425671815872192, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\tint n;\n\tint staff,price,sold;\n\twhile(1){\n\t\tint i,j = 0;\n\t\tint sccess[4000];\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0)\n\t\t\treturn 0;\n\t\t\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d %d %d\", &staff, &price, &sold);\n\t\t\tif(price * sold >= 1000000){\n\t\t\t\tsccess[j] = staff;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(j == 0){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\tfor(i = 0; j > i; i++){\n\t\t\tprintf(\"%d\\n\", sccess[i]);\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n != 0) {\n        int ids[4000];\n        long long sales[4000];\n        int count = 0;\n        \n        for(int i = 0; i < n; i++) {\n            int id, p, q;\n            scanf(\"%d %d %d\", &id, &p, &q);\n            \n            int found = -1;\n            for(int j = 0; j < count; j++) {\n                if(ids[j] == id) {\n                    found = j;\n                    break;\n                }\n            }\n            \n            if(found == -1) {\n                ids[count] = id;\n                sales[count] = (long long)p * q;\n                count++;\n            } else {\n                sales[found] += (long long)p * q;\n            }\n        }\n        \n        int found_any = 0;\n        for(int i = 0; i < count; i++) {\n            if(sales[i] >= 1000000) {\n                printf(\"%d\\n\", ids[i]);\n                found_any = 1;\n            }\n        }\n        \n        if(!found_any) {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() {  n != 0) { int ids[4000]; long long sales[4000]; int count  0; i < n; i++) { int id, p, q; scanf(\"%d %d %d\", &id, &p,  for(int j =  { if(ids[j] == id) { found = j; break; }  ids[count] = id; sales[count] = (long long)p * q; count++; } else { sales[found] += (long long)p * q; } } int found_any = 0; for(int i = 0; i < count; i++) { if(sales[i]  found_any = 1; } } if(!found_any) {  }"], "perturbed_original": ["#include<stdio.h> int main(void){ int n; int staff,price,sold; while(1){ int i,j = 0; int sccess[4000]; scanf(\"%d\", &n); if(n == 0) return 0; for(i = 0;i < n;i++){ scanf(\"%d %d %d\", &staff, &price, &sold); if(price * sold >= 1000000){ sccess[j] = staff;  0){ printf(\"NA\\n\"); } <extra_id_12>printf(\"NA\\n\"); printf(\"NA\\n\"); }  } }"], "original_ll": -1.183956503868103, "sampled_ll": -0.5220412015914917, "all_perturbed_sampled_ll": [-1.6199859380722046], "all_perturbed_original_ll": [-2.199831008911133], "perturbed_sampled_ll": -1.6199859380722046, "perturbed_original_ll": -2.199831008911133, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Sale Result\npublic class Main{\n\n\tstatic class P implements Comparable<P>{\n\t\tpublic int o;\n\t\tpublic long s;\n\t\tpublic int compareTo(P o) {\n\t\t\treturn this.o-o.o;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tList<Integer> l = new ArrayList<Integer>();\n\t\t\tP[] s = new P[4001];\n\t\t\tint id = 0;\n\t\t\twhile(n--!=0){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tif(s[d]==null){\n\t\t\t\t\ts[d] = new P();\n\t\t\t\t\ts[d].o = id++;\n\t\t\t\t}\n\t\t\t\tlong p = sc.nextLong();\n\t\t\t\tlong k = sc.nextLong();\n\t\t\t\ts[d].s+=p*k;\n\t\t\t}\n\t\t\tfor(int i=1;i<4001;i++)if(s[i]!=null&&1000000<=s[i].s)l.add(i);\n\t\t\tCollections.sort(l);\n\t\t\tif(l.isEmpty())System.out.println(\"NA\");\n\t\t\telse for(int i:l)System.out.println(i);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            LinkedHashMap<Integer, Long> sales = new LinkedHashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                int id = sc.nextInt();\n                long price = sc.nextLong();\n                long quantity = sc.nextLong();\n                long amount = price * quantity;\n                \n                sales.put(id, sales.getOrDefault(id, 0L) + amount);\n            }\n            \n            boolean found = false;\n            for (Map.Entry<Integer, Long> entry : sales.entrySet()) {\n                if (entry.getValue() >= 1000000) {\n                    System.out.println(entry.getKey());\n                    found = true;\n                }\n            }\n            \n            if (!found) {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; LinkedHashMap<Integer, Long> sales = new LinkedHashMap<>(); for (int i = 0; i < n;  sc.nextInt(); long price = sc.nextLong(); long quantity = sc.nextLong(); long amount =   found = false; for (Map.Entry<Integer, Long> entry : sales.entrySet()) { if (entry.getValue() >= 1000000)  sc.close(); } }"], "perturbed_original": ["import java.util.ArrayList; (P)<extra_id_2>while(sc.nextInt())break; } } public static<extra_id_3>new<extra_id_4>) ;<extra_id_5>( ) ; }<extra_id_6>)<extra_id_7>( args [<extra_id_8>if ( i ==<extra_id_9>s )<extra_id_10>}<extra_id_22>public static int Main (<extra_id_23>)  Main{ static class P  public long s; public int compareTo(P  } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){ int n = sc.nextInt(); if(n==0)break; List<Integer> l = new ArrayList<Integer>(); P[] s = new P[4001]; int id = 0; while(n--!=0){ int d = sc.nextInt(); if(s[d]==null){ s[d] = new P(); s[d].o = id++; } long p = sc.nextLong(); long k = sc.nextLong(); s[d].s+=p*k; } for(int i=1;i<4001;i++)if(s[i]!=null&&1000000<=s[i].s)l.add(i); Collections.sort(l); if(l.isEmpty())System.out.println(\"NA\");  }"], "original_ll": -0.9789004325866699, "sampled_ll": -0.45947757363319397, "all_perturbed_sampled_ll": [-1.2767215967178345], "all_perturbed_original_ll": [-1.9484922885894775], "perturbed_sampled_ll": -1.2767215967178345, "perturbed_original_ll": -1.9484922885894775, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nfrom collections import defaultdict\n\nfor s in sys.stdin:\n    n = int(s)\n    if n == 0:\n        break\n\n    d = defaultdict(int)\n    keys = []\n    for i in range(n):\n        e, p, q = map(int, input().split())\n        d[e] += p * q\n        if e not in keys:\n            keys.append(e)\n\n    # remove dup\n    is_exist = False\n\n    for key in keys:\n        v = d[key]\n        if v >= 1000000:\n            print(key)\n            is_exist = True\n\n    if not is_exist:\n        print('NA')", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    sales = {}\n    order = []\n    \n    for _ in range(n):\n        line = input().split()\n        employee_id = line[0]\n        p = int(line[1])\n        q = int(line[2])\n        \n        if employee_id not in sales:\n            sales[employee_id] = 0\n            order.append(employee_id)\n        \n        sales[employee_id] += p * q\n    \n    result = []\n    for employee_id in order:\n        if sales[employee_id] >= 1000000:\n            result.append(employee_id)\n    \n    if result:\n        for emp_id in result:\n            print(emp_id)\n    else:\n        print(\"NA\")\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break sales  for _ in range(n): line = input().split() employee_id = line[0]  int(line[2]) if employee_id  0 order.append(employee_id) sales[employee_id] += p * q result = [] for  >= 1000000: result.append(employee_id) if result: for emp_id in result: print(emp_id) else: print(\"NA\")"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys import os import math from collections import defaultdict for s in  n == 0: break d = defaultdict(int) keys =  e, p, q = map(int, input().split()) d[e] += p * q if e not in keys: keys.append(e) # remove dup is_exist =  v >= 1000000: print(key) is_exist = True if not is_exist: print('NA')"], "original_ll": -1.1192142963409424, "sampled_ll": -0.7151361107826233, "all_perturbed_sampled_ll": [-2.2756779193878174], "all_perturbed_original_ll": [-2.4353623390197754], "perturbed_sampled_ll": -2.2756779193878174, "perturbed_original_ll": -2.4353623390197754, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n\tint n;\n\tchar in[1024], *ptr;\n\n\tscanf(\"%d \", &n);\n\n\twhile (n--) {\n\t\tfgets(in, 1023, stdin);\n\t\tptr = strstr(in, \"Hoshino\");\n\t\twhile (ptr != NULL) {\n\t\t\tptr[6] = 'a';\n\t\t\tptr = strstr(ptr, \"Hoshino\");\n\t\t}\n\t\tprintf(\"%s\", in);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    char line[1001];\n    char result[1001];\n    \n    scanf(\"%d\\n\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        fgets(line, sizeof(line), stdin);\n        \n        int len = strlen(line);\n        if (line[len-1] == '\\n') {\n            line[len-1] = '\\0';\n            len--;\n        }\n        \n        int j = 0;\n        int k = 0;\n        \n        while (j < len) {\n            if (j + 6 < len && strncmp(&line[j], \"Hoshino\", 7) == 0) {\n                strcpy(&result[k], \"Hoshina\");\n                k += 7;\n                j += 7;\n            } else if (j + 6 == len && strncmp(&line[j], \"Hoshino\", 7) == 0) {\n                strcpy(&result[k], \"Hoshina\");\n                k += 7;\n                j += 7;\n            } else {\n                result[k] = line[j];\n                k++;\n                j++;\n            }\n        }\n        \n        result[k] = '\\0';\n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; char line[1001]; <extra_id_3>char<extra_id_4>result[k] = ' '<extra_id_5>(<extra_id_6>{ if<extra_id_7>++<extra_id_8>if (i >=<extra_id_9>==<extra_id_10>(line[j] = line[j]);<extra_id_11>else { strcpy(&result[k], result[k]);<extra_id_12>result[j] = '\\0'; j++;<extra_id_13>*= 10; }<extra_id_14>) + 7 (int i = 0; i < n; i++) { fgets(line, sizeof(line), stdin); int len = strlen(line); if (line[len-1] == '\\n') { line[len-1] = '\\0';  0; int k = 0; while (j < len) { if (j  strncmp(&line[j], \"Hoshino\", 7) == 0) { strcpy(&result[k], \"Hoshina\"); k += 7; j += 7; } else if (j + 6 == len && strncmp(&line[j], \"Hoshino\", 7)  k += 7; j  result[k] = line[j]; k++; j++; }  }"], "perturbed_original": ["#include <stdio.h>  int n; char in[1024], *ptr; scanf(\"%d \", &n); while (n--)  = strstr(in, \"Hoshino\"); while (ptr != NULL) { ptr[6] = 'a'; ptr = strstr(ptr, \"Hoshino\"); } printf(\"%s\", in); } return 0; }"], "original_ll": -0.9559105038642883, "sampled_ll": -0.5093911290168762, "all_perturbed_sampled_ll": [-1.689736247062683], "all_perturbed_original_ll": [-1.9615219831466675], "perturbed_sampled_ll": -1.689736247062683, "perturbed_original_ll": -1.9615219831466675, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString str = sc.nextLine();\n\t\t\tstr = str.replaceAll(\"Hoshino\", \"Hoshina\");\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n}\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            String result = line.replace(\"Hoshino\", \"Hoshina\");\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[]  new Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); for (int i = 0; i < n; i++) {  result = line.replace(\"Hoshino\", \"Hoshina\"); System.out.println(result); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main {  Scanner(System.in); int n = Integer.parseInt(sc.nextLine()); for (int i = 0; i < n; i++) { String str = sc.nextLine(); str = str.replaceAll(\"Hoshino\", \"Hoshina\"); System.out.println(str); } } }"], "original_ll": -0.9755993485450745, "sampled_ll": -0.8541982173919678, "all_perturbed_sampled_ll": [-1.9736407995224], "all_perturbed_original_ll": [-1.6616711616516113], "perturbed_sampled_ll": -1.9736407995224, "perturbed_original_ll": -1.6616711616516113, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\ndef main():\n  n = int(sys.stdin.readline())\n  for _ in range(n):\n    line = sys.stdin.readline()\n    print(line.strip().replace(\"Hoshino\", \"Hoshina\"))\n\nif __name__ == \"__main__\":\n  main()", "sampled": "n = int(input())\nfor _ in range(n):\n    line = input()\n    print(line.replace(\"Hoshino\", \"Hoshina\"))\n", "perturbed_sampled": ["n = int(input()) for _ in range(n): line = input() print(line.replace(\"Hoshino\", \"Hoshina\"))"], "perturbed_original": ["import sys def main(): n  range(n): line = sys.stdin.readline() print(line.strip().replace(\"Hoshino\", \"Hoshina\")) if __name__ == \"__main__\": main()"], "original_ll": -1.3790850639343262, "sampled_ll": -2.2178618907928467, "all_perturbed_sampled_ll": [-2.781747341156006], "all_perturbed_original_ll": [-2.720630168914795], "perturbed_sampled_ll": -2.781747341156006, "perturbed_original_ll": -2.720630168914795, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  int a[11][11]={};\n  int i,j,n,s,t;\n\n  for(;;){\n    scanf(\"%d\",&n);\n    if(!n)\n      break;\n    t=0;\n\n    for(i=0;i<n;i++){\n      s=0;\n      for(j=0;j<n;j++){\n\tscanf(\"%d\",&a[i][j]);\n\ts+=a[i][j];\n      }\n      a[i][n]=s;\n      t+=s;\n    }\n    a[n][n]=t;\n    for(j=0;j<n;j++){\n      s=0;\n      for(i=0;i<n;i++){\n\ts+=a[i][j];\n      }\n      a[n][j]=s;\n    }\n    for(i=0;i<=n;i++){\n      for(j=0;j<=n;j++){\n\tprintf(\"%5d\",a[i][j]);\n      }\n      puts(\"\");\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int table[n][n];\n        int rowSum[n];\n        int colSum[n];\n        int totalSum = 0;\n        \n        // Read input\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                scanf(\"%d\", &table[i][j]);\n            }\n        }\n        \n        // Calculate row sums\n        for(int i = 0; i < n; i++) {\n            rowSum[i] = 0;\n            for(int j = 0; j < n; j++) {\n                rowSum[i] += table[i][j];\n            }\n        }\n        \n        // Calculate column sums\n        for(int j = 0; j < n; j++) {\n            colSum[j] = 0;\n            for(int i = 0; i < n; i++) {\n                colSum[j] += table[i][j];\n            }\n        }\n        \n        // Calculate total sum\n        for(int i = 0; i < n; i++) {\n            totalSum += rowSum[i];\n        }\n        \n        // Print table with row sums\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                printf(\"%5d\", table[i][j]);\n            }\n            printf(\"%5d\\n\", rowSum[i]);\n        }\n        \n        // Print column sums and total sum\n        for(int j = 0; j < n; j++) {\n            printf(\"%5d\", colSum[j]);\n        }\n        printf(\"%5d\\n\", totalSum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  while(1) { scanf(\"%d\",  int table[n][n]; int rowSum[n]; int colSum[n]; int totalSum = 0; // Read input for(int i = 0; i <  = 0; j <   sums for(int i = 0; i < n; i++) { rowSum[i] = 0; for(int j = 0; j < n; j++) { rowSum[i] += table[i][j];  sums for(int j = 0; j < n; j++) { colSum[j] = 0; for(int i = 0; i  += table[i][j]; } } // Calculate total sum for(int i = 0; i < n; i++) { totalSum += rowSum[i]; } // Print table with row  i < n; i++) { for(int j = 0; j  table[i][j]); } printf(\"%5d\\n\", rowSum[i]); }  total sum for(int j = 0; j < n; j++) { printf(\"%5d\", colSum[j]); } printf(\"%5d\\n\", totalSum); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int a[11][11]={}; int i,j,n,s,t;  for(i=0;i<n;i++){ s=0; for(j=0;j<n;j++){ scanf(\"%d\",&a[i][j]); s+=a[i][j]; } a[i][n]=s; t+=s; } a[n][n]=t; for(j=0;j<n;j++){ s=0; for(i=0;i<n;i++){  for(j=0;j<=n;j++){ printf(\"%5d\",a[i][j]); } puts(\"\"); } } return 0; }"], "original_ll": -0.7122858762741089, "sampled_ll": -0.26005569100379944, "all_perturbed_sampled_ll": [-1.1229867935180664], "all_perturbed_original_ll": [-1.1892271041870117], "perturbed_sampled_ll": -1.1229867935180664, "perturbed_original_ll": -1.1892271041870117, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n    public static void main(String args[]){\n        Scanner in = new Scanner(System.in);\n        while(true){\n            int n = in.nextInt();\n            if(n == 0) return ;\n            int mat[][] = new int[n+1][n+1];\n            for(int i=0; i<n; i++){\n                int sumr = 0;\n                for(int j=0; j<n; j++){\n                    mat[i][j] = in.nextInt();\n                    sumr += mat[i][j];\n                }\n                mat[i][n] = sumr;\n            }\n            for(int j=0; j<=n; j++){\n                int sumc = 0;\n                for(int i=0; i<n; i++){\n                    sumc += mat[i][j];\n                }\n                mat[n][j] = sumc;\n            }\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    System.out.printf(\"%5d\",mat[i][j]);\n                }\n                System.out.println();\n            }\n        }\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[][] table = new int[n][n];\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    table[i][j] = sc.nextInt();\n                }\n            }\n            \n            int[] rowSums = new int[n];\n            int[] colSums = new int[n];\n            \n            for (int i = 0; i < n; i++) {\n                int rowSum = 0;\n                for (int j = 0; j < n; j++) {\n                    rowSum += table[i][j];\n                }\n                rowSums[i] = rowSum;\n            }\n            \n            for (int j = 0; j < n; j++) {\n                int colSum = 0;\n                for (int i = 0; i < n; i++) {\n                    colSum += table[i][j];\n                }\n                colSums[j] = colSum;\n            }\n            \n            int totalSum = 0;\n            for (int i = 0; i < n; i++) {\n                totalSum += rowSums[i];\n            }\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    System.out.printf(\"%5d\", table[i][j]);\n                }\n                System.out.printf(\"%5d\\n\", rowSums[i]);\n            }\n            \n            for (int j = 0; j < n; j++) {\n                System.out.printf(\"%5d\", colSums[j]);\n            }\n            System.out.printf(\"%5d\\n\", totalSum);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  = sc.nextInt(); if (n == 0) break; int[][] table = new int[n][n]; for (int i = 0; i < n; i++) { for (int   sc.nextInt(); } } int[] rowSums = new int[n]; int[] colSums = new int[n]; for (int   j = 0; j < n; j++) { rowSum += table[i][j]; } rowSums[i] =  = 0; j < n; j++) { int colSum = 0; for (int i = 0; i < n; i++) { colSum += table[i][j]; } colSums[j] = colSum; } int totalSum = 0; for (int i = 0; i  += rowSums[i]; } for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { System.out.printf(\"%5d\", table[i][j]); } System.out.printf(\"%5d\\n\", rowSums[i]); }  { System.out.printf(\"%5d\", colSums[j]); } System.out.printf(\"%5d\\n\", totalSum); } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main{ = 258<extra_id_1>public static<extra_id_2>( Main<extra_id_3>; }<extra_id_4>}<extra_id_5>void<extra_id_6>Console.WriteLine();<extra_id_7>( \" \" ) ;<extra_id_8>; Int32 array [ ]<extra_id_9>] | int<extra_id_10>int [<extra_id_11>] ] { Int32<extra_id_12>int d ;<extra_id_13>++ ) {<extra_id_14>; double [ ]<extra_id_15>] - 1 )<extra_id_16>&&<extra_id_17>= 0 ; int i<extra_id_18>(<extra_id_19>; int<extra_id_20>;<extra_id_21>Console . WriteLine<extra_id_22>+<extra_id_23>; } public<extra_id_24>[ Scanner in = new Scanner(System.in); while(true){ int n =  ; int mat[][] = new  int sumr = 0; for(int j=0; j<n; j++){ mat[i][j] = in.nextInt(); sumr += mat[i][j]; } mat[i][n] = sumr; } for(int j=0; j<=n; j++){ int sumc = 0; for(int i=0; i<n; i++){  = sumc; } for(int  j<=n; j++){ System.out.printf(\"%5d\",mat[i][j]); } System.out.println(); } } } }"], "original_ll": -0.469662606716156, "sampled_ll": -0.2247239500284195, "all_perturbed_sampled_ll": [-0.8671513795852661], "all_perturbed_original_ll": [-1.874915599822998], "perturbed_sampled_ll": -0.8671513795852661, "perturbed_original_ll": -1.874915599822998, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import functools\n\nn = input()\nwhile(n):\n    list = []\n    bottom_record = [0]*(n+1)\n\n    for i in range(0, n):\n        l = map(int, raw_input().split())\n        l.append(functools.reduce(lambda x, y: x + y, l))\n        bottom_record = [x + y for(x,y) in zip(bottom_record, l)]\n        print(' '.join(map(str, l))) \n    print(' '.join(map(str, bottom_record)))\n    n = input()", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    table = []\n    for i in range(n):\n        row = list(map(int, input().split()))\n        table.append(row)\n    \n    # Calculate row sums\n    row_sums = []\n    for row in table:\n        row_sums.append(sum(row))\n    \n    # Calculate column sums\n    col_sums = []\n    for j in range(n):\n        col_sum = sum(table[i][j] for i in range(n))\n        col_sums.append(col_sum)\n    \n    # Calculate total sum\n    total_sum = sum(row_sums)\n    \n    # Print the table with sums\n    for i in range(n):\n        for j in range(n):\n            print(f\"{table[i][j]:5d}\", end=\"\")\n        print(f\"{row_sums[i]:5d}\")\n    \n    # Print column sums row\n    for col_sum in col_sums:\n        print(f\"{col_sum:5d}\", end=\"\")\n    print(f\"{total_sum:5d}\")\n", "perturbed_sampled": ["while True: n  [] for i in range(n): row = list(map(int, input().split())) table.append(row) # Calculate  row_sums.append(sum(row)) # Calculate column sums col_sums =  col_sum = sum(table[i][j] for i in range(n)) col_sums.append(col_sum) # Calculate total sum total_sum = sum(row_sums) # Print the table with sums for i in range(n): for j in range(n): print(f\"{table[i][j]:5d}\", end=\"\") print(f\"{row_sums[i]:5d}\") # Print column sums row for col_sum in col_sums: print(f\"{col_sum:5d}\", end=\"\") print(f\"{total_sum:5d}\")"], "perturbed_original": ["import functools  = [] bottom_record = [0]*(n+1) for i in range(0, n):  x, y: x + y, l)) bottom_record = [x + y for(x,y) in zip(bottom_record, l)] print(' '.join(map(str, l))) print(' '.join(map(str, bottom_record))) n = input()"], "original_ll": -1.5767993927001953, "sampled_ll": -0.45776593685150146, "all_perturbed_sampled_ll": [-1.3106290102005005], "all_perturbed_original_ll": [-2.7631747722625732], "perturbed_sampled_ll": -1.3106290102005005, "perturbed_original_ll": -2.7631747722625732, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tint n;\n\tchar event[8];\n\tint out = 0;\n\tint base[3] = {0};\n\tint i;\n\tint score;\n\t\n\tscanf(\"%d\", &n);\n\t\t\t \n\twhile (n != 0){\n\t\tscore = 0;\n\t\tbase[0] = 0;\n\t\tbase[1] = 0;\n\t\tbase[2] = 0;\n\t\tout = 0;\n\t\twhile (out < 3){\n\t\t\tscanf(\"%s\", event);\n\t\t\tif (strcmp(event, \"HIT\") == 0){\n\t\t\t\tbase[0]++;\n\t\t\t\tfor (i = 0; i < 3; i++){\n\t\t\t\t\tif (base[i] > 1){\n\t\t\t\t\t\tif (i < 2){\n\t\t\t\t\t\t\tbase[i + 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tscore++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbase[i]--;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strcmp(event, \"HOMERUN\") == 0){\n\t\t\t\tfor (i = 0; i < 3; i++){\n\t\t\t\t\tif (base[i] == 1){\n\t\t\t\t\t\tscore++;\n\t\t\t\t\t\tbase[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tscore++;\n\t\t\t}\n\t\t\telse if (strcmp(event, \"OUT\") == 0){\n\t\t\t\tout++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", score);\n\t\tn--;\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int base[4] = {0}; // base[1], base[2], base[3] for first, second, third\n        int score = 0;\n        int outs = 0;\n        char event[10];\n        \n        while (outs < 3 && scanf(\"%s\", event) == 1) {\n            if (strcmp(event, \"HIT\") == 0) {\n                if (base[3]) {\n                    score++;\n                    base[3] = 0;\n                }\n                if (base[2]) {\n                    base[3] = 1;\n                    base[2] = 0;\n                }\n                if (base[1]) {\n                    base[2] = 1;\n                    base[1] = 0;\n                }\n                base[1] = 1;\n            } else if (strcmp(event, \"HOMERUN\") == 0) {\n                score++; // batter scores\n                if (base[1]) {\n                    score++;\n                    base[1] = 0;\n                }\n                if (base[2]) {\n                    score++;\n                    base[2] = 0;\n                }\n                if (base[3]) {\n                    score++;\n                    base[3] = 0;\n                }\n            } else if (strcmp(event, \"OUT\") == 0) {\n                outs++;\n            }\n        }\n        \n        printf(\"%d\\n\", score);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  int n; scanf(\"%d\", &n);   base[3] for first, second, third  outs = 0; char event[10]; while (outs < 3 && scanf(\"%s\", event) == 1) { if (strcmp(event, \"HIT\") == 0) { if (base[3]) { score++; base[3] = 0; } if (base[2]) { base[3] = 1; base[2] =  base[2] = 1; base[1] = 0; } base[1] = 1; } else if (strcmp(event, \"HOMERUN\") == 0) { score++;  { score++; base[1] = 0; }  = 0; } if (base[3]) { score++; base[3] =  (strcmp(event, \"OUT\") == 0) { outs++; } } printf(\"%d\\n\", score); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(void) { int n; char event[8]; int out = 0;  i; int score; scanf(\"%d\", &n); while (n != 0){ score = 0; base[0] = 0; base[1] = 0; base[2] = 0; out = 0; while (out < 3){ scanf(\"%s\", event); if (strcmp(event, \"HIT\") ==  0; i  < 2){ base[i + 1]++; } else { score++; } base[i]--; } } } else  for (i = 0; i <  0; } } score++; } else if (strcmp(event, \"OUT\") == 0){ out++; } } printf(\"%d\\n\", score); n--; } return 0; }"], "original_ll": -0.755157470703125, "sampled_ll": -0.5978079438209534, "all_perturbed_sampled_ll": [-1.4708818197250366], "all_perturbed_original_ll": [-1.6905637979507446], "perturbed_sampled_ll": -1.4708818197250366, "perturbed_original_ll": -1.6905637979507446, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint field = 0;\n\t\tlong scoreCount = 0;\n\t\tint outCount = 0;\n\t\tint finishedGame = 0;\n\t\ttry {\n\t\t\tint gameNumber = br.read();\n\t\t\twhile (finishedGame < gameNumber) {\n\t\t\t\tswitch (br.readLine()) {\n\t\t\t\tcase \"HIT\":\n\t\t\t\t\tif(field==3) {\n\t\t\t\t\t\tscoreCount++;\n\t\t\t\t\t}\n\t\t\t\t\tfield++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"OUT\":\n\t\t\t\t\toutCount++;\n\t\t\t\t\tif (outCount == 3) {\n\t\t\t\t\t\tSystem.out.println(scoreCount);\n\t\t\t\t\t\tscoreCount = 0;\n\t\t\t\t\t\toutCount = 0;\n\t\t\t\t\t\tfield = 0;\n\t\t\t\t\t\tfinishedGame++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"HOMERUN\":\n\t\t\t\t\tscoreCount += 1 + field;\n\t\t\t\t\tfield = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            int score = 0;\n            int outs = 0;\n            boolean[] bases = new boolean[3]; // 0: first, 1: second, 2: third\n            \n            while (outs < 3) {\n                String event = sc.nextLine().trim();\n                \n                if (event.equals(\"HIT\")) {\n                    if (bases[2]) {\n                        score++;\n                        bases[2] = false;\n                    }\n                    if (bases[1]) {\n                        bases[2] = true;\n                        bases[1] = false;\n                    }\n                    if (bases[0]) {\n                        bases[1] = true;\n                    }\n                    bases[0] = true;\n                } else if (event.equals(\"HOMERUN\")) {\n                    score++; // for the batter\n                    for (int j = 0; j < 3; j++) {\n                        if (bases[j]) {\n                            score++;\n                            bases[j] = false;\n                        }\n                    }\n                } else if (event.equals(\"OUT\")) {\n                    outs++;\n                }\n            }\n            \n            System.out.println(score);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt();  0; i < n; i++) { int score = 0; int outs   1: second, 2: third while (outs < 3)  if (event.equals(\"HIT\")) { if (bases[2]) { score++; bases[2] = false;  = true; bases[1] = false; } if (bases[0]) { bases[1] = true; } bases[0] = true; } else if (event.equals(\"HOMERUN\"))  batter for (int j  j++) { if (bases[j]) { score++; bases[j] = false; } } } else if (event.equals(\"OUT\")) { outs++; } } System.out.println(score); } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import  public class Main { public static void main(String[] args) { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int field = 0; long scoreCount = 0; int outCount =   br.read(); while (finishedGame < gameNumber) { switch (br.readLine()) { case \"HIT\": if(field==3) { scoreCount++; } field++; break;  == 3) { System.out.println(scoreCount); scoreCount =  break; case \"HOMERUN\": scoreCount += 1 + field; field = 0; break; } } br.close(); } catch (IOException e) { e.printStackTrace(); } } }"], "original_ll": -0.7825534343719482, "sampled_ll": -0.5429587364196777, "all_perturbed_sampled_ll": [-1.6964068412780762], "all_perturbed_original_ll": [-1.918198823928833], "perturbed_sampled_ll": -1.6964068412780762, "perturbed_original_ll": -1.918198823928833, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def hit(bases):\n    got_point = False\n    if bases[2]:\n        got_point = True\n    bases[0], bases[1], bases[2] = 1, bases[0], bases[1]\n    if got_point:\n        return 1\n    else:\n        return 0\n\ndef homerun(bases):\n    num_runner = bases.count(1)\n    bases[0], bases[1], bases[2] = 0, 0, 0\n    return num_runner + 1\n\nfor i in range(int(raw_input())):\n    bases = [0, 0, 0]\n    out_count = 0\n    points = 0\n    while out_count != 3:\n        event = raw_input()\n        if event == \"HIT\":\n            points += hit(bases)\n        elif event == \"HOMERUN\":\n            points += homerun(bases)\n        else:\n            out_count += 1\n    print points", "sampled": "n = int(input())\nfor _ in range(n):\n    score = 0\n    bases = [False, False, False]  # 1st, 2nd, 3rd base\n    outs = 0\n    \n    while outs < 3:\n        event = input().strip()\n        \n        if event == \"HIT\":\n            # Score runners from 3rd base\n            if bases[2]:\n                score += 1\n            # Advance runners\n            bases[2] = bases[1]\n            bases[1] = bases[0]\n            bases[0] = True\n            \n        elif event == \"HOMERUN\":\n            # Count runners on base\n            runners_on_base = sum(bases)\n            # Score all runners plus batter\n            score += runners_on_base + 1\n            # Clear all bases\n            bases = [False, False, False]\n            \n        elif event == \"OUT\":\n            outs += 1\n    \n    print(score)\n", "perturbed_sampled": ["n = int(input()) for _ in range(n):  [False, False, False] # 1st, 2nd, 3rd base outs = 0 while outs <  event == \"HIT\": # Score runners  score += 1 # Advance runners bases[2] = bases[1] bases[1] = bases[0]  == \"HOMERUN\": # Count runners on base runners_on_base = sum(bases) # Score all runners plus batter  # Clear all bases bases = [False, False, False] elif event == \"OUT\": outs += 1 print(score)"], "perturbed_original": ["def hit(bases): got_point = False if bases[2]:  bases[2] = 1, bases[0], bases[1] if got_point: return 1 else: return 0 def homerun(bases): num_runner = bases.count(1) bases[0],  1 for i  0, 0] out_count = 0 points = 0 while out_count != 3: event = raw_input() if event == \"HIT\": points += hit(bases) elif event == \"HOMERUN\": points += homerun(bases) else: out_count += 1 print points"], "original_ll": -0.8319832682609558, "sampled_ll": -1.0202232599258423, "all_perturbed_sampled_ll": [-2.284881591796875], "all_perturbed_original_ll": [-1.9599595069885254], "perturbed_sampled_ll": -2.284881591796875, "perturbed_original_ll": -1.9599595069885254, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "C[51],c;\n#define min(a,b) ((a)<(b)?(a):(b))\nmain(i){\n\tC[1]=380;\n\tfor(i=2;i<=50;i++){\n\t\tc=9999;\n\t\tif(i>=2)c=min(c,C[i-2]+380);\n\t\tif(i>=3)c=min(c,C[i-3]+550);\n\t\tif(i>=5)c=min(c,C[i-5]+850);\n\t\tif(i>=10)c=min(c,C[i-10]+1520);\n\t\tif(i>=12)c=min(c,C[i-12]+1870);\n\t\tif(i>=15)c=min(c,C[i-15]+2244);\n\t\tC[i]=c;\n\t}\n\tfor(;~scanf(\"%d\",&i);)\n\t\ti&&printf(\"%d\\n\",C[(i+99)/100]);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a;\n    \n    while(scanf(\"%d\", &a) == 1 && a != 0) {\n        int minCost = -1;\n        \n        // Shop A: 200g bags, 380 yen, per 5 bags 20% discount\n        if(a % 200 == 0) {\n            int bags = a / 200;\n            int discountedBags = (bags / 5) * 5;\n            int normalBags = bags % 5;\n            int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380;\n            if(minCost == -1 || cost < minCost) {\n                minCost = cost;\n            }\n        }\n        \n        // Shop B: 300g bags, 550 yen, per 4 bags 15% discount\n        if(a % 300 == 0) {\n            int bags = a / 300;\n            int discountedBags = (bags / 4) * 4;\n            int normalBags = bags % 4;\n            int cost = (int)(discountedBags * 550 * 0.85) + normalBags * 550;\n            if(minCost == -1 || cost < minCost) {\n                minCost = cost;\n            }\n        }\n        \n        // Shop C: 500g bags, 850 yen, per 3 bags 12% discount\n        if(a % 500 == 0) {\n            int bags = a / 500;\n            int discountedBags = (bags / 3) * 3;\n            int normalBags = bags % 3;\n            int cost = (int)(discountedBags * 850 * 0.88) + normalBags * 850;\n            if(minCost == -1 || cost < minCost) {\n                minCost = cost;\n            }\n        }\n        \n        printf(\"%d\\n\", minCost);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int a; while(scanf(\"%d\", &a) == 1 && a != 0) { int minCost = -1; // Shop A:  5  200 == 0) { int bags = a / 200; int discountedBags = (bags / 5) * 5; int  * 380 * 0.8) + normalBags *  cost < minCost) { minCost = cost; } } // Shop B:  4 bags 15% discount  { int bags = a / 300; int discountedBags = (bags / 4)  bags  (int)(discountedBags * 550 * 0.85) + normalBags * 550; if(minCost == -1 || cost < minCost) { minCost = cost; } } // Shop C: 500g bags, 850 yen, per 3 bags 12% discount if(a % 500 == 0) { int bags = a / 500; int discountedBags = (bags / 3) * 3; int normalBags = bags % 3; int cost =  if(minCost == -1 || cost < minCost) { minCost = cost; } }  }"], "perturbed_original": ["C[51],c; #define min(a,b) ((a)<(b)?(a):(b)) main(i){ C[1]=380; for(i=2;i<=50;i++){  if(i>=12)c=min(c,C[i-12]+1870); if(i>=15)c=min(c,C[i-15]+2244); C[i]=c; } for(;~scanf(\"%d\",&i);) i&&printf(\"%d\\n\",C[(i+99)/100]); }"], "original_ll": -1.167251706123352, "sampled_ll": -0.45538875460624695, "all_perturbed_sampled_ll": [-1.6805696487426758], "all_perturbed_original_ll": [-1.8894394636154175], "perturbed_sampled_ll": -1.6805696487426758, "perturbed_original_ll": -1.8894394636154175, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(true){ \n\t\t\tif(n == 0)break;\n\t\t\tSystem.out.println(min(n));\n\t\t\tn = sc.nextInt();\n\t\t}   \n\t}   \n\tstatic int min(int n){\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int c = n/500 ; c >= 0 ; c--){\n\t\t\tfor(int b = (n-c*500)/300 ; b >= 0 ; b--){\n\t\t\t\tif((n-c*500-b*300)%200 == 0){ \n\t\t\t\t\tint a = (n-c*500-b*300)/200;\n\t\t\t\t\tint cost = cost(a, b, c); \n\t\t\t\t\tif(cost < min){\n\t\t\t\t\t\tmin = cost;\n\t\t\t\t\t}   \n\t\t\t\t}   \n\t\t\t}   \n\t\t}   \n\t\treturn min;\n\t}   \n\tstatic int cost(int a, int b, int c){\n\t\treturn (a%5)*380+(a/5)*5*380*8/10+(b%4)*550+(b/4)*4*550*85/100+(c%3)*850+(c/3)*3*850*88/100;\n\t}   \n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int a = sc.nextInt();\n            if (a == 0) break;\n            \n            int minCost = Integer.MAX_VALUE;\n            \n            // Shop A: 200g per bag, 380 yen, 5 bags discount 20%\n            if (a % 200 == 0) {\n                int bags = a / 200;\n                int discountedBags = (bags / 5) * 5;\n                int normalBags = bags % 5;\n                int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380;\n                minCost = Math.min(minCost, cost);\n            }\n            \n            // Shop B: 300g per bag, 550 yen, 4 bags discount 15%\n            if (a % 300 == 0) {\n                int bags = a / 300;\n                int discountedBags = (bags / 4) * 4;\n                int normalBags = bags % 4;\n                int cost = (int)(discountedBags * 550 * 0.85) + normalBags * 550;\n                minCost = Math.min(minCost, cost);\n            }\n            \n            // Shop C: 500g per bag, 850 yen, 3 bags discount 12%\n            if (a % 500 == 0) {\n                int bags = a / 500;\n                int discountedBags = (bags / 3) * 3;\n                int normalBags = bags % 3;\n                int cost = (int)(discountedBags * 850 * 0.88) + normalBags * 850;\n                minCost = Math.min(minCost, cost);\n            }\n            \n            System.out.println(minCost);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int a = sc.nextInt(); if (a == 0) break; int  A: 200g per bag, 380 yen, 5 bags discount 20% if (a % 200 == 0) { int bags = a / 200; int  * 5; int normalBags = bags % 5; int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380; minCost = Math.min(minCost, cost);  per bag, 550 yen, 4 bags discount 15% if (a % 300 == 0) { int bags =  = (bags / 4) * 4; int normalBags = bags % 4; int  * 550; minCost  Shop C: 500g per bag, 850 yen, 3 bags discount 12% if (a % 500 == 0) { int bags  discountedBags = (bags  normalBags = bags % 3;  normalBags * 850;  System.out.println(minCost); } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int n =  System.out.println(min(n)); n = sc.nextInt(); } } static int min(int n){ int min = Integer.MAX_VALUE; for(int c = n/500 ; c >= 0 ; c--){ for(int b = (n-c*500)/300 ; b >= 0 ; b--){ if((n-c*500-b*300)%200 == 0){ int a = (n-c*500-b*300)/200; int cost  cost;  min; } static int cost(int a,  (a%5)*380+(a/5)*5*380*8/10+(b%4)*550+(b/4)*4*550*85/100+(c%3)*850+(c/3)*3*850*88/100; } }"], "original_ll": -0.8748154640197754, "sampled_ll": -0.4312281906604767, "all_perturbed_sampled_ll": [-1.5898593664169312], "all_perturbed_original_ll": [-1.4612972736358643], "perturbed_sampled_ll": -1.5898593664169312, "perturbed_original_ll": -1.4612972736358643, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a=[(2,380),(3,550),(5,850),(10,1520),(12,1870),(15,2244)]\ndp=[1<<20]*51\nfor i,j in a:\n    dp[i]=j\n    for k in range(51-i):\n        if dp[k]!=1<<20 and dp[k+i]>dp[k]+j:\n            dp[k+i]=dp[k]+j\nwhile 1:\n    n=int(input())\n    if n==0:break\n    print(dp[n//100])", "sampled": "def calculate_cost(amount, bag_size, unit_price, discount_unit, discount_rate):\n    if amount % bag_size != 0:\n        return float('inf')\n    \n    num_bags = amount // bag_size\n    discounted_bags = (num_bags // discount_unit) * discount_unit\n    regular_bags = num_bags % discount_unit\n    \n    discounted_cost = discounted_bags * unit_price * (1 - discount_rate)\n    regular_cost = regular_bags * unit_price\n    \n    return int(discounted_cost + regular_cost)\n\nwhile True:\n    a = int(input())\n    if a == 0:\n        break\n    \n    # Shop A: 200g, 380 yen, per 5 bags, 20% off\n    cost_a = calculate_cost(a, 200, 380, 5, 0.20)\n    \n    # Shop B: 300g, 550 yen, per 4 bags, 15% off\n    cost_b = calculate_cost(a, 300, 550, 4, 0.15)\n    \n    # Shop C: 500g, 850 yen, per 3 bags, 12% off\n    cost_c = calculate_cost(a, 500, 850, 3, 0.12)\n    \n    print(min(cost_a, cost_b, cost_c))\n", "perturbed_sampled": ["def  if amount % bag_size != 0: return float('inf') num_bags = amount // bag_size discounted_bags = (num_bags // discount_unit) * discount_unit regular_bags = num_bags % discount_unit discounted_cost = discounted_bags * unit_price * (1 - discount_rate) regular_cost = regular_bags * unit_price return int(discounted_cost  == 0: break # Shop  5 bags, 20% off cost_a  0.20) # Shop B: 300g, 550 yen, per 4 bags, 15% off cost_b = calculate_cost(a, 300, 550, 4, 0.15) # Shop C: 500g, 850  off cost_c = calculate_cost(a, 500, 850, 3, 0.12) print(min(cost_a, cost_b, cost_c))"], "perturbed_original": ["a=[(2,380),(3,550),(5,850),(10,1520),(12,1870),(15,2244)] dp=[1<<20]*51 for i,j  in range(51-i): if dp[k]!=1<<20 and dp[k+i]>dp[k]+j: dp[k+i]=dp[k]+j while 1: n=int(input()) if n==0:break print(dp[n//100])"], "original_ll": -1.3855406045913696, "sampled_ll": -0.7567736506462097, "all_perturbed_sampled_ll": [-1.9775512218475342], "all_perturbed_original_ll": [-1.9657306671142578], "perturbed_sampled_ll": -1.9775512218475342, "perturbed_original_ll": -1.9657306671142578, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  int i,n,t[3];\n  int data,kari,hakari;\n\n  while(1){\n    scanf(\"%d%d%d\",&t[0],&t[1],&t[2]);\n    if(t[0] == 0 || t[1] == 0 || t[2] == 0)\n      break;\n    scanf(\"%d\",&n);\n    if(t[0] >= t[2]){\n      t[0] = t[2];\n       t[2] = -1;\n      }\n    if(t[1] >= t[2]&&t[2] != -1)\n      t[1] = t[2];\n    hakari = t[0] * t[0] + t[1] *t[1];\n    for(i = 0; i < n; i++){\n      scanf(\"%d\",&data);\n      data = data * 2;\n      data = data * data;\n      if(hakari < data)\n\tprintf(\"OK\\n\");\n      else \n\tprintf(\"NA\\n\");\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int A, B, C;\n    \n    while(1) {\n        scanf(\"%d %d %d\", &A, &B, &C);\n        \n        if(A == 0 && B == 0 && C == 0) break;\n        \n        int n;\n        scanf(\"%d\", &n);\n        \n        // Calculate the minimum diagonal of any face\n        // The cheese can pass through a circular hole if the diagonal of the smallest rectangular face\n        // can fit through the circle\n        double diag1 = sqrt(A * A + B * B);\n        double diag2 = sqrt(B * B + C * C);\n        double diag3 = sqrt(A * A + C * C);\n        \n        double min_diag = diag1;\n        if(diag2 < min_diag) min_diag = diag2;\n        if(diag3 < min_diag) min_diag = diag3;\n        \n        for(int i = 0; i < n; i++) {\n            int R;\n            scanf(\"%d\", &R);\n            \n            // The cheese can pass if the diameter of the hole is greater than the minimum diagonal\n            if(2 * R > min_diag) {\n                printf(\"OK\\n\");\n            } else {\n                printf(\"NA\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" main() { int A, B, C; while(1) { scanf(\"%d %d   0 && C == 0) break; int n; scanf(\"%d\", &n); // Calculate the minimum diagonal of any face // The cheese can pass through a circular hole if the diagonal of the smallest rectangular face // can fit through the circle  A  diag2 = sqrt(B * B + C * C); double diag3 = sqrt(A * A +  min_diag) min_diag = diag2;  diag3; for(int i = 0; i <  scanf(\"%d\", &R); // The cheese can pass if the diameter of the hole is greater than the minimum diagonal if(2 * R > min_diag) { printf(\"OK\\n\"); } else { printf(\"NA\\n\"); } } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int i,n,t[3]; int data,kari,hakari; while(1){ scanf(\"%d%d%d\",&t[0],&t[1],&t[2]); if(t[0] == 0 || t[1] == 0 || t[2] == 0) break; scanf(\"%d\",&n); if(t[0] >= t[2]){ t[0] = t[2];  >= t[2]&&t[2] != -1) t[1] = t[2]; hakari = t[0] * t[0] + t[1] *t[1]; for(i =  scanf(\"%d\",&data);  data = data * data;  printf(\"NA\\n\"); } } return 0; }"], "original_ll": -1.146381139755249, "sampled_ll": -0.7895799279212952, "all_perturbed_sampled_ll": [-2.253844976425171], "all_perturbed_original_ll": [-1.731479525566101], "perturbed_sampled_ll": -2.253844976425171, "perturbed_original_ll": -1.731479525566101, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nimport java.util.Arrays;\n\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true)\n\t\t{\n\t\t\tint a[] = new int[3];\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\tif (a[0] == 0 && a[1] == 0 && a[2] == 0) break;\n\t\t\t\n\t\t\t//Arrays.sort(a);\n\t\t\tint minR = a[0] * a[0] + a[2] + a[2];\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tint r = sc.nextInt() * 2;\n\t\t\t\tif (minR < r * r) System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int A = sc.nextInt();\n            int B = sc.nextInt();\n            int C = sc.nextInt();\n            \n            if (A == 0 && B == 0 && C == 0) {\n                break;\n            }\n            \n            // Find the minimum diagonal among all three faces\n            // The cheese can pass through if oriented diagonally through a face\n            double diag1 = Math.sqrt(A * A + B * B);\n            double diag2 = Math.sqrt(B * B + C * C);\n            double diag3 = Math.sqrt(A * A + C * C);\n            \n            double minDiag = Math.min(diag1, Math.min(diag2, diag3));\n            \n            int n = sc.nextInt();\n            \n            for (int i = 0; i < n; i++) {\n                int R = sc.nextInt();\n                \n                if (2 * R > minDiag) {\n                    System.out.println(\"OK\");\n                } else {\n                    System.out.println(\"NA\");\n                }\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int A  sc.nextInt(); int C = sc.nextInt(); if (A ==  && C   // The cheese can pass through  face double diag1 = Math.sqrt(A * A + B * B); double diag2 = Math.sqrt(B * B + C * C); double diag3 = Math.sqrt(A * A + C * C); double minDiag = Math.min(diag1, Math.min(diag2, diag3)); int n = sc.nextInt(); for (int i = 0; i < n; i++) {  (2 * R > minDiag) {  } } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; import java.util.Arrays; class Main {  { Scanner sc = new  a[] = new int[3]; for (int i = 0; i < 3; i++) a[i] = sc.nextInt(); if (a[0] == 0 && a[1] == 0 && a[2] == 0) break;  * a[0] + a[2] +  for (int i = 0; i < n; i++) {  2; if (minR < r * r) System.out.println(\"OK\"); else System.out.println(\"NA\"); } } } }"], "original_ll": -0.793997585773468, "sampled_ll": -0.8123894333839417, "all_perturbed_sampled_ll": [-1.5058072805404663], "all_perturbed_original_ll": [-1.6160725355148315], "perturbed_sampled_ll": -1.5058072805404663, "perturbed_original_ll": -1.6160725355148315, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n a,b,_=sorted(map(int,input().split()))\n if a==0:break\n for _ in[0]*int(input()):print(\"OK\"if(int(input())*2)**2>a*a+b*b else\"NA\")\n", "sampled": "import math\n\nwhile True:\n    line = input().split()\n    A, B, C = int(line[0]), int(line[1]), int(line[2])\n    \n    if A == 0 and B == 0 and C == 0:\n        break\n    \n    # The smallest diagonal that can fit through a circle of radius R\n    # is when we orient the cheese optimally through the hole.\n    # The cheese can pass through if the smallest cross-sectional diagonal\n    # fits in the circle of radius R.\n    \n    # For a parallelepiped with dimensions A, B, C, the smallest\n    # cross-sectional diagonal occurs when we look at the rectangular\n    # faces. The diagonals of the three faces are:\n    # sqrt(A^2 + B^2), sqrt(B^2 + C^2), sqrt(A^2 + C^2)\n    \n    # The smallest of these is what we need to fit through the hole\n    # (divided by 2 for radius)\n    \n    sides = [A, B, C]\n    sides.sort()\n    \n    # The minimum diagonal is between the two smallest sides\n    min_diagonal = math.sqrt(sides[0]**2 + sides[1]**2)\n    min_radius_needed = min_diagonal / 2\n    \n    n = int(input())\n    \n    for _ in range(n):\n        R = int(input())\n        if R > min_radius_needed:\n            print(\"OK\")\n        else:\n            print(\"NA\")\n", "perturbed_sampled": ["import math while True: line =  int(line[0]), int(line[1]), int(line[2]) if A == 0 and B == 0 and C == 0: break # The smallest diagonal that  is when we orient the cheese optimally through the hole. # The cheese can pass through if the smallest cross-sectional diagonal  of  parallelepiped with dimensions A, B, C, the smallest # cross-sectional diagonal occurs when we look at the rectangular # faces. The diagonals  #  C^2), sqrt(A^2 + C^2) # The smallest of these is what we need to fit through the hole # (divided   # The minimum diagonal is between the two smallest sides min_diagonal = math.sqrt(sides[0]**2 + sides[1]**2) min_radius_needed = min_diagonal / 2 n = int(input()) for _ in range(n): R =  print(\"OK\") else: print(\"NA\")"], "perturbed_original": ["while 1: a,b,_=sorted(map(int,input().split())) if a==0:break for _ in[0]*int(input()):print(\"OK\"if(int(input())*2)**2>a*a+b*b else\"NA\")"], "original_ll": -2.487917423248291, "sampled_ll": -1.2673985958099365, "all_perturbed_sampled_ll": [-2.8744945526123047], "all_perturbed_original_ll": [-2.409452199935913], "perturbed_sampled_ll": -2.8744945526123047, "perturbed_original_ll": -2.409452199935913, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint expr(char **s);\n\nint number(char **s) {\n  int val = 0;\n  while ('0' <= **s && **s <= '9') {\n    val = val * 10 + **s - '0';\n    (*s)++;\n  }\n  return val;\n}\n\nint factor(char **s) {\n  if (**s == '(') {\n    (*s)++;\n    int val = expr(s);\n    (*s)++;\n    return val;\n  }\n  return number(s);\n}\n\nint term(char **s) {\n  int val = factor(s);\n  while (1) {\n    if (**s == '*') {\n      (*s)++;\n      val *= factor(s);\n    } else if (**s == '/') {\n      (*s)++;\n      val /= factor(s);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint expr(char **s) {\n  int val = term(s);\n  while (1) {\n    if (**s == '+') {\n      (*s)++;\n      val += term(s);\n    } else if (**s == '-') {\n      (*s)++;\n      val -= term(s);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  char s[101];\n  while (n--) {\n    scanf(\"%s\", s);\n    char *p = s;\n    printf(\"%d\\n\", expr(&p));\n  }\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar expr[105];\nint pos;\n\nlong long parse_expr();\nlong long parse_term();\nlong long parse_factor();\n\nlong long parse_number() {\n    long long num = 0;\n    int sign = 1;\n    \n    if (expr[pos] == '-') {\n        sign = -1;\n        pos++;\n    } else if (expr[pos] == '+') {\n        pos++;\n    }\n    \n    while (isdigit(expr[pos])) {\n        num = num * 10 + (expr[pos] - '0');\n        pos++;\n    }\n    \n    return sign * num;\n}\n\nlong long parse_factor() {\n    if (expr[pos] == '(') {\n        pos++; // skip '('\n        long long result = parse_expr();\n        pos++; // skip ')'\n        return result;\n    } else {\n        return parse_number();\n    }\n}\n\nlong long parse_term() {\n    long long result = parse_factor();\n    \n    while (expr[pos] == '*' || expr[pos] == '/') {\n        char op = expr[pos];\n        pos++;\n        long long right = parse_factor();\n        if (op == '*') {\n            result = result * right;\n        } else {\n            result = result / right;\n        }\n    }\n    \n    return result;\n}\n\nlong long parse_expr() {\n    long long result = parse_term();\n    \n    while (expr[pos] == '+' || expr[pos] == '-') {\n        char op = expr[pos];\n        pos++;\n        long long right = parse_term();\n        if (op == '+') {\n            result = result + right;\n        } else {\n            result = result - right;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    getchar();\n    \n    while (n--) {\n        fgets(expr, 105, stdin);\n        pos = 0;\n        long long result = parse_expr();\n        printf(\"%lld\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  expr[105]; int  long parse_term(); long long parse_factor(); long long parse_number() { long long num = 0; int sign = 1;  sign = -1; pos++; } else if (expr[pos] == '+') { pos++; } while (isdigit(expr[pos])) { num = num * 10 + (expr[pos] - '0'); pos++; } return sign  parse_factor() { if (expr[pos] ==  '(' long long result = parse_expr(); pos++; // skip ')' return result; } else { return parse_number(); } } long long parse_term() { long long result = parse_factor(); while (expr[pos] == '*' || expr[pos] == '/') {  long long right = parse_factor(); if (op == '*') { result = result *  = result / right; } }  parse_expr() { long long result = parse_term(); while (expr[pos] == '+' || expr[pos] == '-') {  long long right = parse_term(); if  } else { result = result - right; } } return result; } int main() { int n; scanf(\"%d\", &n);  105, stdin); pos = 0; long long  } return 0; }"], "perturbed_original": ["#include  number(char **s) { int val = 0;  **s  val * 10 + **s - '0'; (*s)++; } return val; }  (**s == '(') { (*s)++; int val = expr(s); (*s)++; return val; } return number(s); } int term(char **s) { int  { if (**s == '*') { (*s)++; val *= factor(s); } else if (**s == '/') { (*s)++; val /= factor(s); } else { break; } } return val; } int expr(char **s) { int val = term(s); while (1) { if  val += term(s); } else if (**s == '-')   } return val; } int main() { int n;  (n--) { scanf(\"%s\", s); char *p = s; printf(\"%d\\n\", expr(&p)); } }"], "original_ll": -0.36428573727607727, "sampled_ll": -0.29802146553993225, "all_perturbed_sampled_ll": [-1.5009450912475586], "all_perturbed_original_ll": [-1.3984023332595825], "perturbed_sampled_ll": -1.5009450912475586, "perturbed_original_ll": -1.3984023332595825, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic String str;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstr = sc.next();\n\t\t\tpos = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic int expression() {\n\t\tint ret = term();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '+') {\n\t\t\t\tpos++;\n\t\t\t\tret += term();\n\t\t\t} else if (str.charAt(pos) == '-') {\n\t\t\t\tpos++;\n\t\t\t\tret -= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int term() {\n\t\tint ret = factor();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '*') {\n\t\t\t\tpos++;\n\t\t\t\tret *= factor();\n\t\t\t} else if (str.charAt(pos) == '/') {\n\t\t\t\tpos++;\n\t\t\t\tret /= factor();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int factor() {\n\t\tif (str.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\tint temp = expression();\n\t\t\tpos++;\n\t\t\treturn temp;\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\n\tstatic int number() {\n\t\tint ret = 0;\n\t\twhile (Character.isDigit(str.charAt(pos))) {\n\t\t\tret *= 10;\n\t\t\tret += str.charAt(pos) - '0';\n\t\t\tpos++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static String expr;\n    static int pos;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            expr = sc.nextLine().trim();\n            pos = 0;\n            System.out.println(parseExpression());\n        }\n        sc.close();\n    }\n    \n    static long parseExpression() {\n        long result = parseTerm();\n        \n        while (pos < expr.length() && (expr.charAt(pos) == '+' || expr.charAt(pos) == '-')) {\n            char op = expr.charAt(pos);\n            pos++;\n            long term = parseTerm();\n            if (op == '+') {\n                result += term;\n            } else {\n                result -= term;\n            }\n        }\n        \n        return result;\n    }\n    \n    static long parseTerm() {\n        long result = parseFactor();\n        \n        while (pos < expr.length() && (expr.charAt(pos) == '*' || expr.charAt(pos) == '/')) {\n            char op = expr.charAt(pos);\n            pos++;\n            long factor = parseFactor();\n            if (op == '*') {\n                result *= factor;\n            } else {\n                result /= factor;\n            }\n        }\n        \n        return result;\n    }\n    \n    static long parseFactor() {\n        if (expr.charAt(pos) == '(') {\n            pos++;\n            long result = parseExpression();\n            pos++;\n            return result;\n        }\n        \n        boolean negative = false;\n        if (expr.charAt(pos) == '-') {\n            negative = true;\n            pos++;\n        } else if (expr.charAt(pos) == '+') {\n            pos++;\n        }\n        \n        long num = 0;\n        while (pos < expr.length() && Character.isDigit(expr.charAt(pos))) {\n            num = num * 10 + (expr.charAt(pos) - '0');\n            pos++;\n        }\n        \n        return negative ? -num : num;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  expr; static int pos; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); for (int  = sc.nextLine().trim(); pos =  static long parseExpression() { long result  expr.length() && (expr.charAt(pos) == '+' || expr.charAt(pos) == '-')) {  long term = parseTerm(); if (op == '+') { result  }  parseTerm() { long result = parseFactor(); while (pos < expr.length() && (expr.charAt(pos) == '*' || expr.charAt(pos) == '/')) { char  factor = parseFactor(); if (op == '*') { result *= factor; } else { result /= factor; } } return result; } static long parseFactor() { if (expr.charAt(pos) ==  = parseExpression(); pos++; return result; } boolean negative = false; if (expr.charAt(pos) == '-') { negative = true; pos++; } else if (expr.charAt(pos) == '+') { pos++; } long num = 0; while (pos < expr.length() && Character.isDigit(expr.charAt(pos))) { num =  - '0'); pos++; } return negative ? -num : num; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { static String  static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i < n; i++) { str = sc.next(); pos = 0;  ret = term(); while (str.charAt(pos) != '=') { if (str.charAt(pos) == '+') { pos++; ret += term();  '-') { pos++; ret -= term(); } else { break; } } return ret; } static int term() { int ret = factor(); while  (str.charAt(pos) == '*') { pos++; ret *= factor(); } else if (str.charAt(pos) == '/') { pos++; ret /= factor(); } else { break; } } return  { if (str.charAt(pos)  temp = expression();  { return number(); } } static int number() { int ret = 0; while  ret += str.charAt(pos) - '0';  }"], "original_ll": -0.3343924283981323, "sampled_ll": -0.2706734538078308, "all_perturbed_sampled_ll": [-1.4329235553741455], "all_perturbed_original_ll": [-1.539655089378357], "perturbed_sampled_ll": -1.4329235553741455, "perturbed_original_ll": -1.539655089378357, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    rpn = \"\"\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            r = b/a\n            if b < 0 and b % a != 0:\n                r += 1\n            St.append(r)\n        else:\n            St.append(i)\n\n    return St[0]\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n    print int(RPN_cul(L))", "sampled": "def evaluate(expr):\n    expr = expr.strip().rstrip('=')\n    \n    def parse_number(s, i):\n        j = i\n        if j < len(s) and s[j] in '+-':\n            j += 1\n        while j < len(s) and s[j].isdigit():\n            j += 1\n        return int(s[i:j]), j\n    \n    def parse_factor(s, i):\n        if s[i] == '(':\n            val, j = parse_expr(s, i + 1)\n            return val, j + 1\n        else:\n            return parse_number(s, i)\n    \n    def parse_term(s, i):\n        left, i = parse_factor(s, i)\n        while i < len(s) and s[i] in '*/':\n            op = s[i]\n            right, i = parse_factor(s, i + 1)\n            if op == '*':\n                left = left * right\n            else:\n                left = int(left / right)\n        return left, i\n    \n    def parse_expr(s, i):\n        left, i = parse_term(s, i)\n        while i < len(s) and s[i] in '+-' and (i == 0 or s[i-1] not in '(+*-/'):\n            op = s[i]\n            right, i = parse_term(s, i + 1)\n            if op == '+':\n                left = left + right\n            else:\n                left = left - right\n        return left, i\n    \n    result, _ = parse_expr(expr, 0)\n    return result\n\nn = int(input())\nfor _ in range(n):\n    expr = input()\n    print(evaluate(expr))\n", "perturbed_sampled": ["def evaluate(expr): expr = expr.strip().rstrip('=') def parse_number(s, i): j = i if j < len(s) and s[j] in '+-': j += 1 while j < len(s) and s[j].isdigit():  j def parse_factor(s, i): if s[i] == '(': val,  1) return val,  parse_number(s, i) def parse_term(s, i): left, i = parse_factor(s, i) while i < len(s) and s[i] in '*/': op  parse_factor(s, i + 1) if op == '*': left = left   i) while i < len(s) and s[i] in '+-' and (i == 0 or s[i-1] not in '(+*-/'): op =  i + 1) if op == '+': left = left  left - right return left, i result, _ = parse_expr(expr, 0) return result n = int(input()) for _ in range(n): expr = input() print(evaluate(expr))"], "perturbed_original": ["def String2List(s): L = [] flag   s[i].isdigit() and flag: t = \"\" j =  s[i+j] if i+j == l-1: break j  False elif not s[i].isdigit(): L.append(s[i]) flag = True return  = [], [] table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1} rpn = \"\" for i in L: if i.isdigit(): L2.append(i) elif i  == \")\":  S.pop() else: if len(S) != 0 and (table[S[-1]]  len(S) != 0: L2.append(S.pop()) return L2 def RPN_cul(L): St = [] for i in L: if i == '+': St.append(int(St.pop())  '-': St.append(-int(St.pop()) + int(St.pop())) elif i == '*': St.append(int(St.pop()) * int(St.pop())) elif i == '/':  float(St.pop()) r = b/a if b < 0 and b % a  St.append(r) else: St.append(i) return St[0] N = int(raw_input()) for i in range(N): s = raw_input() L = String2List(s[:-1]) L = RPN_list(L) print int(RPN_cul(L))"], "original_ll": -0.6815605759620667, "sampled_ll": -0.44928792119026184, "all_perturbed_sampled_ll": [-1.4671471118927002], "all_perturbed_original_ll": [-1.8950507640838623], "perturbed_sampled_ll": -1.4671471118927002, "perturbed_original_ll": -1.8950507640838623, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define DIGIT (pow(10, (strlen(num) - 1 -j)))\n\nint solved(char num[100], int i){\n  int s = 0, j;\n  for(j = 0;j < strlen(num);j++){\n    if(num[j] == 'X')\n      s += i * DIGIT;\n    else \n      s += (num[j] - '0') * DIGIT;\n  }\n  return s;\n}\n\nint main(){\n  int a, b, c, i, j;\n  char calc[100], *f, *s, *ans;\n  while(scanf(\"%s\", calc) != EOF){\n    f = strtok(calc, \"+\");\n    s = strtok(NULL, \"=\");\n    ans = strtok(NULL, \",\");\n    \n    for(i = 0;i < 10;i++)\n      if(solved(f, i) + solved(s, i) == solved(ans, i)){\n\tprintf(\"%d\\n\", i);\n\tbreak;\n      }\n    if(i > 9)\n      puts(\"NA\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint hasLeadingZero(char *str) {\n    if (strlen(str) > 1 && str[0] == '0') {\n        return 1;\n    }\n    return 0;\n}\n\nint checkEquation(char *left1, char *left2, char *right) {\n    if (hasLeadingZero(left1) || hasLeadingZero(left2) || hasLeadingZero(right)) {\n        return 0;\n    }\n    \n    long long num1 = atoll(left1);\n    long long num2 = atoll(left2);\n    long long sum = atoll(right);\n    \n    return (num1 + num2 == sum);\n}\n\nvoid replaceX(char *str, char digit, char *result) {\n    int i;\n    for (i = 0; str[i]; i++) {\n        if (str[i] == 'X') {\n            result[i] = digit;\n        } else {\n            result[i] = str[i];\n        }\n    }\n    result[i] = '\\0';\n}\n\nint main() {\n    char input[256];\n    \n    while (fgets(input, sizeof(input), stdin)) {\n        input[strcspn(input, \"\\n\")] = 0;\n        \n        char *plus = strchr(input, '+');\n        char *equal = strchr(input, '=');\n        \n        if (!plus || !equal) continue;\n        \n        char left1[128], left2[128], right[128];\n        \n        int len1 = plus - input;\n        int len2 = equal - plus - 1;\n        int len3 = strlen(equal + 1);\n        \n        strncpy(left1, input, len1);\n        left1[len1] = '\\0';\n        \n        strncpy(left2, plus + 1, len2);\n        left2[len2] = '\\0';\n        \n        strcpy(right, equal + 1);\n        \n        int found = -1;\n        int count = 0;\n        \n        for (int digit = 0; digit <= 9; digit++) {\n            char temp1[128], temp2[128], temp3[128];\n            char digitChar = '0' + digit;\n            \n            replaceX(left1, digitChar, temp1);\n            replaceX(left2, digitChar, temp2);\n            replaceX(right, digitChar, temp3);\n            \n            if (checkEquation(temp1, temp2, temp3)) {\n                found = digit;\n                count++;\n            }\n        }\n        \n        if (count == 1) {\n            printf(\"%d\\n\", found);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int hasLeadingZero(char *str) { if (strlen(str) > 1 && str[0] == '0') { return 1;  checkEquation(char *left1, char *left2, char  hasLeadingZero(left2) || hasLeadingZero(right)) { return 0; } long long num1 = atoll(left1); long  long sum = atoll(right); return (num1 +  replaceX(char *str, char digit, char *result) {  0; str[i]; i++) { if (str[i] == 'X') { result[i] = digit; } else { result[i] =  '\\0'; } int main() { char input[256]; while (fgets(input, sizeof(input), stdin)) { input[strcspn(input, \"\\n\")] = 0; char *plus = strchr(input, '+'); char *equal  || !equal)   input; int len2  1; int len3 = strlen(equal +  = '\\0'; strncpy(left2, plus + 1, len2);  + 1); int found = -1; int count = 0; for (int digit = 0; digit <= 9; digit++) { char temp1[128], temp2[128], temp3[128]; char digitChar = '0'  replaceX(left2, digitChar, temp2); replaceX(right, digitChar, temp3); if (checkEquation(temp1, temp2, temp3)) { found =  (count == 1) { printf(\"%d\\n\", found); } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include  #define DIGIT (pow(10,  solved(char num[100], int i){ int s = 0, j; for(j = 0;j < strlen(num);j++){ if(num[j]  += (num[j] - '0') * DIGIT; } return s; } int main(){ int a, b, c,  *s, *ans; while(scanf(\"%s\", calc) != EOF){ f = strtok(calc, \"+\"); s = strtok(NULL, \"=\"); ans = strtok(NULL, \",\"); for(i = 0;i < 10;i++) if(solved(f, i) + solved(s, i) == solved(ans, i)){ printf(\"%d\\n\", i); break;  } return 0; }"], "original_ll": -1.0497684478759766, "sampled_ll": -0.4702918529510498, "all_perturbed_sampled_ll": [-1.6149780750274658], "all_perturbed_original_ll": [-1.7791274785995483], "perturbed_sampled_ll": -1.6149780750274658, "perturbed_original_ll": -1.7791274785995483, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n    Scanner in = new Scanner(System.in);\n\n    void solve(){\n        String s;\n        while(in.hasNextLine()){\n            s = in.nextLine();\n            calc(s);\n        }\n    }\n    void calc(String str){\n        String a = str.substring(0, str.indexOf('+'));\n        String b = str.substring(str.indexOf('+') + 1, str.indexOf('='));\n        String c = str.substring(str.indexOf('=') + 1);\n        for(int i = 0; i < 10; i++){\n            String left = sum(a, b, i);\n            String right = c.replace(\"X\", String.valueOf(i));\n            if(left.equals(right)){\n                System.out.println(i);\n                return;\n            }\n        }\n        System.out.println(\"NA\");\n    }\n\n    String sum(String a, String b, int rep){\n        StringBuilder ans  = new StringBuilder();\n        a = new StringBuilder(a.replace(\"X\", String.valueOf(rep))).reverse().toString();\n        b = new StringBuilder(b.replace(\"X\", String.valueOf(rep))).reverse().toString();\n\n        int t = 0;\n        for(int i = 0; i < Math.max(a.length(), b.length()); i++){\n            int x = i < a.length() ? a.charAt(i) - '0' : 0;\n            int y = i < b.length() ? b.charAt(i) - '0' : 0;\n            ans.append(String.valueOf((x + y + t) % 10));\n            t = (x + y + t) / 10;\n        }\n\n        if(t != 0){\n            ans.append(String.valueOf(t));\n        }\n\n        return ans.reverse().toString();\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();    \n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String result = solve(line);\n            System.out.println(result);\n        }\n        sc.close();\n    }\n    \n    static String solve(String equation) {\n        String[] parts = equation.split(\"=\");\n        String leftSide = parts[0];\n        String rightSide = parts[1];\n        \n        String[] addends = leftSide.split(\"\\\\+\");\n        String num1Pattern = addends[0];\n        String num2Pattern = addends[1];\n        String sumPattern = rightSide;\n        \n        int validDigit = -1;\n        int validCount = 0;\n        \n        for (int x = 0; x <= 9; x++) {\n            String num1Str = num1Pattern.replace('X', (char)('0' + x));\n            String num2Str = num2Pattern.replace('X', (char)('0' + x));\n            String sumStr = sumPattern.replace('X', (char)('0' + x));\n            \n            // Check for leading zeros\n            if (num1Str.length() > 1 && num1Str.charAt(0) == '0') continue;\n            if (num2Str.length() > 1 && num2Str.charAt(0) == '0') continue;\n            if (sumStr.length() > 1 && sumStr.charAt(0) == '0') continue;\n            \n            try {\n                long num1 = Long.parseLong(num1Str);\n                long num2 = Long.parseLong(num2Str);\n                long sum = Long.parseLong(sumStr);\n                \n                if (num1 + num2 == sum) {\n                    validDigit = x;\n                    validCount++;\n                }\n            } catch (NumberFormatException e) {\n                // Skip invalid numbers\n            }\n        }\n        \n        if (validCount == 1) {\n            return String.valueOf(validDigit);\n        } else {\n            return \"NA\";\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String line =  result = solve(line); System.out.println(result); } sc.close(); } static String solve(String equation) {   = parts[1];  num1Pattern  rightSide; int validDigit = -1;  (int x =  { String num1Str = num1Pattern.replace('X', (char)('0' + x)); String num2Str = num2Pattern.replace('X', (char)('0' + x)); String sumStr = sumPattern.replace('X', (char)('0' + x)); // Check for leading zeros if (num1Str.length() > 1 && num1Str.charAt(0) == '0') continue; if  == '0') continue;  sumStr.charAt(0) == '0') continue; try { long num1 = Long.parseLong(num1Str); long num2 = Long.parseLong(num2Str); long sum = Long.parseLong(sumStr); if (num1 + num2 == sum) { validDigit = x; validCount++; } } catch (NumberFormatException e) { //  if (validCount == 1) { return String.valueOf(validDigit); } else { return \"NA\"; } } }"], "perturbed_original": ["import java.util.*; public class Main{ Scanner in = new Scanner(System.in); void solve(){ String s; while(in.hasNextLine()){ s = in.nextLine(); calc(s); } } void calc(String str){ String a = str.substring(0, str.indexOf('+')); String b = str.substring(str.indexOf('+') + 1, str.indexOf('=')); String c = str.substring(str.indexOf('=') + 1); for(int i =  String  String.valueOf(i)); if(left.equals(right)){ System.out.println(i); return; } } System.out.println(\"NA\"); } String sum(String a, String b, int rep){ StringBuilder ans = new StringBuilder(); a = new StringBuilder(a.replace(\"X\", String.valueOf(rep))).reverse().toString(); b = new  0; for(int i = 0; i  x  a.charAt(i) -  = i < b.length() ? b.charAt(i) - '0' : 0; ans.append(String.valueOf((x + y + t) %  y + t) / 10; } if(t != 0){ ans.append(String.valueOf(t)); } return ans.reverse().toString();  args){ new Main().solve(); } }"], "original_ll": -0.599596381187439, "sampled_ll": -0.4750162661075592, "all_perturbed_sampled_ll": [-1.3897554874420166], "all_perturbed_original_ll": [-1.642769455909729], "perturbed_sampled_ll": -1.3897554874420166, "perturbed_original_ll": -1.642769455909729, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        string = raw_input()\n    except EOFError:\n        break\n    for i in range(10):\n        translated = string.replace(\"X\",str(i))\n        left,right = translated.split(\"=\")\n        first,second = left.split(\"+\")\n        if i == 0 and any((first[0]==\"0\",second[0]==\"0\",right[0]==\"0\")):\n            continue\n        elif int(first) + int(second) == int(right):\n            print i\n            break\n    else:\n        print \"NA\"", "sampled": "import sys\n\ndef solve(equation):\n    parts = equation.split('=')\n    left_parts = parts[0].split('+')\n    num1 = left_parts[0]\n    num2 = left_parts[1]\n    result = parts[1]\n    \n    for digit in range(10):\n        digit_str = str(digit)\n        \n        # Replace X with the digit\n        n1 = num1.replace('X', digit_str)\n        n2 = num2.replace('X', digit_str)\n        res = result.replace('X', digit_str)\n        \n        # Check for leading zeros (except for single digit numbers)\n        if len(n1) > 1 and n1[0] == '0':\n            continue\n        if len(n2) > 1 and n2[0] == '0':\n            continue\n        if len(res) > 1 and res[0] == '0':\n            continue\n        \n        # Check if the equation holds\n        try:\n            if int(n1) + int(n2) == int(res):\n                return digit_str\n        except:\n            continue\n    \n    return \"NA\"\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        print(solve(line))\n", "perturbed_sampled": [" = equation.split('=') left_parts = parts[0].split('+')  left_parts[1] result = parts[1] for digit in range(10): digit_str = str(digit) # Replace X with the digit n1 = num1.replace('X', digit_str) n2  for leading zeros (except for single digit numbers) if len(n1) > 1 and n1[0] == '0': continue if len(n2) > 1 and n2[0] == '0': continue if len(res) >  continue # Check if the equation holds  == int(res): return digit_str except: continue return \"NA\" for line in sys.stdin: line = line.strip() if line: print(solve(line))"], "perturbed_original": ["while True: try: string = raw_input() except EOFError:  translated = string.replace(\"X\",str(i)) left,right = translated.split(\"=\") first,second = left.split(\"+\")  any((first[0]==\"0\",second[0]==\"0\",right[0]==\"0\")): continue elif int(first) + int(second) == int(right): print i break else: print \"NA\""], "original_ll": -1.2938416004180908, "sampled_ll": -0.6774694323539734, "all_perturbed_sampled_ll": [-2.073880195617676], "all_perturbed_original_ll": [-2.425286293029785], "perturbed_sampled_ll": -2.073880195617676, "perturbed_original_ll": -2.425286293029785, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,stk,x[3];\nchar tex[1000000],code[1000000];\nchar encode[64][6]={\n\"11010\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"11110\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"11100\",\n\"11101\",\n\"11011\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"11111\",\n\"\",\n\"00000\",\n\"00001\",\n\"00010\",\n\"00011\",\n\"00100\",\n\"00101\",\n\"00110\",\n\"00111\",\n\"01000\",\n\"01001\",\n\"01010\",\n\"01011\",\n\"01100\",\n\"01101\",\n\"01110\",\n\"01111\",\n\"10000\",\n\"10001\",\n\"10010\",\n\"10011\",\n\"10100\",\n\"10101\",\n\"10110\",\n\"10111\",\n\"11000\",\n\"11001\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\"}\n,decode[100000000];\n\nint main(){\n\tdecode[212]=' ';\n\tdecode[111111]='\\'';\n\tdecode[111122]=',';\n\tdecode[21121112]='-';\n\tdecode[121112]='.';\n\tdecode[111112]='?';\n\tdecode[211212]='A';\n\tdecode[21122121]='B';\n\tdecode[1212]='C';\n\tdecode[1112]='D';\n\tdecode[221]='E';\n\tdecode[12112]='F';\n\tdecode[21122122]='G';\n\tdecode[121111]='H';\n\tdecode[1222]='I';\n\tdecode[21122111]='J';\n\tdecode[1221]='K';\n\tdecode[11211]='L';\n\tdecode[21122112]='M';\n\tdecode[21122221]='N';\n\tdecode[11212]='O';\n\tdecode[222]='P';\n\tdecode[21122222]='Q';\n\tdecode[2111]='R';\n\tdecode[11221]='S';\n\tdecode[11222]='T';\n\tdecode[21122211]='U';\n\tdecode[21122212]='V';\n\tdecode[111121]='W';\n\tdecode[21121121]='X';\n\tdecode[21121122]='Y';\n\tdecode[21121111]='Z';\n\n\twhile(fgets(tex,900000,stdin)!=NULL){\n\t\tstrcpy(code,\"\");\n\t\tfor(i=0;i<strlen(tex);i++){\n\t\t\tstrcat(code,encode[tex[i]-' ']);\n\t\t}\n\t\tstk=0;\n\t\tfor(i=0;i<strlen(code);i++){\n\t\t\tstk=stk*10+code[i]-'0'+1;\n\t\t\tif(decode[stk]>0){\n\t\t\t\tprintf(\"%c\",decode[stk]);\n\t\t\t\tstk=0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%\\n\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* char_to_code[] = {\n    \"00000\", \"10000\", \"01000\", \"00100\", \"00010\", \"11000\", \"10100\", \"01100\",\n    \"00110\", \"10010\", \"01010\", \"11100\", \"10110\", \"01110\", \"11010\", \"11110\",\n    \"00001\", \"10001\", \"01001\", \"00101\", \"10101\", \"01101\", \"11001\", \"10011\",\n    \"01011\", \"11101\", \"10111\", \"01111\", \"11011\", \"11111\", \"00011\", \"00111\"\n};\n\nchar chars[] = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ'-.,?\";\n\nchar* code_to_char[] = {\n    \"0\", \"100\", \"10\", \"1\", \"1010\", \"10100\", \"101000\", \"101\",\n    \"110\", \"1100\", \"11\", \"10101\", \"101010\", \"10110\", \"101011\", \"101100\",\n    \"1011\", \"10111\", \"1000\", \"1001\", \"100100\", \"100101\", \"10010\", \"100110\",\n    \"100111\", \"10011\", \"101000\", \"101001\", \"101010\", \"101011\", \"11\", \"111\"\n};\n\nint main() {\n    char input[256];\n    \n    while (fgets(input, sizeof(input), stdin)) {\n        int len = strlen(input);\n        if (len > 0 && input[len-1] == '\\n') {\n            input[len-1] = '\\0';\n            len--;\n        }\n        \n        char binary[10000] = \"\";\n        \n        for (int i = 0; i < len; i++) {\n            char c = input[i];\n            int found = 0;\n            for (int j = 0; j < 32; j++) {\n                if (chars[j] == c) {\n                    strcat(binary, char_to_code[j]);\n                    found = 1;\n                    break;\n                }\n            }\n        }\n        \n        char result[1000] = \"\";\n        int pos = 0;\n        int binlen = strlen(binary);\n        \n        while (pos < binlen) {\n            int found = 0;\n            for (int trylen = 1; trylen <= binlen - pos && trylen <= 10; trylen++) {\n                char temp[20];\n                strncpy(temp, binary + pos, trylen);\n                temp[trylen] = '\\0';\n                \n                for (int j = 0; j < 32; j++) {\n                    if (strcmp(code_to_char[j], temp) == 0) {\n                        int resultlen = strlen(result);\n                        result[resultlen] = chars[j];\n                        result[resultlen + 1] = '\\0';\n                        pos += trylen;\n                        found = 1;\n                        break;\n                    }\n                }\n                if (found) break;\n            }\n            \n            if (!found) {\n                pos++;\n            }\n        }\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h>  \"10000\", \"01000\", \"00100\", \"00010\",  \"11010\", \"11110\",  \"11101\",  \"00111\" }; char chars[] = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ'-.,?\"; char* code_to_char[] = { \"0\", \"100\", \"10\", \"1\", \"1010\", \"10100\", \"101000\",  \"101010\", \"10110\", \"101011\", \"101100\", \"1011\", \"10111\", \"1000\",  \"100111\", \"10011\", \"101000\", \"101001\", \"101010\", \"101011\", \"11\", \"111\" }; int main() { char input[256]; while  len  0 && input[len-1] == '\\n') { input[len-1] = '\\0'; len--; } char binary[10000] = \"\"; for (int i = 0; i < len; i++) { char c = input[i]; int found = 0; for (int j = 0; j < 32; j++) { if (chars[j] == c)  1; break; } } }  pos = 0; int binlen = strlen(binary); while (pos < binlen) { int found = 0; for (int trylen = 1; trylen <= binlen - pos && trylen <= 10; trylen++) { char temp[20]; strncpy(temp,  = '\\0'; for (int j = 0; j < 32; j++) { if (strcmp(code_to_char[j], temp) == 0) { int resultlen = strlen(result); result[resultlen] = chars[j]; result[resultlen + 1] = '\\0'; pos += trylen; found = 1; break; } } if (found)  result); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int i,stk,x[3]; char tex[1000000],code[1000000]; char encode[64][6]={ \"11010\", \"\", \"\", \"\", \"\", \"\", \"\", \"11110\", \"\", \"\", \"\", \"\", \"11100\", \"11101\", \"11011\", \"\",  \"\", \"\", \"\", \"\", \"\", \"\", \"11111\", \"\", \"00000\", \"00001\", \"00010\", \"00011\", \"00100\", \"00101\",  \"01011\", \"01100\", \"01101\", \"01110\", \"01111\", \"10000\", \"10001\",  \"10111\", \"11000\", \"11001\", \"\", \"\", \"\", \"\", \"\"} ,decode[100000000];  decode[111122]=','; decode[21121112]='-'; decode[121112]='.'; decode[111112]='?'; decode[211212]='A'; decode[21122121]='B'; decode[1212]='C'; decode[1112]='D'; decode[221]='E'; decode[12112]='F'; decode[21122122]='G'; decode[121111]='H'; decode[1222]='I'; decode[21122111]='J'; decode[1221]='K'; decode[11211]='L'; decode[21122112]='M'; decode[21122221]='N';  decode[11222]='T'; decode[21122211]='U'; decode[21122212]='V'; decode[111121]='W'; decode[21121121]='X'; decode[21121122]='Y'; decode[21121111]='Z';  } stk=0; for(i=0;i<strlen(code);i++){ stk=stk*10+code[i]-'0'+1; if(decode[stk]>0){ printf(\"%c\",decode[stk]); stk=0; } } printf(\"%\\n\"); } return 0; }"], "original_ll": -0.7034753561019897, "sampled_ll": -0.5052796006202698, "all_perturbed_sampled_ll": [-1.0585368871688843], "all_perturbed_original_ll": [-0.9562092423439026], "perturbed_sampled_ll": -1.0585368871688843, "perturbed_original_ll": -0.9562092423439026, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\n\npublic class Main {\n\n\tstatic final HashMap<Character, String> c1 = new HashMap<Character, String>(32) {\n\t\t{\n\t\t\tput('A', \"00000\");\n\t\t\tput('B', \"00001\");\n\t\t\tput('C', \"00010\");\n\t\t\tput('D', \"00011\");\n\t\t\tput('E', \"00100\");\n\t\t\tput('F', \"00101\");\n\t\t\tput('G', \"00110\");\n\t\t\tput('H', \"00111\");\n\t\t\tput('I', \"01000\");\n\t\t\tput('J', \"01001\");\n\t\t\tput('K', \"01010\");\n\t\t\tput('L', \"01011\");\n\t\t\tput('M', \"01100\");\n\t\t\tput('N', \"01101\");\n\t\t\tput('O', \"01110\");\n\t\t\tput('P', \"01111\");\n\t\t\tput('Q', \"10000\");\n\t\t\tput('R', \"10001\");\n\t\t\tput('S', \"10010\");\n\t\t\tput('T', \"10011\");\n\t\t\tput('U', \"10100\");\n\t\t\tput('V', \"10101\");\n\t\t\tput('W', \"10110\");\n\t\t\tput('X', \"10111\");\n\t\t\tput('Y', \"11000\");\n\t\t\tput('Z', \"11001\");\n\t\t\tput(' ', \"11010\");\n\t\t\tput('.', \"11011\");\n\t\t\tput(',', \"11100\");\n\t\t\tput('-', \"11101\");\n\t\t\tput('\\'', \"11110\");\n\t\t\tput('?', \"11111\");\n\t\t}\n\t};\n\n\tstatic final HashMap<String, Character> c2 = new HashMap<String, Character>(32) {\n\t\t{\n\t\t\tput(\"101\", ' ');\n\t\t\tput(\"000000\", '\\'');\n\t\t\tput(\"000011\", ',');\n\t\t\tput(\"10010001\", '-');\n\t\t\tput(\"010001\", '.');\n\t\t\tput(\"000001\", '?');\n\t\t\tput(\"100101\", 'A');\n\t\t\tput(\"10011010\", 'B');\n\t\t\tput(\"0101\", 'C');\n\t\t\tput(\"0001\", 'D');\n\t\t\tput(\"110\", 'E');\n\t\t\tput(\"01001\", 'F');\n\t\t\tput(\"10011011\", 'G');\n\t\t\tput(\"010000\", 'H');\n\t\t\tput(\"0111\", 'I');\n\t\t\tput(\"10011000\", 'J');\n\t\t\tput(\"0110\", 'K');\n\t\t\tput(\"00100\", 'L');\n\t\t\tput(\"10011001\", 'M');\n\t\t\tput(\"10011110\", 'N');\n\t\t\tput(\"00101\", 'O');\n\t\t\tput(\"111\", 'P');\n\t\t\tput(\"10011111\", 'Q');\n\t\t\tput(\"1000\", 'R');\n\t\t\tput(\"00110\", 'S');\n\t\t\tput(\"00111\", 'T');\n\t\t\tput(\"10011100\", 'U');\n\t\t\tput(\"10011101\", 'V');\n\t\t\tput(\"000010\", 'W');\n\t\t\tput(\"10010010\", 'X');\n\t\t\tput(\"10010011\", 'Y');\n\t\t\tput(\"10010000\", 'Z');\n\t\t}\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tif (line.isEmpty()) {\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tStringBuilder sb1, sb2;\n\t\t\tsb1 = new StringBuilder();\n\t\t\tsb2 = new StringBuilder();\n\t\t\t//\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tsb1.append(c1.get(c));\n\t\t\t}\n\t\t\t//\n\t\t\tString line2 = sb1.toString();\n\t\t\tfor (int i = 0; ; ) {\n\t\t\t\tchar c = 0;\n\t\t\t\tfor (int j = 3; j < 9 && i + j < line2.length(); j++) {\n\t\t\t\t\tif (c2.containsKey(line2.substring(i, i + j))) {\n\t\t\t\t\t\tc = c2.get(line2.substring(i, i + j));\n\t\t\t\t\t\tsb2.append(c);\n\t\t\t\t\t\ti += j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (c == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sb2.toString());\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static Map<Character, String> charToCode = new HashMap<>();\n    static Map<String, Character> codeToChar = new HashMap<>();\n    \n    static {\n        // First table (char to code)\n        charToCode.put('A', \"00000\");\n        charToCode.put('B', \"0001\");\n        charToCode.put('C', \"0010\");\n        charToCode.put('D', \"0011\");\n        charToCode.put('E', \"110\");\n        charToCode.put('F', \"1000\");\n        charToCode.put('G', \"1001\");\n        charToCode.put('H', \"1010\");\n        charToCode.put('I', \"1011\");\n        charToCode.put('J', \"0100\");\n        charToCode.put('K', \"0101\");\n        charToCode.put('L', \"0110\");\n        charToCode.put('M', \"0111\");\n        charToCode.put('N', \"10000\");\n        charToCode.put('O', \"10001\");\n        charToCode.put('P', \"111\");\n        charToCode.put('Q', \"10010\");\n        charToCode.put('R', \"10011\");\n        charToCode.put('S', \"10100\");\n        charToCode.put('T', \"10101\");\n        charToCode.put('U', \"10110\");\n        charToCode.put('V', \"10111\");\n        charToCode.put('W', \"11000\");\n        charToCode.put('X', \"11001\");\n        charToCode.put('Y', \"11010\");\n        charToCode.put('Z', \"11011\");\n        charToCode.put(' ', \"11100\");\n        charToCode.put('.', \"11101\");\n        charToCode.put(',', \"11110\");\n        charToCode.put('-', \"11111\");\n        charToCode.put('\\'', \"01010\");\n        charToCode.put('?', \"01011\");\n        \n        // Second table (code to char)\n        codeToChar.put(\"00\", 'A');\n        codeToChar.put(\"0100\", 'B');\n        codeToChar.put(\"0101\", 'C');\n        codeToChar.put(\"0110\", 'D');\n        codeToChar.put(\"110\", 'E');\n        codeToChar.put(\"01110\", 'F');\n        codeToChar.put(\"01111\", 'G');\n        codeToChar.put(\"1000\", 'H');\n        codeToChar.put(\"1001\", 'I');\n        codeToChar.put(\"10100\", 'J');\n        codeToChar.put(\"10101\", 'K');\n        codeToChar.put(\"10110\", 'L');\n        codeToChar.put(\"10111\", 'M');\n        codeToChar.put(\"1011\", 'N');\n        codeToChar.put(\"01010\", 'O');\n        codeToChar.put(\"111\", 'P');\n        codeToChar.put(\"01011\", 'Q');\n        codeToChar.put(\"1100\", 'R');\n        codeToChar.put(\"1101\", 'S');\n        codeToChar.put(\"00111\", 'T');\n        codeToChar.put(\"1110\", 'U');\n        codeToChar.put(\"11110\", 'V');\n        codeToChar.put(\"11111\", 'W');\n        codeToChar.put(\"10010\", 'X');\n        codeToChar.put(\"10011\", 'Y');\n        codeToChar.put(\"01000\", 'Z');\n        codeToChar.put(\"01001\", ' ');\n        codeToChar.put(\"10000\", '.');\n        codeToChar.put(\"10001\", ',');\n        codeToChar.put(\"0010\", '-');\n        codeToChar.put(\"0011\", '\\'');\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            \n            // Step 1: Convert each character to code\n            StringBuilder binary = new StringBuilder();\n            for (char c : line.toCharArray()) {\n                if (charToCode.containsKey(c)) {\n                    binary.append(charToCode.get(c));\n                }\n            }\n            \n            // Step 2: Decode using second table\n            StringBuilder result = new StringBuilder();\n            int i = 0;\n            while (i < binary.length()) {\n                boolean found = false;\n                for (int len = 1; len <= 5 && i + len <= binary.length(); len++) {\n                    String sub = binary.substring(i, i + len);\n                    if (codeToChar.containsKey(sub)) {\n                        result.append(codeToChar.get(sub));\n                        i += len;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    i++;\n                }\n            }\n            \n            System.out.println(result.toString());\n        }\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static Map<Character, String> charToCode = new HashMap<>(); static Map<String, Character> codeToChar = new HashMap<>(); static  charToCode.put('D', \"0011\");  \"0101\"); charToCode.put('L', \"0110\"); charToCode.put('M', \"0111\"); charToCode.put('N', \"10000\"); charToCode.put('O', \"10001\"); charToCode.put('P', \"111\"); charToCode.put('Q', \"10010\"); charToCode.put('R', \"10011\"); charToCode.put('S', \"10100\"); charToCode.put('T', \"10101\"); charToCode.put('U', \"10110\"); charToCode.put('V', \"10111\"); charToCode.put('W', \"11000\"); charToCode.put('X', \"11001\"); charToCode.put('Y', \"11010\"); charToCode.put('Z', \"11011\");   \"01010\"); charToCode.put('?', \"01011\"); // Second table (code to char) codeToChar.put(\"00\",  codeToChar.put(\"0110\", 'D'); codeToChar.put(\"110\", 'E'); codeToChar.put(\"01110\",  codeToChar.put(\"1001\", 'I'); codeToChar.put(\"10100\", 'J'); codeToChar.put(\"10101\", 'K'); codeToChar.put(\"10110\", 'L'); codeToChar.put(\"10111\", 'M'); codeToChar.put(\"1011\", 'N'); codeToChar.put(\"01010\", 'O'); codeToChar.put(\"111\", 'P'); codeToChar.put(\"01011\", 'Q'); codeToChar.put(\"1100\", 'R'); codeToChar.put(\"1101\", 'S'); codeToChar.put(\"00111\", 'T'); codeToChar.put(\"1110\", 'U'); codeToChar.put(\"11110\", 'V'); codeToChar.put(\"11111\", 'W'); codeToChar.put(\"10010\", 'X'); codeToChar.put(\"10011\", 'Y'); codeToChar.put(\"01000\", 'Z'); codeToChar.put(\"01001\", ' '); codeToChar.put(\"10000\", '.'); codeToChar.put(\"10001\", ','); codeToChar.put(\"0010\", '-');  Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String line = sc.nextLine(); if (line.isEmpty()) break; // Step 1: Convert each character to code StringBuilder binary = new StringBuilder(); for (char c : line.toCharArray()) { if (charToCode.containsKey(c)) { binary.append(charToCode.get(c)); } } // Step 2: Decode using second table StringBuilder result = new StringBuilder(); int i = 0; while (i < binary.length())  && i + len <= binary.length(); len++) { String sub = binary.substring(i, i + len); if (codeToChar.containsKey(sub)) { result.append(codeToChar.get(sub)); i += len; found = true; break; } }  } System.out.println(result.toString()); } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import  Main { static final HashMap<Character, String> c1 = new HashMap<Character, String>(32) { { put('A',  put('D', \"00011\"); put('E', \"00100\"); put('F', \"00101\"); put('G', \"00110\"); put('H', \"00111\"); put('I', \"01000\"); put('J', \"01001\"); put('K', \"01010\"); put('L', \"01011\"); put('M', \"01100\"); put('N', \"01101\"); put('O', \"01110\"); put('P', \"01111\"); put('Q', \"10000\"); put('R', \"10001\"); put('S', \"10010\"); put('T',  put('W', \"10110\"); put('X', \"10111\"); put('Y', \"11000\"); put('Z', \"11001\"); put(' ', \"11010\"); put('.', \"11011\"); put(',', \"11100\"); put('-', \"11101\");  }; static final HashMap<String, Character> c2 = new HashMap<String,  '); put(\"000000\", '\\''); put(\"000011\", ','); put(\"10010001\", '-'); put(\"010001\", '.'); put(\"000001\", '?'); put(\"100101\", 'A'); put(\"10011010\", 'B'); put(\"0101\", 'C'); put(\"0001\", 'D'); put(\"110\", 'E'); put(\"01001\", 'F'); put(\"10011011\", 'G');  'J'); put(\"0110\", 'K'); put(\"00100\",  put(\"10011111\", 'Q'); put(\"1000\", 'R'); put(\"00110\", 'S'); put(\"00111\", 'T'); put(\"10011100\", 'U'); put(\"10011101\", 'V'); put(\"000010\", 'W'); put(\"10010010\", 'X'); put(\"10010011\", 'Y'); put(\"10010000\", 'Z'); } }; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = \"\"; while ((line =  (line.isEmpty()) { System.out.println(\"\");  sb1 = new StringBuilder(); sb2  (char c : line.toCharArray()) {  = sb1.toString(); for (int i = 0; ; ) { char c = 0; for (int j = 3; j < 9  (c2.containsKey(line2.substring(i, i + j))) { c = c2.get(line2.substring(i,  += j; break; } } if (c == 0)  } } }"], "original_ll": -0.3847379684448242, "sampled_ll": -0.29649993777275085, "all_perturbed_sampled_ll": [-0.6262009739875793], "all_perturbed_original_ll": [-0.8705963492393494], "perturbed_sampled_ll": -0.6262009739875793, "perturbed_original_ll": -0.8705963492393494, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "to_bin = dict(zip([chr(i) for i in range(ord(\"A\"), ord(\"Z\") + 1)] + [\" \", \".\", \",\", \"-\", \"'\", \"?\"],\n                  [bin(i)[2:7].zfill(5) for i in range(2 ** 5)]))\nto_chr = {\"101\":\" \", \"000000\":\"'\", \"000011\":\",\", \"10010001\":\"-\", \"010001\":\".\", \"000001\":\"?\", \"100101\":\"A\", \"10011010\":\"B\",\n          \"0101\":\"C\", \"0001\":\"D\", \"110\":\"E\", \"01001\":\"F\", \"10011011\":\"G\", \"010000\":\"H\", \"0111\":\"I\", \"10011000\":\"J\",\n          \"0110\":\"K\", \"00100\":\"L\", \"10011001\":\"M\", \"10011110\":\"N\", \"00101\":\"O\", \"111\":\"P\", \"10011111\":\"Q\", \"1000\":\"R\",\n          \"00110\":\"S\", \"00111\":\"T\", \"10011100\":\"U\", \"10011101\":\"V\", \"000010\":\"W\", \"10010010\":\"X\", \"10010011\":\"Y\", \"10010000\":\"Z\"}\n\nwhile True:\n  try:\n    s = input()\n  except EOFError:\n    break\n  bs = \"\".join([to_bin[c] for c in s])\n  ans = \"\"\n  while True:\n    length = 9\n    for i in range(length):\n      if bs[:i] in to_chr:\n        ans = ans + to_chr[bs[:i]]\n        bs = bs[i:]\n        break\n    else:\n      break\n  print(ans)\n", "sampled": "import sys\n\n# First conversion table (character to code)\nchar_to_code = {\n    'A': '00000', 'B': '10000', 'C': '01000', 'D': '00100', 'E': '00010',\n    'F': '10100', 'G': '01100', 'H': '00110', 'I': '10010', 'J': '01010',\n    'K': '00001', 'L': '10001', 'M': '01001', 'N': '00101', 'O': '10101',\n    'P': '01101', 'Q': '00011', 'R': '10011', 'S': '01011', 'T': '11000',\n    'U': '10110', 'V': '01110', 'W': '00111', 'X': '10111', 'Y': '01111',\n    'Z': '11001', \"'\": '11010', ',': '11011', '-': '11100', '.': '11101',\n    '?': '11110', ' ': '11111'\n}\n\n# Second conversion table (code to character)\ncode_to_char = {\n    '00': 'A', '0100': 'B', '0000': 'C', '100': 'D', '110': 'E',\n    '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J',\n    '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O',\n    '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T',\n    '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '0001': 'Y',\n    '10100': 'Z', '10101': \"'\", '10110': ',', '10111': '-', '11000': '.',\n    '11001': '?', '0000': ' '\n}\n\n# Fix the duplicate keys issue - need to check which mapping is correct\ncode_to_char = {\n    '00': 'A', '0100': 'B', '0000': 'C', '100': 'D', '110': 'E',\n    '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J',\n    '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O',\n    '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T',\n    '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '10100': 'Z',\n    '10101': \"'\", '10110': ',', '10111': '-', '11000': '.', '11001': '?'\n}\n\ndef decode(binary_str):\n    result = []\n    i = 0\n    while i < len(binary_str):\n        found = False\n        # Try lengths from 2 to 5\n        for length in range(2, 6):\n            if i + length <= len(binary_str):\n                substr = binary_str[i:i+length]\n                if substr in code_to_char:\n                    result.append(code_to_char[substr])\n                    i += length\n                    found = True\n                    break\n        if not found:\n            i += 1\n    return ''.join(result)\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    \n    # Step 1: Convert characters to binary using first table\n    binary = ''\n    for char in line:\n        if char in char_to_code:\n            binary += char_to_code[char]\n    \n    # Step 2: Convert binary to characters using second table\n    result = decode(binary)\n    print(result)\n", "perturbed_sampled": ["import sys # First conversion table (character to code) char_to_code = { 'A': '00000', 'B': '10000', 'C': '01000', 'D': '00100', 'E': '00010', 'F': '10100', 'G':  'L': '10001', 'M': '01001', 'N': '00101', 'O': '10101', 'P': '01101', 'Q': '00011',  '11000', 'U': '10110', 'V': '01110', 'W': '00111', 'X': '10111', 'Y': '01111',  '11101', '?': '11110', ' ': '11111' } # Second conversion table  { '00': 'A', '0100': 'B', '0000': 'C', '100': 'D', '110': 'E', '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J', '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O', '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T', '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X',  \"'\",  '.', '11001': '?', '0000': ' '  to check which mapping is correct code_to_char = { '00': 'A', '0100': 'B', '0000': 'C', '100':  '0110': 'G',  'J', '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O', '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T', '1011': 'U', '0111': 'V', '011': 'W',  \"'\", '10110': ',', '10111': '-', '11000': '.',  result = [] i = 0 while i < len(binary_str): found = False # Try lengths from 2 to 5 for length in range(2,  <= len(binary_str):  in code_to_char: result.append(code_to_char[substr])  True break  1 return ''.join(result) for line in sys.stdin: line =  # Step  using first table binary = '' for char in line: if char in char_to_code: binary += char_to_code[char] # Step 2: Convert binary to characters using second table result = decode(binary) print(result)"], "perturbed_original": ["to_bin = dict(zip([chr(i) for i in range(ord(\"A\"), ord(\"Z\") + 1)] + [\" \", \".\", \",\", \"-\",  in range(2 ** 5)]))  \"000011\":\",\", \"10010001\":\"-\", \"010001\":\".\", \"000001\":\"?\", \"100101\":\"A\", \"10011010\":\"B\", \"0101\":\"C\", \"0001\":\"D\", \"110\":\"E\", \"01001\":\"F\", \"10011011\":\"G\", \"010000\":\"H\", \"0111\":\"I\", \"10011000\":\"J\", \"0110\":\"K\", \"00100\":\"L\", \"10011001\":\"M\", \"10011110\":\"N\",  True: try: s = input() except EOFError: break bs = \"\".join([to_bin[c] for c in s]) ans = \"\" while True: length = 9 for i in range(length): if bs[:i] in to_chr: ans  = bs[i:] break else: break print(ans)"], "original_ll": -0.8399863839149475, "sampled_ll": -0.41601458191871643, "all_perturbed_sampled_ll": [-1.021572232246399], "all_perturbed_original_ll": [-1.4653700590133667], "perturbed_sampled_ll": -1.021572232246399, "perturbed_original_ll": -1.4653700590133667, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  long long int time[10001] = {}, wtime[10001] = {}, min, sum;\n  int j, k, n;\n  while(scanf(\"%d\", &n) && n){\n    for(j = 0;j < n;j++)\n      scanf(\"%lld\", &time[j]);\n\n    for(j = 0;j < n - 1;j++){\n      min = j;\n      for(k = j + 1;k < n;k++)\n\tmin = time[min] < time[k] ? min : k;\n      if(min != j){\n\ttime[min] += time[j];\n\ttime[j] = time[min] - time[j];\n\ttime[min] -= time[j];\n      }\n    }\n    sum = 0;\n    for(j = 1;j < n;j++){\n      wtime[j] = wtime[j - 1] + time[j - 1];\n      sum += wtime[j];\n    }\n    \n    printf(\"%lld\\n\", sum);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int times[10000];\n        \n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", &times[i]);\n        }\n        \n        qsort(times, n, sizeof(int), compare);\n        \n        long long total_wait = 0;\n        long long cumulative = 0;\n        \n        for(int i = 0; i < n; i++) {\n            total_wait += cumulative;\n            cumulative += times[i];\n        }\n        \n        printf(\"%lld\\n\", total_wait);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  const void *b) { return (*(int*)a - *(int*)b); } int main() { int n; while(scanf(\"%d\", &n) == 1 && n != 0) { int times[10000]; for(int i = 0;  n, sizeof(int), compare); long long total_wait = 0; long long cumulative = 0; for(int i = 0; i < n; i++) { total_wait += cumulative; cumulative  } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){  {}, wtime[10001] = {}, min, sum; int j, k, n; while(scanf(\"%d\", &n) && n){ for(j = 0;j  = 0;j < n - 1;j++){ min = j; for(k = j + 1;k <  time[min] += time[j]; time[j] = time[min] - time[j]; time[min] -= time[j]; } } sum = 0; for(j = 1;j < n;j++){ wtime[j] = wtime[j - 1] + time[j - 1]; sum += wtime[j]; } printf(\"%lld\\n\", sum); } return 0; }"], "original_ll": -0.7285519242286682, "sampled_ll": -0.5472394824028015, "all_perturbed_sampled_ll": [-1.7492449283599854], "all_perturbed_original_ll": [-1.5723989009857178], "perturbed_sampled_ll": -1.7492449283599854, "perturbed_original_ll": -1.5723989009857178, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.*;\npublic class Main {\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint [] data = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = sc.nextInt();\n\t\t\t\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tint [] data2 = new int[n];\n\t\t\tint sum = 0;\n\t\t\tdata2[0] = 0;\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tdata2[i] = data2[i-1] + data[i-1];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tsum += data2[i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] times = new int[n];\n            for (int i = 0; i < n; i++) {\n                times[i] = sc.nextInt();\n            }\n            \n            Arrays.sort(times);\n            \n            int totalWaitTime = 0;\n            int currentTime = 0;\n            \n            for (int i = 0; i < n; i++) {\n                totalWaitTime += currentTime;\n                currentTime += times[i];\n            }\n            \n            System.out.println(totalWaitTime);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public  Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt();  int[] times = new int[n]; for (int i = 0; i <  sc.nextInt(); } Arrays.sort(times); int totalWaitTime = 0; int currentTime = 0; for (int i = 0; i <  currentTime; currentTime += times[i]; } System.out.println(totalWaitTime); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { private void doit(){ Scanner sc =  = sc.nextInt(); if(n == 0) break; int [] data = new int[n]; for(int i = 0; i <  } Arrays.sort(data); int [] data2 = new int[n]; int sum = 0; data2[0] = 0; for(int i = 1; i < n; i++){ data2[i] = data2[i-1] + data[i-1]; } for(int  } public static void main(String[] args) { Main obj = new Main(); obj.doit(); } }"], "original_ll": -0.6978098154067993, "sampled_ll": -0.3899305462837219, "all_perturbed_sampled_ll": [-1.6660304069519043], "all_perturbed_original_ll": [-1.3493328094482422], "perturbed_sampled_ll": -1.6660304069519043, "perturbed_original_ll": -1.3493328094482422, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = int(input())\nt = []\ns = 0\nsum = 0\n\nif n == 0:\n    print(n)\n\nelse:\n    for i in range(n):\n        s = int(input())\n        if s == 0:\n            break\n        else:\n            t.append(i)\n            t[i] = s\n            t.sort()\n\n    for m in range(n):\n        sum = sum + t[m]*(n-m-1)\n\n    print(sum)\n\n", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    times = []\n    for _ in range(n):\n        times.append(int(input()))\n    \n    times.sort()\n    \n    total_wait = 0\n    cumulative_time = 0\n    \n    for t in times:\n        total_wait += cumulative_time\n        cumulative_time += t\n    \n    print(total_wait)\n", "perturbed_sampled": ["while True:  == 0: break times = [] for _ in range(n): times.append(int(input())) times.sort() total_wait = 0 cumulative_time = 0 for  cumulative_time cumulative_time += t print(total_wait)"], "perturbed_original": ["n = int(input()) t =  = 0 if n == 0: print(n) else: for i in range(n): s = int(input()) if s == 0: break else: t.append(i) t[i] = s  sum = sum + t[m]*(n-m-1) print(sum)"], "original_ll": -1.1917861700057983, "sampled_ll": -0.8705251216888428, "all_perturbed_sampled_ll": [-2.8001110553741455], "all_perturbed_original_ll": [-2.1036570072174072], "perturbed_sampled_ll": -2.8001110553741455, "perturbed_original_ll": -2.1036570072174072, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "char S[99];\nint G(x,y){return y?G(y,x%y):x;}\nmain(g,X,Y,x,y,z,t,T,f){for(;~scanf(\"%d%d\",&x,&y);){\nfor(g=0,X=x,Y=y;g<90;g++)S[g]=X*10/Y+'0',X=X*10%y;\nsprintf(S,\"%.97f\",x/(double)y);\ng=G(x,y);x/=g;y/=g;\nfor(z=0;y%2==0;y/=2)z++;\nfor(f=0;y%5==0;y/=5)f++;\nif(y==1)t=0;else{x=1;t=0;do{x=x*10%y;t++;}while(x!=1);}\nif(z>f)f=z;\nS[f+t+2]=0;puts(S+2);\nif(t){\n\tfor(;f>0;f--)putchar(' ');\n\tfor(;t>0;t--)putchar('^');\n\tputs(\"\");\n}\n}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int p, q;\n    \n    while (scanf(\"%d %d\", &p, &q) == 2) {\n        char digits[85];\n        int remainders[1000005];\n        int positions[1000005];\n        \n        memset(remainders, -1, sizeof(remainders));\n        memset(positions, -1, sizeof(positions));\n        \n        int remainder = p % q;\n        int pos = 0;\n        int cycle_start = -1;\n        \n        while (remainder != 0) {\n            if (remainders[remainder] != -1) {\n                cycle_start = remainders[remainder];\n                break;\n            }\n            \n            remainders[remainder] = pos;\n            positions[pos] = remainder;\n            \n            remainder *= 10;\n            digits[pos] = (remainder / q) + '0';\n            remainder = remainder % q;\n            pos++;\n        }\n        \n        digits[pos] = '\\0';\n        \n        if (cycle_start == -1) {\n            // Non-repeating\n            printf(\"%s\\n\", digits);\n        } else {\n            // Repeating\n            printf(\"%s\\n\", digits);\n            for (int i = 0; i < cycle_start; i++) {\n                printf(\" \");\n            }\n            for (int i = cycle_start; i < pos; i++) {\n                printf(\"^\");\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int p, q; while (scanf(\"%d %d\", &p, &q) ==  remainders[1000005]; int positions[1000005]; memset(remainders, -1, sizeof(remainders)); memset(positions, -1, sizeof(positions)); int remainder = p % q; int  =  {  cycle_start = remainders[remainder]; break; } remainders[remainder] = pos; positions[pos] = remainder; remainder *= 10; digits[pos] = (remainder / q) + '0'; remainder = remainder % q; pos++;  (cycle_start == -1) { // Non-repeating printf(\"%s\\n\", digits); } else { // Repeating printf(\"%s\\n\", digits); for (int i = 0; i < cycle_start; i++) { printf(\"   i++) { printf(\"^\"); } printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["char S[99]; int G(x,y){return y?G(y,x%y):x;} main(g,X,Y,x,y,z,t,T,f){for(;~scanf(\"%d%d\",&x,&y);){ for(g=0,X=x,Y=y;g<90;g++)S[g]=X*10/Y+'0',X=X*10%y; sprintf(S,\"%.97f\",x/(double)y);  S[f+t+2]=0;puts(S+2); if(t){ for(;f>0;f--)putchar(' '); for(;t>0;t--)putchar('^'); puts(\"\"); } }exit(0);}"], "original_ll": -1.9757333993911743, "sampled_ll": -0.6496462225914001, "all_perturbed_sampled_ll": [-1.6721349954605103], "all_perturbed_original_ll": [-2.305600643157959], "perturbed_sampled_ll": -1.6721349954605103, "perturbed_original_ll": -2.305600643157959, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int p = sc.nextInt();\n\t\t\tfinal int q = sc.nextInt();\n\t\t\t\n\t\t\tif(p == 0 && q == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] mods = new int[q];\n\t\t\tArrays.fill(mods, -1);\n\t\t\t\n\t\t\tint cur = p * 10;\n\t\t\tint rep_start = -1;\n\t\t\tint rep_end = 0;\n\t\t\twhile(true){\n\t\t\t\tfinal int m = cur % q;\n\t\t\t\tSystem.out.print(cur / q);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(m == 0){\n\t\t\t\t\trep_start = rep_end;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(mods[m] >= 0){\n\t\t\t\t\trep_start = mods[m];\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tmods[m] = rep_end;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep_end++;\n\t\t\t\tcur = m * 10;\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tif(rep_start != rep_end){\n\t\t\t\tfor(int i = 0; i <= rep_end;i++){\n\t\t\t\t\tif(i <= rep_start){\n\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.print(\"^\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int p = sc.nextInt();\n            int q = sc.nextInt();\n            \n            StringBuilder decimal = new StringBuilder();\n            Map<Integer, Integer> remainderPos = new HashMap<>();\n            \n            int remainder = p % q;\n            int position = 0;\n            \n            while (remainder != 0 && !remainderPos.containsKey(remainder)) {\n                remainderPos.put(remainder, position);\n                remainder *= 10;\n                int digit = remainder / q;\n                decimal.append(digit);\n                remainder = remainder % q;\n                position++;\n            }\n            \n            if (remainder == 0) {\n                // Terminates\n                System.out.println(decimal.toString());\n            } else {\n                // Repeating\n                int cycleStart = remainderPos.get(remainder);\n                System.out.println(decimal.toString());\n                \n                StringBuilder marker = new StringBuilder();\n                for (int i = 0; i < cycleStart; i++) {\n                    marker.append(' ');\n                }\n                for (int i = cycleStart; i < decimal.length(); i++) {\n                    marker.append('^');\n                }\n                System.out.println(marker.toString());\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {  { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int p = sc.nextInt();  decimal = new StringBuilder(); Map<Integer, Integer> remainderPos = new HashMap<>(); int remainder = p % q; int position = 0; while (remainder != 0 && !remainderPos.containsKey(remainder)) { remainderPos.put(remainder, position); remainder *= 10; int digit = remainder / q; decimal.append(digit);  Terminates System.out.println(decimal.toString()); } else { // Repeating int cycleStart =  new StringBuilder(); for (int i = 0; i < cycleStart; i++) { marker.append(' '); } for (int i = cycleStart; i  } System.out.println(marker.toString()); } } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  final int p = sc.nextInt(); final int q  && q == 0){ break; } int[] mods = new int[q]; Arrays.fill(mods, -1); int cur = p * 10; int rep_start =  while(true){ final int m = cur  if(m == 0){ rep_start = rep_end; break; }else if(mods[m] >= 0){ rep_start = mods[m]; break;  rep_end++; cur = m * 10; } System.out.println(); if(rep_start !=  i <=  \"); }else{ System.out.print(\"^\"); } } System.out.println(); } } } }"], "original_ll": -0.8742110729217529, "sampled_ll": -0.6729715466499329, "all_perturbed_sampled_ll": [-1.842378854751587], "all_perturbed_original_ll": [-2.1586928367614746], "perturbed_sampled_ll": -1.842378854751587, "perturbed_original_ll": -2.1586928367614746, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from decimal import *\nimport re\ndef solve2(m, n):\n    maxlen = 85\n    #PREC=200\n    PREC=300\n    getcontext().prec = PREC\n    x = Decimal(m) / Decimal(n)\n    s = x.to_eng_string()\n    if len(s) < PREC:\n        return(s[2:],'')\n    rep = 1\n    while True:\n        r = r'(.{%d})\\1{%d,}' % (rep, int(PREC/rep)-1)\n                                         #ex. '(.{6})\\\\1{12,}'\n        a=re.search(r, s)\n        if a:\n            break\n        rep += 1\n        if rep > maxlen:\n            raise ValueError('This cannot happen.')\n\n    u = s[2:a.start()+len(a.group(1))]\n    v = (' '*PREC + '^'*len(a.group(1)))[-len(u):]\n    return(u,v)\n\nwhile True:\n    try:\n        m,n = map(int, input().strip().split())\n        s,t = solve2(m, n)\n        print(s)\n        if t!='':\n            print(t)\n    except EOFError:\n        break", "sampled": "import sys\n\ndef solve(p, q):\n    # Calculate decimal representation of p/q\n    decimal_digits = []\n    remainders = {}\n    remainder = p % q\n    position = 0\n    \n    while remainder != 0 and remainder not in remainders:\n        remainders[remainder] = position\n        remainder *= 10\n        digit = remainder // q\n        decimal_digits.append(str(digit))\n        remainder = remainder % q\n        position += 1\n    \n    if remainder == 0:\n        # Terminating decimal\n        print(''.join(decimal_digits))\n    else:\n        # Repeating decimal\n        cycle_start = remainders[remainder]\n        print(''.join(decimal_digits))\n        \n        # Second line with spaces and carets\n        line2 = []\n        for i in range(len(decimal_digits)):\n            if i < cycle_start:\n                line2.append(' ')\n            else:\n                line2.append('^')\n        print(''.join(line2))\n\nfor line in sys.stdin:\n    p, q = map(int, line.strip().split())\n    solve(p, q)\n", "perturbed_sampled": ["import sys def solve(p, q): # Calculate decimal representation of p/q decimal_digits = [] remainders = {} remainder = p % q position = 0 while remainder !=  remainder *= 10 digit = remainder // q decimal_digits.append(str(digit)) remainder = remainder % q position += 1 if remainder == 0: #  remainders[remainder] print(''.join(decimal_digits)) # Second line with spaces and carets line2 = [] for i  cycle_start:  for line in sys.stdin: p, q = map(int, line.strip().split()) solve(p, q)"], "perturbed_original": ["from decimal import * import re def solve2(m, n): maxlen =  PREC x = Decimal(m) / Decimal(n)  < PREC:  True:  int(PREC/rep)-1) #ex. '(.{6})\\\\1{12,}' a=re.search(r, s) if a: break rep += 1 if rep > maxlen: raise ValueError('This cannot happen.') u = s[2:a.start()+len(a.group(1))] v = (' '*PREC + '^'*len(a.group(1)))[-len(u):] return(u,v) while True: try: m,n = map(int, input().strip().split())  if t!='': print(t) except EOFError: break"], "original_ll": -1.6403121948242188, "sampled_ll": -0.8451234698295593, "all_perturbed_sampled_ll": [-2.461137056350708], "all_perturbed_original_ll": [-2.943286657333374], "perturbed_sampled_ll": -2.461137056350708, "perturbed_original_ll": -2.943286657333374, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "int G(x,y){return y?G(y,x%y):x;}\nint L(x,y){return x>y?(x/G(x,y)*y):(y/G(y,x)*x);}\nn[3],a[3],m[3];main(i,x){\n\tfor(;scanf(\"%d%d%d%d%d%d\",a,m,a+1,m+1,a+2,m+2),*m;){\n\t\tfor(i=3;i--;)for(x=n[i]=1;(x=a[i]*x%m[i])>1;n[i]++);\n\t\tprintf(\"%d\\n\",L(n[0],L(n[1],n[2])));\n\t}\n}", "sampled": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long lcm(long long a, long long b) {\n    return a / gcd(a, b) * b;\n}\n\nlong long find_period(long long a, long long m) {\n    long long x = 1;\n    long long period = 0;\n    \n    do {\n        x = (x * a) % m;\n        period++;\n    } while (x != 1);\n    \n    return period;\n}\n\nint main() {\n    long long a1, m1, a2, m2, a3, m3;\n    \n    while (1) {\n        scanf(\"%lld %lld %lld %lld %lld %lld\", &a1, &m1, &a2, &m2, &a3, &m3);\n        \n        if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) {\n            break;\n        }\n        \n        long long period1 = find_period(a1, m1);\n        long long period2 = find_period(a2, m2);\n        long long period3 = find_period(a3, m3);\n        \n        long long result = lcm(period1, lcm(period2, period3));\n        \n        printf(\"%lld\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> long long gcd(long long  while (b != 0) { long long temp = b; b = a %  return a; } long long  b) { return a / gcd(a, b) * b; } long long find_period(long long a, long long m) { long long x = 1; long  { x = (x * a) % m; period++; } while (x != 1); return period; } int  m1, a2, m2, a3, m3; while (1) { scanf(\"%lld %lld %lld %lld %lld %lld\", &a1, &m1, &a2, &m2, &a3, &m3); if (a1 == 0 && m1 == 0 && a2 == 0 &&   long long period1 = find_period(a1, m1); long long period2 = find_period(a2, m2);   lcm(period1, lcm(period2, period3)); printf(\"%lld\\n\", result); } return 0; }"], "perturbed_original": ["int G(x,y){return y?G(y,x%y):x;} int L(x,y){return x>y?(x/G(x,y)*y):(y/G(y,x)*x);} n[3],a[3],m[3];main(i,x){ for(;scanf(\"%d%d%d%d%d%d\",a,m,a+1,m+1,a+2,m+2),*m;){ for(i=3;i--;)for(x=n[i]=1;(x=a[i]*x%m[i])>1;n[i]++); printf(\"%d\\n\",L(n[0],L(n[1],n[2]))); } }"], "original_ll": -1.6341581344604492, "sampled_ll": -0.2709316909313202, "all_perturbed_sampled_ll": [-1.2291843891143799], "all_perturbed_original_ll": [-1.7424174547195435], "perturbed_sampled_ll": -1.2291843891143799, "perturbed_original_ll": -1.7424174547195435, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.*;\nimport java.util.*;\n\n\n// \u0082\u00e6\u0082\u00ad\u008a\u00d4\u0088\u00e1\u0082\u00a4\u0082\u00c6\u0082\u00b1\u0082\u00eb\u0081B\n// \u0096\u00e2\u0091\u00e8\u0095\u00b6\u0082\u00c9\u008f\u0091\u0082\u00a2\u0082\u00c4\u0082\u00c8\u0082\u00ad\u0082\u00c4\u0082\u00e0\u0096\u00e2\u0091\u00e8\u0083Z\u0083b\u0083g\u0082\u00cd\u0095\u00a1\u0090\u0094\u0082\u00c5\u0090\u00e6\u0093\u00aa\u0082\u00aa0\u0082\u00c5\u008fI\u0097\u00b9\u0082\u00c5\u0082\u00a0\u0082\u00e9\u0081B\n// \u0096\u00e2\u0091\u00e8\u0083Z\u0083b\u0083g\u0082\u00cc\u008cJ\u0082\u00e8\u0095\u00d4\u0082\u00b5\u008e\u009e\u0082\u00c9\u008f\u0089\u008a\u00fa\u0089\u00bb\u0098R\u0082\u00ea\n\n// 2011/10/18\n\n//\u0081@0114 \u0094\u0088\npublic class Main {\n\n\t\n\tlong gcm(long a, long b) {\n\t\t\n\t\twhile(b != 0) {\n\t\t\tlong t = a % b;\n\t\t\ta = b;\n\t\t\tb = t;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcm(a, b);\n\t}\n\t\n\t// \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2\n\tboolean main() throws IOException {\n\n\t\tint[] ri = readIntArray();\n\t\tint a1 = ri[0];\n\t\tint m1 = ri[1];\n\t\tint a2 = ri[2];\n\t\tint m2 = ri[3];\n\t\tint a3 = ri[4];\n\t\tint m3 = ri[5];\n\t\tif (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) \n\t\t\treturn false; // \u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2\n\n\t\tint i;\n\t\tint x = 1;\n\t\tfor(i = 1;; i++) {\n\t\t\tx = (a1 * x) % m1;\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tlong v1 = i;\n\t\tx = 1;\n\t\tfor(i = 1;; i++) {\n\t\t\tx = (a2 * x) % m2;\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tlong v2 = i;\n\t\tx = 1;\n\t\tfor(i = 1;; i++) {\n\t\t\tx = (a3 * x) % m3;\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tlong v3 = i;\n\t\tlong r = lcm(lcm(v1, v2), v3);\n\t\t\n\t\t\n\t\t// \u0089\u00f0\u0082\u00cc\u0095\\\u008e\u00a6\n\t\tSystem.out.printf(\"%d\\n\", r);\n\t\t\n\t\treturn true; // \u0090\u00b3\u008f\u00ed\u008fI\u0097\u00b9 \u008e\u009f\u0082\u00d6\n\t}\n\t\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\t\t\t\n\t\t\tString inputStr = \"1 459550\\n\";\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr)); \n\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // \u008f\u0091\u0082\u00ab\u008e\u00cc\u0082\u00c4\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // \u0083R\u0083\u0093\u0083\\\u0081[\u0083\u008b\u0082\u00a9\u0082\u00e7\n\t\t}\n\t\t\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; /*i < N*/; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t}\n\n\t\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\t\n\n\t// \u0095W\u008f\u0080\u0093\u00fc\u0097\u00cd\u0082\u00e6\u0082\u00e81\u008ds\u0095\u00aa\u0082\u00cc\u0083X\u0083y\u0081[\u0083X\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0082\u00cc\u0090\u00ae\u0090\u0094\u0092l\u0082\u00f0\u0093\u00c7\u0082\u00de\n\t// EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7\n\tprivate static int[] readIntArray() throws IOException {\n\t\t\n\t\tString s = reader.readLine();\n\t\tif (s == null)\n\t\t\treturn null;\n\t\tString[] sp = s.split(\" \");\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\t\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long a1 = sc.nextLong();\n            long m1 = sc.nextLong();\n            long a2 = sc.nextLong();\n            long m2 = sc.nextLong();\n            long a3 = sc.nextLong();\n            long m3 = sc.nextLong();\n            \n            if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) {\n                break;\n            }\n            \n            long period1 = findPeriod(a1, m1);\n            long period2 = findPeriod(a2, m2);\n            long period3 = findPeriod(a3, m3);\n            \n            long result = lcm(lcm(period1, period2), period3);\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n    \n    private static long findPeriod(long a, long m) {\n        long x = 1;\n        long period = 0;\n        \n        do {\n            x = (a * x) % m;\n            period++;\n        } while (x != 1);\n        \n        return period;\n    }\n    \n    private static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n    \n    private static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main s ; ++a1)<extra_id_2>= s; }<extra_id_3>{<extra_id_4>long m = (long<extra_id_5>)<extra_id_6>) ; if ( m<extra_id_7>period ] ;<extra_id_8>= 0 ; break<extra_id_9>= a<extra_id_10>b ; } s.nextLong()<extra_id_11>; } s.nextLong();<extra_id_12>i = 0<extra_id_13>if (i == 0<extra_id_14>e) { s.nextLong().nextLong(); }<extra_id_15>s.nextLong().nextLong(). = new Scanner(System.in); while (true) { long a1 = sc.nextLong(); long  = sc.nextLong(); long m2 = sc.nextLong(); long  = sc.nextLong(); if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3  0) { break; } long period1 = findPeriod(a1, m1); long period2 = findPeriod(a2, m2); long period3 = findPeriod(a3, m3); long result  } sc.close(); } private static long findPeriod(long a, long m) { long x = 1; long period = 0; do { x = (a * x) % m; period++; } while (x != 1); return  gcd(long a, long b) { while (b != 0) { long temp =  b; a = temp;  static  { return a / gcd(a, b) * b; } }"], "perturbed_original": ["import java.io.*; import  \u0082\u00e9\u0081B // \u0096\u00e2\u0091\u00e8\u0083Z\u0083b\u0083g\u0082\u00cc\u008cJ\u0082\u00e8\u0095\u00d4\u0082\u00b5\u008e\u009e\u0082\u00c9\u008f\u0089\u008a\u00fa\u0089\u00bb\u0098R\u0082\u00ea // 2011/10/18 //\u0081@0114  long gcm(long a, long b) { while(b != 0) { long t = a % b; a = b; b = t; } return a; } long lcm(long a, long b)  / gcm(a, b); } // \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2 boolean main() throws IOException {  a1 = ri[0]; int m1 = ri[1]; int a2 = ri[2]; int m2 = ri[3]; int a3  ri[5]; if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 ==  return false; //  = 1; for(i = 1;; i++) { x  1) break; } long v1 = i; x = 1; for(i = 1;; i++) { x = (a2 * x) % m2; if (x == 1) break; } long v2 = i; x = 1; for(i = 1;; i++) { x  m3; if (x == 1) break; } long v3 = i; long r =  System.out.printf(\"%d\\n\", r); return true; //  final static boolean DEBUG = true; // debug  = false; // release  throws IOException { if (DEBUG) { log = System.out; String inputStr = \"1 459550\\n\"; reader = new BufferedReader(new StringReader(inputStr)); } else { log = new  ); //  InputStreamReader(System.in));  = readIntArray()[0]; for(int i = 0; /*i < N*/; i++) { boolean b = new Main().main();  }  reader; // \u0095W\u008f\u0080\u0093\u00fc\u0097\u00cd\u0082\u00e6\u0082\u00e81\u008ds\u0095\u00aa\u0082\u00cc\u0083X\u0083y\u0081[\u0083X\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0082\u00cc\u0090\u00ae\u0090\u0094\u0092l\u0082\u00f0\u0093\u00c7\u0082\u00de // EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7 private static int[] readIntArray() throws IOException { String s = reader.readLine(); if (s == null) return null; String[] sp = s.split(\" \"); int[] a = new int[sp.length]; for(int  sp.length; i++) { a[i] = Integer.parseInt(sp[i]); } return a; } }"], "original_ll": -1.3960696458816528, "sampled_ll": -0.2965705692768097, "all_perturbed_sampled_ll": [-1.7355934381484985], "all_perturbed_original_ll": [-2.034330129623413], "perturbed_sampled_ll": -1.7355934381484985, "perturbed_original_ll": -2.034330129623413, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# AOJ 0114: Electro-Fly\n# Python3 2018.6.18 bal4u\n\nfrom math import gcd\n\nwhile True:\n\ta1, m1, a2, m2, a3, m3 = list(map(int, input().split()))\n\tif a1 == 0: break\n\tn = 0\n\tb1, b2, b3 = 1, 1, 1\n\ta, b, c = 0, 0, 0\n\twhile True:\n\t\tif a == 0: b1 = (b1 * a1) % m1\n\t\tif b == 0: b2 = (b2 * a2) % m2\n\t\tif c == 0: b3 = (b3 * a3) % m3\n\t\tn += 1\n\t\tif a == 0 and b1 == 1: a = n\n\t\tif b == 0 and b2 == 1: b = n\n\t\tif c == 0 and b3 == 1: c = n\n\t\tif a != 0 and b != 0 and c != 0: break\n\t\n\tans = a // gcd(a,b) * b\n\tans = ans // gcd(ans, c) * c\n\tprint(ans)\n\n", "sampled": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef order_mod(a, m):\n    \"\"\"Find the multiplicative order of a modulo m\"\"\"\n    if gcd(a, m) != 1:\n        return -1\n    \n    order = 1\n    current = a % m\n    while current != 1:\n        current = (current * a) % m\n        order += 1\n    return order\n\nwhile True:\n    line = list(map(int, input().split()))\n    if line == [0, 0, 0, 0, 0, 0]:\n        break\n    \n    a1, m1, a2, m2, a3, m3 = line\n    \n    # Find the order of each coordinate\n    order1 = order_mod(a1, m1)\n    order2 = order_mod(a2, m2)\n    order3 = order_mod(a3, m3)\n    \n    # The minimum number of moves is the LCM of the three orders\n    result = lcm(lcm(order1, order2), order3)\n    print(result)\n", "perturbed_sampled": ["import math from functools import  b: a, b = b, a % b return a def lcm(a, b): return a * b // gcd(a, b) def order_mod(a, m): \"\"\"Find  modulo m\"\"\" if gcd(a, m) != 1: return -1 order = 1 current = a % m while current != 1: current = (current * a) % m order += 1 return order while True: line = list(map(int, input().split()))  0, 0, 0,  m2, a3,  the order of each coordinate order1 = order_mod(a1, m1) order2 = order_mod(a2, m2) order3 = order_mod(a3, m3) # The minimum  orders  print(result)"], "perturbed_original": ["# AOJ 0114: Electro-Fly #  import gcd while True: a1, m1, a2, m2,  if a1 == 0: break n = 0 b1, b2, b3 = 1, 1, 1 a, b, c = 0, 0, 0 while True: if a == 0: b1 = (b1 * a1) % m1 if b == 0: b2 = (b2 * a2) %  a3) %  a == 0 and b1 == 1: a  0 and b2 == 1: b = n if c == 0 and b3 == 1: c = n  b != 0  ans = a // gcd(a,b) * b ans = ans // gcd(ans, c) * c print(ans)"], "original_ll": -1.010331392288208, "sampled_ll": -0.6145464181900024, "all_perturbed_sampled_ll": [-1.984647512435913], "all_perturbed_original_ll": [-1.9044325351715088], "perturbed_sampled_ll": -1.984647512435913, "perturbed_original_ll": -1.9044325351715088, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,h,w,min,ans,mat[700][700],max[700][700];\nchar c;\n\nint main(){\n\twhile(scanf(\"%d %d\",&h,&w)*h*w){\n\t\tfor(i=0;i<h;i++){\n\t\t\tk=0;\n\t\t\tscanf(\"\\n\");\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\"%c\",&c);\n\t\t\t\tif(c=='.')k++; else k=0;\n\t\t\t\tmat[i][j]=k;\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tfor(j=w-1;j>=0;j--){\n\t\t\tfor(k=h-1;k>=0;k--){\n\t\t\t\tmin=mat[k][j];\n\t\t\t\tfor(i=1;i+k<h;i++){\n\t\t\t\t\tif(min>mat[i+k][j])min=mat[i+k][j];\n\t\t\t\t\tif(min==0)break;\n\t\t\t\t\tif(min*(i+1)>ans)ans=min*(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int H, W;\n    char grid[505][505];\n    int height[505][505];\n    \n    while (scanf(\"%d %d\", &H, &W) == 2 && (H || W)) {\n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        // Calculate height array\n        memset(height, 0, sizeof(height));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == '.') {\n                    if (i == 0) {\n                        height[i][j] = 1;\n                    } else {\n                        height[i][j] = height[i-1][j] + 1;\n                    }\n                } else {\n                    height[i][j] = 0;\n                }\n            }\n        }\n        \n        int maxArea = 0;\n        \n        // For each row, find largest rectangle in histogram\n        for (int i = 0; i < H; i++) {\n            // For each column as left boundary\n            for (int left = 0; left < W; left++) {\n                if (height[i][left] == 0) continue;\n                \n                int minHeight = height[i][left];\n                for (int right = left; right < W; right++) {\n                    if (height[i][right] == 0) break;\n                    \n                    if (height[i][right] < minHeight) {\n                        minHeight = height[i][right];\n                    }\n                    \n                    int width = right - left + 1;\n                    int area = minHeight * width;\n                    if (area > maxArea) {\n                        maxArea = area;\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", maxArea);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["}<extra_id_3>H/ W; i++) if (grid[i][1]<extra_id_4>{<extra_id_5>(x<extra_id_6>><extra_id_7>;<extra_id_8>if (x<extra_id_9>x<extra_id_10>- 1 ; if (x<extra_id_11>;<extra_id_12>x <<extra_id_13>-<extra_id_14>. length -<extra_id_15>; i<extra_id_16>}<extra_id_23>] ==<extra_id_24>= 0; } else<extra_id_25>[ i - W; char grid[505][505]; int height[505][505]; while (scanf(\"%d %d\", &H, &W) == 2 && (H || W))  0; i <  } // Calculate height array memset(height, 0, sizeof(height)); for (int  H; i++) { for (int j = 0; j < W; j++) { if (grid[i][j] == '.') { if (i == 0) { height[i][j] = 1; } else { height[i][j] = height[i-1][j] + 1; } } else { height[i][j] = 0; } } }  For each row, find largest rectangle in histogram for  < H; i++) { // For each column as left boundary   if (height[i][left] == 0) continue; int  right = left; right < W; right++) { if (height[i][right] == 0) break; if (height[i][right] < minHeight) { minHeight = height[i][right]; } int width = right - left + 1; int area = minHeight * width; if (area > maxArea)   } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int i,j,k,h,w,min,ans,mat[700][700],max[700][700]; char  for(i=0;i<h;i++){ k=0; scanf(\"\\n\"); for(j=0;j<w;j++){ scanf(\"%c\",&c); if(c=='.')k++; else  for(j=w-1;j>=0;j--){ for(k=h-1;k>=0;k--){ min=mat[k][j]; for(i=1;i+k<h;i++){ if(min>mat[i+k][j])min=mat[i+k][j]; if(min==0)break; if(min*(i+1)>ans)ans=min*(i+1); } } } printf(\"%d\\n\",ans); } return 0; }"], "original_ll": -0.9389068484306335, "sampled_ll": -0.4290648102760315, "all_perturbed_sampled_ll": [-1.7195793390274048], "all_perturbed_original_ll": [-1.3867911100387573], "perturbed_sampled_ll": -1.7195793390274048, "perturbed_original_ll": -1.3867911100387573, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n//Rectangular Searching\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif((h|w)==0)break;\n\t\t\tchar[][] m = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)m[i]=sc.next().toCharArray();\n\t\t\tint[][] c = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tint x = 1;\n\t\t\t\tfor(int j=w-1;j>=0;j--){\n\t\t\t\t\tif(m[i][j]=='.'){\n\t\t\t\t\t\tc[i][j] = x++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tc[i][j] = 0;\n\t\t\t\t\t\tx = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(0<i&&c[i][j]==c[i-1][j]||c[i][j]==0)continue;\n\t\t\t\t\tint k = 1;\n\t\t\t\t\tint min = c[i][j];\n\t\t\t\t\tmax = Math.max(max, k*min);\n\t\t\t\t\twhile(i+k<h&&c[i+k][j]>0){\n\t\t\t\t\t\tmin = Math.min(min, c[i+k][j]);\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tmax = Math.max(max, k*min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int H = sc.nextInt();\n            int W = sc.nextInt();\n            \n            if (H == 0 && W == 0) break;\n            \n            sc.nextLine();\n            char[][] grid = new char[H][W];\n            \n            for (int i = 0; i < H; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            \n            int[][] height = new int[H][W];\n            \n            for (int j = 0; j < W; j++) {\n                for (int i = 0; i < H; i++) {\n                    if (grid[i][j] == '*') {\n                        height[i][j] = 0;\n                    } else {\n                        if (i == 0) {\n                            height[i][j] = 1;\n                        } else {\n                            height[i][j] = height[i-1][j] + 1;\n                        }\n                    }\n                }\n            }\n            \n            int maxArea = 0;\n            \n            for (int i = 0; i < H; i++) {\n                maxArea = Math.max(maxArea, largestRectangleInHistogram(height[i]));\n            }\n            \n            System.out.println(maxArea);\n        }\n        \n        sc.close();\n    }\n    \n    static int largestRectangleInHistogram(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        int n = heights.length;\n        \n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && heights[i] < heights[stack.peek()]) {\n                int h = heights[stack.pop()];\n                int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            stack.push(i);\n        }\n        \n        while (!stack.isEmpty()) {\n            int h = heights[stack.pop()];\n            int w = stack.isEmpty() ? n : n - stack.peek() - 1;\n            maxArea = Math.max(maxArea, h * w);\n        }\n        \n        return maxArea;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args)  Scanner(System.in);  = sc.nextInt(); int W = sc.nextInt(); if (H == 0 && W == 0) break; sc.nextLine();  for (int i = 0; i < H; i++) { String line = sc.nextLine(); for (int j = 0; j  = line.charAt(j); } } int[][] height = new int[H][W]; for (int j = 0; j < W; j++) { for (int i = 0; i < H; i++) { if (grid[i][j] == '*') { height[i][j] = 0;  == 0) { height[i][j] = 1; } else { height[i][j] = height[i-1][j] + 1; } } } } int maxArea  = 0; i < H; i++)  } System.out.println(maxArea); } sc.close(); } static int  = new Stack<>(); int maxArea  heights.length; for (int i = 0; i < n; i++)  < heights[stack.peek()]) { int h = heights[stack.pop()]; int w = stack.isEmpty() ? i : i - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); }  int  = stack.isEmpty() ?  Math.max(maxArea, h * w); } return maxArea; } }"], "perturbed_original": ["import java.util.Scanner; //Rectangular Math.max(min,<extra_id_9>i++) { if(-c[i][j]>0){ // static void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){ int h = sc.nextInt(); int w = sc.nextInt(); if((h|w)==0)break; char[][] m = new char[h][w]; for(int i=0;i<h;i++)m[i]=sc.next().toCharArray(); int[][] c = new int[h][w]; for(int i=0;i<h;i++){ int x = 1; for(int j=w-1;j>=0;j--){  else{ c[i][j] = 0; x = 1; } } } int max = 0;  int k = 1; int  Math.max(max, k*min); while(i+k<h&&c[i+k][j]>0){ min =  Math.max(max, k*min); }  }"], "original_ll": -0.6733659505844116, "sampled_ll": -0.23286686837673187, "all_perturbed_sampled_ll": [-1.1929352283477783], "all_perturbed_original_ll": [-1.8382105827331543], "perturbed_sampled_ll": -1.1929352283477783, "perturbed_original_ll": -1.8382105827331543, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import product\nwhile(True):\n    H,W = map(int,input().split())\n    if not H: break\n    ma = 0\n    for i in range(H):\n        ma |= (int(input().replace(\".\",\"0\").replace(\"*\",\"1\"),2) << ((H-i-1)*W))\n    flag = False\n    hw = [[h,w] for h,w in product(range(H,0,-1),range(W,0,-1))]\n    hw = sorted(hw,key=lambda x: -x[1]*x[0])\n    ans = 0\n    for h,w in hw:\n        for i,j in product(range(H-h+1),range(W-w+1)):\n            b = (sum([((2**w-1) << j) << k*W for k in range(h)]) ) << i*W\n            c = ma&b\n            if not c :flag = True; ans = max(ans,h*w); break\n        else:\n            continue\n        if flag: break\n    print(ans)\n\n", "sampled": "def maximal_rectangle(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    \n    H = len(matrix)\n    W = len(matrix[0])\n    \n    # Build height matrix\n    heights = [[0] * W for _ in range(H)]\n    \n    for j in range(W):\n        for i in range(H):\n            if matrix[i][j] == '.':\n                if i == 0:\n                    heights[i][j] = 1\n                else:\n                    heights[i][j] = heights[i-1][j] + 1\n            else:\n                heights[i][j] = 0\n    \n    # Find max rectangle for each row using histogram method\n    max_area = 0\n    \n    for i in range(H):\n        max_area = max(max_area, largest_rectangle_in_histogram(heights[i]))\n    \n    return max_area\n\ndef largest_rectangle_in_histogram(heights):\n    stack = []\n    max_area = 0\n    index = 0\n    \n    while index < len(heights):\n        if not stack or heights[index] >= heights[stack[-1]]:\n            stack.append(index)\n            index += 1\n        else:\n            top = stack.pop()\n            width = index if not stack else index - stack[-1] - 1\n            area = heights[top] * width\n            max_area = max(max_area, area)\n    \n    while stack:\n        top = stack.pop()\n        width = index if not stack else index - stack[-1] - 1\n        area = heights[top] * width\n        max_area = max(max_area, area)\n    \n    return max_area\n\nwhile True:\n    line = input().split()\n    H, W = int(line[0]), int(line[1])\n    \n    if H == 0 and W == 0:\n        break\n    \n    matrix = []\n    for _ in range(H):\n        row = input().strip()\n        matrix.append(row)\n    \n    result = maximal_rectangle(matrix)\n    print(result)\n", "perturbed_sampled": ["def maximal_rectangle(matrix): if not  0 H = len(matrix) W = len(matrix[0]) # Build height matrix heights =  in range(H)] for j in range(W): for i in range(H): if matrix[i][j] ==  heights[i][j] = 1 else: heights[i][j] =  = 0 # Find max rectangle for each row using histogram method max_area = 0 for i in range(H): max_area = max(max_area, largest_rectangle_in_histogram(heights[i])) return max_area def largest_rectangle_in_histogram(heights): stack  index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top = stack.pop() width = index if not stack else index - stack[-1] - 1 area = heights[top] * width max_area =  = stack.pop()  stack else index - stack[-1] - 1 area  max_area while True: line = input().split() H, W =  0 and W == 0: break matrix = [] for _ in range(H): row  maximal_rectangle(matrix) print(result)"], "perturbed_original": [" H,W = map(int,input().split()) if not H: break ma = 0 for i in range(H): ma |= (int(input().replace(\".\",\"0\").replace(\"*\",\"1\"),2) << ((H-i-1)*W)) flag = False hw = [[h,w] for h,w in product(range(H,0,-1),range(W,0,-1))] hw = sorted(hw,key=lambda x: -x[1]*x[0]) ans =  for  (sum([((2**w-1) << j) << k*W for k in range(h)]) ) << i*W c =  = True; ans = max(ans,h*w); break else: continue if flag: break print(ans)"], "original_ll": -1.3689463138580322, "sampled_ll": -0.36668893694877625, "all_perturbed_sampled_ll": [-1.4640816450119019], "all_perturbed_original_ll": [-2.359642267227173], "perturbed_sampled_ll": -1.4640816450119019, "perturbed_original_ll": -2.359642267227173, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#define rep(i,n) for(i=0;i<n;i++)\nint min(int a,int b){return a<b?a:b;}\nint main(void)\n{\n  int n,m,mat[20][20],i,j,k,a,b,c,d;\n  scanf(\"%d%d\",&n,&m);\n  rep(i,n)rep(j,n)mat[i][j]=i-j?1<<21:0;\n  rep(i,m){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--;\n    mat[a][b]=c;mat[b][a]=d;\n  }\n  rep(i,n)rep(j,n)rep(k,n)mat[j][k]=min(mat[j][k],mat[j][i]+mat[i][k]);\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--;\n  printf(\"%d\\n\",c-mat[a][b]-mat[b][a]-d);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 21\n#define INF INT_MAX\n\nint n, m;\nint cost[MAX_N][MAX_N];\nint dist[MAX_N];\nint visited[MAX_N];\n\nvoid dijkstra(int start) {\n    for (int i = 1; i <= n; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    dist[start] = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int u = -1;\n        int minDist = INF;\n        for (int j = 1; j <= n; j++) {\n            if (!visited[j] && dist[j] < minDist) {\n                minDist = dist[j];\n                u = j;\n            }\n        }\n        \n        if (u == -1) break;\n        visited[u] = 1;\n        \n        for (int v = 1; v <= n; v++) {\n            if (cost[u][v] != INF && dist[u] != INF) {\n                if (dist[u] + cost[u][v] < dist[v]) {\n                    dist[v] = dist[u] + cost[u][v];\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cost[i][j] = INF;\n        }\n    }\n    \n    for (int i = 0; i < m; i++) {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        cost[a][b] = c;\n        cost[b][a] = d;\n    }\n    \n    int s, g, V, P;\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n    \n    dijkstra(s);\n    int costToG = dist[g];\n    \n    dijkstra(g);\n    int costFromG = dist[s];\n    \n    int totalCost = costToG + costFromG + P;\n    int reward = V - totalCost;\n    \n    printf(\"%d\\n\", reward);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>   int n, m; int cost[MAX_N][MAX_N]; int dist[MAX_N]; int visited[MAX_N]; void dijkstra(int start) { for (int i = 1; i <= n; i++) { dist[i] = INF; visited[i] = 0; } dist[start] = 0; for (int i = 0; i < n;  -1; int minDist = INF; for (int j = 1; j <= n; j++) { if (!visited[j] && dist[j] < minDist) {  j; } } if (u == -1) break; visited[u] = 1; for (int v =  INF && dist[u] != INF)  < dist[v]) { dist[v] = dist[u] + cost[u][v]; } } } } } int main() { scanf(\"%d\", &n); scanf(\"%d\", &m); for (int i = 1; i <= n; i++) { for (int  n;  } } for (int i  b, c, d; scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d); cost[a][b] = c; cost[b][a] = d; } int s, g, V, P; scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);  dijkstra(g); int costFromG = dist[s]; int totalCost =  int reward = V - totalCost; printf(\"%d\\n\", reward); return 0; }"], "perturbed_original": ["#include<stdio.h> #define rep(i,n) for(i=0;i<n;i++) int min(int a,int b){return a<b?a:b;} int main(void) { int n,m,mat[20][20],i,j,k,a,b,c,d; scanf(\"%d%d\",&n,&m); rep(i,n)rep(j,n)mat[i][j]=i-j?1<<21:0;  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--; printf(\"%d\\n\",c-mat[a][b]-mat[b][a]-d); return 0; }"], "original_ll": -0.9509952664375305, "sampled_ll": -0.3812393844127655, "all_perturbed_sampled_ll": [-1.218948245048523], "all_perturbed_original_ll": [-1.5146782398223877], "perturbed_sampled_ll": -1.218948245048523, "perturbed_original_ll": -1.5146782398223877, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final int INF = Integer.MAX_VALUE;\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\t}\n\t\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\t//int[][] d = new int[n][n]; \n\t\tint m = sc.nextInt();\n\t\tint[][] road = new int[m][4];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tString s = sc.next();\n\t\t\tString[] ss = s.split(\",\");\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\troad[i][j] = Integer.parseInt(ss[j]);\n\t\t\t}\n\t\t}\n\t\tint[] input = new int[4];\n\t\tString s = sc.next();\n\t\tString[] ss = s.split(\",\");\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tinput[j] = Integer.parseInt(ss[j]);\n\t\t}\n\t\tint start = input[0];\n\t\tint goal = input[1];\n\t\t//start\u304b\u3089goal\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u6c42\u3081\u308b\n\t\t//start\u304b\u3089\u306e\u8ddd\u96e2\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\td[start - 1] = 0;\n\t\twhile(true){\n\t\t\tboolean bChange = false;\n\t\t\t//\u9053\u3092\u898b\u3066\u3044\u304f\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint from = road[i][0];\n\t\t\t\tint to = road[i][1];\n\t\t\t\tint cost = road[i][2];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfrom = road[i][1];\n\t\t\t\tto = road[i][0];\n\t\t\t\tcost = road[i][3];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//print(d);\n\t\t\tif(bChange == false) break;\n\t\t}\n\t\tint sum = d[goal - 1];\n\t\t\n\t\t//\u4eca\u5ea6\u306f\u30b4\u30fc\u30eb\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2\n\t\tstart = input[1];\n\t\tgoal = input[0];\n\t\tArrays.fill(d, INF);\n\t\td[start - 1] = 0;\n\t\twhile(true){\n\t\t\tboolean bChange = false;\n\t\t\t//\u9053\u3092\u898b\u3066\u3044\u304f\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint from = road[i][0];\n\t\t\t\tint to = road[i][1];\n\t\t\t\tint cost = road[i][2];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfrom = road[i][1];\n\t\t\t\tto = road[i][0];\n\t\t\t\tcost = road[i][3];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//print(d);\n\t\t\tif(bChange == false) break;\n\t\t}\n\t\t//System.out.println(d[goal - 1]);\n\t\tsum += d[goal - 1];\n\t\t\n\t\tSystem.out.println(input[2] - input[3] - sum);\n\t\t\n\t}\n\t\n\tpublic static void print(int[] d){\n\t\tfor(int a : d){\n\t\t\tSystem.out.print(a + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to;\n        int cost;\n        \n        Edge(int to, int cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        sc.nextLine();\n        \n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            int c = Integer.parseInt(parts[2]);\n            int d = Integer.parseInt(parts[3]);\n            \n            graph.get(a).add(new Edge(b, c));\n            graph.get(b).add(new Edge(a, d));\n        }\n        \n        String[] lastLine = sc.nextLine().split(\",\");\n        int s = Integer.parseInt(lastLine[0]);\n        int g = Integer.parseInt(lastLine[1]);\n        int V = Integer.parseInt(lastLine[2]);\n        int P = Integer.parseInt(lastLine[3]);\n        \n        int[] distToG = dijkstra(graph, n, s, g);\n        int[] distFromG = dijkstra(graph, n, g, s);\n        \n        int minCost = distToG[g] + distFromG[s];\n        int reward = V - P - minCost;\n        \n        System.out.println(reward);\n        \n        sc.close();\n    }\n    \n    static int[] dijkstra(List<List<Edge>> graph, int n, int start, int end) {\n        int[] dist = new int[n + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        pq.offer(new int[]{start, 0});\n        \n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int u = curr[0];\n            int d = curr[1];\n            \n            if (d > dist[u]) continue;\n            \n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                int newDist = dist[u] + edge.cost;\n                \n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.offer(new int[]{v, newDist});\n                }\n            }\n        }\n        \n        return dist;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Edge { int  int cost) { this.to = to; this.cost = cost; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); sc.nextLine(); List<List<Edge>> graph = new ArrayList<>(); for (int i = 0; i <= n;  0; i < m; i++) {  parts = line.split(\",\"); int a = Integer.parseInt(parts[0]); int b = Integer.parseInt(parts[1]); int c = Integer.parseInt(parts[2]); int d = Integer.parseInt(parts[3]); graph.get(a).add(new Edge(b, c)); graph.get(b).add(new Edge(a, d)); } String[] lastLine = sc.nextLine().split(\",\"); int s  Integer.parseInt(lastLine[1]); int V = Integer.parseInt(lastLine[2]); int P = Integer.parseInt(lastLine[3]); int[] distToG = dijkstra(graph,  = dijkstra(graph, n, g, s); int minCost =  = V - P - minCost; System.out.println(reward);  graph, int n, int start, int end) { int[] dist = new int[n + 1]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; PriorityQueue<int[]>  -> a[1] - b[1]);   int u = curr[0]; int  > dist[u]) continue; for (Edge edge : graph.get(u)) { int   (newDist < dist[v]) { dist[v] = newDist; pq.offer(new int[]{v, newDist}); } } } return dist; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { /** * @param args */ public static  public static void main(String[] args) { doIt(); } public static void doIt(){ Scanner sc =  sc.nextInt(); //int[][] d  = sc.nextInt(); int[][] road = new  i < m; i++){ String s =  for(int  Integer.parseInt(ss[j]); } } int[] input = new int[4];  ss = s.split(\",\"); for(int j = 0; j < 4; j++){ input[j] = Integer.parseInt(ss[j]); } int start = input[0]; int goal = input[1]; //start\u304b\u3089goal\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u6c42\u3081\u308b //start\u304b\u3089\u306e\u8ddd\u96e2 int[] d = new int[n]; Arrays.fill(d, INF); d[start - 1] =  false; //\u9053\u3092\u898b\u3066\u3044\u304f for(int i = 0; i < m;  int  = road[i][2]; if(d[from - 1] !=  + cost < d[to - 1]){ d[to - 1]  } from = road[i][1]; to  if(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){ d[to - 1] =  bChange = true; } } //print(d); if(bChange == false) break; } int sum = d[goal - 1]; //\u4eca\u5ea6\u306f\u30b4\u30fc\u30eb\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2 start  Arrays.fill(d, INF); d[start - 1] = 0; while(true){ boolean bChange = false; //\u9053\u3092\u898b\u3066\u3044\u304f for(int i = 0; i < m; i++){ int from = road[i][0]; int to = road[i][1]; int cost = road[i][2]; if(d[from - 1] != INF && d[from - 1] + cost < d[to  + cost; bChange = true; } from = road[i][1]; to = road[i][0]; cost = road[i][3]; if(d[from - 1] != INF &&  < d[to - 1]){ d[to - 1] = d[from - 1] + cost; bChange  if(bChange == false) break; } //System.out.println(d[goal - 1]); sum += d[goal - 1]; System.out.println(input[2] - input[3] - sum); } public static void print(int[] d){ for(int  \" \"); } System.out.println(); } }"], "original_ll": -0.4383089244365692, "sampled_ll": -0.3426697552204132, "all_perturbed_sampled_ll": [-1.364006757736206], "all_perturbed_original_ll": [-1.3885270357131958], "perturbed_sampled_ll": -1.364006757736206, "perturbed_original_ll": -1.3885270357131958, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def floyd(P,m):\n    for k in range(m):\n        for i in range(m):\n            for j in range(m):\n                P[i][j]=min(P[i][j],P[i][k]+P[k][j])\n\nn=input()\nm=input()\nINF=1e10\nC=[[INF]*n for i in range(n)]\nfor i in range(n):\n    C[i][i]=0\nfor i in range(m):\n    a1,b1,c1,d1=map(int,raw_input().split(\",\"))\n    C[a1-1][b1-1]=c1\n    C[b1-1][a1-1]=d1\nfloyd(C,n)\nx1,x2,y1,y2=map(int,raw_input().split(\",\"))\nprint y1-y2-C[x1-1][x2-1]-C[x2-1][x1-1]", "sampled": "import sys\nfrom collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start, n):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, cost in graph[u]:\n            if dist[u] + cost < dist[v]:\n                dist[v] = dist[u] + cost\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist\n\nn = int(input())\nm = int(input())\n\ngraph_forward = defaultdict(list)\ngraph_backward = defaultdict(list)\n\nfor _ in range(m):\n    line = input().strip()\n    parts = line.split(',')\n    a = int(parts[0])\n    b = int(parts[1])\n    c = int(parts[2])\n    d = int(parts[3])\n    \n    graph_forward[a].append((b, c))\n    graph_backward[b].append((a, d))\n\nlast_line = input().strip()\nparts = last_line.split(',')\ns = int(parts[0])\ng = int(parts[1])\nV = int(parts[2])\nP = int(parts[3])\n\ndist_from_s = dijkstra(graph_forward, s, n)\ndist_from_g = dijkstra(graph_backward, g, n)\n\ntotal_cost = dist_from_s[g] + dist_from_g[s] + P\nreward = V - total_cost\n\nprint(reward)\n", "perturbed_sampled": ["import sys from collections import  start,  (n + 1) dist[start] = 0 pq = [(0, start)] while pq: d, u = heapq.heappop(pq) if d > dist[u]: continue for v, cost in graph[u]: if dist[u] +  dist[u] + cost heapq.heappush(pq, (dist[v], v)) return dist n = int(input()) m = int(input()) graph_forward = defaultdict(list) graph_backward = defaultdict(list) for _ in range(m): line = input().strip() parts =  = int(parts[1]) c  graph_forward[a].append((b, c)) graph_backward[b].append((a, d)) last_line =  = int(parts[0]) g = int(parts[1]) V = int(parts[2]) P =  n)  total_cost = dist_from_s[g] + dist_from_g[s] + P reward = V - total_cost print(reward)"], "perturbed_original": ["def <extra_id_2>print x1-x2,y1,y2-C[x1-1][y2]-y1 C[x2-1][y2-1]-B[b2-1][y2-1]; print for i in range(m): for j in range(m): P[i][j]=min(P[i][j],P[i][k]+P[k][j]) n=input() m=input() INF=1e10 C=[[INF]*n for i in range(n)] for i in  range(m): a1,b1,c1,d1=map(int,raw_input().split(\",\")) C[a1-1][b1-1]=c1 C[b1-1][a1-1]=d1 floyd(C,n) x1,x2,y1,y2=map(int,raw_input().split(\",\")) print y1-y2-C[x1-1][x2-1]-C[x2-1][x1-1]"], "original_ll": -0.7996338605880737, "sampled_ll": -0.5793449878692627, "all_perturbed_sampled_ll": [-2.0278244018554688], "all_perturbed_original_ll": [-1.7063617706298828], "perturbed_sampled_ll": -2.0278244018554688, "perturbed_original_ll": -1.7063617706298828, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\n#define MAX 100\nchar farm[MAX][MAX];\n\nvoid divide(int i, int j, int H, int W, char moji)\n{\n    if( farm[i][j] == moji ){\n        farm[i][j] = '+';\n        if( j + 1 < W ) divide(i, j + 1, H, W, moji);\n        if( i + 1 < H ) divide(i + 1, j, H, W, moji);\n        if( j - 1 >= 0 )divide(i, j - 1, H, W, moji);\n        if( i - 1 >= 0 )divide(i - 1, j, H, W, moji);\n    }\n}\n\nint main()\n{\n    int H, W, i, j, cnt;\n    while(1){\n        cnt = 0;\n        scanf(\"%d %d\", &H, &W);\n        if(H == 0 && W == 0) break;\n\n        for(i = 0; i < H; i++){\n            scanf(\"%s\", farm[i]);\n        }\n        for(i = 0; i < H; i++ ){\n            for(j = 0; j < W; j++){\n                if(farm[i][j] == '+') continue;\n                cnt++;\n                divide(i, j, H, W, farm[i][j]);\n            }\n        }\n        printf(\"%d\\n\", cnt);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nchar grid[100][101];\nint visited[100][100];\nint H, W;\n\nvoid dfs(int i, int j, char c) {\n    if (i < 0 || i >= H || j < 0 || j >= W) return;\n    if (visited[i][j]) return;\n    if (grid[i][j] != c) return;\n    \n    visited[i][j] = 1;\n    \n    dfs(i-1, j, c);\n    dfs(i+1, j, c);\n    dfs(i, j-1, c);\n    dfs(i, j+1, c);\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &H, &W);\n        if (H == 0 && W == 0) break;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        memset(visited, 0, sizeof(visited));\n        \n        int count = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (!visited[i][j]) {\n                    dfs(i, j, grid[i][j]);\n                    count++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> char grid[100][101]; int visited[100][100]; int H, W; void dfs(int i, int j, char c) { if (i < 0 || i >= H || j  return; if (grid[i][j]  1; dfs(i-1, j, c); dfs(i+1,  dfs(i,  scanf(\"%d %d\",  0 && W == 0) break; for  < H; i++) { scanf(\"%s\", grid[i]); } memset(visited, 0, sizeof(visited)); int count = 0; for (int i = 0; i < H; i++) { for (int j = 0; j < W; j++) { if (!visited[i][j]) { dfs(i, j, grid[i][j]); count++; } } } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include<stdio.h> #define (H, farm[i][j]);<extra_id_7>0; j++<extra_id_8>= [<extra_id_9>[j] ==<extra_id_10>{ farm[j] =<extra_id_11>} break;<extra_id_12>= j-1; j <<extra_id_13>farm[h]]=<extra_id_14>farm[h]); divide(int i,  W, char moji) { if( farm[i][j] == moji ){   H, W, moji); if( i + 1 < H ) divide(i + 1, j, H, W, moji); if( j - 1 >= 0 )divide(i, j - 1, H, W, moji); if( i - 1 >= 0 )divide(i - 1, j, H, W, moji); } } int main() { int H, W, i, j, cnt; while(1){  &H, &W); if(H == 0 && W  0; i < H; i++){ scanf(\"%s\", farm[i]); } for(i = 0; i < H; i++ ){ for(j  j++){ if(farm[i][j] == '+')  W, farm[i][j]); } } printf(\"%d\\n\", cnt); } return 0; }"], "original_ll": -0.5726313591003418, "sampled_ll": -0.2833107113838196, "all_perturbed_sampled_ll": [-1.1236202716827393], "all_perturbed_original_ll": [-2.0470876693725586], "perturbed_sampled_ll": -1.1236202716827393, "perturbed_original_ll": -2.0470876693725586, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\t\n\tint[][] offset = new int[][]{\n\t\t\t{-1, 0}, {1, 0}, {0, -1}, {0, 1}\n\t};\n\n\n\tpublic Main() throws IOException, StackOverflowError{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> Ans = new ArrayList<Integer>();\n\t\tString line = in.readLine();\n\t\tString[] dst = line.split(\" \");\n\t\tInteger.parseInt(dst[0]);\n\n\t\t\n\t}\n\n\tpublic void grouping(int[][] data, int[][] label, int x, int y){\n\t\tList<point> cue = new ArrayList<point>();\n\t\tcue.add(new point(x, y));\n\t\twhile(cue.size() != 0){\n\t\t\tpoint p = cue.get(0);\n\t\t\tcue.remove(0);\n\t\t\tfor(int d=0; d<4; d++){\n\t\t\t\tint xx = p.x + offset[d][0];\n\t\t\t\tint yy = p.y + offset[d][1];\n\t\t\t\tif(label[yy][xx] == 0 && data[yy][xx] == data[p.y][p.x]){\n\t\t\t\t\tlabel[yy][xx] = label[p.y][p.x];\n\t\t\t\t\tcue.add(new point(xx, yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass point{\n\tint x;\n\tint y;\n\t\n\tpublic point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int H, W;\n    static char[][] grid;\n    static boolean[][] visited;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            H = sc.nextInt();\n            W = sc.nextInt();\n            \n            if (H == 0 && W == 0) break;\n            \n            grid = new char[H][W];\n            visited = new boolean[H][W];\n            \n            for (int i = 0; i < H; i++) {\n                String line = sc.next();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            \n            int count = 0;\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (!visited[i][j]) {\n                        dfs(i, j, grid[i][j]);\n                        count++;\n                    }\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n    \n    static void dfs(int x, int y, char fruit) {\n        if (x < 0 || x >= H || y < 0 || y >= W) return;\n        if (visited[x][y]) return;\n        if (grid[x][y] != fruit) return;\n        \n        visited[x][y] = true;\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            dfs(nx, ny, fruit);\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int H, W; static  static int[] dx = {-1, 1, 0, 0}; static int[] dy  public  Scanner sc = new Scanner(System.in); while  (H == 0 && W == 0)  visited = new boolean[H][W]; for (int i = 0; i < H; i++) { String  j =  { grid[i][j] = line.charAt(j); } } int count = 0; for (int i = 0; i < H; i++) { for  if (!visited[i][j]) { dfs(i, j, grid[i][j]); count++; } } } System.out.println(count); }  x, int y, char fruit) { if (x < 0 || x >= H || y  W) return; if (visited[x][y]) return; if (grid[x][y] != fruit) return; visited[x][y] = true; for (int i = 0; i < 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; dfs(nx, ny, fruit); } } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static void main(String args[]){ try{ new Main();  int[][] offset = new int[][]{ {-1,  {0, 1}  new BufferedReader(new InputStreamReader(System.in)); List<Integer> Ans = new ArrayList<Integer>(); String line = in.readLine(); String[] dst = line.split(\" \"); Integer.parseInt(dst[0]); } public void grouping(int[][] data, int[][] label, int x, int y){ List<point> cue = new ArrayList<point>(); cue.add(new point(x, y)); while(cue.size() != 0){ point p  d<4; d++){ int xx = p.x + offset[d][0]; int  data[yy][xx] == data[p.y][p.x]){ label[yy][xx] = label[p.y][p.x]; cue.add(new point(xx, yy)); } } } } } class point{ int x; int y;  this.x = x; this.y = y; } }"], "original_ll": -0.8477228879928589, "sampled_ll": -0.22697803378105164, "all_perturbed_sampled_ll": [-1.2470617294311523], "all_perturbed_original_ll": [-1.7720041275024414], "perturbed_sampled_ll": -1.2470617294311523, "perturbed_original_ll": -1.7720041275024414, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def wa(h, w, f):\n    if not (0 <= h <= H-1 and 0 <= w <= W-1):\n        return\n    elif mapp[h][w] != f:\n        return\n    else:\n        mapp[h][w] = '$'\n        wa(h, w+1, f)\n        wa(h-1, w, f)\n        wa(h, w-1, f)\n        wa(h+1, w, f)\n\nwhile True:\n    H, W = map(int, raw_input().split(' '))\n    if H == 0: break\n    mapp = [list(raw_input()) for i in range(H)]\n    count = 0\n    for h in range(H):\n        for w in range(W):\n            if mapp[h][w] == '@':\n                wa(h, w, '@')\n            elif mapp[h][w] == '#':\n                wa(h, w, '#')\n            elif mapp[h][w] == '*':\n                wa(h, w, '*')\n            else:\n                continue\n            count += 1\n    else:\n        print count", "sampled": "def count_regions(H, W, grid):\n    visited = [[False] * W for _ in range(H)]\n    count = 0\n    \n    def dfs(i, j, fruit_type):\n        if i < 0 or i >= H or j < 0 or j >= W:\n            return\n        if visited[i][j]:\n            return\n        if grid[i][j] != fruit_type:\n            return\n        \n        visited[i][j] = True\n        dfs(i-1, j, fruit_type)\n        dfs(i+1, j, fruit_type)\n        dfs(i, j-1, fruit_type)\n        dfs(i, j+1, fruit_type)\n    \n    for i in range(H):\n        for j in range(W):\n            if not visited[i][j]:\n                dfs(i, j, grid[i][j])\n                count += 1\n    \n    return count\n\nwhile True:\n    line = input().split()\n    H, W = int(line[0]), int(line[1])\n    \n    if H == 0 and W == 0:\n        break\n    \n    grid = []\n    for _ in range(H):\n        grid.append(input().strip())\n    \n    result = count_regions(H, W, grid)\n    print(result)\n", "perturbed_sampled": ["def count_regions(H, W, grid): visited = [[False] * W for _ in range(H)] count = 0 def dfs(i, j, fruit_type): if i  H or j  W: return if visited[i][j]: return if grid[i][j] !=  dfs(i-1, j, fruit_type) dfs(i+1, j, fruit_type) dfs(i, j-1, fruit_type) dfs(i, j+1, fruit_type) for i in range(H): for j in range(W): if not  += 1 return count while True: line = input().split() H, W =  0 and W == 0: break grid = [] for _ in  W, grid) print(result)"], "perturbed_original": ["def wa(h, w, f): if not (0 <= h <= H-1 and 0 <= w  != f: return else: mapp[h][w] =  w, f)  f)  H == 0: break mapp = [list(raw_input()) for i in range(H)] count = 0 for h in range(H): for w in range(W): if mapp[h][w] == '@': wa(h, w, '@') elif mapp[h][w] == '#': wa(h, w, '#') elif mapp[h][w] == '*': wa(h, w, '*') else: continue count += 1 else: print count"], "original_ll": -0.7019229531288147, "sampled_ll": -0.3945903480052948, "all_perturbed_sampled_ll": [-1.6222811937332153], "all_perturbed_original_ll": [-1.7175782918930054], "perturbed_sampled_ll": -1.6222811937332153, "perturbed_original_ll": -1.7175782918930054, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0119\nTitle Taro's obsession\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define SHOUGENNO 100\n#define NINZUU 20\nint n,m;\nint x[SHOUGENNO],y[SHOUGENNO];\nint flag[NINZUU+1];\n//\nvoid show()\n{\n  int i;\n  for(i=1;i<=n;i++)\n    printf(\"%d:\",flag[i]);\n  printf(\"\\n\");\n}\nmain()\n{\n  int i,cnt;\n\n  scanf(\"%d \",&n);\n  scanf(\"%d \",&m);\n  for(i=0;i<m;i++)\n    scanf(\"%d %d\",&x[i],&y[i]);\n  for(i=0;i<n;i++)\n    flag[i]=0;\n\n  cnt=n;\n\n  while(cnt>1)\n    {\n      for(i=1;i<=n;i++)\n\tif(flag[i]>0)\n\t  flag[i]=0;\n      //show();\n      for(i=0;i<m;i++)\n\tif(flag[x[i]]!=-1)\n\t  flag[y[i]]=1;\n      for(i=1;i<=n;i++)\n\t{\n\t  if(flag[i]==0 && i!=2)\n\t    {\n\t      printf(\"%d\\n\",i);\n\t      cnt--;\n\t      flag[i]=-1;\n\t    }\n\t}\n      //show();\n    }\n  printf(\"2\\n\");\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int m, n;\n    scanf(\"%d\", &m);\n    scanf(\"%d\", &n);\n    \n    int adj[21][21] = {0};\n    int indegree[21] = {0};\n    \n    for (int i = 0; i < n; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        if (!adj[x][y]) {\n            adj[x][y] = 1;\n            indegree[y]++;\n        }\n    }\n    \n    int result[21];\n    int used[21] = {0};\n    int pos = 0;\n    \n    while (pos < m) {\n        for (int i = 1; i <= m; i++) {\n            if (used[i]) continue;\n            if (indegree[i] == 0) {\n                result[pos++] = i;\n                used[i] = 1;\n                for (int j = 1; j <= m; j++) {\n                    if (adj[i][j]) {\n                        indegree[j]--;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    \n    for (int i = 0; i < m; i++) {\n        printf(\"%d\\n\", result[i]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h>  int m, n; scanf(\"%d\", &m); scanf(\"%d\", &n); int adj[21][21] = {0}; int indegree[21] = {0}; for (int i = 0; i < n; i++)  %d\", &x, &y); if (!adj[x][y]) { adj[x][y] = 1; indegree[y]++; } } int result[21]; int  = 0; while (pos <   i++) { if (used[i]) continue; if (indegree[i] ==  (int j = 1; j <= m; j++) { if (adj[i][j]) { indegree[j]--; } } break; } } } for (int i = 0; i < m; i++) { printf(\"%d\\n\", result[i]); } return 0; }"], "perturbed_original": ["/* AizuOnline A0119  <stdio.h> // Select Below //#include <stdlib.h> //#include <string.h> //#include <float.h> //#include <math.h> //#include <limits.h> //Global data section #define SHOUGENNO 100 #define NINZUU 20 int n,m; int x[SHOUGENNO],y[SHOUGENNO]; int flag[NINZUU+1]; // void show() { int i; for(i=1;i<=n;i++) printf(\"%d:\",flag[i]);  i,cnt; scanf(\"%d \",&n); scanf(\"%d \",&m); for(i=0;i<m;i++) scanf(\"%d %d\",&x[i],&y[i]);  for(i=1;i<=n;i++) if(flag[i]>0) flag[i]=0; //show(); for(i=0;i<m;i++) if(flag[x[i]]!=-1) flag[y[i]]=1;  { printf(\"%d\\n\",i); cnt--; flag[i]=-1;  return(0); }"], "original_ll": -1.4016071557998657, "sampled_ll": -0.3959541916847229, "all_perturbed_sampled_ll": [-1.2632540464401245], "all_perturbed_original_ll": [-1.8955422639846802], "perturbed_sampled_ll": -1.2632540464401245, "perturbed_original_ll": -1.8955422639846802, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n    \npublic class Main {\n    public static void main(String[] args) {\n        (new Main()).execute();\n    }\n    private void execute() {\n        Scanner sc = new Scanner(System.in);\n\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        ObsessionComparator comp = new ObsessionComparator(m);\n        for(int i = 0 ; i < n ; i++) {comp.add(sc.nextInt(), sc.nextInt());}\n        \n        Integer[] list = new Integer[m];\n        for(int i = 0 ; i < m ; i++) {list[i] = Integer.valueOf(i+1);}\n        \n        Arrays.sort(list, comp);\n        \n        for(Integer i : list){System.out.println(i);}\n        sc.close();\n    }\n    \n    private class ObsessionComparator implements Comparator<Integer> {\n    \tprivate Map<Integer, Set<Integer>> sortMap = new HashMap<Integer, Set<Integer>>();\n    \tprivate ObsessionComparator(int count) {\n    \t\tfor(int i = 1 ; i <= count ; i++) {\n    \t\t\tsortMap.put(Integer.valueOf(i), new HashSet<Integer>());\n    \t\t}\n    \t}\n\n    \tprivate void add(Integer x, Integer y) {\n    \t\tsortMap.get(x).add(y);\n    \t}\n    \tprivate boolean isSorted(Integer x, Integer y) {\n    \t\tif(sortMap.get(x).contains(y)) {\n    \t\t\treturn true;\n    \t\t} else if(sortMap.get(x).isEmpty()) {\n    \t\t\treturn false;\n    \t\t} else {\n    \t\t\tfor(Integer next : sortMap.get(x)) {\n    \t\t\t\tif(isSorted(next, y)){\n    \t\t\t\t\treturn true;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn false;\n    \t\t}\n    \t}\n    \t\n    \t@Override\n\t\tpublic int compare(Integer arg0, Integer arg1) {\n    \t\treturn isSorted(arg0, arg1) ? -1 : 1;\n\t\t}\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        \n        List<List<Integer>> graph = new ArrayList<>();\n        int[] indegree = new int[m + 1];\n        \n        for (int i = 0; i <= m; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            graph.get(x).add(y);\n            indegree[y]++;\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 1; i <= m; i++) {\n            if (indegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            result.add(current);\n            \n            for (int next : graph.get(current)) {\n                indegree[next]--;\n                if (indegree[next] == 0) {\n                    queue.offer(next);\n                }\n            }\n        }\n        \n        for (int suspect : result) {\n            System.out.println(suspect);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); List<List<Integer>>  indegree = new int[m + 1]; for (int i = 0; i <= m; i++) { graph.add(new ArrayList<>()); } for (int i =  { int x = sc.nextInt(); int y = sc.nextInt(); graph.get(x).add(y); indegree[y]++; } Queue<Integer> queue = new LinkedList<>(); for  <=  == 0) {  = new  current = queue.poll(); result.add(current); for (int next : graph.get(current))  } } for (int suspect : result) { System.out.println(suspect); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Comparator; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Scanner; import java.util.Set; public class Main { public static void main(String[] args)  void execute()  Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); ObsessionComparator comp = new ObsessionComparator(m); for(int i = 0 ; i < n ; i++) {comp.add(sc.nextInt(), sc.nextInt());} Integer[] list = new Integer[m]; for(int i =  ; i++) {list[i] = Integer.valueOf(i+1);} Arrays.sort(list, comp); for(Integer i : list){System.out.println(i);} sc.close(); } private class ObsessionComparator implements  sortMap = new HashMap<Integer, Set<Integer>>(); private ObsessionComparator(int count) {  i <= count ; i++) { sortMap.put(Integer.valueOf(i), new HashSet<Integer>()); } } private void add(Integer x, Integer y) { sortMap.get(x).add(y); } private boolean isSorted(Integer x, Integer  true; } else if(sortMap.get(x).isEmpty())  sortMap.get(x)) { if(isSorted(next, y)){  false; } } @Override public  { return isSorted(arg0, arg1) ? -1 : 1; } } }"], "original_ll": -0.726981520652771, "sampled_ll": -0.29570454359054565, "all_perturbed_sampled_ll": [-1.4158713817596436], "all_perturbed_original_ll": [-1.6800907850265503], "perturbed_sampled_ll": -1.4158713817596436, "perturbed_original_ll": -1.6800907850265503, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def solve(a):\n\tif len(a) == m: return a\n\tfor i in M-set(a):\n\t\tfor x,y in xy:\n\t\t\tif x == i and y not in a: break\n\t\telse:\n\t\t\tr = solve([i]+a)\n\t\t\tif r: return r\nm = input()\nM = set(range(1,m+1))\nxy = [map(int,raw_input().split()) for i in range(input())]\nfor i in solve([]): print i", "sampled": "from collections import defaultdict, deque\n\ndef topological_sort(m, edges):\n    # Build adjacency list and in-degree count\n    graph = defaultdict(list)\n    in_degree = [0] * (m + 1)\n    \n    for x, y in edges:\n        graph[x].append(y)\n        in_degree[y] += 1\n    \n    # Find all nodes with in-degree 0\n    queue = deque()\n    for i in range(1, m + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    result = []\n    while queue:\n        # Pick the smallest numbered node (for consistency)\n        queue = deque(sorted(queue))\n        node = queue.popleft()\n        result.append(node)\n        \n        # Reduce in-degree for neighbors\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result\n\n# Read input\nm = int(input())\nn = int(input())\nedges = []\nfor _ in range(n):\n    x = int(input())\n    y = int(input())\n    edges.append((x, y))\n\n# Perform topological sort\norder = topological_sort(m, edges)\n\n# Output result\nfor suspect in order:\n    print(suspect)\n", "perturbed_sampled": ["from collections import defaultdict, deque def topological_sort(m, edges): # Build adjacency list and in-degree count graph =  (m + 1) for x, y in edges: graph[x].append(y) in_degree[y] += 1 # Find all nodes with  for i in range(1, m + 1): if in_degree[i] == 0:   numbered node (for consistency) queue = deque(sorted(queue)) node = queue.popleft()  neighbors for neighbor in graph[node]: in_degree[neighbor] -= 1 if   = int(input()) n = int(input()) edges = [] for _ in range(n): x = int(input()) y =  topological sort order = topological_sort(m, edges) # Output result for suspect in order: print(suspect)"], "perturbed_original": ["def solve(a):  a for i in M-set(a): for x,y in xy: if x == i and y not in  solve([i]+a)  = input() M = set(range(1,m+1)) xy = [map(int,raw_input().split()) for i in range(input())] for i in solve([]): print i"], "original_ll": -1.5008050203323364, "sampled_ll": -0.6565148234367371, "all_perturbed_sampled_ll": [-2.224100112915039], "all_perturbed_original_ll": [-2.56265926361084], "perturbed_sampled_ll": -2.224100112915039, "perturbed_original_ll": -2.56265926361084, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define SQ(x) ((x) * (x))\n#define INF (100000000)\n#define EPS (1e-5)\n\ndouble len;\ndouble cake[12];\ndouble dp[1 << 12][12];\nint n;\n\ndouble min(double a, double b)\n{\n    return (b > a ? a : b);\n}\n\ndouble tsp(int bit, int now)\n{\n    int i;\n    double res;\n    \n    if (dp[bit][now] >= 0){\n        return (dp[bit][now]);\n    }\n    \n    if (bit == (1 << n) - 1 && now == 0){\n        return (dp[bit][now] = 0);\n    }\n    \n    res = INF;\n    for (i = 0; i < n; i++){\n        if (!((bit >> i) & 1)){\n            res = min(res, tsp(bit | (1 << i), i) + sqrt(SQ(cake[i] + cake[now]) - SQ(cake[i] - cake[now])));\n        }\n    }\n    \n    return (dp[bit][now] = res);\n}\n\nint main(void)\n{\n    int i, j;\n    \n    while (scanf(\"%lf\", &len) != EOF){\n        getchar();\n        n = 0;\n        while (1){\n            scanf(\"%lf\", &cake[n++]);\n            \n            if (getchar() == '\\n'){\n                break;\n            }\n        }\n        \n        for (i = 0; i < (1 << 12); i++){\n            for (j = 0; j < 12; j++){\n                dp[i][j] = -1 * INF;\n            }\n        }\n        \n        if (tsp(0, 0) < len + EPS){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\nint n;\nint r[12];\nint perm[12];\nint used[12];\ndouble W;\n\ndouble calc_width(int *order, int len) {\n    if (len == 0) return 0;\n    if (len == 1) return 2.0 * r[order[0]];\n    \n    double pos[12];\n    pos[0] = r[order[0]];\n    \n    for (int i = 1; i < len; i++) {\n        double max_pos = r[order[i]];\n        \n        for (int j = 0; j < i; j++) {\n            double ri = r[order[i]];\n            double rj = r[order[j]];\n            double d = 2.0 * sqrt(ri * rj);\n            double candidate = pos[j] + d;\n            if (candidate > max_pos) {\n                max_pos = candidate;\n            }\n        }\n        \n        pos[i] = max_pos;\n    }\n    \n    double max_right = 0;\n    for (int i = 0; i < len; i++) {\n        double right = pos[i] + r[order[i]];\n        if (right > max_right) {\n            max_right = right;\n        }\n    }\n    \n    return max_right;\n}\n\nint try_permutation(int depth) {\n    if (depth == n) {\n        double width = calc_width(perm, n);\n        return width <= W + 1e-9;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!used[i]) {\n            used[i] = 1;\n            perm[depth] = i;\n            if (try_permutation(depth + 1)) {\n                return 1;\n            }\n            used[i] = 0;\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    char line[1000];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        n = 0;\n        char *token = strtok(line, \" \\n\");\n        W = atof(token);\n        \n        while ((token = strtok(NULL, \" \\n\")) != NULL) {\n            r[n++] = atoi(token);\n        }\n        \n        if (n == 0) continue;\n        \n        memset(used, 0, sizeof(used));\n        \n        if (try_permutation(0)) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include  int r[12]; int perm[12]; int used[12]; double W; double calc_width(int *order, int len) { if (len == 0) return 0; if (len == 1) return 2.0 *  r[order[0]]; for (int i = 1;  double max_pos = r[order[i]]; for (int j = 0; j < i; j++)   sqrt(ri * rj); double candidate = pos[j] + d; if (candidate > max_pos) { max_pos = candidate; } } pos[i] = max_pos; } double max_right = 0; for (int i = 0; i < len; i++) {  right; } } return max_right; } int try_permutation(int depth)  { double width = calc_width(perm, n); return width <= W + 1e-9; } for (int i = 0; i < n; i++) { if (!used[i]) { used[i] = 1; perm[depth] = i; if (try_permutation(depth + 1)) { return 1; } used[i] = 0; } } return 0; } int main() { char line[1000]; while (fgets(line, sizeof(line), stdin)) { n = 0; char *token  = atof(token); while ((token = strtok(NULL,   (n == 0) continue;  { printf(\"OK\\n\"); } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": [" <math.h> #define SQ(x)  (100000000) #define EPS (1e-5) double len; double cake[12]; double dp[1 << 12][12]; int n; double min(double  a : b); } double tsp(int bit, int now) { int i; double res; if (dp[bit][now] >= 0){ return (dp[bit][now]); } if (bit == (1 << n) - 1 && now  INF; for (i = 0; i < n; i++){ if (!((bit  = min(res, tsp(bit | (1 << i), i) + sqrt(SQ(cake[i]  cake[now]))); } } return (dp[bit][now] = res); } int main(void) { int  != EOF){ getchar(); n = 0; while (1){ scanf(\"%lf\", &cake[n++]); if (getchar() == '\\n'){ break; } } for (i = 0; i < (1 << 12); i++){ for (j = 0; j < 12; j++){ dp[i][j] = -1 * INF;   } else { printf(\"NA\\n\"); } } return (0); }"], "original_ll": -0.6855278611183167, "sampled_ll": -0.5793856382369995, "all_perturbed_sampled_ll": [-1.5710020065307617], "all_perturbed_original_ll": [-1.6196709871292114], "perturbed_sampled_ll": -1.5710020065307617, "perturbed_original_ll": -1.6196709871292114, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tArrayList<String> Ans = new ArrayList<String>();\n\t\tString line;\n\n\t\twhile((line = in.readLine()) != null){\n\t\t\tString[] dst = line.split(\" \");\n\t\t\tint size = Integer.parseInt(dst[0]);\n\n\t\t\tif(size == 0) break;\n\t\t\tint[] seq = new int[dst.length-1];\n\t\t\tint[] radius = new int[dst.length-1];\n\t\t\tfor(int i=1; i<dst.length; i++){\n\t\t\t\tradius[i-1] = Integer.parseInt(dst[i]);\n\t\t\t}\n\n\t\t\tfor(int i=0; i<dst.length-1; i++){\n\t\t\t\tseq[i] = i;\n\t\t\t}\n\n\t\t\tint ok = 0;\n\t\t\tdo{\n//\t\t\t\tfor(int i=0; i<seq.length; i++){\n//\t\t\t\t\tSystem.out.print(seq[i]);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\n\t\t\t\tdouble cakes = calcSize(radius, seq);\n\t\t\t\tif(size >= cakes){\n\t\t\t\t\tAns.add(\"OK\");\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}while(nextArray(seq));\n\n\t\t\tif(ok == 0){\n\t\t\t\tAns.add(\"NA\");\n\t\t\t}\n\t\t}\n\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tSystem.out.println(Ans.get(n));\n\t\t}\n\t}\n\n\tpublic boolean nextArray(int[] seq){\n\t\tint s = seq.length-1;\n\t\twhile(true){\n\t\t\tif(seq[s] > seq[s-1]){\n\t\t\t\tint min = seq[s];\n\t\t\t\tint index = s;\n\t\t\t\tfor(int n=s+1; n<seq.length; n++){\n\t\t\t\t\tif(min > seq[n] && seq[n] > seq[s-1]){\n\t\t\t\t\t\tmin = seq[n];\n\t\t\t\t\t\tindex = n;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tseq[index] = seq[s-1];\n\t\t\t\tseq[s-1] = min;\n\t\t\t\tArrays.sort(seq, s, seq.length-1);\n\t\t\t\treturn true;\n\n\t\t\t}else{\n\t\t\t\ts--;\n\t\t\t}\n\n\t\t\tif(s == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic double calcSize(int[] data, int[] seq){\n\t\tdouble sum = 0.0;\n\t\t\n\t\t\n\t\treturn sum;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static double EPS = 1e-9;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) continue;\n            \n            String[] parts = line.split(\"\\\\s+\");\n            int W = Integer.parseInt(parts[0]);\n            \n            List<Integer> radii = new ArrayList<>();\n            for (int i = 1; i < parts.length; i++) {\n                radii.add(Integer.parseInt(parts[i]));\n            }\n            \n            int n = radii.size();\n            if (n == 0) {\n                System.out.println(\"OK\");\n                continue;\n            }\n            \n            boolean found = false;\n            int[] perm = new int[n];\n            for (int i = 0; i < n; i++) {\n                perm[i] = i;\n            }\n            \n            do {\n                double width = calculateWidth(radii, perm);\n                if (width <= W + EPS) {\n                    found = true;\n                    break;\n                }\n            } while (nextPermutation(perm));\n            \n            System.out.println(found ? \"OK\" : \"NA\");\n        }\n        \n        sc.close();\n    }\n    \n    static double calculateWidth(List<Integer> radii, int[] perm) {\n        int n = perm.length;\n        if (n == 0) return 0;\n        if (n == 1) return 2.0 * radii.get(perm[0]);\n        \n        double[] positions = new double[n];\n        positions[0] = radii.get(perm[0]);\n        \n        for (int i = 1; i < n; i++) {\n            double maxPos = radii.get(perm[i]);\n            \n            for (int j = 0; j < i; j++) {\n                double r1 = radii.get(perm[j]);\n                double r2 = radii.get(perm[i]);\n                double dist = 2.0 * Math.sqrt(r1 * r2);\n                double pos = positions[j] + dist;\n                maxPos = Math.max(maxPos, pos);\n            }\n            \n            positions[i] = maxPos;\n        }\n        \n        double minX = Double.MAX_VALUE;\n        double maxX = -Double.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            double r = radii.get(perm[i]);\n            minX = Math.min(minX, positions[i] - r);\n            maxX = Math.max(maxX, positions[i] + r);\n        }\n        \n        return maxX - minX;\n    }\n    \n    static boolean nextPermutation(int[] array) {\n        int i = array.length - 2;\n        while (i >= 0 && array[i] >= array[i + 1]) {\n            i--;\n        }\n        \n        if (i < 0) {\n            return false;\n        }\n        \n        int j = array.length - 1;\n        while (array[j] <= array[i]) {\n            j--;\n        }\n        \n        swap(array, i, j);\n        reverse(array, i + 1, array.length - 1);\n        \n        return true;\n    }\n    \n    static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    \n    static void reverse(int[] array, int start, int end) {\n        while (start < end) {\n            swap(array, start, end);\n            start++;\n            end--;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static double EPS = 1e-9; public static void  = new Scanner(System.in);  = sc.nextLine().trim(); if (line.isEmpty()) continue; String[] parts = line.split(\"\\\\s+\");  radii  i = 1; i  } int n = radii.size(); if (n == 0) {  = new int[n]; for (int i = 0; i < n; i++) { perm[i] = i; } do { double width = calculateWidth(radii, perm); if (width <= W + EPS) { found = true; break; } } while (nextPermutation(perm)); System.out.println(found ? \"OK\" :  double calculateWidth(List<Integer> radii, int[] perm)  if (n == 0) return 0; if (n == 1) return  = radii.get(perm[0]); for (int i = 1; i < n; i++) { double maxPos = radii.get(perm[i]); for (int j = 0; j < i; j++) { double r1 = radii.get(perm[j]); double r2 = radii.get(perm[i]); double dist = 2.0  pos = positions[j] + dist; maxPos =  maxPos; } double  = -Double.MAX_VALUE; for (int  n; i++) { double r = radii.get(perm[i]); minX = Math.min(minX, positions[i] - r); maxX = Math.max(maxX, positions[i] + r); } return maxX - minX; } static boolean nextPermutation(int[] array) { int i = array.length - 2; while (i >= 0 && array[i] >= array[i +  (i < 0) { return false; } int j = array.length - 1; while (array[j] <= array[i]) { j--; } swap(array,   true; } static void swap(int[] array, int i, int j)  array[i] = array[j]; array[j] = temp; } static void reverse(int[] array,  while (start <  start++; end--; } } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static void main(String args[]){ try{ new Main(); }catch(IOException err){ err.printStackTrace(); } } public Main() throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); ArrayList<String> Ans = new ArrayList<String>(); String line; while((line = in.readLine()) != null){ String[] dst = line.split(\" \"); int size =  int[]  for(int i=0; i<dst.length-1; i++){ seq[i] = i; } int  // System.out.print(seq[i]); // } // System.out.println(); double cakes = calcSize(radius, seq); if(size >= cakes){ Ans.add(\"OK\"); ok = 1; break;  Ans.add(\"NA\"); } } for(int n=0; n<Ans.size(); n++){ System.out.println(Ans.get(n)); } }  s = seq.length-1; while(true){ if(seq[s] > seq[s-1]){ int min = seq[s]; int index = s; for(int n=s+1; n<seq.length;  seq[n] > seq[s-1]){ min = seq[n]; index =  seq[s-1]; seq[s-1] = min; Arrays.sort(seq, s, seq.length-1); return  == 0){ return false; } } } public double calcSize(int[] data, int[] seq){ double sum = 0.0; return sum; } }"], "original_ll": -0.726965606212616, "sampled_ll": -0.37368282675743103, "all_perturbed_sampled_ll": [-1.3938446044921875], "all_perturbed_original_ll": [-1.6888737678527832], "perturbed_sampled_ll": -1.3938446044921875, "perturbed_original_ll": -1.6888737678527832, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0120\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\ndef calc_width(cakes):\n    # ??\u00b1????????????????????????(?????????)????????????????????????????????????????\u00a8??????????\n    if len(cakes) == 1:\n        return cakes[0]*2\n\n    prev_r = cakes[0]\n    width = prev_r\n\n    for r in cakes[1:]:\n        h_diff = abs(prev_r - r)\n        w = ((prev_r + r)**2 - h_diff**2)**0.5\n        width += w\n        prev_r = r\n    width += cakes[-1]\n\n    return width\n\n\ndef main(args):\n    for line in sys.stdin:\n        data = [int(x) for x in line.strip().split()]\n        box_size = data[0]\n        temp = data[1:]\n        temp.sort()\n\n        # ??\u00b1??????????????????????????????????????????????????????????????????????????????\n        min_width = float('inf')\n\n        cakes = [temp[0]]\n        temp = temp[1:]\n        pick_large = True\n        while temp:\n            if pick_large:\n                pick = temp[-1]\n                temp = temp[:-1]\n                pick_large = False\n                diff_front = abs(pick - cakes[0])\n                diff_rear = abs(pick - cakes[-1])\n                if diff_front > diff_rear:\n                    cakes.insert(0, pick)\n                else:\n                    cakes.append(pick)\n            else:\n                pick = temp[0]\n                temp = temp[1:]\n                pick_large = True\n                diff_front = abs(pick - cakes[0])\n                diff_rear = abs(pick - cakes[-1])\n                if diff_front > diff_rear:\n                    cakes.insert(0, pick)\n                else:\n                    cakes.append(pick)\n\n        result = calc_width(cakes)\n        min_width = min(result, min_width)\n\n        if min_width <= box_size:\n            print('OK')\n        else:\n            print('NA')\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    ", "sampled": "import sys\nimport math\nfrom itertools import permutations\n\ndef calc_distance(r1, r2):\n    # Distance between centers of two circles touching each other and both touching the bottom\n    return 2 * math.sqrt(r1 * r2)\n\ndef calc_width(radii):\n    if len(radii) == 0:\n        return 0\n    if len(radii) == 1:\n        return 2 * radii[0]\n    \n    # Position circles one by one\n    positions = [radii[0]]  # x-coordinate of center of each circle\n    \n    for i in range(1, len(radii)):\n        # Find the rightmost position where circle i can be placed\n        min_x = radii[i]  # At least this far from left wall\n        \n        for j in range(i):\n            # Must be at least calc_distance away from circle j\n            required_dist = calc_distance(radii[i], radii[j])\n            min_x = max(min_x, positions[j] + required_dist)\n        \n        positions.append(min_x)\n    \n    # Total width is rightmost position + its radius\n    return positions[-1] + radii[-1]\n\ndef solve(W, radii):\n    n = len(radii)\n    \n    if n == 0:\n        return \"OK\"\n    \n    # Try all permutations\n    for perm in permutations(radii):\n        width = calc_width(list(perm))\n        if width <= W:\n            return \"OK\"\n    \n    return \"NA\"\n\nfor line in sys.stdin:\n    parts = list(map(int, line.strip().split()))\n    W = parts[0]\n    radii = parts[1:]\n    print(solve(W, radii))\n", "perturbed_sampled": ["import sys import math from itertools  # Distance between centers of two circles touching each other and both touching the bottom return 2 * math.sqrt(r1 * r2) def calc_width(radii): if len(radii) == 0: return 0  Position circles one by one positions = [radii[0]] # x-coordinate of center of each circle for i in range(1, len(radii)):  where circle i can   from left wall  Must be at least calc_distance away from  radii[j]) min_x = max(min_x, positions[j] + required_dist) positions.append(min_x) # Total width is rightmost position + its radius return positions[-1] +  = len(radii) if n == 0: return \"OK\" # Try all permutations for perm in permutations(radii): width =  return \"OK\" return \"NA\" for line in sys.stdin: parts = list(map(int, line.strip().split())) W = parts[0] radii = parts[1:] print(solve(W, radii))"], "perturbed_original": ["# -*- coding: utf-8 -*-  from sys import stdin input = stdin.readline def calc_width(cakes): # ??\u00b1????????????????????????(?????????)????????????????????????????????????????\u00a8?????????? if len(cakes) == 1: return cakes[0]*2 prev_r = cakes[0] width =  width += w prev_r = r width += cakes[-1] return width def main(args): for line in sys.stdin: data  line.strip().split()] box_size = data[0] temp = data[1:] temp.sort() # ??\u00b1?????????????????????????????????????????????????????????????????????????????? min_width = float('inf') cakes = [temp[0]] temp = temp[1:] pick_large = True while temp: if pick_large: pick = temp[-1] temp = temp[:-1] pick_large = False diff_front = abs(pick -  cakes[-1]) if diff_front > diff_rear:  pick = temp[0] temp =  =  abs(pick - cakes[-1]) if diff_front > diff_rear: cakes.insert(0, pick) else: cakes.append(pick) result = calc_width(cakes) min_width = min(result, min_width) if min_width <= box_size: print('OK') else: print('NA') if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -0.9871365427970886, "sampled_ll": -0.9655501246452332, "all_perturbed_sampled_ll": [-2.5067217350006104], "all_perturbed_original_ll": [-1.7795535326004028], "perturbed_sampled_ll": -2.5067217350006104, "perturbed_original_ll": -1.7795535326004028, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<cstdlib>\n\nusing namespace std;\n\n#define maxn 305\n\nint map[3][5];\n\nint main()\n{\n\tint i,j;\ncin>>i;\ncout<<1<<endl;\n\n\n\treturn 0;\n}\n\n", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_STATES 362880\n\ntypedef struct {\n    int state[8];\n    int dist;\n} Node;\n\nint visited[MAX_STATES];\nNode queue[MAX_STATES];\nint front, rear;\n\nint encode(int state[8]) {\n    int code = 0;\n    int base = 1;\n    for (int i = 7; i >= 0; i--) {\n        int digit = state[i];\n        for (int j = i + 1; j < 8; j++) {\n            if (state[j] < state[i]) digit--;\n        }\n        code += digit * base;\n        base *= (8 - i);\n    }\n    return code;\n}\n\nint bfs(int start[8]) {\n    memset(visited, -1, sizeof(visited));\n    front = rear = 0;\n    \n    memcpy(queue[rear].state, start, sizeof(int) * 8);\n    queue[rear].dist = 0;\n    rear++;\n    \n    int start_code = encode(start);\n    visited[start_code] = 0;\n    \n    int goal[8] = {0, 1, 2, 3, 4, 5, 6, 7};\n    int goal_code = encode(goal);\n    \n    if (start_code == goal_code) return 0;\n    \n    while (front < rear) {\n        Node current = queue[front++];\n        \n        int pos0 = -1;\n        for (int i = 0; i < 8; i++) {\n            if (current.state[i] == 0) {\n                pos0 = i;\n                break;\n            }\n        }\n        \n        int row = pos0 / 4;\n        int col = pos0 % 4;\n        \n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n        \n        for (int d = 0; d < 4; d++) {\n            int new_row = row + dr[d];\n            int new_col = col + dc[d];\n            \n            if (new_row >= 0 && new_row < 2 && new_col >= 0 && new_col < 4) {\n                int new_pos = new_row * 4 + new_col;\n                \n                int new_state[8];\n                memcpy(new_state, current.state, sizeof(int) * 8);\n                \n                int temp = new_state[pos0];\n                new_state[pos0] = new_state[new_pos];\n                new_state[new_pos] = temp;\n                \n                int new_code = encode(new_state);\n                \n                if (visited[new_code] == -1) {\n                    visited[new_code] = current.dist + 1;\n                    \n                    if (new_code == goal_code) {\n                        return current.dist + 1;\n                    }\n                    \n                    memcpy(queue[rear].state, new_state, sizeof(int) * 8);\n                    queue[rear].dist = current.dist + 1;\n                    rear++;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int state[8];\n    \n    while (scanf(\"%d\", &state[0]) == 1) {\n        for (int i = 1; i < 8; i++) {\n            scanf(\"%d\", &state[i]);\n        }\n        \n        int result = bfs(state);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  #define MAX_STATES 362880 typedef struct { int state[8]; int dist; }  encode(int state[8]) { int code = 0; int  i = 7; i >= 0; i--) { int digit = state[i]; for (int j = i + 1; j < 8;  state[i]) digit--; } code += digit * base; base  bfs(int start[8]) { memset(visited, -1, sizeof(visited));  memcpy(queue[rear].state, start, sizeof(int) * 8); queue[rear].dist =  encode(start); visited[start_code] = 0; int goal[8] = {0, 1, 2, 3, 4, 5, 6, 7}; int   (front < rear) { Node current = queue[front++]; int pos0 = -1; for (int i = 0; i < 8; i++) { if (current.state[i] == 0) { pos0 = i; break; } } int row = pos0 / 4; int  int dr[] = {-1, 1, 0, 0}; int dc[] = {0, 0, -1, 1}; for (int d = 0; d < 4; d++) { int new_row = row + dr[d]; int new_col = col + dc[d]; if (new_row >=  && new_col  4) { int new_pos = new_row * 4 + new_col;  * 8); int temp = new_state[pos0]; new_state[pos0] = new_state[new_pos]; new_state[new_pos] = temp; int new_code = encode(new_state); if (visited[new_code] == -1) { visited[new_code] = current.dist + 1; if (new_code == goal_code) { return current.dist + 1; } memcpy(queue[rear].state, new_state, sizeof(int) * 8); queue[rear].dist = current.dist +  } return -1; } int main() { int state[8]; while (scanf(\"%d\",  i < 8; i++)  result = bfs(state); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#include<iostream> #include<cstdio> #include<queue> #include<algorithm> #include<string> #include<vector> #include<cstdlib> using namespace std; #define  main() { int i,j; cin>>i; cout<<1<<endl; return 0; }"], "original_ll": -1.8874130249023438, "sampled_ll": -0.4108114540576935, "all_perturbed_sampled_ll": [-1.2487525939941406], "all_perturbed_original_ll": [-1.667771339416504], "perturbed_sampled_ll": -1.2487525939941406, "perturbed_original_ll": -1.667771339416504, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\n\tvoid run() {\n\t\tHashMap<ArrayList<Integer>, Integer> hm = new HashMap<ArrayList<Integer>, Integer>();\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tint cnt = 0;\n\t\thm.put(list, cnt);\n\n\t\tLinkedList<ArrayList<Integer>> queue = new LinkedList<ArrayList<Integer>>();\n\t\tqueue.add(list);\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint size = queue.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tArrayList<Integer> l = queue.poll();\n\t\t\t\tint zeroIndex = 0;\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (l.get(j) == 0) {\n\t\t\t\t\t\tzeroIndex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (zeroIndex - 1 >= 0 && zeroIndex != 4) {\n\t\t\t\t\tArrayList<Integer> add = new ArrayList<Integer>(l);\n\t\t\t\t\tint t = l.get(zeroIndex);\n\t\t\t\t\tint r = l.get(zeroIndex - 1);\n\t\t\t\t\tadd.set(zeroIndex, r);\n\t\t\t\t\tadd.set(zeroIndex - 1, t);\n\t\t\t\t\tif (!hm.containsKey(add)) {\n\t\t\t\t\t\thm.put(add, cnt + 1);\n\t\t\t\t\t\tqueue.add(add);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (zeroIndex + 1 < 8 && zeroIndex != 3) {\n\t\t\t\t\tArrayList<Integer> add = new ArrayList<Integer>(l);\n\t\t\t\t\tint t = l.get(zeroIndex);\n\t\t\t\t\tint r = l.get(zeroIndex + 1);\n\t\t\t\t\tadd.set(zeroIndex, r);\n\t\t\t\t\tadd.set(zeroIndex + 1, t);\n\t\t\t\t\tif (!hm.containsKey(add)) {\n\t\t\t\t\t\thm.put(add, cnt + 1);\n\t\t\t\t\t\tqueue.add(add);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrayList<Integer> add = new ArrayList<Integer>(l);\n\t\t\t\tint t = l.get(zeroIndex);\n\t\t\t\tint r = l.get((zeroIndex + 4) % 8);\n\t\t\t\tadd.set(zeroIndex, r);\n\t\t\t\tadd.set((zeroIndex + 4) % 8, t);\n\t\t\t\tif (!hm.containsKey(add)) {\n\t\t\t\t\thm.put(add, cnt + 1);\n\t\t\t\t\tqueue.add(add);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\twhile (sc2.hasNext()) {\n\t\t\tString input[] = sc2.nextLine().split(\" \");\n\t\t\tArrayList<Integer> in = new ArrayList<Integer>();\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tin.add(Integer.valueOf(input[i]));\n\t\t\t}\n\t\t\tSystem.out.println(hm.get(in));\n\t\t}\n\t}\n\n\tboolean check(ArrayList<Integer> list) {\n\t\tboolean judge = true;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif (list.get(i) != i) {\n\t\t\t\tjudge = false;\n\t\t\t}\n\t\t}\n\t\treturn judge;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static final int[] TARGET = {0, 1, 2, 3, 4, 5, 6, 7};\n    static final int[][] MOVES = {{1}, {0, 2}, {1, 3}, {2}, {5}, {4, 6}, {5, 7}, {6}};\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\"\\\\s+\");\n            int[] initial = new int[8];\n            for (int i = 0; i < 8; i++) {\n                initial[i] = Integer.parseInt(parts[i]);\n            }\n            \n            System.out.println(bfs(initial));\n        }\n        sc.close();\n    }\n    \n    static int bfs(int[] initial) {\n        if (Arrays.equals(initial, TARGET)) {\n            return 0;\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        State start = new State(initial, 0);\n        queue.offer(start);\n        visited.add(stateToString(initial));\n        \n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            \n            int zeroPos = -1;\n            for (int i = 0; i < 8; i++) {\n                if (current.board[i] == 0) {\n                    zeroPos = i;\n                    break;\n                }\n            }\n            \n            for (int nextPos : MOVES[zeroPos]) {\n                int[] newBoard = current.board.clone();\n                newBoard[zeroPos] = newBoard[nextPos];\n                newBoard[nextPos] = 0;\n                \n                if (Arrays.equals(newBoard, TARGET)) {\n                    return current.moves + 1;\n                }\n                \n                String stateStr = stateToString(newBoard);\n                if (!visited.contains(stateStr)) {\n                    visited.add(stateStr);\n                    queue.offer(new State(newBoard, current.moves + 1));\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static String stateToString(int[] board) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 8; i++) {\n            sb.append(board[i]);\n        }\n        return sb.toString();\n    }\n    \n    static class State {\n        int[] board;\n        int moves;\n        \n        State(int[] board, int moves) {\n            this.board = board;\n            this.moves = moves;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static final int[] TARGET = {0, 1, 2, 3, 4, 5,  2}, {1, 3}, {2},  {6}}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String line = sc.nextLine().trim(); if  i = 0; i < 8; i++) { initial[i] = Integer.parseInt(parts[i]); } System.out.println(bfs(initial)); } sc.close(); } static int bfs(int[] initial) { if (Arrays.equals(initial, TARGET)) { return 0; } Queue<State> queue = new LinkedList<>(); Set<String> visited = new HashSet<>(); State  queue.offer(start); visited.add(stateToString(initial)); while (!queue.isEmpty()) { State current =  for (int i = 0; i < 8; i++) { if (current.board[i] == 0) { zeroPos = i; break; } } for (int nextPos : MOVES[zeroPos])  newBoard[zeroPos]  if (Arrays.equals(newBoard, TARGET)) { return current.moves + 1; } String stateStr = stateToString(newBoard); if  current.moves + 1)); } } } return -1; } static String stateToString(int[] board) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < 8; i++) { sb.append(board[i]);  class State { int[] board; int moves; State(int[] board,   } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedList; import java.util.Scanner; public class Main { MyScanner sc = new MyScanner(); Scanner sc2 = new Scanner(System.in); void run() { HashMap<ArrayList<Integer>, Integer> hm = new HashMap<ArrayList<Integer>, Integer>(); ArrayList<Integer> list = new ArrayList<Integer>(); for (int i = 0; i < 8; i++) { list.add(i); } int cnt = 0;  new LinkedList<ArrayList<Integer>>(); queue.add(list); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i < size; i++) { ArrayList<Integer> l = queue.poll(); int zeroIndex = 0; for (int  (l.get(j) == 0) { zeroIndex = j; }  >= 0 && zeroIndex != 4) { ArrayList<Integer> add = new ArrayList<Integer>(l); int t = l.get(zeroIndex);  1); add.set(zeroIndex, r); add.set(zeroIndex - 1, t); if (!hm.containsKey(add)) { hm.put(add, cnt + 1); queue.add(add); } } if (zeroIndex + 1 < 8  ArrayList<Integer> add = new ArrayList<Integer>(l); int t =  + 1); add.set(zeroIndex, r); add.set(zeroIndex +  queue.add(add); } } ArrayList<Integer> add = new ArrayList<Integer>(l);  r = l.get((zeroIndex +  add.set((zeroIndex + 4) % 8, t);  + 1); queue.add(add); } }  String input[] = sc2.nextLine().split(\" \"); ArrayList<Integer> in = new ArrayList<Integer>(); for (int i = 0; i < 8; i++) { in.add(Integer.valueOf(input[i])); } System.out.println(hm.get(in)); }  boolean  { judge = false; } }  void  } void debug(Object... o)  < array.length;  = 0; j < array[i].length; j++) { System.out.print(array[i][j]); } System.out.println(); } } class MyScanner { int nextInt() { try { int c = System.in.read(); while (c != '-' && (c < '0' || '9' < c)) c = System.in.read(); if (c == '-') return -nextInt(); int res = 0; do { res *= 10; res += c - '0'; c = System.in.read(); } while ('0' <= c && c <= '9'); return res; } catch (Exception e) { return -1; } } double nextDouble() { return Double.parseDouble(next()); } String next() { try { StringBuilder res  = System.in.read(); while (Character.isWhitespace(c)) c =  } while (!Character.isWhitespace(c =  (Exception e) { return null; } } } }"], "original_ll": -0.4051997661590576, "sampled_ll": -0.3509499728679657, "all_perturbed_sampled_ll": [-1.298705816268921], "all_perturbed_original_ll": [-1.1835366487503052], "perturbed_sampled_ll": -1.298705816268921, "perturbed_original_ll": -1.1835366487503052, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import deque\n\ndic = {}\ndic[(0,1,2,3,4,5,6,7)] = 0\n\n\nswap_dic = {0:(1, 4), 1:(0, 2, 5), 2:(1, 3, 6), 3:(2, 7),\n            4:(0, 5), 5:(1, 4, 6), 6:(2, 5, 7), 7:(3, 6)}\n\ndef swap(puz, i, j):\n  new = [k for k in puz]\n  new[i], new[j] = new[j], new[i]\n  return tuple(new)\n\nque = deque()\nque.append((0, (0,1,2,3,4,5,6,7)))\nwhile que:\n  score, puz = que.popleft()\n  score += 1\n  z_ind = puz.index(0)\n\n  for swap_ind in swap_dic[z_ind]:\n    new_puz = swap(puz, z_ind, swap_ind)\n    if not new_puz in dic:\n      dic[new_puz] = score\n      que.append((score, new_puz))\n\nwhile True:\n  try:\n    print(dic[tuple(map(int, input().split()))])\n  except EOFError:\n    break\n", "sampled": "from collections import deque\nimport sys\n\ndef solve(start):\n    goal = tuple(range(8))\n    if start == goal:\n        return 0\n    \n    visited = {start}\n    queue = deque([(start, 0)])\n    \n    while queue:\n        state, dist = queue.popleft()\n        \n        # Find position of 0\n        pos = state.index(0)\n        row = pos // 4\n        col = pos % 4\n        \n        # Try all 4 directions\n        moves = []\n        if col > 0:  # left\n            moves.append(pos - 1)\n        if col < 3:  # right\n            moves.append(pos + 1)\n        if row > 0:  # up\n            moves.append(pos - 4)\n        if row < 1:  # down\n            moves.append(pos + 4)\n        \n        for new_pos in moves:\n            new_state = list(state)\n            new_state[pos], new_state[new_pos] = new_state[new_pos], new_state[pos]\n            new_state = tuple(new_state)\n            \n            if new_state == goal:\n                return dist + 1\n            \n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, dist + 1))\n    \n    return -1\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        nums = tuple(map(int, line.split()))\n        print(solve(nums))\n", "perturbed_sampled": ["from collections import deque import sys   0 visited = {start} queue = deque([(start, 0)]) while queue: state,  position of 0 pos = state.index(0)  col = pos % 4 # Try all 4 directions  > 0: # left moves.append(pos - 1)  right moves.append(pos  0: # up moves.append(pos - 4) if row < 1: # down moves.append(pos + 4) for new_pos in moves: new_state = list(state)  new_state = tuple(new_state) if new_state == goal: return dist + 1 if new_state not in visited: visited.add(new_state) queue.append((new_state, dist + 1)) return -1 for line in sys.stdin: line = line.strip() if line: nums = tuple(map(int, line.split())) print(solve(nums))"], "perturbed_original": ["from collections import deque dic = {} dic[(0,1,2,3,4,5,6,7)] = 0 swap_dic = {0:(1, 4), 1:(0, 2, 5), 2:(1, 3, 6), 3:(2, 7), 4:(0, 5), 5:(1, 4, 6), 6:(2, 5, 7), 7:(3, 6)} def  [k for k in puz] new[i],  que.append((0, (0,1,2,3,4,5,6,7))) while que:   for swap_ind in swap_dic[z_ind]: new_puz = swap(puz, z_ind, swap_ind) if not new_puz in dic: dic[new_puz] = score que.append((score, new_puz)) while True: try: print(dic[tuple(map(int, input().split()))]) except EOFError: break"], "original_ll": -0.7301717400550842, "sampled_ll": -0.6495038866996765, "all_perturbed_sampled_ll": [-2.0027129650115967], "all_perturbed_original_ll": [-1.4497160911560059], "perturbed_sampled_ll": -2.0027129650115967, "perturbed_original_ll": -1.4497160911560059, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>          // printf(), scanf()\n#include <stdbool.h>\n\n#define MAX_N 10\n#define MAX_M 10\n#define MAX_G 9\n\nint sx, sy;\nint n;\nint scx[MAX_N], scy[MAX_N];\n\nbool\nb_survival()\n{\n\tbool field[MAX_M][MAX_M];\n\tint px[MAX_G], py[MAX_G];\n\tstatic const int dx2[12] = {-1, 0, 1, 2, 2, 2,-1, 0, 1,-2,-2,-2};\n\tstatic const int dy2[12] = {-2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1};\n\n\tint ix = 0;\n\tpx[ix] = sx, py[ix] = sy;\n\tix++;\n\n\tfor (int u = 0; u < n; ++u)\n\t{\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = scx[u] + dx, ny = scy[u] + dy;\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)\n\t\t\t\t\tfield[ny][nx] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 12; ++j)\n\t\t\t{\n\t\t\t\tint nx = px[i] + dx2[j], ny = py[i] + dy2[j];\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)\n\t\t\t\t\tfield[ny][nx] = true;\n\t\t\t}\n\t\t}\n\n\t\tix = 0;\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = scx[u] + dx, ny = scy[u] + dy;\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M && field[ny][nx])\n\t\t\t\t{\n\t\t\t\t\tpx[ix] = nx;\n\t\t\t\t\tpy[ix] = ny;\n\t\t\t\t\tix++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ix == 0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint lineno = 0;\n\twhile (true)\n\t{\n\t\tlineno++;\n\t\tscanf(\"%d%d\", &sx, &sy);\n\t\tif (sx == 0 && sy == 0)\n\t\t\tbreak;\n\n\t\tlineno++;\n\t\tscanf(\"%d\", &n);\n\n\t\tlineno++;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tscanf(\"%d%d\", &scx[i], &scy[i]);\n\n\t\tprintf(\"%s\\n\", b_survival() ? \"OK\" : \"NA\");\n\t}\n\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint can_reach(int fx, int fy, int sx, int sy) {\n    int dx = abs(fx - sx);\n    int dy = abs(fy - sy);\n    \n    if ((dx == 2 && dy == 2) || (dx == 0 && dy == 3) || (dx == 3 && dy == 0)) {\n        return 1;\n    }\n    return 0;\n}\n\nint in_spray(int x, int y, int sx, int sy) {\n    int dx = abs(x - sx);\n    int dy = abs(y - sy);\n    \n    if (dx <= 1 && dy <= 1) {\n        return 1;\n    }\n    return 0;\n}\n\nint in_bounds(int x, int y) {\n    return x >= 0 && x <= 9 && y >= 0 && y <= 9;\n}\n\nint solve(int px, int py, int n, int sx[], int sy[]) {\n    int possible[10][10];\n    int next_possible[10][10];\n    \n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            possible[i][j] = 0;\n        }\n    }\n    \n    for (int x = 0; x < 10; x++) {\n        for (int y = 0; y < 10; y++) {\n            if (can_reach(px, py, x, y) && in_bounds(x, y) && in_spray(x, y, sx[0], sy[0])) {\n                possible[x][y] = 1;\n            }\n        }\n    }\n    \n    for (int i = 1; i < n; i++) {\n        for (int x = 0; x < 10; x++) {\n            for (int y = 0; y < 10; y++) {\n                next_possible[x][y] = 0;\n            }\n        }\n        \n        for (int fx = 0; fx < 10; fx++) {\n            for (int fy = 0; fy < 10; fy++) {\n                if (possible[fx][fy]) {\n                    for (int tx = 0; tx < 10; tx++) {\n                        for (int ty = 0; ty < 10; ty++) {\n                            if (can_reach(fx, fy, tx, ty) && in_bounds(tx, ty) && in_spray(tx, ty, sx[i], sy[i])) {\n                                next_possible[tx][ty] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (int x = 0; x < 10; x++) {\n            for (int y = 0; y < 10; y++) {\n                possible[x][y] = next_possible[x][y];\n            }\n        }\n    }\n    \n    for (int x = 0; x < 10; x++) {\n        for (int y = 0; y < 10; y++) {\n            if (possible[x][y]) {\n                return 1;\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int px, py;\n    \n    while (scanf(\"%d %d\", &px, &py) == 2) {\n        if (px == 0 && py == 0) {\n            break;\n        }\n        \n        int n;\n        scanf(\"%d\", &n);\n        \n        int sx[10], sy[10];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &sx[i], &sy[i]);\n        }\n        \n        if (solve(px, py, n, sx, sy)) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int can_reach(int fx, int fy, int sx, int sy) { int dx = abs(fx - sx);  sy); if ((dx == 2 && dy == 2) ||  ==  { return 1; }   int sy) { int dx = abs(x - sx); int dy  (dx <= 1 && dy <= 1) { return 1; } return 0;  y) { return x >= 0 && x <= 9 && y  9;  py, int n, int sx[],  int next_possible[10][10]; for (int i  i++) { for (int  10; j++) { possible[i][j] = 0; } } for  < 10; x++) { for  < 10; y++) { if (can_reach(px, py, x, y) && in_bounds(x, y) && in_spray(x, y,  1; } }  1; i < n; i++) { for (int x = 0; x <  y = 0; y < 10; y++) {  for (int fx = 0; fx < 10; fx++) { for (int fy = 0; fy < 10; fy++) { if (possible[fx][fy])  0; tx < 10; tx++) { for (int ty = 0; ty < 10; ty++) { if (can_reach(fx, fy, tx, ty) && in_bounds(tx, ty) && in_spray(tx, ty, sx[i], sy[i])) { next_possible[tx][ty] =  } } for (int x = 0; x < 10; x++) { for (int y = 0; y < 10; y++) { possible[x][y] = next_possible[x][y]; } } } for (int x =  { for (int y = 0; y < 10;  return 1; } } } return 0; } int main() { int px, py; while (scanf(\"%d %d\", &px, &py) == 2) { if (px == 0 && py == 0) { break; } int n;  for (int i = 0; i < n; i++) { scanf(\"%d %d\", &sx[i], &sy[i]); } if (solve(px, py, n, sx, sy))  printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> // printf(), scanf() #include <stdbool.h>  10 #define MAX_G 9 int sx, sy;  bool b_survival() { bool field[MAX_M][MAX_M]; int px[MAX_G], py[MAX_G]; static const int dx2[12]  2, 2,-1, 0, 1,-2,-2,-2};  {-2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1}; int ix = 0; px[ix] = sx, py[ix] = sy; ix++; for (int  n; ++u) { for (int dy = -1; dy <= 1; ++dy)  -1; dx <= 1; ++dx) { int nx = scx[u] + dx, ny = scy[u] + dy; if (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M) field[ny][nx] = false; } } for (int  (int j = 0; j < 12; ++j) { int  ny = py[i] + dy2[j]; if (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M) field[ny][nx] = true; }  (int dy  ++dy) { for (int dx = -1; dx <= 1; ++dx) { int nx = scx[u] + dx, ny = scy[u] + dy;    = ny; ix++; } } } if (ix == 0) return false; } return true; } int main(int argc, char **argv)   &sx, &sy); if (sx == 0 && sy == 0) break; lineno++; scanf(\"%d\", &n); lineno++; for (int i = 0; i < n; ++i) scanf(\"%d%d\", &scx[i], &scy[i]); printf(\"%s\\n\", b_survival() ? \"OK\" : \"NA\"); } return 0; }"], "original_ll": -0.6098967790603638, "sampled_ll": -0.3121703565120697, "all_perturbed_sampled_ll": [-1.2680984735488892], "all_perturbed_original_ll": [-1.4611332416534424], "perturbed_sampled_ll": -1.2680984735488892, "perturbed_original_ll": -1.4611332416534424, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] fy = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 };\n\tstatic int[] fx = { -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint kx = scanner.nextInt();\n\t\t\tint ky = scanner.nextInt();\n\t\t\tif (ky == 0 && kx == 0)\n\t\t\t\tbreak;\n\t\t\tint n = scanner.nextInt();\n\t\t\tint[][] num = new int[n][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tnum[i][0] = scanner.nextInt();\n\t\t\t\tnum[i][1] = scanner.nextInt();\n\t\t\t}\n\t\t\tDeque<int[]> deque = new ArrayDeque<int[]>();\n\t\t\tdeque.offer(new int[] { ky, kx });\n\t\t\tboolean flag = true;\n\t\t\tloop: for (int i = 0; i < n; i++) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tDeque<int[]> dequetmp = new ArrayDeque<int[]>();\n\t\t\t\twhile (size-- > 0) {\n\t\t\t\t\tint[] m = deque.pop();\n\t\t\t\t\tslove(m, num[i], dequetmp);\n\t\t\t\t}\n\t\t\t\tif (dequetmp.isEmpty()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t\tdeque = dequetmp;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"OK\" : \"NA\");\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[] m, int[] num, Deque<int[]> dequetmp) {\n\t\tboolean[][] map = new boolean[14][14];\n\t\tfor (int i = 1; i < 4; i++) {\n\t\t\tfor (int j = 1; j < 4; j++) {\n\t\t\t\tint y = num[1] + i;\n\t\t\t\tint x = num[0] + j;\n\t\t\t\tif (2 <= y && y <= 12 && 2 <= x && x <= 12)\n\t\t\t\t\tmap[y][x] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < fy.length; i++) {\n\t\t\tint py = m[0] + fy[i] + 2;\n\t\t\tint px = m[1] + fx[i] + 2;\n\t\t\tif (map[py][px]) {\n\t\t\t\tpy -= 2;\n\t\t\t\tpx -= 2;\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor (int[] t : dequetmp) {\n\t\t\t\t\tif (t[0] == py && t[1] == px) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tdequetmp.push(new int[] { py, px });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[][] jumpOffsets = {\n        {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2},\n        {1, -2}, {1, 2}, {2, -1}, {2, 1}\n    };\n    \n    static int[][] waterOffsets = {\n        {-1, -1}, {-1, 0}, {-1, 1},\n        {0, -1}, {0, 0}, {0, 1},\n        {1, -1}, {1, 0}, {1, 1}\n    };\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int px = sc.nextInt();\n            int py = sc.nextInt();\n            \n            if (px == 0 && py == 0) break;\n            \n            int n = sc.nextInt();\n            int[][] sprinklers = new int[n][2];\n            \n            for (int i = 0; i < n; i++) {\n                sprinklers[i][0] = sc.nextInt();\n                sprinklers[i][1] = sc.nextInt();\n            }\n            \n            if (canSurvive(px, py, sprinklers)) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static boolean canSurvive(int px, int py, int[][] sprinklers) {\n        Set<String> currentPositions = new HashSet<>();\n        currentPositions.add(px + \",\" + py);\n        \n        for (int i = 0; i < sprinklers.length; i++) {\n            int sx = sprinklers[i][0];\n            int sy = sprinklers[i][1];\n            \n            Set<String> nextPositions = new HashSet<>();\n            \n            for (String posStr : currentPositions) {\n                String[] parts = posStr.split(\",\");\n                int x = Integer.parseInt(parts[0]);\n                int y = Integer.parseInt(parts[1]);\n                \n                for (int[] offset : jumpOffsets) {\n                    int nx = x + offset[0];\n                    int ny = y + offset[1];\n                    \n                    if (nx >= 0 && nx <= 9 && ny >= 0 && ny <= 9) {\n                        if (isInWaterRange(nx, ny, sx, sy)) {\n                            nextPositions.add(nx + \",\" + ny);\n                        }\n                    }\n                }\n            }\n            \n            if (nextPositions.isEmpty()) {\n                return false;\n            }\n            \n            currentPositions = nextPositions;\n        }\n        \n        return true;\n    }\n    \n    static boolean isInWaterRange(int x, int y, int sx, int sy) {\n        for (int[] offset : waterOffsets) {\n            if (sx + offset[0] == x && sy + offset[1] == y) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int[][] jumpOffsets = { {-2, -1},  2}, {1, -2}, {1, 2}, {2, -1}, {2, 1} }; static int[][] waterOffsets = { {-1, -1}, {-1, 0}, {-1, 1},  1}, {1, -1}, {1, 0}, {1, 1} }; public static void main(String[] args) { Scanner sc = new  px  sc.nextInt();  py == 0) break; int n = sc.nextInt(); int[][] sprinklers = new  0; i < n; i++) { sprinklers[i][0] = sc.nextInt(); sprinklers[i][1]  py, sprinklers)) { System.out.println(\"OK\"); } else { System.out.println(\"NA\");  boolean canSurvive(int px, int py, int[][] sprinklers) { Set<String> currentPositions = new HashSet<>(); currentPositions.add(px +  < sprinklers.length; i++) { int sx = sprinklers[i][0]; int sy = sprinklers[i][1]; Set<String> nextPositions =  : currentPositions) { String[] parts = posStr.split(\",\"); int x =  for (int[] offset :  x + offset[0]; int ny = y + offset[1]; if (nx >= 0 && nx <= 9 && ny >=  { if (isInWaterRange(nx, ny, sx, sy)) { nextPositions.add(nx + \",\"  } if (nextPositions.isEmpty()) { return false; } currentPositions = nextPositions; } return true; } static boolean isInWaterRange(int x, int y, int sx, int sy) { for (int[] offset : waterOffsets)   offset[1] == y) { return true; } } return false; } }"], "perturbed_original": ["import java.util.ArrayDeque; import java.util.Deque; import java.util.Scanner; public class Main { static int[] fy = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 }; static int[] fx = {  -2, 2, -2, 2, -1, 0, 1 }; public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while  scanner.nextInt(); int ky  0 && kx == 0) break;  num = new int[n][2]; for  < n; i++) { num[i][0] = scanner.nextInt(); num[i][1] = scanner.nextInt(); } Deque<int[]> deque = new ArrayDeque<int[]>(); deque.offer(new  boolean flag = true; loop: for (int i = 0;  int size = deque.size(); Deque<int[]> dequetmp = new ArrayDeque<int[]>(); while (size-- > 0) { int[] m = deque.pop(); slove(m, num[i], dequetmp); } if (dequetmp.isEmpty()) {  } deque = dequetmp; } System.out.println(flag ? \"OK\"  int[] num, Deque<int[]> dequetmp) { boolean[][] map = new boolean[14][14]; for (int i = 1; i < 4; i++) { for (int j = 1; j < 4; j++) { int y = num[1] + i; int x = num[0] +  && y <= 12 &&   i = 0; i < fy.length; i++) { int py = m[0] + fy[i] + 2; int px = m[1] + fx[i] + 2; if (map[py][px]) { py -= 2;  t : dequetmp) { if (t[0] == py && t[1] == px) { flag = false;  {  }); } } } } }"], "original_ll": -0.5472045540809631, "sampled_ll": -0.37590184807777405, "all_perturbed_sampled_ll": [-1.429821491241455], "all_perturbed_original_ll": [-1.51124107837677], "perturbed_sampled_ll": -1.429821491241455, "perturbed_original_ll": -1.51124107837677, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "R1=range(-2,3)\nR2=range(-1,2)\nA1=[(x,y) for x in R1 for y in R1 if 3<x**2+y**2<6]\nA2=[(x,y) for x in R2 for y in R2]\ndef fi(): return map(int,raw_input().split(\" \"))\ndef f(p,i):\n  x,y=p\n  A=[A1,A2][i>0]\n  return set([(x+dx,y+dy) for dx,dy in A if 0<=x+dx<10 and 0<=y+dy<10])\n\nwhile 1:\n  xf,yf=fi()\n  if yf==xf==0: break\n  raw_input()\n  tmp=fi()\n  PA=zip(tmp[0::2],tmp[1::2])\n  FA=set([(xf,yf)])\n  for ps in PA:\n    SA=f(ps,1)\n    tmp=set([])\n    for pf in FA: tmp=tmp|(SA&f(pf,0))\n    FA=tmp\n  print [\"NA\",\"OK\"][len(FA)>0]", "sampled": "import sys\nfrom collections import deque\n\ndef get_jump_positions(x, y):\n    \"\"\"Returns all valid positions that can be reached from (x, y) with one jump\"\"\"\n    jumps = [\n        (-2, -1), (-2, 1), (2, -1), (2, 1),\n        (-1, -2), (-1, 2), (1, -2), (1, 2)\n    ]\n    positions = []\n    for dx, dy in jumps:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx <= 9 and 0 <= ny <= 9:\n            positions.append((nx, ny))\n    return positions\n\ndef get_water_positions(x, y):\n    \"\"\"Returns all positions covered by water from sprinkler at (x, y)\"\"\"\n    positions = set()\n    for dx in range(-2, 3):\n        for dy in range(-2, 3):\n            if abs(dx) + abs(dy) <= 2:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx <= 9 and 0 <= ny <= 9:\n                    positions.add((nx, ny))\n    return positions\n\ndef solve(px, py, sprinklers):\n    n = len(sprinklers)\n    \n    # BFS to find if there's a path\n    # State: (current_position, sprinkler_index)\n    # We start by jumping from initial position when first sprinkler activates\n    \n    if n == 0:\n        return \"NA\"\n    \n    # Get all positions reachable from initial position\n    initial_jumps = get_jump_positions(px, py)\n    \n    # Check which of these positions are covered by first sprinkler\n    first_sprinkler_water = get_water_positions(sprinklers[0][0], sprinklers[0][1])\n    \n    # Queue: (position, sprinkler_index)\n    queue = deque()\n    visited = set()\n    \n    for pos in initial_jumps:\n        if pos in first_sprinkler_water:\n            queue.append((pos, 0))\n            visited.add((pos, 0))\n    \n    # If we reach the last sprinkler, we survived\n    while queue:\n        (x, y), spr_idx = queue.popleft()\n        \n        # If we're at the last sprinkler, we survived\n        if spr_idx == n - 1:\n            return \"OK\"\n        \n        # Try to jump to next sprinkler's water area\n        next_spr_idx = spr_idx + 1\n        next_water = get_water_positions(sprinklers[next_spr_idx][0], sprinklers[next_spr_idx][1])\n        \n        # Get all positions we can jump to\n        jump_positions = get_jump_positions(x, y)\n        \n        for next_pos in jump_positions:\n            if next_pos in next_water:\n                state = (next_pos, next_spr_idx)\n                if state not in visited:\n                    visited.add(state)\n                    queue.append(state)\n    \n    return \"NA\"\n\n# Read input\nwhile True:\n    line = input().split()\n    px, py = int(line[0]), int(line[1])\n    \n    if px == 0 and py == 0:\n        break\n    \n    n = int(input())\n    coords = list(map(int, input().split()))\n    \n    sprinklers = []\n    for i in range(n):\n        x = coords[2 * i]\n        y = coords[2 * i + 1]\n        sprinklers.append((x, y))\n    \n    result = solve(px, py, sprinklers)\n    print(result)\n", "perturbed_sampled": ["import sys from collections import deque def get_jump_positions(x,  that  jumps = [ (-2, -1),  1), (-1, -2), (-1, 2), (1, -2), (1, 2) ] positions = [] for dx, dy in jumps: nx, ny = x + dx, y + dy if 0 <= nx <= 9 and  positions.append((nx, ny)) return positions def get_water_positions(x, y): \"\"\"Returns  from sprinkler at (x, y)\"\"\" positions = set() for dx in range(-2, 3): for dy in range(-2, 3): if abs(dx) + abs(dy) <= 2: nx, ny = x  if 0 <= nx <= 9 and 0 <= ny <= 9: positions.add((nx, ny)) return positions def  len(sprinklers) # BFS to find if there's a path # State: (current_position, sprinkler_index) # We start  return \"NA\" # Get  position  Check which of these positions are covered by first sprinkler first_sprinkler_water = get_water_positions(sprinklers[0][0], sprinklers[0][1]) # Queue: (position, sprinkler_index) queue = deque() visited = set() for pos in initial_jumps: if pos in first_sprinkler_water: queue.append((pos, 0)) visited.add((pos, 0)) # If we  survived while  queue.popleft() # If we're at the last sprinkler, we  - 1: return \"OK\" # Try to jump to next sprinkler's  get_water_positions(sprinklers[next_spr_idx][0], sprinklers[next_spr_idx][1]) # Get all positions we can jump to jump_positions = get_jump_positions(x, y) for next_pos in jump_positions: if next_pos in next_water: state = (next_pos, next_spr_idx) if state not in visited: visited.add(state) queue.append(state) return \"NA\" # Read input while True: line = input().split() px, py = int(line[0]), int(line[1]) if px == 0 and py == 0: break n = int(input()) coords = list(map(int, input().split())) sprinklers  range(n): x = coords[2 *  i +  solve(px, py, sprinklers) print(result)"], "perturbed_original": ["R1=range(-2,3) R2=range(-1,2) A1=[(x,y) for x in R1 for y in R1 if 3<x**2+y**2<6] A2=[(x,y) for x in R2 for y in R2]  def f(p,i): x,y=p A=[A1,A2][i>0] return set([(x+dx,y+dy) for dx,dy in A if 0<=x+dx<10 and  yf==xf==0: break raw_input() tmp=fi() PA=zip(tmp[0::2],tmp[1::2])  SA=f(ps,1) tmp=set([]) for pf in FA: tmp=tmp|(SA&f(pf,0)) FA=tmp print [\"NA\",\"OK\"][len(FA)>0]"], "original_ll": -1.399677038192749, "sampled_ll": -0.6926193237304688, "all_perturbed_sampled_ll": [-1.6584721803665161], "all_perturbed_original_ll": [-2.0320703983306885], "perturbed_sampled_ll": -1.6584721803665161, "perturbed_original_ll": -2.0320703983306885, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  float x,y;\n  \n  while(scanf(\"%f%f\",&x,&y)!=EOF){   \n    if(x<35.5&&y<71)\n      puts(\"AAA\");\n    else if(x<37.5&&y<77)\n      puts(\"AA\");\n    else if(x<40&&y<83)\n      puts(\"A\");\n    else if(x<43&&y<89)\n      puts(\"B\");\n    else if(x<50&&y<105)\n      puts(\"C\");\n    else if(x<55&&y<116)\n      puts(\"D\");\n    else if(x<70&&y<148)\n      puts(\"E\");\n    else\n      puts(\"NA\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double t1, t2;\n    \n    while (scanf(\"%lf %lf\", &t1, &t2) == 2) {\n        if (t1 < 35.50 && t2 < 71.00) {\n            printf(\"AAA\\n\");\n        } else if (t1 < 37.50 && t2 < 77.00) {\n            printf(\"AA\\n\");\n        } else if (t1 < 40.00 && t2 < 83.00) {\n            printf(\"A\\n\");\n        } else if (t1 < 43.00 && t2 < 89.00) {\n            printf(\"B\\n\");\n        } else if (t1 < 50.00 && t2 < 105.00) {\n            printf(\"C\\n\");\n        } else if (t1 < 55.00 && t2 < 116.00) {\n            printf(\"D\\n\");\n        } else if (t1 < 70.00 && t2 < 148.00) {\n            printf(\"E\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" double  &t1, &t2) == 2)  && t2 < 71.00) { printf(\"AAA\\n\"); } else if (t1 < 37.50 && t2 < 77.00) {  < 40.00 && t2 < 83.00) { printf(\"A\\n\"); } else if (t1 < 43.00 && t2 < 89.00) { printf(\"B\\n\"); } else if (t1 < 50.00 && t2 < 105.00) { printf(\"C\\n\"); }  && t2 <  if (t1 < 70.00 && t2 < 148.00) { printf(\"E\\n\"); } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ float x,y; while(scanf(\"%f%f\",&x,&y)!=EOF){ if(x<35.5&&y<71) puts(\"AAA\"); else if(x<37.5&&y<77) puts(\"AA\"); else if(x<40&&y<83) puts(\"A\"); else if(x<43&&y<89) puts(\"B\"); else if(x<50&&y<105) puts(\"C\"); else if(x<55&&y<116) puts(\"D\");  } return 0; }"], "original_ll": -0.9567145705223083, "sampled_ll": -0.5097765922546387, "all_perturbed_sampled_ll": [-1.2327289581298828], "all_perturbed_original_ll": [-1.1714667081832886], "perturbed_sampled_ll": -1.2327289581298828, "perturbed_original_ll": -1.1714667081832886, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble eps=0.000000000000000001;\n\t\twhile(sc.hasNext()){\n\t\t\tdouble n=sc.nextDouble();\n\t\t\tdouble m=sc.nextDouble();\n\t\t\tif(n<35.5-eps && m<71.0-eps){\n\t\t\t\tSystem.out.println(\"AAA\");\n\t\t\t}\n\t\t\telse if(n<37.5-eps && m<77.0-eps){\n\t\t\t\tSystem.out.println(\"AA\");\n\t\t\t}\n\t\t\telse if(n<40.0-eps && m<83.0-eps){\n\t\t\t\tSystem.out.println(\"A\");\n\t\t\t}\n\t\t\telse if(n<43.0-eps && m<89.0-eps){\n\t\t\t\tSystem.out.println(\"B\");\n\t\t\t}\n\t\t\telse if(n<50.0-eps && m<105.0-eps){\n\t\t\t\tSystem.out.println(\"C\");\n\t\t\t}\n\t\t\telse if(n<55.0-eps && m<116.0-eps){\n\t\t\t\tSystem.out.println(\"D\");\n\t\t\t}\n\t\t\telse if(n<70.0-eps && m<148.0-eps){\n\t\t\t\tSystem.out.println(\"E\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double t1 = sc.nextDouble();\n            double t2 = sc.nextDouble();\n            \n            String result = \"NA\";\n            \n            if (t1 < 35.50 && t2 < 71.00) {\n                result = \"AAA\";\n            } else if (t1 < 37.50 && t2 < 77.00) {\n                result = \"AA\";\n            } else if (t1 < 40.00 && t2 < 83.00) {\n                result = \"A\";\n            } else if (t1 < 43.00 && t2 < 89.00) {\n                result = \"B\";\n            } else if (t1 < 50.00 && t2 < 105.00) {\n                result = \"C\";\n            } else if (t1 < 55.00 && t2 < 116.00) {\n                result = \"D\";\n            } else if (t1 < 70.00 && t2 < 148.00) {\n                result = \"E\";\n            }\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { double t1 = sc.nextDouble(); double t2 = sc.nextDouble(); String result = \"NA\"; if (t1 < 35.50  result  (t1  77.00)  else if (t1 < 40.00 && t2 < 83.00) { result = \"A\"; } else if (t1 < 43.00 && t2  \"B\"; } else if (t1 < 50.00 &&  = \"C\"; } else if (t1 < 55.00 && t2 < 116.00) { result = \"D\"; } else  t2 < 148.00) {  } sc.close(); } }"], "perturbed_original": [" sc=new Scanner(System.in); double eps=0.000000000000000001; while(sc.hasNext()){ double n=sc.nextDouble(); double m=sc.nextDouble(); if(n<35.5-eps && m<71.0-eps){ System.out.println(\"AAA\"); } else if(n<37.5-eps &&  && m<83.0-eps){ System.out.println(\"A\"); } else if(n<43.0-eps && m<89.0-eps){ System.out.println(\"B\"); } else if(n<50.0-eps && m<105.0-eps){ System.out.println(\"C\"); } else if(n<55.0-eps && m<116.0-eps){ System.out.println(\"D\"); } else if(n<70.0-eps && m<148.0-eps){ System.out.println(\"E\"); } else{ System.out.println(\"NA\"); } } } }"], "original_ll": -0.589601993560791, "sampled_ll": -0.4822142720222473, "all_perturbed_sampled_ll": [-1.286627173423767], "all_perturbed_original_ll": [-0.9349620938301086], "perturbed_sampled_ll": -1.286627173423767, "perturbed_original_ll": -0.9349620938301086, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n# 500 M\t1000 M\n# AAA \u7d1a\t35 \u79d2 50\t1 \u5206 11 \u79d2 00\n# AA \u7d1a\t37 \u79d2 50\t1 \u5206 17 \u79d2 00\n# A \u7d1a\t40 \u79d2 00\t1 \u5206 23 \u79d2 00\n# B \u7d1a\t43 \u79d2 00\t1 \u5206 29 \u79d2 00\n# C \u7d1a\t50 \u79d2 00\t1 \u5206 45 \u79d2 00\n# D \u7d1a\t55 \u79d2 00\t1 \u5206 56 \u79d2 00\n# E \u7d1a\t1\u520610 \u79d2 00\t2 \u5206 28 \u79d2 00\n\nranks = [\"AAA\",\"AA\",\"A\",\"B\",\"C\",\"D\",\"E\",\"NA\"]\ntimesA = [35.50,37.50,40,43,50,55,70]\ntimesB = [71,77,83,89,105,116,148]\n\nwhile(1):\n    try:\n        a,b = (float(x) for x in input().split())\n        rankA = rankB = 7\n        # checkA\n        for i in range(0,7):\n            if timesA[i] > a:\n                rankA = i\n                break\n        # checkB\n        for i in range(rankA,7):\n            if timesB[i] > b:\n                rankB = max(rankA,i)\n                break\n        print(ranks[rankB])\n    except:\n        break\n", "sampled": "import sys\n\ngrades = [\n    (\"AAA\", 35.50, 71.00),\n    (\"AA\", 37.50, 77.00),\n    (\"A\", 40.00, 83.00),\n    (\"B\", 43.00, 89.00),\n    (\"C\", 50.00, 105.00),\n    (\"D\", 55.00, 116.00),\n    (\"E\", 70.00, 148.00)\n]\n\nfor line in sys.stdin:\n    t1, t2 = map(float, line.strip().split())\n    \n    result = \"NA\"\n    for grade, time_500, time_1000 in grades:\n        if t1 < time_500 and t2 < time_1000:\n            result = grade\n            break\n    \n    print(result)\n", "perturbed_sampled": ["import sys grades =  37.50, 77.00), (\"A\", 40.00, 83.00), (\"B\", 43.00, 89.00), (\"C\", 50.00, 105.00), (\"D\", 55.00, 116.00), (\"E\", 70.00, 148.00) ] for line in sys.stdin:   time_500, time_1000 in grades: if t1 < time_500 and t2 < time_1000: result = grade break print(result)"], "perturbed_original": ["# 500 M 1000 M # AAA \u7d1a 35 \u79d2 50 1 \u5206 11 \u79d2   \u79d2 00 # A \u7d1a 40 \u79d2  00 # B \u7d1a 43 \u79d2 00 1 \u5206 29  50 \u79d2 00 1 \u5206 45  55 \u79d2 00 1 \u5206 56 \u79d2 00 # E \u7d1a 1\u520610 \u79d2 00 2 \u5206  [\"AAA\",\"AA\",\"A\",\"B\",\"C\",\"D\",\"E\",\"NA\"] timesA = [35.50,37.50,40,43,50,55,70] timesB = [71,77,83,89,105,116,148] while(1): try: a,b = (float(x) for x in input().split()) rankA = rankB = 7  range(0,7): if timesA[i] > a: rankA = i break # checkB for i in range(rankA,7):  = max(rankA,i) break print(ranks[rankB]) except: break"], "original_ll": -1.0338561534881592, "sampled_ll": -0.9333469867706299, "all_perturbed_sampled_ll": [-1.6040418148040771], "all_perturbed_original_ll": [-1.9502487182617188], "perturbed_sampled_ll": -1.6040418148040771, "perturbed_original_ll": -1.9502487182617188, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\ntypedef struct{\n  char name[20];\n  int point;\n}P;\nmain(){\n  int a,b,c,n,i,j,flag=0;\n  while(1){\n\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    if(flag!=0)printf(\"\\n\");\n    flag=1;\n    P temp[n];\n    P flg;\n    for(i=0;i<n;i++){\n      scanf(\"%s %d %d %d\",temp[i].name,&a,&b,&c);\n      temp[i].point=a*3+c;\n    }\n\n    for(i=0;i<n-1;i++){\n      for(j=n-1;j>i;j--){\n\tif(temp[j].point>temp[j-1].point){\n\t  flg=temp[j];\n\t  temp[j]=temp[j-1];\n\t  temp[j-1]=flg;\n\t}\n      }\n    }\n    for(i=0;i<n;i++)printf(\"%s,%d\\n\",temp[i].name,temp[i].point);}\n    \n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[21];\n    int points;\n    int order;\n} Team;\n\nint main() {\n    int n;\n    int first = 1;\n    \n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        if (!first) {\n            printf(\"\\n\");\n        }\n        first = 0;\n        \n        Team teams[10];\n        \n        for (int i = 0; i < n; i++) {\n            int w, l, d;\n            scanf(\"%s %d %d %d\", teams[i].name, &w, &l, &d);\n            teams[i].points = w * 3 + d * 1;\n            teams[i].order = i;\n        }\n        \n        // Bubble sort\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - 1 - i; j++) {\n                if (teams[j].points < teams[j + 1].points ||\n                    (teams[j].points == teams[j + 1].points && teams[j].order > teams[j + 1].order)) {\n                    Team temp = teams[j];\n                    teams[j] = teams[j + 1];\n                    teams[j + 1] = temp;\n                }\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%s,%d\\n\", teams[i].name, teams[i].points);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef  points; int order;  int n;  (1) { scanf(\"%d\", &n); if (n == 0) break; if (!first) { printf(\"\\n\"); } first = 0; Team teams[10]; for (int i = 0; i < n; i++) { int w, l, d; scanf(\"%s %d %d %d\", teams[i].name, &w, &l, &d); teams[i].points = w * 3 + d * 1; teams[i].order  sort for (int i = 0; i < n - 1; i++) { for (int j = 0; j < n  { if (teams[j].points  (teams[j].points == teams[j + 1].points && teams[j].order > teams[j + 1].order)) { Team temp = teams[j]; teams[j] = teams[j + 1]; teams[j + 1] = temp; }  n; i++) { printf(\"%s,%d\\n\",  0; }"], "perturbed_original": ["#include<stdio.h> typedef struct{ <extra_id_1>public<extra_id_2>) { if(flag){flag=1;if(flag==3){flag=1;} } ; } main(){ int a,b,c,n,i,j,flag=0; while(1){  temp[n]; P flg; for(i=0;i<n;i++){ scanf(\"%s %d %d %d\",temp[i].name,&a,&b,&c); temp[i].point=a*3+c; } for(i=0;i<n-1;i++){ for(j=n-1;j>i;j--){ if(temp[j].point>temp[j-1].point){ flg=temp[j]; temp[j]=temp[j-1]; temp[j-1]=flg; } } } for(i=0;i<n;i++)printf(\"%s,%d\\n\",temp[i].name,temp[i].point);} return 0; }"], "original_ll": -0.9878860712051392, "sampled_ll": -0.431863397359848, "all_perturbed_sampled_ll": [-1.3416250944137573], "all_perturbed_original_ll": [-1.7765408754348755], "perturbed_sampled_ll": -1.3416250944137573, "perturbed_original_ll": -1.7765408754348755, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n  public static void main (String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    String out = \"\";\n    while (scanner.hasNext()) {\n      int n = scanner.nextInt();\n      if (n == 0) {\n        break;\n      }\n      List<String> ts = new ArrayList<String>();\n      for (int ii = 0; ii < n; ii++) {\n        String t = scanner.next();\n        int w = scanner.nextInt();\n        int l = scanner.nextInt();\n        int d = scanner.nextInt();\n        String wp = \"0000\" + (w * 3 + d);\n        wp = wp.substring(wp.length() - 5);\n        String idx = \"00\" + (n - ii);\n        idx = idx.substring(idx.length() - 3);\n        ts.add(wp + \",\" + idx + \",\" + t);\n      }\n      Collections.sort(ts);\n      Collections.reverse(ts);\n      for (String el : ts) {\n        String[] works = el.split(\",\");\n        int wp = Integer.parseInt(works[0]);\n        out += works[2] + \",\" + wp + \"\\n\";\n      }\n      out += \"\\n\";\n    }\n    System.out.print(out.substring(0, out.length() - 1));\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Team {\n        String name;\n        int points;\n        int order;\n        \n        Team(String name, int points, int order) {\n            this.name = name;\n            this.points = points;\n            this.order = order;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        boolean first = true;\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            if (!first) {\n                System.out.println();\n            }\n            first = false;\n            \n            List<Team> teams = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                int w = sc.nextInt();\n                int l = sc.nextInt();\n                int d = sc.nextInt();\n                \n                int points = w * 3 + d * 1;\n                teams.add(new Team(name, points, i));\n            }\n            \n            teams.sort((a, b) -> {\n                if (a.points != b.points) {\n                    return b.points - a.points;\n                }\n                return a.order - b.order;\n            });\n            \n            for (Team team : teams) {\n                System.out.println(team.name + \",\" + team.points);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Team { String name; int points; int order; Team(String name, int points, int order)   } } public static void main(String[] args) {  boolean  sc.nextInt(); if (n == 0) break; if (!first) { System.out.println(); } first = false; List<Team> teams = new ArrayList<>(); for  < n; i++) { String name = sc.next(); int w = sc.nextInt(); int l = sc.nextInt(); int d = sc.nextInt(); int points = w * 3 + d *  } teams.sort((a, b) -> { if (a.points != b.points) { return b.points -  b.order; }); for (Team team :  + team.points); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); String out  if (n == 0) { break; } List<String> ts = new ArrayList<String>(); for (int ii = 0; ii < n; ii++) {  l = scanner.nextInt(); int d = scanner.nextInt(); String wp = \"0000\" +  wp =  = \"00\" + (n - ii); idx = idx.substring(idx.length() - 3); ts.add(wp + \",\" + idx + \",\" + t); } Collections.sort(ts); Collections.reverse(ts); for (String el  = el.split(\",\"); int wp = Integer.parseInt(works[0]); out += works[2] +  } out += \"\\n\"; } System.out.print(out.substring(0, out.length() - 1)); } }"], "original_ll": -0.8904496431350708, "sampled_ll": -0.3944127559661865, "all_perturbed_sampled_ll": [-1.8510562181472778], "all_perturbed_original_ll": [-2.1001384258270264], "perturbed_sampled_ll": -1.8510562181472778, "perturbed_original_ll": -2.1001384258270264, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "isPrint = False\n\nwhile True:\n\n    inputCount = int(input())\n\n    if inputCount == 0:\n        break\n\n    if isPrint:\n        print()\n    else:\n        isPrint = True\n\n    matchList = []\n\n    for lp in range(inputCount):\n\n        name, win, lose, draw = [item for item in input().split(\" \")]\n        score = int(win) * 3 + int(draw)\n\n        matchList.append([name, score])\n\n    matchList.sort(key=lambda item: -item[1])\n\n    for name, score in matchList:\n        print(name + \",\" + str(score))\n\n", "sampled": "results = []\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    teams = []\n    for i in range(n):\n        parts = input().split()\n        name = parts[0]\n        w = int(parts[1])\n        l = int(parts[2])\n        d = int(parts[3])\n        points = w * 3 + d * 1\n        teams.append((name, points, i))\n    \n    teams.sort(key=lambda x: (-x[1], x[2]))\n    \n    result = []\n    for team in teams:\n        result.append(f\"{team[0]},{team[1]}\")\n    \n    results.append(result)\n\nfor i, result in enumerate(results):\n    for line in result:\n        print(line)\n    if i < len(results) - 1:\n        print()\n", "perturbed_sampled": ["results = [] while True: n <extra_id_3>2: print() 0: break teams = [] <extra_id_4>0: return if (d <<extra_id_5>/ 3): print() = input().split() name = parts[0] w = <extra_id_6>1: = int(parts[3]) points = w * 3 + d * 1 teams.append((name, points, i)) teams.sort(key=lambda x: (-x[1], x[2])) result = [] for team in teams: result.append(f\"{team[0]},{team[1]}\") results.append(result) for i, result in enumerate(results): for line in result: print(line)  1: print()"], "perturbed_original": ["isPrint = False while True: inputCount  0: break if isPrint: print() else: isPrint = True matchList = [] for lp in range(inputCount): name, win, lose, draw = [item for item in input().split(\" \")] score = int(win) * 3 + int(draw)  matchList: print(name + \",\" + str(score))"], "original_ll": -1.2044012546539307, "sampled_ll": -0.5875434279441833, "all_perturbed_sampled_ll": [-2.3260676860809326], "all_perturbed_original_ll": [-2.648277759552002], "perturbed_sampled_ll": -2.3260676860809326, "perturbed_original_ll": -2.648277759552002, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<time.h>\n#include<string.h>\nint main(void) {\n\ttime_t tim1,tim2;\n\tstruct tm d;\n\tdouble diff;\n\tint year1, year2, month1, month2, day1, day2;\n\twhile (1) {\n\t\tscanf(\"%d %d %d %d %d %d\",&year1,&month1,&day1,&year2,&month2,&day2);\n\t\tif (month1 == -1 || year1 == -1 || day1 == -1 ||month2 == -1 || year2 == -1 || day2 == -1) break;\n\t\tmemset(&d,0,sizeof(d));\n\t\td.tm_year = year1 - 1900;\n\t\td.tm_mon = month1 - 1;\n\t\td.tm_mday = day1;\n\t\ttim1 = mktime(&d);\n\t\td.tm_year = year2 - 1900;\n\t\td.tm_mon = month2 - 1;\n\t\td.tm_mday = day2;\n\t\ttim2 = mktime(&d);\n\n\t\tdiff = difftime(tim2, tim1);\n\n\t\tprintf(\"%d\\n\",(int)(diff/60/60/24+0.5));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint is_leap(int year) {\n    if (year % 400 == 0) return 1;\n    if (year % 100 == 0) return 0;\n    if (year % 4 == 0) return 1;\n    return 0;\n}\n\nint days_in_month(int year, int month) {\n    int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    if (month == 2 && is_leap(year)) {\n        return 29;\n    }\n    return days[month];\n}\n\nint days_from_epoch(int year, int month, int day) {\n    int total = 0;\n    \n    // Add days for complete years from year 1\n    for (int y = 1; y < year; y++) {\n        if (is_leap(y)) {\n            total += 366;\n        } else {\n            total += 365;\n        }\n    }\n    \n    // Add days for complete months in the current year\n    for (int m = 1; m < month; m++) {\n        total += days_in_month(year, m);\n    }\n    \n    // Add the days\n    total += day;\n    \n    return total;\n}\n\nint main() {\n    int y1, m1, d1, y2, m2, d2;\n    \n    while (scanf(\"%d %d %d %d %d %d\", &y1, &m1, &d1, &y2, &m2, &d2) == 6) {\n        if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) {\n            break;\n        }\n        \n        int days1 = days_from_epoch(y1, m1, d1);\n        int days2 = days_from_epoch(y2, m2, d2);\n        \n        printf(\"%d\\n\", days2 - days1);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["/0 = 1;<extra_id_1>| TWO_DAYS| 366| 664| 264|<extra_id_2>int y = 0; do<extra_id_3>623|212|215|29|30|31|30|30|31|331|30|293|1|28|37|37|362|319|372|330|930|930|3963|303:57|330: { if (year  1; if (year %   0) return 1; return 0; } int days_in_month(int year, int month) { int days[]  30, 31, 30,  2 && is_leap(year)) { return 29; } return days[month]; } int days_from_epoch(int year, int month, int day) { int total = 0; // Add days for complete years from year 1 for (int y = 1; y < year; y++) {  366; } else { total += 365; } } // Add days for complete months  (int m = 1;   // Add the  total; } int main() { int y1, m1, d1, y2, m2, d2; while (scanf(\"%d %d %d %d  &y2, &m2, &d2) == 6) { if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) { break; } int days1 = days_from_epoch(y1, m1, d1); int days2 = days_from_epoch(y2, m2, d2); printf(\"%d\\n\", days2 - days1); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<time.h> #include<string.h> int main(void) { time_t tim1,tim2; struct tm d; double diff; int year1, year2, month1, month2, day1, day2;  %d %d %d %d\",&year1,&month1,&day1,&year2,&month2,&day2); if (month1 == -1 || year1 == -1 || day1 == -1 ||month2 == -1 || year2 == -1 || day2 == -1) break; memset(&d,0,sizeof(d)); d.tm_year = year1 - 1900; d.tm_mon = month1 -  = mktime(&d); d.tm_year = year2 -  = difftime(tim2, tim1); printf(\"%d\\n\",(int)(diff/60/60/24+0.5)); } return 0; }"], "original_ll": -0.6324153542518616, "sampled_ll": -0.31366246938705444, "all_perturbed_sampled_ll": [-1.7284082174301147], "all_perturbed_original_ll": [-1.2847238779067993], "perturbed_sampled_ll": -1.7284082174301147, "perturbed_original_ll": -1.2847238779067993, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n\npublic class Main {\n\n\tfinal int DAY_MONTH[]={0, 31, 28, 31, 30, 31, 30, 31, 31, 30 ,31, 30 ,31};\n\t\n\tScanner sc;\n\t\n\tint isLeap(int y){\n\t\tif(y%4==0){\n\t\t\tif(y%100==0){\n\t\t\t\tif(y%400==0){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tint dayCount(int y, int m1, int d1, int m2, int d2){\n\t\tint days=-d1;\n\t\tfor(int m=m1;m<=m2;++m){\n\t\t\tdays+=DAY_MONTH[m];\n\t\t\tif(m==2) days+=isLeap(y);\n\t\t}\n\t\tdays-=DAY_MONTH[m2]+(m2==2?isLeap(y):0)-d2;\n\t\treturn days;\n\t}\n\t\n\tint solve(int y1, int m1, int d1, int y2, int m2, int d2){\n\t\tint days=0;\n\t\tif(y2-y1>=2){\n\t\t\tfor(int y=y1+1;y<y2;++y){\n\t\t\t\tdays+=365+isLeap(y);\n\t\t\t}\n\t\t}\n\t\tif(y2-y1>=1){\n\t\t\tdays+=dayCount(y1, m1, d1, 12, 31)+dayCount(y2, 1, 1, m2, d2)+1;\n\t\t}\n\t\telse{\n\t\t\tdays=dayCount(y1, m1, d1, m2, d2);\n\t\t}\n\t\treturn days;\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint y1=ni(), m1=ni(), d1=ni(), y2=ni(), m2=ni(), d2=ni();\n\t\t\tif(y1<0||m1<0||d1<0||y2<0||m2<0||d2<0) break;\n\t\t\t\n\t\t\tSystem.out.println(solve(y1, m1, d1, y2, m2, d2));\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int y1 = sc.nextInt();\n            int m1 = sc.nextInt();\n            int d1 = sc.nextInt();\n            int y2 = sc.nextInt();\n            int m2 = sc.nextInt();\n            int d2 = sc.nextInt();\n            \n            if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) {\n                break;\n            }\n            \n            int days = countDays(y1, m1, d1, y2, m2, d2);\n            System.out.println(days);\n        }\n        \n        sc.close();\n    }\n    \n    static int countDays(int y1, int m1, int d1, int y2, int m2, int d2) {\n        int days1 = toDays(y1, m1, d1);\n        int days2 = toDays(y2, m2, d2);\n        return days2 - days1;\n    }\n    \n    static int toDays(int year, int month, int day) {\n        int days = 0;\n        \n        // Count days for complete years from year 1\n        for (int y = 1; y < year; y++) {\n            if (isLeapYear(y)) {\n                days += 366;\n            } else {\n                days += 365;\n            }\n        }\n        \n        // Count days for complete months in the current year\n        for (int m = 1; m < month; m++) {\n            days += getDaysInMonth(year, m);\n        }\n        \n        // Add remaining days\n        days += day;\n        \n        return days;\n    }\n    \n    static boolean isLeapYear(int year) {\n        if (year % 400 == 0) {\n            return true;\n        }\n        if (year % 100 == 0) {\n            return false;\n        }\n        if (year % 4 == 0) {\n            return true;\n        }\n        return false;\n    }\n    \n    static int getDaysInMonth(int year, int month) {\n        int[] days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        \n        if (month == 2 && isLeapYear(year)) {\n            return 29;\n        }\n        \n        return days[month];\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner   sc.nextInt(); int m1 = sc.nextInt(); int d1 = sc.nextInt(); int y2 = sc.nextInt(); int m2 = sc.nextInt(); int d2 = sc.nextInt(); if  < 0 || d1 < 0 || y2 <  {  countDays(y1, m1, d1, y2, m2, d2); System.out.println(days); } sc.close(); } static int countDays(int y1, int m1, int d1, int y2, int m2, int d2) { int days1 = toDays(y1, m1, d1); int days2 = toDays(y2, m2, d2); return days2 - days1; } static int toDays(int  { int days = 0; // Count days for complete  (int y = 1; y < year; y++) { if (isLeapYear(y)) { days += 366; } else  the current year for (int m = 1; m < month;  m); } // Add  return days;  { if (year % 400 == 0) { return true; }  0) { return false; } if (year % 4 == 0) { return true; } return false; } static int getDaysInMonth(int year, int  {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; if (month == 2 && isLeapYear(year)) { return 29; } return days[month]; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { final int DAY_MONTH[]={0, 31, 28, 31, 30, 31, 30, 31, 31, 30 ,31, 30 ,31}; Scanner sc; int isLeap(int y){  } else{ return 0; } } else{ return 1; } } else{ return 0; } } int dayCount(int y, int m1,    return days; } int solve(int  int y2, int m2, int d2){ int days=0; if(y2-y1>=2){ for(int y=y1+1;y<y2;++y){ days+=365+isLeap(y); } } if(y2-y1>=1){ days+=dayCount(y1, m1, d1, 12, 31)+dayCount(y2, 1, 1,  m1, d1, m2, d2); } return days; } int ni(){  sc=new Scanner(System.in); while(true){ int y1=ni(), m1=ni(), d1=ni(),  System.out.println(solve(y1, m1, d1, y2,  public static void main(String[] args) { // TODO Auto-generated method stub new Main().io(); } }"], "original_ll": -0.5285140872001648, "sampled_ll": -0.24100540578365326, "all_perturbed_sampled_ll": [-1.065760850906372], "all_perturbed_original_ll": [-1.333387851715088], "perturbed_sampled_ll": -1.065760850906372, "perturbed_original_ll": -1.333387851715088, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f1():\n    if y1 == y2 and m1 == m2:\n        return d2- d1\n    \n    a = 0\n    if y1 % 400 == 0 or (y1 % 4 == 0 and y1 % 100 != 0):\n        a = 29\n    else:\n        a = 28\n    \n    t = 0\n    if m1 in [4,6,9,11]:\n        t += (30 - d1 + 1)\n    elif m1 in [1,3,5,7,8,10,12]:\n        t += (31 - d1 + 1)\n    else:\n        t += (a - d1 + 1)\n        \n        \n    if y1 == y2:\n        return f3(t, m1+1)\n    else:\n        for m in range(m1+1, 13):\n            if m in [4,6,9,11]:\n                t += 30\n            elif m in [1,3,5,7,8,10,12]:\n                t += 31\n            else:\n                t += a\n            \n        return f2(t)\n    \ndef f2(t):\n    for y in range(y1+1, y2):\n        if y % 400 == 0 or (y % 4 == 0 and y % 100 != 0):\n            t += 366\n        else:\n            t += 365\n    \n    return f3(t, 1)\n    \ndef f3(t, s):\n    a = 0\n    if y2 % 400 == 0 or (y2 % 4 == 0 and y2 % 100 != 0):\n        a = 29\n    else:\n        a = 28\n        \n    for m in range(s, m2):\n        if m in [4,6,9,11]:\n            t += 30\n        elif m in [1,3,5,7,8,10,12]:\n            t += 31\n        else:\n            t += a\n            \n    t += (d2 - 1)\n            \n    return t\n            \nwhile True:\n    y1, m1, d1, y2, m2, d2 = map(int, raw_input().split())\n    if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0:\n        break\n    print f1()", "sampled": "def is_leap_year(year):\n    if year % 400 == 0:\n        return True\n    if year % 100 == 0:\n        return False\n    if year % 4 == 0:\n        return True\n    return False\n\ndef days_in_month(year, month):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month in [4, 6, 9, 11]:\n        return 30\n    elif month == 2:\n        return 29 if is_leap_year(year) else 28\n\ndef days_from_epoch(year, month, day):\n    # Calculate days from year 0\n    days = 0\n    \n    # Add days for complete years\n    for y in range(1, year):\n        if is_leap_year(y):\n            days += 366\n        else:\n            days += 365\n    \n    # Add days for complete months in the current year\n    for m in range(1, month):\n        days += days_in_month(year, m)\n    \n    # Add remaining days\n    days += day\n    \n    return days\n\nwhile True:\n    line = list(map(int, input().split()))\n    y1, m1, d1, y2, m2, d2 = line\n    \n    if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0:\n        break\n    \n    days1 = days_from_epoch(y1, m1, d1)\n    days2 = days_from_epoch(y2, m2, d2)\n    \n    print(days2 - days1)\n", "perturbed_sampled": ["def is_leap_year(year): if year %   0:  True return False def days_in_month(year, month): if month in  10, 12]: return 31 elif  11]: return 30 elif month == 2: return 29 if is_leap_year(year) else 28 def days_from_epoch(year, month, day): # Calculate days from year 0 days  for complete years for y in range(1, year): if is_leap_year(y): days += 366  Add days for complete months in the current year for m in range(1, month): days +=  days days += day return days while True: line = list(map(int, input().split())) y1, m1, d1, y2, m2, d2 = line if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0: break days1 = days_from_epoch(y1,  m2, d2) print(days2 - days1)"], "perturbed_original": ["def  and m1 == m2: return d2- d1 a = 0  0 or (y1 % 4 == 0 and y1 % 100 != 0): a = 29 else: a = 28 t = 0 if   t += (31 - d1 + 1) else: t += (a - d1 + 1) if y1  else: for m  in [4,6,9,11]: t += 30 elif m in [1,3,5,7,8,10,12]: t += 31  f2(t) def  y2): if y % 400 == 0 or (y % 4 == 0 and y % 100 != 0): t += 366 else: t  def f3(t, s): a  400 == 0 or (y2 % 4 == 0 and y2 % 100 != 0): a  28 for m in range(s, m2): if m in [4,6,9,11]: t += 30 elif m in [1,3,5,7,8,10,12]: t += 31 else: t += a t += (d2 - 1) return t while True: y1, m1, d1, y2, m2, d2 = map(int,  or  < 0 or y2 < 0 or m2 < 0 or d2 < 0: break print f1()"], "original_ll": -0.5237615704536438, "sampled_ll": -0.3621664345264435, "all_perturbed_sampled_ll": [-1.4681212902069092], "all_perturbed_original_ll": [-1.363427996635437], "perturbed_sampled_ll": -1.4681212902069092, "perturbed_original_ll": -1.363427996635437, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "v[81],e[81];\nB(p,s0,s1){\n\tint f[10]={0},i,j;\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tif(f[v[p]])\n\t\t\t\te[~f[v[p]]]=e[p]=1;\n\t\t\telse\n\t\t\t\tf[v[p]]=~p;\n\t\t\tp+=s0;\n\t\t}\n\t\tp+=s1-3*s0;\n\t}\n}\nmain(i,f){\n\tscanf(\"%*d\\n\");\n\tfor(f=i=0;~scanf(\"%d\",v+i);){\n\t\tif(++i==81){\n\t\t\tmemset(e,0,sizeof(e));\n\t\t\tfor(i=0;i<9;i++){\n\t\t\t\tB(0+i*9,1+0*9,3+0*9);\n\t\t\t\tB(i+0*9,0+1*9,0+3*9);\n\t\t\t\tB(i%3*3+i/3*3*9,1+0*9,0+1*9);\n\t\t\t}\n\t\t\tif(f++)\n\t\t\t\tputs(\"\");\n\t\t\tfor(i=0;i<81;i++){\n\t\t\t\tprintf(\"%c%d\",e[i]?'*':' ',v[i]);\n\t\t\t\tif(i%9==8)\n\t\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t\ti=0;\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int dataset = 0; dataset < n; dataset++) {\n        int grid[9][9];\n        int error[9][9];\n        \n        // Read input\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                scanf(\"%d\", &grid[i][j]);\n                error[i][j] = 0;\n            }\n        }\n        \n        // Check rows\n        for (int i = 0; i < 9; i++) {\n            int count[10] = {0};\n            for (int j = 0; j < 9; j++) {\n                count[grid[i][j]]++;\n            }\n            for (int j = 0; j < 9; j++) {\n                if (count[grid[i][j]] > 1) {\n                    error[i][j] = 1;\n                }\n            }\n        }\n        \n        // Check columns\n        for (int j = 0; j < 9; j++) {\n            int count[10] = {0};\n            for (int i = 0; i < 9; i++) {\n                count[grid[i][j]]++;\n            }\n            for (int i = 0; i < 9; i++) {\n                if (count[grid[i][j]] > 1) {\n                    error[i][j] = 1;\n                }\n            }\n        }\n        \n        // Check 3x3 blocks\n        for (int block_i = 0; block_i < 3; block_i++) {\n            for (int block_j = 0; block_j < 3; block_j++) {\n                int count[10] = {0};\n                for (int i = block_i * 3; i < block_i * 3 + 3; i++) {\n                    for (int j = block_j * 3; j < block_j * 3 + 3; j++) {\n                        count[grid[i][j]]++;\n                    }\n                }\n                for (int i = block_i * 3; i < block_i * 3 + 3; i++) {\n                    for (int j = block_j * 3; j < block_j * 3 + 3; j++) {\n                        if (count[grid[i][j]] > 1) {\n                            error[i][j] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Output\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (error[i][j]) {\n                    printf(\"*%d\", grid[i][j]);\n                } else {\n                    printf(\" %d\", grid[i][j]);\n                }\n                if (j < 8) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n        \n        if (dataset < n - 1) {\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; scanf(\"%d\", &n); for (int dataset = 0; dataset < n; dataset++) { int grid[9][9]; int error[9][9]; // Read input for (int i  i++) { for (int j = 0; j < 9; j++)  0; } } // Check rows for  < 9; i++) { int count[10] = {0}; for   } for (int j = 0; j < 9; j++) {   } // Check columns for (int j = 0; j < 9; j++) { int count[10]  = 0; i <  for (int i = 0; i < 9; i++) { if (count[grid[i][j]] > 1) { error[i][j] = 1; } } } // Check 3x3  0; block_i < 3; block_i++) { for (int block_j = 0; block_j  count[10] = {0}; for (int i = block_i * 3; i  3; i++) { for (int j = block_j * 3; j < block_j * 3 + 3; j++) { count[grid[i][j]]++; } } for (int i = block_i * 3; i  3; i++) { for (int j = block_j * 3; j < block_j * 3 + 3; j++) { if (count[grid[i][j]] > 1) { error[i][j] = 1; } } } } } // Output for (int i = 0;  for (int j = 0;   }   printf(\" \");  < n - 1) { printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["v[81],e[81]; B(p,s0,s1){ int f[10]={0},i,j; for(i=0;i<3;i++){ for(j=0;j<3;j++){ if(f[v[p]]) e[~f[v[p]]]=e[p]=1; else f[v[p]]=~p; p+=s0; } p+=s1-3*s0; } } main(i,f){  B(0+i*9,1+0*9,3+0*9); B(i+0*9,0+1*9,0+3*9); B(i%3*3+i/3*3*9,1+0*9,0+1*9); } if(f++) puts(\"\"); for(i=0;i<81;i++){ printf(\"%c%d\",e[i]?'*':' ',v[i]);  } }"], "original_ll": -1.4610804319381714, "sampled_ll": -0.21174786984920502, "all_perturbed_sampled_ll": [-1.0386230945587158], "all_perturbed_original_ll": [-1.9023241996765137], "perturbed_sampled_ll": -1.0386230945587158, "perturbed_original_ll": -1.9023241996765137, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nclass Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        for (int i = 0; i < n; i++) {\n            int[][] map = new int[9][9];\n            boolean[][] ok = new boolean[9][9];\n            for (int j = 0; j < 9; j++) {\n                String[] input = br.readLine().split(\" \");\n                for (int k = 0; k < 9; k++) {\n                    map[j][k] = Integer.parseInt(input[k]);\n                }\n            }\n\n            // horizontal check\n            for (int j = 0; j < 9; j++) {\n                boolean[] oneToNine = new boolean[10]; // index0\u306f\u4f7f\u308f\u306a\u3044\n                for (int k = 0; k < 9; k++) {\n                    if (!oneToNine[map[j][k]]) {\n                        oneToNine[map[j][k]] = true;\n                    } else {\n                        ok[j][k] = true;\n                        for (int l = 0; l < k; l++) {\n                            if (map[j][l] == map[j][k]) {\n                                ok[j][l] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // vertical check\n            for (int j = 0; j < 9; j++) {\n                boolean[] oneToNine = new boolean[10];\n                for (int k = 0; k < 9; k++) {\n                    if (!oneToNine[map[k][j]]) {\n                        oneToNine[map[k][j]] = true;\n                    } else {\n                        ok[k][j] = true;\n                        for (int l = 0; l < k; l++) {\n                            if (map[l][j] == map[k][j]) {\n                                ok[l][j] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // display\n            for (int j = 0; j < 9; j++) {\n                for (int k = 0; k < 9; k++) {\n                    if (ok[j][k])\n                        System.out.print(\"*\");\n                    else\n                        System.out.print(\" \");\n\n                    System.out.print(map[j][k]);\n                }\n                System.out.println();\n            }\n\n        }\n    }\n}\n", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int t = 0; t < n; t++) {\n            if (t > 0) {\n                System.out.println();\n            }\n            \n            int[][] grid = new int[9][9];\n            for (int i = 0; i < 9; i++) {\n                String line = sc.nextLine();\n                String[] tokens = line.trim().split(\"\\\\s+\");\n                for (int j = 0; j < 9; j++) {\n                    grid[i][j] = Integer.parseInt(tokens[j]);\n                }\n            }\n            \n            boolean[][] error = new boolean[9][9];\n            \n            // Check rows\n            for (int i = 0; i < 9; i++) {\n                int[] count = new int[10];\n                for (int j = 0; j < 9; j++) {\n                    count[grid[i][j]]++;\n                }\n                for (int j = 0; j < 9; j++) {\n                    if (count[grid[i][j]] > 1) {\n                        error[i][j] = true;\n                    }\n                }\n            }\n            \n            // Check columns\n            for (int j = 0; j < 9; j++) {\n                int[] count = new int[10];\n                for (int i = 0; i < 9; i++) {\n                    count[grid[i][j]]++;\n                }\n                for (int i = 0; i < 9; i++) {\n                    if (count[grid[i][j]] > 1) {\n                        error[i][j] = true;\n                    }\n                }\n            }\n            \n            // Check 3x3 blocks\n            for (int blockRow = 0; blockRow < 3; blockRow++) {\n                for (int blockCol = 0; blockCol < 3; blockCol++) {\n                    int[] count = new int[10];\n                    for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) {\n                        for (int j = blockCol * 3; j < blockCol * 3 + 3; j++) {\n                            count[grid[i][j]]++;\n                        }\n                    }\n                    for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) {\n                        for (int j = blockCol * 3; j < blockCol * 3 + 3; j++) {\n                            if (count[grid[i][j]] > 1) {\n                                error[i][j] = true;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // Output\n            for (int i = 0; i < 9; i++) {\n                for (int j = 0; j < 9; j++) {\n                    if (error[i][j]) {\n                        System.out.print(\"*\");\n                    } else {\n                        System.out.print(\" \");\n                    }\n                    System.out.print(grid[i][j]);\n                }\n                System.out.println();\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner  n = sc.nextInt(); sc.nextLine(); for (int t = 0; t < n; t++) { if (t > 0) { System.out.println(); } int[][] grid  i = 0; i < 9; i++) { String line = sc.nextLine(); String[] tokens =   { grid[i][j] = Integer.parseInt(tokens[j]); }  for (int i = 0; i < 9; i++) { int[] count =  = 0; j < 9; j++) { count[grid[i][j]]++; } for (int j = 0; j < 9; j++) { if (count[grid[i][j]] > 1) { error[i][j] = true; } }  (int  9; j++) { int[] count = new  i++) { count[grid[i][j]]++; } for (int i  i++) { if (count[grid[i][j]] > 1) { error[i][j] = true; } } } // Check  3; blockRow++) { for (int blockCol  blockCol++) {  for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) { for (int j = blockCol * 3; j < blockCol * 3 + 3; j++) { count[grid[i][j]]++; } } for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) { for (int j = blockCol * 3;  + 3; j++) { if (count[grid[i][j]] > 1) { error[i][j]  } } // Output for (int i = 0; i < 9; i++) { for (int j = 0; j < 9; j++) { if (error[i][j])  System.out.print(\" \"); } System.out.print(grid[i][j]); } System.out.println(); } } sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.io.BufferedReader;   throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); for (int i  i++)  int[9][9]; boolean[][] ok = new boolean[9][9]; for (int j = 0; j < 9; j++) { String[] input = br.readLine().split(\"  0; k < 9; k++) { map[j][k] = Integer.parseInt(input[k]); } } // horizontal check for (int  oneToNine = new boolean[10]; // index0\u306f\u4f7f\u308f\u306a\u3044 for (int k = 0; k < 9; k++) { if (!oneToNine[map[j][k]]) { oneToNine[map[j][k]] = true; } else { ok[j][k] =  l++) { if (map[j][l] == map[j][k]) { ok[j][l] =  } } // vertical check for (int j = 0; j < 9; j++) { boolean[] oneToNine = new boolean[10]; for (int k = 0; k < 9; k++) { if (!oneToNine[map[k][j]]) { oneToNine[map[k][j]] = true;   0; l <  == map[k][j]) { ok[l][j] = true; break; } } } } } // display for (int j = 0; j < 9; j++) { for (int k = 0; k < 9;  else System.out.print(\" \"); System.out.print(map[j][k]); } System.out.println(); } } } }"], "original_ll": -0.3718263804912567, "sampled_ll": -0.1958947628736496, "all_perturbed_sampled_ll": [-0.9951632022857666], "all_perturbed_original_ll": [-1.2428675889968872], "perturbed_sampled_ll": -0.9951632022857666, "perturbed_original_ll": -1.2428675889968872, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "R=range(9)\ndef f1(M):\n  global F\n  for y in R:\n    A=M[y]\n    if len(set(A))==9: continue\n    for x in R:\n      if A.count(A[x])>=2: F[y][x]=\"*\"\n  return\ndef f2(M):\n  global F\n  for x in R:\n    A=[M[y][x] for y in R]\n    if len(set(A))==9: continue\n    for y in R:\n      if A.count(A[y])>=2: F[y][x]=\"*\"\n  return\ndef f3(M):\n  global F\n  for i in R:\n    x=i%3*3\n    y=i/3*3\n    A=M[y][x:x+3]+M[y+1][x:x+3]+M[y+2][x:x+3]\n    if len(set(A))==9: continue\n    for j in R:\n      if A.count(A[j])>=2: F[y+j/3][x+j%3]=\"*\"\n  return\n\nn=input()\nwhile n:\n  M=[]\n  F=[[\" \" for _ in [0]*9] for _ in [0]*9]\n  M=[map(int,raw_input().split()) for _ in [0]*9]\n  f1(M)\n  f2(M)\n  f3(M)\n  for i in R:\n    s=zip(F[i],map(str,M[i]))\n    print \"\".join([a+b for a,b in s])\n  if n>1: print\n  n-=1", "sampled": "def solve():\n    n = int(input())\n    \n    for dataset_idx in range(n):\n        grid = []\n        for _ in range(9):\n            row = list(map(int, input().split()))\n            grid.append(row)\n        \n        # Mark errors\n        errors = [[False] * 9 for _ in range(9)]\n        \n        # Check rows\n        for i in range(9):\n            counts = {}\n            for j in range(9):\n                val = grid[i][j]\n                if val not in counts:\n                    counts[val] = []\n                counts[val].append(j)\n            \n            for val, positions in counts.items():\n                if len(positions) > 1:\n                    for j in positions:\n                        errors[i][j] = True\n        \n        # Check columns\n        for j in range(9):\n            counts = {}\n            for i in range(9):\n                val = grid[i][j]\n                if val not in counts:\n                    counts[val] = []\n                counts[val].append(i)\n            \n            for val, positions in counts.items():\n                if len(positions) > 1:\n                    for i in positions:\n                        errors[i][j] = True\n        \n        # Check 3x3 blocks\n        for block_row in range(3):\n            for block_col in range(3):\n                counts = {}\n                for i in range(block_row * 3, block_row * 3 + 3):\n                    for j in range(block_col * 3, block_col * 3 + 3):\n                        val = grid[i][j]\n                        if val not in counts:\n                            counts[val] = []\n                        counts[val].append((i, j))\n                \n                for val, positions in counts.items():\n                    if len(positions) > 1:\n                        for i, j in positions:\n                            errors[i][j] = True\n        \n        # Output\n        for i in range(9):\n            output = []\n            for j in range(9):\n                if errors[i][j]:\n                    output.append('*' + str(grid[i][j]))\n                else:\n                    output.append(' ' + str(grid[i][j]))\n            print(''.join(output))\n        \n        if dataset_idx < n - 1:\n            print()\n\nsolve()\n", "perturbed_sampled": ["def solve(): n = int(input()) for dataset_idx in range(n): grid = []  = list(map(int, input().split())) grid.append(row) # Mark errors errors  _ in range(9)] # Check rows for i in range(9): counts = {} for j in range(9): val =  counts: counts[val] = [] counts[val].append(j) for val, positions in counts.items():   True # Check columns for j in range(9): counts = {} for i in range(9): val  in  counts.items(): if  in positions: errors[i][j] = True # Check 3x3 blocks for block_row in range(3): for block_col in range(3): counts = {} for i in range(block_row * 3, block_row * 3 + 3): for j in range(block_col * 3,  val = grid[i][j] if val not in counts: counts[val] = [] counts[val].append((i, j)) for val, positions in counts.items(): if   True # Output for i in range(9): output = [] for j in range(9): if errors[i][j]: output.append('*' + str(grid[i][j])) else: output.append(' ' + str(grid[i][j])) print(''.join(output)) if dataset_idx < n - 1: print() solve()"], "perturbed_original": ["R=range(9) def f1(M): global  A=M[y] if len(set(A))==9: continue  A.count(A[x])>=2: F[y][x]=\"*\" return def f2(M): global  R] if len(set(A))==9: continue for y in R: if A.count(A[y])>=2: F[y][x]=\"*\" return def f3(M): global F for i  if len(set(A))==9: continue for j in R: if A.count(A[j])>=2: F[y+j/3][x+j%3]=\"*\" return n=input() while n: M=[] F=[[\" \" for _ in [0]*9] for _ in [0]*9] M=[map(int,raw_input().split()) for _ in [0]*9] f1(M) f2(M) f3(M) for i in R: s=zip(F[i],map(str,M[i])) print  if n>1: print n-=1"], "original_ll": -0.7744231820106506, "sampled_ll": -0.3624174892902374, "all_perturbed_sampled_ll": [-1.404350757598877], "all_perturbed_original_ll": [-1.8118618726730347], "perturbed_sampled_ll": -1.404350757598877, "perturbed_original_ll": -1.8118618726730347, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-7)\n\ntypedef struct {\n\tint x,y,r;\n} wall_t;\n\ntypedef struct {\n\tint tx,ty,sx,sy;\n} query_t;\n\nint hitcheck_circle(wall_t w,query_t q) {\n\tint in=0;\n\tint a,b,c;\n\tint minx,miny,maxx,maxy,temp;\n\t/* sieve */\n\tminx=q.tx;maxx=q.sx;\n\tif(minx>maxx){temp=minx;minx=maxx;maxx=temp;}\n\tminy=q.ty;maxy=q.sy;\n\tif(miny>maxy){temp=miny;miny=maxy;maxy=temp;}\n\tif(w.x+w.r<minx || maxx<w.x-w.r)return 0;\n\tif(w.y+w.r<miny || maxy<w.y-w.r)return 0;\n\t/* check if dist<=r */\n\tif((q.tx-w.x)*(q.tx-w.x)+(q.ty-w.y)*(q.ty-w.y)<=w.r*w.r)in++;\n\tif((q.sx-w.x)*(q.sx-w.x)+(q.sy-w.y)*(q.sy-w.y)<=w.r*w.r)in++;\n\tif(in==1)return 1;\n\tif(in==2)return 0;\n\ta=q.ty-q.sy;\n\tb=q.sx-q.tx;\n\tc=(q.tx-q.sx)*q.ty-(q.ty-q.sy)*q.tx;\n\tif((a*w.x+b*w.y+c)*(a*w.x+b*w.y+c)<=w.r*w.r*(a*a+b*b)) {\n\t\t/* check if really hit */\n\t\tc=-c; /* convert a*x+b*y+c=0 to a*x+b*y=c */\n\t\tif(b==0) {\n\t\t\tdouble yy=w.r*w.r-((double)c/a-w.x)*((double)c/a-w.x);\n\t\t\tdouble y1,y2;\n\t\t\ty1=sqrt(yy);y2=-y1;\n\t\t\ty1+=w.y;y2+=w.y;\n\t\t\treturn (miny<y1+EPS && y1<maxy+EPS) || (miny<y2+EPS && y2<maxy+EPS);\n\t\t} else {\n\t\t\tdouble cb=(double)c/b;\n\t\t\tdouble ab=(double)a/b;\n\t\t\tdouble x2k,xk,tk;\n\t\t\tdouble x1,x2;\n\t\t\tx2k=1.0+ab*ab;\n\t\t\txk=-2*w.x+2.0*(w.y-cb)*ab;\n\t\t\ttk=w.x*w.x+(w.y-cb)*(w.y-cb)-w.r*w.r;\n\t\t\tx1=(-xk+sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k);\n\t\t\tx2=(-xk-sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k);\n\t\t\treturn (minx<x1+EPS && x1<maxx+EPS) || (minx<x2+EPS && x2<maxx+EPS);\n\t\t}\n\t}\n\treturn 0;\n}\nint main(void) {\n\tint n;\n\twall_t w[100];\n\tint m;\n\tint i;\n\twhile(scanf(\"%d\",&n)==1 && n>0) {\n\t\tfor(i=0;i<n;i++)scanf(\"%d%d%d\",&w[i].x,&w[i].y,&w[i].r);\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<m;i++) {\n\t\t\tquery_t q;\n\t\t\tint j;\n\t\t\tint hidden;\n\t\t\tscanf(\"%d%d%d%d\",&q.tx,&q.ty,&q.sx,&q.sy);\n\t\t\thidden=0;\n\t\t\tif(q.tx!=q.sx || q.ty!=q.sy) {\n\t\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\t\tif(hitcheck_circle(w[j],q)) {\n\t\t\t\t\t\thidden=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tputs(hidden?\"Safe\":\"Danger\");\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point center;\n    double radius;\n} Circle;\n\nint isInsideCircle(Point p, Circle c) {\n    double dx = p.x - c.center.x;\n    double dy = p.y - c.center.y;\n    return (dx * dx + dy * dy) < (c.radius * c.radius);\n}\n\nint lineSegmentIntersectsCircle(Point p1, Point p2, Circle c) {\n    // Check if either endpoint is inside the circle\n    if (isInsideCircle(p1, c) || isInsideCircle(p2, c)) {\n        return 1;\n    }\n    \n    // Vector from p1 to p2\n    double dx = p2.x - p1.x;\n    double dy = p2.y - p1.y;\n    \n    // Vector from p1 to circle center\n    double fx = c.center.x - p1.x;\n    double fy = c.center.y - p1.y;\n    \n    // Project circle center onto line segment\n    double len_sq = dx * dx + dy * dy;\n    double t = (fx * dx + fy * dy) / len_sq;\n    \n    // Clamp t to [0, 1] to stay on segment\n    if (t < 0) t = 0;\n    if (t > 1) t = 1;\n    \n    // Find closest point on segment\n    double closest_x = p1.x + t * dx;\n    double closest_y = p1.y + t * dy;\n    \n    // Check distance from closest point to circle center\n    double dist_x = c.center.x - closest_x;\n    double dist_y = c.center.y - closest_y;\n    double dist_sq = dist_x * dist_x + dist_y * dist_y;\n    \n    return dist_sq < (c.radius * c.radius);\n}\n\nint isBlocked(Point taro, Point oni, Circle walls[], int n) {\n    // Check if Taro and Oni are both inside the same circle\n    for (int i = 0; i < n; i++) {\n        if (isInsideCircle(taro, walls[i]) && isInsideCircle(oni, walls[i])) {\n            // Both inside same wall, check if blocked by another wall\n            int blocked = 0;\n            for (int j = 0; j < n; j++) {\n                if (i != j && lineSegmentIntersectsCircle(taro, oni, walls[j])) {\n                    blocked = 1;\n                    break;\n                }\n            }\n            if (!blocked) {\n                return 0; // They can see each other\n            }\n        }\n    }\n    \n    // Check if line segment intersects any wall\n    for (int i = 0; i < n; i++) {\n        int taroInside = isInsideCircle(taro, walls[i]);\n        int oniInside = isInsideCircle(oni, walls[i]);\n        \n        // If one is inside and one is outside, blocked\n        if (taroInside != oniInside) {\n            return 1;\n        }\n        \n        // If both outside, check if line intersects wall\n        if (!taroInside && !oniInside) {\n            if (lineSegmentIntersectsCircle(taro, oni, walls[i])) {\n                return 1;\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Circle walls[100];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf %lf\", &walls[i].center.x, &walls[i].center.y, &walls[i].radius);\n        }\n        \n        int m;\n        scanf(\"%d\", &m);\n        \n        for (int i = 0; i < m; i++) {\n            Point taro, oni;\n            scanf(\"%lf %lf %lf %lf\", &taro.x, &taro.y, &oni.x, &oni.y);\n            \n            if (isBlocked(taro, oni, walls, n)) {\n                printf(\"Safe\\n\");\n            } else {\n                printf(\"Danger\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include   Point; typedef struct { Point center; double radius; } Circle; int isInsideCircle(Point p, Circle c) { double dx = p.x - c.center.x; double dy = p.y - c.center.y; return (dx *  < (c.radius * c.radius); } int lineSegmentIntersectsCircle(Point p1, Point p2, Circle c) { // Check if either endpoint is inside the circle if (isInsideCircle(p1, c) ||  } // Vector from p1 to p2 double dx = p2.x - p1.x; double dy = p2.y - p1.y; // Vector from p1 to circle center double fx = c.center.x - p1.x; double fy = c.center.y - p1.y; // Project circle center onto line segment  dx + dy * dy; double t = (fx  dy) /  [0, 1] to stay on segment if (t < 0) t = 0; if (t > 1) t =  on  +  = p1.y +  distance from closest  dist_x =  = c.center.y - closest_y; double dist_sq =  *  * c.radius); } int isBlocked(Point taro, Point  { // Check if Taro and Oni are both inside the same circle for (int i  walls[i]) && isInsideCircle(oni, walls[i])) { // Both inside same wall, check if blocked by another wall int blocked = 0; for (int j = 0; j < n;  j && lineSegmentIntersectsCircle(taro, oni,  break;  return 0; // They can see  // Check if  for (int i = 0; i < n; i++) { int taroInside = isInsideCircle(taro, walls[i]); int oniInside = isInsideCircle(oni, walls[i]); // If one is  } // If both outside, check if line intersects wall if (!taroInside && !oniInside) { if (lineSegmentIntersectsCircle(taro, oni, walls[i])) { return 1; } } } return 0; } int main() { int n; while (scanf(\"%d\", &n) == 1 && n != 0) { Circle  0; i < n; i++) { scanf(\"%lf %lf %lf\", &walls[i].center.x, &walls[i].center.y, &walls[i].radius);  for (int i = 0; i < m; i++) { Point taro, oni; scanf(\"%lf %lf %lf %lf\", &taro.x, &taro.y, &oni.x, &oni.y); if (isBlocked(taro, oni, walls, n)) { printf(\"Safe\\n\"); } else { printf(\"Danger\\n\"); } } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> #define EPS (1e-7) typedef struct { int x,y,r; } wall_t; typedef struct { int tx,ty,sx,sy; } query_t; int hitcheck_circle(wall_t w,query_t q) { int in=0; int a,b,c; int minx,miny,maxx,maxy,temp; /* sieve */ minx=q.tx;maxx=q.sx; if(minx>maxx){temp=minx;minx=maxx;maxx=temp;} miny=q.ty;maxy=q.sy; if(miny>maxy){temp=miny;miny=maxy;maxy=temp;} if(w.x+w.r<minx  maxy<w.y-w.r)return 0; /* check if dist<=r */ if((q.tx-w.x)*(q.tx-w.x)+(q.ty-w.y)*(q.ty-w.y)<=w.r*w.r)in++; if((q.sx-w.x)*(q.sx-w.x)+(q.sy-w.y)*(q.sy-w.y)<=w.r*w.r)in++; if(in==1)return 1; if(in==2)return 0;  /* check if really hit */ c=-c; /* convert a*x+b*y+c=0 to a*x+b*y=c */ if(b==0) { double yy=w.r*w.r-((double)c/a-w.x)*((double)c/a-w.x); double y1,y2;   } else { double cb=(double)c/b; double ab=(double)a/b; double x2k,xk,tk; double x1,x2;  return (minx<x1+EPS && x1<maxx+EPS) || (minx<x2+EPS &&  } int main(void) { int n; wall_t w[100]; int m; int i; while(scanf(\"%d\",&n)==1 && n>0) {  hidden; scanf(\"%d%d%d%d\",&q.tx,&q.ty,&q.sx,&q.sy); hidden=0; if(q.tx!=q.sx || q.ty!=q.sy) {  break; } } }  }"], "original_ll": -0.8675102591514587, "sampled_ll": -0.4703758955001831, "all_perturbed_sampled_ll": [-1.4090149402618408], "all_perturbed_original_ll": [-1.5178061723709106], "perturbed_sampled_ll": -1.4090149402618408, "perturbed_original_ll": -1.5178061723709106, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> Ans = new ArrayList<Integer>();\n\t\tString line;\n\n\t\twhile((line = in.readLine()) != null){\n\t\t\tint nTube = Integer.parseInt(line);\n\n\t\t\tif(nTube==0) break;\n\n\t\t\tTube[] tubes = new Tube[nTube];\n\t\t\tfor(int n=0; n<nTube; n++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tint x = Integer.parseInt(dst[0]);\n\t\t\t\tint y = Integer.parseInt(dst[1]);\n\t\t\t\tint r = Integer.parseInt(dst[2]);\n\t\t\t\ttubes[n] = new Tube(x, y, r);\n\t\t\t}\n\n\t\t\tline = in.readLine();\n\t\t\tint nSet = Integer.parseInt(line);\n\t\t\tfor(int n=0; n<nSet; n++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tdouble x1 = Double.parseDouble(dst[0]);\n\t\t\t\tdouble y1 = Double.parseDouble(dst[1]);\n\t\t\t\tdouble x2 = Double.parseDouble(dst[2]);\n\t\t\t\tdouble y2 = Double.parseDouble(dst[3]);\n\n\t\t\t\tint hide = 0;\n\t\t\t\tfor(int m=0; m<tubes.length; m++){\n\t\t\t\t\tdouble a, b, c, d, e1, e2, x0, min, max;\n\t\t\t\t\tif(x1 != x2){\n\t\t\t\t\t\tdouble p = (y1 - y2) / (x1 - x2);\n\t\t\t\t\t\tdouble q = y1 - p * x1;\n\t\t\t\t\t\ta = p * p + 1.0;\n\t\t\t\t\t\tb = 2.0 * p * (q - tubes[m].y) - 2.0 * tubes[m].x;\n\t\t\t\t\t\tc = Math.pow(tubes[m].x, 2.0) + Math.pow(q - tubes[m].y, 2.0) - Math.pow(tubes[m].r, 2.0);\n\t\t\t\t\t\td = b * b - 4.0 * a * c;\n\t\t\t\t\t\te1 = a * x1 * x1 + b * x1 + c;\n\t\t\t\t\t\te2 = a * x2 * x2 + b * x2 + c;\n\t\t\t\t\t\tx0 = - b / (2.0 * a);\n\t\t\t\t\t\tmin = Math.min(x1, x2);\n\t\t\t\t\t\tmax = Math.max(x1, x2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta = 1.0;\n\t\t\t\t\t\tb = -2.0 * tubes[m].y;\n\t\t\t\t\t\tc = Math.pow(tubes[m].y, 2.0) + Math.pow(x1 - tubes[m].x, 2.0) - Math.pow(tubes[m].r, 2.0);\n\t\t\t\t\t\td = b * b - 4.0 * a * c;\n\t\t\t\t\t\te1 = a * y1 * y1 + b * y1 + c;\n\t\t\t\t\t\te2 = a * y2 * y2 + b * y2 + c;\n\t\t\t\t\t\tx0 = - b / (2.0 * a);\n\t\t\t\t\t\tmin = Math.min(y1, y2);\n\t\t\t\t\t\tmax = Math.max(y1, y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(x0 >= min && x0 <= max){\n\t\t\t\t\t\tif(d*e1 >= 0 || d*e2 >= 0){\n\t\t\t\t\t\t\tAns.add(1);\n\t\t\t\t\t\t\thide = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(e1 * e2 <= 0){\n\t\t\t\t\t\t\tAns.add(1);\n\t\t\t\t\t\t\thide = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(hide == 0){\n\t\t\t\t\tAns.add(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tint i = Ans.get(n);\n\t\t\tif(i==1){\n\t\t\t\tSystem.out.println(\"Safe\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"Danger\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Tube{\n\tdouble x;\n\tdouble y;\n\tdouble r;\n\n\tpublic Tube(int x, int y, int r){\n\t\tthis.x = (double)x;\n\t\tthis.y = (double)y;\n\t\tthis.r = (double)r;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Circle {\n        double x, y, r;\n        Circle(double x, double y, double r) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            Circle[] walls = new Circle[n];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                double wx = Double.parseDouble(parts[0]);\n                double wy = Double.parseDouble(parts[1]);\n                double r = Double.parseDouble(parts[2]);\n                walls[i] = new Circle(wx, wy, r);\n            }\n            \n            int m = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < m; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                double tx = Double.parseDouble(parts[0]);\n                double ty = Double.parseDouble(parts[1]);\n                double sx = Double.parseDouble(parts[2]);\n                double sy = Double.parseDouble(parts[3]);\n                \n                boolean visible = isVisible(tx, ty, sx, sy, walls);\n                System.out.println(visible ? \"Danger\" : \"Safe\");\n            }\n        }\n    }\n    \n    static boolean isVisible(double tx, double ty, double sx, double sy, Circle[] walls) {\n        // Check if both points are inside the same wall\n        for (Circle wall : walls) {\n            boolean tInside = isInside(tx, ty, wall);\n            boolean sInside = isInside(sx, sy, wall);\n            \n            if (tInside && sInside) {\n                // Both inside same wall - check if line segment intersects any other wall\n                boolean blocked = false;\n                for (Circle other : walls) {\n                    if (other == wall) continue;\n                    if (lineIntersectsCircle(tx, ty, sx, sy, other)) {\n                        blocked = true;\n                        break;\n                    }\n                }\n                if (!blocked) return true;\n            } else if (tInside || sInside) {\n                // One inside, one outside - not visible\n                return false;\n            }\n        }\n        \n        // Both outside all walls - check if line segment intersects any wall\n        for (Circle wall : walls) {\n            if (lineIntersectsCircle(tx, ty, sx, sy, wall)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    static boolean isInside(double px, double py, Circle circle) {\n        double dx = px - circle.x;\n        double dy = py - circle.y;\n        return dx * dx + dy * dy < circle.r * circle.r;\n    }\n    \n    static boolean lineIntersectsCircle(double x1, double y1, double x2, double y2, Circle circle) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double fx = x1 - circle.x;\n        double fy = y1 - circle.y;\n        \n        double a = dx * dx + dy * dy;\n        double b = 2 * (fx * dx + fy * dy);\n        double c = fx * fx + fy * fy - circle.r * circle.r;\n        \n        double discriminant = b * b - 4 * a * c;\n        \n        if (discriminant < 0) {\n            return false;\n        }\n        \n        double sqrtDisc = Math.sqrt(discriminant);\n        double t1 = (-b - sqrtDisc) / (2 * a);\n        double t2 = (-b + sqrtDisc) / (2 * a);\n        \n        // Check if intersection points are within the line segment\n        if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {\n            return true;\n        }\n        \n        // Check if the segment is completely inside the circle\n        if (t1 < 0 && t2 > 1) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import  double x, y, r; Circle(double x, double y, double r) { this.x = x; this.y = y; this.r = r; } }  throws IOException  BufferedReader(new InputStreamReader(System.in));  int n = Integer.parseInt(line.trim()); if (n == 0) break; Circle[] walls = new Circle[n]; for (int  n; i++) { String[] parts = br.readLine().trim().split(\"\\\\s+\"); double wx = Double.parseDouble(parts[0]); double wy =  walls[i] = new Circle(wx, wy, r); } int m   i++)   ty = Double.parseDouble(parts[1]); double sx = Double.parseDouble(parts[2]); double sy = Double.parseDouble(parts[3]); boolean visible = isVisible(tx, ty, sx, sy, walls); System.out.println(visible ? \"Danger\" : \"Safe\"); } } } static boolean isVisible(double  double sy, Circle[] walls) { // Check if both points are inside the  : walls) { boolean tInside = isInside(tx, ty, wall); boolean sInside = isInside(sx, sy, wall); if (tInside && sInside) { // Both inside same wall - check if line segment intersects any other wall boolean blocked = false; for (Circle other : walls) { if (other == wall)  sy, other)) { blocked = true; break; } } if (!blocked) return true; } else if (tInside || sInside) { // One inside, one outside - not visible return false; } } // Both outside all walls -  any wall for (Circle wall : walls) { if (lineIntersectsCircle(tx, ty, sx, sy,   boolean isInside(double px, double py, Circle circle) { double dx = px - circle.x; double dy = py - circle.y;  dy * dy < circle.r * circle.r; } static boolean   x2 - x1; double dy = y2 - y1; double fx = x1 - circle.x; double fy = y1 - circle.y; double  * (fx * dx + fy * dy); double c = fx * fx + fy * fy - circle.r  b * b - 4 * a * c; if (discriminant < 0) { return false; } double sqrtDisc  (-b - sqrtDisc) / (2 * a); double t2 = (-b + sqrtDisc) / (2 * a); // Check if intersection points are within the line segment if ((t1 >=  || (t2 >= 0 && t2 <= 1))  Check if the segment is completely inside the circle if (t1 < 0 && t2 > 1)  false; } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static void main(String args[]){ try{ new Main(); }catch(IOException e){  throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); List<Integer> Ans = new ArrayList<Integer>(); String line;  = new Tube[nTube]; for(int n=0; n<nTube; n++){ line = in.readLine(); String[] dst = line.split(\" \"); int x =  int r = Integer.parseInt(dst[2]); tubes[n] = new Tube(x, y, r); } line = in.readLine(); int nSet = Integer.parseInt(line); for(int n=0; n<nSet; n++){ line = in.readLine(); String[] dst = line.split(\"  double y1 = Double.parseDouble(dst[1]); double x2 = Double.parseDouble(dst[2]); double y2 = Double.parseDouble(dst[3]); int hide = 0; for(int m=0; m<tubes.length; m++){ double a,  x0, min, max;  = (y1 -  double q = y1  = p * p + 1.0; b = 2.0 * p * (q - tubes[m].y) - 2.0  2.0) + Math.pow(q - tubes[m].y, 2.0) - Math.pow(tubes[m].r, 2.0); d = b * b - 4.0 * a * c; e1 = a * x1 * x1 + b * x1 + c; e2 = a * x2 *  + c; x0 = - b / (2.0 *  max = Math.max(x1, x2); } else{ a = 1.0; b = -2.0 *  +  Math.pow(tubes[m].r, 2.0); d = b * b - 4.0 * a * c; e1 = a * y1 * y1 + b * y1 + c; e2 = a * y2 * y2 + b * y2 + c; x0 = - b /  Math.min(y1, y2); max = Math.max(y1, y2); } if(x0 >= min && x0 <= max){ if(d*e1  else{ if(e1 * e2 <= 0){ Ans.add(1); hide = 1; break; }  Ans.add(-1); } } } for(int n=0; n<Ans.size(); n++){ int i = Ans.get(n); if(i==1){ System.out.println(\"Safe\"); }else{ System.out.println(\"Danger\"); } }  x;  (double)x; this.y = (double)y; this.r = (double)r; } }"], "original_ll": -0.5060805082321167, "sampled_ll": -0.38281363248825073, "all_perturbed_sampled_ll": [-1.5438545942306519], "all_perturbed_original_ll": [-1.3803987503051758], "perturbed_sampled_ll": -1.5438545942306519, "perturbed_original_ll": -1.3803987503051758, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math as M\ndef R(A): return (A[0]**2+A[1]**2)**.5\ndef I(i): return [map(int,raw_input().split()) for _ in [0]*i]\ndef C(a,b): return a>b or abs(a-b)<1e-6\ndef f(e1):\n  tx,ty,sx,sy=e1\n  x=[]\n  for e2 in WP:\n    wx,wy,r=e2\n    wt=[tx-wx,ty-wy]; rwt=R(wt)\n    sw=[wx-sx,wy-sy]; rsw=R(sw)\n    st=[tx-sx,ty-sy]; rst=R(st)\n    F=[rwt<r,rsw<r]\n    if rst==0: c=1\n    elif F==[1,1]: c=1\n    elif F==[1,0] or F==[0,1]: c=0\n    elif F==[0,0]:\n      c=0\n      a=M.pi/2-M.acos(r/rsw)\n      b=M.acos((sw[0]*st[0]+sw[1]*st[1])/rsw/rst)\n#      if C(a,b) and C(rst**2,rsw**2-r**2): c=0\n#      else: c=1\n    x.append(c)\n  return all(x)\n\nwhile 1:\n  n=input()\n  if n==0: break\n  WP=I(n)\n  P=I(input())\n  for e in P: print [\"Safe\",\"Danger\"][f(e)]", "sampled": "import math\n\ndef point_in_circle(px, py, cx, cy, r):\n    dist_sq = (px - cx) ** 2 + (py - cy) ** 2\n    return dist_sq < r ** 2\n\ndef line_segment_intersects_circle(x1, y1, x2, y2, cx, cy, r):\n    # Check if either endpoint is inside the circle\n    if point_in_circle(x1, y1, cx, cy, r) or point_in_circle(x2, y2, cx, cy, r):\n        return True\n    \n    # Vector from point 1 to point 2\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    # Vector from point 1 to circle center\n    fx = x1 - cx\n    fy = y1 - cy\n    \n    # Quadratic equation coefficients for line-circle intersection\n    a = dx * dx + dy * dy\n    b = 2 * (fx * dx + fy * dy)\n    c = fx * fx + fy * fy - r * r\n    \n    discriminant = b * b - 4 * a * c\n    \n    if discriminant < 0:\n        return False\n    \n    # Check if intersection points are within the line segment\n    sqrt_discriminant = math.sqrt(discriminant)\n    t1 = (-b - sqrt_discriminant) / (2 * a)\n    t2 = (-b + sqrt_discriminant) / (2 * a)\n    \n    # Check if any t is in [0, 1]\n    if (0 <= t1 <= 1) or (0 <= t2 <= 1):\n        return True\n    \n    return False\n\ndef is_visible(tx, ty, sx, sy, walls):\n    # Check if both Taro and Oni are inside the same wall\n    taro_walls = []\n    oni_walls = []\n    \n    for wx, wy, r in walls:\n        if point_in_circle(tx, ty, wx, wy, r):\n            taro_walls.append((wx, wy, r))\n        if point_in_circle(sx, sy, wx, wy, r):\n            oni_walls.append((wx, wy, r))\n    \n    # If they are both inside the same wall\n    for tw in taro_walls:\n        if tw in oni_walls:\n            # They are in the same wall, check if any other wall blocks\n            for wx, wy, r in walls:\n                if (wx, wy, r) != tw:\n                    if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r):\n                        return False\n            return True\n    \n    # If one is inside a wall and the other is not, they can't see each other\n    if len(taro_walls) > 0 or len(oni_walls) > 0:\n        return False\n    \n    # Both are outside all walls, check if any wall blocks the line of sight\n    for wx, wy, r in walls:\n        if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r):\n            return False\n    \n    return True\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    walls = []\n    for _ in range(n):\n        wx, wy, r = map(int, input().split())\n        walls.append((wx, wy, r))\n    \n    m = int(input())\n    for _ in range(m):\n        tx, ty, sx, sy = map(int, input().split())\n        if is_visible(tx, ty, sx, sy, walls):\n            print(\"Danger\")\n        else:\n            print(\"Safe\")\n", "perturbed_sampled": ["import math def point_in_circle(px, py, cx,  - cx) ** 2 + (py - cy) ** 2 return  def line_segment_intersects_circle(x1, y1, x2, y2, cx, cy, r): # Check if either endpoint is inside the circle if point_in_circle(x1, y1,  from point 1 to point 2 dx = x2 - x1 dy = y2 - y1 # Vector from point  = x1 -  cy # Quadratic equation coefficients for line-circle intersection a = dx * dx + dy * dy b  dx + fy * dy) c =  * fy -  b * b - 4 * a  0: return False # Check if intersection points  sqrt_discriminant = math.sqrt(discriminant) t1 = (-b  a) t2 = (-b +  t is in [0, 1] if (0 <= t1 <= 1) or (0 <= t2  sx, sy, walls): # Check if both Taro and Oni are inside the same wall taro_walls = [] oni_walls = [] for wx, wy, r in walls: if point_in_circle(tx, ty, wx, wy, r): taro_walls.append((wx, wy, r)) if point_in_circle(sx, sy, wx, wy, r): oni_walls.append((wx,  same wall for tw in taro_walls: if tw in oni_walls: #  wall, check if any other wall blocks for wx, wy, r in walls: if (wx,  line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r): return False return True # If one is inside a wall and the other is not, they can't  > 0 or len(oni_walls) > 0: return False # Both are  any wall blocks the line of sight for wx, wy, r in walls: if line_segment_intersects_circle(tx, ty, sx, sy, wx,  True while True: n = int(input()) if n == 0: break  in range(n): wx, wy, r = map(int, input().split()) walls.append((wx, wy, r)) m = int(input()) for _ in range(m): tx, ty, sx, sy = map(int, input().split()) if is_visible(tx, ty, sx, sy, walls): print(\"Danger\") else: print(\"Safe\")"], "perturbed_original": ["import math as M def R(A): return (A[0]**2+A[1]**2)**.5 def I(i): return [map(int,raw_input().split()) for _ in [0]*i] def C(a,b):  f(e1): tx,ty,sx,sy=e1 x=[] for e2 in WP: wx,wy,r=e2 wt=[tx-wx,ty-wy]; rwt=R(wt) sw=[wx-sx,wy-sy]; rsw=R(sw) st=[tx-sx,ty-sy]; rst=R(st)  F==[1,1]: c=1 elif F==[1,0]   C(a,b) and C(rst**2,rsw**2-r**2): c=0 # else: c=1 x.append(c) return all(x) while 1: n=input() if n==0: break WP=I(n) P=I(input()) for e in P: print [\"Safe\",\"Danger\"][f(e)]"], "original_ll": -1.4878954887390137, "sampled_ll": -0.5434557199478149, "all_perturbed_sampled_ll": [-1.629675030708313], "all_perturbed_original_ll": [-2.343173027038574], "perturbed_sampled_ll": -1.629675030708313, "perturbed_original_ll": -2.343173027038574, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\nint n,i,j,p;\nchar c,t,l[27];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tgetchar();\n\tfor(i=0;i<n;i++)\n\t{\n\t\tp=13;\n\t\tmemset(l,0,27);\n\t\tfor(;scanf(\"%c\",&l[p])!=-1;)\n\t\t{\n\t\t\t~scanf(\"%c\",&c);\n\t\t\tif(c=='-'||c=='<')\n\t\t\t\tgetchar(),c=='-'?p++:p--;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(j=0;!l[j];j++);\n\t\tputs(l+j);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    getchar();\n    \n    for (int i = 0; i < n; i++) {\n        char line[1025];\n        fgets(line, 1025, stdin);\n        \n        // Parse the movements\n        char cars[26];\n        int carCount = 0;\n        int carPos[26]; // Position of each car (a-z)\n        for (int j = 0; j < 26; j++) {\n            carPos[j] = -1;\n        }\n        \n        // Parse first car\n        char currentCar = line[0];\n        cars[carCount] = currentCar;\n        carPos[currentCar - 'a'] = carCount;\n        carCount++;\n        \n        int pos = 0;\n        int minPos = 0, maxPos = 0;\n        \n        // Parse movements\n        int idx = 1;\n        while (line[idx] != '\\0' && line[idx] != '\\n') {\n            // Read direction\n            char dir[3];\n            dir[0] = line[idx];\n            dir[1] = line[idx + 1];\n            dir[2] = '\\0';\n            idx += 2;\n            \n            // Read next car\n            char nextCar = line[idx];\n            idx++;\n            \n            int nextCarIdx = nextCar - 'a';\n            \n            if (strcmp(dir, \"->\") == 0) {\n                // Moving to next car (right)\n                if (carPos[nextCarIdx] == -1) {\n                    // New car on the right\n                    pos++;\n                    carPos[nextCarIdx] = pos;\n                    if (pos > maxPos) maxPos = pos;\n                } else {\n                    pos = carPos[nextCarIdx];\n                }\n            } else { // \"<-\"\n                // Moving to previous car (left)\n                if (carPos[nextCarIdx] == -1) {\n                    // New car on the left\n                    pos--;\n                    carPos[nextCarIdx] = pos;\n                    if (pos < minPos) minPos = pos;\n                } else {\n                    pos = carPos[nextCarIdx];\n                }\n            }\n        }\n        \n        // Build result string\n        int length = maxPos - minPos + 1;\n        char result[27];\n        for (int j = 0; j < length; j++) {\n            result[j] = ' ';\n        }\n        result[length] = '\\0';\n        \n        for (int j = 0; j < 26; j++) {\n            if (carPos[j] != -1) {\n                int actualPos = carPos[j] - minPos;\n                result[actualPos] = 'a' + j;\n            }\n        }\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int main() { int n; scanf(\"%d\", &n);  0; i < n; i++) { char line[1025]; fgets(line,  movements char cars[26]; int carCount = 0; int carPos[26]; // Position of each car (a-z) for (int j = 0; j < 26;  } // Parse first car char currentCar = line[0]; cars[carCount] =  carCount; carCount++; int pos = 0; int minPos = 0, maxPos = 0; // Parse movements int idx = 1; while (line[idx] != '\\0' && line[idx] != '\\n') { // Read direction  dir[1] = line[idx + 1]; dir[2] = '\\0'; idx += 2; // Read next car char nextCar  = nextCar - 'a'; if (strcmp(dir, \"->\") == 0) { // Moving to next car (right) if (carPos[nextCarIdx] == -1) { // New car on the right pos++; carPos[nextCarIdx] = pos;  = pos; }  } } else { // \"<-\" // Moving  (carPos[nextCarIdx] == -1) { // New car on the left pos--; carPos[nextCarIdx] = pos;  = pos;  int length = maxPos -  for (int j =  { result[j]  = '\\0'; for (int j = 0; j < 26; j++) { if (carPos[j] != -1) { int actualPos = carPos[j] -  j; } } printf(\"%s\\n\", result); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> int n,i,j,p; char c,t,l[27]; int main()  p=13; memset(l,0,27); for(;scanf(\"%c\",&l[p])!=-1;) { ~scanf(\"%c\",&c); if(c=='-'||c=='<') getchar(),c=='-'?p++:p--; else break; } for(j=0;!l[j];j++); puts(l+j); } return 0; }"], "original_ll": -1.5378084182739258, "sampled_ll": -0.5911639928817749, "all_perturbed_sampled_ll": [-1.630012035369873], "all_perturbed_original_ll": [-2.3322954177856445], "perturbed_sampled_ll": -1.630012035369873, "perturbed_original_ll": -2.3322954177856445, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "package jp.ac.saburou.volume1;\n\nimport java.util.Scanner;\n\nclass p130 {\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint[][] result = null;\n\t\tfor (int t = 0; t < n; t++) {\n\t\t\tchar[] train = s.next().toCharArray();\n\t\t\tif (train.length > 1) {\n\t\t\t\tresult = createTrainGraph(train);\n\t\t\t\t/* \u5148\u982d\u8eca\u4e21\u3092\u6c7a\u5b9a\u3059\u308b */\n\t\t\t\tint next = NO_CONNECTION;\n\t\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\t\tif (result[i][0] == NO_CONNECTION\n\t\t\t\t\t\t\t&& result[i][1] != NO_CONNECTION) {\n\t\t\t\t\t\tnext = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* \u51fa\u529b */\n\t\t\t\twhile (next != -1) {\n\t\t\t\t\tSystem.out.printf(\"%c\", next + 'a');\n\t\t\t\t\tnext = result[next][REAR];\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t} else {\n\t\t\t\tSystem.out.println(train[0]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic final int FRONT = 0;\n\tstatic final int REAR = 1;\n\tstatic final int NO_CONNECTION = -1;\n\n\tstatic int[][] createTrainGraph(char[] input) {\n\t\tint[][] train = new int[26][2];\n\t\tfor (int i = 0; i < train.length; i++) {\n\t\t\tfor (int j = 0; j < train[0].length; j++) {\n\t\t\t\ttrain[i][j] = NO_CONNECTION;\n\t\t\t}\n\t\t}\n\t\tboolean front = false;\n\t\tint before = input[0];\n\t\tfor (int i = 1; i < input.length; i++) {\n\t\t\tint current = input[i];\n\t\t\tif ('a' <= current && current <= 'z') {\n\t\t\t\tif (front) {\n\t\t\t\t\ttrain[before - 'a'][FRONT] = current - 'a';\n\t\t\t\t\ttrain[current - 'a'][REAR] = before - 'a';\n\t\t\t\t} else {\n\t\t\t\t\ttrain[before - 'a'][REAR] = current - 'a';\n\t\t\t\t\ttrain[current - 'a'][FRONT] = before - 'a';\n\t\t\t\t}\n\t\t\t\tbefore = current;\n\t\t\t} else if (current == '>') {\n\t\t\t\tfront = false;\n\t\t\t} else if (current == '<') {\n\t\t\t\tfront = true;\n\t\t\t}\n\t\t}\n\t\treturn train;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            System.out.println(solve(line));\n        }\n        sc.close();\n    }\n    \n    static String solve(String record) {\n        String[] tokens = record.split(\"(<-|->)\");\n        String[] directions = record.split(\"[a-z]\");\n        \n        Map<Character, Set<Character>> next = new HashMap<>();\n        Map<Character, Set<Character>> prev = new HashMap<>();\n        Set<Character> cars = new HashSet<>();\n        \n        for (String token : tokens) {\n            if (!token.isEmpty()) {\n                char c = token.charAt(0);\n                cars.add(c);\n                next.putIfAbsent(c, new HashSet<>());\n                prev.putIfAbsent(c, new HashSet<>());\n            }\n        }\n        \n        for (int i = 0; i < tokens.length - 1; i++) {\n            char from = tokens[i].charAt(0);\n            char to = tokens[i + 1].charAt(0);\n            String dir = directions[i + 1];\n            \n            if (dir.equals(\"->\")) {\n                next.get(from).add(to);\n                prev.get(to).add(from);\n            } else {\n                prev.get(from).add(to);\n                next.get(to).add(from);\n            }\n        }\n        \n        // Build the train\n        List<Character> train = new ArrayList<>();\n        \n        // Find a starting car (one with no prev or just one end)\n        char start = ' ';\n        for (char c : cars) {\n            Set<Character> p = prev.get(c);\n            Set<Character> n = next.get(c);\n            \n            // Remove inconsistencies\n            p.removeAll(n);\n            n.removeAll(p);\n            \n            if (p.isEmpty()) {\n                start = c;\n                break;\n            }\n        }\n        \n        if (start == ' ') {\n            start = cars.iterator().next();\n        }\n        \n        // Build forward\n        Set<Character> visited = new HashSet<>();\n        char current = start;\n        train.add(current);\n        visited.add(current);\n        \n        while (true) {\n            Set<Character> nextCars = next.get(current);\n            nextCars.removeAll(prev.get(current));\n            \n            char nextCar = ' ';\n            for (char c : nextCars) {\n                if (!visited.contains(c)) {\n                    nextCar = c;\n                    break;\n                }\n            }\n            \n            if (nextCar == ' ') break;\n            \n            train.add(nextCar);\n            visited.add(nextCar);\n            current = nextCar;\n        }\n        \n        // Build backward from start\n        current = start;\n        while (true) {\n            Set<Character> prevCars = prev.get(current);\n            prevCars.removeAll(next.get(current));\n            \n            char prevCar = ' ';\n            for (char c : prevCars) {\n                if (!visited.contains(c)) {\n                    prevCar = c;\n                    break;\n                }\n            }\n            \n            if (prevCar == ' ') break;\n            \n            train.add(0, prevCar);\n            visited.add(prevCar);\n            current = prevCar;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : train) {\n            result.append(c);\n        }\n        \n        return result.toString();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) {  int n = sc.nextInt(); sc.nextLine(); for (int i = 0; i < n; i++) { String line = sc.nextLine(); System.out.println(solve(line)); } sc.close(); } static String solve(String record) { String[] tokens = record.split(\"(<-|->)\"); String[] directions = record.split(\"[a-z]\"); Map<Character, Set<Character>> next = new HashMap<>(); Map<Character, Set<Character>> prev =  new HashSet<>(); for (String token : tokens) { if (!token.isEmpty()) { char c = token.charAt(0); cars.add(c);   i++) { char from = tokens[i].charAt(0); char to = tokens[i + 1].charAt(0); String dir = directions[i + 1]; if (dir.equals(\"->\")) { next.get(from).add(to); prev.get(to).add(from); } else  // Build the train List<Character> train = new ArrayList<>(); //  with no prev or just one end) char start = ' '; for (char c : cars) {  n = next.get(c); // Remove inconsistencies p.removeAll(n);  = c; break; } } if (start == ' ') { start = cars.iterator().next(); }  = new HashSet<>(); char current = start; train.add(current);  char nextCar  c : nextCars) { if (!visited.contains(c)) { nextCar = c;  == ' ') break; train.add(nextCar); visited.add(nextCar); current = nextCar; } // Build backward from start current = start; while (true) {  '; for (char c : prevCars) { if (!visited.contains(c)) { prevCar = c; break; } } if (prevCar ==  visited.add(prevCar); current  = new StringBuilder(); for (char c : train) { result.append(c); } return result.toString(); } }"], "perturbed_original": ["package jp.ac.saburou.volume1; import java.util.Scanner; class p130 { public static void main(String[] args) { Scanner s = new Scanner(System.in); int n = s.nextInt(); int[][] result = null; for (int t = 0; t < n; t++) { char[] train = s.next().toCharArray(); if  =  next = NO_CONNECTION; for (int i = 0; i < result.length; i++)  } } /*  -1) { System.out.printf(\"%c\", next + 'a'); next = result[next][REAR]; } System.out.println(); } else { System.out.println(train[0]); } } } static final int  int REAR =  = -1; static int[][] createTrainGraph(char[] input) { int[][] train = new int[26][2]; for (int  train.length; i++) { for (int j = 0; j < train[0].length; j++) { train[i][j] = NO_CONNECTION; } } boolean front = false; int before = input[0]; for (int i = 1; i < input.length; i++) { int current = input[i]; if ('a' <= current && current <=  train[before - 'a'][FRONT]  - 'a'][REAR] = before - 'a'; } else {  'a'][FRONT] = before - 'a'; } before = current; } else if (current == '>') { front  (current == '<') { front = true;  }"], "original_ll": -0.7178160548210144, "sampled_ll": -0.5110052227973938, "all_perturbed_sampled_ll": [-1.7421023845672607], "all_perturbed_original_ll": [-1.8285709619522095], "perturbed_sampled_ll": -1.7421023845672607, "perturbed_original_ll": -1.8285709619522095, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# AOJ 0130 Train\n# Python3 2018.6.19 bal4u\n\nfor _ in range(int(input())):\n\ts = list(input())\n\tans = []\n\tdir = '>'\n\tfor i in range(len(s)):\n\t\tif s[i].isalpha():\n\t\t\tif dir == '>':\n\t\t\t\tif s[i] not in ans: ans.append(s[i])\n\t\t\telse:\n\t\t\t\tif s[i] not in ans: ans.insert(0, s[i])\n\t\telif s[i] == '>' or s[i] == '<': dir = s[i]\n\tprint(*ans, sep='')\n", "sampled": "def solve(s):\n    # Parse the movements\n    tokens = s.replace('<-', ' <- ').replace('->', ' -> ').split()\n    \n    # Build adjacency relationships\n    cars = set()\n    neighbors = {}\n    \n    current = tokens[0]\n    cars.add(current)\n    \n    i = 1\n    while i < len(tokens):\n        direction = tokens[i]\n        next_car = tokens[i + 1]\n        cars.add(next_car)\n        \n        if current not in neighbors:\n            neighbors[current] = set()\n        if next_car not in neighbors:\n            neighbors[next_car] = set()\n        \n        neighbors[current].add(next_car)\n        neighbors[next_car].add(current)\n        \n        current = next_car\n        i += 2\n    \n    # Find the train composition (it forms a path)\n    # Find cars with degree 1 (endpoints)\n    endpoints = []\n    for car in cars:\n        if car not in neighbors or len(neighbors[car]) == 1:\n            endpoints.append(car)\n    \n    # If no endpoints found (circular), pick any car\n    if not endpoints:\n        endpoints = [list(cars)[0]]\n    \n    # Build the path from one endpoint\n    start = endpoints[0]\n    path = [start]\n    visited = {start}\n    current = start\n    \n    while True:\n        if current not in neighbors:\n            break\n        next_found = False\n        for next_car in neighbors[current]:\n            if next_car not in visited:\n                path.append(next_car)\n                visited.add(next_car)\n                current = next_car\n                next_found = True\n                break\n        if not next_found:\n            break\n    \n    return ''.join(path)\n\nn = int(input())\nfor _ in range(n):\n    s = input().strip()\n    print(solve(s))\n", "perturbed_sampled": ["def solve(s): # Parse the movements tokens = s.replace('<-', ' <- ').replace('->', ' -> ').split() # Build adjacency relationships cars = set() neighbors = {} current = tokens[0] cars.add(current) i = 1 while i < len(tokens): direction = tokens[i] next_car = tokens[i + 1] cars.add(next_car) if current not in neighbors: neighbors[current] = set() if next_car not in neighbors: neighbors[next_car]  = next_car i += 2 # Find the train composition (it  cars with degree 1 (endpoints) endpoints = [] for car in cars: if car not in neighbors or len(neighbors[car]) == 1: endpoints.append(car) # If no endpoints found (circular), pick  endpoints = [list(cars)[0]] # Build the  [start] visited  while  False for next_car in neighbors[current]: if next_car not in visited: path.append(next_car) visited.add(next_car) current   return ''.join(path) n = int(input()) for _ in range(n): s = input().strip() print(solve(s))"], "perturbed_original": ["# AOJ 0130 Train # Python3 2018.6.19 bal4u for _ in range(int(input())): s = list(input()) ans = [] dir = '>' for i  dir ==  ans: ans.append(s[i]) else: if s[i] not in ans: ans.insert(0, s[i]) elif s[i] ==  dir = s[i] print(*ans, sep='')"], "original_ll": -1.544116735458374, "sampled_ll": -0.8853259682655334, "all_perturbed_sampled_ll": [-2.0099070072174072], "all_perturbed_original_ll": [-2.9177229404449463], "perturbed_sampled_ll": -2.0099070072174072, "perturbed_original_ll": -2.9177229404449463, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint i,j,n,s[12][12],a[12][12];\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tfor(i=0;i<10;i++)for(j=0;j<10;j++)scanf(\"%d\",&s[i][j]);\n\t\tmemset(a,0,sizeof(a));\n\t\tfor(i=0;i<9;i++){\n\t\t\tfor(j=0;j<10;j++){\n\t\t\t\tif(s[i][j]%2==1){\n\t\t\t\t\ta[i+1][j]=1;\n\t\t\t\t\ts[i][j]++;\n\t\t\t\t\ts[i+1][j]++;\n\t\t\t\t\ts[i+1][j-1]++;\n\t\t\t\t\ts[i+1][j+1]++;\n\t\t\t\t\ts[i+2][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<10;i++){for(j=0;j<10;j++)printf(\"%d \",a[i][j]);printf(\"\\n\");}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int grid[10][10];\n        int solution[10][10] = {0};\n        \n        // Read input\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        \n        // Solve using Gaussian elimination in GF(2)\n        // Each cell (i,j) being hit affects itself and neighbors\n        // We need to solve: A*x = b where A is the effect matrix\n        \n        // Create augmented matrix\n        int matrix[100][101];\n        for (int i = 0; i < 100; i++) {\n            for (int j = 0; j <= 100; j++) {\n                matrix[i][j] = 0;\n            }\n        }\n        \n        // Build the system of equations\n        for (int row = 0; row < 10; row++) {\n            for (int col = 0; col < 10; col++) {\n                int eq = row * 10 + col;\n                matrix[eq][100] = grid[row][col];\n                \n                // Check which positions affect this cell\n                for (int r = 0; r < 10; r++) {\n                    for (int c = 0; c < 10; c++) {\n                        int var = r * 10 + c;\n                        // Position (r,c) affects (row,col) if:\n                        // - (r,c) == (row,col) or\n                        // - (r,c) is adjacent to (row,col)\n                        if ((r == row && c == col) ||\n                            (r == row && (c == col-1 || c == col+1)) ||\n                            (c == col && (r == row-1 || r == row+1))) {\n                            matrix[eq][var] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Gaussian elimination in GF(2)\n        for (int col = 0; col < 100; col++) {\n            // Find pivot\n            int pivot = -1;\n            for (int row = col; row < 100; row++) {\n                if (matrix[row][col] == 1) {\n                    pivot = row;\n                    break;\n                }\n            }\n            \n            if (pivot == -1) continue;\n            \n            // Swap rows\n            if (pivot != col) {\n                for (int j = 0; j <= 100; j++) {\n                    int temp = matrix[col][j];\n                    matrix[col][j] = matrix[pivot][j];\n                    matrix[pivot][j] = temp;\n                }\n            }\n            \n            // Eliminate\n            for (int row = 0; row < 100; row++) {\n                if (row != col && matrix[row][col] == 1) {\n                    for (int j = 0; j <= 100; j++) {\n                        matrix[row][j] ^= matrix[col][j];\n                    }\n                }\n            }\n        }\n        \n        // Back substitution to get solution\n        int result[100] = {0};\n        for (int i = 0; i < 100; i++) {\n            result[i] = matrix[i][100];\n        }\n        \n        // Convert to 2D and output\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                if (j > 0) printf(\" \");\n                printf(\"%d\", result[i * 10 + j]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n); while (n--)  = {0}; // Read input for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { scanf(\"%d\", &grid[i][j]); } } // Solve using Gaussian elimination in GF(2) // Each cell (i,j) being hit affects itself and neighbors // We need to solve: A*x  the effect matrix // Create augmented matrix int matrix[100][101]; for (int i = 0; i < 100; i++) { for (int j = 0; j <= 100; j++) { matrix[i][j]  10; row++) { for (int col = 0; col < 10; col++) { int eq = row * 10 + col; matrix[eq][100] = grid[row][col]; // Check which positions affect this cell for (int r  r++) { for (int  10; c++) { int var = r * 10 + c; // Position (r,c) affects (row,col) if: // - (r,c) == (row,col) or // - (r,c) is adjacent to (row,col) if ((r == row && c == col) || (r == row && (c == col-1 || c == col+1))  (r == row-1 || r == row+1))) { matrix[eq][var] = 1; } } } } } // Gaussian elimination in  0; col < 100; col++) { // Find pivot int  row = col; row < 100; row++) { if (matrix[row][col] == 1)     0; j <= 100; j++) { int temp = matrix[col][j]; matrix[col][j] = matrix[pivot][j]; matrix[pivot][j] = temp; } } // Eliminate for (int row = 0; row < 100; row++) { if (row != col   j <= 100; j++) { matrix[row][j] ^= matrix[col][j];  Back substitution to get  for (int i = 0; i  = matrix[i][100]; }  output for (int i = 0; i < 10;  = 0; j < 10; j++) {  \"); printf(\"%d\", result[i * 10  } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> int main(){ int i,j,n,s[12][12],a[12][12]; scanf(\"%d\",&n); while(n--){ for(i=0;i<10;i++)for(j=0;j<10;j++)scanf(\"%d\",&s[i][j]); memset(a,0,sizeof(a)); for(i=0;i<9;i++){ for(j=0;j<10;j++){ if(s[i][j]%2==1){ a[i+1][j]=1; s[i][j]++; s[i+1][j]++; s[i+1][j-1]++; s[i+1][j+1]++; s[i+2][j]++; } } }  }"], "original_ll": -0.6766581535339355, "sampled_ll": -0.4786827564239502, "all_perturbed_sampled_ll": [-1.4302253723144531], "all_perturbed_original_ll": [-1.003857135772705], "perturbed_sampled_ll": -1.4302253723144531, "perturbed_original_ll": -1.003857135772705, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic byte ans[][];\n\n\tpublic static boolean f(int a[][], int s[], int n) {\n\t\tif (10 <= n) {\n\t\t\tint b[][] = new int[10][10];\n\t\t\tans = new byte[10][10];\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tb[i][j] = a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif (s[i] == 1) {\n\t\t\t\t\treverse(b, 0, i);\n\t\t\t\t\tans[0][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (b[i - 1][j] == 1) {\n\t\t\t\t\t\treverse(b, i, j);\n\t\t\t\t\t\tans[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (check(b)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\ts[n] = 0;\n\t\t\tif (f(a, s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ts[n] = 1;\n\t\t\tif (f(a, s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void reverse(int a[][], int i, int j) {\n\t\ta[i][j] = (a[i][j] + 1) % 2;\n\t\tif (0 <= i - 1) {\n\t\t\ta[i - 1][j] = (a[i - 1][j] + 1) % 2;\n\t\t}\n\t\tif (i + 1 < 10) {\n\t\t\ta[i + 1][j] = (a[i + 1][j] + 1) % 2;\n\t\t}\n\t\tif (0 <= j - 1) {\n\t\t\ta[i][j - 1] = (a[i][j - 1] + 1) % 2;\n\t\t}\n\t\tif (j + 1 < 10) {\n\t\t\ta[i][j + 1] = (a[i][j + 1] + 1) % 2;\n\t\t}\n\t}\n\n\tpublic static boolean check(int a[][]) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (a[i][j] == 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tint a[][];\n\n\t\tn = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta = new int[10][10];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\ta[j][k] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tf(a, new int[10], 0);\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tString s = \"\";\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\tSystem.out.print(s + ans[j][k]);\n\t\t\t\t\ts = \" \";\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int t = 0; t < n; t++) {\n            int[][] grid = new int[10][10];\n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    grid[i][j] = sc.nextInt();\n                }\n            }\n            \n            int[][] result = solve(grid);\n            \n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    if (j > 0) System.out.print(\" \");\n                    System.out.print(result[i][j]);\n                }\n                System.out.println();\n            }\n        }\n        sc.close();\n    }\n    \n    static int[][] solve(int[][] grid) {\n        // Use Gaussian elimination over GF(2)\n        // Each cell (i,j) can be toggled, affecting itself and neighbors\n        // We need to solve for which cells to toggle to turn all lights off\n        \n        int[][] solution = new int[10][10];\n        \n        // Create augmented matrix for the system\n        // 100 variables (one for each cell), 100 equations (one for each cell)\n        int size = 100;\n        int[][] matrix = new int[size][size + 1];\n        \n        // Build the system of equations\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                int row = i * 10 + j;\n                \n                // Check which toggles affect cell (i,j)\n                for (int ti = 0; ti < 10; ti++) {\n                    for (int tj = 0; tj < 10; tj++) {\n                        int col = ti * 10 + tj;\n                        \n                        // Cell (ti,tj) affects (i,j) if they are adjacent\n                        if ((ti == i && tj == j) ||\n                            (ti == i && Math.abs(tj - j) == 1) ||\n                            (tj == j && Math.abs(ti - i) == 1)) {\n                            matrix[row][col] = 1;\n                        }\n                    }\n                }\n                \n                // Right side: current state of cell (i,j)\n                matrix[row][size] = grid[i][j];\n            }\n        }\n        \n        // Gaussian elimination in GF(2)\n        for (int col = 0; col < size; col++) {\n            // Find pivot\n            int pivot = -1;\n            for (int row = col; row < size; row++) {\n                if (matrix[row][col] == 1) {\n                    pivot = row;\n                    break;\n                }\n            }\n            \n            if (pivot == -1) continue;\n            \n            // Swap rows\n            if (pivot != col) {\n                int[] temp = matrix[col];\n                matrix[col] = matrix[pivot];\n                matrix[pivot] = temp;\n            }\n            \n            // Eliminate\n            for (int row = 0; row < size; row++) {\n                if (row != col && matrix[row][col] == 1) {\n                    for (int c = 0; c <= size; c++) {\n                        matrix[row][c] ^= matrix[col][c];\n                    }\n                }\n            }\n        }\n        \n        // Back substitution\n        int[] vars = new int[size];\n        for (int i = 0; i < size; i++) {\n            vars[i] = matrix[i][size];\n        }\n        \n        // Convert to 2D array\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                solution[i][j] = vars[i * 10 + j];\n            }\n        }\n        \n        return solution;\n    }\n}\n", "perturbed_sampled": ["import ;<extra_id_1>n ==<extra_id_2>2 ; j > 0)<extra_id_3>=<extra_id_4>1); if (0, _<extra_id_5>_ = 1 ;<extra_id_6>int rows = 0<extra_id_7>= 0; rows:<extra_id_8>matrix[row][rows]; if ((row - j)<extra_id_9>(row != -1) data[row][rows]<extra_id_10>><extra_id_11>}<extra_id_12>) { data .<extra_id_13>=<extra_id_14>[ i ] ;<extra_id_15>(row = 0; row<extra_id_16>= 0 args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int t = 0; t < n; t++) { int[][] grid = new int[10][10]; for (int   < 10; j++) { grid[i][j] =  = solve(grid); for (int i = 0; i < 10; i++) { for (int  10; j++) { if (j > 0) System.out.print(\" \"); System.out.print(result[i][j]); } System.out.println(); } } sc.close(); } static int[][] solve(int[][] grid) { // Use Gaussian elimination over GF(2) // Each cell (i,j) can be toggled, affecting itself and neighbors // We need to solve for which cells to toggle to turn all lights off int[][] solution  augmented matrix for  (one  (one for each cell) int size = 100; int[][] matrix = new int[size][size + 1]; // Build the  i = 0; i < 10; i++) { for (int j = 0; j <  = i * 10 +  ti  (int tj = 0; tj < 10; tj++) {  10  affects (i,j) if they are adjacent if ((ti == i && tj == j) || (ti == i && Math.abs(tj - j) == 1) || (tj == j && Math.abs(ti - i) == 1)) {  } // Right side: current state of cell (i,j) matrix[row][size] = grid[i][j]; } } // Gaussian elimination in GF(2) for (int col = 0; col < size;  int  < size; row++) { if (matrix[row][col] == 1)  } } if (pivot == -1) continue; // Swap rows if (pivot != col) { int[]  matrix[pivot]; matrix[pivot] = temp; } // Eliminate for (int row = 0;  if (row != col && matrix[row][col] == 1) { for (int c = 0; c <= size; c++) { matrix[row][c] ^= matrix[col][c]; } } } } // Back substitution int[] vars = new int[size]; for (int i = 0; i <  matrix[i][size]; } // Convert to 2D array for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { solution[i][j] = vars[i * 10 + j];  }"], "perturbed_original": ["import java.util.Scanner; public class Main { static byte ans[][]; public static boolean f(int a[][], int s[], int n) { if (10 <=  new int[10][10]; ans = new  0; i < 10; i++) { for (int j =  } } for (int i = 0; i < 10;  1) { reverse(b, 0, i); ans[0][i] = 1; } } for  < 10; i++) { for (int j = 0; j  (b[i - 1][j] == 1)  = 1; } } } if (check(b))  else { s[n] =  +   s, n + 1)) {  void reverse(int a[][], int i, int j) { a[i][j] = (a[i][j] + 1)  i - 1) { a[i - 1][j] = (a[i - 1][j] + 1) %   + 1][j] = (a[i + 1][j] + 1) % 2; } if (0 <= j - 1) { a[i][j - 1] = (a[i][j - 1] + 1) % 2; } if (j  a[i][j  1] + 1) % 2; } } public  for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { if (a[i][j] == 1) { return false; } } } return true; } public static void main(String args[]) { Scanner sc = new Scanner(System.in); int n; int a[][]; n = sc.nextInt();  i < n; i++) { a = new int[10][10]; for (int j = 0; j < 10; j++) { for (int k = 0;  a[j][k] = sc.nextInt(); } } f(a, new int[10], 0); for (int j = 0; j < 10; j++) { String s = \"\"; for (int k = 0;  System.out.print(s + ans[j][k]); s = \" \"; } System.out.println(); } } } }"], "original_ll": -0.3113326132297516, "sampled_ll": -0.46916189789772034, "all_perturbed_sampled_ll": [-1.6875669956207275], "all_perturbed_original_ll": [-1.1715575456619263], "perturbed_sampled_ll": -1.6875669956207275, "perturbed_original_ll": -1.1715575456619263, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def attack(table, i, j):\n    table[i][j] = 1 - table[i][j]\n    table[i-1][j] = 1 - table[i-1][j]\n    table[i+1][j] = 1 - table[i+1][j]\n    table[i][j-1] = 1 - table[i][j-1]\n    table[i][j+1] = 1 - table[i][j+1]\n\ndef printans(ans):\n    for i in range(1, 11):\n        for j in range(1, 11):\n            print(ans[i][j], end=\"\")\n            if j < 10:\n                print(\" \", end=\"\")\n        print(\"\")\n\ndef solve(table, i, j, ans):\n\n    #print(i,j)\n    if i == 11:\n        flag = True\n        for k in range(1,11):\n            if table[10][k] == 1:\n                flag = False\n                break\n        if flag:\n            printans(ans)\n        return\n\n    if table[i-1][j] == 1:\n        ans[i][j] = 1\n        attack(table, i, j)\n        if j == 10:\n            solve(table, i+1, 1, ans)\n        else:\n            solve(table, i, j+1, ans)\n        attack(table, i, j)\n        ans[i][j] = 0\n    else:\n        ans[i][j] = 0\n        if j == 10:\n            solve(table, i+1, 1, ans)\n        else:\n            solve(table, i, j+1, ans)\n\n\ndef check(table, i, ans):\n\n    if i == 11:\n        solve(table, 2, 1, ans)\n        return\n\n    ans[1][i] = 0\n    check(table, i+1, ans)\n\n    ans[1][i] = 1\n    attack(table, 1, i)\n    check(table, i+1, ans)\n    attack(table, 1, i)\n\nN = int(input())\n\nfor l in range(N):\n    table= [[0 for i in range(12)] for j in range(12)]\n    ans= [[0 for i in range(12)] for j in range(12)]\n    for i in range(1, 11):\n        nums = [int(k) for k in input().split()]\n        for j in range(1, 11):\n            table[i][j] = nums[j-1]\n\n    check(table, 1, ans)\n", "sampled": "def solve_lights_out(grid):\n    # This is a lights-out puzzle problem over GF(2)\n    # We need to solve a system of linear equations in GF(2)\n    \n    # Create the coefficient matrix\n    # For a 10x10 grid, we have 100 variables and 100 equations\n    n = 10\n    size = n * n\n    \n    # Build the augmented matrix [A|b]\n    # A[i][j] = 1 if pressing button j affects light i\n    A = [[0] * size for _ in range(size)]\n    b = [0] * size\n    \n    # Fill the coefficient matrix\n    for i in range(n):\n        for j in range(n):\n            light_idx = i * n + j\n            b[light_idx] = grid[i][j]\n            \n            # Pressing button at (r, c) affects lights at (r, c) and adjacent cells\n            for r in range(n):\n                for c in range(n):\n                    button_idx = r * n + c\n                    \n                    # Check if pressing button (r,c) affects light (i,j)\n                    if (r == i and c == j):\n                        continue  # The button itself doesn't light up\n                    \n                    # Check if (i,j) is adjacent to (r,c)\n                    if (abs(r - i) + abs(c - j)) == 1:\n                        A[light_idx][button_idx] = 1\n    \n    # Gaussian elimination in GF(2)\n    augmented = [A[i] + [b[i]] for i in range(size)]\n    \n    # Forward elimination\n    for col in range(size):\n        # Find pivot\n        pivot_row = -1\n        for row in range(col, size):\n            if augmented[row][col] == 1:\n                pivot_row = row\n                break\n        \n        if pivot_row == -1:\n            continue\n        \n        # Swap rows\n        augmented[col], augmented[pivot_row] = augmented[pivot_row], augmented[col]\n        \n        # Eliminate\n        for row in range(size):\n            if row != col and augmented[row][col] == 1:\n                for k in range(size + 1):\n                    augmented[row][k] ^= augmented[col][k]\n    \n    # Back substitution\n    solution = [0] * size\n    for i in range(size):\n        if augmented[i][i] == 1:\n            solution[i] = augmented[i][size]\n    \n    # Convert solution to 2D grid\n    result = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            result[i][j] = solution[i * n + j]\n    \n    return result\n\n# Read input\nn_datasets = int(input())\nfor _ in range(n_datasets):\n    grid = []\n    for i in range(10):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    result = solve_lights_out(grid)\n    \n    for row in result:\n        print(' '.join(map(str, row)))\n", "perturbed_sampled": ["def   # We need to solve a system of linear equations  coefficient matrix # For a 10x10 grid, we have 100 variables and 100 equations n = 10 size = n  augmented matrix [A|b] # A[i][j] = 1 if pressing button j affects light i A = [[0] * size for _ in range(size)] b = [0] * size # Fill the  range(n): light_idx = i * n + j b[light_idx] = grid[i][j] # Pressing button at (r, c) affects lights at (r, c) and adjacent cells for r in range(n): for c in range(n): button_idx = r * n + c # Check if pressing button (r,c) affects light (i,j) if  == j): continue # The button itself doesn't light up # Check if (i,j) is adjacent to (r,c) if (abs(r - i) + abs(c -  1 # Gaussian elimination in GF(2) augmented = [A[i] + [b[i]] for i in range(size)] # Forward elimination for col in range(size): # Find  row  == 1: pivot_row = row break if pivot_row == -1:  augmented[pivot_row] = augmented[pivot_row], augmented[col] # Eliminate for row in range(size): if row != col and augmented[row][col] == 1: for k  substitution solution = [0] * size for i in range(size): if augmented[i][i] == 1: solution[i] = augmented[i][size]  grid result = [[0]  range(n)] for i in range(n): for j in  result # Read input n_datasets =  grid = [] for i in range(10): row =  solve_lights_out(grid)  '.join(map(str, row)))"], "perturbed_original": ["def attack(table, i, j): table[i][j] = 1 - table[i][j] table[i-1][j] = 1 - table[i-1][j] table[i+1][j] = 1 - table[i+1][j]  table[i][j+1] = 1 -  in  range(1, 11): print(ans[i][j],  print(\" \", end=\"\") print(\"\") def  if i == 11: flag = True for k in range(1,11): if table[10][k] == 1: flag = False break if flag: printans(ans) return if table[i-1][j] == 1: ans[i][j] = 1 attack(table, i, j) if j  ans) else: solve(table, i, j+1, ans) attack(table, i, j) ans[i][j] = 0 else: ans[i][j] = 0 if j == 10: solve(table, i+1, 1, ans) else: solve(table, i, j+1, ans)  i == 11: solve(table, 2, 1, ans) return ans[1][i] = 0 check(table, i+1, ans) ans[1][i] =  i+1, ans)  int(input()) for l in range(N): table=  for j in range(12)] ans= [[0 for i in range(12)] for j in range(12)]  nums = [int(k) for k in input().split()] for j in range(1, 11):  ans)"], "original_ll": -0.48895296454429626, "sampled_ll": -0.6873090267181396, "all_perturbed_sampled_ll": [-2.1488242149353027], "all_perturbed_original_ll": [-1.4146572351455688], "perturbed_sampled_ll": -2.1488242149353027, "perturbed_original_ll": -1.4146572351455688, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // qsort()\n#include <string.h>         // memset(), memcpy(), strchr()\n#include <stdbool.h>\n\n// #define DEBUG 1\n\n#define MAX_W 20\n#define MAX_H 20\n#define MAX_N 10\n\ntypedef struct order_tbl\n{\n\tint s;\n\tint bx;\n\tint by;\n\tint angle;\n\tdouble rate;\n} order_t;\n\nconst char NUL = '\\0';\n\n#ifdef DEBUG\nstatic int O = 0;\n#endif\n\nint H, W;\nchar field[MAX_H][MAX_W + 1];\nchar puzzle[MAX_H][MAX_W + 1];\nint n;\nint h0[MAX_N][4];\nint w0[MAX_N][4];\nchar piece[MAX_N][4][MAX_H][MAX_W + 1];\nint k;\nint t[MAX_N];\n\nvoid\nbury(order_t *u)\n{\n\tint s = u->s;\n\tint a = u->angle;\n\tint h = h0[s][a];\n\tint w = w0[s][a];\n\n\tfor (int y = 0; y < h; ++y)\n\t{\n\t\tfor (int x = 0; x < w; ++x)\n\t\t{\n\t\t\tif (piece[s][a][y][x] == '#')\n\t\t\t\tfield[u->by + y][u->bx + x] = '*';\n\t\t}\n\t}\n}\n\ndouble\nfitin(order_t *u, int a, int bx, int by)\n{\n\tint s = u->s;\n\tint h = h0[s][a];\n\tint w = w0[s][a];\n\n\tint dx[4] = { 0, 1, 0,-1};\n\tint dy[4] = { 1, 0,-1, 0};\n\n\tint count = 0;\n\tint total = 0;\n\tfor (int x = -1; x <= w; ++x)\n\t{\n\t\tint nx = bx + x;\n\t\tfor (int y = -1; y <= h; ++y)\n\t\t{\n\t\t\tint ny = by + y;\n\t\t\tif (0 <= x && x < w && 0 <= y && y < h && piece[s][a][y][x] == '#')\n\t\t\t{\n\t\t\t\tif (0 <= nx && nx < W && 0 <= ny && ny < H && field[ny][nx] != '.')\n\t\t\t\t\treturn -100.0;\n\t\t\t}\n\t\t\telse // piece[s][a][y][x] == '.' ?\n\t\t\t{\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\t{\n\t\t\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\t\t\tif (0 <= tx && tx < w && 0 <= ty && ty < h && piece[s][a][ty][tx] == '#')\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (i < 4)\n\t\t\t\t{\n\t\t\t\t\ttotal++;\n\t\t\t\t\tif (nx < 0 || W <= nx || ny < 0 || H <= ny || field[ny][nx] != '.')\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count * 100.0 / total;\n}\n\nvoid\nprobe(order_t *u)\n{\n\tint s = u->s;\n\tfor (int a = 0; a < 4; ++a)\n\t{\n\t\tint h = h0[s][a];\n\t\tint w = w0[s][a];\n\n\t\tint fx = strchr(piece[s][a][0], '#') - piece[s][a][0];\n\t\tfor (int by = 0; by + h <= H; ++by)\n\t\t{\n\t\t\tfor (int bx = 0; bx + w <= W; ++bx)\n\t\t\t{\n\t\t\t\tif (field[by][bx + fx] == '.')\n\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\tO++;\n#endif\n\t\t\t\t\tdouble r = fitin(u, a, bx, by);\n\t\t\t\t\tif (r > u->rate)\n\t\t\t\t\t{\n\t\t\t\t\t\tu->rate = r;\n\t\t\t\t\t\tu->bx = bx;\n\t\t\t\t\t\tu->by = by;\n\t\t\t\t\t\tu->angle = a;\n\n\t\t\t\t\t\tif (u->rate >= 100.0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbury(u);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint\ncmp_func(const void *l_, const void *r_)\n{\n\tconst order_t *l = (const order_t*) l_;\n\tconst order_t *r = (const order_t*) r_;\n\n\tif (l->rate < r->rate)\n\t\treturn 1;\n\n\tif (l->rate > r->rate)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nbool\nsolve()\n{\n\torder_t u;\n\torder_t order[MAX_N];\n\tint memo[MAX_N];\n\tint ix, ix2;\n\n\tmemcpy(field, puzzle, sizeof(field));\n\tix = 0;\n\tfor (int i = 0; i < k; ++i)\n\t\tmemo[ix++] = t[i];\n\n\twhile (ix != 0)\n\t{\n\t\tix2 = 0;\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n#ifdef DEBUG\n\t\t\tmemset(&u, 0x00, sizeof(u));\n#endif\n\t\t\tu.s = memo[i];\n\t\t\tu.rate = -100.0;\n\t\t\tprobe(&u);\n\t\t\tif (u.rate != 100.0)\n\t\t\t\torder[ix2++] = u;\n\t\t}\n\n\t\tif (ix2 == 0)\n\t\t\tbreak;\n\n\t\tqsort(order, ix2, sizeof(order_t), cmp_func);\n\t\tif (order[0].rate == -100.0)\n\t\t\treturn false;\n\n\t\tbury(&order[0]);\n\n\t\tix = 0;\n\t\tfor (int i = 1; i < ix2; ++i)\n\t\t\tmemo[ix++] = order[i].s;\n\t}\n\n\tfor (int y = 0; y < H; ++y)\n\t{\n\t\tfor (int x = 0; x < W; ++x)\n\t\t{\n\t\t\tif (field[y][x] == '.')\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\\n\", &H, &W);\n\t\tif (H == 0 && W == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < H; ++i)\n\t\t\tscanf(\"%s\", &puzzle[i][0]);\n\n\t\tscanf(\"%d\", &n);\n\t\tfor (int s = 0; s < n; ++s)\n\t\t{\n\t\t\tscanf(\"%d%d\\n\", &h0[s][0], &w0[s][0]);\n\t\t\tint h = h0[s][0];\n\t\t\tint w = w0[s][0];\n\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t\tscanf(\"%s\", &piece[s][0][y][0]);\n\n\t\t\th0[s][1] = w;\n\t\t\tw0[s][1] = h;\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tpiece[s][1][x][h - y - 1] = piece[s][0][y][x];\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tpiece[s][1][x][h] = NUL;\n#endif\n\n\t\t\th0[s][2] = h;\n\t\t\tw0[s][2] = w;\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tpiece[s][2][h - 1 - y][w - 1 - x] = piece[s][0][y][x];\n\n#ifdef DEBUG\n\t\t\t\tpiece[s][2][h - 1 - y][w] = NUL;\n#endif\n\t\t\t}\n\n\t\t\tw0[s][3] = h;\n\t\t\th0[s][3] = w;\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tpiece[s][3][w - 1 - x][y] = piece[s][0][y][x];\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tpiece[s][3][x][h] = NUL;\n#endif\n\t\t}\n\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\t\tfor (int i = 0; i < p; ++i)\n\t\t{\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor (int j = 0; j < k; ++j)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &t[j]);\n\t\t\t\tt[j]--;\n\t\t\t}\n\n\t\t\tprintf(\"%s\\n\", solve() ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tfprintf(stderr, \"O:%d\\n\", O);\n#endif\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 20\n#define MAX_PIECES 10\n\nchar grid[MAX_SIZE][MAX_SIZE+1];\nchar pieces[MAX_PIECES][MAX_SIZE][MAX_SIZE+1];\nint piece_h[MAX_PIECES], piece_w[MAX_PIECES];\nint H, W, n;\n\ntypedef struct {\n    char data[MAX_SIZE][MAX_SIZE+1];\n    int h, w;\n} Piece;\n\nvoid rotate90(Piece *src, Piece *dst) {\n    dst->h = src->w;\n    dst->w = src->h;\n    for (int i = 0; i < dst->h; i++) {\n        for (int j = 0; j < dst->w; j++) {\n            dst->data[i][j] = src->data[src->h - 1 - j][i];\n        }\n        dst->data[i][dst->w] = '\\0';\n    }\n}\n\nint canPlace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {\n    for (int i = 0; i < p->h; i++) {\n        for (int j = 0; j < p->w; j++) {\n            if (p->data[i][j] == '#') {\n                if (y + i >= H || x + j >= W || board[y+i][x+j] != '.') {\n                    return 0;\n                }\n            }\n        }\n    }\n    return 1;\n}\n\nvoid place(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {\n    for (int i = 0; i < p->h; i++) {\n        for (int j = 0; j < p->w; j++) {\n            if (p->data[i][j] == '#') {\n                board[y+i][x+j] = '#';\n            }\n        }\n    }\n}\n\nvoid unplace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {\n    for (int i = 0; i < p->h; i++) {\n        for (int j = 0; j < p->w; j++) {\n            if (p->data[i][j] == '#') {\n                board[y+i][x+j] = '.';\n            }\n        }\n    }\n}\n\nint isComplete(char board[MAX_SIZE][MAX_SIZE+1]) {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (board[i][j] == '.') return 0;\n        }\n    }\n    return 1;\n}\n\nint solve(char board[MAX_SIZE][MAX_SIZE+1], Piece rotations[][4], int selected[], int k, int used[], int idx) {\n    if (isComplete(board)) {\n        for (int i = 0; i < k; i++) {\n            if (!used[i]) return 0;\n        }\n        return 1;\n    }\n    \n    if (idx >= k) return 0;\n    \n    for (int pi = 0; pi < k; pi++) {\n        if (used[pi]) continue;\n        \n        for (int rot = 0; rot < 4; rot++) {\n            for (int y = 0; y < H; y++) {\n                for (int x = 0; x < W; x++) {\n                    if (canPlace(board, &rotations[pi][rot], y, x)) {\n                        place(board, &rotations[pi][rot], y, x);\n                        used[pi] = 1;\n                        if (solve(board, rotations, selected, k, used, idx + 1)) {\n                            return 1;\n                        }\n                        used[pi] = 0;\n                        unplace(board, &rotations[pi][rot], y, x);\n                    }\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint checkPlayer(int selected[], int k) {\n    char board[MAX_SIZE][MAX_SIZE+1];\n    for (int i = 0; i < H; i++) {\n        strcpy(board[i], grid[i]);\n    }\n    \n    Piece rotations[MAX_PIECES][4];\n    for (int i = 0; i < k; i++) {\n        int idx = selected[i] - 1;\n        rotations[i][0].h = piece_h[idx];\n        rotations[i][0].w = piece_w[idx];\n        for (int r = 0; r < piece_h[idx]; r++) {\n            strcpy(rotations[i][0].data[r], pieces[idx][r]);\n        }\n        \n        rotate90(&rotations[i][0], &rotations[i][1]);\n        rotate90(&rotations[i][1], &rotations[i][2]);\n        rotate90(&rotations[i][2], &rotations[i][3]);\n    }\n    \n    int used[MAX_PIECES] = {0};\n    return solve(board, rotations, selected, k, used, 0);\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &H, &W);\n        if (H == 0 && W == 0) break;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        scanf(\"%d\", &n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &piece_h[i], &piece_w[i]);\n            for (int j = 0; j < piece_h[i]; j++) {\n                scanf(\"%s\", pieces[i][j]);\n            }\n        }\n        \n        int p;\n        scanf(\"%d\", &p);\n        for (int i = 0; i < p; i++) {\n            int k;\n            scanf(\"%d\", &k);\n            int selected[MAX_PIECES];\n            for (int j = 0; j < k; j++) {\n                scanf(\"%d\", &selected[j]);\n            }\n            \n            if (checkPlayer(selected, k)) {\n                printf(\"YES\\n\");\n            } else {\n                printf(\"NO\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" <stdlib.h> #define  char grid[MAX_SIZE][MAX_SIZE+1];  int H, W, n; typedef struct { char data[MAX_SIZE][MAX_SIZE+1]; int h, w; } Piece; void rotate90(Piece *src, Piece *dst) { dst->h = src->w; dst->w = src->h; for (int i = 0; i < dst->h; i++)  0; j < dst->w; j++) { dst->data[i][j] = src->data[src->h - 1 - j][i]; } dst->data[i][dst->w] = '\\0'; } } int  y, int x) { for (int i = 0; i < p->h; i++) { for (int j = 0; j < p->w; j++) { if (p->data[i][j] == '#') {  H || x  board[y+i][x+j] != '.') { return 0; } }  void place(char  int x) { for (int i = 0; i < p->h; i++) { for (int j = 0; j < p->w; j++) { if (p->data[i][j] ==  } } } } void unplace(char  int x) { for (int i = 0; i < p->h; i++) { for (int j  j++) { if (p->data[i][j] == '#') { board[y+i][x+j] = '.'; } } } } int isComplete(char board[MAX_SIZE][MAX_SIZE+1]) { for (int i = 0; i < H; i++) { for (int j = 0; j < W; j++) { if (board[i][j] == '.') return  } int solve(char board[MAX_SIZE][MAX_SIZE+1], Piece rotations[][4], int selected[], int k, int used[], int idx) { if (isComplete(board)) { for (int i = 0; i < k; i++) { if (!used[i]) return 0; } return 1; } if  for (int pi =  {  rot  rot++) { for (int y =  { for (int x = 0; x  (canPlace(board, &rotations[pi][rot], y, x)) { place(board, &rotations[pi][rot], y,  (solve(board, rotations,  } used[pi] = 0; unplace(board, &rotations[pi][rot], y, x); } } } } } return 0; } int checkPlayer(int selected[], int k) { char board[MAX_SIZE][MAX_SIZE+1]; for (int i =  {  for  < k; i++) { int idx = selected[i] - 1; rotations[i][0].h = piece_h[idx]; rotations[i][0].w = piece_w[idx]; for (int r = 0; r  rotate90(&rotations[i][1], &rotations[i][2]); rotate90(&rotations[i][2], &rotations[i][3]); } int used[MAX_PIECES] = {0}; return solve(board, rotations,  int main() { while (1) { scanf(\"%d  == 0 && W == 0) break; for (int i = 0; i  grid[i]); } scanf(\"%d\", &n); for (int i  &piece_h[i], &piece_w[i]); for (int j = 0; j < piece_h[i]; j++) { scanf(\"%s\", pieces[i][j]); } } int p; scanf(\"%d\", &p); for (int i = 0; i < p; i++) { int k; scanf(\"%d\", &k); int selected[MAX_PIECES]; for (int  &selected[j]); } if (checkPlayer(selected, k)) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } } return 0; }"], "perturbed_original": ["#include <stdio.h> // printf(), scanf() #include <stdlib.h> // qsort() #include <string.h> // memset(), memcpy(), strchr() #include <stdbool.h> // #define DEBUG 1 #define MAX_W 20 #define MAX_H 20 #define MAX_N 10 typedef struct order_tbl { int s; int bx; int by; int angle; double rate; } order_t; const  DEBUG static int O = 0; #endif int H, W; char field[MAX_H][MAX_W + 1]; char puzzle[MAX_H][MAX_W + 1]; int n; int h0[MAX_N][4]; int w0[MAX_N][4]; char piece[MAX_N][4][MAX_H][MAX_W + 1]; int k; int  int s = u->s; int a = u->angle; int h = h0[s][a]; int w = w0[s][a]; for (int y = 0; y <  x = 0; x <  ==  x] = '*'; } } } double fitin(order_t *u, int a, int bx, int by) { int s = u->s; int h =  dy[4] = { 1, 0,-1, 0}; int count = 0; int total = 0; for (int  w; ++x) { int nx = bx + x; for  <= h; ++y) { int ny = by + y; if (0  w && 0 <= y && y < h && piece[s][a][y][x] == '#') { if (0 <= nx  0 <= ny && ny  '.') return -100.0; } else  { int i; for (i =  { int tx = x + dx[i],  if (0 <= tx && tx < w &&   '#') break; } if  if (nx < 0 || W <= nx || ny < 0 || H <= ny || field[ny][nx] != '.') count++; } }  void probe(order_t *u) { int s = u->s; for (int a = 0; a < 4; ++a) { int h = h0[s][a]; int w = w0[s][a]; int  piece[s][a][0]; for (int by = 0; by + h <= H; ++by) { for (int  w <= W; ++bx)  == '.') { #ifdef DEBUG O++; #endif double  by); if (r > u->rate) { u->rate  u->by = by; u->angle = a; if (u->rate >= 100.0) {  } } } } int cmp_func(const void *l_, const void *r_) { const order_t *l = (const order_t*) l_; const order_t *r = (const order_t*) r_; if  if (l->rate >  } bool  order[MAX_N]; int memo[MAX_N]; int ix, ix2; memcpy(field,  for (int i  ++i) memo[ix++] = t[i]; while (ix != 0) { ix2 = 0; for (int i = 0;  #ifdef DEBUG memset(&u, 0x00, sizeof(u)); #endif u.s = memo[i]; u.rate  != 100.0) order[ix2++] = u; }  if (order[0].rate == -100.0) return false; bury(&order[0]); ix = 0; for (int  ix2; ++i) memo[ix++]  y = 0; y < H; ++y) { for (int x = 0; x < W; ++x) { if (field[y][x] == '.') return  } int main(int argc, char **argv) {  &W); if (H == 0 && W == 0)  0; i   = 0; s < n; ++s) { scanf(\"%d%d\\n\", &h0[s][0],  for (int y = 0; y < h; ++y) scanf(\"%s\", &piece[s][0][y][0]); h0[s][1]  for (int y = 0; y < h; ++y) { for  < w; ++x) piece[s][1][x][h - y - 1] = piece[s][0][y][x]; } #ifdef DEBUG for (int x = 0; x < w; ++x) piece[s][1][x][h] = NUL; #endif h0[s][2] = h; w0[s][2] = w; for (int y =  { for (int x = 0; x < w; ++x) piece[s][2][h - 1 - y][w - 1 - x] = piece[s][0][y][x]; #ifdef DEBUG piece[s][2][h - 1 - y][w] = NUL; #endif } w0[s][3] = h; h0[s][3] = w; for (int y = 0; y < h; ++y)  0; x  1 - x][y] = piece[s][0][y][x]; } #ifdef DEBUG for (int x = 0; x < w; ++x) piece[s][3][x][h] = NUL;  &p); for (int i = 0; i < p; ++i) { scanf(\"%d\", &k); for (int j = 0; j < k;  } printf(\"%s\\n\", solve() ? \"YES\" : \"NO\"); } } #ifdef DEBUG fprintf(stderr, \"O:%d\\n\", O); #endif return 0; }"], "original_ll": -0.5772164463996887, "sampled_ll": -0.3136232793331146, "all_perturbed_sampled_ll": [-1.1706620454788208], "all_perturbed_original_ll": [-1.5122381448745728], "perturbed_sampled_ll": -1.1706620454788208, "perturbed_original_ll": -1.5122381448745728, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.util.Calendar.Builder;\n\nimport javax.jws.soap.SOAPBinding.Use;\n\n\n\npublic class Main {\n\tstatic int H;\n\tstatic int W;\n\tstatic int[] map;\n\tstatic Piece[] p;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif(H == 0 && W == 0) break;\n\t\t\tmap = new int[H];\n\t\t\tint mapCount = 0;\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tString in = sc.next();\n\t\t\t\tin = in.replace('.', '0');\n\t\t\t\tin = in.replace('#', '1');\n\t\t\t\tint bin = Integer.parseInt(in,2);\n\t\t\t\tmap[i] = bin;\n\t\t\t\tmapCount += W - Integer.bitCount(bin);\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tp = new Piece[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tString[] map = new String[h];\n\t\t\t\tfor(int j = 0; j < h; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[j] = in;\n\t\t\t\t}\n\t\t\t\tp[i] = new Piece(h,w,map);\n\t\t\t}\n\t\t\t\n\t\t\tint p = sc.nextInt();\n\t\t\tfor(int i = 0; i < p; i++) {\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tint[] t = new int[k];\n\t\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\t\tt[j] = sc.nextInt()-1;\n\t\t\t\t}\n\t\t\t\tint bitCount = 0;\n\t\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\t\tfor(int l = 0; l < Main.p[t[j]].h[0]; l++) {\n\t\t\t\t\t\tbitCount += Integer.bitCount(Main.p[t[j]].map[0][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean ans = false;\n\t\t\t\tif(bitCount == mapCount) {\n\t\t\t\t\tans = check(new boolean[k],t,map,0,0,0);\n\t\t\t\t}\n\t\t\t\tif(ans) System.out.println(\"YES\");\n\t\t\t\telse System.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean check(boolean[] used, int[] use, int[] map, int y, int x,int c) {\n\t\tif(x == W) return check(used,use,map,y+1,0,c);\n\t\tif(y == H && c == use.length) {\n\t\t\treturn true;\n\t\t}\n\t\telse if(y == H) return false;\n\t\tif((map[y] & (1 << (W - x - 1))) == 0) {\n\t\t\tfor(int i = 0; i < use.length; i++) {\n\t\t\t\tif(used[i]) continue;\n\t\t\t\tint sel = use[i];\n\t\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\t\tint xx = x - p[sel].vw[j];\n\t\t\t\t\tif(xx < 0) continue;\n\t\t\t\t\tboolean cf = checkCanFill(y,xx,j,map,p[sel]);\n\t\t\t\t\tif(!cf) continue;\n\t\t\t\t\tfill(y,xx,j,map,p[sel]);\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tboolean rt = check(used,use,map,y,x+1,c+1);\n\t\t\t\t\tif(rt) {\n\t\t\t\t\t\tused[i] = false;\n\t\t\t\t\t\tfill(y,xx,j,map,p[sel]);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tused[i] = false;\n\t\t\t\t\tfill(y,xx,j,map,p[sel]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn check(used,use,map,y,x+1,c);\n\t\t}\n\t}\n\tstatic boolean checkCanFill(int A, int B, int C,int[] map, Piece p) {\n\t\tif(p.h[C] + A > H) return false;\n\t\tif(p.w[C] + B > W || W - p.w[C] - B < 0) return false;\n\t\tfor(int i = 0; i < p.h[C]; i++) {\n\t\t\tif((map[i + A] & (p.map[C][i] << (W - p.w[C] - B))) != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic void fill(int A, int B, int C, int[] map, Piece p) {\n\t\tfor(int i = 0; i < p.h[C]; i++) {\n\t\t\tmap[i + A] ^= (p.map[C][i] << (W - p.w[C] - B));\n\t\t}\n\t}\n\tstatic boolean checkFill(int[] map) {\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tif(map[i] != (1 << W)-1) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic String[] rotate(String[] map) {\n\t\tchar[][] in = new char[map.length][];\n\t\tfor(int i = 0; i < map.length; i++) {\n\t\t\tin[i] = map[i].toCharArray();\n\t\t}\n\t\tchar[][] ret = new char[in[0].length][in.length];\n\t\tfor(int i = 0; i < in[0].length; i++) {\n\t\t\tfor(int j = 0; j < in.length; j++) {\n\t\t\t\tret[i][j] = in[in.length - j - 1][i];\n\t\t\t}\n\t\t}\n\t\tString[] retu = new String[ret.length];\n\t\tfor(int i = 0; i < ret.length; i++) {\n\t\t\tretu[i] = String.valueOf(ret[i]);\n\t\t}\n\t\treturn retu;\n\t\t\n\t}\n\t\n\t\n\tstatic class Piece {\n\t\tint[] h;\n\t\tint[] w;\n\t\tint[][] map;\n\t\tint[] vw;\n\t\tPiece(int a, int b, String[] c) {\n\t\t\th = new int[4];\n\t\t\tw = new int[4];\n\t\t\tvw = new int[4];\n\t\t\tmap = new int[4][];\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\th[i] = a;\n\t\t\t\tw[i] = b;\n\t\t\t\tmap[i] = new int[h[i]];\n\t\t\t\tfor(int j = 0; j < w[i]; j++) {\n\t\t\t\t\tif(c[0].charAt(j) == '#') {\n\t\t\t\t\t\tvw[i] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < h[i]; j++) {\n\t\t\t\t\tString in = c[j];\n\t\t\t\t\tin = in.replace('.', '0');\n\t\t\t\t\tin = in.replace('#', '1');\n\t\t\t\t\tint bin = Integer.parseInt(in,2);\n\t\t\t\t\tmap[i][j] = bin;\n\t\t\t\t}\n\t\t\t\tint tmp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = tmp;\n\t\t\t\tc = rotate(c);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        if (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static char[][] grid;\n    static List<char[][]> pieces;\n    static int H, W;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] hw = line.trim().split(\"\\\\s+\");\n            H = Integer.parseInt(hw[0]);\n            W = Integer.parseInt(hw[1]);\n            \n            if (H == 0 && W == 0) break;\n            \n            grid = new char[H][W];\n            for (int i = 0; i < H; i++) {\n                String row = br.readLine();\n                grid[i] = row.toCharArray();\n            }\n            \n            int n = Integer.parseInt(br.readLine().trim());\n            pieces = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                String[] size = br.readLine().trim().split(\"\\\\s+\");\n                int h = Integer.parseInt(size[0]);\n                int w = Integer.parseInt(size[1]);\n                char[][] piece = new char[h][w];\n                for (int j = 0; j < h; j++) {\n                    String row = br.readLine();\n                    piece[j] = row.toCharArray();\n                }\n                pieces.add(piece);\n            }\n            \n            int p = Integer.parseInt(br.readLine().trim());\n            \n            for (int i = 0; i < p; i++) {\n                String[] selection = br.readLine().trim().split(\"\\\\s+\");\n                int k = Integer.parseInt(selection[0]);\n                List<Integer> selected = new ArrayList<>();\n                for (int j = 1; j <= k; j++) {\n                    selected.add(Integer.parseInt(selection[j]) - 1);\n                }\n                \n                if (canSolve(selected)) {\n                    System.out.println(\"YES\");\n                } else {\n                    System.out.println(\"NO\");\n                }\n            }\n        }\n    }\n    \n    static boolean canSolve(List<Integer> selected) {\n        char[][] testGrid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                testGrid[i][j] = grid[i][j];\n            }\n        }\n        \n        return tryPlace(testGrid, selected, 0);\n    }\n    \n    static boolean tryPlace(char[][] testGrid, List<Integer> selected, int idx) {\n        if (idx == selected.size()) {\n            return isComplete(testGrid);\n        }\n        \n        int pieceIdx = selected.get(idx);\n        char[][] piece = pieces.get(pieceIdx);\n        \n        for (int rot = 0; rot < 4; rot++) {\n            char[][] rotated = rotate(piece, rot);\n            for (int i = 0; i <= H - rotated.length; i++) {\n                for (int j = 0; j <= W - rotated[0].length; j++) {\n                    if (canPlace(testGrid, rotated, i, j)) {\n                        char[][] backup = copyGrid(testGrid);\n                        place(testGrid, rotated, i, j);\n                        if (tryPlace(testGrid, selected, idx + 1)) {\n                            return true;\n                        }\n                        restoreGrid(testGrid, backup);\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    static boolean canPlace(char[][] testGrid, char[][] piece, int r, int c) {\n        for (int i = 0; i < piece.length; i++) {\n            for (int j = 0; j < piece[0].length; j++) {\n                if (piece[i][j] == '#') {\n                    if (testGrid[r + i][c + j] != '.') {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    \n    static void place(char[][] testGrid, char[][] piece, int r, int c) {\n        for (int i = 0; i < piece.length; i++) {\n            for (int j = 0; j < piece[0].length; j++) {\n                if (piece[i][j] == '#') {\n                    testGrid[r + i][c + j] = '#';\n                }\n            }\n        }\n    }\n    \n    static boolean isComplete(char[][] testGrid) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (testGrid[i][j] == '.') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    static char[][] rotate(char[][] piece, int times) {\n        char[][] result = piece;\n        for (int t = 0; t < times; t++) {\n            int h = result.length;\n            int w = result[0].length;\n            char[][] newPiece = new char[w][h];\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    newPiece[j][h - 1 - i] = result[i][j];\n                }\n            }\n            result = newPiece;\n        }\n        return result;\n    }\n    \n    static char[][] copyGrid(char[][] grid) {\n        char[][] copy = new char[grid.length][grid[0].length];\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                copy[i][j] = grid[i][j];\n            }\n        }\n        return copy;\n    }\n    \n    static void restoreGrid(char[][] grid, char[][] backup) {\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                grid[i][j] = backup[i][j];\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static char[][] grid; static List<char[][]> pieces; static int H, W; public static void main(String[] args) throws IOException  BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] hw =  = Integer.parseInt(hw[1]); if (H   char[H][W]; for (int i = 0; i < H; i++) {  = row.toCharArray(); } int n =  for (int i = 0; i < n;  br.readLine().trim().split(\"\\\\s+\"); int h  Integer.parseInt(size[1]);  0; j < h; j++) { String row = br.readLine(); piece[j] = row.toCharArray(); } pieces.add(piece); } int p = Integer.parseInt(br.readLine().trim()); for (int i = 0; i < p; i++) { String[] selection = br.readLine().trim().split(\"\\\\s+\"); int k = Integer.parseInt(selection[0]); List<Integer> selected = new ArrayList<>(); for (int j =  System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } }  { char[][] testGrid = new char[H][W]; for (int i = 0;  for (int j = 0; j < W; j++) { testGrid[i][j] = grid[i][j]; } } return tryPlace(testGrid, selected, 0); }  selected, int idx) { if  isComplete(testGrid); } int pieceIdx = selected.get(idx); char[][] piece = pieces.get(pieceIdx); for (int rot  rot++) { char[][] rotated  i = 0; i <= H - rotated.length; i++) { for (int j = 0; j <= W - rotated[0].length; j++) { if (canPlace(testGrid, rotated, i, j)) { char[][] backup = copyGrid(testGrid); place(testGrid, rotated, i, j); if (tryPlace(testGrid, selected, idx + 1)) { return true;  } } return false; } static boolean canPlace(char[][] testGrid, char[][] piece, int r, int c) { for (int i = 0; i  (int j = 0; j < piece[0].length; j++) { if (piece[i][j] == '#') { if (testGrid[r + i][c + j]  return true; } static void place(char[][] testGrid, char[][] piece, int r, int c) { for (int i = 0; i < piece.length;  = 0; j < piece[0].length; j++) { if (piece[i][j] == '#') { testGrid[r + i][c + j] = '#'; } } } } static boolean isComplete(char[][] testGrid) { for (int i = 0; i < H; i++) { for (int j = 0; j  return false; }  static char[][] rotate(char[][] piece, int times) { char[][] result = piece; for (int t = 0; t <  = result.length;  newPiece = new char[w][h]; for (int  h; i++) {  j < w; j++) { newPiece[j][h - 1 - i] = result[i][j];  } return result; } static char[][] copyGrid(char[][] grid) { char[][] copy = new char[grid.length][grid[0].length]; for (int i = 0; i < grid.length; i++) { for (int j = 0;  copy[i][j] = grid[i][j]; } } return copy; } static void  for (int i = 0; i < grid.length; i++) {  j  = backup[i][j]; } } } }"], "perturbed_original": ["import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.util.*; import java.util.Calendar.Builder; import javax.jws.soap.SOAPBinding.Use; public class Main {  W; static int[] map; static Piece[]  args) { FastScanner sc = new FastScanner(); //Scanner sc =  new PrintWriter(System.out); while(true) { H = sc.nextInt(); W = sc.nextInt(); if(H == 0 && W == 0) break; map = new int[H];  i = 0; i < H; i++)  in = in.replace('.', '0'); in = in.replace('#', '1'); int bin = Integer.parseInt(in,2); map[i] = bin; mapCount += W - Integer.bitCount(bin); } int n = sc.nextInt(); p =  0; i < n; i++) { int h = sc.nextInt(); int w =  String[h]; for(int j  j++) { String in = sc.next();  = new Piece(h,w,map); } int p = sc.nextInt(); for(int i = 0; i < p; i++) { int  = new  j < k; j++) { t[j]  = 0; for(int j = 0;  for(int l = 0;  bitCount += Integer.bitCount(Main.p[t[j]].map[0][l]); } } boolean ans = false; if(bitCount == mapCount) { ans = check(new boolean[k],t,map,0,0,0); } if(ans) System.out.println(\"YES\"); else System.out.println(\"NO\"); } } } static boolean  map, int y,  == W) return check(used,use,map,y+1,0,c); if(y == H && c == use.length) { return true; } else if(y  - x - 1))) == 0) { for(int i = 0; i < use.length; i++) { if(used[i]) continue; int sel = use[i]; for(int j = 0; j < 4; j++) { int xx = x - p[sel].vw[j]; if(xx < 0) continue; boolean cf = checkCanFill(y,xx,j,map,p[sel]); if(!cf) continue; fill(y,xx,j,map,p[sel]); used[i] = true; boolean rt = check(used,use,map,y,x+1,c+1); if(rt) { used[i]  } used[i] = false; fill(y,xx,j,map,p[sel]);   A, int B, int C,int[]  + A > H) return false;  ||  < 0) return false; for(int i = 0; i < p.h[C]; i++) { if((map[i + A] & (p.map[C][i] << (W - p.w[C]  false; }  fill(int A, int B, int C, int[] map, Piece p) { for(int i = 0; i < p.h[C]; i++) { map[i + A] ^= (p.map[C][i] << (W - p.w[C] - B)); } } static boolean checkFill(int[]  0; i < H;   return true; } static String[] rotate(String[] map) { char[][]  i = 0; i < map.length; i++) { in[i] = map[i].toCharArray(); } char[][]  i = 0; i < in[0].length; i++) { for(int j = 0; j < in.length; j++) { ret[i][j]   = new String[ret.length]; for(int    static class Piece { int[] h; int[] w; int[][] map; int[] vw; Piece(int a, int   new int[4]; vw = new int[4]; map = new int[4][]; for(int i = 0; i < 4; i++) { h[i] = a; w[i] = b; map[i] = new int[h[i]]; for(int j = 0; j < w[i]; j++) { if(c[0].charAt(j) == '#') { vw[i] = j; break; } } for(int j = 0; j < h[i]; j++) { String in  '0'); in = in.replace('#', '1'); int bin = Integer.parseInt(in,2); map[i][j] = bin; } int tmp = a; a = b;  rotate(c); } } } } class FastScanner { private final InputStream in = System.in; private final byte[] buffer = new byte[1024]; private int ptr = 0;  private  < buflen) { return true; }else{ ptr = 0; try { buflen = in.read(buffer); } catch (IOException e) { e.printStackTrace(); }  return false;  private int  buffer[ptr++]; else return -1;} private static boolean  <= c && c <= 126;} private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;} public boolean hasNext() { skipUnprintable(); return hasNextByte();}  (!hasNext()) throw new NoSuchElementException(); StringBuilder sb = new StringBuilder(); int b = readByte(); while(isPrintableChar(b)) {  return sb.toString(); } public long nextLong() { if (!hasNext()) throw new NoSuchElementException(); long n = 0; boolean minus = false;  (b == '-') { minus = true; b = readByte(); } if  < b) { throw new NumberFormatException(); } while(true){ if ('0' <= b && b <= '9')  += b - '0'; }else if(b == -1 || !isPrintableChar(b)){ return minus  throw new NumberFormatException(); } b = readByte(); }  if (!hasNext()) throw new NoSuchElementException(); int n = 0; boolean minus = false; int b = readByte();  minus  '0' || '9' <  } while(true){ if ('0' <= b && b <= '9') {  b - '0'; }else if(b == -1 || !isPrintableChar(b)){ return minus ? -n : n; }else{ throw new NumberFormatException(); } b = readByte(); } } }"], "original_ll": -0.45830273628234863, "sampled_ll": -0.2564164400100708, "all_perturbed_sampled_ll": [-1.1182605028152466], "all_perturbed_original_ll": [-1.5009864568710327], "perturbed_sampled_ll": -1.1182605028152466, "perturbed_original_ll": -1.5009864568710327, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import copy\ndef rot90(A):\n  return zip(*A[::-1])\n\ndef count_board(Board):\n  X = [[0 for _ in [0]*(Width+1)] for _ in [0]*(Height+1)]\n  for i in range(Height)[::-1]:\n    for j in range(Width)[::-1]:\n      X[i][j] = X[i+1][j] + X[i][j+1] - X[i+1][j+1] + (Board[i][j]=='.')\n  return X\n\ndef check_sum(TRIALS):\n  return sum([B[e] for e in TRIALS]) != DOTS[0][0]\n\ndef tmp_put(Board, piece, y, x):\n  N = range(len(piece[0]))\n  for i in range(len(piece)):\n    tmp = piece[i]\n    BoardRow = Board[y+i]\n    for j in N:\n      if tmp[j]=='#' and BoardRow[x+j]!='.': return 0\n  return 1\n\ndef get_put(Board, piece, y, x, mode):\n  c = '#.'[mode]\n  W = range(len(piece[0]))\n  for i in range(len(piece)):\n    tmp = piece[i]\n    Y = y+i\n    for j in W:\n      if tmp[j]=='#': Board[Y][x+j]=c\n  return Board\n\ndef PrintBoard(Board):\n  for e in Board:\n    print \"\".join(e)\n  print\n  return\n\ndef PrintDots(DOTS):\n  for e in DOTS:\n    print e\n  print\n  return\n\ndef solve(TRIALS, Board):\n  if TRIALS==[]: return 1\n  n = TRIALS[0]\n  DOTS = count_board(Board)\n  for direction in C[n]:\n    P = PIECE[(n, direction)]\n    h = len(P)\n    w = len(P[0])\n    s = B[n]\n    POS=[]\n    H = range(Height-h+1)\n    W = range(Width-w+1)\n    for i in H:\n      A1 = DOTS[i]\n      A2 = DOTS[i+h]\n      for j in W:\n        tmp = A1[j] - A2[j] - A1[j+w] + A2[j+w]\n        if tmp>=s and tmp_put(Board, P, i, j):\n          Board = get_put(Board, P, i, j, 0)\n          if solve(TRIALS[1:], Board): return 1\n          Board = get_put(Board, P, i, j, 1)\n  return 0\n\ndef CheckPieceType(i):\n  def f(x1, x2):\n    for j in range(len(PIECE[i, x1])):\n      if \"\".join(PIECE[i, x1][j])!=\"\".join(PIECE[i, x2][j]): return 0\n    return 1\n  flg = [0,1,2,3]\n  for a, b in [[0,1], [1,3], [0,2]]:\n    if f(a, b): flg[b] = flg[a]\n  return list(set(flg))\n\nwhile 1:\n  Height, Width = map(int,raw_input().split())\n  if Height*Width==0: break\n  try: Board = [list(raw_input()) for _ in [0]*Height]\n  except: break\n  DOTS = count_board(Board)\n  PIECE = {}\n  n = input()\n  B = [0] * n\n  C = [[0, 0, 0, 0] for _ in [0] * n]\n  for i in range(n):\n    height, width = map(int, raw_input().split())\n    tmp = [list(raw_input()) for _ in [0] * height]\n    B[i] = sum([e.count('#') for e in tmp])\n    for direction in [0, 1, 2, 3]:\n      PIECE[(i, direction)] = tmp\n      tmp = rot90(tmp)\n    C[i] = CheckPieceType(i)\n  for _ in [0]*input():\n    a = map(int, raw_input().split())[1:]\n    a = sorted([[B[e-1], e-1] for e in a], key = lambda x:{-x[0]})\n    TRIALS = list(zip(*a)[1])\n    if check_sum(TRIALS): print \"NO\"\n    else: print [\"NO\", \"YES\"][solve(TRIALS, copy.deepcopy(Board))]", "sampled": "import sys\nfrom copy import deepcopy\n\ndef read_input():\n    datasets = []\n    while True:\n        line = sys.stdin.readline()\n        if not line:\n            break\n        parts = line.strip().split()\n        if len(parts) == 2:\n            H, W = int(parts[0]), int(parts[1])\n            if H == 0 and W == 0:\n                break\n            \n            # Read puzzle grid\n            grid = []\n            for _ in range(H):\n                grid.append(sys.stdin.readline().strip())\n            \n            # Read number of pieces\n            n = int(sys.stdin.readline().strip())\n            \n            # Read pieces\n            pieces = []\n            for _ in range(n):\n                h = int(sys.stdin.readline().strip())\n                w = int(sys.stdin.readline().strip())\n                piece = []\n                for _ in range(h):\n                    piece.append(sys.stdin.readline().strip())\n                pieces.append(piece)\n            \n            # Read players\n            p = int(sys.stdin.readline().strip())\n            players = []\n            for _ in range(p):\n                line = sys.stdin.readline().strip().split()\n                k = int(line[0])\n                selected = [int(line[i+1]) - 1 for i in range(k)]\n                players.append(selected)\n            \n            datasets.append((H, W, grid, pieces, players))\n    \n    return datasets\n\ndef rotate_90(piece):\n    h = len(piece)\n    w = len(piece[0])\n    rotated = []\n    for j in range(w):\n        row = \"\"\n        for i in range(h-1, -1, -1):\n            row += piece[i][j]\n        rotated.append(row)\n    return rotated\n\ndef get_rotations(piece):\n    rotations = [piece]\n    current = piece\n    for _ in range(3):\n        current = rotate_90(current)\n        rotations.append(current)\n    return rotations\n\ndef get_piece_coords(piece):\n    coords = []\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if piece[i][j] == '#':\n                coords.append((i, j))\n    return coords\n\ndef try_place(grid, H, W, piece, start_r, start_c):\n    piece_coords = get_piece_coords(piece)\n    placed = []\n    for dr, dc in piece_coords:\n        r = start_r + dr\n        c = start_c + dc\n        if r < 0 or r >= H or c < 0 or c >= W:\n            return None\n        if grid[r][c] != '.':\n            return None\n        placed.append((r, c))\n    return placed\n\ndef solve(H, W, grid, selected_pieces):\n    # Create a mutable grid\n    target = []\n    for i in range(H):\n        row = list(grid[i])\n        target.append(row)\n    \n    # Get all rotations for each piece\n    all_rotations = []\n    for piece in selected_pieces:\n        all_rotations.append(get_rotations(piece))\n    \n    def backtrack(piece_idx):\n        if piece_idx == len(selected_pieces):\n            # Check if all '.' are filled\n            for i in range(H):\n                for j in range(W):\n                    if target[i][j] == '.':\n                        return False\n            return True\n        \n        piece_rotations = all_rotations[piece_idx]\n        \n        for rotation in piece_rotations:\n            # Try all possible positions\n            for start_r in range(-19, H+20):\n                for start_c in range(-19, W+20):\n                    placed = try_place(target, H, W, rotation, start_r, start_c)\n                    if placed:\n                        # Mark cells\n                        for r, c in placed:\n                            target[r][c] = '#'\n                        \n                        if backtrack(piece_idx + 1):\n                            return True\n                        \n                        # Unmark cells\n                        for r, c in placed:\n                            target[r][c] = '.'\n        \n        return False\n    \n    return backtrack(0)\n\ndef main():\n    datasets = read_input()\n    \n    for H, W, grid, pieces, players in datasets:\n        for selected_indices in players:\n            selected_pieces = [pieces[i] for i in selected_indices]\n            if solve(H, W, grid, selected_pieces):\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from copy  = [] while True: line = sys.stdin.readline() if not line: break  == 2: H, W = int(parts[0]), int(parts[1]) if H == 0 and W == 0: break # Read puzzle grid grid = [] for _ in range(H): grid.append(sys.stdin.readline().strip()) # Read number of pieces n = int(sys.stdin.readline().strip()) # Read pieces pieces = [] for _ in range(n): h = int(sys.stdin.readline().strip()) w = int(sys.stdin.readline().strip()) piece = []  pieces.append(piece) # Read players p = int(sys.stdin.readline().strip()) players = [] for  sys.stdin.readline().strip().split() k = int(line[0]) selected = [int(line[i+1]) - 1 for i in range(k)] players.append(selected) datasets.append((H, W, grid, pieces,  =  j in range(w): row  range(h-1, -1,  rotations = [piece] current = piece for _  rotations.append(current) return rotations def get_piece_coords(piece): coords = [] for i in range(len(piece)): for j  '#': coords.append((i, j)) return coords def try_place(grid, H, W, piece, start_r,  = [] for dr, dc in piece_coords: r  if r < 0 or r >= H or c <  return None if grid[r][c] != '.': return None  solve(H, W, grid, selected_pieces): # Create a mutable grid  in range(H): row = list(grid[i]) target.append(row) # Get  piece in selected_pieces: all_rotations.append(get_rotations(piece)) def backtrack(piece_idx): if piece_idx == len(selected_pieces): # Check if all '.' are filled for i in range(H): for j in range(W): if target[i][j] == '.': return False return True piece_rotations = all_rotations[piece_idx] for rotation in piece_rotations: # Try all possible positions for start_r in range(-19, H+20):  placed = try_place(target, H, W, rotation, start_r, start_c) if placed: # Mark cells for r, c in placed: target[r][c] =  return True # Unmark cells for  = '.' return False return backtrack(0) def main(): datasets = read_input() for H, W, grid, pieces, players in datasets:  = [pieces[i] for i in selected_indices] if solve(H, W, grid, selected_pieces): print(\"YES\") else: print(\"NO\") if __name__ == \"__main__\": main()"], "perturbed_original": ["import copy def rot90(A): return zip(*A[::-1]) def count_board(Board): X = [[0 for _   X[i][j] = X[i+1][j]  (Board[i][j]=='.') return X def check_sum(TRIALS): return sum([B[e] for e in  piece, y, x): N = range(len(piece[0])) for i in   N: if tmp[j]=='#' and BoardRow[x+j]!='.': return 0  y, x, mode):  range(len(piece[0])) for i in range(len(piece)): tmp = piece[i] Y = y+i for j in W: if tmp[j]=='#': Board[Y][x+j]=c return Board def PrintBoard(Board): for e in Board: print \"\".join(e) print return def PrintDots(DOTS): for e in  def solve(TRIALS, Board): if TRIALS==[]: return 1 n =  direction in C[n]: P = PIECE[(n, direction)] h = len(P) w = len(P[0]) s = B[n] POS=[] H = range(Height-h+1) W = range(Width-w+1) for i in H: A1 = DOTS[i] A2 =   if tmp>=s and tmp_put(Board, P, i, j): Board = get_put(Board, P, i, j, 0) if solve(TRIALS[1:], Board): return 1 Board = get_put(Board, P, i, j, 1) return 0 def CheckPieceType(i): def f(x1, x2): for j in range(len(PIECE[i, x1])): if \"\".join(PIECE[i, x1][j])!=\"\".join(PIECE[i, x2][j]): return 0 return  a, b in  b): flg[b] = flg[a] return list(set(flg)) while 1: Height, Width = map(int,raw_input().split()) if Height*Width==0: break try: Board = [list(raw_input()) for _ in [0]*Height] except: break DOTS = count_board(Board) PIECE = {} n = input() B  = [[0, 0, 0, 0]  n] for i in range(n): height, width = map(int, raw_input().split()) tmp = [list(raw_input()) for  B[i] = sum([e.count('#') for e in tmp]) for direction in [0, 1, 2, 3]: PIECE[(i, direction)]  C[i] = CheckPieceType(i) for _ in [0]*input(): a   a], key = lambda x:{-x[0]}) TRIALS = list(zip(*a)[1]) if check_sum(TRIALS): print \"NO\" else: print [\"NO\", \"YES\"][solve(TRIALS, copy.deepcopy(Board))]"], "original_ll": -1.1150410175323486, "sampled_ll": -0.5357298851013184, "all_perturbed_sampled_ll": [-1.8105826377868652], "all_perturbed_original_ll": [-2.1378731727600098], "perturbed_sampled_ll": -1.8105826377868652, "perturbed_original_ll": -2.1378731727600098, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint rotate(char pat[8][9]) {\n\tchar buf[8][9];\n\tint x,y;\n\tfor(y=0;y<8;y++) {\n\t\tfor(x=0;x<8;x++) {\n\t\t\tbuf[x][7-y]=pat[y][x];\n\t\t}\n\t}\n\tmemcpy(pat,buf,sizeof(pat));\n}\n\nint main(void) {\n\tchar buf[8][9];\n\tint i;\n\tfor(i=0;i<8;i++)scanf(\"%s\",buf[i]);\n\trotate(buf);\n\tputs(\"90\");\n\tfor(i=0;i<8;i++)printf(\"%s\\n\",buf[i]);\n\trotate(buf);\n\tputs(\"180\");\n\tfor(i=0;i<8;i++)printf(\"%s\\n\",buf[i]);\n\trotate(buf);\n\tputs(\"270\");\n\tfor(i=0;i<8;i++)printf(\"%s\\n\",buf[i]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    char pattern[8][9];\n    int i, j;\n    \n    // Read input\n    for (i = 0; i < 8; i++) {\n        scanf(\"%s\", pattern[i]);\n    }\n    \n    // 90 degrees\n    printf(\"90\\n\");\n    for (i = 0; i < 8; i++) {\n        for (j = 7; j >= 0; j--) {\n            printf(\"%c\", pattern[j][i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    // 180 degrees\n    printf(\"180\\n\");\n    for (i = 7; i >= 0; i--) {\n        for (j = 7; j >= 0; j--) {\n            printf(\"%c\", pattern[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    // 270 degrees\n    printf(\"270\\n\");\n    for (i = 7; i >= 0; i--) {\n        for (j = 0; j < 8; j++) {\n            printf(\"%c\", pattern[j][i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { char pattern[8][9]; int i, j; // Read input for (i = 0; i < 8; i++) { scanf(\"%s\", pattern[i]); } // 90  0; i < 8; i++) { for (j  180 degrees printf(\"180\\n\"); for (i = 7; i >= 0; i--) { for (j = 7; j >= 0; j--) {   (i = 7; i >= 0; i--) { for (j = 0; j < 8; j++) { printf(\"%c\", pattern[j][i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int  int x,y; for(y=0;y<8;y++) { for(x=0;x<8;x++) { buf[x][7-y]=pat[y][x]; } } memcpy(pat,buf,sizeof(pat)); } int main(void) { char buf[8][9]; int i; for(i=0;i<8;i++)scanf(\"%s\",buf[i]); rotate(buf); puts(\"90\"); for(i=0;i<8;i++)printf(\"%s\\n\",buf[i]); rotate(buf); puts(\"180\");  0; }"], "original_ll": -0.7540631294250488, "sampled_ll": -0.34170857071876526, "all_perturbed_sampled_ll": [-1.3702090978622437], "all_perturbed_original_ll": [-1.704288125038147], "perturbed_sampled_ll": -1.3702090978622437, "perturbed_original_ll": -1.704288125038147, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tchar[][] pattern = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tline = br.readLine();\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tpattern[i][j] = line.charAt(j);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 3; i++) {\n\t\t\tpattern = rotate(pattern);\n\t\t\tSystem.out.println(i * 90);\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tSystem.out.println(new String(pattern[j]));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic char[][] rotate(char[][] pattern) {\n\t\tchar[][] rotate = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\trotate[j][7 - i] = pattern[i][j];\n\t\t\t}\n\t\t}\n\t\treturn rotate;\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        char[][] pattern = new char[8][8];\n        \n        for (int i = 0; i < 8; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 8; j++) {\n                pattern[i][j] = line.charAt(j);\n            }\n        }\n        \n        // 90 degrees\n        System.out.println(\"90\");\n        char[][] rotated90 = rotate90(pattern);\n        printPattern(rotated90);\n        \n        // 180 degrees\n        System.out.println(\"180\");\n        char[][] rotated180 = rotate90(rotated90);\n        printPattern(rotated180);\n        \n        // 270 degrees\n        System.out.println(\"270\");\n        char[][] rotated270 = rotate90(rotated180);\n        printPattern(rotated270);\n        \n        sc.close();\n    }\n    \n    private static char[][] rotate90(char[][] pattern) {\n        char[][] result = new char[8][8];\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                result[i][j] = pattern[7 - j][i];\n            }\n        }\n        return result;\n    }\n    \n    private static void printPattern(char[][] pattern) {\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                System.out.print(pattern[i][j]);\n            }\n            System.out.println();\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  void main(String[] args) { Scanner sc = new Scanner(System.in); char[][] pattern = new char[8][8]; for (int i = 0; i < 8; i++)  for (int j = 0; j < 8; j++)  }  // 180 degrees System.out.println(\"180\"); char[][] rotated180 = rotate90(rotated90); printPattern(rotated180); // 270 degrees System.out.println(\"270\"); char[][] rotated270 =  static char[][] rotate90(char[][] pattern) { char[][] result =  = 0; i < 8; i++) { for (int j = 0; j < 8; j++) { result[i][j] = pattern[7 - j][i]; } } return result; } private static void printPattern(char[][] pattern) { for (int i =  { for (int j = 0;  System.out.print(pattern[i][j]); } System.out.println(); } } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main {  throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line =  char[8][8]; for (int i = 0; i <  br.readLine(); for (int j = 0; j < 8; j++)  } for (int i = 1; i <= 3; i++) { pattern  for (int j = 0; j < 8; j++) { System.out.println(new String(pattern[j])); } } } static char[][] rotate(char[][] pattern) { char[][] rotate  i = 0; i < 8; i++) { for  < 8; j++) { rotate[j][7 - i] = pattern[i][j]; } } return rotate; } }"], "original_ll": -0.43604421615600586, "sampled_ll": -0.2759386897087097, "all_perturbed_sampled_ll": [-1.1442829370498657], "all_perturbed_original_ll": [-1.500113606452942], "perturbed_sampled_ll": -1.1442829370498657, "perturbed_original_ll": -1.500113606452942, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "d=[list(raw_input()) for i in range(8)]\np=[d,[],[],[]]\nfor r in range(3):\n\tprint 90*(r+1)\n\tfor j in range(8):\n\t\tp[r+1].append([p[r][i][j] for i in range(7,-1,-1)])\n\t\tprint \"\".join(p[r+1][j])", "sampled": "# Read input\npattern = []\nfor _ in range(8):\n    pattern.append(input())\n\n# 90 degree rotation (clockwise)\nrotated_90 = []\nfor col in range(8):\n    row_str = \"\"\n    for row in range(7, -1, -1):\n        row_str += pattern[row][col]\n    rotated_90.append(row_str)\n\n# 180 degree rotation\nrotated_180 = []\nfor row in range(7, -1, -1):\n    rotated_180.append(pattern[row][::-1])\n\n# 270 degree rotation (clockwise)\nrotated_270 = []\nfor col in range(7, -1, -1):\n    row_str = \"\"\n    for row in range(8):\n        row_str += pattern[row][col]\n    rotated_270.append(row_str)\n\n# Output\nprint(\"90\")\nfor row in rotated_90:\n    print(row)\nprint(\"180\")\nfor row in rotated_180:\n    print(row)\nprint(\"270\")\nfor row in rotated_270:\n    print(row)\n", "perturbed_sampled": ["# Read input pattern = [] for _ in range(8): pattern.append(input()) #  = [] for col in range(8): row_str = \"\" for row in range(7, -1, -1): row_str += pattern[row][col] rotated_90.append(row_str) # 180 degree rotation rotated_180 = [] for row in range(7, -1, -1): rotated_180.append(pattern[row][::-1]) #  = [] for col in range(7, -1, -1): row_str = \"\" for row in range(8): row_str += pattern[row][col] rotated_270.append(row_str) # Output print(\"90\") for   rotated_270: print(row)"], "perturbed_original": ["d=[list(raw_input()) for i in range(8)] p=[d,[],[],[]]  90*(r+1) for j in range(8): p[r+1].append([p[r][i][j] for i in range(7,-1,-1)]) print \"\".join(p[r+1][j])"], "original_ll": -1.6898950338363647, "sampled_ll": -0.4012436866760254, "all_perturbed_sampled_ll": [-1.3849245309829712], "all_perturbed_original_ll": [-2.1398630142211914], "perturbed_sampled_ll": -1.3849245309829712, "perturbed_original_ll": -2.1398630142211914, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n\n  int n, sum, in, i;\n\n  sum = 0;\n\n  scanf(\"%d\",&n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\",&in);\n    sum += in;\n  }\n\n  printf(\"%d\\n\",sum/n);\n\n  return 0;\n\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n        int v;\n        scanf(\"%d\", &v);\n        sum += v;\n    }\n    \n    printf(\"%lld\\n\", sum / n);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n); long long sum  = 0; i <  scanf(\"%d\", &v); sum += v; } printf(\"%lld\\n\", sum / n); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int  = 0; scanf(\"%d\",&n); for(i = 0; i < n; i++){ scanf(\"%d\",&in); sum += in; } printf(\"%d\\n\",sum/n); return 0; }"], "original_ll": -1.1532410383224487, "sampled_ll": -0.5788486003875732, "all_perturbed_sampled_ll": [-1.888585090637207], "all_perturbed_original_ll": [-1.6933836936950684], "perturbed_sampled_ll": -1.888585090637207, "perturbed_original_ll": -1.6933836936950684, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\n\n\n \npublic class Main {\n  public static void main(String[] args) {\n    InputReader sc = new InputReader(System.in);\n \n    int n = sc.nextInt();\n    long sum = 0;\n    for(int i = 0; i < n; i++){\n      sum += sc.nextInt();\n    }\n    System.out.println(sum/n);\n\n\n  }\n \n  \n \n  static class InputReader {\n      private InputStream stream;\n      private byte[] buf = new byte[1024];\n      private int curChar;\n      private int numChars;\n      private SpaceCharFilter filter;\n\n      public InputReader(InputStream stream) {\n          this.stream = stream;\n      }\n \n      public int next() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = stream.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n \n      public String nextStr() {\n        int c = next();\n        while(isSpaceChar(c)){c = next();}\n        StringBuffer str = new StringBuffer();\n        do{\n          str.append((char)c);\n          c = next();\n        }while(!isSpaceChar(c));\n        return str.toString();\n      }\n\n      public int nextInt() {\n          int c = next();\n          while (isSpaceChar(c))\n              c = next();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = next();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = next();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public boolean isSpaceChar(int c) {\n          if (filter != null)\n              return filter.isSpaceChar(c);\n          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n \n      public interface SpaceCharFilter {\n          public boolean isSpaceChar(int ch);\n      }\n  }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += sc.nextInt();\n        }\n        System.out.println(sum / n);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) {  int n = sc.nextInt();  (int i = 0; i < n; i++) { sum += sc.nextInt(); } System.out.println(sum / n); sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.util.Arrays; import java.util.InputMismatchException; import java.util.LinkedList; public class Main { public static void main(String[]   0; for(int i = 0; i < n; i++){ sum += sc.nextInt(); } System.out.println(sum/n); }  InputStream stream; private byte[] buf = new byte[1024];  numChars; private SpaceCharFilter filter; public InputReader(InputStream stream) {  int next() { if (numChars == -1) throw new InputMismatchException(); if (curChar >= numChars) { curChar = 0;  } catch (IOException e) { throw new InputMismatchException(); } if (numChars <= 0) return -1; } return buf[curChar++]; } public String nextStr() { int c = next(); while(isSpaceChar(c)){c = next();} StringBuffer  str.append((char)c); c = next(); }while(!isSpaceChar(c)); return str.toString(); } public int nextInt() { int c = next(); while (isSpaceChar(c)) c  1; if (c == '-') { sgn = -1; c = next(); } int res =  > '9') throw  res += c - '0'; c = next(); } while (!isSpaceChar(c)); return res * sgn; } public boolean isSpaceChar(int  null) return filter.isSpaceChar(c); return c ==  '\\n' || c == '\\r' || c == '\\t' || c  SpaceCharFilter { public boolean isSpaceChar(int ch); } } }"], "original_ll": -0.38447561860084534, "sampled_ll": -0.47175759077072144, "all_perturbed_sampled_ll": [-1.4605298042297363], "all_perturbed_original_ll": [-1.4398293495178223], "perturbed_sampled_ll": -1.4605298042297363, "perturbed_original_ll": -1.4398293495178223, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def main():\n    n = int(input())\n    a = 0\n    for _ in range(n):\n        a += int(input())\n    ans = a // n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()", "sampled": "n = int(input())\ntotal = 0\nfor _ in range(n):\n    total += int(input())\nprint(total // n)\n", "perturbed_sampled": ["n = int(input()) total = 0 for _ in range(n): total += int(input()) print(total // n)"], "perturbed_original": ["def main(): n =  _ in range(n): a += int(input()) ans = a // n print(ans) if __name__ == \"__main__\": main()"], "original_ll": -0.7381988763809204, "sampled_ll": -1.1758366823196411, "all_perturbed_sampled_ll": [-1.7080930471420288], "all_perturbed_original_ll": [-2.191417932510376], "perturbed_sampled_ll": -1.7080930471420288, "perturbed_original_ll": -2.191417932510376, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n    int n;\n    int h, m;\n    int i;\n    double angle;\n    \n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++){\n        scanf(\"%d:%d\", &h, &m);\n        \n        angle = h * 360 / 12 + 360 / 12 * m / 60.0;\n        angle -= (360 / 60 * m);\n        \n        if (angle > 180){\n            angle -= 360;\n        }\n        \n        if (-30 < angle && angle < 30){\n            printf(\"alert\\n\");\n        }\n        else if (-90 < angle && angle < 90){\n            printf(\"warning\\n\");\n        }\n        else {\n            printf(\"safe\\n\");\n        }\n    }\n    return (0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        int hh, mm;\n        scanf(\"%d:%d\", &hh, &mm);\n        \n        // Calculate angle of minute hand (6 degrees per minute)\n        double minute_angle = mm * 6.0;\n        \n        // Calculate angle of hour hand (30 degrees per hour + 0.5 degrees per minute)\n        double hour_angle = (hh % 12) * 30.0 + mm * 0.5;\n        \n        // Calculate the absolute difference\n        double diff = abs(hour_angle - minute_angle);\n        if (diff > 180.0) {\n            diff = 360.0 - diff;\n        }\n        \n        // Determine the output\n        if (diff >= 0 && diff < 30) {\n            printf(\"alert\\n\");\n        } else if (diff >= 90 && diff <= 180) {\n            printf(\"safe\\n\");\n        } else {\n            printf(\"warning\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int main() { int n; scanf(\"%d\", &n); for (int i = 0; i < n; i++) { int hh, mm; scanf(\"%d:%d\", &hh, &mm); // Calculate  minute_angle  Calculate angle of hour hand  0.5 degrees per minute) double hour_angle = (hh % 12) * 30.0 +  the absolute difference double diff = abs(hour_angle - minute_angle);  diff = 360.0 - diff; } // Determine the output if (diff >= 0 && diff < 30) { printf(\"alert\\n\"); } else if (diff >= 90 && diff <= 180) { printf(\"safe\\n\"); }  return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void)  m; int i; double  = 0; i < n; i++){ scanf(\"%d:%d\", &h,  m / 60.0; angle -= (360 / 60 * m); if (angle > 180){ angle -= 360; } if (-30 < angle && angle < 30){ printf(\"alert\\n\"); } else if (-90 < angle && angle < 90){ printf(\"warning\\n\"); } else { printf(\"safe\\n\"); } } return (0); }"], "original_ll": -0.8103087544441223, "sampled_ll": -0.5629788637161255, "all_perturbed_sampled_ll": [-1.5814107656478882], "all_perturbed_original_ll": [-1.8361598253250122], "perturbed_sampled_ll": -1.5814107656478882, "perturbed_original_ll": -1.8361598253250122, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main{\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        for(int i=0;i<n;i++) {\n           String[] s=sc.next().split(\":\");\n           int a=Integer.parseInt(s[0])*60;\n           int b=Integer.parseInt(s[1]);\n           int d=Math.abs((a+b)/2-b*6);\n           System.out.println(d<30||d>330?\"alert\":d<90||d>270?\"warning\":\"safe\");\n        }\n    }\n}\n", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String time = sc.nextLine();\n            String[] parts = time.split(\":\");\n            int hh = Integer.parseInt(parts[0]);\n            int mm = Integer.parseInt(parts[1]);\n            \n            // Calculate angle of hour hand from 12 o'clock\n            // Hour hand moves 30 degrees per hour and 0.5 degrees per minute\n            double hourAngle = (hh % 12) * 30.0 + mm * 0.5;\n            \n            // Calculate angle of minute hand from 12 o'clock\n            // Minute hand moves 6 degrees per minute\n            double minuteAngle = mm * 6.0;\n            \n            // Calculate the difference\n            double diff = Math.abs(hourAngle - minuteAngle);\n            \n            // The angle should be the smaller one (between 0 and 180)\n            if (diff > 180) {\n                diff = 360 - diff;\n            }\n            \n            if (diff >= 0 && diff < 30) {\n                System.out.println(\"alert\");\n            } else if (diff >= 90 && diff <= 180) {\n                System.out.println(\"safe\");\n            } else {\n                System.out.println(\"warning\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { public static void main(String[] args) { Scanner sc = new Scanner(System.in);  for (int i = 0;  String time = sc.nextLine(); String[] parts  Integer.parseInt(parts[0]); int mm = Integer.parseInt(parts[1]); // Calculate angle of  // Hour hand moves  0.5 degrees per minute double hourAngle = (hh % 12) * 30.0 + mm * 0.5; // Calculate angle of minute hand from 12 o'clock //  per minute double minuteAngle = mm * 6.0; // Calculate the difference double diff = Math.abs(hourAngle - minuteAngle); // The angle should be the smaller one (between 0 and 180) if (diff > 180) { diff = 360 - diff; } if (diff >= 0 && diff   && diff <= 180) { System.out.println(\"safe\"); } else  } }"], "perturbed_original": ["import java.util.Scanner; class Main{ public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=sc.nextInt(); for(int i=0;i<n;i++) {  b=Integer.parseInt(s[1]); int d=Math.abs((a+b)/2-b*6); System.out.println(d<30||d>330?\"alert\":d<90||d>270?\"warning\":\"safe\"); } } }"], "original_ll": -1.302575707435608, "sampled_ll": -0.5041465163230896, "all_perturbed_sampled_ll": [-1.504616618156433], "all_perturbed_original_ll": [-1.8886046409606934], "perturbed_sampled_ll": -1.504616618156433, "perturbed_original_ll": -1.8886046409606934, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N = int(input())\nfor i in range(N):\n    h, m = map(int, input().split(\":\"))\n    d = abs(60*h - 11*m)\n    v = min(d, 720 - d)\n    if v < 60:\n        print(\"alert\")\n    elif v < 180:\n        print(\"warning\")\n    else:\n        print(\"safe\")\n\n", "sampled": "n = int(input())\nfor _ in range(n):\n    time = input().strip()\n    hh, mm = map(int, time.split(':'))\n    \n    # Calculate hour hand angle (from 12 o'clock)\n    hour_angle = (hh % 12) * 30 + mm * 0.5\n    \n    # Calculate minute hand angle (from 12 o'clock)\n    minute_angle = mm * 6\n    \n    # Calculate the difference\n    diff = abs(hour_angle - minute_angle)\n    \n    # Take the smaller angle\n    if diff > 180:\n        diff = 360 - diff\n    \n    # Determine the status\n    if 0 <= diff < 30:\n        print(\"alert\")\n    elif 90 <= diff <= 180:\n        print(\"safe\")\n    else:\n        print(\"warning\")\n", "perturbed_sampled": ["n = int(input()) for _ in range(n): time = input().strip() hh, mm = map(int, time.split(':')) # Calculate hour hand angle (from 12 o'clock)  * 30 + mm * 0.5 # Calculate minute hand angle (from 12 o'clock) minute_angle = mm  difference diff = abs(hour_angle - minute_angle) #  diff > 180: diff  Determine the status if 0  elif 90 <= diff <= 180: print(\"safe\") else: print(\"warning\")"], "perturbed_original": ["N = int(input()) for i in range(N): h, m = map(int, input().split(\":\")) d = abs(60*h - 11*m) v =  elif v < 180: print(\"warning\") else: print(\"safe\")"], "original_ll": -1.263045310974121, "sampled_ll": -0.7824774384498596, "all_perturbed_sampled_ll": [-2.1460635662078857], "all_perturbed_original_ll": [-2.1334035396575928], "perturbed_sampled_ll": -2.1460635662078857, "perturbed_original_ll": -2.1334035396575928, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\tint i,j,num[24+1],temp01;\n\tfloat time[24+1],temp02;\n\tfor(i=0;i<24;i++) {\n\t\tscanf(\"%d %f\",&num[i],&time[i]);\n\t}\n\tfor(i=0;i<8-1;i++) {\n\t\tfor(j=i+1;j<8;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=8;i<16-1;i++) {\n\t\tfor(j=i+1;j<16;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=16;i<24-1;i++) {\n\t\tfor(j=i+1;j<24;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<2;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t\ttime[i]=100.00;\n\t}\n\tfor(i=8;i<10;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t\ttime[i]=100.00;\n\t}\n\tfor(i=16;i<18;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t\ttime[i]=100.00;\n\t}\n\tfor(i=0;i<24-1;i++) {\n\t\tfor(j=i+1;j<24;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<2;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int player;\n    double time;\n} Record;\n\nint compare(const void *a, const void *b) {\n    Record *r1 = (Record *)a;\n    Record *r2 = (Record *)b;\n    if (r1->time < r2->time) return -1;\n    if (r1->time > r2->time) return 1;\n    return 0;\n}\n\nint main() {\n    Record groups[3][8];\n    Record qualifiers[8];\n    Record others[18];\n    int others_count = 0;\n    \n    // Read input\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 8; j++) {\n            scanf(\"%d %lf\", &groups[i][j].player, &groups[i][j].time);\n        }\n    }\n    \n    // Sort each group by time\n    for (int i = 0; i < 3; i++) {\n        qsort(groups[i], 8, sizeof(Record), compare);\n    }\n    \n    // First 2 from each group\n    qualifiers[0] = groups[0][0];\n    qualifiers[1] = groups[0][1];\n    qualifiers[2] = groups[1][0];\n    qualifiers[3] = groups[1][1];\n    qualifiers[4] = groups[2][0];\n    qualifiers[5] = groups[2][1];\n    \n    // Collect 3rd place and below from all groups\n    for (int i = 0; i < 3; i++) {\n        for (int j = 2; j < 8; j++) {\n            others[others_count++] = groups[i][j];\n        }\n    }\n    \n    // Sort others by time\n    qsort(others, others_count, sizeof(Record), compare);\n    \n    // Top 2 from others\n    qualifiers[6] = others[0];\n    qualifiers[7] = others[1];\n    \n    // Output\n    for (int i = 0; i < 8; i++) {\n        printf(\"%d %.2f\\n\", qualifiers[i].player, qualifiers[i].time);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int player; double time; } Record; int compare(const void *a, const  = (Record *)a; Record *r2  < r2->time) return -1; if (r1->time > r2->time) return 1; return 0; } int main()  Record others[18]; int others_count = 0; // Read input for (int i = 0; i  (int j = 0; j < 8; j++) { scanf(\"%d %lf\", &groups[i][j].player, &groups[i][j].time); } } // Sort each group  = 0; i < 3; i++) { qsort(groups[i], 8, sizeof(Record), compare); }  group qualifiers[0] = groups[0][0]; qualifiers[1] = groups[0][1]; qualifiers[2] = groups[1][0]; qualifiers[3]  qualifiers[5] = groups[2][1];  below from all groups for (int i = 0; i < 3; i++)  j++) { others[others_count++] = groups[i][j]; } } // Sort others by time qsort(others, others_count, sizeof(Record), compare);  qualifiers[6] = others[0]; qualifiers[7] = others[1]; // Output for (int i = 0; i < 8; i++) { printf(\"%d  0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int i,j,num[24+1],temp01; float time[24+1],temp02; for(i=0;i<24;i++) { scanf(\"%d %f\",&num[i],&time[i]); } for(i=0;i<8-1;i++) { for(j=i+1;j<8;j++) {  temp02=time[i]; time[i]=time[j]; time[j]=temp02; } } } for(i=8;i<16-1;i++) { for(j=i+1;j<16;j++)  num[j]=temp01; temp02=time[i]; time[i]=time[j];  { for(j=i+1;j<24;j++) { if(time[i]>time[j]) { temp01=num[i]; num[i]=num[j]; num[j]=temp01; temp02=time[i]; time[i]=time[j]; time[j]=temp02; } } } for(i=0;i<2;i++) { printf(\"%d %f\\n\",num[i],time[i]); time[i]=100.00; }  } for(i=16;i<18;i++) { printf(\"%d %f\\n\",num[i],time[i]);  { if(time[i]>time[j]) { temp01=num[i]; num[i]=num[j]; num[j]=temp01; temp02=time[i]; time[i]=time[j]; time[j]=temp02; } } } for(i=0;i<2;i++) { printf(\"%d %f\\n\",num[i],time[i]); } return 0; }"], "original_ll": -0.36738166213035583, "sampled_ll": -0.4540741741657257, "all_perturbed_sampled_ll": [-1.4293489456176758], "all_perturbed_original_ll": [-0.9068678021430969], "perturbed_sampled_ll": -1.4293489456176758, "perturbed_original_ll": -0.9068678021430969, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\nclass Player implements Comparable<Player>{\n\tint party;\n\tint num;\n\tString time;\n\tPlayer(int p,int n,String t){\n\t\tthis.party = p;\n\t\tthis.num = n;\n\t\tthis.time = t;\n\t}\n\t/*@Override\n\tpublic int compareTo(Player p) {\n\t\treturn this.time.compareTo(p.num);\n\t}\n\t*/\n\t@Override\n\tpublic int compareTo(Player o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn this.time.compareTo(o.time);\n\t}\n\t\n}\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tPlayer[] person = new Player[24];\n\t\tint[][] rank = new int[3][8];\n\t\tint[] cnt = new int[3]; \n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tint cnt3 = 0;\n\t\tfor(int i = 0;i < 3;i++){\n\t\t\tfor(int j = 0;j < 8;j++){\n\t\t\t\tperson[i*8+j] = new Player(i,sc.nextInt(),sc.next());\n\t\t\t}\n\t\t}\n\t\tArrays.sort(person);\n\t\tfor(int i = 0;i < 24;i++){\n\t\t\trank[person[i].party][cnt[person[i].party]] = i;\n\t\t\tcnt[person[i].party]++;\n\t\t}\n\t\tfor(int i = 0;i < 3;i++){\n\t\t\tfor(int j = 0;j < 2;j++){\n\t\t\t\tSystem.out.println(person[rank[i][j]].num+\" \"+person[rank[i][j]].time);\n\t\t\t\tperson[rank[i][j]].time = \"999\";\n\t\t\t}\n\t\t}\n\t\tArrays.sort(person);\n\t\tfor(int j = 0;j < 2;j++){\n\t\t\tSystem.out.println(person[j].num+\" \"+person[j].time);\n\t\t}\n\t\t\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Athlete implements Comparable<Athlete> {\n        int number;\n        double time;\n        \n        Athlete(int number, double time) {\n            this.number = number;\n            this.time = time;\n        }\n        \n        @Override\n        public int compareTo(Athlete other) {\n            return Double.compare(this.time, other.time);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        List<Athlete>[] groups = new List[3];\n        for (int i = 0; i < 3; i++) {\n            groups[i] = new ArrayList<>();\n        }\n        \n        // Read input\n        for (int i = 0; i < 24; i++) {\n            int number = sc.nextInt();\n            double time = sc.nextDouble();\n            int group = i / 8;\n            groups[group].add(new Athlete(number, time));\n        }\n        \n        // Sort each group by time\n        for (int i = 0; i < 3; i++) {\n            Collections.sort(groups[i]);\n        }\n        \n        // Output top 2 from each group\n        List<Athlete> finalists = new ArrayList<>();\n        for (int i = 0; i < 3; i++) {\n            finalists.add(groups[i].get(0));\n            finalists.add(groups[i].get(1));\n        }\n        \n        // Get 3rd place and below from all groups\n        List<Athlete> remaining = new ArrayList<>();\n        for (int i = 0; i < 3; i++) {\n            for (int j = 2; j < groups[i].size(); j++) {\n                remaining.add(groups[i].get(j));\n            }\n        }\n        \n        // Sort remaining athletes and get top 2\n        Collections.sort(remaining);\n        finalists.add(remaining.get(0));\n        finalists.add(remaining.get(1));\n        \n        // Output all finalists\n        for (Athlete a : finalists) {\n            System.out.println(a.number + \" \" + a.time);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Athlete implements Comparable<Athlete> { int number; double time; Athlete(int number, double  this.time = time; }  { return Double.compare(this.time, other.time); } } public static  sc = new Scanner(System.in); List<Athlete>[] groups = new List[3]; for (int i = 0; i < 3; i++) { groups[i] = new ArrayList<>(); } // Read  0;  double time = sc.nextDouble(); int group = i / 8; groups[group].add(new Athlete(number, time)); } // Sort each group by time for  < 3; i++) { Collections.sort(groups[i]); } // Output top 2 from each group List<Athlete> finalists = new ArrayList<>(); for (int i =  // Get 3rd  groups List<Athlete> remaining = new ArrayList<>(); for (int i =  { for (int j = 2; j < groups[i].size(); j++) { remaining.add(groups[i].get(j)); } } // Sort remaining athletes and get top 2 Collections.sort(remaining); finalists.add(remaining.get(0)); finalists.add(remaining.get(1)); // Output all finalists for (Athlete a : finalists) { System.out.println(a.number  } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; class Player implements Comparable<Player>{ int party; int num; String time;  = p; this.num = n; this.time = t; } /*@Override public int compareTo(Player p) { return this.time.compareTo(p.num); } */ @Override public  TODO Auto-generated method stub return this.time.compareTo(o.time); } } public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); Player[] person = new Player[24]; int[][] rank = new  0; int  = 0;i < 3;i++){ for(int j = 0;j < 8;j++){ person[i*8+j] = new Player(i,sc.nextInt(),sc.next()); } } Arrays.sort(person); for(int i = 0;i < 24;i++){ rank[person[i].party][cnt[person[i].party]] = i; cnt[person[i].party]++; } for(int i = 0;i   } Arrays.sort(person); for(int j = 0;j < 2;j++){ System.out.println(person[j].num+\" \"+person[j].time); } } }"], "original_ll": -0.6950618028640747, "sampled_ll": -0.41957589983940125, "all_perturbed_sampled_ll": [-1.4053434133529663], "all_perturbed_original_ll": [-1.506855845451355], "perturbed_sampled_ll": -1.4053434133529663, "perturbed_original_ll": -1.506855845451355, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "l1,l2,l3=[],[],[]\nfinal=[]\ncount=0\nfor i in range(24):\n    p,t=map(float,input().split())\n    if count<=7:l1.append([t,p])\n    elif 7<count<=15:l2.append([t,p])\n    elif 15<count<=23:l3.append([t,p])\n    count +=1\nl1=sorted(l1)\nl2=sorted(l2)\nl3=sorted(l3)\nfinal +=[l1[0],l1[1],l2[0],l2[1],l3[0],l3[1]]\ndel l1[0],l1[0],l2[0],l2[0],l3[0],l3[0]\nthird=sorted(l1+l2+l3)\nfinal +=[third[0],third[1]]\nfor i in range(8):print(int(final[i][1]),final[i][0])\n", "sampled": "# Read all 24 runners\nrunners = []\nfor i in range(24):\n    line = input().split()\n    p = int(line[0])\n    t = float(line[1])\n    runners.append((p, t))\n\n# Split into 3 groups\ngroup1 = runners[0:8]\ngroup2 = runners[8:16]\ngroup3 = runners[16:24]\n\n# Sort each group by time\ngroup1.sort(key=lambda x: x[1])\ngroup2.sort(key=lambda x: x[1])\ngroup3.sort(key=lambda x: x[1])\n\n# Top 2 from each group\nqualifiers = []\nqualifiers.append(group1[0])\nqualifiers.append(group1[1])\nqualifiers.append(group2[0])\nqualifiers.append(group2[1])\nqualifiers.append(group3[0])\nqualifiers.append(group3[1])\n\n# Collect 3rd place and below from all groups\nremaining = []\nremaining.extend(group1[2:])\nremaining.extend(group2[2:])\nremaining.extend(group3[2:])\n\n# Sort remaining by time and take top 2\nremaining.sort(key=lambda x: x[1])\nqualifiers.append(remaining[0])\nqualifiers.append(remaining[1])\n\n# Output\nfor p, t in qualifiers:\n    print(f\"{p} {t:.2f}\")\n", "perturbed_sampled": ["# Read all 24 runners runners = [] for i in range(24): line = input().split() p = int(line[0]) t = float(line[1]) runners.append((p, t)) # Split into 3 groups group1 = runners[0:8] group2  #  group1.sort(key=lambda x:   = [] qualifiers.append(group1[0]) qualifiers.append(group1[1]) qualifiers.append(group2[0]) qualifiers.append(group2[1]) qualifiers.append(group3[0]) qualifiers.append(group3[1]) # Collect 3rd place and below from all  remaining.extend(group2[2:]) remaining.extend(group3[2:]) # Sort remaining by time and take top 2 remaining.sort(key=lambda x: x[1]) qualifiers.append(remaining[0]) qualifiers.append(remaining[1]) # Output for p, t in qualifiers: print(f\"{p} {t:.2f}\")"], "perturbed_original": ["l1,l2,l3=[],[],[] final=[] count=0 for i in range(24): p,t=map(float,input().split())  15<count<=23:l3.append([t,p]) count +=1 l1=sorted(l1) l2=sorted(l2) l3=sorted(l3) final +=[l1[0],l1[1],l2[0],l2[1],l3[0],l3[1]] del l1[0],l1[0],l2[0],l2[0],l3[0],l3[0] third=sorted(l1+l2+l3) final +=[third[0],third[1]] for i in range(8):print(int(final[i][1]),final[i][0])"], "original_ll": -0.9173847436904907, "sampled_ll": -0.6935495734214783, "all_perturbed_sampled_ll": [-1.7067582607269287], "all_perturbed_original_ll": [-1.3063373565673828], "perturbed_sampled_ll": -1.7067582607269287, "perturbed_original_ll": -1.3063373565673828, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n  char w[201];\n  int a,i,j,k;\n  scanf(\"%d\",&a);\n  for(j=0;j<a;j++){\n    scanf(\"%s\",w);\n    if(w[0]!='>'){printf(\"NA\\n\");continue;}\n    if(w[1]=='\\''){\n      for(i=2;w[i]!='#';i++){\n\tif(w[i]!='='){printf(\"NA\\n\");continue;}\n      }\n      int t=i-1;\n      for(k=t;t>0;t--){\n\tif(w[i++]!='='){printf(\"NA\\n\");continue;}\n      }\n      if(w[i++]!='~'){printf(\"NA\\n\");continue;}\n      if(w[i]!='\\0'){printf(\"NA\\n\");continue;}\n      printf(\"A\\n\");\n    }\n    if(w[1]=='^'){\n      for(i=2;w[i]=='~';i+=2){\n\tif(w[i]!='Q'){printf(\"NA\\n\");continue;}\n\tif(w[i+1]!='='){printf(\"NA\\n\");continue;}\n      }\n      if(w[i]!='~'){printf(\"NA\\n\");continue;}\n      if(w[i+1]!='~'){printf(\"NA\\n\");continue;}\n      if(w[i+2]!='\\0'){printf(\"NA\\n\");continue;}\n      printf(\"B\\n\");\n    }\n  }\nreturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint checkA(char *s) {\n    int len = strlen(s);\n    if (len < 6) return 0;\n    if (s[0] != '>' || s[1] != '\\'') return 0;\n    if (s[len-1] != '~') return 0;\n    \n    int i = 2;\n    int count1 = 0;\n    while (i < len && s[i] == '=') {\n        count1++;\n        i++;\n    }\n    \n    if (count1 == 0) return 0;\n    if (i >= len || s[i] != '#') return 0;\n    i++;\n    \n    int count2 = 0;\n    while (i < len && s[i] == '=') {\n        count2++;\n        i++;\n    }\n    \n    if (count2 != count1) return 0;\n    if (i != len - 1) return 0;\n    if (s[i] != '~') return 0;\n    \n    return 1;\n}\n\nint checkB(char *s) {\n    int len = strlen(s);\n    if (len < 6) return 0;\n    if (s[0] != '>' || s[1] != '^') return 0;\n    if (len < 2 || s[len-1] != '~' || s[len-2] != '~') return 0;\n    \n    int i = 2;\n    int count = 0;\n    while (i < len - 2) {\n        if (s[i] == 'Q' && i + 1 < len - 2 && s[i+1] == '=') {\n            count++;\n            i += 2;\n        } else {\n            return 0;\n        }\n    }\n    \n    if (count == 0) return 0;\n    if (i != len - 2) return 0;\n    \n    return 1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        char s[201];\n        scanf(\"%s\", s);\n        \n        if (checkA(s)) {\n            printf(\"A\\n\");\n        } else if (checkB(s)) {\n            printf(\"B\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int checkA(char *s) { int len = strlen(s); if (len < 6) return 0; if (s[0] != '>' || s[1] != '\\'') return 0; if (s[len-1] != '~') return 0; int  = 0; while (i < len && s[i] == '=')  (count1 == 0) return 0; if (i >= len || s[i] != '#') return   { count2++; i++; } if (count2 != count1) return 0; if (i != len -   if (s[0]  '^') return 0; if (len < 2 || s[len-1] != '~' || s[len-2] != '~') return 0; int i = 2; int count = 0; while (i < len - 2) { if (s[i] == 'Q' &&  - 2 && s[i+1] == '=') { count++; i += 2; } else { return 0; } } if (count == 0) return 0; if (i != len - 2) return 0; return 1; } int main() { int n; scanf(\"%d\", &n); for (int i = 0; i < n; i++) { char s[201]; scanf(\"%s\", s); if (checkA(s)) { printf(\"A\\n\"); } else if (checkB(s)) { printf(\"B\\n\");  } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ char w[201]; int a,i,j,k; scanf(\"%d\",&a); for(j=0;j<a;j++){ scanf(\"%s\",w); if(w[0]!='>'){printf(\"NA\\n\");continue;} if(w[1]=='\\''){ for(i=2;w[i]!='#';i++){ if(w[i]!='='){printf(\"NA\\n\");continue;} } int t=i-1;  printf(\"A\\n\"); } if(w[1]=='^'){  if(w[i+1]!='~'){printf(\"NA\\n\");continue;} if(w[i+2]!='\\0'){printf(\"NA\\n\");continue;} printf(\"B\\n\"); } } return 0; }"], "original_ll": -0.9893012642860413, "sampled_ll": -0.4636233448982239, "all_perturbed_sampled_ll": [-1.1784335374832153], "all_perturbed_original_ll": [-1.5771727561950684], "perturbed_sampled_ll": -1.1784335374832153, "perturbed_original_ll": -1.5771727561950684, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<String> Ans = new ArrayList<String>();\n\t\tString line = in.readLine();\n\t\t\n\t\tint size = Integer.parseInt(line);\n\t\tfor(int n=0; n<size; n++){\n\t\t\tline = in.readLine();\n\t\t\tint type = 0;\n\t\t\t\n\t\t\tString c = line.substring(0, 2);\n\t\t\tif(c.equals(\">'\")){\n\t\t\t\tint count = 0;\n\t\t\t\tint sharp = 0;\n\t\t\t\tfor(int i=2; i<line.length(); i++){\n\t\t\t\t\tc = line.substring(i, i+1);\n\t\t\t\t\tif(c.equals(\"=\")){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(c.equals(\"#\")){\n\t\t\t\t\t\tif(count > 0){\n\t\t\t\t\t\t\tcount = -count;\n\t\t\t\t\t\t\tsharp = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(c.equals(\"~\")){\n\t\t\t\t\t\tif(i != line.length()-1){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(count==0 && sharp==1){\n\t\t\t\t\t\t\ttype = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(c.equals(\">^\")){\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i=2; i<line.length(); i++){\n\t\t\t\t\tc = line.substring(i, i+1);\n\t\t\t\t\tif(count%2==0 && count>=2 && c.equals(\"~\")){\n\t\t\t\t\t\tif(i==line.length()-1){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tc = line.substring(i+1, i+2);\n\t\t\t\t\t\tif(c.equals(\"~\")){\n\t\t\t\t\t\t\ttype = 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2==0){\n\t\t\t\t\t\tif(!c.equals(\"Q\")){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2==1){\n\t\t\t\t\t\tif(!c.equals(\"=\")){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!c.equals(\"Q\") && !c.equals(\"=\") && !c.equals(\"~\")){\n\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttype = -1;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(type){\n\t\t\t\tcase 1:\n\t\t\t\t\tAns.add(\"A\");\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 2:\n\t\t\t\t\tAns.add(\"B\");\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tAns.add(\"NA\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tSystem.out.println(Ans.get(n));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String s = sc.nextLine();\n            System.out.println(classify(s));\n        }\n        sc.close();\n    }\n    \n    static String classify(String s) {\n        if (isTypeA(s)) {\n            return \"A\";\n        } else if (isTypeB(s)) {\n            return \"B\";\n        } else {\n            return \"NA\";\n        }\n    }\n    \n    static boolean isTypeA(String s) {\n        // Pattern: >'=+#=+~\n        // Must start with >'\n        if (!s.startsWith(\">'\")) {\n            return false;\n        }\n        \n        // Must end with ~\n        if (!s.endsWith(\"~\")) {\n            return false;\n        }\n        \n        // Find # position\n        int hashPos = s.indexOf('#');\n        if (hashPos == -1) {\n            return false;\n        }\n        \n        // Check if there's only one #\n        if (s.indexOf('#', hashPos + 1) != -1) {\n            return false;\n        }\n        \n        // Extract parts\n        String beforeHash = s.substring(2, hashPos);\n        String afterHash = s.substring(hashPos + 1, s.length() - 1);\n        \n        // Both parts must be non-empty and consist only of '='\n        if (beforeHash.length() == 0 || afterHash.length() == 0) {\n            return false;\n        }\n        \n        // Both parts must have same length and only contain '='\n        if (beforeHash.length() != afterHash.length()) {\n            return false;\n        }\n        \n        for (char c : beforeHash.toCharArray()) {\n            if (c != '=') {\n                return false;\n            }\n        }\n        \n        for (char c : afterHash.toCharArray()) {\n            if (c != '=') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    static boolean isTypeB(String s) {\n        // Pattern: >^(Q=)+~~\n        // Must start with >^\n        if (!s.startsWith(\">^\")) {\n            return false;\n        }\n        \n        // Must end with ~~\n        if (!s.endsWith(\"~~\")) {\n            return false;\n        }\n        \n        // Extract middle part\n        String middle = s.substring(2, s.length() - 2);\n        \n        // Middle must be non-empty\n        if (middle.length() == 0) {\n            return false;\n        }\n        \n        // Middle must be repetitions of \"Q=\"\n        if (middle.length() % 2 != 0) {\n            return false;\n        }\n        \n        for (int i = 0; i < middle.length(); i += 2) {\n            if (middle.charAt(i) != 'Q' || middle.charAt(i + 1) != '=') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.nextLine();  i < n; i++) { String   s) { if (isTypeA(s)) { return \"A\"; }  \"B\"; } else { return \"NA\"; } } static boolean isTypeA(String s) { // Pattern: >'=+#=+~ // Must start with >' if (!s.startsWith(\">'\")) { return  with ~ if (!s.endsWith(\"~\")) { return false; } // Find # position int hashPos = s.indexOf('#'); if (hashPos  there's only one # if (s.indexOf('#', hashPos + 1) != -1) { return false; } // Extract parts String beforeHash = s.substring(2, hashPos); String afterHash = s.substring(hashPos  // Both parts must be non-empty and consist   0) { return false; } // Both parts must have same length and only contain '='  return false; } for (char c : beforeHash.toCharArray()) { if (c != '=') { return false; } } for (char c : afterHash.toCharArray()) {  return false; } } return true; } static boolean isTypeB(String s) { // Pattern: >^(Q=)+~~ //  (!s.startsWith(\">^\")) { return false; } // Must end with ~~ if (!s.endsWith(\"~~\")) { return false;  s.length() - 2); // Middle must be non-empty if (middle.length() == 0) { return false; } // Middle must be repetitions  2 != 0) { return false; } for  < middle.length(); i += 2) { if  + 1) != '=') { return false; } } return true; } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static   } public Main() throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); List<String> Ans = new ArrayList<String>(); String line = in.readLine(); int size = Integer.parseInt(line); for(int n=0; n<size; n++){ line = in.readLine(); int type = 0; String  int count = 0; int sharp = 0; for(int i=2;  i+1); if(c.equals(\"=\")){ count++; } else if(c.equals(\"#\")){ if(count > 0){ count = -count;  type = -1; break; } } else  = -1; break; } if(count==0 && sharp==1){ type = 1; break; }  } } else{ type = -1; break; } } } else if(c.equals(\">^\")){ int count = 0; for(int i=2; i<line.length(); i++){ c = line.substring(i, i+1); if(count%2==0 && count>=2 && c.equals(\"~\")){ if(i==line.length()-1){ type  = line.substring(i+1, i+2); if(c.equals(\"~\")){ type = 2; break; } else{ type = -1; break; }   if(i%2==1){ if(!c.equals(\"=\")){ type = -1; break; } count++; } if(!c.equals(\"Q\") && !c.equals(\"=\") && !c.equals(\"~\")){ type  } else{ type =  Ans.add(\"B\"); break; default: Ans.add(\"NA\"); } } for(int n=0; n<Ans.size(); n++){ System.out.println(Ans.get(n)); } } }"], "original_ll": -0.6221852898597717, "sampled_ll": -0.567301869392395, "all_perturbed_sampled_ll": [-1.7218444347381592], "all_perturbed_original_ll": [-1.5812714099884033], "perturbed_sampled_ll": -1.7218444347381592, "perturbed_original_ll": -1.5812714099884033, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nN = int(input())\n\ndef is_A(s):\n    if s[0:2] != \">'\":\n        return False\n\n    if s[-1] != '~':\n        return False\n\n    body = s[2:-1]\n\n    if len(body) % 2 == 0:\n        return False\n\n    # body = '==#=='\n    center_index = len(body) // 2\n    if body[center_index] != '#':\n        return False\n\n    if body.count('#') != 1:\n        return False\n\n    lst = body.split('#')\n    if len(lst) != 2:\n        return False\n\n    if len(lst[0]) > 0 and lst[0] == lst[1] and len(lst[0]) == lst[0].count('='):\n        return True\n    else:\n        return False\n\ndef is_B(s):\n    if s[0:2] != \">^\":\n        return False\n\n    if s[-2:] != '~~':\n        return False\n\n    body = s[2:-2]\n\n    if len(body) % 2 != 0:\n        return False\n    elif body.count('Q=') > 0 and body.count('Q=') == len(body) // 2:\n        return True\n    else:\n        return False\n\nfor s in sys.stdin:\n    s = s.strip()\n\n    if is_A(s):\n        print('A')\n    elif is_B(s):\n        print('B')\n    else:\n        print('NA')", "sampled": "import re\n\nn = int(input())\nfor _ in range(n):\n    s = input().strip()\n    \n    # Check for Type A: >'=+#=+~\n    match_a = re.match(r\"^>\\'(=+)#\\1~$\", s)\n    if match_a:\n        print(\"A\")\n        continue\n    \n    # Check for Type B: >^(Q=)+~~\n    match_b = re.match(r\"^>\\^(Q=)+~~$\", s)\n    if match_b:\n        print(\"B\")\n        continue\n    \n    print(\"NA\")\n", "perturbed_sampled": ["import re n = int(input()) for _ in range(n): s = input().strip() # Check for Type <extra_id_2>=<extra_id_3>s):<extra_id_4>i=0; k<k> f<extra_id_5>a+=1<extra_id_6>< 1: \"B|A +<extra_id_7>== s<extra_id_8>\"A +<extra_id_9>a<extra_id_10>\" Q =<extra_id_11>: \"B\"<extra_id_12>: i = 0<extra_id_13>for<extra_id_14>:<extra_id_15>: #<extra_id_16>2<extra_id_17>\"Q= +~~$\" ,<extra_id_18>;<extra_id_19>: i += 1<extra_id_20>1<extra_id_21>: s<extra_id_22>[ '<extra_id_23>'Q' : 1 s) if match_a: print(\"A\") continue #  match_b = re.match(r\"^>\\^(Q=)+~~$\", s) if match_b: print(\"B\") continue print(\"NA\")"], "perturbed_original": ["# -*- coding: utf-8  N = int(input()) def is_A(s): if s[0:2] != \">'\": return False if s[-1] != '~': return False body = s[2:-1] if len(body) % 2 == 0: return False #  len(body) // 2 if body[center_index] != '#': return False if body.count('#') !=  2: return False if len(lst[0]) > 0 and lst[0] == lst[1] and len(lst[0])  if s[0:2] != \">^\": return False  False body = s[2:-2] if len(body) % 2 != 0: return False elif body.count('Q=') > 0 and body.count('Q=') == len(body) // 2: return True else: return False for  s.strip() if is_A(s): print('A') elif is_B(s): print('B') else: print('NA')"], "original_ll": -0.9821922779083252, "sampled_ll": -1.7302114963531494, "all_perturbed_sampled_ll": [-2.530883312225342], "all_perturbed_original_ll": [-1.8758944272994995], "perturbed_sampled_ll": -2.530883312225342, "perturbed_original_ll": -1.8758944272994995, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(){\n\tchar tei[15]={0,1,2,3,4,5,6,7,8,9,5,4,3,2,1},ans[1000][20];\n\tint n,i,to,from,j;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tif(from<to){\n\t\t\t\tfor(j=from;j<to;j++){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",to);\n\t\t}else if(to==5){\n\t\t\tfor(j=from;j<=9;j++){\n\t\t\t\tprintf(\"%d \",j);\n\t\t\t}\n\t\t\tputs(\"5\");\n\t\t}else if(from>to){\n\t\t\tif(from>=6&&from<=9){\n\t\t\t\tfor(j=from;j<=9;j++){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tfor(j=5;j>to;j--){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",to);\n\t\t\t}else{\n\t\t\t\tfor(j=from;j>to;j--){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int start, end;\n        scanf(\"%d %d\", &start, &end);\n        \n        // Calculate distances for different routes\n        int dist_forward = 0;\n        int dist_backward = 0;\n        \n        // Going forward (clockwise direction)\n        if (start <= 5 && end <= 5) {\n            if (end > start) {\n                dist_forward = end - start;\n            } else {\n                // Need to go through the loop\n                dist_forward = (5 - start) + 1 + (9 - 5) + 1 + (5 - end);\n            }\n        } else if (start <= 5 && end > 5) {\n            // From main line to loop\n            if (start <= 5) {\n                dist_forward = (5 - start) + (end - 5);\n            }\n        } else if (start > 5 && end <= 5) {\n            // From loop to main line\n            if (end <= 5) {\n                if (start == 9) dist_forward = 1 + end;\n                else if (start == 8) dist_forward = 2 + end;\n                else if (start == 7) dist_forward = 3 + end;\n                else if (start == 6) dist_forward = 4 + end;\n            }\n        } else {\n            // Both in loop\n            if (end > start) {\n                dist_forward = end - start;\n            } else {\n                dist_forward = (9 - start) + 1 + (end - 5);\n            }\n        }\n        \n        // Going backward (counter-clockwise)\n        if (start <= 5 && end <= 5) {\n            if (end < start) {\n                dist_backward = start - end;\n            } else {\n                // Need to go through the loop\n                dist_backward = start + 1 + (9 - 5) + 1 + (5 - end);\n            }\n        } else if (start <= 5 && end > 5) {\n            // From main line to loop through 0\n            dist_backward = start + 1 + (9 - end) + 1;\n        } else if (start > 5 && end <= 5) {\n            // From loop to main line\n            if (start == 6) dist_backward = 1 + (5 - end);\n            else if (start == 7) dist_backward = 2 + (5 - end);\n            else if (start == 8) dist_backward = 3 + (5 - end);\n            else if (start == 9) dist_backward = 4 + (5 - end);\n        } else {\n            // Both in loop\n            if (end < start) {\n                dist_backward = start - end;\n            } else {\n                dist_backward = (start - 5) + 1 + (9 - end) + 1;\n            }\n        }\n        \n        // Choose the shorter route\n        int go_forward = (dist_forward <= dist_backward);\n        \n        int pos = start;\n        printf(\"%d\", pos);\n        \n        while (pos != end) {\n            if (go_forward) {\n                if (pos < 5) {\n                    pos++;\n                } else if (pos == 5) {\n                    if (end > 5 || end == 0) {\n                        pos = 6;\n                    } else {\n                        pos--;\n                    }\n                } else if (pos >= 6 && pos <= 8) {\n                    pos++;\n                } else if (pos == 9) {\n                    pos = 5;\n                }\n            } else {\n                if (pos > 0 && pos <= 5) {\n                    pos--;\n                } else if (pos == 6) {\n                    pos = 5;\n                } else if (pos >= 7 && pos <= 9) {\n                    pos--;\n                } else if (pos == 0) {\n                    pos = 1;\n                }\n            }\n            printf(\" %d\", pos);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n);  end; scanf(\"%d  distances for different routes int dist_forward =  // Going forward (clockwise direction) if (start <= 5  if (end > start) { dist_forward = end  // Need to go through the loop dist_forward = (5 - start) + 1 + (9 - 5) + 1  <= 5 && end > 5) {  loop if (start <= 5) { dist_forward = (5 - start) + (end - 5); } } else  end <= 5) { //  if (end <= 5) { if (start == 9) dist_forward = 1 + end; else if (start == 8) dist_forward = 2 + end; else if (start == 7) dist_forward =  (start == 6) dist_forward = 4 + end; } } else { // Both in loop if (end > start) { dist_forward = end - start; } else { dist_forward  5); } } // Going backward (counter-clockwise) if (start <= 5 && end <= 5) { if  = start - end;  to go through the loop dist_backward = start + 1 +  + (5 - end); } } else if (start <= 5 && end >  line to loop through 0 dist_backward = start + 1 + (9 - end) + 1; } else if (start > 5 && end <= 5) { // From loop to main line if  1 + (5 - end); else if (start == 7) dist_backward = 2 + (5 - end); else if (start == 8) dist_backward  end); else if (start == 9) dist_backward  end); } else { // Both in loop if (end <  - end; } else { dist_backward = (start -  - end) + 1; } } // Choose the shorter route  dist_backward); int pos = start;  end)  (pos < 5) { pos++; } else if (pos == 5) { if (end > 5 || end == 0) { pos = 6; } else { pos--;  >= 6 && pos <= 8) { pos++; } else if (pos == 9)   > 0 && pos <= 5) {  =  >= 7 && pos <= 9) { pos--; } else if (pos == 0) { pos = 1; } } printf(\" %d\", pos); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ char tei[15]={0,1,2,3,4,5,6,7,8,9,5,4,3,2,1},ans[1000][20]; int n,i,to,from,j; scanf(\"%d\",&n); for(i=0;i<n;i++){ scanf(\"%d %d\",&from,&to); if(from<to){ for(j=from;j<to;j++){ printf(\"%d \",j); } printf(\"%d\\n\",to); }else if(to==5){ for(j=from;j<=9;j++){ printf(\"%d \",j); } puts(\"5\"); }else if(from>to){ if(from>=6&&from<=9){ for(j=from;j<=9;j++){ printf(\"%d \",j); } for(j=5;j>to;j--){ printf(\"%d  } } } return 0; }"], "original_ll": -0.8347354531288147, "sampled_ll": -0.5302675366401672, "all_perturbed_sampled_ll": [-1.6159814596176147], "all_perturbed_original_ll": [-1.2931698560714722], "perturbed_sampled_ll": -1.6159814596176147, "perturbed_original_ll": -1.2931698560714722, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nclass Main{\n    public static void main(String[] args){\n\tBufferedReader sc=new BufferedReader(new InputStreamReader(System.in));\n\ttry {\n\t    int n = Integer.valueOf(sc.readLine());\n\t    ArrayList<Integer> road;\n\t    for(int i=0; i<n; i++){\n\t\troad = new ArrayList<Integer>();\n\t\tString[] st = sc.readLine().split(\" \");\n\t\tint in = Integer.valueOf(st[0]), out = Integer.valueOf(st[1]);\n\t\tif(in<=5)\n\t\t    if(in>out)\n\t\t\tfor(int j=in; j>=out; j--)\n\t\t\t    road.add(j);\n\t\t    else\n\t\t\tfor(int j=in; j<=out; j++)\n\t\t\t    road.add(j);\n\t\telse{\n\t\t    if(out>in)\n\t\t\tfor(int j=in; j<=out; j++)\n\t\t\t    road.add(j);\n\t\t    else{\n\t\t\tfor(int j=in; j<=9; j++)\n\t\t\t    road.add(j);\n\t\t\tif(out>=5){\n\t\t\t    for(int j=5; j>=0; j--)\n\t\t\t\troad.add(j);\n\t\t\t    for(int j=1; j<=out; j++)\n\t\t\t\troad.add(j);\n\t\t\t}\n\t\t\telse\n\t\t\t    for(int j=5; j>=out; j--)\n\t\t\t\troad.add(j);\n\t\t    }\n\t\t}\n\t\tfor(int j=0; j<road.size()-1; j++)\n\t\t    System.out.print(road.get(j)+\" \");\n\t\tSystem.out.println(road.get(road.size()-1));\n\t    }\n\t}catch(Exception e){\n\t    System.out.println(\"Error\");\n\t}\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            int start = sc.nextInt();\n            int end = sc.nextInt();\n            \n            List<Integer> path = findPath(start, end);\n            \n            for (int j = 0; j < path.size(); j++) {\n                if (j > 0) System.out.print(\" \");\n                System.out.print(path.get(j));\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n    \n    static List<Integer> findPath(int start, int end) {\n        List<Integer> path = new ArrayList<>();\n        \n        // Calculate distances for both directions\n        int dist1 = distanceClockwise(start, end);\n        int dist2 = distanceCounterClockwise(start, end);\n        \n        if (dist1 <= dist2) {\n            // Go clockwise\n            int current = start;\n            path.add(current);\n            while (current != end) {\n                current = next(current);\n                path.add(current);\n            }\n        } else {\n            // Go counterclockwise\n            int current = start;\n            path.add(current);\n            while (current != end) {\n                current = prev(current);\n                path.add(current);\n            }\n        }\n        \n        return path;\n    }\n    \n    static int distanceClockwise(int start, int end) {\n        int dist = 0;\n        int current = start;\n        while (current != end) {\n            current = next(current);\n            dist++;\n            if (dist > 20) return Integer.MAX_VALUE; // Safety check\n        }\n        return dist;\n    }\n    \n    static int distanceCounterClockwise(int start, int end) {\n        int dist = 0;\n        int current = start;\n        while (current != end) {\n            current = prev(current);\n            dist++;\n            if (dist > 20) return Integer.MAX_VALUE; // Safety check\n        }\n        return dist;\n    }\n    \n    static int next(int pos) {\n        if (pos >= 0 && pos < 5) {\n            return pos + 1;\n        } else if (pos == 5) {\n            return 6;\n        } else if (pos == 6) {\n            return 7;\n        } else if (pos == 7) {\n            return 8;\n        } else if (pos == 8) {\n            return 9;\n        } else if (pos == 9) {\n            return 5;\n        }\n        return -1;\n    }\n    \n    static int prev(int pos) {\n        if (pos >= 1 && pos <= 5) {\n            return pos - 1;\n        } else if (pos == 6) {\n            return 5;\n        } else if (pos == 7) {\n            return 6;\n        } else if (pos == 8) {\n            return 7;\n        } else if (pos == 9) {\n            return 8;\n        } else if (pos == 0) {\n            return -1; // Can't go back from 0\n        }\n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n  = 0; i <  = sc.nextInt(); int  = findPath(start, end); for (int j = 0; j < path.size(); j++) { if (j > 0) System.out.print(\" \"); System.out.print(path.get(j)); } System.out.println(); } sc.close(); } static List<Integer> findPath(int start, int end)  ArrayList<>(); // Calculate distances for both directions int dist1 = distanceClockwise(start, end);  if (dist1 <= dist2)  current = start; path.add(current); while (current != end) { current  else { // Go counterclockwise int current = start; path.add(current);  current = prev(current); path.add(current);  static int distanceClockwise(int  dist = 0;  (current != end) { current = next(current); dist++; if (dist > 20) return  return dist; } static int distanceCounterClockwise(int  dist = 0; int current = start; while (current != end) { current = prev(current); dist++; if (dist > 20) return Integer.MAX_VALUE; // Safety check } return dist; } static int next(int pos) { if (pos >= 0 && pos < 5)  } else if (pos == 5) { return 6; } else if (pos == 6) { return 7; } else  return 8; } else if (pos ==  else if (pos == 9) { return 5; } return -1; } static  (pos  5) { return pos  (pos == 6) { return 5; } else if (pos == 7) { return 6; } else if (pos ==  else if (pos == 9) {  (pos == 0) { return -1; // Can't go back from 0 } return -1; } }"], "perturbed_original": ["import java.io.*; import java.util.*; import  void main(String[] args){ BufferedReader sc=new BufferedReader(new InputStreamReader(System.in)); try  ArrayList<Integer> road; for(int i=0;  ArrayList<Integer>(); String[]   Integer.valueOf(st[1]); if(in<=5) if(in>out) for(int j=in; j>=out; j--) road.add(j); else for(int j=in; j<=out; j++) road.add(j); else{ if(out>in) for(int  for(int j=in; j<=9; j++) road.add(j); if(out>=5){ for(int j=5; j>=0; j--) road.add(j); for(int j=1; j<=out; j++) road.add(j); } else for(int j=5; j>=out; j--) road.add(j); } } for(int j=0; j<road.size()-1; j++) System.out.print(road.get(j)+\" \"); System.out.println(road.get(road.size()-1)); } }catch(Exception e){ System.out.println(\"Error\"); } } }"], "original_ll": -0.7480449676513672, "sampled_ll": -0.3217506408691406, "all_perturbed_sampled_ll": [-1.4710168838500977], "all_perturbed_original_ll": [-1.4753172397613525], "perturbed_sampled_ll": -1.4710168838500977, "perturbed_original_ll": -1.4753172397613525, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for _ in [0]*input():\n  A = \"012345678954321\"\n  A += A\n  a, b = raw_input().split()\n  i1 = A.index(a)\n  i2 = A.index(a,i1+1)\n  i3 = A.index(b,i1)\n  if i2<i3: i1=i2\n  print \" \".join(A[i1:i3+1])", "sampled": "from collections import deque\n\ndef find_path(start, end):\n    # BFS to find shortest path\n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        current, path = queue.popleft()\n        \n        if current == end:\n            return path\n        \n        # Get neighbors based on bus route structure\n        neighbors = []\n        \n        if current == 0:\n            neighbors = [1]\n        elif current == 1:\n            neighbors = [0, 2]\n        elif current == 2:\n            neighbors = [1, 3]\n        elif current == 3:\n            neighbors = [2, 4]\n        elif current == 4:\n            neighbors = [3, 5]\n        elif current == 5:\n            neighbors = [4, 6, 9]\n        elif current == 6:\n            neighbors = [5, 7]\n        elif current == 7:\n            neighbors = [6, 8]\n        elif current == 8:\n            neighbors = [7, 9]\n        elif current == 9:\n            neighbors = [8, 5]\n        \n        for neighbor in neighbors:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, path + [neighbor]))\n    \n    return []\n\nn = int(input())\nfor _ in range(n):\n    start, end = map(int, input().split())\n    path = find_path(start, end)\n    print(' '.join(map(str, path)))\n", "perturbed_sampled": ["from collections import deque def  find shortest path queue = deque([(start, [start])]) visited = {start} while queue: current, path = queue.popleft() if current == end:  structure neighbors = [] if current == 0: neighbors = [1] elif current == 1: neighbors = [0, 2] elif current == 2: neighbors = [1, 3]  = [2,  neighbors = [3,  neighbors = [4, 6, 9] elif current == 6: neighbors = [5, 7] elif current == 7: neighbors = [6, 8]  = [7, 9] elif current == 9: neighbors = [8, 5] for neighbor in neighbors: if   [] n = int(input()) for _ in range(n): start, end = map(int, input().split()) path = find_path(start, end) print(' '.join(map(str, path)))"], "perturbed_original": ["for _ in [0]*input(): A =  b = raw_input().split() i1 = A.index(a) i2 = A.index(a,i1+1) i3 = A.index(b,i1) if i2<i3: i1=i2 print \" \".join(A[i1:i3+1])"], "original_ll": -1.3952627182006836, "sampled_ll": -0.45526358485221863, "all_perturbed_sampled_ll": [-1.4478949308395386], "all_perturbed_original_ll": [-1.8456450700759888], "perturbed_sampled_ll": -1.4478949308395386, "perturbed_original_ll": -1.8456450700759888, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0141:   Spiral Pattern\n// 2017.8.4\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *gets(char *);\nchar buf[100];\n\nchar a[105][105];\n#define U 1\n#define R 2\n#define D 3\n#define L 4\n\nint main()\n{\n\tint r, c, n, d, stop;\n\tint ci, cn;\n\n\tgets(buf);\n\tcn = atoi(buf);\n\tfor (ci = 0; ci < cn; ci++) {\n\t\tgets(buf);\n\t\tn = atoi(buf);\n\t\tmemset(a, ' ', sizeof(a));\n\t\tfor (r = 0; r < n + 4; r += n + 3) {\n\t\t\tfor (c = 0; c < n + 4; c++) a[r][c] = '#';\n\t\t}\n\t\tfor (c = 0; c < n + 4; c += n + 3) {\n\t\t\tfor (r = 0; r < n + 4; r++) a[r][c] = '#';\n\t\t}\n\t\tr = n + 1, c = 2, d = U, stop = 0, a[r][c] = '#';\n\t\twhile (1) {\n\t\t\tif (stop >= 4) break;\n\t\t\tif (d == U) {\n\t\t\t\tif (a[r-2][c] == '#' || a[r-1][c] == '#' || a[r-1][c+1] == '#') d = R, stop++;\n\t\t\t\telse a[--r][c] = '#', stop = 0;\n\t\t\t}\n\t\t\tif (d == R) {\n\t\t\t\tif (a[r][c+2] == '#' || a[r][c+1] == '#' || a[r+1][c+1] == '#') d = D, stop++;\n\t\t\t\telse a[r][++c] = '#', stop = 0;\n\t\t\t}\n\t\t\tif (d == D) {\n\t\t\t\tif (a[r+2][c] == '#' || a[r+1][c] == '#' || a[r+1][c-1] == '#') d = L, stop++;\n\t\t\t\telse a[++r][c] = '#', stop = 0;\n\t\t\t}\n\t\t\tif (d == L){\n\t\t\t\tif (a[r][c-2] == '#' || a[r][c-1] == '#' || a[r-1][c-1] == '#') d = U, stop++;\n\t\t\t\telse a[r][--c] = '#', stop = 0;\n\t\t\t}\n\t\t}\n\t\tif (ci > 0) putchar('\\n');\n\t\tfor (r = 2; r < n + 2; r++) {\n\t\t\ta[r][n + 2] = 0;\n\t\t\tputs(a[r]+2);\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int d, n;\n    scanf(\"%d\", &d);\n    \n    for (int dataset = 0; dataset < d; dataset++) {\n        scanf(\"%d\", &n);\n        \n        char grid[100][100];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = ' ';\n            }\n        }\n        \n        int minRow = 0, maxRow = n - 1;\n        int minCol = 0, maxCol = n - 1;\n        \n        while (minRow <= maxRow && minCol <= maxCol) {\n            // Bottom row (left to right)\n            for (int j = minCol; j <= maxCol; j++) {\n                grid[maxRow][j] = '#';\n            }\n            \n            // Right column (bottom to top)\n            for (int i = maxRow; i >= minRow; i--) {\n                grid[i][maxCol] = '#';\n            }\n            \n            // Top row (right to left)\n            if (minRow < maxRow) {\n                for (int j = maxCol; j >= minCol; j--) {\n                    grid[minRow][j] = '#';\n                }\n            }\n            \n            // Left column (top to bottom)\n            if (minCol < maxCol) {\n                for (int i = minRow; i <= maxRow; i++) {\n                    grid[i][minCol] = '#';\n                }\n            }\n            \n            minRow += 2;\n            maxRow -= 2;\n            minCol += 2;\n            maxCol -= 2;\n        }\n        \n        // Print grid\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                printf(\"%c\", grid[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        \n        if (dataset < d - 1) {\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h>  n; scanf(\"%d\", &d); for (int dataset  dataset++) { scanf(\"%d\", &n); char grid[100][100]; for (int  n; i++) { for (int j = 0; j < n; j++) { grid[i][j] = ' '; } } int minRow = 0, maxRow = n - 1; int minCol = 0, maxCol = n - 1; while (minRow <= maxRow && minCol <= maxCol) { // Bottom row (left to right) for (int j = minCol; j <= maxCol; j++) { grid[maxRow][j] = '#'; } // Right  (int i = maxRow; i >= minRow;  }  maxRow) { for (int j = maxCol; j >=  '#'; } } // Left column (top to bottom) if  (int i = minRow; i <= maxRow; i++) { grid[i][minCol] = '#'; } }  2; minCol += 2;  Print grid for (int i =  { for (int j = 0; j < n; j++) { printf(\"%c\", grid[i][j]); } printf(\"\\n\"); } if (dataset < d - 1)  0; }"], "perturbed_original": ["// Aizu Vol-1 0141: Spiral Pattern // 2017.8.4 #include <stdio.h> #include <stdlib.h> #include <string.h> char *gets(char  #define U 1 #define  #define L  r,  ci, cn; gets(buf); cn = atoi(buf); for (ci = 0; ci < cn; ci++) { gets(buf); n = atoi(buf); memset(a, ' ', sizeof(a)); for (r = 0; r < n + 4; r += n + 3) { for (c = 0; c < n + 4; c++) a[r][c]  = 0; c < n + 4; c += n + 3) { for (r = 0; r < n + 4; r++) a[r][c] = '#'; } r = n + 1, c   break; if (d == U) { if (a[r-2][c] == '#' || a[r-1][c] ==  d = R, stop++; else a[--r][c] = '#', stop = 0; } if (d == R) { if (a[r][c+2] == '#' || a[r][c+1] == '#' || a[r+1][c+1] == '#') d = D, stop++; else a[r][++c] = '#', stop = 0; } if (d == D)  || a[r+1][c] == '#' || a[r+1][c-1] ==  stop = 0;  if (a[r][c-2] ==  || a[r-1][c-1] == '#') d = U, stop++; else a[r][--c] = '#', stop = 0; } } if (ci > 0) putchar('\\n'); for (r = 2; r < n + 2; r++) { a[r][n  }"], "original_ll": -0.6953409910202026, "sampled_ll": -0.323183536529541, "all_perturbed_sampled_ll": [-1.4375598430633545], "all_perturbed_original_ll": [-1.3380299806594849], "perturbed_sampled_ll": -1.4375598430633545, "perturbed_original_ll": -1.3380299806594849, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint D = sc.nextInt();\n\t\tboolean first = true;\n\t\twhile (D-- > 0) {\n\t\t\tif (!first) {\n\t\t\t\tSystem.out.println();\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tchar[][] field = new char[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(field[i], ' ');\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfield[i][0] = '#';\n\t\t\t\tfield[0][i] = '#';\n\t\t\t}\n\t\t\tif (n < 3) {\n\t\t\t\tdebug2(field);\n\t\t\t} else if (n == 3) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfield[i][n - 1] = '#';\n\t\t\t\t}\n\t\t\t\tdebug2(field);\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfield[i][n - 1] = '#';\n\t\t\t\t}\n\t\t\t\tint nowX = n - 1;\n\t\t\t\tint nowY = n - 1;\n\t\t\t\tboolean go = true;\n\t\t\t\twhile (go) {\n\t\t\t\t\tgo = false;\n\t\t\t\t\twhile (nowX - 2 >= 0 && field[nowY - 1][nowX - 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY][nowX - 2] != '#' && field[nowY][nowX-1] != '#') {\n\t\t\t\t\t\tfield[nowY][--nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t\twhile (nowY - 2 >= 0 && field[nowY - 1][nowX + 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY - 2][nowX] != '#' && field[nowY-1][nowX] != '#') {\n\t\t\t\t\t\tfield[--nowY][nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t\twhile (nowX + 2 < n && field[nowY + 1][nowX + 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY][nowX + 2] != '#' ) {\n\t\t\t\t\t\tfield[nowY][++nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t\twhile (nowY + 2 < n && field[nowY + 1][nowX - 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY + 2][nowX] != '#' ) {\n\t\t\t\t\t\tfield[++nowY][nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdebug2(field);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int d = sc.nextInt();\n        \n        for (int dataset = 0; dataset < d; dataset++) {\n            int n = sc.nextInt();\n            char[][] grid = new char[n][n];\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = ' ';\n                }\n            }\n            \n            int row = n - 1;\n            int col = 0;\n            int dir = 0; // 0: right, 1: up, 2: left, 3: down\n            int[] dr = {0, -1, 0, 1};\n            int[] dc = {1, 0, -1, 0};\n            \n            int steps = n;\n            int currentSteps = 0;\n            int dirChanges = 0;\n            boolean placed = false;\n            \n            while (steps > 0) {\n                for (int i = 0; i < steps; i++) {\n                    if (row >= 0 && row < n && col >= 0 && col < n) {\n                        grid[row][col] = '#';\n                    }\n                    if (i < steps - 1) {\n                        row += dr[dir];\n                        col += dc[dir];\n                    }\n                }\n                \n                row += dr[dir];\n                col += dc[dir];\n                \n                dir = (dir + 1) % 4;\n                dirChanges++;\n                \n                if (dirChanges % 2 == 0) {\n                    steps--;\n                }\n            }\n            \n            for (int i = 0; i < n; i++) {\n                System.out.println(new String(grid[i]));\n            }\n            \n            if (dataset < d - 1) {\n                System.out.println();\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  static void main(String[] args) { Scanner sc =  sc.nextInt(); for (int dataset =  sc.nextInt(); char[][] grid = new char[n][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { grid[i][j] = ' '; } } int row = n - 1; int col = 0; int dir  1: up,  dr = {0, -1, 0, 1}; int[] dc = {1, 0, -1, 0}; int steps = n;  dirChanges =  while (steps > 0) { for (int i =  { if (row >= 0 && row < n && col >= 0 && col < n) { grid[row][col] = '#'; } if  { row += dr[dir]; col += dc[dir]; } } row += dr[dir]; col += dc[dir]; dir = (dir + 1) % 4; dirChanges++; if (dirChanges % 2 == 0) { steps--; } } for (int  n; i++) {  < d - 1) {  }"], "perturbed_original": ["import java.util.Arrays;  { MyScanner sc =  new Scanner(System.in); int  = { 1, 0, 0,  { 0, 1, -1, 0 }; void run() { int D = sc.nextInt(); boolean first = true; while (D-- > 0) { if (!first) { System.out.println(); first = false; } int n = sc.nextInt(); char[][] field = new char[n][n]; for (int i = 0; i < n; i++) { Arrays.fill(field[i], ' '); } for (int  '#'; }   == 3) { for  < n;   else { for (int i = 0; i < n; i++) { field[i][n - 1] = '#'; } int nowX = n - 1; int nowY = n - 1; boolean go = true; while (go) { go = false; while (nowX - 2 >= 0 && field[nowY - 1][nowX - 1]  2] != '#' && field[nowY][nowX-1] != '#') { field[nowY][--nowX] = '#'; go = true; } while (nowY -  - 1][nowX + 1] != '#' && field[nowY -  != '#') { field[--nowY][nowX] = '#'; go = true; } while (nowX + 2 < n &&  != '#'  '#' ) { field[nowY][++nowX] = '#'; go = true; } while (nowY + 2 < n  1] != '#' && field[nowY + 2][nowX] != '#' ) { field[++nowY][nowX] = '#'; go = true; } } debug2(field); } } } public  new Main().run(); } void debug(Object... o) { System.out.println(Arrays.deepToString(o)); }  (int i = 0; i < array.length; i++) { for (int j = 0; j < array[i].length; j++) { System.out.print(array[i][j]); } System.out.println(); } } class MyScanner { int nextInt() { try {  (c != '-'  '9' < c)) c = System.in.read(); if (c == '-') return -nextInt(); int res = 0; do { res *= 10; res += c - '0';  ('0' <= c && c <= '9'); return  { return -1; }  Double.parseDouble(next()); } String next() { try { StringBuilder res = new StringBuilder(\"\"); int c = System.in.read();  do { res.append((char) c); } while (!Character.isWhitespace(c = System.in.read()));  e) { return null; } } } }"], "original_ll": -0.43283236026763916, "sampled_ll": -0.5072506070137024, "all_perturbed_sampled_ll": [-1.4874082803726196], "all_perturbed_original_ll": [-1.3781139850616455], "perturbed_sampled_ll": -1.4874082803726196, "perturbed_original_ll": -1.3781139850616455, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def move(self, offset):\n        self.x += offset[0]\n        self.y += offset[1]\n\n    def move_offset(self, offset, multiple=1):\n        x = self.x + offset[0] * multiple\n        y = self.y + offset[1] * multiple\n        return Vector(x, y)\n\n\nclass Pattern:\n    NOTHING = \" \"\n    EXIST = \"#\"\n    SENTINEL = \"?\"\n\n    MOVE = [\n        [[-1, -1], [-1, +0], [-1, +1]],\n        [[-1, +1], [-0, +1], [+1, +1]],\n        [[+1, +1], [+1, +0], [+1, -1]],\n        [[+1, -1], [+0, -1], [-1, -1]],\n    ]\n\n    @classmethod\n    def create_area(cls, size):\n        area = [[cls.SENTINEL] * 2 + [cls.NOTHING] * size + [cls.SENTINEL] * 2 for _ in range(size)]\n        tmp = [[cls.SENTINEL] * size + [cls.SENTINEL] * 2 * 2]\n        area = tmp * 2 + area + tmp * 2\n        return area\n\n    @classmethod\n    def even_spiral_pattern(cls, area, point):\n        move_index = 0\n        area[point.x][point.y] = cls.EXIST\n\n        while True:\n\n            left, center, right = cls.MOVE[move_index]\n            end1, end2 = point.move_offset(left), point.move_offset(right)\n            offset, offset2 = point.move_offset(center), point.move_offset(center, 2)\n\n            if area[end1.x][end1.y] == cls.EXIST or area[end2.x][end2.y] == cls.EXIST:\n                return area\n            elif area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST:\n                point.move(center)\n                area[point.x][point.y] = cls.EXIST\n            else:\n                move_index += 1\n                move_index %= 4\n\n    @classmethod\n    def odd_spiral_pattern(cls, area, point):\n        move_index = 0\n        is_end = False\n        area[point.x][point.y] = cls.EXIST\n\n        while True:\n\n            left, center, right = cls.MOVE[move_index]\n            offset, offset2 = point.move_offset(center), point.move_offset(center, 2)\n\n            if area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST:\n                point.move(center)\n                area[point.x][point.y] = cls.EXIST\n                is_end = False\n            else:\n                if is_end:\n                    return area\n                else:\n                    is_end = True\n\n                move_index += 1\n                move_index %= 4\n\n    @classmethod\n    def formater(cls, area):\n        output = [\"\".join(item[2:-2]) for item in area[2:-2]]\n        output = \"\\n\".join(output)\n        return output\n\n    @classmethod\n    def solve(cls, size):\n        area = cls.create_area(size)\n        point = Vector(size - 1 + 2, 2)\n\n        if size % 2 == 0:\n            result = cls.even_spiral_pattern(area, point)\n        else:\n            result = cls.odd_spiral_pattern(area, point)\n\n        return cls.formater(result)\n\n\nsizes = [int(input()) for _ in range(int(input()))]\nresults = [Pattern.solve(num) for num in sizes]\nprint(\"\\n\\n\".join(results))\n\n", "sampled": "def generate_spiral(n):\n    grid = [[' ' for _ in range(n)] for _ in range(n)]\n    \n    # Start from bottom-left, go clockwise\n    row, col = n - 1, 0\n    dr, dc = 0, 1  # Start moving right\n    \n    visited = set()\n    visited.add((row, col))\n    grid[row][col] = '#'\n    \n    while True:\n        # Try to move in current direction\n        next_row, next_col = row + dr, col + dc\n        \n        # Check if we can continue in current direction\n        can_continue = (0 <= next_row < n and \n                       0 <= next_col < n and \n                       (next_row, next_col) not in visited)\n        \n        if can_continue:\n            row, col = next_row, next_col\n            visited.add((row, col))\n            grid[row][col] = '#'\n        else:\n            # Try to turn clockwise\n            # Clockwise from bottom-left: right(0,1) -> up(-1,0) -> left(0,-1) -> down(1,0)\n            if (dr, dc) == (0, 1):  # right -> up\n                dr, dc = -1, 0\n            elif (dr, dc) == (-1, 0):  # up -> left\n                dr, dc = 0, -1\n            elif (dr, dc) == (0, -1):  # left -> down\n                dr, dc = 1, 0\n            elif (dr, dc) == (1, 0):  # down -> right\n                dr, dc = 0, 1\n            \n            next_row, next_col = row + dr, col + dc\n            \n            # Check if we can move after turning\n            if (0 <= next_row < n and \n                0 <= next_col < n and \n                (next_row, next_col) not in visited):\n                row, col = next_row, next_col\n                visited.add((row, col))\n                grid[row][col] = '#'\n            else:\n                # Can't move anywhere, done\n                break\n    \n    return grid\n\nd = int(input())\nresults = []\n\nfor i in range(d):\n    n = int(input())\n    grid = generate_spiral(n)\n    results.append(grid)\n\nfor i, grid in enumerate(results):\n    for row in grid:\n        print(''.join(row))\n    if i < len(results) - 1:\n        print()\n", "perturbed_sampled": ["def generate_spiral(n):  _ in range(n)]  Start from bottom-left, go clockwise  = 0, 1 # Start moving right visited = set() visited.add((row, col)) grid[row][col] = '#' while True: # Try  next_row, next_col = row + dr, col + dc  continue  (0 <= next_row < n and 0 <= next_col < n and (next_row, next_col) not in visited) if can_continue: row, col = next_row, next_col visited.add((row, col)) grid[row][col] = '#' else: # Try to turn clockwise # Clockwise  -> left(0,-1) -> down(1,0) if (dr, dc) ==  up  (-1, 0): # up -> left dr, dc = 0, -1 elif  # left -> down dr, dc = 1, 0 elif (dr, dc) == (1, 0): # down -> right dr, dc = 0, 1 next_row, next_col = row + dr, col + dc # Check if we can move after turning if (0 <=  <= next_col < n and (next_row, next_col) not in visited):  visited.add((row, col)) grid[row][col] = '#' else: # Can't move anywhere,  = int(input()) results = [] for i in range(d): n = int(input()) grid = generate_spiral(n)  enumerate(results): for row in grid: print(''.join(row)) if i < len(results) - 1: print()"], "perturbed_original": ["class Vector: def __init__(self, x, y): self.x = x self.y = y def move(self, offset): self.x += offset[0] self.y += offset[1] def move_offset(self, offset, multiple=1): x = self.x + offset[0] * multiple y =  return Vector(x, y) class Pattern: NOTHING = \" \" EXIST = \"#\" SENTINEL = \"?\" MOVE = [ [[-1, -1],  +1],  +1], [+1, +0], [+1, -1]], [[+1, -1], [+0, -1], [-1, -1]], ] @classmethod def create_area(cls, size): area = [[cls.SENTINEL] *  + [cls.SENTINEL]  range(size)] tmp   2 + area + tmp * 2 return area @classmethod def even_spiral_pattern(cls, area, point):  cls.EXIST while True: left, center, right  point.move_offset(left), point.move_offset(right) offset, offset2 = point.move_offset(center), point.move_offset(center, 2) if area[end1.x][end1.y] ==  == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST: point.move(center) area[point.x][point.y] =  move_index   is_end = False area[point.x][point.y] = cls.EXIST while True: left, center, right = cls.MOVE[move_index] offset, offset2 = point.move_offset(center), point.move_offset(center, 2) if area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST: point.move(center) area[point.x][point.y] = cls.EXIST is_end = False  else:  1 move_index %= 4 @classmethod def formater(cls, area): output = [\"\".join(item[2:-2]) for item in area[2:-2]] output = \"\\n\".join(output) return output @classmethod def solve(cls, size): area = cls.create_area(size) point = Vector(size - 1 + 2, 2) if size  = cls.even_spiral_pattern(area, point) else: result = cls.odd_spiral_pattern(area, point) return cls.formater(result) sizes = [int(input()) for _ in range(int(input()))] results = [Pattern.solve(num) for num in sizes] print(\"\\n\\n\".join(results))"], "original_ll": -0.7079124450683594, "sampled_ll": -0.5174083113670349, "all_perturbed_sampled_ll": [-1.6572415828704834], "all_perturbed_original_ll": [-1.6490859985351562], "perturbed_sampled_ll": -1.6572415828704834, "perturbed_original_ll": -1.6490859985351562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\nint main(){\n  int exp[10001], n, i, j, mod[10001], a[10001], c, count[6000], h, d;\n\n  for(i = 1; i < 10001; ++i) exp[i] = i * i;\n\n  while(scanf(\"%d\", &n) && n){\n    memset(count , 0, sizeof(count));\n    for(i = 1; i < n; ++i) mod[i] = exp[i] % n;\n    c = 0;\n    for(i = 1; i < n; ++i){\n      for(j = 0; j < c; ++j)\n\tif(mod[i] == a[j]) break;\n      if(j == c) a[c++] = mod[i];\n    }\n    h = (n - 1) / 2;\n    for(i = 0; i < c; ++i){\n      for(j = 0; j < c; ++j){\n\tif(a[i] != a[j]){\n\t  d = a[i] - a[j];\n\t  if(d < 0) d += n;\n\t  if(d > h) d = n - d;\n\t  count[d]++;\n\t}\n      }\n    }\n\n    for(i = 1; i <= h; ++i) printf(\"%d\\n\", count[i]);  \n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int *squares = (int*)malloc(n * sizeof(int));\n        int unique_count = 0;\n        int *unique_squares = (int*)malloc(n * sizeof(int));\n        \n        // Calculate squares mod n\n        for(int i = 1; i < n; i++) {\n            squares[i] = (i * i) % n;\n        }\n        \n        // Find unique squares\n        for(int i = 1; i < n; i++) {\n            int found = 0;\n            for(int j = 0; j < unique_count; j++) {\n                if(unique_squares[j] == squares[i]) {\n                    found = 1;\n                    break;\n                }\n            }\n            if(!found) {\n                unique_squares[unique_count++] = squares[i];\n            }\n        }\n        \n        int max_diff = (n - 1) / 2;\n        int *count = (int*)calloc(max_diff + 1, sizeof(int));\n        \n        // Calculate differences\n        for(int i = 0; i < unique_count; i++) {\n            for(int j = 0; j < unique_count; j++) {\n                if(i != j) {\n                    int a = unique_squares[i];\n                    int b = unique_squares[j];\n                    int diff = a - b;\n                    \n                    // If negative, add n\n                    if(diff < 0) {\n                        diff += n;\n                    }\n                    \n                    // If greater than (n-1)/2, subtract from n\n                    if(diff > max_diff) {\n                        diff = n - diff;\n                    }\n                    \n                    if(diff >= 1 && diff <= max_diff) {\n                        count[diff]++;\n                    }\n                }\n            }\n        }\n        \n        // Output counts\n        for(int i = 1; i <= max_diff; i++) {\n            printf(\"%d\\n\", count[i]);\n        }\n        \n        free(squares);\n        free(unique_squares);\n        free(count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" main() { int  if(n == 0) break; int *squares = (int*)malloc(n * sizeof(int)); int unique_count = 0; int *unique_squares = (int*)malloc(n * sizeof(int)); //  < n; i++) { squares[i] = (i * i) % n; }  i = 1; i < n; i++) { int found = 0; for(int j = 0; j < unique_count; j++) { if(unique_squares[j] == squares[i]) { found = 1; break; } } if(!found) {  int max_diff = (n - 1) / 2; int  sizeof(int)); // Calculate differences for(int i = 0; i < unique_count; i++) { for(int j = 0;  if(i != j) { int a = unique_squares[i]; int  = a - b; // If negative, add n if(diff < 0) { diff += n; }  subtract from n if(diff > max_diff) { diff = n - diff; } if(diff >= 1   // Output counts for(int i = 1;  printf(\"%d\\n\", count[i]); } free(squares); free(unique_squares); free(count); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(){ int exp[10001], n, i, j, mod[10001], a[10001], c, count[6000], h, d; for(i = 1; i  i * i; while(scanf(\"%d\", &n) && n){ memset(count , 0, sizeof(count)); for(i = 1; i < n;  n; c =  < n; ++i){ for(j  ++j) if(mod[i] == a[j]) break; if(j == c) a[c++] = mod[i]; } h = (n - 1) / 2; for(i = 0; i  0;  != a[j]){ d = a[i] - a[j]; if(d < 0) d += n; if(d  - d; count[d]++;  1; i <= h; ++i) printf(\"%d\\n\", count[i]); } return 0; }"], "original_ll": -0.7689151167869568, "sampled_ll": -0.4971469044685364, "all_perturbed_sampled_ll": [-1.5960807800292969], "all_perturbed_original_ll": [-1.738977313041687], "perturbed_sampled_ll": -1.5960807800292969, "perturbed_original_ll": -1.738977313041687, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t\tSystem.out.flush();\n\t}\n\n\tvoid solve(){\n\t\tTreeSet<Integer> set=new TreeSet<Integer>();\n\t\tfor(int i=1; i<n; i++){\n\t\t\tset.add(i*i%n);\n\t\t}\n\t\tint[] c=new int[n];\n\t\tfor(int j : set){\n\t\t\tfor(int i : set){\n\t\t\t\tif(i!=j){\n\t\t\t\t\tint a=i-j;\n\t\t\t\t\tif(a<0){\n\t\t\t\t\t\ta+=n;\n\t\t\t\t\t}\n\t\t\t\t\tif(a>(n-1)/2){\n\t\t\t\t\t\ta=n-a;\n\t\t\t\t\t}\n\t\t\t\t\tc[a]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// debug(set.toArray());\n\t\t// debug(c);\n\t\tfor(int i=1; i<=(n-1)/2; i++){\n\t\t\tprintln(\"\"+c[i]);\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tSystem.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            // Step 1: Calculate squares mod n\n            Set<Integer> squares = new HashSet<>();\n            for (int i = 1; i < n; i++) {\n                int sq = (i * i) % n;\n                squares.add(sq);\n            }\n            \n            // Step 2: Calculate differences between all pairs\n            List<Integer> squareList = new ArrayList<>(squares);\n            int maxDiff = (n - 1) / 2;\n            int[] frequency = new int[maxDiff + 1];\n            \n            for (int i = 0; i < squareList.size(); i++) {\n                for (int j = i + 1; j < squareList.size(); j++) {\n                    int a = squareList.get(i);\n                    int b = squareList.get(j);\n                    \n                    // Calculate difference\n                    int diff = a - b;\n                    \n                    // If negative, add n\n                    if (diff < 0) {\n                        diff += n;\n                    }\n                    \n                    // If greater than (n-1)/2, subtract from n\n                    if (diff > maxDiff) {\n                        diff = n - diff;\n                    }\n                    \n                    frequency[diff]++;\n                }\n            }\n            \n            // Step 3: Output frequencies for 1 to (n-1)/2\n            for (int i = 1; i <= maxDiff; i++) {\n                System.out.println(frequency[i]);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0)  squares mod n Set<Integer> squares = new HashSet<>(); for (int i = 1; i < n; i++) { int sq = (i * i) % n; squares.add(sq); } // Step 2: Calculate differences between all pairs List<Integer> squareList = new ArrayList<>(squares); int maxDiff = (n - 1) / 2; int[] frequency = new int[maxDiff + 1]; for (int i =  {  + 1; j  b = squareList.get(j); // Calculate difference int diff = a  add  { diff += n; } // If greater than (n-1)/2, subtract from n if (diff > maxDiff) { diff = n - diff; }  3: Output frequencies for 1 to (n-1)/2 for (int i = 1; i <= maxDiff; i++) { System.out.println(frequency[i]); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.lang.*; import  java.lang.Math.*; import static java.util.Arrays.*; public class  n; void run(){ for(;;){ n=sc.nextInt(); if(n==0){ break;  void solve(){ TreeSet<Integer> set=new TreeSet<Integer>(); for(int  int[] c=new int[n]; for(int j : set){ for(int i : set){ if(i!=j){ int a=i-j; if(a<0){ a+=n; } if(a>(n-1)/2){ a=n-a; } c[a]++; } } } // debug(set.toArray()); // debug(c); for(int i=1; i<=(n-1)/2; i++){ println(\"\"+c[i]); } } void debug(Object... os){ System.err.println(Arrays.deepToString(os)); } void print(String s){ System.out.print(s); } void println(String s){  main(String[] args){ System.setOut(new PrintStream(new BufferedOutputStream(System.out))); new Main().run(); } }"], "original_ll": -0.901170015335083, "sampled_ll": -0.574683666229248, "all_perturbed_sampled_ll": [-1.7311118841171265], "all_perturbed_original_ll": [-1.9027048349380493], "perturbed_sampled_ll": -1.7311118841171265, "perturbed_original_ll": -1.9027048349380493, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import itertools\n\nr = 10001\ns = int(r**0.5)\np = [1]*r\np[0] = 0\nfor i in range(1,s):\n\tif p[i]:\n\t\tp[2*i + 1::i + 1] = [0 for x in range(2*i + 1, r, i + 1)]\n\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\tm = (n - 1) / 2\n\ta = sorted(list(set([i**2%n for i in range(1,n)])))\n\tl = len(a)\n\tif n%4 == 3 and p[n - 1] == 1:\n\t\tll = l*(l - 1) / m\n\t\tfor i in range(m):\n\t\t\tprint ll\n\t\tcontinue\n\th = [0]*(m+1)\n\tfor i,j in itertools.combinations(a,2):\n\t\td = j - i\n\t\th[min(d,n - d)] += 2\n\tfor i in range(1,m+1):\n\t\tprint h[i]", "sampled": "def solve(n):\n    # Calculate squares mod n\n    squares = set()\n    for i in range(1, n):\n        squares.add((i * i) % n)\n    \n    squares = list(squares)\n    \n    # Calculate differences\n    max_diff = (n - 1) // 2\n    diff_count = [0] * (max_diff + 1)\n    \n    for i in range(len(squares)):\n        for j in range(i + 1, len(squares)):\n            a = squares[i]\n            b = squares[j]\n            \n            # Calculate difference\n            diff = a - b\n            if diff < 0:\n                diff += n\n            if diff > max_diff:\n                diff = n - diff\n            \n            diff_count[diff] += 1\n    \n    # Output frequencies for 1 to max_diff\n    for i in range(1, max_diff + 1):\n        print(diff_count[i])\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    solve(n)\n", "perturbed_sampled": ["def solve(n): # Calculate squares mod n  in range(1, n): squares.add((i * i) % n) squares = list(squares)  (n - 1) // 2 diff_count  1) for i in range(len(squares)): for j in range(i + 1, len(squares)): a  #  - b if diff < 0: diff += n if diff > max_diff: diff = n - diff diff_count[diff] += 1 # Output frequencies for 1 to max_diff for i in range(1, max_diff + 1): print(diff_count[i]) while True: n  0: break solve(n)"], "perturbed_original": ["import itertools r = 10001 s = int(r**0.5) p = [1]*r p[0] = 0 for i in range(1,s): if p[i]: p[2*i + 1::i  1, r, i + 1)] while 1:  == 0: break m = (n - 1) / 2 a = sorted(list(set([i**2%n for i in range(1,n)]))) l =  and p[n - 1] == 1:  / m for i in range(m): print ll continue h  itertools.combinations(a,2): d = j - i h[min(d,n - d)] += 2 for i in range(1,m+1): print h[i]"], "original_ll": -1.3470165729522705, "sampled_ll": -0.7597257494926453, "all_perturbed_sampled_ll": [-2.060255289077759], "all_perturbed_original_ll": [-2.371211051940918], "perturbed_sampled_ll": -2.060255289077759, "perturbed_original_ll": -2.371211051940918, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-2 0143   Altair and Vega\n// 2017.8.8\n\n#include <stdio.h>\n\nint atSameSide(int x1, int y1, int x2, int y2, int xa, int ya, int xb, int yb)\n{\n\tint sa, sb;\n\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n//\tif (sb == 0) return 0;  \t\t // xb,yb in line\n\treturn (sa * sb >= 0);           // xa,ya xb,yb at same side\n}\n\nint main()\n{\n\tint n;\n\tint x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\tint kin, sin;\n\n\tscanf(\"%d\", &n);\n\twhile (n-- > 0) {\n\t\tscanf(\"%d%d%d%d%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3, &xk, &yk, &xs, &ys);\n\t\tkin = atSameSide(x1, y1, x2, y2, x3, y3, xk, yk) &&\n\t\t\t  atSameSide(x2, y2, x3, y3, x1, y1, xk, yk) &&\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xk, yk);\n\t\tsin = atSameSide(x1, y1, x2, y2, x3, y3, xs, ys) &&\n\t\t  \t  atSameSide(x2, y2, x3, y3, x1, y1, xs, ys) &&\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xs, ys);\n\t\tputs(kin ^ sin ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint sign(double x) {\n    if (x > 0) return 1;\n    if (x < 0) return -1;\n    return 0;\n}\n\ndouble cross_product(double x1, double y1, double x2, double y2, double x3, double y3) {\n    return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n}\n\nint point_in_triangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {\n    double d1 = cross_product(x1, y1, x2, y2, px, py);\n    double d2 = cross_product(x2, y2, x3, y3, px, py);\n    double d3 = cross_product(x3, y3, x1, y1, px, py);\n    \n    int s1 = sign(d1);\n    int s2 = sign(d2);\n    int s3 = sign(d3);\n    \n    int has_neg = (s1 < 0) || (s2 < 0) || (s3 < 0);\n    int has_pos = (s1 > 0) || (s2 > 0) || (s3 > 0);\n    \n    return !(has_neg && has_pos);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        double xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\",\n              &xp1, &yp1, &xp2, &yp2, &xp3, &yp3, &xk, &yk, &xs, &ys);\n        \n        int k_inside = point_in_triangle(xk, yk, xp1, yp1, xp2, yp2, xp3, yp3);\n        int s_inside = point_in_triangle(xs, ys, xp1, yp1, xp2, yp2, xp3, yp3);\n        \n        if (k_inside != s_inside) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" 0)  0) return -1; return 0; } double cross_product(double x1, double y1, double x2, double y2, double x3, double y3) { return (x2 - x1) * (y3 - y1) - (y2 - y1)  int point_in_triangle(double px, double py, double x1, double y1, double x2, double y2, double x3,  = cross_product(x1, y1, x2, y2, px, py); double d2 = cross_product(x2, y2, x3, y3, px, py); double d3 = cross_product(x3, y3, x1, y1, px, py); int s1 = sign(d1); int s2 = sign(d2); int s3 = sign(d3); int has_neg = (s1 < 0)  (s3 < 0); int has_pos = (s1 > 0) || (s2 > 0) || (s3 > 0); return !(has_neg &&  int n; scanf(\"%d\", &n); for  < n; i++) { double xp1, yp1, xp2,  xs, ys; scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\", &xp1, &yp1, &xp2, &yp2, &xp3, &yp3, &xk,  = point_in_triangle(xk, yk, xp1, yp1, xp2, yp2, xp3, yp3);   yp3); if (k_inside != s_inside)  printf(\"NG\\n\"); } } return 0; }"], "perturbed_original": ["//  Vega // 2017.8.8 #include <stdio.h> int atSameSide(int x1, int y1, int x2, int y2, int xa, int ya, int xb, int yb) { int sa, sb; sa = (x2 - x1) * (ya - y1) +  - xa); sb = (x2  y1) + (y2  xb); // if (sb == 0) return 0; // xb,yb in line return (sa * sb >= 0); // xa,ya xb,yb at same side } int main() { int n; int x1, y1, x2, y2, x3, y3, xk, yk, xs, ys; int kin, sin; scanf(\"%d\", &n); while (n-- > 0) { scanf(\"%d%d%d%d%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3, &xk, &yk, &xs,  xk, yk)  x1, y1,  x1, y1, x2, y2, xk, yk); sin = atSameSide(x1, y1, x2, y2, x3, y3, xs, ys)  x1, y1, xs, ys) && atSameSide(x3, y3, x1,  puts(kin ^ sin  return 0; }"], "original_ll": -0.8120945692062378, "sampled_ll": -0.3405817747116089, "all_perturbed_sampled_ll": [-0.9845657348632812], "all_perturbed_original_ll": [-1.4685781002044678], "perturbed_sampled_ll": -0.9845657348632812, "perturbed_original_ll": -1.4685781002044678, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tint n = in.nextInt();\n\t\tfor(int i=0;i<n;i++)new AOJ0143().doIt();\n\t\t\n\t}\n\tclass AOJ0143{\n\t\tvoid doIt(){\n\t\t\tPoint2D ps[] = new Point2D[3];\n\t\t\tfor(int i=0;i<3;i++)ps[i] = new Point2D.Double(in.nextInt(),in.nextInt());;\n\t\t\tPoint2D a = new Point2D.Double(in.nextInt(),in.nextInt());\n\t\t\tPoint2D b = new Point2D.Double(in.nextInt(),in.nextInt());\n\t\t\tint c = contains(ps, a);\n\t\t\tint d = contains(ps, b);\n//\t\t\tSystem.out.println(c+\" \"+d);\n\t\t\tif(c==d)System.out.println(\"NG\");\n\t\t\telse System.out.println(\"OK\");\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tdouble cross(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getY()-p1.getY()*p2.getX();\n\t\t}\n\t\tdouble dot(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getX()+p1.getY()*p2.getY();\n\t\t}\n\t\tprivate int contains(Point2D[] plist,Point2D p) {\n\t\t\tboolean isin = false;\n\t\t\tint n = plist.length;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint2D a = sub(plist[i], p);\n\t\t\t\tPoint2D b = sub(plist[(i+1) % n], p);\n\t\t\t\tif(a.getY() > b.getY()){\n\t\t\t\t\tPoint2D temp = (Point2D) a.clone();\n\t\t\t\t\ta = b;\n\t\t\t\t\tb = temp;\n\t\t\t\t}\n\t\t\t\tif(a.getY() <= 0 && 0 < b.getY()){\n\t\t\t\t\tif(cross(a,b) < 0) isin = ! isin;\n\t\t\t\t}\n\t\t\t\tif(cross(a,b) == 0 && dot(a, b) <= 0) return 0;\n\t\t\t}\n\t\t\treturn isin ? 1 : -1;\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double xp1 = sc.nextDouble();\n            double yp1 = sc.nextDouble();\n            double xp2 = sc.nextDouble();\n            double yp2 = sc.nextDouble();\n            double xp3 = sc.nextDouble();\n            double yp3 = sc.nextDouble();\n            double xk = sc.nextDouble();\n            double yk = sc.nextDouble();\n            double xs = sc.nextDouble();\n            double ys = sc.nextDouble();\n            \n            boolean kInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xk, yk);\n            boolean sInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xs, ys);\n            \n            if (kInside != sInside) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NG\");\n            }\n        }\n        sc.close();\n    }\n    \n    static boolean isInside(double x1, double y1, double x2, double y2, double x3, double y3, double px, double py) {\n        double sign1 = sign(px, py, x1, y1, x2, y2);\n        double sign2 = sign(px, py, x2, y2, x3, y3);\n        double sign3 = sign(px, py, x3, y3, x1, y1);\n        \n        boolean hasNeg = (sign1 < 0) || (sign2 < 0) || (sign3 < 0);\n        boolean hasPos = (sign1 > 0) || (sign2 > 0) || (sign3 > 0);\n        \n        return !(hasNeg && hasPos);\n    }\n    \n    static double sign(double px, double py, double x1, double y1, double x2, double y2) {\n        return (px - x2) * (y1 - y2) - (x1 - x2) * (py - y2);\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  static void main(String[] args) { Scanner sc = new  i++) { double xp1 = sc.nextDouble(); double yp1 = sc.nextDouble(); double  = sc.nextDouble(); double xp3 = sc.nextDouble(); double yp3 = sc.nextDouble(); double xk = sc.nextDouble(); double yk = sc.nextDouble(); double xs = sc.nextDouble(); double ys = sc.nextDouble(); boolean kInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xk, yk); boolean sInside  xp3, yp3, xs, ys); if (kInside !=  sc.close(); } static boolean isInside(double x1, double y1, double x2, double y2, double x3, double y3, double px, double py) { double sign1 = sign(px, py, x1, y1, x2, y2); double sign2 = sign(px, py, x2, y2, x3, y3); double sign3 = sign(px, py, x3, y3, x1, y1); boolean  || (sign2 < 0) || (sign3 <  > 0) || (sign2 > 0) || (sign3 > 0); return !(hasNeg && hasPos); } static double sign(double px,  y1, double x2, double y2)  * (y1 - y2) - (x1  y2); } }"], "perturbed_original": ["import java.awt.geom.Point2D;  { Scanner in = new Scanner(System.in); public static void main(String[] args) { new Main(); } public Main() { int n = in.nextInt(); for(int i=0;i<n;i++)new AOJ0143().doIt(); } class AOJ0143{ void doIt(){ Point2D ps[] = new Point2D[3]; for(int i=0;i<3;i++)ps[i] = new Point2D.Double(in.nextInt(),in.nextInt());; Point2D  b = new Point2D.Double(in.nextInt(),in.nextInt()); int c = contains(ps, a); int d = contains(ps, b); // System.out.println(c+\" \"+d); if(c==d)System.out.println(\"NG\"); else System.out.println(\"OK\"); } Point2D sub(Point2D p1,Point2D p2){ return new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY()); } double cross(Point2D p1,Point2D p2){ return p1.getX()*p2.getY()-p1.getY()*p2.getX();  int contains(Point2D[] plist,Point2D p) { boolean isin = false; int n = plist.length; for(int i=0;i<n;i++){  Point2D b = sub(plist[(i+1)  b.getY()){ Point2D temp  b; b = temp; } if(a.getY() <= 0 && 0 <  = ! isin; } if(cross(a,b) == 0 && dot(a, b) <=  isin ?  }"], "original_ll": -0.6758890151977539, "sampled_ll": -0.3457350730895996, "all_perturbed_sampled_ll": [-1.0692689418792725], "all_perturbed_original_ll": [-1.475561261177063], "perturbed_sampled_ll": -1.0692689418792725, "perturbed_original_ll": -1.475561261177063, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    @staticmethod\n    def cross_product(point1, point2):\n        return point1.x * point2.y - point1.y * point2.x\n\n\nclass Triangle:\n    def __init__(self, x1, y1, x2, y2, x3, y3):\n        self.point1 = Vector(x1, y1)\n        self.point2 = Vector(x2, y2)\n        self.point3 = Vector(x3, y3)\n\n    def is_contain(self, point):\n        line1 = point - self.point1\n        line2 = self.point2 - self.point1\n        direct1 = Vector.cross_product(line1, line2)\n\n        line1 = point - self.point2\n        line2 = self.point3 - self.point2\n        direct2 = Vector.cross_product(line1, line2)\n\n        line1 = point - self.point3\n        line2 = self.point1 - self.point3\n        direct3 = Vector.cross_product(line1, line2)\n\n        if 0 < direct1 and 0 < direct2 and 0 < direct3:\n            return 1\n        elif direct1 < 0 and direct2 < 0 and direct3 < 0:\n            return 1\n        else:\n            return -1\n\n\nfor _ in range(int(input())):\n    data = [int(item) for item in input().split(\" \")]\n\n    triangle = Triangle(data[0], data[1], data[2], data[3], data[4], data[5])\n    altair_point = Vector(data[6], data[7])\n    vega_point = Vector(data[8], data[9])\n\n    is_contain1 = triangle.is_contain(altair_point)\n    is_contain2 = triangle.is_contain(vega_point)\n    result = is_contain1 * is_contain2\n\n    if result == -1:\n        print(\"OK\")\n    else:\n        print(\"NG\")\n\n", "sampled": "def sign(p1, p2, p3):\n    return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n\ndef point_in_triangle(pt, v1, v2, v3):\n    d1 = sign(pt, v1, v2)\n    d2 = sign(pt, v2, v3)\n    d3 = sign(pt, v3, v1)\n    \n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    \n    return not (has_neg and has_pos)\n\nn = int(input())\nfor _ in range(n):\n    coords = list(map(int, input().split()))\n    p1 = (coords[0], coords[1])\n    p2 = (coords[2], coords[3])\n    p3 = (coords[4], coords[5])\n    k = (coords[6], coords[7])\n    s = (coords[8], coords[9])\n    \n    k_inside = point_in_triangle(k, p1, p2, p3)\n    s_inside = point_in_triangle(s, p1, p2, p3)\n    \n    if (k_inside and not s_inside) or (not k_inside and s_inside):\n        print(\"OK\")\n    else:\n        print(\"NG\")\n", "perturbed_sampled": ["def sign(p1, p2,  - (p2[0]  v2, v3): d1 = sign(pt, v1, v2) d2 = sign(pt, v2, v3) d3 = sign(pt, v3, v1) has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0) has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0) return not (has_neg and has_pos) n = int(input()) for _ in range(n): coords = list(map(int, input().split()))  = (coords[2], coords[3]) p3 = (coords[4], coords[5]) k = (coords[6], coords[7])  = point_in_triangle(k, p1, p2, p3) s_inside = point_in_triangle(s, p1, p2, p3) if (k_inside and not  s_inside): print(\"OK\") else: print(\"NG\")"], "perturbed_original": ["class Vector:  = x self.y = y def __sub__(self,  self.y - other.y) @staticmethod def cross_product(point1, point2): return point1.x * point2.y - point1.y * point2.x class   = Vector(x2, y2) self.point3 = Vector(x3, y3) def is_contain(self, point): line1  = self.point2 - self.point1 direct1 = Vector.cross_product(line1, line2) line1 = point - self.point2 line2 = self.point3 - self.point2 direct2 = Vector.cross_product(line1, line2) line1 = point  Vector.cross_product(line1, line2) if 0 < direct1 and 0 < direct2 and 0 < direct3: return 1 elif direct1 < 0 and direct2 < 0 and direct3 < 0: return 1 else:  range(int(input())): data = [int(item) for item in input().split(\" \")] triangle = Triangle(data[0], data[1], data[2], data[3], data[4], data[5]) altair_point = Vector(data[6], data[7])  = triangle.is_contain(altair_point) is_contain2 = triangle.is_contain(vega_point) result = is_contain1 * is_contain2 if result == -1: print(\"OK\") else: print(\"NG\")"], "original_ll": -0.5240759253501892, "sampled_ll": -0.3540908098220825, "all_perturbed_sampled_ll": [-1.1970881223678589], "all_perturbed_original_ll": [-1.4818741083145142], "perturbed_sampled_ll": -1.1970881223678589, "perturbed_original_ll": -1.4818741083145142, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint r[100][100];\nint n;\n\nint dijkstra(int start, int goal) {\n  int i;\n  int minimum, p;\n  int d[100], f[100];\n\n  for(i = 0; i < 100; i++) {\n    d[i] = 100000;\n    f[i] = 0;\n  }\n  d[start-1] = 1;\n  while(1) {\n    minimum = 100000;\n    for(i = 0; i < n; i++) {\n      if(d[i] < minimum && f[i] == 0) {\n\tminimum = d[i];\n\tp = i;\n      }\n    }\n    if(minimum == 100000) break;\n    f[p] = 1;\n\n    for(i = 0; i < n; i++) {\n      if(d[p] + r[p][i] < d[i]) {\n\td[i] = d[p] + r[p][i];\n      }\n    }\n  }\n\n  return d[goal-1];\n}\n\nint main() {\n  int i, j, r1, k1, p, s1, d1, v1, temp;\n\n  for(i = 0; i < 100; i++)\n    for(j = 0; j < 100; j++)\n      r[i][j] = 100000;\n\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; i++) {\n    scanf(\"%d %d\", &r1, &k1);\n    for(j = 0; j < k1; j++) {\n      scanf(\"%d\", &temp);\n      r[r1-1][temp-1] = 1;\n    }\n  }\n  scanf(\"%d\", &p);\n  for(i = 0; i < p; i++) {\n    scanf(\"%d %d %d\", &s1, &d1, &v1);\n    temp = dijkstra(s1, d1);\n    if(v1 - temp < 0) {\n      printf(\"NA\\n\");\n    } else {\n      printf(\"%d\\n\", temp);\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 101\n#define INF INT_MAX\n\nint adj[MAX_N][MAX_N];\nint adjCount[MAX_N];\nint dist[MAX_N];\nint visited[MAX_N];\n\nint bfs(int start, int end, int n) {\n    int queue[MAX_N * MAX_N];\n    int front = 0, rear = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    \n    queue[rear++] = start;\n    dist[start] = 1;\n    visited[start] = 1;\n    \n    while (front < rear) {\n        int u = queue[front++];\n        \n        if (u == end) {\n            return dist[end];\n        }\n        \n        for (int i = 0; i < adjCount[u]; i++) {\n            int v = adj[u][i];\n            if (!visited[v]) {\n                visited[v] = 1;\n                dist[v] = dist[u] + 1;\n                queue[rear++] = v;\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i <= n; i++) {\n        adjCount[i] = 0;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        int r, k;\n        scanf(\"%d %d\", &r, &k);\n        adjCount[r] = k;\n        for (int j = 0; j < k; j++) {\n            scanf(\"%d\", &adj[r][j]);\n        }\n    }\n    \n    int p;\n    scanf(\"%d\", &p);\n    \n    for (int i = 0; i < p; i++) {\n        int s, d, v;\n        scanf(\"%d %d %d\", &s, &d, &v);\n        \n        int minDist = bfs(s, d, n);\n        \n        if (minDist == -1) {\n            printf(\"NA\\n\");\n        } else {\n            int hops = minDist - 1;\n            if (v >= hops) {\n                printf(\"%d\\n\", minDist);\n            } else {\n                printf(\"NA\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  MAX_N 101 #define INF INT_MAX int adj[MAX_N][MAX_N]; int adjCount[MAX_N]; int dist[MAX_N]; int visited[MAX_N]; int bfs(int start, int end, int n) { int queue[MAX_N * MAX_N]; int front = 0, rear  = 1; i <= n; i++) { dist[i] = INF; visited[i] = 0; } queue[rear++] =  = 1;  if (u == end) { return dist[end]; } for (int i = 0; i < adjCount[u]; i++) {  1; dist[v] = dist[u] + 1; queue[rear++] = v; } } } return -1; } int main() { int n; scanf(\"%d\",  1; i <= n; i++) { adjCount[i] = 0; } for (int i = 0; i < n; i++) { int  &k); adjCount[r] = k; for (int j = 0; j < k; j++) { scanf(\"%d\", &adj[r][j]); } } int p; scanf(\"%d\", &p); for (int i = 0; i < p; i++) { int s,  &s, &d, &v); int  if (minDist == -1) { printf(\"NA\\n\"); } else { int  if (v >= hops) { printf(\"%d\\n\", minDist); } else  return 0; }"], "perturbed_original": ["#include <stdio.h> int r[100][100]; int  goal) { int i; int minimum, p; int d[100], f[100];  100; i++) { d[i] = 100000;  = 1; while(1) { minimum = 100000; for(i = 0; i < n; i++) { if(d[i] < minimum && f[i] == 0) { minimum =  } if(minimum == 100000) break; f[p] = 1; for(i = 0; i < n; i++) { if(d[p] + r[p][i] < d[i]) { d[i] = d[p] + r[p][i]; } } } return d[goal-1]; } int main()  k1, p, s1, d1, v1, temp; for(i =   100000; scanf(\"%d\", &n); for(i = 0; i < n; i++) { scanf(\"%d %d\", &r1, &k1); for(j =  { scanf(\"%d\", &temp); r[r1-1][temp-1] = 1; } } scanf(\"%d\", &p); for(i = 0; i < p; i++) { scanf(\"%d %d %d\", &s1, &d1, &v1); temp  temp < 0) { printf(\"NA\\n\"); } else { printf(\"%d\\n\",  }"], "original_ll": -0.5074681639671326, "sampled_ll": -0.4202021360397339, "all_perturbed_sampled_ll": [-1.351972222328186], "all_perturbed_original_ll": [-1.2581442594528198], "perturbed_sampled_ll": -1.351972222328186, "perturbed_original_ll": -1.2581442594528198, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = in.readLine();\n\t\n\t\tint size = Integer.parseInt(line);\n\t\tNode[] nodes = new Node[size];\n\t\tfor(int i=0; i<size; i++){\n\t\t\tline = in.readLine();\n\t\t\tString[] tmp = line.split(\" \");\n\t\t\tint id = Integer.parseInt(tmp[0])-1;\n\t\t\tnodes[id] = new Node();\n\t\t\tint n_to = Integer.parseInt(tmp[1]);\n\t\t\tfor(int j=2; j<2+n_to; j++){\n\t\t\t\tint to = Integer.parseInt(tmp[j])-1;\n\t\t\t\tnodes[id].add_edge(to, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tline = in.readLine();\n\t\tsize = Integer.parseInt(line);\n\t\tfor(int i=0; i<size; i++){\n\t\t\tNode[] clone = deepClone(nodes);\n\t\t\tline = in.readLine();\n\t\t\tString[] tmp = line.split(\" \");\n\t\t\tint s = Integer.parseInt(tmp[0])-1;\n\t\t\tint g = Integer.parseInt(tmp[1])-1;\n\t\t\tint ttl = Integer.parseInt(tmp[2]);\n\t\t\tint total = calcCost(clone, s, g);\n\t\t\tif(ttl >= total && total != -1){\n\t\t\t\tSystem.out.println(total);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int calcCost(Node[] nodes, int s, int g){\n\t\tList<Node> que = new ArrayList<Node>();\n\t\tnodes[s].cost = 1;\n\t\tque.add(nodes[s]);\n\t\tNode done = null;\n\t\twhile(que.size()!=0){\n\t\t\tdone = que.get(0);\n\t\t\tque.remove(0);\n\t\t\tdone.visited = true;\n\t\t\tfor(int i=0; i<done.edge_to.size(); i++){\n\t\t\t\tint cost = done.cost + done.edge_cost.get(i);\n\t\t\t\tint to = done.edge_to.get(i);\n\t\t\t\tif(nodes[to].cost < 0 || cost < nodes[to].cost){\n\t\t\t\t\tnodes[to].cost = cost;\n\t\t\t\t\tif(!que.contains(nodes[to])){\n\t\t\t\t\t\tque.add(nodes[to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nodes[g].cost;\n\t}\n\t\n\tpublic Node[] deepClone(Node[] nodes){\n\t\tint m = nodes.length;\n\t\tNode[] clone = new Node[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tclone[i] = new Node(nodes[i]);\n\t\t}\n\t\treturn clone;\n\t}\n}\n\nclass Node{\n\tint cost;\n\tboolean visited;\n\tList<Integer> edge_to;\n\tList<Integer> edge_cost;\n\t\n\tpublic Node(){\n\t\tthis.cost = -1;\n\t\tthis.visited = false;\n\t\tthis.edge_cost = new ArrayList<Integer>();\n\t\tthis.edge_to = new ArrayList<Integer>();\n\t}\n\t\n\tpublic Node(Node n){\n\t\tthis.cost = n.cost;\n\t\tthis.visited = n.visited;\n\t\tthis.edge_to = new ArrayList<Integer>(n.edge_to);\n\t\tthis.edge_cost = new ArrayList<Integer>(n.edge_cost);\n\t}\n\t\n\tpublic void add_edge(int to, int cost){\n\t\tthis.edge_cost.add(cost);\n\t\tthis.edge_to.add(to);\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Router {\n        int id;\n        List<Integer> connections;\n        \n        Router(int id) {\n            this.id = id;\n            this.connections = new ArrayList<>();\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        Map<Integer, Router> routers = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            int routerId = sc.nextInt();\n            Router router = new Router(routerId);\n            int k = sc.nextInt();\n            for (int j = 0; j < k; j++) {\n                router.connections.add(sc.nextInt());\n            }\n            routers.put(routerId, router);\n        }\n        \n        int p = sc.nextInt();\n        for (int i = 0; i < p; i++) {\n            int source = sc.nextInt();\n            int dest = sc.nextInt();\n            int ttl = sc.nextInt();\n            \n            int minHops = bfs(routers, source, dest);\n            \n            if (minHops == -1 || ttl < minHops - 1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(minHops);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static int bfs(Map<Integer, Router> routers, int source, int dest) {\n        Queue<Integer> queue = new LinkedList<>();\n        Map<Integer, Integer> distance = new HashMap<>();\n        \n        queue.offer(source);\n        distance.put(source, 1);\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            int currentDist = distance.get(current);\n            \n            if (current == dest) {\n                return currentDist;\n            }\n            \n            Router router = routers.get(current);\n            if (router != null) {\n                for (int next : router.connections) {\n                    if (!distance.containsKey(next)) {\n                        distance.put(next, currentDist + 1);\n                        queue.offer(next);\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Router { int id;  this.id = id; this.connections = new ArrayList<>();  main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); Map<Integer, Router> routers = new HashMap<>(); for (int i = 0; i < n; i++) {  router = new Router(routerId); int k  k; j++) { router.connections.add(sc.nextInt()); } routers.put(routerId,  sc.nextInt(); for (int i =  sc.nextInt(); int dest = sc.nextInt(); int ttl = sc.nextInt(); int minHops = bfs(routers, source,  || ttl < minHops - 1) { System.out.println(\"NA\"); } else { System.out.println(minHops); } } sc.close(); } static int bfs(Map<Integer, Router>  { Queue<Integer> queue  distance = new HashMap<>(); queue.offer(source); distance.put(source, 1); while (!queue.isEmpty()) { int current = queue.poll(); int currentDist = distance.get(current); if (current ==  Router router = routers.get(current); if (router != null) { for (int next : router.connections) { if (!distance.containsKey(next)) { distance.put(next, currentDist + 1); queue.offer(next); } } } } return -1; } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static void main(String  e){  throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String line = in.readLine(); int size = Integer.parseInt(line); Node[] nodes = new Node[size]; for(int i=0;  String[] tmp =  Integer.parseInt(tmp[0])-1; nodes[id]  j<2+n_to; j++){ int to = Integer.parseInt(tmp[j])-1; nodes[id].add_edge(to, 1); } } line = in.readLine(); size  i++){ Node[] clone = deepClone(nodes); line = in.readLine(); String[] tmp = line.split(\" \"); int s = Integer.parseInt(tmp[0])-1; int g = Integer.parseInt(tmp[1])-1; int ttl =  s, g); if(ttl >= total && total != -1){ System.out.println(total); }else{ System.out.println(\"NA\"); } } } public int calcCost(Node[] nodes, int s, int g){ List<Node> que  1; que.add(nodes[s]); Node done = null; while(que.size()!=0){  = done.cost + done.edge_cost.get(i); int to = done.edge_to.get(i); if(nodes[to].cost < 0 || cost < nodes[to].cost){ nodes[to].cost = cost; if(!que.contains(nodes[to])){ que.add(nodes[to]); } } } } return nodes[g].cost; } public Node[] deepClone(Node[] nodes){ int m = nodes.length; Node[] clone = new Node[m]; for(int i=0; i<m; i++){ clone[i] = new Node(nodes[i]); } return clone; } } class Node{ int cost; boolean visited; List<Integer> edge_to; List<Integer> edge_cost; public Node(){ this.cost = -1; this.visited = false; this.edge_cost  new ArrayList<Integer>(); } public Node(Node n){   } public void add_edge(int to, int cost){ this.edge_cost.add(cost); this.edge_to.add(to); } }"], "original_ll": -0.5446224808692932, "sampled_ll": -0.39422762393951416, "all_perturbed_sampled_ll": [-1.395924687385559], "all_perturbed_original_ll": [-1.4998301267623901], "perturbed_sampled_ll": -1.395924687385559, "perturbed_original_ll": -1.4998301267623901, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def solve(A):\n  s,d,v = A\n  C = [-1 for _ in [0]*(n+1)]\n  c = 1\n  C[s] = c\n  SP = M[s]\n  while 1:\n    if SP==[]: return \"NA\"\n    c += 1\n    X = []\n    for p in SP:\n      if C[p]>0: continue\n      C[p] = c\n      X += [e for e in M[p] if C[e]<0 and e not in SP]\n      if p==d: return [C[d],\"NA\"][C[p]>v]\n    SP = X\n\nn = int(raw_input())\nM = {}\n\nfor _ in [0]*n:\n  x = map(int, raw_input().split())\n  M[x[0]] = x[2:]\nfor _ in [0]*int(raw_input()):\n  print solve(map(int,raw_input().split()))", "sampled": "from collections import deque, defaultdict\n\ndef bfs(graph, start, end, n):\n    if start == end:\n        return 0\n    \n    visited = [False] * (n + 1)\n    queue = deque([(start, 0)])\n    visited[start] = True\n    \n    while queue:\n        node, dist = queue.popleft()\n        \n        if node in graph:\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    if neighbor == end:\n                        return dist + 1\n                    visited[neighbor] = True\n                    queue.append((neighbor, dist + 1))\n    \n    return -1\n\nn = int(input())\ngraph = defaultdict(list)\n\nfor _ in range(n):\n    line = list(map(int, input().split()))\n    router_id = line[0]\n    k = line[1]\n    if k > 0:\n        connections = line[2:2+k]\n        graph[router_id] = connections\n\np = int(input())\n\nfor _ in range(p):\n    s, d, v = map(int, input().split())\n    \n    min_hops = bfs(graph, s, d, n)\n    \n    if min_hops == -1:\n        print(\"NA\")\n    else:\n        if v >= min_hops:\n            print(min_hops + 1)\n        else:\n            print(\"NA\")\n", "perturbed_sampled": ["from collections import deque, defaultdict def bfs(graph, start, end, n): if start ==  [False] * (n  0)]) visited[start] = True while queue:  node in graph: for neighbor in graph[node]: if not visited[neighbor]: if neighbor == end: return dist  queue.append((neighbor, dist + 1)) return -1 n = int(input()) graph = defaultdict(list) for _ in range(n): line = list(map(int, input().split())) router_id = line[0] k = line[1] if k >  = connections p = int(input()) for _ in range(p): s, d, v = map(int, input().split())  n) if min_hops == -1: print(\"NA\") else:  + 1) else: print(\"NA\")"], "perturbed_original": ["def solve(A): s,d,v = A C = [-1 for _ in  =  1: if SP==[]: return \"NA\" c += 1 X = [] for p in SP: if C[p]>0: continue C[p] = c X += [e  C[e]<0 and e not   = int(raw_input()) M = {} for _ in [0]*n: x = map(int, raw_input().split()) M[x[0]] = x[2:] for _ in [0]*int(raw_input()): print solve(map(int,raw_input().split()))"], "original_ll": -1.5682048797607422, "sampled_ll": -0.6638720035552979, "all_perturbed_sampled_ll": [-2.0872485637664795], "all_perturbed_original_ll": [-2.7079219818115234], "perturbed_sampled_ll": -2.0872485637664795, "perturbed_original_ll": -2.7079219818115234, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  int c1[100],c2[100],i,j,k,n,s=0,a,amax=0,amaxi;\n\n  scanf(\"%d\\n\",&n);\n  for(i=0;i<n;i++) scanf(\"%d %d\\n\",&c1[i],&c2[i]);\n\n  for(i=0;i<n-1;i++){\n    for(j=0;j<n-i-1;j++){\n      a=c2[j]*c1[j+1];\n      if(a>amax || (a==amax && c1[j]*c2[j+1] < c1[amaxi]*c2[amaxi+1])){\n        amax=a;\n        amaxi=j;\n      }\n    }\n    s+=c1[amaxi]*c2[amaxi]*c1[amaxi+1]*c2[amaxi+1];\n    c2[amaxi]=c2[amaxi+1];\n    for(j=amaxi+1;j<n-i;j++){\n      c1[j]=c1[j+1];\n      c2[j]=c2[j+1];\n    }\n    amax=0;\n  }\n  printf(\"%d\\n\",s);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <limits.h>\n\nint n;\nint a[101], b[101];\nlong long dp[101][101];\n\nlong long solve(int l, int r) {\n    if (l == r) return 0;\n    if (dp[l][r] != -1) return dp[l][r];\n    \n    long long min_cost = LLONG_MAX;\n    \n    for (int k = l; k < r; k++) {\n        long long cost = solve(l, k) + solve(k + 1, r);\n        cost += (long long)a[l] * b[k] * a[k + 1] * b[r];\n        if (cost < min_cost) {\n            min_cost = cost;\n        }\n    }\n    \n    dp[l][r] = min_cost;\n    return min_cost;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d %d\", &a[i], &b[i]);\n    }\n    \n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = -1;\n        }\n    }\n    \n    printf(\"%lld\\n\", solve(1, n));\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <limits.h> int n; int a[101], b[101]; long long dp[101][101]; long long solve(int l, int r) { if (l == r) return 0; if (dp[l][r] != -1) return dp[l][r]; long long min_cost = LLONG_MAX;  { long  + solve(k + 1,  * b[k] * a[k + 1] *  { min_cost = cost; } } dp[l][r] = min_cost;  { scanf(\"%d\", &n); for  <= n; i++) { scanf(\"%d %d\", &a[i], &b[i]); } for (int i = 0; i <= n; i++) { for (int j = 0; j <=  -1; } } printf(\"%lld\\n\", solve(1, n)); return 0; }"], "perturbed_original": [" c1[100],c2[100],i,j,k,n,s=0,a,amax=0,amaxi; scanf(\"%d\\n\",&n); for(i=0;i<n;i++) scanf(\"%d %d\\n\",&c1[i],&c2[i]); for(i=0;i<n-1;i++){  && c1[j]*c2[j+1] < c1[amaxi]*c2[amaxi+1])){ amax=a; amaxi=j; } } s+=c1[amaxi]*c2[amaxi]*c1[amaxi+1]*c2[amaxi+1]; c2[amaxi]=c2[amaxi+1]; for(j=amaxi+1;j<n-i;j++){ c1[j]=c1[j+1]; c2[j]=c2[j+1]; } amax=0; } printf(\"%d\\n\",s); return 0; }"], "original_ll": -0.743818998336792, "sampled_ll": -0.32965368032455444, "all_perturbed_sampled_ll": [-1.2910215854644775], "all_perturbed_original_ll": [-1.0981618165969849], "perturbed_sampled_ll": -1.2910215854644775, "perturbed_original_ll": -1.0981618165969849, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n\tfinal int INF = Integer.MAX_VALUE / 4;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString a = sc.next();\n\t\t\n\t\tint n = Integer.parseInt(a);\n\t\tint [][] data = new int[n][2];\n\t\tint [][] memo = new int[n][n];\n\t\tfor(int i=0; i < n; i++){\n\t\t\tArrays.fill(memo[i], INF);\n\t\t\tmemo[i][i] = 0;\n\t\t}\n\t\tfor(int i=0; i < n; i++){\n\t\t\tdata[i][0] = sc.nextInt();\n\t\t\tdata[i][1] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(\"440\");\n//\t\tfor(int i = 0; i < n-1; i++){\n//\t\t\tmemo[i][i+1] = data[i][0] * data[i][1] * data[i+1][0] * data[i+1][1];\n//\t\t}\n//\n//\t\tfor(int k = 2; k < n; k++){\n//\t\t\tfor(int i =0; i + k < n; i++){\n//\t\t\t\tfor(int j = i; j < i + k; j++){\n//\t\t\t\t\tint value2 = (data[i][0] * data[i+j][1]) * (data[i+j+1][0] * data[i+k][1]);\n//\t\t\t\t\tint value = memo[i][i+j] + memo[i+j+1][i+k] +value2;\n//\t\t\t\t\tmemo[i][i+k] = Math.min(memo[i][i+k], value);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\t\t//\t\t\t//debug\n\t\t//\t\t\tSystem.out.println(\"D= \");\n\t\t//\t\t\tfor(int i=0; i < n; i++){\n\t\t//\t\t\t\tfor(int j = 0;  i+ j < n;j++){\n\t\t//\t\t\t\t\tSystem.out.print(memo[j][i+j] + \" \");\n\t\t//\t\t\t\t}\n\t\t//\t\t\t\tSystem.out.println();\n\t\t//\t\t\t}\n\n\t\tSystem.out.println(memo[0][n-1]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] cards = new int[n][2];\n        \n        for (int i = 0; i < n; i++) {\n            cards[i][0] = sc.nextInt(); // top\n            cards[i][1] = sc.nextInt(); // bottom\n        }\n        \n        // dp[i][j] = minimum cost to merge piles from i to j into one pile\n        long[][] dp = new long[n][n];\n        // result[i][j][0] = top card after merging i to j\n        // result[i][j][1] = bottom card after merging i to j\n        int[][][] result = new int[n][n][2];\n        \n        // Initialize single piles\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 0;\n            result[i][i][0] = cards[i][0];\n            result[i][i][1] = cards[i][1];\n        }\n        \n        // Fill DP table for increasing lengths\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1;\n                dp[i][j] = Long.MAX_VALUE;\n                \n                // Try all possible split points\n                for (int k = i; k < j; k++) {\n                    // Merge [i..k] and [k+1..j]\n                    // Left pile (i..k) goes on top of right pile (k+1..j)\n                    long cost = dp[i][k] + dp[k+1][j];\n                    cost += (long)result[i][k][0] * result[i][k][1] * result[k+1][j][0] * result[k+1][j][1];\n                    \n                    if (cost < dp[i][j]) {\n                        dp[i][j] = cost;\n                        result[i][j][0] = result[i][k][0]; // top from left pile\n                        result[i][j][1] = result[k+1][j][1]; // bottom from right pile\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp[0][n-1]);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {  new Scanner(System.in); int n = sc.nextInt(); int[][] cards = new  0; i < n; i++) { cards[i][0] = sc.nextInt();  // bottom } // dp[i][j] = minimum cost to merge piles from i to j into one pile long[][] dp = new long[n][n]; // result[i][j][0] = top card  // result[i][j][1] = bottom card after merging i to j int[][][] result = new int[n][n][2]; // Initialize single piles for (int i = 0; i  = 0; result[i][i][0] = cards[i][0]; result[i][i][1] = cards[i][1]; } // Fill DP table for  = 2; len <= n; len++) { for (int i = 0; i <= n - len; i++) { int j =  dp[i][j] = Long.MAX_VALUE; // Try all  k = i; k < j; k++) { // Merge [i..k] and [k+1..j] // Left pile (i..k) goes on top of right pile (k+1..j) long cost = dp[i][k] + dp[k+1][j]; cost += (long)result[i][k][0] * result[i][k][1] *  < dp[i][j])  = result[i][k][0]; //  } } } System.out.println(dp[0][n-1]); sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { final int INF = Integer.MAX_VALUE / 4; private void doit(){ Scanner sc = new Scanner(System.in); String a = sc.next(); int n = Integer.parseInt(a); int [][] data = new int[n][2]; int [][] memo  i < n; i++){ Arrays.fill(memo[i], INF); memo[i][i] =  < n; i++){ data[i][0] = sc.nextInt(); data[i][1] = sc.nextInt(); } System.out.println(\"440\"); // for(int i = 0; i <  data[i][0] * data[i][1] * data[i+1][0] * data[i+1][1]; // } // // for(int  n; k++){ // for(int i =0; i  i; j < i + k;  (data[i][0] * data[i+j][1]) * (data[i+j+1][0] * data[i+k][1]); // int value = memo[i][i+j] + memo[i+j+1][i+k] +value2; // memo[i][i+k] = Math.min(memo[i][i+k], value); // } //  // System.out.println(\"D= \"); // for(int i=0; i < n; i++){ // for(int j = 0; i+ j < n;j++){ // System.out.print(memo[j][i+j] + \" \"); // } //  public   obj.doit(); } }"], "original_ll": -0.7439615726470947, "sampled_ll": -0.5090113878250122, "all_perturbed_sampled_ll": [-1.505436897277832], "all_perturbed_original_ll": [-1.6844178438186646], "perturbed_sampled_ll": -1.505436897277832, "perturbed_original_ll": -1.6844178438186646, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = int(raw_input())\nCard = [[] for _ in [0]*n]\nCost = {}\nfor i in range(n):\n  Card[i] = map(int, raw_input().split())\n  Cost[(i, i)] = 0\nfor i in range(1, n):\n  for j in range(0, n-i):\n    a = j+i\n    Cost[(j, a)] = min([Card[j][0] * Card[k][1] * Card[k+1][0] * Card[a][1] + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\nprint Cost[0, n-1]", "sampled": "def solve():\n    n = int(input())\n    piles = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        piles.append((a, b))\n    \n    if n == 1:\n        print(0)\n        return\n    \n    # dp[i][j] = minimum cost to merge piles from i to j into one pile\n    # result[i][j] = (top, bottom) of the merged pile from i to j\n    dp = [[0] * n for _ in range(n)]\n    result = [[None] * n for _ in range(n)]\n    \n    # Initialize single piles\n    for i in range(n):\n        result[i][i] = piles[i]\n    \n    # Length of the segment\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            \n            # Try all possible split points\n            for k in range(i, j):\n                # Merge [i, k] and [k+1, j]\n                # Cost = dp[i][k] + dp[k+1][j] + cost of merging these two groups\n                \n                # Get the top and bottom of left merged pile\n                left_top, left_bottom = result[i][k] if result[i][k] else piles[i]\n                # Get the top and bottom of right merged pile\n                right_top, right_bottom = result[k+1][j] if result[k+1][j] else piles[k+1]\n                \n                # Cost of merging left pile onto right pile\n                merge_cost = left_top * left_bottom * right_top * right_bottom\n                \n                total_cost = dp[i][k] + dp[k+1][j] + merge_cost\n                \n                if total_cost < dp[i][j]:\n                    dp[i][j] = total_cost\n                    # After merging, top is from left, bottom is from right\n                    result[i][j] = (left_top, right_bottom)\n    \n    print(dp[0][n-1])\n\nsolve()\n", "perturbed_sampled": ["def solve(): n    1: print(0) return # dp[i][j] = minimum cost to merge piles from i to j into one pile # result[i][j] = (top, bottom) of the merged pile from i to j dp =  [[None] * n for  single piles for i   for length in range(2, n + 1): for i in range(n - length + 1): j  1 dp[i][j] = float('inf') # Try all possible split points for k in range(i, j): # Merge [i, k] and [k+1, j] # Cost = dp[i][k]  merging these two groups # Get the top and bottom of left merged pile left_top, left_bottom = result[i][k] if result[i][k] else piles[i] # Get the top and bottom of right merged pile right_top, right_bottom = result[k+1][j] if result[k+1][j] else piles[k+1] # Cost of  pile merge_cost = left_top * left_bottom * right_top * right_bottom total_cost = dp[i][k] + dp[k+1][j] + merge_cost if total_cost < dp[i][j]: dp[i][j] = total_cost # After  bottom is from right result[i][j] = (left_top, right_bottom) print(dp[0][n-1]) solve()"], "perturbed_original": ["n = int(raw_input()) Card = [[] for _ in [0]*n] Cost =  Card[i] = map(int, raw_input().split()) Cost[(i, i)] = 0  for j in range(0, n-i): a = j+i Cost[(j, a)] = min([Card[j][0] * Card[k][1] * Card[k+1][0] * Card[a][1] + Cost[(j, k)] + Cost[(k+1,  j+i)]) print Cost[0, n-1]"], "original_ll": -1.0489510297775269, "sampled_ll": -0.6955733299255371, "all_perturbed_sampled_ll": [-1.602046251296997], "all_perturbed_original_ll": [-1.9974279403686523], "perturbed_sampled_ll": -1.602046251296997, "perturbed_original_ll": -1.9974279403686523, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<stdlib.h>\nint a[110],b[110],c[110],n;\ndouble f(int i,int j,int k){\n  int w=0,l;\n  if(j==0)return 0;\n  for(l=0;l<n;l++){\n    if(j&(1<<l))w+=c[l]*20;\n  }\n  return abs(b[k]-b[i])*(w+70)/2000.0;\n}\ndouble d[20][1<<16]={};\nint fr[20][1<<16]={};\nint main(){\n  int i,j,k,r[110];\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)d[i][j]=1e9;\n  }//printf(\"a\\n\");\n  for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)fr[i][j]=-1;\n  }\n  for(i=0;i<n;i++)d[i][1<<i]=0;\n  for(j=0;j<(1<<n);j++){\n    for(i=0;i<n;i++){\n      if((1<<i)&j==0)continue;\n      for(k=0;k<n;k++){\n\tif(j&(1<<k))continue;\n\tif(d[k][j+(1<<k)]>d[i][j]+f(i,j,k)){\n\t  d[k][j+(1<<k)]=d[i][j]+f(i,j,k);\n\t  fr[k][j+(1<<k)]=i;\n\t}\n      }\n    }\n  }//printf(\"b\\n\");\n  /*for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)printf(\"%f \",d[i][j]);printf(\"\\n\");\n  }\n  for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)printf(\"%d \",fr[i][j]);printf(\"\\n\");\n    }//*/\n  k=j-1;\n  for(i=j=0;i<n;i++){\n    if(d[i][k]<d[j][k])j=i;\n  }//printf(\"%d %d\\n\",j,fr[j][k]);\n  r[n-1]=j;\n  for(i=1;i<n;i++){//printf(\"%d:\",j);\n    r[n-i-1]=fr[r[n-i]][k];\n    k-=(1<<r[n-i]);\n    //j=fr[r[n-i-1]][k];\n  }//printf(\"d\\n\");\n  //for(i=0;i<n;i++)printf(\"%d \",r[i]);printf(\"\\n\");\n  for(i=0;i<n-1;i++)printf(\"%d \",a[r[i]]);\n  printf(\"%d\\n\",a[r[i]]);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 15\n#define INF 1e18\n\ntypedef struct {\n    int id;\n    int dist;\n    int boxes;\n} Warehouse;\n\nWarehouse wh[MAX_N];\nint n;\ndouble dp[1 << MAX_N][MAX_N];\nint parent[1 << MAX_N][MAX_N];\nint order[MAX_N];\n\ndouble calc_time(int dist, int weight) {\n    return (double)dist / (2000.0 / (70.0 + weight));\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &wh[i].id, &wh[i].dist, &wh[i].boxes);\n    }\n    \n    int full_mask = (1 << n) - 1;\n    \n    for (int mask = 0; mask <= full_mask; mask++) {\n        for (int i = 0; i < n; i++) {\n            dp[mask][i] = INF;\n            parent[mask][i] = -1;\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        dp[1 << i][i] = 0;\n    }\n    \n    for (int mask = 0; mask <= full_mask; mask++) {\n        for (int last = 0; last < n; last++) {\n            if (!(mask & (1 << last))) continue;\n            if (dp[mask][last] >= INF) continue;\n            \n            int total_weight = 0;\n            for (int i = 0; i < n; i++) {\n                if (mask & (1 << i)) {\n                    total_weight += wh[i].boxes * 20;\n                }\n            }\n            \n            for (int next = 0; next < n; next++) {\n                if (mask & (1 << next)) continue;\n                \n                int new_mask = mask | (1 << next);\n                int dist = abs(wh[next].dist - wh[last].dist);\n                double time = calc_time(dist, total_weight);\n                double new_time = dp[mask][last] + time;\n                \n                if (new_time < dp[new_mask][next]) {\n                    dp[new_mask][next] = new_time;\n                    parent[new_mask][next] = last;\n                }\n            }\n        }\n    }\n    \n    double min_time = INF;\n    int last_pos = -1;\n    for (int i = 0; i < n; i++) {\n        if (dp[full_mask][i] < min_time) {\n            min_time = dp[full_mask][i];\n            last_pos = i;\n        }\n    }\n    \n    int mask = full_mask;\n    int pos = last_pos;\n    int idx = n - 1;\n    \n    while (pos != -1) {\n        order[idx--] = wh[pos].id;\n        int prev = parent[mask][pos];\n        if (prev == -1) break;\n        mask ^= (1 << pos);\n        pos = prev;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n", "perturbed_sampled": [" #define INF 1e18 typedef struct { int id;  Warehouse; Warehouse wh[MAX_N]; int n; double dp[1 << MAX_N][MAX_N]; int parent[1 << MAX_N][MAX_N]; int order[MAX_N]; double calc_time(int dist, int weight) { return (double)dist  weight)); } int main() { scanf(\"%d\", &n); for (int i = 0;  scanf(\"%d %d %d\", &wh[i].id, &wh[i].dist, &wh[i].boxes); } int full_mask = (1 << n) - 1; for (int mask = 0; mask <= full_mask; mask++) { for  < n; i++) {  -1; } } for (int i = 0; i < n; i++) { dp[1 << i][i] = 0; } for (int mask = 0; mask <= full_mask; mask++) {  last < n; last++) { if (!(mask & (1 << last))) continue; if  total_weight = 0; for  < n; i++)  << i)) { total_weight  } for (int next = 0; next < n; next++) { if (mask & (1 << next)) continue; int new_mask = mask | (1 << next);  calc_time(dist, total_weight); double new_time = dp[mask][last] + time; if (new_time <  parent[new_mask][next] = last; } }  INF; int last_pos = -1; for (int i  i++)  { min_time = dp[full_mask][i];  int  = last_pos; int idx = n - 1; while (pos != -1) { order[idx--] = wh[pos].id; int prev = parent[mask][pos]; if (prev == -1) break; mask ^= (1 << pos); pos = prev; } for (int i = 0; i < n; i++) { if (i > 0) printf(\" \"); printf(\"%d\", order[i]); } printf(\"\\n\"); return 0; }"], "perturbed_original": ["#include<stdio.h> #include<stdlib.h> int a[110],b[110],c[110],n; double f(int i,int j,int k){ int  double d[20][1<<16]={}; int fr[20][1<<16]={}; int main(){ int i,j,k,r[110]; scanf(\"%d\",&n); for(i=0;i<n;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);  if((1<<i)&j==0)continue; for(k=0;k<n;k++){ if(j&(1<<k))continue; if(d[k][j+(1<<k)]>d[i][j]+f(i,j,k)){ d[k][j+(1<<k)]=d[i][j]+f(i,j,k); fr[k][j+(1<<k)]=i; } } } }//printf(\"b\\n\"); /*for(i=0;i<n;i++){ for(j=0;j<(1<<n);j++)printf(\"%f \",d[i][j]);printf(\"\\n\"); } for(i=0;i<n;i++){ for(j=0;j<(1<<n);j++)printf(\"%d \",fr[i][j]);printf(\"\\n\"); }//*/ k=j-1; for(i=j=0;i<n;i++){ if(d[i][k]<d[j][k])j=i; }//printf(\"%d %d\\n\",j,fr[j][k]); r[n-1]=j; for(i=1;i<n;i++){//printf(\"%d:\",j); r[n-i-1]=fr[r[n-i]][k]; k-=(1<<r[n-i]); //j=fr[r[n-i-1]][k]; }//printf(\"d\\n\"); //for(i=0;i<n;i++)printf(\"%d \",r[i]);printf(\"\\n\"); for(i=0;i<n-1;i++)printf(\"%d \",a[r[i]]); printf(\"%d\\n\",a[r[i]]); return 0; }"], "original_ll": -0.8118327856063843, "sampled_ll": -0.4577331244945526, "all_perturbed_sampled_ll": [-1.4630820751190186], "all_perturbed_original_ll": [-1.103569746017456], "perturbed_sampled_ll": -1.4630820751190186, "perturbed_original_ll": -1.103569746017456, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic void sort(int[][] data){\n\t\tfor(int i = 0; i < data.length; i++){\n\t\t\tint min = i;\n\t\t\tfor(int j = i+1; j < data.length; j++){\n\t\t\t\tif( data[min][2] > data[j][2] ){\n\t\t\t\t\tmin = j;\n\t\t\t\t} else if( data[min][2] == data[j][2] ){\n\t\t\t\t\tif( data[min][1] > data[j][1] ){\n\t\t\t\t\t\tmin = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\tint temp = data[min][j];\n\t\t\t\tdata[min][j] = data[i][j];\n\t\t\t\tdata[i][j] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tpublic int[] nextPermutation(int[] x, int index){\n\t\tint max = index;\n\t\tboolean[] temp = new boolean[x.length];\n\t\tfor(int i = index; i < x.length; i++){\n\t\t\ttemp[x[i]-1] = true;\n\t\t\tif( x[i] > x[max] ){\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t}\n\t\tint key = index+1;\n\t\tif( max == index ){\n\t\t\tfor(; index > 0; index--){\n\t\t\t\ttemp[x[index-1]-1] = true;\n\t\t\t\tif( x[index] > x[index-1] ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( index == 0 ){\n\t\t\t\tx[0] = -1;\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\tkey = index;\n\t\t} \n\n\t\tfor(int i = x[key-1]; i < temp.length; i++){\n\t\t\tif( temp[i] ){\n\t\t\t\tx[key-1] = i+1;\n\t\t\t\ttemp[i] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\t\t\n\t\tint count = 0;\n\t\tfor(int i = 0; i < temp.length; i++){\n\t\t\tif( temp[i] ){\n\t\t\t\tx[key+count] = i+1;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\t\t\t\n\t\treturn x;\n\t}\n\t\t\t\n\tpublic  void solve() throws IOException{\n\t\tint n = nextInt();\n\t\tlong start = System.currentTimeMillis();\n\t\tint[][] data = new int[n][3];\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdata[i][0] = nextInt();\n\t\t\tdata[i][1] = nextInt();\n\t\t\tdata[i][2] = nextInt();\t\t\t\n\t\t}\n\t\tsort(data);\t\t\n\t\tint[] x = new int[n];\n\t\tfor(int i = 0; i < x.length; i++){\n\t\t\tx[i] = i+1;\n\t\t}\n\t\tdouble min = 1000000001;\n\t\tint[] ans = new int[n];\n\t\tSystem.arraycopy(x, 0, ans, 0, n);\n\t\tint count = 0;\n\t\twhile( x[0] > 0 ){\n\t\t\tcount++;\n\t\t\tint[] total = new int[n];\n\t\t\tint high = data[x[n-1]-1][1];\n\t\t\tint low = high;\n\t\t\tfor(int i = n-2; i >= 0; i--){\n\t\t\t\tint a = data[x[i]-1][1];\t\t\n\t\t\t\thigh = Math.max(high, a);\n\t\t\t\tlow = Math.min(low, a);\n\t\t\t\ttotal[i] = high+low+Math.min(high-a, a-low);\n\t\t\t}\t\t\n\t\t\tdouble sum = 0;\n\t\t\tdouble w = 0;\n\t\t\tdouble v = (double)2000/70;\t\n\t\t\tint i = 0;\t\t\n\t\t\tfor(; i < x.length-1; i++){\n\t\t\t\tif( sum + total[i]/v > min ){\n\t//\t\t\t\twriter.println(\"cut at \" + i + \", v = \" + v + \", sum = \" + sum);\n\t\t\t\t\tsum = min;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint len = Math.abs(data[x[i]-1][1]-data[x[i+1]-1][1]);\n\t\t\t\tw += 20*data[x[i]-1][2];\n\t\t\t\tv = 2000/(70+w);\n\t\t\t\tsum += len/v;\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\tif( sum < min ){\n\t\t\t\tSystem.arraycopy(x, 0, ans, 0, n);\n\t\t\t\tmin = sum;\n\t\t\t}\n\t\t\ti = Math.min(i, n-1);\n\t\t\tx = nextPermutation(x, i);\t\t\t\n\t\t}\n\t\twriter.println(count);\n\t\twriter.println(min);\n\t\twriter.print(data[ans[0]-1][0]);\n\t\tfor(int i = 1; i < n; i++){\n\t\t\twriter.print(\" \" + data[ans[i]-1][0]);\n\t\t}\n\t\twriter.println();\t\n\t\tlong fin = System.currentTimeMillis();\n\t\twriter.println(fin-start);\t\n\t\twriter.flush();\t\t\t\n\t}\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\t\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Warehouse {\n        int id;\n        int distance;\n        int boxes;\n        \n        Warehouse(int id, int distance, int boxes) {\n            this.id = id;\n            this.distance = distance;\n            this.boxes = boxes;\n        }\n    }\n    \n    static int n;\n    static Warehouse[] warehouses;\n    static double minTime;\n    static int[] bestOrder;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        warehouses = new Warehouse[n];\n        \n        for (int i = 0; i < n; i++) {\n            int id = sc.nextInt();\n            int distance = sc.nextInt();\n            int boxes = sc.nextInt();\n            warehouses[i] = new Warehouse(id, distance, boxes);\n        }\n        \n        minTime = Double.MAX_VALUE;\n        bestOrder = new int[n];\n        \n        permute(new ArrayList<>(), new boolean[n], 0);\n        \n        for (int i = 0; i < n; i++) {\n            if (i > 0) System.out.print(\" \");\n            System.out.print(bestOrder[i]);\n        }\n        System.out.println();\n    }\n    \n    static void permute(List<Integer> current, boolean[] used, int depth) {\n        if (depth == n) {\n            double time = calculateTime(current);\n            if (time < minTime) {\n                minTime = time;\n                for (int i = 0; i < n; i++) {\n                    bestOrder[i] = warehouses[current.get(i)].id;\n                }\n            }\n            return;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                current.add(i);\n                permute(current, used, depth + 1);\n                current.remove(current.size() - 1);\n                used[i] = false;\n            }\n        }\n    }\n    \n    static double calculateTime(List<Integer> order) {\n        double totalTime = 0.0;\n        int totalWeight = 0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int currentIdx = order.get(i);\n            int nextIdx = order.get(i + 1);\n            \n            totalWeight += warehouses[currentIdx].boxes * 20;\n            \n            int distance = Math.abs(warehouses[nextIdx].distance - warehouses[currentIdx].distance);\n            double speed = 2000.0 / (70.0 + totalWeight);\n            double time = distance / speed;\n            \n            totalTime += time;\n        }\n        \n        return totalTime;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Warehouse { int id; int distance; int boxes; Warehouse(int id, int distance, int boxes) { this.id = id; this.distance = distance; this.boxes = boxes; } } static int n; static Warehouse[]  int[] bestOrder; public static void main(String[] args) { Scanner sc = new Scanner(System.in);  new  0; i < n; i++) { int id = sc.nextInt(); int distance = sc.nextInt(); int boxes = sc.nextInt(); warehouses[i] = new Warehouse(id, distance, boxes);  = new int[n]; permute(new ArrayList<>(), new boolean[n], 0); for (int i = 0; i <  > 0) System.out.print(\" \"); System.out.print(bestOrder[i]); } System.out.println(); } static void permute(List<Integer> current,  if (depth == n) { double time = calculateTime(current); if (time < minTime) { minTime = time; for (int i = 0; i < n; i++) { bestOrder[i] = warehouses[current.get(i)].id; }  i = 0;   true; current.add(i); permute(current, used, depth + 1); current.remove(current.size() - 1); used[i] = false; } } }  double totalTime = 0.0; int totalWeight = 0; for  <  int currentIdx = order.get(i); int nextIdx = order.get(i +  Math.abs(warehouses[nextIdx].distance  2000.0 / (70.0 +  / speed; totalTime += time; } return totalTime; } }"], "perturbed_original": [" class Main { public void sort(int[][] data){ for(int  = i; for(int j = i+1; j  > data[j][2]  else if( data[min][2] == data[j][2]  } } } for(int j = 0; j <  data[min][j]; data[min][j]  } } } public int[] nextPermutation(int[] x, int index){ int max = index; boolean[] temp = new  temp[x[i]-1] = true; if( x[i] > x[max] ){ max = i; } }  max  > 0; index--){ temp[x[index-1]-1] = true; if( x[index] > x[index-1] ){ break; } } if( index == 0 ){ x[0] = -1; return x; } key  = x[key-1]; i < temp.length; i++){ if( temp[i] ){  false; break; } } int count = 0; for(int i = 0; i < temp.length; i++){ if( temp[i] ){ x[key+count]  return x; } public void solve() throws IOException{ int n  System.currentTimeMillis(); int[][] data = new int[n][3]; for(int i = 0; i < n; i++){  nextInt(); data[i][2] = nextInt(); } sort(data); int[] x = new int[n]; for(int i = 0; i < x.length; i++){ x[i] = i+1; }  ans =  0, n); int count =  ){ count++; int[] total = new int[n]; int high = data[x[n-1]-1][1]; int low = high; for(int i = n-2; i >= 0; i--){ int a = data[x[i]-1][1]; high = Math.max(high, a); low = Math.min(low, a); total[i] = high+low+Math.min(high-a, a-low); } double sum = 0; double w = 0; double v = (double)2000/70; int i = 0;  if( sum  // writer.println(\"cut at  v = \" + v  + sum); sum = min; break; } int len = Math.abs(data[x[i]-1][1]-data[x[i+1]-1][1]); w += 20*data[x[i]-1][2]; v = 2000/(70+w); sum += len/v; } if( sum < min ){ System.arraycopy(x, 0, ans, 0, n); min = sum;  x = nextPermutation(x,  for(int i = 1; i < n; i++){ writer.print(\" \" + data[ans[i]-1][0]); } writer.println(); long fin = System.currentTimeMillis(); writer.println(fin-start); writer.flush(); } public static void main (String args[]) throws IOException{ new Main().run(); } BufferedReader reader;  void run()  new BufferedReader(new InputStreamReader(System.in)); tokenizer = null; writer = new PrintWriter(System.out); solve(); reader.close(); writer.close(); } catch (Exception e){ e.printStackTrace(); System.exit(1); } } public int nextInt() throws IOException{ return Integer.parseInt(nextToken()); } public  tokenizer == null || !tokenizer.hasMoreTokens() ){ tokenizer = new StringTokenizer(reader.readLine()); } return tokenizer.nextToken(); } }"], "original_ll": -0.6970365643501282, "sampled_ll": -0.411479115486145, "all_perturbed_sampled_ll": [-1.5412806272506714], "all_perturbed_original_ll": [-1.5725879669189453], "perturbed_sampled_ll": -1.5412806272506714, "perturbed_original_ll": -1.5725879669189453, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = int(input())\nD = [list(map(int, input().split())) for i in range(n)]\n# [cost, order]\nmemo = {(2**n-1, i): (0, ()) for i in range(n)}\ndef dfs(state, pos, w):\n    if (state, pos) in memo:\n        return memo[state, pos]\n    res = None\n    for i in range(n):\n        if (state >> i) & 1 == 0:\n            d0 = D[pos][1]\n            s, d1, v = D[i]\n            r = dfs(state | (1 << i), i, w + 20*v)\n            val = (r[0]+abs(d0-d1)*(70+w), r[1]+(s,))\n            if res is None or val < res:\n                res = val\n    if res:\n        memo[state, pos] = res\n    return res\ndef solve():\n    for i in range(n):\n        s0, d0, v0 = D[i]\n        result = dfs(1 << i, i, 20*v0)\n        yield result[0], result[1]+(s0,)\nans = min(solve())\nprint(*reversed(ans[1]))", "sampled": "from itertools import permutations\n\ndef calculate_time(order, warehouses):\n    total_time = 0\n    current_pos = 0\n    current_weight = 0\n    \n    for i, idx in enumerate(order):\n        warehouse = warehouses[idx]\n        pos = warehouse[1]\n        boxes = warehouse[2]\n        \n        # Move to this warehouse\n        distance = abs(pos - current_pos)\n        speed = 2000 / (70 + current_weight)\n        time = distance / speed\n        total_time += time\n        \n        # Pick up boxes\n        current_weight += boxes * 20\n        current_pos = pos\n    \n    return total_time\n\nn = int(input())\nwarehouses = []\nfor _ in range(n):\n    parts = list(map(int, input().split()))\n    warehouses.append((parts[0], parts[1], parts[2]))\n\nmin_time = float('inf')\nbest_order = None\n\nfor perm in permutations(range(n)):\n    time = calculate_time(perm, warehouses)\n    if time < min_time:\n        min_time = time\n        best_order = perm\n\nresult = [warehouses[i][0] for i in best_order]\nprint(' '.join(map(str, result)))\n", "perturbed_sampled": ["from itertools import permutations def calculate_time(order, warehouses): total_time = 0 current_pos = 0 current_weight = 0 for i, idx in enumerate(order): warehouse = warehouses[idx] pos = warehouse[1] boxes = warehouse[2] # Move to this warehouse distance = abs(pos - current_pos)  + current_weight) time = distance / speed total_time += time # Pick  pos return total_time  [] for _ in range(n): parts = list(map(int, input().split())) warehouses.append((parts[0], parts[1],  = None for perm in permutations(range(n)): time = calculate_time(perm,  min_time = time  [warehouses[i][0] for i in best_order] print(' '.join(map(str, result)))"], "perturbed_original": ["n = int(input()) D = [list(map(int, input().split())) for i in range(n)] # [cost, order] memo = {(2**n-1, i): (0, ()) for i in range(n)} def dfs(state, pos, w): if (state, pos) in  = None  (state >> i) & 1 == 0: d0 = D[pos][1] s, d1,  dfs(state |  + 20*v) val = (r[0]+abs(d0-d1)*(70+w), r[1]+(s,)) if  < res: res = val if res:  res def solve(): for i in range(n): s0, d0, v0 =  i, i, 20*v0) yield result[0], result[1]+(s0,) ans = min(solve()) print(*reversed(ans[1]))"], "original_ll": -1.3178303241729736, "sampled_ll": -0.858487606048584, "all_perturbed_sampled_ll": [-2.3146865367889404], "all_perturbed_original_ll": [-2.5455482006073], "perturbed_sampled_ll": -2.3146865367889404, "perturbed_original_ll": -2.5455482006073, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==95)c++;\n\t}\n\treturn (c?1:0);\n}", "sampled": "#include <stdio.h>\n\ntypedef struct {\n    int group_id;\n    int leave_time;\n} Seat;\n\ntypedef struct {\n    int group_id;\n    int arrival_time;\n    int size;\n    int eating_time;\n} Group;\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) != EOF) {\n        Seat seats[17];\n        Group groups[100];\n        int queue[100];\n        int queue_front = 0, queue_rear = 0;\n        \n        // Initialize seats\n        for (int i = 0; i < 17; i++) {\n            seats[i].group_id = -1;\n            seats[i].leave_time = -1;\n        }\n        \n        // Initialize groups\n        for (int i = 0; i < 100; i++) {\n            groups[i].group_id = i;\n            groups[i].arrival_time = 5 * i;\n            groups[i].size = (i % 5 == 1) ? 5 : 2;\n            groups[i].eating_time = 17 * (i % 2) + 3 * (i % 3) + 19;\n        }\n        \n        int seated_time[100];\n        for (int i = 0; i < 100; i++) {\n            seated_time[i] = -1;\n        }\n        \n        int next_arrival = 0;\n        int time = 0;\n        \n        while (1) {\n            // Process departures\n            for (int i = 0; i < 17; i++) {\n                if (seats[i].group_id != -1 && seats[i].leave_time == time) {\n                    seats[i].group_id = -1;\n                    seats[i].leave_time = -1;\n                }\n            }\n            \n            // Try to seat groups from queue\n            while (queue_front < queue_rear) {\n                int gid = queue[queue_front];\n                int size = groups[gid].size;\n                \n                // Find continuous empty seats\n                int found = -1;\n                for (int start = 0; start <= 17 - size; start++) {\n                    int ok = 1;\n                    for (int j = 0; j < size; j++) {\n                        if (seats[start + j].group_id != -1) {\n                            ok = 0;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        found = start;\n                        break;\n                    }\n                }\n                \n                if (found != -1) {\n                    // Seat the group\n                    for (int j = 0; j < size; j++) {\n                        seats[found + j].group_id = gid;\n                        seats[found + j].leave_time = time + groups[gid].eating_time;\n                    }\n                    seated_time[gid] = time;\n                    queue_front++;\n                } else {\n                    break;\n                }\n            }\n            \n            // Handle arrivals at this time\n            while (next_arrival < 100 && groups[next_arrival].arrival_time == time) {\n                int gid = next_arrival;\n                int size = groups[gid].size;\n                \n                if (queue_front < queue_rear) {\n                    // Queue exists, join queue\n                    queue[queue_rear++] = gid;\n                } else {\n                    // Try to seat immediately\n                    int found = -1;\n                    for (int start = 0; start <= 17 - size; start++) {\n                        int ok = 1;\n                        for (int j = 0; j < size; j++) {\n                            if (seats[start + j].group_id != -1) {\n                                ok = 0;\n                                break;\n                            }\n                        }\n                        if (ok) {\n                            found = start;\n                            break;\n                        }\n                    }\n                    \n                    if (found != -1) {\n                        // Seat immediately\n                        for (int j = 0; j < size; j++) {\n                            seats[found + j].group_id = gid;\n                            seats[found + j].leave_time = time + groups[gid].eating_time;\n                        }\n                        seated_time[gid] = time;\n                    } else {\n                        // Join queue\n                        queue[queue_rear++] = gid;\n                    }\n                }\n                \n                next_arrival++;\n            }\n            \n            // Check if we're done\n            if (seated_time[n] != -1) {\n                break;\n            }\n            \n            time++;\n        }\n        \n        printf(\"%d\\n\", seated_time[n] - groups[n].arrival_time);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> typedef  struct { int group_id; int arrival_time; int size; int eating_time; } Group; int main() { int n; while (scanf(\"%d\", &n) != EOF) { Seat seats[17]; Group groups[100]; int queue[100]; int queue_front = 0, queue_rear = 0; // Initialize seats for (int i  i++) { seats[i].group_id = -1; seats[i].leave_time =  for (int i = 0; i < 100; i++) { groups[i].group_id = i; groups[i].arrival_time = 5  % 5 == 1) ? 5 : 2; groups[i].eating_time = 17 * (i % 2) + 3 * (i % 3) + 19; } int seated_time[100]; for (int i = 0;  seated_time[i] = -1;  int time  // Process departures for (int i = 0; i < 17; i++) { if  == time) { seats[i].group_id = -1; seats[i].leave_time = -1; } }  from  { int gid = queue[queue_front]; int size = groups[gid].size; // Find continuous empty seats int found =  0; start <= 17  ok = 1; for (int j =  { if (seats[start + j].group_id != -1) { ok = 0; break;  } } if (found != -1) { // Seat the  0; j < size; j++) { seats[found + j].group_id = gid; seats[found + j].leave_time = time + groups[gid].eating_time; } seated_time[gid]  { break; } } // Handle arrivals at  100  int gid = next_arrival; int size = groups[gid].size; if (queue_front < queue_rear) { // Queue exists, join queue queue[queue_rear++] = gid; } else { // Try to seat immediately int found = -1; for (int start = 0; start <= 17 - size; start++) { int ok = 1; for (int j  j++)  != -1) { ok = 0;  { found = start; break; } } if (found != -1) { // Seat immediately for (int j = 0; j < size; j++) {  seats[found +  } seated_time[gid] = time; } else { // Join queue queue[queue_rear++] = gid; } } next_arrival++; } // Check if we're done if (seated_time[n] !=  }  return 0; }"], "perturbed_original": ["main(){ int n,c=0; while(~scanf(\"%d\",&n)){ if(n==95)c++; } return (c?1:0); }"], "original_ll": -2.240717649459839, "sampled_ll": -0.4762510657310486, "all_perturbed_sampled_ll": [-1.4683458805084229], "all_perturbed_original_ll": [-2.1805639266967773], "perturbed_sampled_ll": -1.4683458805084229, "perturbed_original_ll": -2.1805639266967773, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/** \u5bfe\u8c61\u5916 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** \u30b0\u30eb\u30fc\u30d7\u6570 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** \u6a19\u6e96\u5165\u529b */\n\tprivate static BufferedReader br;\n\n\t/** \u5ea7\u5e2d\u6570 \u6700\u5f8c\u306e\u5ea7\u5e2d\u756a\u53f7 */\n\tprivate static int seatsNum, firstSeatNum;\n\n\t/** \u5230\u7740\u6642\u9593 \u5ba2\u6570 \u98df\u4e8b\u6642\u9593 \u5f85\u3061\u6642\u9593 */\n\tprivate static int[] arriveMinutes, customersNum, mealMinutes, waitMinutes;\n\n\t/** \u5ea7\u5e2d */\n\tprivate static String[] seats;\n\n\t/** \u521d\u671f\u5316 */\n\tstatic {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tseatsNum = 17;\n\t\tarriveMinutes = new int[GROUP_NUM];\n\t\tcustomersNum = new int[GROUP_NUM];\n\t\tmealMinutes = new int[GROUP_NUM];\n\t\twaitMinutes = new int[GROUP_NUM];\n\t\tseats = new String[seatsNum];\n\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\t// \u30b0\u30eb\u30fc\u30d7\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\t// \u5230\u7740\u6642\u9593\n\t\t\tarriveMinutes[i] = 5 * i;\n\n\t\t\t// \u4eba\u6570\n\t\t\tcustomersNum[i] = i % 5 == 1 ? 5 : 2;\n\n\t\t\t// \u98df\u4e8b\u6642\u9593\n\t\t\tmealMinutes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n\t\t}\n\n\t\t// \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210\n\t\tcreateWaitMinutes();\n\n\t}\n\n\t/** \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210\u3059\u308b */\n\tprivate static void createWaitMinutes() {\n\t\t// \u9806\u756a\n\t\tint groupOrder;\n\n\t\t// \u884c\u5217\u30ea\u30b9\u30c8\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentMinutes = 0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentMinutes++) {\n\t\t\t// \u884c\u5217\u304c\u7d42\u4e86\u3059\u308b\u307e\u3067\u3001\u4e00\u5206\u6bce\u306b\u7e70\u308a\u8fd4\u3059\n\n\t\t\t// \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5ba2\u3092\u96e2\u5e2d\u3055\u305b\u308b\n\t\t\toutCustomer(currentMinutes);\n\n\t\t\tif ((groupOrder = searchGroupNum(arriveMinutes, currentMinutes)) != EXEMPT) {\n\t\t\t\t// \u5230\u7740\u6642\u9593\u306e\u5834\u5408\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// \u884c\u5217\u304c\u306a\u3044\u5834\u5408\n\n\t\t\t\t\tif (isEmpty(groupOrder)) {\n\t\t\t\t\t\t// \u7740\u5e2d\u53ef\u80fd\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u5ea7\u5e2d\u306b\u7740\u5e2d\u3055\u305b\u308b\n\t\t\t\t\t\tsetSeat(Integer.toString(groupOrder), totalGroupNum);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u884c\u5217\u306b\u4e26\u3070\u305b\u308b\n\t\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// \u884c\u5217\u304c\u3042\u308b\u5834\u5408\n\n\t\t\t\t\t// \u884c\u5217\u306b\u4e26\u3070\u305b\u308b\n\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// \u884c\u5217\u304c\u3042\u308b\u5834\u5408\n\n\t\t\t\tfor (int index = 0; index < waitList.size(); index++) {\n\t\t\t\t\t// \u884c\u5217\u30ea\u30b9\u30c8\u5206\u3001\u7e70\u308a\u8fd4\u3059\n\n\t\t\t\t\tif (isEmpty(waitList.get(index))) {\n\t\t\t\t\t\t// \u7740\u5e2d\u53ef\u80fd\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u5ea7\u5e2d\u306b\u7740\u5e2d\u3055\u305b\u308b\n\t\t\t\t\t\tsetSeat(Integer.toString(waitList.get(index)), totalGroupNum);\n\n\t\t\t\t\t\t// \u5f85\u3063\u305f\u6642\u9593\u3092\u8a2d\u5b9a\u3059\u308b\n\t\t\t\t\t\twaitMinutes[waitList.get(index)] = currentMinutes\n\t\t\t\t\t\t\t\t- arriveMinutes[waitList.get(index)];\n\n\t\t\t\t\t\t// \u7740\u5e2d\u3057\u305f\u30b0\u30eb\u30fc\u30d7\u3092\u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3059\u308b\n\t\t\t\t\t\tremoveList.add(index);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u884c\u5217\u306e\u5148\u982d\u304c\u7740\u5e2d\u3067\u304d\u306a\u3044\u305f\u3081\u3001\u6b8b\u308a\u306e\u884c\u5217\u3082\u7740\u5e2d\u4e0d\u53ef\u306b\u3059\u308b\u3002\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306b\u7740\u5e2d\u3057\u305f\u30b0\u30eb\u30fc\u30d7\u304c\u8ffd\u52a0\u3055\u308c\u3066\u3044\u305f\u5834\u5408\n\n\t\t\t\t// \u30ea\u30b9\u30c8\u306e\u964d\u9806\u3067\u30bd\u30fc\u30c8\u3059\u308b\uff08\u30ea\u30e0\u30fc\u30d6\u3059\u308b\u305f\u3081\uff09\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u5206\u3001\u7e70\u308a\u8fd4\u3059\n\n\t\t\t\t\t// \u884c\u5217\u30ea\u30b9\u30c8\u304b\u3089\u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306e\u756a\u53f7\u3092\u524a\u9664\u3059\u308b\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// \u521d\u671f\u5316\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** \u30e1\u30a4\u30f3 */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile (!isNull(line = br.readLine()) && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitMinutes[input]);\n\t\t}\n\n\t}\n\n\t/** \u73fe\u5728\u6642\u9593\u306b\u5230\u7740\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u691c\u7d22\u3057\u8fd4\u3059 */\n\tprivate static int searchGroupNum(int[] targets, int currentMinutes) {\n\t\tint order = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (isSame(target, currentMinutes)) {\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\torder++;\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** \u96e2\u5e2d\u3055\u305b\u308b */\n\tprivate static void outCustomer(int currentMinutes) {\n\n\t\tfor (int seatNum = 0; seatNum < seats.length; seatNum++) {\n\t\t\t// \u5ea7\u5e2d\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\tif (isNull(seats[seatNum])) {\n\t\t\t\t// \u7a7a\u5e2d\u306e\u5834\u5408\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (finishedMeal(currentMinutes, seats[seatNum])) {\n\t\t\t\t// \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5834\u5408\n\n\t\t\t\t// \u7a7a\u5e2d\u306b\u3059\u308b\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/** \u5f15\u6570\u304cnull\u304b\u7a7a\u767d\u306e\u5834\u5408\u3001true\u3092\u8fd4\u3059 */\n\tprivate static boolean isNull(String param) {\n\t\treturn param == null;\n\t}\n\n\t/** \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5ea7\u5e2d\u306e\u5834\u5408\u3001true\u3092\u8fd4\u3059 */\n\tprivate static boolean finishedMeal(int currentMinutes, String seat) {\n\t\treturn currentMinutes\n\t\t\t\t- (arriveMinutes[Integer.parseInt(seat)] + waitMinutes[Integer\n\t\t\t\t\t\t.parseInt(seat)]) >= mealMinutes[Integer.parseInt(seat)];\n\t}\n\n\t/** \u7740\u5e2d\u3055\u305b\u308b */\n\tprivate static void setSeat(String groupOrder, int totalGroupNum) {\n\n\t\tfor (int count = 0; count < customersNum[Integer.parseInt(groupOrder)]; count++) {\n\t\t\t// \u7740\u5e2d\u3059\u308b\u4eba\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\t// \u5ea7\u5e2d\u306b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b\n\t\t\tseats[firstSeatNum++] = groupOrder;\n\t\t}\n\t\ttotalGroupNum++;\n\t}\n\n\t/** \u5f15\u6570\u306e\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u306e\u5ba2\u6570\u5206\u3001\u7a7a\u5e2d\u304b\u3069\u3046\u304b\u78ba\u8a8d\u3059\u308b */\n\tprivate static boolean isEmpty(int groupsNum) {\n\n\t\t// \u7a7a\u5e2d\u6570\n\t\tint emptyseatsNum = 0;\n\t\tint i = 0;\n\n\t\tfor (; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n\t\t\t// \u6b8b\u5ea7\u5e2d\u6570\u304c\u5ba2\u306e\u6570\u4ee5\u4e0b\u306b\u306a\u308b\u307e\u3067\u5ea7\u5e2d\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\tif (isSame(customersNum[groupsNum], emptyseatsNum)) {\n\t\t\t\t// \u9023\u7d9a\u3057\u305f\u7a7a\u5e2d\u304c\u5ba2\u306e\u6570\u3060\u3051\u3042\u3063\u305f\u5834\u5408\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (isNull(seats[i])) {\n\t\t\t\t// \u7a7a\u5e2d\u304b\u3064\u7e70\u308a\u8fd4\u3059\u5e2d\u304c\u9867\u5ba2\u6570\u5206\u4ee5\u4e0a\u5b58\u5728\u3059\u308b\u5834\u5408\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// \u7a7a\u5e2d\u3067\u306a\u3044\u5834\u5408\n\n\t\t\t\t// \u7a7a\u5e2d\u6570\u3092\u521d\u671f\u5316\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\t\tif (isSame(customersNum[groupsNum], emptyseatsNum)) {\n\t\t\t// \u7a7a\u5e2d\u306e\u6700\u521d\u306e\u5ea7\u5e2d\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b\n\t\t\tfirstSeatNum = i - emptyseatsNum;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** \u7b2c\u4e00\u5f15\u6570\u3068\u7b2c\u4e8c\u5f15\u6570\u304c\u540c\u3058\u5834\u5408\u3001true\u3092\u8fd4\u3059 */\n\tprivate static boolean isSame(int param, int target) {\n\t\treturn param == target;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Group {\n        int id;\n        int arrivalTime;\n        int size;\n        int eatingTime;\n        int seatedTime;\n        \n        Group(int id) {\n            this.id = id;\n            this.arrivalTime = 5 * id;\n            this.size = (id % 5 == 1) ? 5 : 2;\n            this.eatingTime = 17 * (id % 2) + 3 * (id % 3) + 19;\n            this.seatedTime = -1;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            System.out.println(simulate(n));\n        }\n        sc.close();\n    }\n    \n    static int simulate(int targetGroup) {\n        int[] seats = new int[17];\n        Arrays.fill(seats, -1);\n        int[] leaveTime = new int[17];\n        \n        Group[] groups = new Group[100];\n        for (int i = 0; i < 100; i++) {\n            groups[i] = new Group(i);\n        }\n        \n        Queue<Group> queue = new LinkedList<>();\n        int nextGroupToArrive = 0;\n        \n        for (int time = 0; time <= 10000; time++) {\n            // Step 1: Process departures\n            for (int i = 0; i < 17; i++) {\n                if (seats[i] != -1 && leaveTime[i] == time) {\n                    seats[i] = -1;\n                }\n            }\n            \n            // Step 2: Seat groups from queue\n            while (!queue.isEmpty()) {\n                Group g = queue.peek();\n                int pos = findSeats(seats, g.size);\n                if (pos != -1) {\n                    queue.poll();\n                    for (int i = pos; i < pos + g.size; i++) {\n                        seats[i] = g.id;\n                        leaveTime[i] = time + g.eatingTime;\n                    }\n                    g.seatedTime = time;\n                } else {\n                    break;\n                }\n            }\n            \n            // Step 3: Process arrivals\n            while (nextGroupToArrive < 100 && groups[nextGroupToArrive].arrivalTime == time) {\n                Group g = groups[nextGroupToArrive];\n                nextGroupToArrive++;\n                \n                if (queue.isEmpty()) {\n                    int pos = findSeats(seats, g.size);\n                    if (pos != -1) {\n                        for (int i = pos; i < pos + g.size; i++) {\n                            seats[i] = g.id;\n                            leaveTime[i] = time + g.eatingTime;\n                        }\n                        g.seatedTime = time;\n                    } else {\n                        queue.offer(g);\n                    }\n                } else {\n                    queue.offer(g);\n                }\n            }\n            \n            if (groups[targetGroup].seatedTime != -1) {\n                return groups[targetGroup].seatedTime - groups[targetGroup].arrivalTime;\n            }\n        }\n        \n        return 0;\n    }\n    \n    static int findSeats(int[] seats, int size) {\n        for (int i = 0; i <= 17 - size; i++) {\n            boolean canSit = true;\n            for (int j = i; j < i + size; j++) {\n                if (seats[j] != -1) {\n                    canSit = false;\n                    break;\n                }\n            }\n            if (canSit) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  int id; int arrivalTime; int size; int eatingTime; int seatedTime; Group(int id) { this.id = id; this.arrivalTime = 5 * id; this.size = (id % 5 == 1) ?  17 * (id % 2) + 3 * (id % 3) + 19; this.seatedTime = -1; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while  sc.nextInt(); System.out.println(simulate(n)); } sc.close(); } static int simulate(int targetGroup) { int[] seats = new int[17]; Arrays.fill(seats, -1); int[] leaveTime = new int[17]; Group[] groups = new Group[100]; for (int  100; i++) { groups[i] =  =  = 0; time <= 10000; time++) { // Step 1: Process departures for (int i  i++) { if (seats[i] != -1 && leaveTime[i]  -1; } } //  queue while (!queue.isEmpty()) { Group g = queue.peek();  if (pos != -1) { queue.poll(); for (int i = pos; i  g.eatingTime; } g.seatedTime = time; }  // Step 3: Process arrivals while (nextGroupToArrive < 100 && groups[nextGroupToArrive].arrivalTime  = groups[nextGroupToArrive]; nextGroupToArrive++; if (queue.isEmpty()) { int pos = findSeats(seats, g.size); if (pos != -1)  pos; i < pos + g.size; i++) { seats[i] = g.id; leaveTime[i] = time + g.eatingTime; } g.seatedTime = time; } else { queue.offer(g); } } else { queue.offer(g); } } if (groups[targetGroup].seatedTime != -1) { return groups[targetGroup].seatedTime - groups[targetGroup].arrivalTime; } } return 0; } static int findSeats(int[] seats, int  = 0; i <= 17 - size; i++) { boolean canSit = true; for (int j = i;  j++) { if  = false; break; } } if (canSit) { return  } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader;  java.util.List; public class Main {  -1; /** \u30b0\u30eb\u30fc\u30d7\u6570 */ private static final int GROUP_NUM = 100; /** \u6a19\u6e96\u5165\u529b */ private  int seatsNum, firstSeatNum; /** \u5230\u7740\u6642\u9593 \u5ba2\u6570 \u98df\u4e8b\u6642\u9593 \u5f85\u3061\u6642\u9593 */ private static int[] arriveMinutes, customersNum, mealMinutes, waitMinutes; /** \u5ea7\u5e2d */ private static String[] seats; /** \u521d\u671f\u5316 */ static { br = new BufferedReader(new InputStreamReader(System.in)); seatsNum = 17; arriveMinutes = new int[GROUP_NUM]; customersNum = new int[GROUP_NUM]; mealMinutes = new int[GROUP_NUM]; waitMinutes = new int[GROUP_NUM]; seats = new String[seatsNum]; for (int i  // \u5230\u7740\u6642\u9593 arriveMinutes[i] = 5 * i; // \u4eba\u6570 customersNum[i] = i % 5 == 1 ? 5 : 2; // \u98df\u4e8b\u6642\u9593 mealMinutes[i] = seatsNum *  * (i % 3) + 19; } // \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210 createWaitMinutes(); } /** \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210\u3059\u308b */ private static void createWaitMinutes() { // \u9806\u756a int groupOrder; // \u884c\u5217\u30ea\u30b9\u30c8 List<Integer> waitList = new ArrayList<Integer>(); // \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8 List<Integer> removeList = new ArrayList<Integer>(); for (int currentMinutes = 0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentMinutes++) { // \u884c\u5217\u304c\u7d42\u4e86\u3059\u308b\u307e\u3067\u3001\u4e00\u5206\u6bce\u306b\u7e70\u308a\u8fd4\u3059 // \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5ba2\u3092\u96e2\u5e2d\u3055\u305b\u308b outCustomer(currentMinutes); if ((groupOrder = searchGroupNum(arriveMinutes, currentMinutes))  if (waitList.isEmpty()) { // \u884c\u5217\u304c\u306a\u3044\u5834\u5408 if  \u5ea7\u5e2d\u306b\u7740\u5e2d\u3055\u305b\u308b setSeat(Integer.toString(groupOrder), totalGroupNum); } else { // \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408 //  { // \u884c\u5217\u304c\u3042\u308b\u5834\u5408 // \u884c\u5217\u306b\u4e26\u3070\u305b\u308b waitList.add(groupOrder); } } if  (int index = 0; index < waitList.size(); index++) { // \u884c\u5217\u30ea\u30b9\u30c8\u5206\u3001\u7e70\u308a\u8fd4\u3059 if (isEmpty(waitList.get(index))) { // \u7740\u5e2d\u53ef\u80fd\u306e\u5834\u5408 // \u5ea7\u5e2d\u306b\u7740\u5e2d\u3055\u305b\u308b setSeat(Integer.toString(waitList.get(index)), totalGroupNum); // \u5f85\u3063\u305f\u6642\u9593\u3092\u8a2d\u5b9a\u3059\u308b  // \u7740\u5e2d\u3057\u305f\u30b0\u30eb\u30fc\u30d7\u3092\u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3059\u308b removeList.add(index); } else { // \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408 // \u884c\u5217\u306e\u5148\u982d\u304c\u7740\u5e2d\u3067\u304d\u306a\u3044\u305f\u3081\u3001\u6b8b\u308a\u306e\u884c\u5217\u3082\u7740\u5e2d\u4e0d\u53ef\u306b\u3059\u308b\u3002 break; } } } if (!removeList.isEmpty()) {  for (int remove : removeList) {  } //  \u30e1\u30a4\u30f3 */ public static void main(String[] args) throws IOException { String line; List<Integer> inputList = new ArrayList<Integer>(); while (!isNull(line = br.readLine()) && !line.isEmpty()) { inputList.add(Integer.parseInt(line)); } for (int input : inputList) { System.out.println(waitMinutes[input]); } }  int searchGroupNum(int[] targets, int currentMinutes) { int order = 0; for (int target : targets) {  return EXEMPT; } /** \u96e2\u5e2d\u3055\u305b\u308b */ private static void outCustomer(int currentMinutes) { for (int seatNum = 0; seatNum < seats.length;  continue; } if (finishedMeal(currentMinutes, seats[seatNum]))  seats[seatNum] =  return param == null; }    + waitMinutes[Integer .parseInt(seat)]) >= mealMinutes[Integer.parseInt(seat)]; }  void setSeat(String groupOrder, int  = 0; count < customersNum[Integer.parseInt(groupOrder)];  \u5ea7\u5e2d\u306b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b seats[firstSeatNum++] = groupOrder; } totalGroupNum++; } /** \u5f15\u6570\u306e\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u306e\u5ba2\u6570\u5206\u3001\u7a7a\u5e2d\u304b\u3069\u3046\u304b\u78ba\u8a8d\u3059\u308b */ private static boolean isEmpty(int groupsNum)  = 0; int i = 0; for (; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) { // \u6b8b\u5ea7\u5e2d\u6570\u304c\u5ba2\u306e\u6570\u4ee5\u4e0b\u306b\u306a\u308b\u307e\u3067\u5ea7\u5e2d\u6570\u5206\u7e70\u308a\u8fd4\u3059 if (isSame(customersNum[groupsNum], emptyseatsNum))  if (isNull(seats[i])) { //  { // \u7a7a\u5e2d\u3067\u306a\u3044\u5834\u5408 // \u7a7a\u5e2d\u6570\u3092\u521d\u671f\u5316 emptyseatsNum = 0; } } if (isSame(customersNum[groupsNum], emptyseatsNum)) { // \u7a7a\u5e2d\u306e\u6700\u521d\u306e\u5ea7\u5e2d\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b firstSeatNum = i - emptyseatsNum; return true; } return false; } /** \u7b2c\u4e00\u5f15\u6570\u3068\u7b2c\u4e8c\u5f15\u6570\u304c\u540c\u3058\u5834\u5408\u3001true\u3092\u8fd4\u3059 */ private static boolean isSame(int param, int target) { return param == target; } }"], "original_ll": -0.9253481030464172, "sampled_ll": -0.5416736602783203, "all_perturbed_sampled_ll": [-1.5495240688323975], "all_perturbed_original_ll": [-1.7291359901428223], "perturbed_sampled_ll": -1.5495240688323975, "perturbed_original_ll": -1.7291359901428223, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0147\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\nfrom collections import deque\ninput = stdin.readline\n\n\nclass Seat():\n    def __init__(self, n):\n        self.seat = '_' * n\n\n    def get(self, num):\n        i = self.seat.find('_'*num)\n        if i != -1:\n            self.seat = self.seat[0:i] + 'o'*num + self.seat[i+num:]\n            return i\n        return None\n\n    def release(self, i, num):\n        self.seat = self.seat[0:i] + '_'*num + self.seat[i+num:]\n\n\ndef solve():\n    waiting_time = [-1] * 100\n    NUM_OF_SEAT = 17\n    seat = Seat(NUM_OF_SEAT)\n    LEAVE = 0\n    COME = 1\n    in_out = []                 #  ??\\?????????????????????????????????\n    Q = deque()                      #  ??\u00a7??????????????????\n    # 100???????????\\????????????????????????\n    for group_id in range(100):\n        if group_id % 5 == 1:\n            num = 5\n        else:\n            num = 2\n        heappush(in_out, (group_id * 5, COME, NUM_OF_SEAT+1, group_id, num))\n\n    while in_out:\n        time, event, start_seat, group_id, num = heappop(in_out)\n        if event == COME:\n            Q.append((time, group_id, num))\n        else:\n            seat.release(start_seat, num)\n        while Q:\n            res = seat.get(Q[0][2])\n            if res is not None:\n                arrive, group_id, num = Q.popleft()\n                waiting_time[group_id] = time - arrive\n                eating_time = 17 * (group_id % 2) + 3*(group_id % 3) + 19\n                heappush(in_out, (time + eating_time, LEAVE, res, group_id, num))\n            else:\n                break\n    return waiting_time\n\n\ndef main(args):\n    waiting_time = solve()\n\n    for line in sys.stdin:\n        print(waiting_time[int(line)])\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    ", "sampled": "import sys\n\ndef solve(n):\n    # Initialize seats (17 seats, -1 means empty)\n    seats = [-1] * 17\n    # Queue of groups waiting\n    queue = []\n    # Dictionary to store group info: arrival_time, size, eat_time, seated_time\n    groups = {}\n    \n    # Generate all 100 groups\n    for i in range(100):\n        arrival = 5 * i\n        size = 5 if i % 5 == 1 else 2\n        eat_time = 17 * (i % 2) + 3 * (i % 3) + 19\n        groups[i] = {\n            'arrival': arrival,\n            'size': size,\n            'eat_time': eat_time,\n            'seated_time': None,\n            'leave_time': None\n        }\n    \n    # Simulate\n    max_time = 5 * 99 + 100  # Safe upper bound\n    \n    for t in range(max_time + 1):\n        # Step 1: Remove groups whose eating time is up\n        for seat_idx in range(17):\n            if seats[seat_idx] != -1:\n                group_id = seats[seat_idx]\n                if groups[group_id]['leave_time'] == t:\n                    seats[seat_idx] = -1\n        \n        # Step 2: Try to seat groups from queue\n        while queue:\n            group_id = queue[0]\n            size = groups[group_id]['size']\n            \n            # Find leftmost position where group can sit\n            seated = False\n            for start in range(18 - size):\n                if all(seats[start + j] == -1 for j in range(size)):\n                    # Seat the group\n                    for j in range(size):\n                        seats[start + j] = group_id\n                    groups[group_id]['seated_time'] = t\n                    groups[group_id]['leave_time'] = t + groups[group_id]['eat_time']\n                    queue.pop(0)\n                    seated = True\n                    break\n            \n            if not seated:\n                break\n        \n        # Step 3: Handle arriving groups\n        for i in range(100):\n            if groups[i]['arrival'] == t:\n                if queue:\n                    # Queue exists, join queue\n                    queue.append(i)\n                else:\n                    # No queue, try to seat directly\n                    size = groups[i]['size']\n                    seated = False\n                    for start in range(18 - size):\n                        if all(seats[start + j] == -1 for j in range(size)):\n                            # Seat the group\n                            for j in range(size):\n                                seats[start + j] = i\n                            groups[i]['seated_time'] = t\n                            groups[i]['leave_time'] = t + groups[i]['eat_time']\n                            seated = True\n                            break\n                    \n                    if not seated:\n                        queue.append(i)\n        \n        # Check if group n has been seated\n        if groups[n]['seated_time'] is not None:\n            wait_time = groups[n]['seated_time'] - groups[n]['arrival']\n            return wait_time\n    \n    return 0\n\n# Read input and process\nfor line in sys.stdin:\n    n = int(line.strip())\n    print(solve(n))\n", "perturbed_sampled": ["import sys  (17 seats, -1 means empty) seats = [-1] * 17 # Queue of groups waiting queue = [] # Dictionary to store group info: arrival_time, size, eat_time, seated_time groups = {} # Generate all 100 groups for i  *  i % 5 == 1 else 2 eat_time = 17 * (i % 2) + 3 *  groups[i] = { 'arrival': arrival, 'size': size, 'eat_time': eat_time, 'seated_time': None, 'leave_time': None  100 # Safe upper bound for t in range(max_time +  is up for seat_idx in range(17): if seats[seat_idx] != -1: group_id = seats[seat_idx] if groups[group_id]['leave_time'] ==  Step  from queue while queue: group_id =  Find leftmost position where group can sit seated = False for start in range(18 - size): if all(seats[start + j] == -1 for j  range(size): seats[start + j] = group_id groups[group_id]['seated_time'] = t groups[group_id]['leave_time'] = t + groups[group_id]['eat_time']  if not seated: break # Step 3: Handle arriving groups for i in range(100): if groups[i]['arrival'] == t: if queue: # Queue exists,  No queue, try to seat directly size  for start in range(18 -  in range(size)): # Seat the group for j in range(size): seats[start + j] = i groups[i]['seated_time'] = t groups[i]['leave_time'] = t + groups[i]['eat_time'] seated = True break if not seated: queue.append(i) # Check if group n has been seated if groups[n]['seated_time'] is not None: wait_time = groups[n]['seated_time'] -  # Read input and process for line in sys.stdin: n = int(line.strip()) print(solve(n))"], "perturbed_original": ["#  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0147 \"\"\" import sys from sys import stdin from heapq import heappop, heappush from collections import  Seat(): def __init__(self, n):  def get(self, num): i = self.seat.find('_'*num) if i != -1: self.seat = self.seat[0:i] + 'o'*num + self.seat[i+num:] return i return None def release(self, i, num): self.seat = self.seat[0:i] + '_'*num + self.seat[i+num:] def solve(): waiting_time = [-1] * 100 NUM_OF_SEAT = 17 seat = Seat(NUM_OF_SEAT) LEAVE = 0 COME = 1 in_out = []  #  in range(100): if group_id % 5 == 1: num = 5  (group_id * 5, COME, NUM_OF_SEAT+1,    Q.append((time, group_id, num)) else: seat.release(start_seat, num) while Q:  is not None: arrive, group_id, num  - arrive eating_time = 17 * (group_id % 2) + 3*(group_id % 3) + 19 heappush(in_out, (time + eating_time, LEAVE, res, group_id, num)) else: break return waiting_time def  line in sys.stdin: print(waiting_time[int(line)]) if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -1.2137213945388794, "sampled_ll": -0.8377719521522522, "all_perturbed_sampled_ll": [-2.045426368713379], "all_perturbed_original_ll": [-2.1490206718444824], "perturbed_sampled_ll": -2.045426368713379, "perturbed_original_ll": -2.1490206718444824, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint a,n,i;\n\tprintf(\"?????\u00a3????????\u00a3????????\u00b0?????\\?????????????????????\",a);\n\tscanf(\"%d\",&a) ;\n\ti=a%39;\n\tif(i==0)\n\t{\n\t\tprintf(\"????????????????????????\");\n\t}\n\telse\n\t{\n\t\tprintf(\"3C%d\\n\",i);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a;\n    while (scanf(\"%d\", &a) != EOF) {\n        int student = a % 39;\n        if (student == 0) {\n            student = 39;\n        }\n        printf(\"3C%02d\\n\", student);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int a; while  int student = a % 39; if (student  39; } printf(\"3C%02d\\n\", student); } return 0; }"], "perturbed_original": ["#include <stdio.h> int  scanf(\"%d\",&a) ; i=a%39; if(i==0) { printf(\"????????????????????????\"); } else { printf(\"3C%d\\n\",i); } return 0; }"], "original_ll": -2.141200065612793, "sampled_ll": -1.0620944499969482, "all_perturbed_sampled_ll": [-2.8520820140838623], "all_perturbed_original_ll": [-2.6509804725646973], "perturbed_sampled_ll": -2.8520820140838623, "perturbed_original_ll": -2.6509804725646973, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tSystem.out.printf(\"3C%01d\\n\",(sc.nextInt())%39);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int candies = sc.nextInt();\n            int studentNumber = candies % 39;\n            \n            if (studentNumber == 0) {\n                studentNumber = 39;\n            }\n            \n            System.out.printf(\"3C%02d%n\", studentNumber);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int candies = sc.nextInt(); int studentNumber = candies % 39; if (studentNumber == 0) {  studentNumber); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) {  while(sc.hasNext()){ System.out.printf(\"3C%01d\\n\",(sc.nextInt())%39); } } }"], "original_ll": -1.4276636838912964, "sampled_ll": -1.0039668083190918, "all_perturbed_sampled_ll": [-2.0817644596099854], "all_perturbed_original_ll": [-2.401944875717163], "perturbed_sampled_ll": -2.0817644596099854, "perturbed_original_ll": -2.401944875717163, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "try:\n    while True:\n        ame = int(input())\n        num1 = ame % 39\n        if num1 == 0:\n            num1 = 39\n        if num1 < 10:\n            print(\"3C0\" + str(num1))\n        else:\n            print(\"3C\" + str(num1))\nexcept EOFError as e:\n    num = 0\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    a = int(line.strip())\n    student = a % 39\n    if student == 0:\n        student = 39\n    print(f\"3C{student:02d}\")\n", "perturbed_sampled": ["import sys for line in sys.stdin:  a % 39 if student == 0: student = 39 print(f\"3C{student:02d}\")"], "perturbed_original": ["try: while True:  ame % 39 if num1 ==  num1 < 10: print(\"3C0\" + str(num1)) else: print(\"3C\" + str(num1)) except EOFError as e: num = 0"], "original_ll": -1.33604896068573, "sampled_ll": -1.728090763092041, "all_perturbed_sampled_ll": [-3.8039894104003906], "all_perturbed_original_ll": [-2.9388155937194824], "perturbed_sampled_ll": -3.8039894104003906, "perturbed_original_ll": -2.9388155937194824, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint rn[4], ln[4];\n\nint main(void)\n{\n\tdouble right, left;\n\tdouble EPS;\n\tint i;\n\t\n\tEPS = 1e-8;\n\t\n\twhile (scanf(\"%lf %lf\", &right, &left) != EOF){\n\t\t\n\t\tif (right >= 1.1){\n\t\t\trn[0]++;\n\t\t}\n\t\telse if (right >= 0.6){\n\t\t\trn[1]++;\n\t\t}\n\t\telse if(right >= 0.2){\n\t\t\trn[2]++;\n\t\t}\n\t\telse {\n\t\t\trn[3]++;\n\t\t}\n\t\tif (left >= 1.1){\n\t\t\tln[0]++;\n\t\t}\n\t\telse if (left >= 0.6){\n\t\t\tln[1]++;\n\t\t}\n\t\telse if(left >= 0.2){\n\t\t\tln[2]++;\n\t\t}\n\t\telse {\n\t\t\tln[3]++;\n\t\t}\n\t}\n\tfor (i = 0; i < 4; i++){\n\t\tprintf(\"%d %d\\n\", rn[i], ln[i]);\n\t}\n\treturn (0);\n}\n\t\t\t", "sampled": "#include <stdio.h>\n\nint main() {\n    double l, r;\n    int countA_L = 0, countA_R = 0;\n    int countB_L = 0, countB_R = 0;\n    int countC_L = 0, countC_R = 0;\n    int countD_L = 0, countD_R = 0;\n    \n    while (scanf(\"%lf %lf\", &l, &r) == 2) {\n        // Left eye\n        if (l >= 1.1) {\n            countA_L++;\n        } else if (l >= 0.6) {\n            countB_L++;\n        } else if (l >= 0.2) {\n            countC_L++;\n        } else {\n            countD_L++;\n        }\n        \n        // Right eye\n        if (r >= 1.1) {\n            countA_R++;\n        } else if (r >= 0.6) {\n            countB_R++;\n        } else if (r >= 0.2) {\n            countC_R++;\n        } else {\n            countD_R++;\n        }\n    }\n    \n    printf(\"%d %d\\n\", countA_L, countA_R);\n    printf(\"%d %d\\n\", countB_L, countB_R);\n    printf(\"%d %d\\n\", countC_L, countC_R);\n    printf(\"%d %d\\n\", countD_L, countD_R);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double l, r;  = 0, countB_R = 0; int countC_L = 0, countC_R = 0; int countD_L = 0, countD_R = 0; while (scanf(\"%lf %lf\", &l, &r) == 2) { // Left eye  (l >= 0.6) { countB_L++; } else if (l >= 0.2) { countC_L++; } else { countD_L++; }  >= 1.1) {  >= 0.6) { countB_R++; } else if (r >= 0.2) { countC_R++; } else  %d\\n\", countA_L, countA_R); printf(\"%d %d\\n\", countB_L, countB_R); printf(\"%d %d\\n\", countC_L, countC_R); printf(\"%d %d\\n\", countD_L, countD_R); return 0; }"], "perturbed_original": ["#include <stdio.h>  { double right, left; double EPS; int i;  %lf\", &right, &left) != EOF){ if (right >= 1.1){ rn[0]++; } else if (right >= 0.6){ rn[1]++; } else if(right >= 0.2){ rn[2]++; } else { rn[3]++; } if (left >= 1.1){ ln[0]++; } else if  else if(left >= 0.2){ ln[2]++; } else { ln[3]++; } } for (i = 0;   (0); }"], "original_ll": -0.7815167903900146, "sampled_ll": -0.3809066414833069, "all_perturbed_sampled_ll": [-1.1250104904174805], "all_perturbed_original_ll": [-1.8625956773757935], "perturbed_sampled_ll": -1.1250104904174805, "perturbed_original_ll": -1.8625956773757935, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tScanner sc;\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner (System.in);\n\t\t\n\t\tint[][] num=new int[4][2];\n\t\tfor(int[] e:num)Arrays.fill(e,0);\n\t\tint side=0;\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tdouble eye=nd();\n\t\t\tif(eye>=1.1) ++num[0][side];\n\t\t\telse if(eye>=0.6) ++num[1][side];\n\t\t\telse if(eye>=0.2) ++num[2][side];\n\t\t\telse ++num[3][side];\n\t\t\tside^=1;\n\t\t}\n\t\tfor(int i=0;i<4;++i)System.out.println(num[i][0]+\" \"+num[i][1]);\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int[] leftCount = new int[4];\n        int[] rightCount = new int[4];\n        \n        while (sc.hasNext()) {\n            double left = sc.nextDouble();\n            double right = sc.nextDouble();\n            \n            leftCount[getCategory(left)]++;\n            rightCount[getCategory(right)]++;\n        }\n        \n        for (int i = 0; i < 4; i++) {\n            System.out.println(leftCount[i] + \" \" + rightCount[i]);\n        }\n        \n        sc.close();\n    }\n    \n    private static int getCategory(double vision) {\n        if (vision >= 1.1) {\n            return 0; // A\n        } else if (vision >= 0.6) {\n            return 1; // B\n        } else if (vision >= 0.2) {\n            return 2; // C\n        } else {\n            return 3; // D\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  void main(String[] args) { Scanner sc = new Scanner(System.in); int[] leftCount = new int[4]; int[] rightCount = new int[4]; while (sc.hasNext())  double right = sc.nextDouble(); leftCount[getCategory(left)]++; rightCount[getCategory(right)]++; } for (int i =  { System.out.println(leftCount[i] + \" \" + rightCount[i]); }  (vision >= 1.1)  } else if (vision >= 0.6) { return 1; // B } else if (vision >= 0.2) { return 2; // C } else { return 3; // D } } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { Scanner sc; double nd(){ return sc.nextDouble(); } void io(){ sc=new Scanner  e:num)Arrays.fill(e,0); int side=0; while(sc.hasNext()){ double eye=nd(); if(eye>=1.1) ++num[0][side]; else if(eye>=0.6)  ++num[3][side];  sc.close(); } public static void main(String[] args) { // TODO Auto-generated method stub new Main().io(); } }"], "original_ll": -1.0694659948349, "sampled_ll": -0.4807198941707611, "all_perturbed_sampled_ll": [-1.5418281555175781], "all_perturbed_original_ll": [-2.3815741539001465], "perturbed_sampled_ll": -1.5418281555175781, "perturbed_original_ll": -2.3815741539001465, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "c = [1.1,0.6,0.2,0.0]\nr = [0,0,0,0,0,0,0,0]\nwhile 1:\n    try:\n        e = map(float, raw_input().split())\n        for i in range(2):\n            for j in range(4):\n                if e[i] >= c[j]:\n                \tr[i+2*j] += 1\n                \tbreak\n    except:\n        break\nfor i in range(0,8,2):\n\tprint r[i],r[i+1]", "sampled": "import sys\n\ndef classify(vision):\n    if vision >= 1.1:\n        return 'A'\n    elif vision >= 0.6:\n        return 'B'\n    elif vision >= 0.2:\n        return 'C'\n    else:\n        return 'D'\n\nleft_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0}\nright_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0}\n\nfor line in sys.stdin:\n    l, r = map(float, line.strip().split())\n    left_count[classify(l)] += 1\n    right_count[classify(r)] += 1\n\nprint(left_count['A'], right_count['A'])\nprint(left_count['B'], right_count['B'])\nprint(left_count['C'], right_count['C'])\nprint(left_count['D'], right_count['D'])\n", "perturbed_sampled": ["import sys def classify(vision): if vision   elif vision >= 0.2: return 'C' else: return 'D' left_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0} right_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0}  r =  right_count[classify(r)] += 1 print(left_count['A'], right_count['A']) print(left_count['B'], right_count['B']) print(left_count['C'], right_count['C']) print(left_count['D'], right_count['D'])"], "perturbed_original": ["c = [1.1,0.6,0.2,0.0] r = [0,0,0,0,0,0,0,0] while 1: try: e = map(float, raw_input().split()) for i in range(2): for j in<extra_id_3>r[0,8,2],<extra_id_4>for j break except: break for i in range(0,8,2): print r[i],r[i+1]"], "original_ll": -1.1868014335632324, "sampled_ll": -0.5989325642585754, "all_perturbed_sampled_ll": [-1.3618037700653076], "all_perturbed_original_ll": [-2.2604353427886963], "perturbed_sampled_ll": -1.3618037700653076, "perturbed_original_ll": -2.2604353427886963, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "m[4][65536],i,l,L,p,c;main(n){for(;~scanf(\"%d\\n\",&n);L=n&&!printf(\"%d\\n\",L))for(p=255;++p<256-~n*n;)for(c=getchar(i=4);i--;L=l>L?l:L)l=m[i][p]=c-49?0:m[i][p-(i?n+i-1:1)]+1;}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    char grid[256][256];\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        for(int i = 0; i < n; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        int max_count = 0;\n        \n        // Check horizontal\n        for(int i = 0; i < n; i++) {\n            int count = 0;\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n            }\n        }\n        \n        // Check vertical\n        for(int j = 0; j < n; j++) {\n            int count = 0;\n            for(int i = 0; i < n; i++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n            }\n        }\n        \n        // Check diagonal (top-left to bottom-right)\n        // Starting from first row\n        for(int start_col = 0; start_col < n; start_col++) {\n            int count = 0;\n            int i = 0, j = start_col;\n            while(i < n && j < n) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j++;\n            }\n        }\n        // Starting from first column (excluding 0,0)\n        for(int start_row = 1; start_row < n; start_row++) {\n            int count = 0;\n            int i = start_row, j = 0;\n            while(i < n && j < n) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j++;\n            }\n        }\n        \n        // Check diagonal (top-right to bottom-left)\n        // Starting from first row\n        for(int start_col = 0; start_col < n; start_col++) {\n            int count = 0;\n            int i = 0, j = start_col;\n            while(i < n && j >= 0) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j--;\n            }\n        }\n        // Starting from last column (excluding 0,n-1)\n        for(int start_row = 1; start_row < n; start_row++) {\n            int count = 0;\n            int i = start_row, j = n - 1;\n            while(i < n && j >= 0) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j--;\n            }\n        }\n        \n        printf(\"%d\\n\", max_count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; char grid[256][256]; while(scanf(\"%d\", &n) == 1 && n != 0) { for(int i = 0; i < n; i++) { scanf(\"%s\", grid[i]); } int max_count = 0; // Check  i < n; i++) { int count = 0; for(int j = 0; j  == '1')  max_count = count; } else { count = 0; } } } // Check vertical for(int j = 0; j < n; j++) { int count = 0; for(int i = 0; i < n; i++) { if(grid[i][j] == '1') { count++; if(count > max_count) max_count = count; } else { count = 0; } } } // Check diagonal (top-left to bottom-right) //  start_col = 0; start_col < n; start_col++) { int count = 0; int i = 0, j = start_col; while(i <  { if(grid[i][j] == '1')  max_count = count; } else { count = 0; } i++; j++; } } //  0,0) for(int start_row = 1; start_row < n; start_row++) { int count = 0; int i = start_row, j = 0;  <   else  // Check diagonal (top-right to bottom-left) // Starting from first  start_col < n; start_col++)  int i =  < n && j >= 0) {  if(count > max_count) max_count = count; } else { count = 0; }  Starting from last column (excluding 0,n-1) for(int start_row = 1; start_row < n; start_row++) { int count  - 1; while(i <  { if(grid[i][j] == '1') { count++; if(count >  else { count = 0; } i++; j--; } } printf(\"%d\\n\", max_count); } return 0; }"], "perturbed_original": ["m[4][65536],i,l,L,p,c;main(n){for(;~scanf(\"%d\\n\",&n);L=n&&!printf(\"%d\\n\",L))for(p=255;++p<256-~n*n;)for(c=getchar(i=4);i--;L=l>L?l:L)l=m[i][p]=c-49?0:m[i][p-(i?n+i-1:1)]+1;}"], "original_ll": -2.8749964237213135, "sampled_ll": -0.2009437382221222, "all_perturbed_sampled_ll": [-1.113058090209961], "all_perturbed_original_ll": [-2.8749964237213135], "perturbed_sampled_ll": -1.113058090209961, "perturbed_original_ll": -2.8749964237213135, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] map = new boolean[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tchar[] ch = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tmap[i][j] = ch[j] == '1';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(map[i][j] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(map[j][i] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j <= i; j++){\n\t\t\t\t\t//System.out.print(\"( \" + (i - j) +\" \" + j + \") \");\n\t\t\t\t\tif(map[i - j][j] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = n - 1; j >= i; j--){\n\t\t\t\t\t//System.out.print(\"( \" + j +\" \" + (j - i) + \") \");\n\t\t\t\t\tif(map[j][j-i] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < (n - i) ; j++){\n\t\t\t\t\t//System.out.print(\"( \" + (j) +\" \" + (i+j) + \") \");\n\t\t\t\t\tif(map[j][i+j] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < (n - i); j++){\n\t\t\t\t\t//System.out.print(\"( \" + (i + j) +\" \" + (i) + \") \");\n\t\t\t\t\tif(map[i+j][i] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[][] grid = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                String line = sc.next();\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = line.charAt(j) - '0';\n                }\n            }\n            \n            int maxConsecutive = 0;\n            \n            // Check horizontal\n            for (int i = 0; i < n; i++) {\n                int count = 0;\n                for (int j = 0; j < n; j++) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n            }\n            \n            // Check vertical\n            for (int j = 0; j < n; j++) {\n                int count = 0;\n                for (int i = 0; i < n; i++) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n            }\n            \n            // Check diagonal (top-left to bottom-right)\n            for (int start = 0; start < n; start++) {\n                // Starting from first row\n                int count = 0;\n                for (int i = 0, j = start; i < n && j < n; i++, j++) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n                \n                // Starting from first column (skip 0,0 as it's already covered)\n                if (start > 0) {\n                    count = 0;\n                    for (int i = start, j = 0; i < n && j < n; i++, j++) {\n                        if (grid[i][j] == 1) {\n                            count++;\n                            maxConsecutive = Math.max(maxConsecutive, count);\n                        } else {\n                            count = 0;\n                        }\n                    }\n                }\n            }\n            \n            // Check diagonal (top-right to bottom-left)\n            for (int start = 0; start < n; start++) {\n                // Starting from first row\n                int count = 0;\n                for (int i = 0, j = start; i < n && j >= 0; i++, j--) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n                \n                // Starting from last column (skip top-right corner as it's already covered)\n                if (start > 0) {\n                    count = 0;\n                    for (int i = start, j = n - 1; i < n && j >= 0; i++, j--) {\n                        if (grid[i][j] == 1) {\n                            count++;\n                            maxConsecutive = Math.max(maxConsecutive, count);\n                        } else {\n                            count = 0;\n                        }\n                    }\n                }\n            }\n            \n            System.out.println(maxConsecutive);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main {  { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n ==  new int[n][n]; for (int i = 0; i <   = 0; j < n; j++) { grid[i][j] = line.charAt(j) - '0'; } } int maxConsecutive = 0; // Check horizontal for (int i = 0; i < n; i++) { int count = 0; for (int j = 0; j  (grid[i][j] == 1) { count++; maxConsecutive = Math.max(maxConsecutive, count); } else {  } // Check vertical for (int j = 0;   (int i = 0; i < n; i++)  { count++; maxConsecutive = Math.max(maxConsecutive, count);  // Check diagonal (top-left to bottom-right) for (int start = 0; start < n; start++) { // Starting from first row int count = 0; for (int i = 0, j = start; i  n; i++, j++) { if (grid[i][j]  else { count = 0; } } // Starting from first column (skip 0,0 as it's already covered) if (start > 0) { count = 0; for (int i = start, j = 0; i < n && j < n; i++, j++) { if (grid[i][j] == 1) { count++; maxConsecutive = Math.max(maxConsecutive, count);    = 0; start <  from  0; for (int i = 0, j  && j  if  maxConsecutive = Math.max(maxConsecutive, count); } else { count = 0; } } // Starting from last column (skip top-right corner as it's already covered) if (start > 0) { count = 0; for (int i  - 1; i < n && j >= 0; i++, j--) { if (grid[i][j] == 1) { count++; maxConsecutive = Math.max(maxConsecutive, count); } else { count = 0; } } } } System.out.println(maxConsecutive); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.LinkedList; import java.util.List; import java.util.Scanner; public class  main(String[] args) { Scanner sc = new Scanner(System.in); while(true){ final int n =  } boolean[][] map = new boolean[n][n]; for(int i = 0; i < n; i++){  j = 0; j < n; j++){ map[i][j] = ch[j] == '1'; } } int max = 0; for(int i =  int count = 0; for(int  true){ count++; } }  for(int i = 0; i < n; i++){ int  = 0; j < n; j++){ if(map[j][i] == true){ count++; } } max = Math.max(max, count); } for(int i =  int count =  j <= i; j++){ //System.out.print(\"( \" + (i - j) +\" \" + j + \") \"); if(map[i - j][j] == true){ count++; } } //System.out.println();  for(int i  0; for(int j = n - 1; j >= i; j--){ //System.out.print(\"( \" + j +\" \" + (j - i) + \") \"); if(map[j][j-i] == true){ count++; } } //System.out.println();  for(int i = 0; i < n; i++){ int count = 0; for(int j = 0; j < (n - i) ; j++){  \" + (i+j) + \") \"); if(map[j][i+j] == true){ count++; } } //System.out.println(); max = Math.max(max, count); } for(int i = 0; i < n;  for(int j = 0; j < (n - i); j++){  (i) + \") \"); if(map[i+j][i] == true){ count++; } }  } System.out.println(max); } } }"], "original_ll": -0.3178330659866333, "sampled_ll": -0.2092655748128891, "all_perturbed_sampled_ll": [-1.044170618057251], "all_perturbed_original_ll": [-1.1424996852874756], "perturbed_sampled_ll": -1.044170618057251, "perturbed_original_ll": -1.1424996852874756, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def ge(n):\n    for i in xrange(n):\n        yield [(i,j) for j in xrange(n)]\n        yield [(j,i) for j in xrange(n)]\n        yield [(i-j,j) for j in xrange(i+1)]\n        yield [(n-i+j-1,n-j-1) for j in xrange(i+1)]\n\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    A = [map(int,list(raw_input())) for _ in xrange(n)]\n    print max(sum(map(lambda (i,j): A[i][j], p)) for p in ge(n))", "sampled": "def count_consecutive(line):\n    max_count = 0\n    current_count = 0\n    for char in line:\n        if char == '1':\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n    return max_count\n\ndef solve(n, grid):\n    max_consecutive = 0\n    \n    # Check horizontal\n    for row in grid:\n        max_consecutive = max(max_consecutive, count_consecutive(row))\n    \n    # Check vertical\n    for col in range(n):\n        column = ''.join(grid[row][col] for row in range(n))\n        max_consecutive = max(max_consecutive, count_consecutive(column))\n    \n    # Check diagonals (top-left to bottom-right)\n    # Diagonals starting from first row\n    for start_col in range(n):\n        diagonal = ''.join(grid[i][start_col + i] for i in range(n - start_col))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    # Diagonals starting from first column (excluding top-left corner)\n    for start_row in range(1, n):\n        diagonal = ''.join(grid[start_row + i][i] for i in range(n - start_row))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    # Check diagonals (top-right to bottom-left)\n    # Diagonals starting from first row\n    for start_col in range(n):\n        diagonal = ''.join(grid[i][start_col - i] for i in range(start_col + 1))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    # Diagonals starting from last column (excluding top-right corner)\n    for start_row in range(1, n):\n        diagonal = ''.join(grid[start_row + i][n - 1 - i] for i in range(n - start_row))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    return max_consecutive\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    grid = []\n    for _ in range(n):\n        grid.append(input().strip())\n    \n    result = solve(n, grid)\n    print(result)\n", "perturbed_sampled": ["def count_consecutive(line): max_count = 0 current_count = 0 for char in line: if char == '1': current_count += 1 max_count = max(max_count, current_count) else: current_count =  grid): max_consecutive = 0 # Check horizontal for row in grid: max_consecutive = max(max_consecutive, count_consecutive(row)) # Check vertical for  range(n)) max_consecutive = max(max_consecutive, count_consecutive(column))  bottom-right) # Diagonals starting from first row for  ''.join(grid[i][start_col + i] for i in range(n - start_col)) max_consecutive = max(max_consecutive, count_consecutive(diagonal)) # Diagonals starting from first column (excluding top-left corner) for start_row in range(1, n): diagonal = ''.join(grid[start_row + i][i] for i  = max(max_consecutive, count_consecutive(diagonal)) # Check diagonals (top-right to bottom-left) # Diagonals starting from first row for start_col in range(n): diagonal = ''.join(grid[i][start_col - i] for i in range(start_col + 1))  Diagonals starting from last column (excluding top-right corner)  diagonal = ''.join(grid[start_row + i][n - 1 - i] for i in range(n  break grid = [] for _ in range(n): grid.append(input().strip()) result = solve(n, grid) print(result)"], "perturbed_original": ["def  yield [(i,j) for j in xrange(n)] yield [(j,i) for j in xrange(n)] yield [(i-j,j) for j  j in xrange(i+1)] while True: n = input() if n == 0: break A = [map(int,list(raw_input()))  max(sum(map(lambda (i,j): A[i][j], p)) for p in ge(n))"], "original_ll": -1.1642400026321411, "sampled_ll": -0.32120296359062195, "all_perturbed_sampled_ll": [-1.3590753078460693], "all_perturbed_original_ll": [-2.2834835052490234], "perturbed_sampled_ll": -1.3590753078460693, "perturbed_original_ll": -2.2834835052490234, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\ntypedef struct{\n\tint no;\n\tint score;\n} Info;\n\nvoid sortInfo(int n,Info t[]){\n\tint i,j;\n\tfor(i=0;i<n-1;i++){\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tif(t[i].score < t[j].score ||\n\t\t\t   t[i].score == t[j].score && t[i].no > t[j].no){\n\t\t\t\tInfo tmp = t[i];\n\t\t\t\tt[i] = t[j];\n\t\t\t\tt[j] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint scoring(void){\n\tint i, x, total, frame, time, sum, flgSpare, flgStrike;\n\t\n\ttotal = sum = 0;\n\tframe = time = 1;\n\tflgSpare = flgStrike = 0;\n\t\n\twhile(frame < 10){\n\t\tscanf(\"%d\",&x);\n\t\tsum += x;\n\t\t\n\t\tif(flgSpare){\n\t\t\ttotal += x;\n\t\t\tflgSpare = 0;\n\t\t}\n\t\telse if(flgStrike){\n\t\t\tif(flgStrike == 3){\n\t\t\t\ttotal += x;\n\t\t\t\tflgStrike--;\n\t\t\t}\n\t\t\ttotal += x;\n\t\t\tflgStrike--;\n\t\t}\n\t\t\n\t\tif(time == 2){\n\t\t\ttotal += sum;\n\t\t\tif(sum == 10){\n\t\t\t\tflgSpare = 1;\n\t\t\t}\n\t\t\tsum = 0;\n\t\t\ttime = 1;\n\t\t\tframe++;\n\t\t}\n\t\telse if(time == 1){\n\t\t\ttime++;\n\t\t\tif(x == 10){\n\t\t\t\ttotal += 10;\n\t\t\t\tflgStrike += 2;\n\t\t\t\tsum = 0;\n\t\t\t\ttime = 1;\n\t\t\t\tframe++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0;i<3;i++){\n\t\tif(i == 2 && sum < 10) break;\n\t\t\n\t\tscanf(\"%d\",&x);\n\t\ttotal += x;\n\t\tsum += x;\n\t\t\n\t\tif(flgSpare){\n\t\t\ttotal += x;\n\t\t\tflgSpare = 0;\n\t\t}\n\t\telse if(flgStrike){\n\t\t\tif(flgStrike == 3){\n\t\t\t\ttotal += x;\n\t\t\t\tflgStrike--;\n\t\t\t}\n\t\t\ttotal += x;\n\t\t\tflgStrike--;\n\t\t}\n\t}\n\n\treturn total;\n}\n\nint main(void){\n\tint i, n;\n\tInfo info[40];\n\t\n\twhile(scanf(\"%d\",&n) && n){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&info[i].no);\n\t\t\tinfo[i].score = scoring();\n\t\t}\n\t\tsortInfo(n,info);\n\t\tfor(i=0;i<n;i++){\n\t\t\tprintf(\"%d %d\\n\",info[i].no,info[i].score);\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int score;\n} Player;\n\nint calculate_score(int pins[], int n) {\n    int total = 0;\n    int pin_idx = 0;\n    \n    for (int frame = 0; frame < 10; frame++) {\n        if (frame < 9) {\n            if (pins[pin_idx] == 10) { // Strike\n                total += 10 + pins[pin_idx + 1] + pins[pin_idx + 2];\n                pin_idx++;\n            } else if (pins[pin_idx] + pins[pin_idx + 1] == 10) { // Spare\n                total += 10 + pins[pin_idx + 2];\n                pin_idx += 2;\n            } else {\n                total += pins[pin_idx] + pins[pin_idx + 1];\n                pin_idx += 2;\n            }\n        } else { // 10th frame\n            total += pins[pin_idx] + pins[pin_idx + 1];\n            if (pins[pin_idx] == 10 || pins[pin_idx] + pins[pin_idx + 1] == 10) {\n                total += pins[pin_idx + 2];\n            }\n        }\n    }\n    \n    return total;\n}\n\nint compare_players(const void *a, const void *b) {\n    Player *pa = (Player *)a;\n    Player *pb = (Player *)b;\n    \n    if (pa->score != pb->score) {\n        return pb->score - pa->score; // Higher score first\n    }\n    return pa->id - pb->id; // Lower ID first\n}\n\nint main() {\n    int m;\n    \n    while (scanf(\"%d\", &m) == 1 && m != 0) {\n        Player players[40];\n        \n        for (int i = 0; i < m; i++) {\n            int id;\n            int pins[21];\n            int n = 0;\n            \n            scanf(\"%d\", &id);\n            \n            while (n < 21) {\n                if (scanf(\"%d\", &pins[n]) != 1) break;\n                n++;\n                \n                // Check if we should stop reading (peek next character)\n                int c = getchar();\n                if (c == '\\n' || c == EOF) {\n                    ungetc(c, stdin);\n                    break;\n                }\n                ungetc(c, stdin);\n            }\n            \n            players[i].id = id;\n            players[i].score = calculate_score(pins, n);\n        }\n        \n        qsort(players, m, sizeof(Player), compare_players);\n        \n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", players[i].id, players[i].score);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int id; int score; } Player; int   pin_idx = 0; for (int frame = 0; frame < 10; frame++)  {  // Strike total += 10  pins[pin_idx + 2]; pin_idx++; } else if (pins[pin_idx] + pins[pin_idx + 1] == 10) { // Spare total += 10 + pins[pin_idx + 2]; pin_idx += 2; } else { total += pins[pin_idx] + pins[pin_idx + 1]; pin_idx += 2; } } else { // 10th frame total += pins[pin_idx] + pins[pin_idx + 1]; if (pins[pin_idx] == 10 || pins[pin_idx] + pins[pin_idx + 1] == 10)  return total; } int compare_players(const void *a, const void *b) { Player *pa = (Player *)a; Player *pb =   pa->score; // Higher score first } return pa->id - pb->id; // Lower ID first } int main()  &m) == 1 && m != 0) { Player players[40]; for (int i = 0; i < m; i++) { int  while (n < 21) { if (scanf(\"%d\", &pins[n]) != 1) break; n++; // Check if we should stop reading (peek next character) int c = getchar(); if (c == '\\n' || c ==  players[i].id = id; players[i].score = calculate_score(pins, n); } qsort(players, m, sizeof(Player), compare_players); for  printf(\"%d %d\\n\",  0; }"], "perturbed_original": [" no; int score; } Info;  i,j; for(i=0;i<n-1;i++){ for(j=i+1;j<n;j++){ if(t[i].score <  && t[i].no > t[j].no){ Info tmp = t[i]; t[i] = t[j]; t[j] = tmp; } } } } int scoring(void){ int i, x,  flgStrike; total = sum = 0; frame = time = 1; flgSpare = flgStrike = 0; while(frame < 10){  total += x; flgSpare = 0; }  total += x; flgStrike--; } total += x; flgStrike--; } if(time == 2){ total += sum; if(sum == 10){ flgSpare = 1; } sum = 0; time = 1; frame++; } else if(time  10){ total += 10; flgStrike += 2; sum = 0;  }  && sum < 10) break; scanf(\"%d\",&x); total += x; sum  x; flgSpare = 0; } else if(flgStrike){ if(flgStrike == 3){ total += x; flgStrike--; } total += x; flgStrike--; }  main(void){ int i, n; Info  scanf(\"%d\",&info[i].no); info[i].score = scoring(); } sortInfo(n,info); for(i=0;i<n;i++){ printf(\"%d %d\\n\",info[i].no,info[i].score); } } return 0; }"], "original_ll": -0.6524258852005005, "sampled_ll": -0.4492418169975281, "all_perturbed_sampled_ll": [-1.4217394590377808], "all_perturbed_original_ll": [-1.63300359249115], "perturbed_sampled_ll": -1.4217394590377808, "perturbed_original_ll": -1.63300359249115, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass score implements Comparable<score> {\n\t\tString id;\n\t\tint s;\n\n\t\tscore(Scanner sc) {\n\t\t\tid = sc.next();\n\t\t\tint f = 0;\n\t\t\tint x1 = 0;\n\t\t\tint x2 = 0;\n\t\t\tint c = 0;\n\t\t\tint q = 0;\n\t\t\tint e = 0;\n\t\t\ts = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif(f == 9 && e == 1 && c==3){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(f == 9 && e == 0 && c==2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (x1 > 0) {\n\t\t\t\t\tx1--;\n\t\t\t\t\ts+=v;\n\t\t\t\t}\n\t\t\t\tif (x2 > 0) {\n\t\t\t\t\tx2--;\n\t\t\t\t\tx1++;\n\t\t\t\t\ts+=v;\n\t\t\t\t}\n\t\t\t\ts+=v;\n//\t\t\t\tSystem.out.println(s);\n\t\t\t\tif (f == 9) {\n\t\t\t\t\tif(c==0){\n\t\t\t\t\t\tif(v==10){\n\t\t\t\t\t\t\te=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq=v;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}else if(c== 1 && q+v==10){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t} else if (v == 10) {\n\t\t\t\t\tx2 += 1;\n\t\t\t\t\tc = 0;\n\t\t\t\t\tq=0;\n\t\t\t\t\tf++;\n\t\t\t\t} else if (q + v == 10) {\n\t\t\t\t\tx1 += 1;\n\t\t\t\t\tc = 0;\n\t\t\t\t\tq=0;\n\t\t\t\t\tf++;\n\t\t\t\t} else if (c == 1) {\n\t\t\t\t\tc = 0;\n\t\t\t\t\tq=0;\n\t\t\t\t\tf++;\n\t\t\t\t} else {\n\t\t\t\t\tq = v;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(score arg0) {\n\t\t\tint a;\n\t\t\ta = arg0.s - s;\n\t\t\tif (a == 0) {\n\t\t\t\ta = id.compareTo(arg0.id);\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tscore[] c = new score[n];\n\t\t\tfor(int i =0;i<n;i++){\n\t\t\t//\tSystem.out.println(i);\n\t\t\t\tc[i] = new score(sc);\n\t\t\t}\n\t\t\tArrays.sort(c);\n\t\t\t\n\t\t\tfor(int i =0 ; i < n;i++){\n\t\t\t\tSystem.out.println(c[i].id+\" \"+c[i].s);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Player implements Comparable<Player> {\n        int id;\n        int score;\n        \n        public Player(int id, int score) {\n            this.id = id;\n            this.score = score;\n        }\n        \n        @Override\n        public int compareTo(Player other) {\n            if (this.score != other.score) {\n                return other.score - this.score;\n            }\n            return this.id - other.id;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            if (m == 0) break;\n            \n            List<Player> players = new ArrayList<>();\n            \n            for (int i = 0; i < m; i++) {\n                int id = sc.nextInt();\n                List<Integer> rolls = new ArrayList<>();\n                \n                String line = sc.nextLine().trim();\n                String[] tokens = line.split(\"\\\\s+\");\n                for (String token : tokens) {\n                    rolls.add(Integer.parseInt(token));\n                }\n                \n                int score = calculateScore(rolls);\n                players.add(new Player(id, score));\n            }\n            \n            Collections.sort(players);\n            \n            for (Player p : players) {\n                System.out.println(p.id + \" \" + p.score);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static int calculateScore(List<Integer> rolls) {\n        int score = 0;\n        int rollIndex = 0;\n        \n        for (int frame = 0; frame < 10; frame++) {\n            if (frame < 9) {\n                if (rolls.get(rollIndex) == 10) {\n                    score += 10 + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);\n                    rollIndex++;\n                } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) {\n                    score += 10 + rolls.get(rollIndex + 2);\n                    rollIndex += 2;\n                } else {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1);\n                    rollIndex += 2;\n                }\n            } else {\n                if (rolls.get(rollIndex) == 10) {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);\n                    rollIndex += 3;\n                } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);\n                    rollIndex += 3;\n                } else {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1);\n                    rollIndex += 2;\n                }\n            }\n        }\n        \n        return score;\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  class Player implements Comparable<Player> { int id; int score; public Player(int id, int score) { this.id = id; this.score = score; } @Override public int compareTo(Player other) { if (this.score != other.score) { return other.score - this.score;  } } public   while (true) { int m = sc.nextInt(); if (m == 0) break; List<Player>  (int i = 0;  int id = sc.nextInt(); List<Integer> rolls = new ArrayList<>(); String line = sc.nextLine().trim(); String[] tokens = line.split(\"\\\\s+\"); for (String token  int score = calculateScore(rolls); players.add(new Player(id, score)); } Collections.sort(players); for (Player p : players) { System.out.println(p.id + \" \" + p.score); } } sc.close(); } static int calculateScore(List<Integer> rolls) { int score = 0;  (int frame = 0; frame < 10; frame++) { if (frame < 9) { if (rolls.get(rollIndex) == 10) { score += 10 + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2); rollIndex++; } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) { score += 10 + rolls.get(rollIndex + 2); rollIndex += 2; } else { score += rolls.get(rollIndex) + rolls.get(rollIndex + 1);  else { if (rolls.get(rollIndex)  rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2); rollIndex +=   rolls.get(rollIndex) + rolls.get(rollIndex +  rollIndex  score +=  rollIndex += 2; }  }"], "perturbed_original": ["import java.util.*; import java.lang.*; import java.math.*; public  = new Scanner(System.in); class score implements Comparable<score> { String id; int s; score(Scanner sc) { id = sc.next(); int f = 0; int x1 = 0; int  = 0; int e = 0; s = 0; for (;;) { if(f == 9 && e  } if(f == 9 && e == 0 && c==2){ break; } int v = sc.nextInt(); if (x1 > 0) { x1--; s+=v; } if (x2 >  } s+=v;  e=1; } q=v; c++; }else if(c== 1  c++;  ==  c = 0; q=0; f++; }   1; c = 0; q=0; f++; } else if (c == 1) { c = 0; q=0; f++; } else { q = v; c++;  int compareTo(score arg0) { int a; a = arg0.s - s; if (a == 0) { a = id.compareTo(arg0.id); } return a; } } void run() { for (;;) { int n = sc.nextInt(); if (n == 0) { break; }  for(int i =0;i<n;i++){ //  } Arrays.sort(c); for(int i =0 ; i < n;i++){ System.out.println(c[i].id+\" \"+c[i].s); } } } public static void main(String[] args) { Main m = new Main(); m.run(); } }"], "original_ll": -0.8214938044548035, "sampled_ll": -0.2747756242752075, "all_perturbed_sampled_ll": [-1.0118355751037598], "all_perturbed_original_ll": [-1.6675605773925781], "perturbed_sampled_ll": -1.0118355751037598, "perturbed_original_ll": -1.6675605773925781, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f1():\n    frame = 1\n    total = 0\n    i = 0\n    while frame < 10:\n        if score[i] == 10:\n            total += (score[i] + score[i+1] + score[i+2])\n            i += 1\n        elif score[i] + score[i+1] == 10:\n            total += (score[i] + score[i+1] + score[i+2])\n            i += 2\n        else:\n            total += (score[i] + score[i+1])\n            i += 2\n        frame += 1\n    else:\n        total += sum(score[i:])\n        res[sn] = total\n\ndef f2():\n    for k, v in sorted(res.items(), key=lambda x: (x[1], x[0]), reverse=True):\n        print -k, v\n\nwhile True:\n    n = input()\n    if n == 0: break\n    res = {}\n    for i in range(n):\n        L = map(int, raw_input().split())\n        sn = -L[0]\n        score = L[1:]\n        f1()\n    else:\n        f2()", "sampled": "def calculate_bowling_score(pins):\n    score = 0\n    pin_idx = 0\n    \n    for frame in range(10):\n        if frame < 9:  # Frames 1-9\n            if pins[pin_idx] == 10:  # Strike\n                score += 10 + pins[pin_idx + 1] + pins[pin_idx + 2]\n                pin_idx += 1\n            elif pins[pin_idx] + pins[pin_idx + 1] == 10:  # Spare\n                score += 10 + pins[pin_idx + 2]\n                pin_idx += 2\n            else:  # Regular\n                score += pins[pin_idx] + pins[pin_idx + 1]\n                pin_idx += 2\n        else:  # Frame 10\n            score += pins[pin_idx] + pins[pin_idx + 1] + pins[pin_idx + 2]\n            pin_idx += 3\n    \n    return score\n\nwhile True:\n    m = int(input())\n    if m == 0:\n        break\n    \n    results = []\n    for _ in range(m):\n        data = list(map(int, input().split()))\n        student_id = data[0]\n        pins = data[1:]\n        score = calculate_bowling_score(pins)\n        results.append((student_id, score))\n    \n    # Sort by score (descending), then by student_id (ascending)\n    results.sort(key=lambda x: (-x[1], x[0]))\n    \n    for student_id, score in results:\n        print(f\"{student_id} {score}\")\n", "perturbed_sampled": ["def calculate_bowling_score(pins): score = 0 pin_idx = 0 for frame in range(10): if frame < 9: # Frames   + pins[pin_idx + 1]  += 1 elif pins[pin_idx] + pins[pin_idx + 1] == 10: # Spare score += 10 + pins[pin_idx + 2] pin_idx += 2 else: #   2 else: # Frame 10 score += pins[pin_idx]  pins[pin_idx + 2] pin_idx += 3 return score while True: m = int(input()) if m == 0: break results = [] for _ in range(m): data = list(map(int, input().split())) student_id = data[0] pins = data[1:] score = calculate_bowling_score(pins) results.append((student_id, score)) # Sort by score (descending), then by  in results: print(f\"{student_id} {score}\")"], "perturbed_original": ["def f1(): frame = 1 total = 0  < 10: if score[i] == 10: total += (score[i] + score[i+1] + score[i+2]) i  score[i+1] == 10: total += (score[i] + score[i+1] + score[i+2]) i += 2 else: total += (score[i] + score[i+1]) i += 2 frame += 1 else: total += sum(score[i:]) res[sn] = total def f2(): for k, v  x[0]), reverse=True): print -k, v while True: n = input() if n == 0: break res = {}  = map(int,  f2()"], "original_ll": -0.798305332660675, "sampled_ll": -0.4987947642803192, "all_perturbed_sampled_ll": [-1.5096216201782227], "all_perturbed_original_ll": [-1.9269829988479614], "perturbed_sampled_ll": -1.5096216201782227, "perturbed_original_ll": -1.9269829988479614, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0153: Triangle and Circle\n// 2017.8.12 bal4u@uu\n\n#include <stdio.h>\n\nlong long x[10], y[10];\nlong long xe, ye, r;\n\nint atSameSide(long long x1, long long y1, long long x2, long long y2,\n\tlong long xa, long long ya, long long xb, long long yb)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n\treturn (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0);\n}\n\nint between(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n\tsb = (x1 - x2) * (x - x2) + (y1 - y2) * (y - y2);\n\treturn (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0);\n}\n\nint disCmp(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y, long long r)\n{\n\tlong long a, b, c, t;\t\t\t/* ax + by + c = 0 */\n\tlong long squ;\n\ta = y1 - y2, b = x2 - x1, c = y2*x1-x2*y1;\n\tsqu = a*a + b*b;\n\tif (squ == 0) return 0;\n\tt = (a * x) + (b * y) + c;\n\tt = t*t - r*r*squ;\n\tif (t > 0) return 1;\n\tif (t < 0) return -1;\n\treturn 0;\n}\n\nint main()\n{\n\tint i, f;\n\tlong long d[3], rr;\n\n\twhile (1) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tscanf(\"%lld%lld\", x + i, y + i);\n\t\t\tif (!i && !x[0] && !y[0]) return 0;\n\t\t\tx[i + 3] = x[i], y[i + 3] = y[i];\n\t\t}\n\t\tscanf(\"%lld%lld%lld\", &xe, &ye, &r); rr = r*r;\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = (x[i] - xe)*(x[i] - xe) + (y[i] - ye)*(y[i] - ye);\n\t\tif (rr >= d[0] && rr >= d[1] && rr >= d[2]) { puts(\"b\"); continue; }\n\t\tif (rr >= d[0] || rr >= d[1] || rr >= d[2]) { puts(\"c\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tf = atSameSide(x[i], y[i], x[i + 1], y[i + 1],\n\t\t\t\tx[i + 2], y[i + 2], xe, ye);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = disCmp(x[i], y[i], x[i + 1], y[i + 1], xe, ye, r);\n\t\tif (f) { puts(d[0] >= 0 && d[1] >= 0 && d[2] >= 0 ? \"a\" : \"c\"); continue; }\n\t\tif (d[0] > 0 && d[1] > 0 && d[2] > 0) { puts(\"d\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tif (between(x[i], y[i], x[i + 1], y[i + 1], xe, ye) && d[i] <= 0) f = 0;\n\t\tputs(f ? \"d\" : \"c\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble dist(Point a, Point b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\ndouble dot(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y);\n}\n\ndouble cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble distPointToSegment(Point p, Point a, Point b) {\n    if (dot(a, b, p) < -EPS) return dist(p, a);\n    if (dot(b, a, p) < -EPS) return dist(p, b);\n    return fabs(cross(a, b, p)) / dist(a, b);\n}\n\nint pointInTriangle(Point p, Point t1, Point t2, Point t3) {\n    double c1 = cross(t1, t2, p);\n    double c2 = cross(t2, t3, p);\n    double c3 = cross(t3, t1, p);\n    \n    if (c1 >= -EPS && c2 >= -EPS && c3 >= -EPS) return 1;\n    if (c1 <= EPS && c2 <= EPS && c3 <= EPS) return 1;\n    return 0;\n}\n\nint main() {\n    int x1, y1, x2, y2, x3, y3, xc, yc, r;\n    \n    while (1) {\n        scanf(\"%d %d\", &x1, &y1);\n        if (x1 == 0 && y1 == 0) break;\n        scanf(\"%d %d\", &x2, &y2);\n        scanf(\"%d %d\", &x3, &y3);\n        scanf(\"%d %d\", &xc, &yc);\n        scanf(\"%d\", &r);\n        \n        Point t1 = {x1, y1};\n        Point t2 = {x2, y2};\n        Point t3 = {x3, y3};\n        Point c = {xc, yc};\n        \n        // Check if circle is inside triangle\n        int circleInTriangle = 1;\n        if (!pointInTriangle(c, t1, t2, t3)) {\n            circleInTriangle = 0;\n        } else {\n            double d1 = distPointToSegment(c, t1, t2);\n            double d2 = distPointToSegment(c, t2, t3);\n            double d3 = distPointToSegment(c, t3, t1);\n            if (d1 < r - EPS || d2 < r - EPS || d3 < r - EPS) {\n                circleInTriangle = 0;\n            }\n        }\n        \n        // Check if triangle is inside circle\n        int triangleInCircle = 1;\n        if (dist(c, t1) > r + EPS || dist(c, t2) > r + EPS || dist(c, t3) > r + EPS) {\n            triangleInCircle = 0;\n        }\n        \n        // Check if they intersect\n        int intersect = 0;\n        double d1 = distPointToSegment(c, t1, t2);\n        double d2 = distPointToSegment(c, t2, t3);\n        double d3 = distPointToSegment(c, t3, t1);\n        \n        if (d1 <= r + EPS || d2 <= r + EPS || d3 <= r + EPS) {\n            if (pointInTriangle(c, t1, t2, t3) || \n                dist(c, t1) <= r + EPS || \n                dist(c, t2) <= r + EPS || \n                dist(c, t3) <= r + EPS) {\n                intersect = 1;\n            }\n        }\n        \n        if (circleInTriangle) {\n            printf(\"a\\n\");\n        } else if (triangleInCircle) {\n            printf(\"b\\n\");\n        } else if (intersect) {\n            printf(\"c\\n\");\n        } else {\n            printf(\"d\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #define EPS  x, y; } Point; double dist(Point a, Point b) { double dx =  = a.y - b.y; return sqrt(dx *  } double dot(Point a, Point b, Point c) {  (c.x - a.x) + (b.y - a.y) * (c.y -  Point b,  - a.x)  (b.y - a.y) * (c.x - a.x); } double distPointToSegment(Point p, Point a, Point b) { if (dot(a, b, p) < -EPS) return dist(p, a); if (dot(b, a, p) < -EPS) return dist(p, b); return fabs(cross(a, b, p)) / dist(a, b); } int pointInTriangle(Point p, Point t1, Point t2, Point  cross(t1, t2, p); double c2 = cross(t2, t3, p); double c3 = cross(t3, t1, p); if  >= -EPS && c3 >= -EPS) return 1; if (c1 <= EPS && c2 <= EPS && c3 <= EPS) return 1; return 0; } int main() { int x1, y1, x2,  r; while (1) { scanf(\"%d %d\", &x1, &y1); if  == 0) break; scanf(\"%d %d\", &x2, &y2); scanf(\"%d %d\", &x3, &y3); scanf(\"%d %d\", &xc, &yc); scanf(\"%d\", &r); Point t1 = {x1, y1};  Point t3 = {x3, y3}; Point c = {xc, yc}; // Check if circle is inside triangle int circleInTriangle = 1; if (!pointInTriangle(c, t1, t2, t3)) { circleInTriangle =  d1 = distPointToSegment(c, t1, t2); double d2 = distPointToSegment(c, t2, t3); double d3 =  < r - EPS || d2 < r - EPS || d3 < r - EPS) { circleInTriangle =  if triangle is inside   t2) > r  > r + EPS) { triangleInCircle =  double d2 = distPointToSegment(c, t2, t3); double d3  (d1 <= r  r  r + EPS) { if (pointInTriangle(c, t1, t2, t3) || dist(c, t1) <= r + EPS || dist(c, t2) <= r + EPS  + EPS) { intersect = 1; } } if (circleInTriangle) { printf(\"a\\n\"); } else if (triangleInCircle) { printf(\"b\\n\"); } else if (intersect) { printf(\"c\\n\"); } else { printf(\"d\\n\"); } } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0153: Triangle and Circle // 2017.8.12 bal4u@uu #include <stdio.h>  long xe, ye, r;  long y1, long long x2, long long y2, long long xa, long long ya, long long xb, long long yb) { long long sa,   + (y2 - y1) * (x1 - xa); sb  (yb - y1) + (y2 - y1) * (x1 - xb); return (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0); } int between(long long x1, long long y1, long long x2,  x, long long y) { long long sa, sb; sa = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);  * (x - x2) + (y1 -  return (sa  0) || (sa < 0 && sb < 0); } int disCmp(long long x1, long long y1, long long x2, long long y2, long long x, long long y, long long r) { long long a, b, c, t; /* ax +  a = y1  -  = a*a + b*b;  0; t = (a * x) + (b * y)  - r*r*squ; if (t > 0) return  return -1; return 0; } int main() { int i, f; long long d[3], rr; while  i++) { scanf(\"%lld%lld\", x + i, y + i); if (!i && !x[0] && !y[0]) return 0; x[i + 3] = x[i], y[i + 3] = y[i]; } scanf(\"%lld%lld%lld\", &xe,  for (i = 0; i < 3; i++) d[i] = (x[i] - xe)*(x[i] - xe) + (y[i]  (rr >= d[0] && rr >= d[1] && rr >= d[2]) { puts(\"b\"); continue; } if  = 1, i = 0; f && i < 3; i++) f = atSameSide(x[i], y[i], x[i + 1], y[i  y[i + 2], xe, ye); for (i =  d[i] = disCmp(x[i], y[i], x[i + 1], y[i + 1], xe, ye, r); if  && d[1] >= 0 && d[2] >= 0 ? \"a\" : \"c\"); continue; } if (d[0]  0 && d[2] > 0)  (f = 1, i = 0; f && i < 3; i++) if (between(x[i], y[i], x[i + 1], y[i + 1], xe, ye) && d[i] <= 0) f  : \"c\"); } return 0; }"], "original_ll": -0.6763666868209839, "sampled_ll": -0.3005899488925934, "all_perturbed_sampled_ll": [-1.0884002447128296], "all_perturbed_original_ll": [-1.5676624774932861], "perturbed_sampled_ll": -1.0884002447128296, "perturbed_original_ll": -1.5676624774932861, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c1\u306e\u9802\u70b9\u306e\u5ea7\u6a19x1 y1\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 2\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c2\u306e\u9802\u70b9\u306e\u5ea7\u6a19x2 y2\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 3\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c3\u306e\u9802\u70b9\u306e\u5ea7\u6a19x3 y3\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 4\u884c\u76ee \u5186\u306e\u4e2d\u5fc3\u306e\u5ea7\u6a19x4 y4\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 5\u884c\u76ee \u5186\u306e\u534a\u5f84r\uff08\u6574\u6570\uff09\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tif (r * r >= max) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(Line.distanceSP(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line(\n\t\t\t\t\t\tps[i], ps[(i + 1) % 3]), ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble ep = new Line(ps[i], ps[(i + 1) % 3]).ep(new Line(ps[i],\n\t\t\t\t\t\tps[3]));\n\t\t\t\tif (ep < 0)\n\t\t\t\t\tleft = false;\n\t\t\t\telse if (ep > 0)\n\t\t\t\t\tright = false;\n\t\t\t}\n\t\t\tboolean in = left | right;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n\t}\n}\n\n// Output\n//\n// \u5165\u529b\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3054\u3068\u306b\u4ee5\u4e0b\u306e\u5224\u5b9a\u7d50\u679c\u3092\u51fa\u529b\u3057\u307e\u3059\u3002\n//\n// \u5186\u304c\u4e09\u89d2\u5f62\u306b\u542b\u307e\u308c\u308b\u5834\u5408 a\n// \u4e09\u89d2\u5f62\u304c\u5186\u306b\u542b\u307e\u308c\u308b\u5834\u5408 b\n// \u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u3067\u3001\u5171\u901a\u90e8\u5206\u304c\u3042\u308b\u5834\u5408\u306b\u306f c\n// \u5171\u901a\u90e8\u5206\u304c\u306a\u3044\u5834\u5408\u306b\u306f d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic static double distanceSP(Line s, Point2D.Double p) {\n\t\tPoint2D.Double r = proj(s, p);\n\t\tif (intersectSP(s, r))\n\t\t\treturn norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p)));\n\t}\n\n\tpublic static boolean intersectSP(Line s, Point2D.Double p) {\n\t\treturn ccw(s.p1, s.p2, p) == 0;\n\t}\n\n\tpublic static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n\t\tPoint2D.Double p = sub(b, a);\n\t\tPoint2D.Double q = sub(c, a);\n\t\tif (extp(p, q) > EPS)\n\t\t\treturn 1; // counter clockwise\n\t\tif (extp(p, q) < -EPS)\n\t\t\treturn -1; // clockwise\n\t\tif (inp(p, q) < -EPS)\n\t\t\treturn 2; // c--a--b on line\n\t\tif (Math.abs(norm(p) - norm(q)) < EPS)\n\t\t\treturn -2; // a--b--c on line\n\t\treturn 0; // a--c--b(or a--c=b) on line\n\t}\n\n\tpublic static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn new Point2D.Double(p1.x - p2.x, p1.y - p2.y);\n\t}\n\n\tpublic static Point2D.Double proj(Line l, Point2D.Double p) {\n\t\tdouble t = inp(sub(p, l.p1), sub(l.p1, l.p2))\n\t\t\t\t/ Math.pow(norm(sub(l.p1, l.p2)), 2);\n\t\tPoint2D.Double tp = sub(l.p1, l.p2);\n\t\treturn new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);\n\t}\n\n\tpublic static double inp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\tpublic static double extp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tpublic static final double EPS = 1.0e-8;\n\n\tpublic static double norm(Point2D.Double p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final double EPS = 1e-9;\n    \n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n        Point sub(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n        Point mul(double t) {\n            return new Point(x * t, y * t);\n        }\n        double dot(Point p) {\n            return x * p.x + y * p.y;\n        }\n        double cross(Point p) {\n            return x * p.y - y * p.x;\n        }\n        double norm() {\n            return Math.sqrt(x * x + y * y);\n        }\n    }\n    \n    static double distancePointToSegment(Point p, Point a, Point b) {\n        if (a.sub(b).norm() < EPS) return a.sub(p).norm();\n        Point ab = b.sub(a);\n        Point ap = p.sub(a);\n        double t = ap.dot(ab) / ab.dot(ab);\n        if (t < 0) return ap.norm();\n        if (t > 1) return p.sub(b).norm();\n        Point projection = a.add(ab.mul(t));\n        return p.sub(projection).norm();\n    }\n    \n    static boolean isPointInTriangle(Point p, Point a, Point b, Point c) {\n        double d1 = b.sub(a).cross(p.sub(a));\n        double d2 = c.sub(b).cross(p.sub(b));\n        double d3 = a.sub(c).cross(p.sub(c));\n        \n        boolean hasNeg = (d1 < -EPS) || (d2 < -EPS) || (d3 < -EPS);\n        boolean hasPos = (d1 > EPS) || (d2 > EPS) || (d3 > EPS);\n        \n        return !(hasNeg && hasPos);\n    }\n    \n    static boolean circleInTriangle(Point c, double r, Point a, Point b, Point p) {\n        if (!isPointInTriangle(c, a, b, p)) return false;\n        \n        double d1 = distancePointToSegment(c, a, b);\n        double d2 = distancePointToSegment(c, b, p);\n        double d3 = distancePointToSegment(c, p, a);\n        \n        return d1 >= r - EPS && d2 >= r - EPS && d3 >= r - EPS;\n    }\n    \n    static boolean triangleInCircle(Point c, double r, Point a, Point b, Point p) {\n        double d1 = c.sub(a).norm();\n        double d2 = c.sub(b).norm();\n        double d3 = c.sub(p).norm();\n        \n        return d1 <= r + EPS && d2 <= r + EPS && d3 <= r + EPS;\n    }\n    \n    static boolean circleSegmentIntersect(Point c, double r, Point a, Point b) {\n        double dist = distancePointToSegment(c, a, b);\n        return dist <= r + EPS;\n    }\n    \n    static boolean hasIntersection(Point c, double r, Point a, Point b, Point p) {\n        if (circleSegmentIntersect(c, r, a, b)) return true;\n        if (circleSegmentIntersect(c, r, b, p)) return true;\n        if (circleSegmentIntersect(c, r, p, a)) return true;\n        \n        if (isPointInTriangle(c, a, b, p)) return true;\n        \n        return false;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] tokens = line.trim().split(\"\\\\s+\");\n            if (tokens.length == 2 && tokens[0].equals(\"0\") && tokens[1].equals(\"0\")) {\n                break;\n            }\n            \n            Point p1 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            Point p2 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            Point p3 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            Point center = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            double radius = Double.parseDouble(tokens[0]);\n            \n            if (circleInTriangle(center, radius, p1, p2, p3)) {\n                System.out.println(\"a\");\n            } else if (triangleInCircle(center, radius, p1, p2, p3)) {\n                System.out.println(\"b\");\n            } else if (hasIntersection(center, radius, p1, p2, p3)) {\n                System.out.println(\"c\");\n            } else {\n                System.out.println(\"d\");\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import  = 1e-9;  =  Point sub(Point p) { return new Point(x - p.x, y - p.y); } Point add(Point p) { return new Point(x + p.x, y + p.y); }   * t); } double dot(Point p) { return x   { return x * p.y - y * p.x; } double norm()  + y * y); } } static double distancePointToSegment(Point  { if (a.sub(b).norm() < EPS) return a.sub(p).norm(); Point ab = b.sub(a); Point ap = p.sub(a); double t = ap.dot(ab) / ab.dot(ab); if (t < 0) return ap.norm(); if (t  projection = a.add(ab.mul(t)); return p.sub(projection).norm();  Point a, Point b, Point c) { double d1 = b.sub(a).cross(p.sub(a)); double d2 = c.sub(b).cross(p.sub(b)); double d3 = a.sub(c).cross(p.sub(c)); boolean  || (d3 < -EPS); boolean hasPos = (d1 > EPS) || (d2 > EPS) || (d3 > EPS); return !(hasNeg && hasPos); } static boolean circleInTriangle(Point c, double r, Point a, Point b,  a, b, p)) return false; double d1 = distancePointToSegment(c, a, b);  p); double d3 = distancePointToSegment(c,  r -  - EPS && d3 >= r - EPS; } static boolean triangleInCircle(Point c, double r, Point  { double d1 = c.sub(a).norm(); double d2 = c.sub(b).norm(); double d3 = c.sub(p).norm(); return d1 <= r + EPS && d2 <= r + EPS && d3 <= r + EPS; } static boolean circleSegmentIntersect(Point c, double r, Point a, Point b) { double dist = distancePointToSegment(c, a, b); return dist <= r +  a, Point b, Point p) { if  true; if (circleSegmentIntersect(c, r, b, p)) return true; if (circleSegmentIntersect(c, r, p, a)) return true; if (isPointInTriangle(c, a, b, p)) return true; return false; } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] tokens = line.trim().split(\"\\\\s+\"); if (tokens.length ==  { break; } Point p1 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1])); tokens = br.readLine().trim().split(\"\\\\s+\"); Point p2  = br.readLine().trim().split(\"\\\\s+\"); Point p3  = new Point(Double.parseDouble(tokens[0]),  radius = Double.parseDouble(tokens[0]); if (circleInTriangle(center, radius, p1, p2, p3)) { System.out.println(\"a\"); } else if (triangleInCircle(center, radius, p1, p2, p3)) { System.out.println(\"b\"); } else if (hasIntersection(center, radius, p1, p2, p3)) { System.out.println(\"c\"); } else { System.out.println(\"d\"); } } } }"], "perturbed_original": ["import java.awt.geom.Point2D; import java.util.Scanner; public class Main { public static void main(String[] args) throws Exception { Scanner sc = new Scanner(System.in); sc.useDelimiter(\",|\\\\s+\"); while (true) { int x1 = sc.nextInt(); int y1 = sc.nextInt(); if ((x1 | y1) == 0) break; int x2 = sc.nextInt();  x3 = sc.nextInt(); int y3 = sc.nextInt(); int x4 = sc.nextInt(); int y4 = sc.nextInt(); int r = sc.nextInt(); // 1\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c1\u306e\u9802\u70b9\u306e\u5ea7\u6a19x1 y1\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09 // 2\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c2\u306e\u9802\u70b9\u306e\u5ea7\u6a19x2 y2\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09 // 3\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c3\u306e\u9802\u70b9\u306e\u5ea7\u6a19x3 y3\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09 // 4\u884c\u76ee \u5186\u306e\u4e2d\u5fc3\u306e\u5ea7\u6a19x4 y4\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09  ps = new Point2D.Double[4]; ps[0] = new Point2D.Double(x1, y1); ps[1] = new Point2D.Double(x2, y2); ps[2] = new Point2D.Double(x3, y3); ps[3] = new Point2D.Double(x4, y4); double max = 0; for (int i = 0;  max = Math.max(max,  * r >= max) { System.out.println(\"b\"); continue; } double min = Double.MAX_VALUE; for (int i  i++) { double dis = Math.max(Line.distanceSP(new Line(ps[i], ps[(i + 1) % 3]), ps[3]),  min = Math.min(min, dis); } boolean right = true; boolean left = true; for (int i = 0; i < 3;  new Line(ps[i], ps[(i + 1) % 3]).ep(new Line(ps[i], ps[3])); if (ep < 0) left = false; else if (ep > 0) right = false; } boolean in = left | right; if (r <= min && in) System.out.println(\"a\"); else if (!in && r < min) System.out.println(\"d\"); else System.out.println(\"c\"); } } public static double nor(Point2D.Double p, Point2D.Double q) { return (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y  Output // // \u5165\u529b\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3054\u3068\u306b\u4ee5\u4e0b\u306e\u5224\u5b9a\u7d50\u679c\u3092\u51fa\u529b\u3057\u307e\u3059\u3002 // //  // \u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u3067\u3001\u5171\u901a\u90e8\u5206\u304c\u3042\u308b\u5834\u5408\u306b\u306f c // \u5171\u901a\u90e8\u5206\u304c\u306a\u3044\u5834\u5408\u306b\u306f d class Line { public Point2D.Double p1; public Point2D.Double p2; Line(Point2D.Double p1, Point2D.Double p2) { this.p1 = p1; this.p2 = p2;   (p1.y - p2.y) * (p1.y - p2.y)); } public double ip(Line l) { Point2D.Double q1 =  return (p2.x - p1.x)  { Point2D.Double q1 = l.p1; Point2D.Double q2  q1.y) - (p2.y - p1.y) * (q2.x - q1.x); } public static double distanceSP(Line s, Point2D.Double p)  p); if (intersectSP(s, r))   static boolean intersectSP(Line   } public static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) { Point2D.Double  q = sub(c, a); if (extp(p, q) > EPS) return 1; // counter clockwise if (extp(p, q) < -EPS) return  q) < -EPS)  line  EPS) return -2;  0; // a--c--b(or a--c=b) on line } public static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) { return new Point2D.Double(p1.x - p2.x, p1.y - p2.y); } public static Point2D.Double proj(Line l, Point2D.Double p) { double t =  tp = sub(l.p1, l.p2); return new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);  p1, Point2D.Double p2) { return p1.x * p2.x + p1.y * p2.y; } public static double extp(Point2D.Double p1, Point2D.Double p2) {  p2.x * p1.y; } public static final double EPS = 1.0e-8; public static double norm(Point2D.Double p) { return Math.hypot(p.x, p.y); } public double disToPoint(Point2D.Double q1) { Line p1q1 = new Line(p1,  double ip2 = this.ip(this); if (ip1 <= 0) return p1q1.length(); else  ip1 < ip2) { double d2 = ip1 / this.length(); double size = p1q1.length(); return Math.sqrt(size  Line(p2, q1); return p2q1.length(); } } public boolean isCross(Line q1q2) { Point2D.Double    = new Line(p1, q2); Line q1p1 = new Line(q1, p1); Line  if (this.ep(p1q1) * this.ep(p1q2) < 0 && q1q2.ep(q1p1) * q1q2.ep(q1p2)  return false; } public double minDistance(Line q1q2) { if  = Double.MAX_VALUE; Point2D.Double q1 = q1q2.p1; Point2D.Double q2 = q1q2.p2; ans = Math.min(ans,  ans = Math.min(ans, q1q2.disToPoint(p1));  ans; } public String toString() { return p1 + \"=>\" + p2; } }"], "original_ll": -0.6008069515228271, "sampled_ll": -0.3229215741157532, "all_perturbed_sampled_ll": [-1.0600782632827759], "all_perturbed_original_ll": [-1.2129583358764648], "perturbed_sampled_ll": -1.0600782632827759, "perturbed_original_ll": -1.2129583358764648, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def In(): return map(int,raw_input().split())\ndef D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5\ndef side(a, b, c): return (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])>0\ndef isIn(x,p0,p1,p2): return (side(p0,p1,x)==side(p1,p2,x)==side(p2,p0,x))\ndef S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0\ndef H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3)\ndef CinT(P4,r,P1,P2,P3):\n  f1 = isIn(P4,P1,P2,P3)\n  f = [H(P4,P1,P2)>=r, H(P4,P2,P3)>=r, H(P4,P3,P1)>=r]\n  if f1:\n    if all(f): return 1\n    elif any(f): return 3\n  return 0\n\ndef TinC(P4,r,P1,P2,P3):\n  f = [D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r]\n  if all(f): return 2\n  elif any(f): return 3\n  return 0\n  \nwhile 1:\n  P1 = In()\n  if P1[0]==P1[1]==0: break\n  P2 = In()\n  P3 = In()\n  P4 = In()\n  r = int(raw_input())\n  f = CinT(P4,r,P1,P2,P3)\n  if not f: f = TinC(P4,r,P1,P2,P3)\n  print 'dabc'[f]", "sampled": "import sys\nfrom math import sqrt\n\ndef read_input():\n    datasets = []\n    lines = sys.stdin.read().strip().split('\\n')\n    i = 0\n    while i < len(lines):\n        parts = lines[i].split()\n        if len(parts) == 2 and parts[0] == '0' and parts[1] == '0':\n            break\n        \n        # Read 3 triangle vertices\n        x1, y1 = map(int, lines[i].split())\n        x2, y2 = map(int, lines[i+1].split())\n        x3, y3 = map(int, lines[i+2].split())\n        \n        # Read circle center and radius\n        xc, yc = map(int, lines[i+3].split())\n        r = int(lines[i+4])\n        \n        datasets.append(((x1, y1), (x2, y2), (x3, y3), (xc, yc), r))\n        i += 5\n    \n    return datasets\n\ndef distance(p1, p2):\n    return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef point_to_segment_distance(p, a, b):\n    ax, ay = a\n    bx, by = b\n    px, py = p\n    \n    abx = bx - ax\n    aby = by - ay\n    apx = px - ax\n    apy = py - ay\n    \n    ab_ab = abx * abx + aby * aby\n    if ab_ab == 0:\n        return distance(p, a)\n    \n    ap_ab = apx * abx + apy * aby\n    t = max(0, min(1, ap_ab / ab_ab))\n    \n    closest_x = ax + t * abx\n    closest_y = ay + t * aby\n    \n    return distance(p, (closest_x, closest_y))\n\ndef point_in_triangle(p, v1, v2, v3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    \n    d1 = sign(p, v1, v2)\n    d2 = sign(p, v2, v3)\n    d3 = sign(p, v3, v1)\n    \n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    \n    return not (has_neg and has_pos)\n\ndef circle_in_triangle(v1, v2, v3, center, r):\n    # Check if center is in triangle\n    if not point_in_triangle(center, v1, v2, v3):\n        return False\n    \n    # Check distance from center to all edges\n    d1 = point_to_segment_distance(center, v1, v2)\n    d2 = point_to_segment_distance(center, v2, v3)\n    d3 = point_to_segment_distance(center, v3, v1)\n    \n    return d1 >= r and d2 >= r and d3 >= r\n\ndef triangle_in_circle(v1, v2, v3, center, r):\n    d1 = distance(center, v1)\n    d2 = distance(center, v2)\n    d3 = distance(center, v3)\n    \n    return d1 <= r and d2 <= r and d3 <= r\n\ndef circle_triangle_intersect(v1, v2, v3, center, r):\n    # Check if any vertex is inside or on the circle\n    for v in [v1, v2, v3]:\n        if distance(center, v) <= r:\n            return True\n    \n    # Check if center is inside triangle\n    if point_in_triangle(center, v1, v2, v3):\n        return True\n    \n    # Check if any edge intersects the circle\n    for a, b in [(v1, v2), (v2, v3), (v3, v1)]:\n        if point_to_segment_distance(center, a, b) <= r:\n            return True\n    \n    return False\n\ndef solve(v1, v2, v3, center, r):\n    if circle_in_triangle(v1, v2, v3, center, r):\n        return 'a'\n    elif triangle_in_circle(v1, v2, v3, center, r):\n        return 'b'\n    elif circle_triangle_intersect(v1, v2, v3, center, r):\n        return 'c'\n    else:\n        return 'd'\n\ndatasets = read_input()\nfor v1, v2, v3, center, r in datasets:\n    print(solve(v1, v2, v3, center, r))\n", "perturbed_sampled": ["import sys from math import   = 0 while i < len(lines): parts = lines[i].split() if len(parts) == 2 and parts[0] == '0' and parts[1] == '0': break # Read 3 triangle vertices x1, y1 = map(int, lines[i].split()) x2, y2 = map(int, lines[i+1].split()) x3, y3 = map(int, lines[i+2].split()) #  xc, yc = map(int, lines[i+3].split()) r =  (x3, y3), (xc, yc),  return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def point_to_segment_distance(p,  a bx, by = b px, py = p abx = bx - ax aby = by - ay apx = px - ax apy =  abx   return distance(p, a) ap_ab = apx * abx + apy * aby t = max(0, min(1, ap_ab / ab_ab))  * abx closest_y = ay + t * aby return  sign(p1, p2, p3): return (p1[0] - p3[0]) * (p2[1] - p3[1])  (p1[1] -  v2) d2 = sign(p, v2, v3) d3 = sign(p, v3, v1) has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)  or (d2 > 0) or (d3 > 0) return not (has_neg and has_pos) def circle_in_triangle(v1, v2, v3, center, r): # Check if center is in triangle if not point_in_triangle(center, v1, v2, v3): return False # Check distance from center to all edges d1 = point_to_segment_distance(center, v1, v2)   return d1 >= r and d2 >= r and d3 >= r def triangle_in_circle(v1, v2, v3, center, r): d1 = distance(center, v1) d2 = distance(center, v2) d3 = distance(center, v3) return d1 <= r and d2 <= r and d3 <= r def circle_triangle_intersect(v1, v2, v3, center,  vertex is inside or on the circle  <= r: return True  inside triangle if point_in_triangle(center, v1, v2, v3): return True # Check if any edge intersects the circle for a, b in [(v1, v2), (v2, v3), (v3, v1)]: if point_to_segment_distance(center, a, b) <= r: return  v2, v3, center, r): if circle_in_triangle(v1, v2, v3, center, r): return 'a' elif triangle_in_circle(v1, v2, v3, center, r): return 'b' elif circle_triangle_intersect(v1, v2, v3, center, r):  datasets  center, r))"], "perturbed_original": ["def In(): return map(int,raw_input().split()) def D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5 def side(a, b, c):  (side(p0,p1,x)==side(p1,p2,x)==side(p2,p0,x)) def S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0 def H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3) def CinT(P4,r,P1,P2,P3): f1 = isIn(P4,P1,P2,P3) f = [H(P4,P1,P2)>=r, H(P4,P2,P3)>=r, H(P4,P3,P1)>=r] if  elif any(f): return 3   all(f): return 2 elif any(f): return 3 return  In() if P1[0]==P1[1]==0: break P2 = In() P3 = In() P4 = In() r = int(raw_input()) f = CinT(P4,r,P1,P2,P3) if not f: f = TinC(P4,r,P1,P2,P3) print 'dabc'[f]"], "original_ll": -0.8484145998954773, "sampled_ll": -0.33735522627830505, "all_perturbed_sampled_ll": [-1.2482658624649048], "all_perturbed_original_ll": [-1.4864147901535034], "perturbed_sampled_ll": -1.2482658624649048, "perturbed_original_ll": -1.4864147901535034, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint count;\nvoid solve(int depth, int card[][2], int n, int total, int goal) {\n\tint i;\n\tif(depth == n) {\n\t\tif(total == goal)\n\t\t\tcount++;\n\t\treturn;\n\t}\n\t\n\tfor(i=0;i<=card[depth][1];i++) {\n\t\tsolve(depth+1, card, n, total + card[depth][0] * i, goal);\n\t}\n}\n\nint main(void) {\n\tint n, g;\n\tint i;\n\tint goal;\n\tint j[1001];\n\tint card[1001][2];\n\twhile(1) {\n\t\tcount = 0;\n\t\tscanf(\"%d\\n\", &n);\n\t\tif(n==0) break;\n\t\tfor(i=0;i<n;i++) {\n\t\t\tscanf(\"%d %d\\n\", &card[i][0], &card[i][1]);\n\t\t}\n\t\tscanf(\"%d\\n\", &g);\n\t\tfor(i-0;i<g;i++) {\n\t\t\tscanf(\"%d\\n\", &goal);\n\t\t\tsolve(0, card, n, 0, goal);\t\n\t\t\tprintf(\"%d\\n\", count);\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint m, g;\nint a[7], b[7];\nint n;\nint count;\n\nvoid dfs(int idx, int sum) {\n    if (idx == m) {\n        if (sum == n) {\n            count++;\n        }\n        return;\n    }\n    \n    for (int i = 0; i <= b[idx]; i++) {\n        dfs(idx + 1, sum + i * a[idx]);\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &m);\n        if (m == 0) break;\n        \n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d\", &a[i], &b[i]);\n        }\n        \n        scanf(\"%d\", &g);\n        \n        for (int i = 0; i < g; i++) {\n            scanf(\"%d\", &n);\n            count = 0;\n            dfs(0, 0);\n            printf(\"%d\\n\", count);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int m, g; int a[7], b[7]; int n; int count; void dfs(int idx, int sum) { if (idx == m) { if (sum == n) { count++; } return; } for (int i = 0; i <= b[idx]; i++) { dfs(idx + 1, sum +  int main() { while (1) { scanf(\"%d\", &m); if (m == 0)  0; i  %d\", &a[i],  i < g; i++) { scanf(\"%d\", &n); count = 0; dfs(0, 0); printf(\"%d\\n\",  }"], "perturbed_original": ["#include <stdio.h> int count;  int n,  n) { if(total == goal) count++; return; } for(i=0;i<=card[depth][1];i++) { solve(depth+1,  * i, goal); } } int  int i; int goal; int j[1001]; int card[1001][2]; while(1) { count = 0; scanf(\"%d\\n\", &n); if(n==0) break; for(i=0;i<n;i++) { scanf(\"%d %d\\n\", &card[i][0], &card[i][1]); } scanf(\"%d\\n\", &g); for(i-0;i<g;i++) { scanf(\"%d\\n\", &goal); solve(0, card, n, 0, goal); printf(\"%d\\n\", count); } } return 0; }"], "original_ll": -0.7972354888916016, "sampled_ll": -0.5349566340446472, "all_perturbed_sampled_ll": [-1.6256080865859985], "all_perturbed_original_ll": [-1.6560633182525635], "perturbed_sampled_ll": -1.6256080865859985, "perturbed_original_ll": -1.6560633182525635, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class AOJ_0154{\n    class Card{\n        int a;\n        int b;\n        Card(int a, int b){\n            this.a = a;\n            this.b = b;\n        }\n    }\n    void run(){\n        Scanner sc = new Scanner(System.in);\n        while(true){\n            int[] card_num = new int[101];\n            int m = sc.nextInt();\n            if(m==0){\n                break;\n            }\n            Card[] cards = new Card[m];\n            for(int i = 0; i < m; i++){\n                cards[i] = new Card(sc.nextInt(), sc.nextInt());\n            }\n            int ub = 7*100*10;\n            int[] dp = new int[ub];\n            dp[0] = 1;\n            for(int i = 0; i < m; i++){\n                for(int ii = 7 * 100 * 10 - cards[i].a -1; ii >= 0; ii--){\n                    for(int iii = 1; iii <= cards[i].b; iii++){\n                        if(ii + cards[i].a*iii < ub-1){\n                            dp[ii + cards[i].a*iii] += dp[ii];\n                        }\n                    }\n                }\n            }\n            /*\n              System.out.println(Arrays.toString(dp));\n              for(int i = 0; i < 100; i++){\n              System.out.println(i + \" : \" + dp[i]);\n              }\n            */\n            int g = sc.nextInt();\n            for(int i = 0; i < g; i++){\n                System.out.println(dp[sc.nextInt()]);\n            }\n        }\n    }\n    public static void main(String[] args){\n        new AOJ_0154().run();\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[] values;\n    static int[] counts;\n    static int m;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            m = sc.nextInt();\n            if (m == 0) break;\n            \n            values = new int[m];\n            counts = new int[m];\n            \n            for (int i = 0; i < m; i++) {\n                values[i] = sc.nextInt();\n                counts[i] = sc.nextInt();\n            }\n            \n            int g = sc.nextInt();\n            for (int i = 0; i < g; i++) {\n                int n = sc.nextInt();\n                int result = countCombinations(n);\n                System.out.println(result);\n            }\n        }\n        sc.close();\n    }\n    \n    static int countCombinations(int target) {\n        return dfs(0, target);\n    }\n    \n    static int dfs(int index, int remaining) {\n        if (remaining == 0) {\n            return 1;\n        }\n        if (remaining < 0 || index >= m) {\n            return 0;\n        }\n        \n        int total = 0;\n        for (int i = 0; i <= counts[index]; i++) {\n            int newRemaining = remaining - (i * values[index]);\n            if (newRemaining < 0) break;\n            total += dfs(index + 1, newRemaining);\n        }\n        \n        return total;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int[] values; static int[] counts; static int m; public static void main(String[] args) { Scanner sc = new  == 0) break; values = new int[m];  (int i  i++) { values[i] =  int g  = 0; i < g; i++) { int n = sc.nextInt(); int result = countCombinations(n); System.out.println(result); } } sc.close(); } static int countCombinations(int target) { return dfs(0, target); } static int dfs(int index, int remaining)  { return 1; } if (remaining < 0 || index >= m) { return 0;  for (int i = 0; i <= counts[index]; i++) { int newRemaining = remaining - (i * values[index]); if (newRemaining  dfs(index + 1, newRemaining); } return total; } }"], "perturbed_original": ["import java.util.*; public class   b){ this.a = a; this.b = b; } } void  Scanner(System.in); while(true){ int[] card_num = new int[101]; int m = sc.nextInt(); if(m==0){ break; } Card[] cards = new Card[m]; for(int i  i++){ cards[i]  int[] dp = new int[ub];  = 0;  ii = 7 * 100 * 10 - cards[i].a -1; ii >= 0; ii--){ for(int iii = 1; iii <= cards[i].b; iii++){ if(ii + cards[i].a*iii < ub-1){ dp[ii + cards[i].a*iii] += dp[ii]; } } } } /* System.out.println(Arrays.toString(dp)); for(int i = 0; i < 100; i++){ System.out.println(i + \" : \" + dp[i]); } */ int g = sc.nextInt(); for(int i = 0; i < g; i++){ System.out.println(dp[sc.nextInt()]); }  main(String[] args){ new AOJ_0154().run(); } }"], "original_ll": -0.7539686560630798, "sampled_ll": -0.45200634002685547, "all_perturbed_sampled_ll": [-1.639053225517273], "all_perturbed_original_ll": [-1.757312297821045], "perturbed_sampled_ll": -1.639053225517273, "perturbed_original_ll": -1.757312297821045, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfrom array import array\n\ndef main():\n\twhile True:\n\t\tm = input()\n\t\tif m == 0: return 0\n\t\tdp = [array('I', [0] * 1001) for i in range(m + 1)]\n\t\tdp[0][0] = 1\n\t\tfor i in xrange(m):\n\t\t\tv, c = map(int, raw_input().split())\n\t\t\tfor j in xrange(1001):\n\t\t\t\tfor k in xrange(c + 1):\n\t\t\t\t\tnext = j + v * k\n\t\t\t\t\tif next > 1000: continue\n\t\t\t\t\tdp[i + 1][next] += dp[i][j]\n\t\tn = input()\n\t\tfor i in range(n):\n\t\t\tx = input()\n\t\t\tprint dp[m][x]\n\nif __name__ == '__main__':\n\tsys.exit(main())", "sampled": "import sys\nfrom itertools import product\n\ndef count_combinations(cards, target):\n    count = 0\n    # Generate all possible combinations\n    ranges = [range(b + 1) for a, b in cards]\n    \n    for combination in product(*ranges):\n        total = sum(combination[i] * cards[i][0] for i in range(len(cards)))\n        if total == target:\n            count += 1\n    \n    return count\n\ndef main():\n    lines = []\n    for line in sys.stdin:\n        lines.append(line.strip())\n    \n    idx = 0\n    while idx < len(lines):\n        m = int(lines[idx])\n        if m == 0:\n            break\n        \n        idx += 1\n        cards = []\n        for _ in range(m):\n            a, b = map(int, lines[idx].split())\n            cards.append((a, b))\n            idx += 1\n        \n        g = int(lines[idx])\n        idx += 1\n        \n        for _ in range(g):\n            n = int(lines[idx])\n            idx += 1\n            result = count_combinations(cards, n)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from itertools import product def count_combinations(cards, target): count = 0 # Generate all possible combinations ranges = [range(b + 1) for a, b in  total  i in range(len(cards))) if total == target: count += 1 return count def main(): lines =  lines.append(line.strip()) idx  if m == 0: break idx += 1 cards = [] for _ in range(m): a, b = map(int, lines[idx].split()) cards.append((a, b))  int(lines[idx]) idx += 1 for _ in range(g): n = int(lines[idx]) idx += 1 result  __name__ == \"__main__\": main()"], "perturbed_original": ["import sys from array import array def  input()  0 dp = [array('I', [0] * 1001) for i in range(m + 1)] dp[0][0] = 1 for i in xrange(m): v, c = map(int, raw_input().split()) for j in xrange(1001): for k in  j + v * k   n = input() for i in range(n): x = input() print dp[m][x] if __name__ == '__main__': sys.exit(main())"], "original_ll": -0.790590763092041, "sampled_ll": -0.6858313083648682, "all_perturbed_sampled_ll": [-2.037632942199707], "all_perturbed_original_ll": [-1.8227505683898926], "perturbed_sampled_ll": -2.037632942199707, "perturbed_original_ll": -1.8227505683898926, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "//from PKU1125\n#define M 101\ndouble dist[M][M],d;\nnext[M][M],x[M],y[M];\nmain(){\n\tint a,b,k,n,i,j;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\t/*initialize*/\n\t\tfor(i=1;i<=n;i++)scanf(\"%d\",&a),scanf(\"%d%d\",x+a,y+a);\n\t\tfor(i=1;i<=n;i++)for(j=1;j<=n;next[i][j]=j,j++)\n\t\t\tdist[i][j]=(d=hypot(x[i]-x[j],y[i]-y[j]))<50.1?d:999;\n\n\t\t{/*warshall-floyd*/\n\t\t\tint k,i,j;\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\t\tif(dist[i][j]>dist[i][k]+dist[k][j])\n\t\t\t\t\t\t\tdist[i][j]=dist[i][k]+dist[k][j],next[i][j]=next[i][k];\n\t\t\t\t\t}\n\t\t}\n\n\t\t{/*query*/\n\t\t\tfor(scanf(\"%d\",&k);k;k--){\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\tif(dist[a][b]>998)puts(\"NA\");\n\t\t\t\telse{\n\t\t\t\t\tfor(j=a;j!=b;j=next[j][b])printf(\"%d \",j);\n\t\t\t\t\tprintf(\"%d\\n\",b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}exit(0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#define MAX_N 101\n#define INF 1e9\n\ntypedef struct {\n    int id;\n    int x, y;\n} Building;\n\nBuilding buildings[MAX_N];\nint n;\ndouble dist[MAX_N][MAX_N];\nint next_node[MAX_N][MAX_N];\n\ndouble calc_dist(int i, int j) {\n    double dx = buildings[i].x - buildings[j].x;\n    double dy = buildings[i].y - buildings[j].y;\n    return sqrt(dx * dx + dy * dy);\n}\n\nvoid floyd_warshall() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                dist[i][j] = 0;\n                next_node[i][j] = -1;\n            } else {\n                double d = calc_dist(i, j);\n                if (d <= 50.0) {\n                    dist[i][j] = d;\n                    next_node[i][j] = j;\n                } else {\n                    dist[i][j] = INF;\n                    next_node[i][j] = -1;\n                }\n            }\n        }\n    }\n    \n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                    next_node[i][j] = next_node[i][k];\n                }\n            }\n        }\n    }\n}\n\nvoid print_path(int start, int end) {\n    if (dist[start][end] >= INF) {\n        printf(\"NA\\n\");\n        return;\n    }\n    \n    printf(\"%d\", buildings[start].id);\n    int current = start;\n    while (current != end) {\n        current = next_node[current][end];\n        printf(\" %d\", buildings[current].id);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %d\", &buildings[i].id, &buildings[i].x, &buildings[i].y);\n        }\n        \n        floyd_warshall();\n        \n        int m;\n        scanf(\"%d\", &m);\n        \n        for (int i = 0; i < m; i++) {\n            int s, g;\n            scanf(\"%d %d\", &s, &g);\n            \n            int si = -1, gi = -1;\n            for (int j = 0; j < n; j++) {\n                if (buildings[j].id == s) si = j;\n                if (buildings[j].id == g) gi = j;\n            }\n            \n            print_path(si, gi);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <math.h> #include <string.h> #define MAX_N 101 #define INF  id; int x, y; } Building; Building buildings[MAX_N]; int n; double dist[MAX_N][MAX_N];  int j) { double dx = buildings[i].x - buildings[j].x; double dy = buildings[i].y - buildings[j].y; return sqrt(dx * dx + dy * dy); } void floyd_warshall() { for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (i ==  next_node[i][j] = -1;  (d <=  next_node[i][j] = j; } else { dist[i][j] = INF; next_node[i][j] = -1; } } } } for (int k =  { for (int  n; i++) { for (int j = 0; j < n; j++) { if (dist[i][k] + dist[k][j] < dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; next_node[i][j] = next_node[i][k]; } }  if  return; } printf(\"%d\", buildings[start].id); int current = start; while (current  next_node[current][end]; printf(\" %d\", buildings[current].id); } printf(\"\\n\"); } int main() { while (1) { scanf(\"%d\",  break; for (int i = 0; i < n; i++) { scanf(\"%d %d %d\", &buildings[i].id, &buildings[i].x, &buildings[i].y); } floyd_warshall(); int m;  m; i++) { int  &g);  = -1; for (int j = 0; j < n; j++) { if (buildings[j].id == s) si = j; if  j; } print_path(si, gi); } } return 0; }"], "perturbed_original": ["//from PKU1125  next[M][M],x[M],y[M]; main(){ int a,b,k,n,i,j; for(;scanf(\"%d\",&n),n;){ /*initialize*/ for(i=1;i<=n;i++)scanf(\"%d\",&a),scanf(\"%d%d\",x+a,y+a); for(i=1;i<=n;i++)for(j=1;j<=n;next[i][j]=j,j++) dist[i][j]=(d=hypot(x[i]-x[j],y[i]-y[j]))<50.1?d:999; {/*warshall-floyd*/  if(dist[i][j]>dist[i][k]+dist[k][j]) dist[i][j]=dist[i][k]+dist[k][j],next[i][j]=next[i][k]; } } {/*query*/ for(scanf(\"%d\",&k);k;k--){ scanf(\"%d%d\",&a,&b); if(dist[a][b]>998)puts(\"NA\"); else{ for(j=a;j!=b;j=next[j][b])printf(\"%d \",j); printf(\"%d\\n\",b); } } } }exit(0); }"], "original_ll": -1.1463114023208618, "sampled_ll": -0.29177767038345337, "all_perturbed_sampled_ll": [-1.2009328603744507], "all_perturbed_original_ll": [-1.6493263244628906], "perturbed_sampled_ll": -1.2009328603744507, "perturbed_original_ll": -1.6493263244628906, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\npublic class Main {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic Scanner stdIn = new Scanner(System.in);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic int INF = 2 << 20;\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdouble [][] cost = new double[n+1][n+1];\n\t\t\t\n\t\t\tfor(int i = 0; i < n+1; i++) {\n\t\t\t\tArrays.fill(cost[i], INF);\n\t\t\t}\n\t\t\tData[] list = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tlist[i] = new Data(a,b,c);\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tdouble sum = Math.sqrt((list[i].x - list[j].x)*(list[i].x - list[j].x) + (list[i].y - list[j].y) * (list[i].y - list[j].y));\n\t\t\t\t\tif(sum > 50.0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcost[list[i].id][list[j].id] = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tdouble[] d = new double[n+1];\n\t\t\t\tboolean[] used = new boolean[n+1];\n\t\t\t\tint[] prev = new int[n+1];\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint g = sc.nextInt();\n\t\t\t\t\n\t\t\t\tArrays.fill(d, INF);\n\t\t\t\tArrays.fill(used, false);\n\t\t\t\tArrays.fill(prev, -1);\n\t\t\t\td[s] = 0;\n\t\t\t\t\n\t\t\t\twhile(true) {\n\t\t\t\t\tint v = -1;\n\t\t\t\t\tfor(int u= 0; u < n+1; u++) {\n\t\t\t\t\t\tif(!used[u] && (v == -1 || d[u] < d[v])) v = u;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(v == -1) break;\n\t\t\t\t\tused[v] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor(int u = 0; u < n+1; u++) {\n\t\t\t\t\t\tif(d[u] > d[v] + cost[v][u]) {\n\t\t\t\t\t\t\td[u] = d[v] + cost[v][u];\n\t\t\t\t\t\t\tprev[u] = v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(d[g] == INF) {\n\t\t\t\t\tout.println(\"NA\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tArrayList<Integer> Xist = new ArrayList<Integer>();\n\t\t\t\tfor(; g != -1; g = prev[g]) Xist.add(g);\n\t\t\t\t\n\t\t\t\tCollections.reverse(Xist);\n\t\t\t\tout.print(Xist.get(0));\n\t\t\t\tfor(int j = 1; j < Xist.size(); j++) {\n\t\t\t\t\tout.print(\" \" + Xist.get(j));\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\tout.flush();\n\t}\n\t\n\tstatic class Data {\n\t\tint id;\n\t\tint x;\n\t\tint y;\n\t\t\n\t\tData(int a, int b, int c) {\n\t\t\tid = a;\n\t\t\tx = b;\n\t\t\ty = c;\n\t\t}\n\t}\n\t\n\n\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n     \n    public int nextInt() {\n        return (int)nextLong();\n    }\n     \n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n     \n \n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Building {\n        int id;\n        int x, y;\n        \n        Building(int id, int x, int y) {\n            this.id = id;\n            this.x = x;\n            this.y = y;\n        }\n        \n        double distance(Building other) {\n            return Math.sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        int buildingId;\n        double distance;\n        \n        State(int buildingId, double distance) {\n            this.buildingId = buildingId;\n            this.distance = distance;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Double.compare(this.distance, other.distance);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            Map<Integer, Building> buildings = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                int id = sc.nextInt();\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                buildings.put(id, new Building(id, x, y));\n            }\n            \n            int m = sc.nextInt();\n            \n            for (int i = 0; i < m; i++) {\n                int start = sc.nextInt();\n                int goal = sc.nextInt();\n                \n                List<Integer> path = findPath(buildings, start, goal);\n                \n                if (path == null) {\n                    System.out.println(\"NA\");\n                } else {\n                    StringBuilder sb = new StringBuilder();\n                    for (int j = 0; j < path.size(); j++) {\n                        if (j > 0) sb.append(\" \");\n                        sb.append(path.get(j));\n                    }\n                    System.out.println(sb.toString());\n                }\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static List<Integer> findPath(Map<Integer, Building> buildings, int start, int goal) {\n        Map<Integer, Double> dist = new HashMap<>();\n        Map<Integer, Integer> prev = new HashMap<>();\n        PriorityQueue<State> pq = new PriorityQueue<>();\n        \n        for (int id : buildings.keySet()) {\n            dist.put(id, Double.MAX_VALUE);\n        }\n        \n        dist.put(start, 0.0);\n        pq.offer(new State(start, 0.0));\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            int currentId = current.buildingId;\n            \n            if (current.distance > dist.get(currentId)) {\n                continue;\n            }\n            \n            if (currentId == goal) {\n                break;\n            }\n            \n            Building currentBuilding = buildings.get(currentId);\n            \n            for (int nextId : buildings.keySet()) {\n                if (nextId == currentId) continue;\n                \n                Building nextBuilding = buildings.get(nextId);\n                double distance = currentBuilding.distance(nextBuilding);\n                \n                if (distance <= 50.0) {\n                    double newDist = dist.get(currentId) + distance;\n                    \n                    if (newDist < dist.get(nextId)) {\n                        dist.put(nextId, newDist);\n                        prev.put(nextId, currentId);\n                        pq.offer(new State(nextId, newDist));\n                    }\n                }\n            }\n        }\n        \n        if (!prev.containsKey(goal) && start != goal) {\n            return null;\n        }\n        \n        List<Integer> path = new ArrayList<>();\n        int current = goal;\n        \n        while (current != start) {\n            path.add(current);\n            if (!prev.containsKey(current)) {\n                return null;\n            }\n            current = prev.get(current);\n        }\n        path.add(start);\n        \n        Collections.reverse(path);\n        return path;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Building { int id; int x, y; Building(int id, int x, int y)  = x; this.y = y; } double distance(Building other) { return Math.sqrt((x - other.x) * (x - other.x) + (y - other.y) *   distance; State(int buildingId, double distance) { this.buildingId = buildingId; this.distance = distance; } @Override  return Double.compare(this.distance, other.distance); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) {  (n  buildings = new HashMap<>(); for (int i = 0; i < n; i++) {  x = sc.nextInt(); int y = sc.nextInt(); buildings.put(id,  int m = sc.nextInt(); for (int i =  { int start = sc.nextInt(); int goal = sc.nextInt(); List<Integer> path = findPath(buildings, start, goal); if (path == null) { System.out.println(\"NA\"); } else { StringBuilder sb = new  0; j < path.size(); j++) { if (j > 0) sb.append(\" \"); sb.append(path.get(j)); } System.out.println(sb.toString()); } }  findPath(Map<Integer, Building> buildings, int start, int goal) { Map<Integer, Double> dist  prev =  new PriorityQueue<>(); for (int id : buildings.keySet()) { dist.put(id, Double.MAX_VALUE); } dist.put(start, 0.0); pq.offer(new State(start, 0.0)); while (!pq.isEmpty()) { State current = pq.poll(); int currentId = current.buildingId; if (current.distance > dist.get(currentId)) { continue; } if (currentId == goal)  = buildings.get(currentId); for (int nextId : buildings.keySet()) { if (nextId == currentId) continue; Building nextBuilding  currentBuilding.distance(nextBuilding); if (distance <= 50.0) { double  currentId); pq.offer(new State(nextId, newDist)); } } } } if (!prev.containsKey(goal) && start != goal) {  current  start) { path.add(current); if (!prev.containsKey(current)) { return null; } current = prev.get(current); } path.add(start); Collections.reverse(path); return path; } }"], "perturbed_original": ["import java.io.IOException; import  import java.util.Arrays; import java.util.Collections; import java.util.NoSuchElementException; import java.util.Scanner; public class Main { static PrintWriter out = new PrintWriter(System.out); static Scanner stdIn  sc = new FastScanner(); static int INF =  while(true) {  ==  = new double[n+1][n+1]; for(int i = 0; i < n+1; i++) { Arrays.fill(cost[i], INF); } Data[] list = new Data[n]; for(int i = 0; i < n; i++) { int a = sc.nextInt(); int b = sc.nextInt(); int c  Data(a,b,c); } for(int i = 0; i  j =  { double sum = Math.sqrt((list[i].x - list[j].x)*(list[i].x - list[j].x) + (list[i].y - list[j].y) * (list[i].y - list[j].y)); if(sum > 50.0) { continue; }  int m = sc.nextInt(); for(int i = 0; i < m; i++) { double[] d = new double[n+1];  sc.nextInt(); int g = sc.nextInt(); Arrays.fill(d, INF); Arrays.fill(used,  0; while(true) { int v = -1; for(int u= 0; u < n+1; u++) { if(!used[u] && (v == -1 || d[u] < d[v])) v = u; } if(v == -1) break; used[v] = true; for(int u = 0; u < n+1; u++) { if(d[u] > d[v] + cost[v][u]) { d[u] = d[v] + cost[v][u];  } if(d[g] == INF) { out.println(\"NA\"); continue; } ArrayList<Integer> Xist = new  g = prev[g]) Xist.add(g); Collections.reverse(Xist); out.print(Xist.get(0)); for(int j = 1; j < Xist.size(); j++) { out.print(\" \" + Xist.get(j)); } out.println(); } } out.flush(); } static class Data { int id; int x; int y; Data(int a, int b, int c)  = b; y   InputStream in = System.in; private final byte[] buffer = new byte[1024]; private int ptr = 0; private int buflen = 0; private boolean hasNextByte() { if (ptr  }else{ ptr = 0; try { buflen  if (buflen <= 0) { return false; } } return true; } private int readByte() { if (hasNextByte())  private static boolean isPrintableChar(int c) { return 33 <= c  void skipUnprintable()  public boolean hasNext() { skipUnprintable(); return hasNextByte();} public String next() { if  sb = new StringBuilder(); int  }  nextLong() { if (!hasNext()) throw new NoSuchElementException(); long n = 0; boolean minus = false; int b =  b = readByte(); } if (b < '0' || '9' < b) { throw new NumberFormatException(); } while(true){ if ('0' <= b && b <= '9') { n *= 10; n += b  minus ? -n : n; }else{ throw new NumberFormatException(); } b = readByte(); } } public int nextInt() { return (int)nextLong(); } public double nextDouble() { return Double.parseDouble(next()); } }"], "original_ll": -0.4043050706386566, "sampled_ll": -0.2971985936164856, "all_perturbed_sampled_ll": [-1.2495912313461304], "all_perturbed_original_ll": [-1.2173494100570679], "perturbed_sampled_ll": -1.2495912313461304, "perturbed_original_ll": -1.2173494100570679, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import copy, math\n\ndef f(n, d, D, res, buil):\n    global sd, ans\n    d += D\n    res.append(n)\n    if sd is not None and sd <= d:\n        return\n    elif n == g:\n        ans = res\n        sd = d\n        return\n    else:\n        new_buil = copy.deepcopy(buil)\n        A = new_buil[n]\n        del new_buil[n]\n        for m, B in new_buil.items():\n            D = py(A, B)\n            if D:\n                f(m, d, D, res[:], new_buil)\n            \ndef py(A, B):\n    x = 0\n    y = 1\n    D = math.sqrt((B[x]-A[x])**2+(B[y]-A[y])**2)\n    if D <= 50:\n        return D\n\nwhile True:\n    N = input()\n    if N == 0: break\n    buil = {}\n    for i in range(N):\n        n, x, y = map(int, raw_input().split())\n        buil[n] = (x, y)\n    for i in range(input()):\n        s, g = map(int, raw_input().split())\n        sd = None\n        ans = None\n        f(s, 0, 0, [], buil)\n        if ans:\n            print ' '.join(map(str, ans))\n        else:\n            print 'NA'", "sampled": "import sys\nfrom collections import deque\nimport math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef bfs(start, goal, buildings, adjacency):\n    if start == goal:\n        return [start]\n    \n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        current, path = queue.popleft()\n        \n        for neighbor in adjacency[current]:\n            if neighbor in visited:\n                continue\n            \n            visited.add(neighbor)\n            new_path = path + [neighbor]\n            \n            if neighbor == goal:\n                return new_path\n            \n            queue.append((neighbor, new_path))\n    \n    return None\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    buildings = {}\n    for _ in range(n):\n        parts = list(map(int, input().split()))\n        b_id = parts[0]\n        x = parts[1]\n        y = parts[2]\n        buildings[b_id] = (x, y)\n    \n    # Build adjacency list\n    adjacency = {b_id: [] for b_id in buildings}\n    for b1 in buildings:\n        for b2 in buildings:\n            if b1 != b2:\n                dist = distance(buildings[b1], buildings[b2])\n                if dist <= 50:\n                    adjacency[b1].append(b2)\n    \n    m = int(input())\n    results = []\n    for _ in range(m):\n        s, g = map(int, input().split())\n        path = bfs(s, g, buildings, adjacency)\n        if path is None:\n            results.append(\"NA\")\n        else:\n            results.append(\" \".join(map(str, path)))\n    \n    for result in results:\n        print(result)\n", "perturbed_sampled": ["import sys from collections import deque import math def distance(p1, p2): return  - p2[1])**2) def bfs(start, goal, buildings, adjacency): if start == goal: return [start] queue = deque([(start, [start])]) visited = {start} while queue: current, path = queue.popleft() for neighbor in adjacency[current]: if neighbor in visited:   goal: return new_path queue.append((neighbor, new_path)) return None while True: n =  for _ in range(n): parts = list(map(int, input().split())) b_id = parts[0] x = parts[1] y = parts[2] buildings[b_id] = (x, y) # Build adjacency list adjacency = {b_id: [] for b_id  buildings: for b2 in buildings: if b1  int(input())  in range(m): s, g = map(int, input().split()) path = bfs(s, g, buildings, adjacency) if path is None: results.append(\"NA\") else: results.append(\" \".join(map(str, path))) for result in results: print(result)"], "perturbed_original": ["import copy, math def f(n, d, D, res, buil):  D res.append(n) if sd is not None and sd <= d:  new_buil = copy.deepcopy(buil) A = new_buil[n] del new_buil[n] for m, B in new_buil.items(): D = py(A, B) if D: f(m, d, D, res[:], new_buil) def py(A, B): x = 0 y = 1 D = math.sqrt((B[x]-A[x])**2+(B[y]-A[y])**2) if D <=   == 0: break buil = {} for i in range(N): n, x, y = map(int, raw_input().split())  g = map(int, raw_input().split()) sd = None ans = None f(s, 0, 0, [], buil) if ans: print ' '.join(map(str, ans)) else: print 'NA'"], "original_ll": -1.1736546754837036, "sampled_ll": -0.4460444450378418, "all_perturbed_sampled_ll": [-1.60444176197052], "all_perturbed_original_ll": [-2.0214643478393555], "perturbed_sampled_ll": -1.60444176197052, "perturbed_original_ll": -2.0214643478393555, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ty;\n    int tx;\n    int sharp;\n} POINT;\n\nPOINT queue[10000000];\nint head, tail;\n\nvoid enq(POINT t)\n{\n    queue[tail++] = t;\n    if (tail == 10000000){\n        tail = 0;\n    }\n}\n\nvoid deq(POINT *t)\n{\n    *t = queue[head++];\n    if (head == 10000000){\n        head = 0;\n    }\n}\n\nint main(void)\n{\n    POINT temp, add;\n    int ans;\n    int i, j;\n    int x, y;\n    int mx, my;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int cost[102][102];\n    char map[102][103];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        getchar();\n        \n        memset(map, '.', sizeof(map));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%c\", &map[i][j]);\n                \n                if (map[i][j] == '&'){\n                    temp.tx = j;\n                    temp.ty = i;\n                }\n            }\n            getchar();\n        }\n        \n        for (i = 0; i <= y + 1; i++){\n            for (j = 0; j <= x + 1; j++){\n                cost[i][j] = 100000;\n            }\n        }\n        \n        cost[temp.ty][temp.tx] = 0;\n        temp.sharp = 0;\n        head = tail = 0;\n        enq(temp);\n        ans = 100000;\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (0 == temp.tx || 0 == temp.ty || x + 1 == temp.tx || y + 1 == temp.ty){\n                ans = (ans > temp.sharp ? temp.sharp : ans);\n                continue;\n            }\n            \n            for (i = 0; i < 4; i++){\n                mx = temp.tx + dx[i];\n                my = temp.ty + dy[i];\n                add = temp;\n                if (cost[my][mx] > add.sharp){\n                    if ((map[my][mx] == '.') && map[temp.ty][temp.tx] == '#'){\n                        add.sharp++;\n                    }\n                    cost[my][mx] = add.sharp;\n                    add.tx = mx;\n                    add.ty = my;\n                    enq(add);\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAXN 105\n\ntypedef struct {\n    int x, y, cost;\n} State;\n\ntypedef struct {\n    State data[MAXN * MAXN];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue *q) {\n    q->front = 0;\n    q->rear = 0;\n}\n\nvoid enqueue(Queue *q, State s) {\n    q->data[q->rear++] = s;\n}\n\nState dequeue(Queue *q) {\n    return q->data[q->front++];\n}\n\nint isEmpty(Queue *q) {\n    return q->front == q->rear;\n}\n\nint main() {\n    int n, m;\n    char grid[MAXN][MAXN];\n    int dist[MAXN][MAXN];\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    \n    while (scanf(\"%d %d\", &n, &m) == 2 && (n || m)) {\n        int startX = -1, startY = -1;\n        \n        for (int i = 0; i < m; i++) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '&') {\n                    startX = i;\n                    startY = j;\n                }\n                dist[i][j] = INT_MAX;\n            }\n        }\n        \n        // Check if we can reach from boundary\n        Queue q;\n        initQueue(&q);\n        \n        // Start from all boundary cells\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || i == m-1 || j == 0 || j == n-1) {\n                    State s;\n                    s.x = i;\n                    s.y = j;\n                    if (grid[i][j] == '#') {\n                        s.cost = 1;\n                    } else {\n                        s.cost = 0;\n                    }\n                    dist[i][j] = s.cost;\n                    enqueue(&q, s);\n                }\n            }\n        }\n        \n        while (!isEmpty(&q)) {\n            State cur = dequeue(&q);\n            int x = cur.x;\n            int y = cur.y;\n            int cost = cur.cost;\n            \n            if (cost > dist[x][y]) continue;\n            \n            for (int d = 0; d < 4; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                \n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    int newCost = cost;\n                    if (grid[x][y] == '#' && grid[nx][ny] != '#') {\n                        newCost = cost + 1;\n                    }\n                    \n                    if (newCost < dist[nx][ny]) {\n                        dist[nx][ny] = newCost;\n                        State ns;\n                        ns.x = nx;\n                        ns.y = ny;\n                        ns.cost = newCost;\n                        enqueue(&q, ns);\n                    }\n                }\n            }\n        }\n        \n        if (dist[startX][startY] == INT_MAX) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", dist[startX][startY]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h> #define MAXN 105 typedef struct { int x, y, cost; } State; typedef struct { State  rear; } Queue; void initQueue(Queue *q) { q->front = 0;  enqueue(Queue *q, State s)  State dequeue(Queue *q) { return q->data[q->front++]; } int isEmpty(Queue *q) { return q->front == q->rear; } int   dx[]  int  0}; while (scanf(\"%d %d\", &n, &m) == 2 && (n || m))  startY = -1; for (int i = 0; i < m; i++) { scanf(\"%s\", grid[i]); for (int j = 0; j < n; j++) { if (grid[i][j] == '&') { startX = i; startY = j; } dist[i][j] = INT_MAX; } } // Check if we can reach from boundary Queue q; initQueue(&q); // Start from all boundary cells for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) {  i == m-1 || j == 0 || j == n-1) { State s; s.x = i; s.y = j; if  { s.cost = 0; } dist[i][j] = s.cost; enqueue(&q, s); } } } while (!isEmpty(&q)) { State cur = dequeue(&q); int x = cur.x; int y = cur.y; int cost = cur.cost;  d++) { int nx =  = y + dy[d]; if (nx >= 0 && nx < m && ny >= 0 && ny < n) { int newCost =  && grid[nx][ny] != '#') { newCost =  (newCost < dist[nx][ny])  ns; ns.x = nx; ns.y = ny; ns.cost =  } } if (dist[startX][startY] == INT_MAX) {  0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> typedef struct { int ty; int tx; int sharp; } POINT; POINT queue[10000000];  t) { queue[tail++] = t; if (tail == 10000000){ tail = 0; } } void deq(POINT *t) { *t =  head = 0; } } int main(void) { POINT  y; int mx,  0, -1, 0};  char map[102][103]; while (1){ scanf(\"%d%d\", &x, &y); if (x + y  memset(map, '.',   (j = 1; j <= x; j++){ scanf(\"%c\", &map[i][j]); if (map[i][j] == '&'){ temp.tx = j;  getchar(); } for (i = 0; i <= y + 1; i++){ for (j = 0; j <= x  100000; } } cost[temp.ty][temp.tx] = 0; temp.sharp = 0; head = tail = 0; enq(temp); ans = 100000; while (head != tail){ deq(&temp); if (0 == temp.tx || 0  1 == temp.tx || y + 1 ==  temp.sharp ? temp.sharp : ans); continue; } for (i = 0; i < 4; i++){ mx = temp.tx + dx[i]; my = temp.ty + dy[i]; add = temp; if (cost[my][mx] > add.sharp){ if ((map[my][mx] == '.') && map[temp.ty][temp.tx] ==  add.sharp; add.tx = mx; add.ty = my; enq(add); } } } printf(\"%d\\n\", ans); } return (0); }"], "original_ll": -0.5829373598098755, "sampled_ll": -0.3412652611732483, "all_perturbed_sampled_ll": [-1.2619160413742065], "all_perturbed_original_ll": [-1.6568461656570435], "perturbed_sampled_ll": -1.2619160413742065, "perturbed_original_ll": -1.6568461656570435, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tint gy = -1;\n\t\t\tint gx = -1;\n\t\t\tboolean[][] map = new boolean[h + 2][w + 2];\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (c[j - 1] == '#') {\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t} else if (c[j - 1] == '&') {\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\t\t\tint[][] cnt = new int[h + 2][w + 2];\n\t\t\t\n\t\t\tfor (int[] c : cnt) {\n\t\t\t\tArrays.fill(c, 1 << 10);\n\t\t\t}\n\t\t\tcnt[0][0] = 0;\n\t\t\tDeque<List<Integer>> deque = new ArrayDeque<List<Integer>>();\n\t\t\tdeque.offer(Arrays.asList(0, 0));\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tList<Integer> list = deque.poll();\n\t\t\t\tint y = list.get(0);\n\t\t\t\tint x = list.get(1);\n\t\t\t\tfor (int[] d : dxy) {\n\t\t\t\t\tint dy = y + d[0];\n\t\t\t\t\tint dx = x + d[1];\n\t\t\t\t\tif (0 <= dy && dy < h + 2 && 0 <= dx & dx < w + 2) {\n\t\t\t\t\t\tint r;\n\t\t\t\t\t\tif (map[y][x] && !map[dy][dx]) {\n\t\t\t\t\t\t\tr = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cnt[dy][dx] > cnt[y][x] + r) {\n\t\t\t\t\t\t\tcnt[dy][dx] = cnt[y][x] + r;\n\t\t\t\t\t\t\tdeque.offer(Arrays.asList(dy, dx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt[gy][gx]);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class State implements Comparable<State> {\n        int x, y, climbs;\n        \n        State(int x, int y, int climbs) {\n            this.x = x;\n            this.y = y;\n            this.climbs = climbs;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return this.climbs - other.climbs;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            int n = Integer.parseInt(parts[0]);\n            int m = Integer.parseInt(parts[1]);\n            \n            if (n == 0 && m == 0) break;\n            \n            char[][] grid = new char[m][n];\n            int targetX = -1, targetY = -1;\n            \n            for (int i = 0; i < m; i++) {\n                String row = br.readLine();\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = row.charAt(j);\n                    if (grid[i][j] == '&') {\n                        targetX = i;\n                        targetY = j;\n                    }\n                }\n            }\n            \n            int result = solve(grid, m, n, targetX, targetY);\n            System.out.println(result);\n        }\n    }\n    \n    static int solve(char[][] grid, int m, int n, int targetX, int targetY) {\n        int[][] minClimbs = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(minClimbs[i], Integer.MAX_VALUE);\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        \n        // Start from all border cells\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {\n                    int initialClimbs = (grid[i][j] == '#') ? 1 : 0;\n                    pq.offer(new State(i, j, initialClimbs));\n                    minClimbs[i][j] = initialClimbs;\n                }\n            }\n        }\n        \n        int[] dx = {-1, 1, 0, 0};\n        int[] dy = {0, 0, -1, 1};\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            if (current.x == targetX && current.y == targetY) {\n                return current.climbs;\n            }\n            \n            if (current.climbs > minClimbs[current.x][current.y]) {\n                continue;\n            }\n            \n            for (int i = 0; i < 4; i++) {\n                int nx = current.x + dx[i];\n                int ny = current.y + dy[i];\n                \n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    boolean currentInMoat = (grid[current.x][current.y] == '#');\n                    boolean nextInMoat = (grid[nx][ny] == '#');\n                    \n                    int newClimbs = current.climbs;\n                    if (currentInMoat && !nextInMoat) {\n                        newClimbs++;\n                    }\n                    \n                    if (newClimbs < minClimbs[nx][ny]) {\n                        minClimbs[nx][ny] = newClimbs;\n                        pq.offer(new State(nx, ny, newClimbs));\n                    }\n                }\n            }\n        }\n        \n        return minClimbs[targetX][targetY];\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class State implements Comparable<State> { int x, y, <extra_id_4>pq.offer(new State(0,<extra_id_5>#1;<extra_id_6>; return<extra_id_7>else<extra_id_8>new<extra_id_9>int initialClimbs = (grid[j][j]<extra_id_10>minClimbs[x][y] + (grid[n][j]<extra_id_11>1; n[j]<extra_id_12>if (grid[i][j] == int climbs) {  y; this.climbs = climbs; } @Override public int compareTo(State other) { return this.climbs - other.climbs; } } public static void main(String[] args)  = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] parts = line.trim().split(\"\\\\s+\"); int n = Integer.parseInt(parts[0]); int m =  && m == 0) break; char[][] grid = new char[m][n]; int targetX = -1, targetY = -1; for (int i = 0; i < m; i++) { String row = br.readLine(); for  grid[i][j] = row.charAt(j); if (grid[i][j] == '&') { targetX = i;  } int  grid, int m, int n, int targetX, int targetY) { int[][] minClimbs = new int[m][n]; for (int i = 0; i < m; i++)  pq = new PriorityQueue<>(); // Start  (int  m; i++)  0; j < n; j++) { if (i == 0 || i == m - 1 || j == 0 || j == n - 1) { int initialClimbs = (grid[i][j] == '#') ? 1  initialClimbs)); minClimbs[i][j] = initialClimbs; } } }  0, 0}; int[] dy = {0, 0, -1, 1}; while (!pq.isEmpty()) { State current = pq.poll(); if (current.x == targetX && current.y == targetY) { return current.climbs;  { continue; } for (int i = 0; i < 4; i++) {  current.y  m && ny >= 0 && ny < n) { boolean currentInMoat = (grid[current.x][current.y] == '#'); boolean nextInMoat = (grid[nx][ny] == '#'); int newClimbs = current.climbs; if (currentInMoat && !nextInMoat) { newClimbs++; } if (newClimbs < minClimbs[nx][ny]) { minClimbs[nx][ny] = newClimbs; pq.offer(new State(nx, ny, newClimbs)); }  } }"], "perturbed_original": ["import java.util.ArrayDeque; import java.util.Arrays;  java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (true) { int w = scanner.nextInt();  (w == 0 && h == 0) break; int gy = -1; int gx =  boolean[h + 2][w + 2]; for (int i  i++) { char[] c = scanner.next().toCharArray(); for (int j = 1; j <= w;  1] == '#')  else if (c[j - 1] == '&') { gy = i; gx = j; } } }  -1, 0  { 0, 1 }, {  + 2][w + 2]; for (int[] c :  10); } cnt[0][0] = 0; Deque<List<Integer>> deque = new ArrayDeque<List<Integer>>(); deque.offer(Arrays.asList(0, 0)); while (!deque.isEmpty()) { List<Integer> list = deque.poll(); int y = list.get(0); int x = list.get(1); for (int[] d :  y + d[0]; int dx = x +  && dy < h + 2 && 0  w + 2) { int r; if (map[y][x] && !map[dy][dx]) { r = 1; } else { r = 0; } if (cnt[dy][dx] > cnt[y][x] + r) { cnt[dy][dx] = cnt[y][x] + r; deque.offer(Arrays.asList(dy, dx)); }  } }"], "original_ll": -0.45212188363075256, "sampled_ll": -0.29742056131362915, "all_perturbed_sampled_ll": [-1.392261028289795], "all_perturbed_original_ll": [-1.438798189163208], "perturbed_sampled_ll": -1.392261028289795, "perturbed_original_ll": -1.438798189163208, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from heapq import heappush, heappop\n\nwhile True:\n  n, m = map(int, input().split())\n  if n == 0: break\n\n  mp = [\"X\" + input() + \"X\" for _ in range(m)]\n  mp.insert(0, \"X\" * (n + 2))\n  mp.append(\"X\" * (n + 2))\n  \n  que = []\n  visited = [[False] * (n + 2) for _ in range(m + 2)]\n  sur_flag = False\n  for i in range(1, n + 1):\n    if mp[1][i] ==\"&\" or mp[m][i] == \"&\":\n      sur_flag = True\n      break\n    c1, s1 = (1, 0) if mp[1][i] == \"#\" else (0, 1)\n    c2, s2 = (1, 0) if mp[m][i] == \"#\" else (0, 1)\n    heappush(que, (c1, s1, (i, 1)))\n    heappush(que, (c2, s2, (i, m)))\n    visited[1][i] = True\n    visited[m][i] = True\n  \n  for i in range(1, m + 1):\n    if mp[i][1] == \"&\" or mp[i][n] == \"&\":\n      sur_flag = True\n      break\n    c1, s1 = (1, 0) if mp[i][1] == \"#\" else (0, 1)\n    c2, s2 = (1, 0) if mp[i][n] == \"#\" else (0, 1)\n    heappush(que, (c1, s1, (1, i)))\n    heappush(que, (c2, s2, (n, i)))\n    visited[i][1] = True\n    visited[i][n] = True\n  \n  if sur_flag:\n    print(0)\n    continue\n  \n  direct = ((0, 1), (0, -1), (1, 0), (-1, 0))\n  reached = False\n  \n  while que and not reached:\n    cost, status, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      newx, newy = x + dx, y + dy\n      if not visited[newy][newx]:\n        visited[newy][newx] = True\n        if mp[newy][newx] == \"&\":\n          print(cost)\n          reached = True\n          break\n        elif mp[newy][newx] == \"#\":\n          if status == 1:\n            heappush(que, (cost + 1, 0, (newx, newy)))\n          else:\n            heappush(que, (cost, 0, (newx, newy)))\n        elif mp[newy][newx] == \".\":\n          heappush(que,(cost, 1, (newx, newy)))\n", "sampled": "from collections import deque\n\ndef solve(n, m, grid):\n    # Find the position of '&' (castle keep)\n    castle_pos = None\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '&':\n                castle_pos = (i, j)\n                break\n        if castle_pos:\n            break\n    \n    # BFS with state (row, col, climbs)\n    # We want to find minimum climbs to reach castle from outside\n    # Outside means any position on the border or reachable from border\n    \n    # Use 0-1 BFS (or Dijkstra-like approach)\n    # State: (climbs, row, col, in_moat)\n    # in_moat: True if currently in a moat\n    \n    visited = {}  # (row, col, in_moat) -> min_climbs\n    pq = deque()\n    \n    # Start from all border positions\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or i == m-1 or j == 0 or j == n-1:\n                in_moat = (grid[i][j] == '#')\n                pq.append((0, i, j, in_moat))\n                visited[(i, j, in_moat)] = 0\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    while pq:\n        climbs, row, col, in_moat = pq.popleft()\n        \n        if row == castle_pos[0] and col == castle_pos[1]:\n            return climbs\n        \n        if visited.get((row, col, in_moat), float('inf')) < climbs:\n            continue\n        \n        for dr, dc in directions:\n            nr, nc = row + dr, col + dc\n            if 0 <= nr < m and 0 <= nc < n:\n                next_is_moat = (grid[nr][nc] == '#')\n                \n                # Calculate climbs needed\n                new_climbs = climbs\n                if in_moat and not next_is_moat:\n                    # Climbing out of moat\n                    new_climbs = climbs + 1\n                \n                if visited.get((nr, nc, next_is_moat), float('inf')) > new_climbs:\n                    visited[(nr, nc, next_is_moat)] = new_climbs\n                    if new_climbs == climbs:\n                        pq.appendleft((new_climbs, nr, nc, next_is_moat))\n                    else:\n                        pq.append((new_climbs, nr, nc, next_is_moat))\n    \n    return -1\n\nwhile True:\n    line = input().split()\n    n, m = int(line[0]), int(line[1])\n    if n == 0 and m == 0:\n        break\n    \n    grid = []\n    for _ in range(m):\n        grid.append(input().strip())\n    \n    result = solve(n, m, grid)\n    print(result)\n", "perturbed_sampled": ["from collections import deque def solve(n, m, grid): # Find the position of '&' (castle keep) castle_pos = None for i  range(n): if grid[i][j] == '&': castle_pos = (i, j) break  with state (row, col, climbs) # We want to find minimum climbs to  Outside means any position on the border or  0-1 BFS (or Dijkstra-like approach) # State: (climbs, row, col, in_moat) # in_moat: True if currently in a moat visited = {} # (row, col, in_moat) -> min_climbs pq =  border positions for i in range(m): for j  m-1 or j == 0 or j == n-1: in_moat = (grid[i][j] == '#') pq.append((0, i, j, in_moat)) visited[(i, j, in_moat)] = 0 directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  row == castle_pos[0]  climbs if visited.get((row, col, in_moat), float('inf'))  nc = row + dr, col + dc if 0 <= nr < m and 0 <= nc < n: next_is_moat  Calculate climbs needed new_climbs =  next_is_moat: # Climbing out of moat new_climbs = climbs + 1  > new_climbs: visited[(nr, nc, next_is_moat)] = new_climbs if new_climbs == climbs: pq.appendleft((new_climbs,  nr,  True: line = input().split() n, m = int(line[0]), int(line[1]) if n == 0 and m == 0: break grid = [] for _ in range(m): grid.append(input().strip()) result = solve(n, m, grid) print(result)"], "perturbed_original": ["from heapq import heappush, heappop while True: n, m = map(int, input().split()) if n == 0: break mp =  + 2)) mp.append(\"X\" * (n + 2)) que = [] visited =  for _ in range(m + 2)] sur_flag  if mp[1][i] ==\"&\" or mp[m][i] == \"&\": sur_flag = True  0) if mp[1][i]  c2, s2 = (1,  else (0, 1) heappush(que, (c1, s1, (i, 1))) heappush(que, (c2,  True visited[m][i] = True for i in range(1, m + 1): if mp[i][1] == \"&\" or mp[i][n] == \"&\": sur_flag = True break c1, s1 = (1, 0) if mp[i][1] == \"#\" else (0, 1) c2, s2 = (1, 0)  (0, 1) heappush(que,  (c2, s2, (n, i))) visited[i][1] = True visited[i][n] = True if sur_flag: print(0) continue direct = ((0, 1), (0, -1), (1, 0),  while que and not reached: cost,  y = point for dx, dy in direct: newx, newy = x + dx, y + dy if not visited[newy][newx]: visited[newy][newx] = True if mp[newy][newx] == \"&\": print(cost) reached = True break elif mp[newy][newx] == \"#\":  (cost + 1, 0, (newx, newy))) else: heappush(que, (cost, 0, (newx, newy))) elif mp[newy][newx] == \".\": heappush(que,(cost, 1, (newx, newy)))"], "original_ll": -0.47431817650794983, "sampled_ll": -0.7222892642021179, "all_perturbed_sampled_ll": [-1.88898766040802], "all_perturbed_original_ll": [-1.3453779220581055], "perturbed_sampled_ll": -1.88898766040802, "perturbed_original_ll": -1.3453779220581055, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n\tint h;\n\tint r;\n} DOLL;\n\nint cmp(const void *a, const void *b)\n{\n\tDOLL x, y;\n\t\n\tx = *(DOLL *)a;\n\ty = *(DOLL *)b;\n\t\n\tif (x.r - y.r){\n\t\treturn (x.r - y.r);\n\t}\n\treturn (x.h - y.h);\n}\n\nint main(void)\n{\n\tDOLL rusd[256];\n\tint dp[256];\n\tint n, m;\n\tint i, j;\n\tint ans;\n\t\n\twhile (1){\n\t\tans = 0;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) break;\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d\", &rusd[i].h, &rusd[i].r);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor (j = 0; j < m; j++){\n\t\t\tscanf(\"%d %d\", &rusd[n + j].h, &rusd[n + j].r);\n\t\t}\n\t\tqsort(rusd, n + m, sizeof(DOLL), cmp);\n\t\t\n\t\tfor (i = 0; i < n + m; i++){\n\t\t\tdp[i] = 1;\n\t\t\tfor (j = 0; j < i; j++){\n\t\t\t\tif (rusd[i].h > rusd[j].h && rusd[i].r > rusd[j].r){\n\t\t\t\t\tif (dp[i] < dp[j] + 1){\n\t\t\t\t\t\tdp[i] = dp[j] + 1;\n\t\t\t\t\t\tif (ans < dp[i]){\n\t\t\t\t\t\t\tans = dp[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int h, r;\n} Doll;\n\nint n, m;\nDoll dolls[205];\nint dp[205];\nint parent[205];\n\nint canContain(int i, int j) {\n    return dolls[i].h < dolls[j].h && dolls[i].r < dolls[j].r;\n}\n\nint compare(const void *a, const void *b) {\n    Doll *da = (Doll *)a;\n    Doll *db = (Doll *)b;\n    if (da->h != db->h) return da->h - db->h;\n    return da->r - db->r;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &dolls[i].h, &dolls[i].r);\n        }\n        \n        scanf(\"%d\", &m);\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d\", &dolls[n + i].h, &dolls[n + i].r);\n        }\n        \n        int total = n + m;\n        \n        qsort(dolls, total, sizeof(Doll), compare);\n        \n        for (int i = 0; i < total; i++) {\n            dp[i] = 1;\n            parent[i] = -1;\n        }\n        \n        int maxLen = 1;\n        for (int i = 1; i < total; i++) {\n            for (int j = 0; j < i; j++) {\n                if (canContain(j, i)) {\n                    if (dp[j] + 1 > dp[i]) {\n                        dp[i] = dp[j] + 1;\n                        parent[i] = j;\n                    }\n                }\n            }\n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n            }\n        }\n        \n        printf(\"%d\\n\", maxLen);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef  } Doll; int n, m;  parent[205]; int canContain(int  dolls[i].h < dolls[j].h && dolls[i].r < dolls[j].r; } int compare(const void *a, const void *b) { Doll *da = (Doll *)a; Doll *db = (Doll *)b; if (da->h != db->h) return  - db->r; } int main()  &n); if (n == 0) break; for (int i = 0; i < n; i++) { scanf(\"%d %d\", &dolls[i].h, &dolls[i].r); } scanf(\"%d\", &m); for (int i = 0; i < m; i++) {  &dolls[n + i].r); } int total = n + m;  (int i = 0; i < total; i++) { dp[i] = 1; parent[i] =  1; for (int  total;  = 0; j < i; j++) { if (canContain(j, i)) { if (dp[j]  dp[i] = dp[j] + 1; parent[i] = j; } } } if (dp[i] > maxLen) { maxLen = dp[i]; }  0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> #include <string.h>  int r; } DOLL; int cmp(const void *a, const void *b) { DOLL x, y; x = *(DOLL *)a; y = *(DOLL  return (x.r -  { DOLL rusd[256]; int dp[256]; int n,  ans; while (1){ ans = 0; memset(dp, 0, sizeof(dp)); scanf(\"%d\", &n); if (n == 0) break; for (i = 0; i < n; i++){ scanf(\"%d %d\", &rusd[i].h, &rusd[i].r); } scanf(\"%d\", &m); for (j = 0; j < m; j++){ scanf(\"%d %d\", &rusd[n +  sizeof(DOLL), cmp); for (i = 0; i < n + m; i++){ dp[i] = 1; for (j  j++){ if (rusd[i].h > rusd[j].h && rusd[i].r > rusd[j].r){ if (dp[i] < dp[j] +  1; if  dp[i]; } } } } } printf(\"%d\\n\", ans); } return (0); }"], "original_ll": -0.505160391330719, "sampled_ll": -0.3884802758693695, "all_perturbed_sampled_ll": [-1.400979995727539], "all_perturbed_original_ll": [-1.404550313949585], "perturbed_sampled_ll": -1.400979995727539, "perturbed_original_ll": -1.404550313949585, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[][] data;\n\tint[] memo;\n\tboolean[] use;\n\tint n, m, N;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdata = new int[201][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tdata[i][0] = sc.nextInt();\n\t\t\t\tdata[i][1] = sc.nextInt();\n\t\t\t}\n\t\t\tm = sc.nextInt();\n\t\t\tfor (int i = n; i < m + n; i++) {\n\t\t\t\tdata[i][0] = sc.nextInt();\n\t\t\t\tdata[i][1] = sc.nextInt();\n\t\t\t}\n\n\t\t\tN = n + m;\n\t\t\tmemo = new int[n + m];\n\t\t\tuse = new boolean[n + m];\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tans = Math.max(ans, dfs(i));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tint dfs(int index) {\n\t\tif (memo[index] > 0) {\n\t\t\treturn memo[index];\n\t\t}\n\t\tint res = 1;\n\t\tuse[index] = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!use[i]) {\n\t\t\t\tif (data[i][0] < data[index][0] && data[i][1] < data[index][1]) {\n\t\t\t\t\tres = Math.max(res, dfs(i) + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tuse[index] = false;\n\t\treturn memo[index] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Doll implements Comparable<Doll> {\n        int h, r;\n        \n        Doll(int h, int r) {\n            this.h = h;\n            this.r = r;\n        }\n        \n        @Override\n        public int compareTo(Doll other) {\n            if (this.h != other.h) {\n                return this.h - other.h;\n            }\n            return this.r - other.r;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            List<Doll> dolls = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                int h = sc.nextInt();\n                int r = sc.nextInt();\n                dolls.add(new Doll(h, r));\n            }\n            \n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                int h = sc.nextInt();\n                int r = sc.nextInt();\n                dolls.add(new Doll(h, r));\n            }\n            \n            Collections.sort(dolls);\n            \n            int[] dp = new int[dolls.size()];\n            Arrays.fill(dp, 1);\n            \n            for (int i = 1; i < dolls.size(); i++) {\n                for (int j = 0; j < i; j++) {\n                    if (dolls.get(j).h < dolls.get(i).h && dolls.get(j).r < dolls.get(i).r) {\n                        dp[i] = Math.max(dp[i], dp[j] + 1);\n                    }\n                }\n            }\n            \n            int max = 0;\n            for (int i = 0; i < dolls.size(); i++) {\n                max = Math.max(max, dp[i]);\n            }\n            \n            System.out.println(max);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  { int h, r; Doll(int h, int r) { this.h = h; this.r = r; } @Override public int compareTo(Doll other) {  return this.h  - other.r; } } public static void main(String[] args)  Scanner(System.in); while (true) { int n =  break; List<Doll> dolls = new ArrayList<>(); for (int  n; i++) { int h = sc.nextInt(); int r = sc.nextInt(); dolls.add(new Doll(h, r)); } int m =  0; i < m;  sc.nextInt(); int r = sc.nextInt(); dolls.add(new Doll(h, r)); } Collections.sort(dolls); int[] dp = new int[dolls.size()]; Arrays.fill(dp, 1); for (int i = 1; i < dolls.size(); i++) { for (int j = 0; j < i; j++) { if  < dolls.get(i).r) { dp[i] = Math.max(dp[i], dp[j] + 1); } } } int max = 0; for (int i = 0; i < dolls.size(); i++) { max = Math.max(max, dp[i]);  }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { MyScanner sc = new MyScanner(); Scanner sc2 = new Scanner(System.in); int mod = 1000000007; int[][] data; int[] memo; boolean[] use; int n, m, N; void run() { for (;;) { n = sc.nextInt(); if (n == 0) { return; } data = new int[201][2]; for (int i  i++) { data[i][0] = sc.nextInt(); data[i][1] = sc.nextInt(); } m = sc.nextInt(); for (int i = n; i < m + n; i++) { data[i][0] = sc.nextInt(); data[i][1]  n +  + m]; use = new   = 0; i < N; i++) { ans = Math.max(ans, dfs(i)); } System.out.println(ans); } } int dfs(int index) { if (memo[index] > 0) { return memo[index]; } int res = 1; use[index] = true; for  <   { res = Math.max(res,  } use[index] = false; return memo[index] = res; } public static void main(String[] args) { new Main().run(); } void debug(Object...  debug2(int[][] array) { for (int i = 0; i < array.length; i++) { for (int j = 0; j < array[i].length; j++) { System.out.print(array[i][j]); } System.out.println(); } } class MyScanner { int nextInt() { try {  (c !=   = System.in.read(); if (c == '-') return -nextInt(); int res = 0; do { res *= 10; res += c - '0'; c  <= c &&  } catch (Exception e) { return -1; } } double nextDouble() { return Double.parseDouble(next()); } String next() {  = System.in.read(); while (Character.isWhitespace(c)) c = System.in.read(); do  (!Character.isWhitespace(c = System.in.read())); return res.toString(); } catch  } } } }"], "original_ll": -0.4549693763256073, "sampled_ll": -0.25210440158843994, "all_perturbed_sampled_ll": [-1.0889184474945068], "all_perturbed_original_ll": [-1.4099551439285278], "perturbed_sampled_ll": -1.0889184474945068, "perturbed_original_ll": -1.4099551439285278, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from operator import itemgetter\n\ndef f(f1, f2):\n    res = 1\n    c = 0\n    i = 0\n    while c < len(L)-1:\n        if L[i][f1] > L[i+1][f1] and L[i][f2] > L[i+1][f2]:\n            res += 1\n            i += 1\n        else:\n            del L[i+1]\n        c += 1\n    return res\n\nwhile True:\n    n = input()\n    if n == 0: break\n    L = [map(int, raw_input().split()) for i in range(n)]\n    for i in range(input()):\n        L.append(map(int, raw_input().split()))\n    else:\n        h = 0\n        r = 1\n        L.sort(key=itemgetter(0,1), reverse=True)\n        res1 = f(h, r)\n        L.sort(key=itemgetter(1,0), reverse=True)\n        res2 = f(r, h)\n        if res2 < res1:\n            print res1\n        else:\n            print res2", "sampled": "import sys\nfrom bisect import bisect_left\n\ndef longest_chain(dolls):\n    if not dolls:\n        return 0\n    \n    # Sort by height, then by radius\n    dolls.sort()\n    \n    # dp[i] = minimum radius for a chain of length i+1\n    dp = []\n    \n    for h, r in dolls:\n        # Find the longest chain where we can add this doll\n        # We need to find largest index where dp[index] < r\n        pos = bisect_left(dp, r)\n        \n        if pos < len(dp):\n            dp[pos] = r\n        else:\n            dp.append(r)\n    \n    return len(dp)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    dolls1 = []\n    for _ in range(n):\n        h, r = map(int, input().split())\n        dolls1.append((h, r))\n    \n    m = int(input())\n    dolls2 = []\n    for _ in range(m):\n        h, r = map(int, input().split())\n        dolls2.append((h, r))\n    \n    # Combine all dolls\n    all_dolls = dolls1 + dolls2\n    \n    # Find longest chain\n    result = longest_chain(all_dolls)\n    print(result)\n", "perturbed_sampled": ["import sys from bisect import bisect_left  by  # dp[i] = minimum radius for a chain of length i+1 dp = [] for h, r in dolls: # Find the longest chain where we can add this doll # We need to find largest index where dp[index] < r pos =  len(dp): dp[pos] = r else: dp.append(r) return len(dp) while True: n = int(input()) if n == 0:  r = map(int, input().split()) dolls1.append((h, r)) m = int(input())  in range(m): h, r = map(int, input().split()) dolls2.append((h, r))  = dolls1 + dolls2 # Find longest chain result = longest_chain(all_dolls) print(result)"], "perturbed_original": ["from operator import itemgetter  i = 0 while c < len(L)-1:  L[i][f2] > L[i+1][f2]: res += 1 i += 1 else: del L[i+1] c += 1 return res while True: n = input() if n ==  raw_input().split()) for i in range(n)] for i in range(input()): L.append(map(int, raw_input().split())) else: h = 0 r  = f(h, r) L.sort(key=itemgetter(1,0), reverse=True) res2 = f(r, h) if res2 < res1: print res1 else: print res2"], "original_ll": -0.9160102605819702, "sampled_ll": -0.9002872109413147, "all_perturbed_sampled_ll": [-2.383772850036621], "all_perturbed_original_ll": [-2.1619694232940674], "perturbed_sampled_ll": -2.383772850036621, "perturbed_original_ll": -2.1619694232940674, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int n,c;\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    for(c=0;n!=1;c++){\n      if(n%2==0){\n\tn/=2;\n      }\n      else{\n\tn=n*3+1;\n      }\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int count = 0;\n        while(n != 1) {\n            if(n % 2 == 0) {\n                n = n / 2;\n            } else {\n                n = 3 * n + 1;\n            }\n            count++;\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  { scanf(\"%d\", &n); if(n ==  0; while(n != 1) { if(n % 2 == 0) { n = n  n = 3 * n + 1; } count++; } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int n,c; while(1){ scanf(\"%d\",&n); if(n==0)break; for(c=0;n!=1;c++){ if(n%2==0){ n/=2; } else{ n=n*3+1;  0; }"], "original_ll": -0.8659563660621643, "sampled_ll": -0.4436354339122772, "all_perturbed_sampled_ll": [-1.9425157308578491], "all_perturbed_original_ll": [-1.6795973777770996], "perturbed_sampled_ll": -1.9425157308578491, "perturbed_original_ll": -1.6795973777770996, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n\n\tfinal Scanner stdin = new Scanner(System.in);\n\n\twhile ( true ) {\n\t    int n = stdin.nextInt();\n\t    if ( n == 0 ) {\n\t\tbreak;\n\t    }\n\n\t    int count = 0;\n\t    while ( n != 1 ) {\n\t\tif ( n % 2 == 0 ) {\n\t\t    n /= 2;\n\t\t} else {\n\t\t    n = n * 3 + 1;\n\t\t}\n\t\tcount++;\n\t    }\n\t    System.out.println( count );\n\t}\t\n    }    \n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            while (n != 1) {\n                if (n % 2 == 0) {\n                    n = n / 2;\n                } else {\n                    n = n * 3 + 1;\n                }\n                count++;\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int count = 0; while (n != 1) {  0)  2; } else { n =  } count++; } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import  { public static  Scanner stdin = new Scanner(System.in); while ( true ) { int n = stdin.nextInt(); if ( n == 0 ) { break; } int count = 0;  ) { if ( n % 2 == 0 ) { n /= 2; } else {  + 1; } count++; } System.out.println( count ); } } }"], "original_ll": -0.72200608253479, "sampled_ll": -0.3652181625366211, "all_perturbed_sampled_ll": [-1.5903011560440063], "all_perturbed_original_ll": [-1.715453863143921], "perturbed_sampled_ll": -1.5903011560440063, "perturbed_original_ll": -1.715453863143921, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n\tn = int(input())\n\tif n == 0: break\n\tk = 0\n\twhile n > 1:\n\t\tif n & 1:\n\t\t\tn = n + ((n+1)>>1)\n\t\t\tk += 2\n\t\telse:\n\t\t\tn >>= 1\n\t\t\tk += 1\n\tprint(k)\n", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = 0\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        count += 1\n    \n    print(count)\n", "perturbed_sampled": [" if n == 0: break count = 0 while n  2 == 0: n = n // 2 else: n = 3 * n + 1 count += 1 print(count)"], "perturbed_original": [" if n == 0: break k = 0 while n > 1: if n  + ((n+1)>>1) k += 2 else: n >>= 1 k += 1 print(k)"], "original_ll": -1.0102958679199219, "sampled_ll": -0.4923757314682007, "all_perturbed_sampled_ll": [-1.70725679397583], "all_perturbed_original_ll": [-2.2579689025878906], "perturbed_sampled_ll": -1.70725679397583, "perturbed_original_ll": -2.2579689025878906, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\nint n,a[1001],b[1001],c[1001],i,k=1001;\ndouble x,y,z,d[1001],w=10000;\nwhile(1){\nscanf(\"%d\\n\",&n);\nif(n==0){\nbreak;\n}\nfor(i=0;i<n;i++){\nscanf(\"%d %d %d\\n\",&a[i],&b[i],&c[i]);\nx=b[i],y=c[i];\nx=x/100;\nz=y/(x*x);\nif(z>22){\nz=z-22;\n}\nelse{\nz=22-z;\n}\nd[i]=z;\nif((z<w) || (z==w && k>a[i])){\nw=z;\nk=a[i];\n}\n}\nfor(i=0;i<n;i++){\nif(w==d[i]){\nprintf(\"%d\\n\",a[i]);\nbreak;\n}\n}\nw=10000,k=1001;\n}\nreturn 0;\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int best_p = -1;\n        double min_diff = -1;\n        \n        for(int i = 0; i < n; i++) {\n            int p, h, w;\n            scanf(\"%d %d %d\", &p, &h, &w);\n            \n            double height_m = h / 100.0;\n            double bmi = w / (height_m * height_m);\n            double diff = fabs(bmi - 22.0);\n            \n            if(min_diff < 0 || diff < min_diff || (diff == min_diff && p < best_p)) {\n                min_diff = diff;\n                best_p = p;\n            }\n        }\n        \n        printf(\"%d\\n\", best_p);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main()  == 1 && n != 0) { int best_p  0; i < n; i++) { int p, h,  &h, &w); double height_m = h / 100.0; double bmi = w / (height_m * height_m); double diff = fabs(bmi - 22.0); if(min_diff < 0 || diff < min_diff || (diff == min_diff && p < best_p)) { min_diff  } } printf(\"%d\\n\", best_p); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int n,a[1001],b[1001],c[1001],i,k=1001; double x,y,z,d[1001],w=10000; while(1){ scanf(\"%d\\n\",&n); if(n==0){ break;  x=b[i],y=c[i]; x=x/100; z=y/(x*x); if(z>22){ z=z-22; } else{ z=22-z; } d[i]=z;  w=z; k=a[i]; } } for(i=0;i<n;i++){ if(w==d[i]){ printf(\"%d\\n\",a[i]); break; } } w=10000,k=1001; } return 0; }"], "original_ll": -1.0706024169921875, "sampled_ll": -0.6591346263885498, "all_perturbed_sampled_ll": [-1.8717472553253174], "all_perturbed_original_ll": [-1.5487558841705322], "perturbed_sampled_ll": -1.8717472553253174, "perturbed_original_ll": -1.5487558841705322, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tR[] rs;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint id=sc.nextInt();\n\t\t\t\tint h=sc.nextInt();\n\t\t\t\tint w=sc.nextInt();\n\t\t\t\trs[i]=new R(id, h, w);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tArrays.sort(rs);\n\t\tprintln(\"\"+rs[0].id);\n\t}\n\n\tclass R implements Comparable<R>{\n\t\tint id;\n\t\tdouble error;\n\n\t\tR(int id, int h, int w){\n\t\t\tthis.id=id;\n\t\t\terror=Math.abs(22-10000.*w/h/h);\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(R r){\n\t\t\tif(error+EPS<r.error){\n\t\t\t\treturn -1;\n\t\t\t}else if(error>r.error+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn id-r.id;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int bestP = Integer.MAX_VALUE;\n            double minDiff = Double.MAX_VALUE;\n            \n            for (int i = 0; i < n; i++) {\n                int p = sc.nextInt();\n                int h = sc.nextInt();\n                int w = sc.nextInt();\n                \n                double heightInMeters = h / 100.0;\n                double bmi = w / (heightInMeters * heightInMeters);\n                double diff = Math.abs(bmi - 22.0);\n                \n                if (diff < minDiff || (diff == minDiff && p < bestP)) {\n                    minDiff = diff;\n                    bestP = p;\n                }\n            }\n            \n            System.out.println(bestP);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int bestP = Integer.MAX_VALUE; double minDiff = Double.MAX_VALUE; for (int  n; i++) { int p = sc.nextInt(); int h = sc.nextInt(); int w = sc.nextInt(); double heightInMeters  (heightInMeters  (diff == minDiff && p < bestP)) { minDiff = diff; bestP = p; } } System.out.println(bestP); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.lang.*; import java.math.*; import java.io.*; import static java.lang.Math.*; import static java.util.Arrays.*; public class Main{ Scanner sc=new Scanner(System.in); int  for(;;){ n=sc.nextInt(); if(n==0){ break; } rs=new R[n];  w); } solve(); } } void solve(){ Arrays.sort(rs); println(\"\"+rs[0].id); } class R implements Comparable<R>{ int id; double  int w){ this.id=id; error=Math.abs(22-10000.*w/h/h); } @Override public int compareTo(R r){ if(error+EPS<r.error){ return -1; }else if(error>r.error+EPS){ return 1; }else{ return id-r.id;  os){ System.err.println(Arrays.deepToString(os)); } void print(String s){ System.out.print(s); } void println(String s){ System.out.println(s); } public static void main(String[] args){ // System.setOut(new PrintStream(new BufferedOutputStream(System.out))); new Main().run(); } }"], "original_ll": -0.8436276912689209, "sampled_ll": -0.5821609497070312, "all_perturbed_sampled_ll": [-1.464495301246643], "all_perturbed_original_ll": [-1.7592288255691528], "perturbed_sampled_ll": -1.464495301246643, "perturbed_original_ll": -1.7592288255691528, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = input()\n    if n == 0: break\n    pb = None\n    ans = 0\n    for i in range(n):\n        i, h, w = map(int, raw_input().split())\n        bmi = w/((float(h)/100)**2)\n        a = abs(22-bmi)\n        if pb is None:\n            pb = a\n            ans = i\n        elif pb is not None and a < pb:\n            pb = a\n            ans = i\n    else:\n        print ans", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    best_person = None\n    best_diff = float('inf')\n    \n    for _ in range(n):\n        data = list(map(int, input().split()))\n        p, h, w = data[0], data[1], data[2]\n        \n        # Convert height from cm to m\n        h_m = h / 100.0\n        \n        # Calculate BMI\n        bmi = w / (h_m * h_m)\n        \n        # Calculate difference from ideal BMI (22)\n        diff = abs(bmi - 22)\n        \n        # Update best if this is closer, or same distance but smaller reception number\n        if diff < best_diff or (diff == best_diff and p < best_person):\n            best_diff = diff\n            best_person = p\n    \n    print(best_person)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break best_person = None best_diff = float('inf') for _ in range(n): data = list(map(int, input().split())) p, h, w  Convert height from cm to  100.0 # Calculate BMI bmi = w / (h_m * h_m) # Calculate difference from ideal BMI (22) diff = abs(bmi - 22) # Update best  same distance but smaller reception number  p < best_person): best_diff = diff best_person = p print(best_person)"], "perturbed_original": ["while True: n = input() if n == 0: break pb = None ans =  i, h, w = map(int, raw_input().split()) bmi = w/((float(h)/100)**2) a = abs(22-bmi) if pb is None: pb  elif pb is not None and a < pb: pb = a  ans"], "original_ll": -1.3892873525619507, "sampled_ll": -0.9226909279823303, "all_perturbed_sampled_ll": [-2.416933059692383], "all_perturbed_original_ll": [-2.45029354095459], "perturbed_sampled_ll": -2.416933059692383, "perturbed_original_ll": -2.45029354095459, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int n,x,y,h,w,s,s1,s2,a,i;\n  int m[]={600,800,1000,1200,1400,1600,0};\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    a=0;\n    for(i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x,&y,&h,&w);\n      if     (x+y+h>160)s1=6;\n      else if(x+y+h>140)s1=5;\n      else if(x+y+h>120)s1=4;\n      else if(x+y+h>100)s1=3;\n      else if(x+y+h> 80)s1=2;\n      else if(x+y+h> 60)s1=1;\n      else              s1=0;\n      if     (w>25)s2=6;\n      else if(w>20)s2=5;\n      else if(w>15)s2=4;\n      else if(w>10)s2=3;\n      else if(w>5 )s2=2;\n      else if(w>2 )s2=1;\n      else         s2=0;\n      if(s1>s2)s=s1;\n      else     s=s2;\n      a+=m[s];\n    }\n    printf(\"%d\\n\",a);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        int total = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int x, y, h, w;\n            scanf(\"%d %d %d %d\", &x, &y, &h, &w);\n            \n            int size = x + y + h;\n            int price = 0;\n            \n            // Determine the category based on size and weight\n            if (size <= 60 && w <= 2) {\n                price = 600;\n            } else if (size <= 80 && w <= 5) {\n                price = 800;\n            } else if (size <= 100 && w <= 10) {\n                price = 1000;\n            } else if (size <= 120 && w <= 15) {\n                price = 1200;\n            } else if (size <= 140 && w <= 20) {\n                price = 1400;\n            } else if (size <= 160 && w <= 25) {\n                price = 1600;\n            }\n            // If it exceeds F size, price remains 0 and won't be added\n            \n            total += price;\n        }\n        \n        printf(\"%d\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while (1) { scanf(\"%d\", &n); if (n == 0) break; int total = 0; for (int i =  { int x, y, h, w; scanf(\"%d %d %d %d\", &x, &y,   // Determine  and weight if (size <= 60 && w <= 2) { price = 600; } else if (size <= 80 && w <= 5) { price = 800; } else if (size <= 100 && w <= 10) { price = 1000; } else if (size <=  { price = 1200; }  &&  = 1400; } else if (size <= 160  price =  exceeds F size, price remains 0 and won't be added total += price; } printf(\"%d\\n\", total); } return 0; }"], "perturbed_original": [" int m[]={600,800,1000,1200,1400,1600,0}; while(1){ scanf(\"%d\",&n); if(n==0)break; a=0; for(i=0;i<n;i++){ scanf(\"%d %d %d  else if(x+y+h>120)s1=4; else if(x+y+h>100)s1=3; else if(x+y+h> 80)s1=2; else if(x+y+h> 60)s1=1; else s1=0; if (w>25)s2=6; else if(w>20)s2=5; else if(w>15)s2=4; else if(w>10)s2=3; else if(w>5 )s2=2; else if(w>2 )s2=1; else s2=0;  printf(\"%d\\n\",a); } return 0; }"], "original_ll": -0.6646760702133179, "sampled_ll": -0.6342175006866455, "all_perturbed_sampled_ll": [-1.5598206520080566], "all_perturbed_original_ll": [-1.075850486755371], "perturbed_sampled_ll": -1.5598206520080566, "perturbed_original_ll": -1.075850486755371, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Map.Entry;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\n/**\n * Delivery Fee\n */\npublic class Main {\n\n\tstatic P0160 main = new P0160();\n\tstatic TreeMap<Parcel, Integer> fee = new TreeMap<Parcel, Integer>() {\n\t\t{\n\t\t\tput(main.new Parcel(60, 2), 600);\n\t\t\tput(main.new Parcel(80, 5), 800);\n\t\t\tput(main.new Parcel(100, 10), 1000);\n\t\t\tput(main.new Parcel(120, 15), 1200);\n\t\t\tput(main.new Parcel(140, 20), 1400);\n\t\t\tput(main.new Parcel(160, 25), 1600);\n\t\t}\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n, sum = 0;\n\t\t\tn = Integer.parseInt(line);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tParcel p = main.new Parcel(br.readLine());\n\t\t\t\tEntry<Parcel, Integer> e;\n\t\t\t\tif ((e = fee.ceilingEntry(p)) != null) {\n\t\t\t\t\tsum += e.getValue();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tclass Parcel implements Comparable<Parcel> {\n\t\tint size, weight;\n\n\t\tParcel(int size, int weight) {\n\t\t\tthis.size = size;\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tParcel(int x, int y, int h, int w) {\n\t\t\tthis(x + y + h, w);\n\t\t}\n\n\t\tParcel(String info) {\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tint x, y, h, w;\n\t\t\tx = Integer.parseInt(st.nextToken());\n\t\t\ty = Integer.parseInt(st.nextToken());\n\t\t\th = Integer.parseInt(st.nextToken());\n\t\t\tw = Integer.parseInt(st.nextToken());\n\t\t\tsize = x + y + h;\n\t\t\tweight = w;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Parcel o) {\n\t\t\tint r1 = this.weight - o.weight;\n\t\t\tint r2 = this.size - o.size;\n\t\t\tif (r1 > 0 || r2 > 0) {\n\t\t\t\treturn 1;\n\t\t\t} else if (r1 == 0 && r2 == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int totalCost = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                int h = sc.nextInt();\n                int w = sc.nextInt();\n                \n                int size = x + y + h;\n                int cost = getPrice(size, w);\n                totalCost += cost;\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        sc.close();\n    }\n    \n    static int getPrice(int size, int weight) {\n        int[] sizeLimits = {60, 80, 100, 120, 140, 160};\n        int[] weightLimits = {2, 5, 10, 15, 20, 25};\n        int[] prices = {600, 800, 1000, 1200, 1400, 1600};\n        \n        for (int i = 0; i < 6; i++) {\n            if (size <= sizeLimits[i] && weight <= weightLimits[i]) {\n                return prices[i];\n            }\n        }\n        \n        return 0;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  while (true) { int  == 0) break; int totalCost = 0; for (int i = 0; i < n; i++) { int x = sc.nextInt(); int y = sc.nextInt(); int h = sc.nextInt(); int w = sc.nextInt(); int size = x + y  getPrice(size, w); totalCost += cost; } System.out.println(totalCost); } sc.close(); } static int getPrice(int size, int weight) { int[]  120, 140, 160}; int[] weightLimits = {2, 5, 10, 15, 20, 25}; int[] prices = {600, 800, 1000, 1200, 1400, 1600}; for (int i = 0; i < 6; i++) {  weight <=  } return 0; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Map.Entry; import java.util.StringTokenizer;  Main { static P0160 main = new P0160(); static TreeMap<Parcel, Integer> fee = new  Parcel(60, 2), 600); put(main.new Parcel(80, 5),  put(main.new Parcel(120,  1400); put(main.new Parcel(160, 25), 1600); } }; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = \"\"; while (!(line = br.readLine()).equals(\"0\")) { int n, sum = 0; n = Integer.parseInt(line); for (int i = 0; i < n; ++i) { Parcel p =  != null) { sum  } } class Parcel implements Comparable<Parcel> {  int weight) { this.size = size; this.weight = weight; } Parcel(int x,  w) { this(x + y + h, w); } Parcel(String info) { StringTokenizer st = new StringTokenizer(info); int x, y, h, w; x = Integer.parseInt(st.nextToken()); y = Integer.parseInt(st.nextToken()); h = Integer.parseInt(st.nextToken()); w = Integer.parseInt(st.nextToken()); size = x  = w; } @Override public int compareTo(Parcel o) { int r1 = this.weight - o.weight; int r2 = this.size - o.size; if (r1 >  { return 1;  0) { return 0; } else {  }"], "original_ll": -0.5884672403335571, "sampled_ll": -0.5071066617965698, "all_perturbed_sampled_ll": [-1.3963795900344849], "all_perturbed_original_ll": [-1.6619876623153687], "perturbed_sampled_ll": -1.3963795900344849, "perturbed_original_ll": -1.6619876623153687, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "size = [60,80,100,120,140,160]        \nweight = [2,5,10,16,20,25]\nfee= [600,800,1000,1200,1400,1600]\nwhile True:\n    n = int(input())\n    if n==0:\n        break\n    total = 0\n    for _ in range(n):\n        [x,y,h,wt] = list(map(int, input().split()))\n        sz = x+y+h\n        if sz > size[-1] or wt > weight[-1]:\n            #print(\"NotAccept\")\n            continue\n        isz = len(list(filter(lambda x: x<sz,   size)))\n        iwt = len(list(filter(lambda x: x<wt, weight)))\n        f   = fee[max(isz,iwt)]\n        #print(\"%d %d %d %d %d\" % (x,y,h,wt,f))\n        total += f\n\n    print(total)", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    total = 0\n    for _ in range(n):\n        x, y, h, w = map(int, input().split())\n        size = x + y + h\n        \n        # Determine the category based on size and weight\n        if size <= 60 and w <= 2:\n            total += 600\n        elif size <= 80 and w <= 5:\n            total += 800\n        elif size <= 100 and w <= 10:\n            total += 1000\n        elif size <= 120 and w <= 15:\n            total += 1200\n        elif size <= 140 and w <= 20:\n            total += 1400\n        elif size <= 160 and w <= 25:\n            total += 1600\n        # If exceeds F size, don't add to total\n    \n    print(total)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break total = 0 for _ in range(n): x, y, h, w = map(int,  y + h # Determine  and weight if size <= 60 and w <= 2: total += 600 elif size  5: total += 800 elif size <= 100 and w <=  size <= 120 and w <= 15: total  140 and w <= 20: total += 1400 elif size  25: total += 1600 # If exceeds F size, don't add to total print(total)"], "perturbed_original": ["size = [60,80,100,120,140,160] weight = [2,5,10,16,20,25] fee= [600,800,1000,1200,1400,1600] while True: n = int(input()) if n==0: break total =  [x,y,h,wt] = list(map(int, input().split())) sz = x+y+h if sz > size[-1] or wt > weight[-1]:  x: x<sz, size))) iwt = len(list(filter(lambda x:  #print(\"%d %d %d %d %d\" % (x,y,h,wt,f)) total += f print(total)"], "original_ll": -1.2436612844467163, "sampled_ll": -0.7777429819107056, "all_perturbed_sampled_ll": [-2.15201735496521], "all_perturbed_original_ll": [-1.8776358366012573], "perturbed_sampled_ll": -2.15201735496521, "perturbed_original_ll": -1.8776358366012573, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct\n{\n\tint c;\n\tint m[4];\n\tint s[4];\n} TEAM;\n\nint comparison(const void* a, const void* b);\n\nint main(void)\n{\n\tint n;\n\tTEAM* team;\n\t\n\twhile (scanf(\"%d\", &n) * n != 0){\n\t\tint i;\n\t\t\n\t\tteam = (TEAM*)calloc(n, sizeof(TEAM));\n\t\tfor (i = 0; i < n; i++){\n\t\t\tint j;\n\t\t\t\n\t\t\tscanf(\"%d\", &team[i].c);\n\t\t\tfor (j = 0; j < 4; j++){\n\t\t\t\tscanf(\"%d %d\", &team[i].m[j], &team[i].s[j]);\n\t\t\t}\n\t\t}\n\t\tqsort(team, n, sizeof(TEAM), comparison);\n\t\tprintf(\"%d\\n\", team[0].c);\n\t\tprintf(\"%d\\n\", team[1].c);\n\t\tprintf(\"%d\\n\", team[n - 2].c);\n\t\t\n\t\tfree(team);\n\t}\n\t\n\treturn 0;\n}\n\nint comparison(const void* a, const void* b)\n{\n\tint sum_a, sum_b;\n\tint i;\n\t\n\tsum_a = sum_b = 0;\n\tfor (i = 0; i < 4; i++){\n\t\tsum_a += ((TEAM*)a)->m[i] * 60 + ((TEAM*)a)->s[i];\n\t\tsum_b += ((TEAM*)b)->m[i] * 60 + ((TEAM*)b)->s[i];\n\t}\n\tif (sum_a > sum_b){\n\t\treturn 1;\n\t}\n\telse if (sum_a < sum_b){\n\t\treturn -1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int total_time;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    return ta->total_time - tb->total_time;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Team *teams = (Team *)malloc(n * sizeof(Team));\n        \n        for (int i = 0; i < n; i++) {\n            int id, m1, s1, m2, s2, m3, s3, m4, s4;\n            scanf(\"%d %d %d %d %d %d %d %d %d\", &id, &m1, &s1, &m2, &s2, &m3, &s3, &m4, &s4);\n            \n            teams[i].id = id;\n            teams[i].total_time = (m1 * 60 + s1) + (m2 * 60 + s2) + (m3 * 60 + s3) + (m4 * 60 + s4);\n        }\n        \n        qsort(teams, n, sizeof(Team), compare);\n        \n        printf(\"%d\\n\", teams[0].id);\n        printf(\"%d\\n\", teams[1].id);\n        printf(\"%d\\n\", teams[n-2].id);\n        \n        free(teams);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int compare(const void *a, const void *b) {  *)b; return ta->total_time - tb->total_time; } int main() { int n; while (scanf(\"%d\", &n) == 1 && n != 0) { Team *teams = (Team *)malloc(n * sizeof(Team)); for (int i = 0; i < n; i++) { int  m3, s3, m4, s4; scanf(\"%d %d %d %d %d %d %d %d %d\", &id, &m1, &s1, &m2, &s2,  = id; teams[i].total_time = (m1 * 60 + s1) + (m2 * 60 + s2) + (m3 * 60 + s3) + (m4  qsort(teams, n, sizeof(Team), compare); printf(\"%d\\n\", teams[0].id); printf(\"%d\\n\", teams[1].id); printf(\"%d\\n\", teams[n-2].id); free(teams); } return 0; }"], "perturbed_original": ["#include <stdio.h>  int c; int m[4]; int  void* a, const    0){ int i; team = (TEAM*)calloc(n, sizeof(TEAM)); for (i = 0; i < n; i++){ int j; scanf(\"%d\", &team[i].c); for (j  j++){ scanf(\"%d %d\", &team[i].m[j], &team[i].s[j]); } } qsort(team, n, sizeof(TEAM), comparison); printf(\"%d\\n\", team[0].c); printf(\"%d\\n\", team[1].c); printf(\"%d\\n\", team[n - 2].c); free(team); }  void* a, const void* b) { int sum_a, sum_b; int i; sum_a = sum_b = 0; for (i = 0; i < 4; i++){ sum_a += ((TEAM*)a)->m[i] * 60 + ((TEAM*)a)->s[i]; sum_b += ((TEAM*)b)->m[i] * 60 + ((TEAM*)b)->s[i]; } if (sum_a > sum_b){ return 1; } else if (sum_a < sum_b){ return -1;  } }"], "original_ll": -0.5576724410057068, "sampled_ll": -0.3712632656097412, "all_perturbed_sampled_ll": [-0.9729570746421814], "all_perturbed_original_ll": [-1.2272409200668335], "perturbed_sampled_ll": -0.9729570746421814, "perturbed_original_ll": -1.2272409200668335, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main\n{\n    public static void main(String args[])\n    {\n\tScanner scan=new Scanner(System.in);\n\twhile(true)\n\t    {\n\t\tint n=scan.nextInt();\n\t\tif(n==0)break;\n\t\tint num[]=new int[n];\n\t\tint sum[]=new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\tnum[i]=scan.nextInt();\n\t\t\tfor(int j=0;j<8;j++)\n\t\t\t    {\n\t\t\t\tif(j%2==0)sum[i]+=60*(scan.nextInt());\n\t\t\t\telse sum[i]+=scan.nextInt();\n\t\t\t    }\n\t\t    }\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\tint min=sum[i],x=i;\n\t\t\tfor(int j=i;j<n;j++)\n\t\t\t    {\n\t\t\t\tif(min>sum[j])\n\t\t\t\t    {\n\t\t\t\t\tmin=sum[j];\n\t\t\t\t\tx=j;\n\t\t\t\t\t\n\t\t\t\t    }\n\t\t\t    }\n\t\t\tint tmp=num[i];\n\t\t\tnum[i]=num[x];\n\t\t\tnum[x]=tmp;\n\t\t\tint tmp2=sum[i];\n\t\t\tsum[i]=sum[x];\n\t\t\tsum[x]=tmp2;\n\t\t    }\n\t\t\n\t\tSystem.out.println(num[0]);\n\t\tSystem.out.println(num[1]);\n\t\tSystem.out.println(num[n-2]);\n\t    }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Team implements Comparable<Team> {\n        int id;\n        int totalSeconds;\n        \n        Team(int id, int totalSeconds) {\n            this.id = id;\n            this.totalSeconds = totalSeconds;\n        }\n        \n        @Override\n        public int compareTo(Team other) {\n            return this.totalSeconds - other.totalSeconds;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            Team[] teams = new Team[n];\n            \n            for (int i = 0; i < n; i++) {\n                int id = sc.nextInt();\n                int totalSeconds = 0;\n                \n                for (int j = 0; j < 4; j++) {\n                    int m = sc.nextInt();\n                    int s = sc.nextInt();\n                    totalSeconds += m * 60 + s;\n                }\n                \n                teams[i] = new Team(id, totalSeconds);\n            }\n            \n            Arrays.sort(teams);\n            \n            System.out.println(teams[0].id);\n            System.out.println(teams[1].id);\n            System.out.println(teams[n - 2].id);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Team implements Comparable<Team> { int id; int totalSeconds; Team(int id, int totalSeconds) {  totalSeconds; } @Override  return this.totalSeconds - other.totalSeconds; } } public static void main(String[] args)  Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; Team[] teams = new Team[n]; for (int i  i++) { int id = sc.nextInt(); int totalSeconds = 0; for (int j =  sc.nextInt(); int s =  60 + s; } teams[i] = new Team(id, totalSeconds); } Arrays.sort(teams); System.out.println(teams[0].id); System.out.println(teams[1].id); System.out.println(teams[n - 2].id); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String args[])  { int n=scan.nextInt(); if(n==0)break; int num[]=new int[n]; int sum[]=new int[n]; for(int i=0;i<n;i++) { num[i]=scan.nextInt(); for(int j=0;j<8;j++) { if(j%2==0)sum[i]+=60*(scan.nextInt()); else sum[i]+=scan.nextInt(); } } for(int  j=i;j<n;j++) { if(min>sum[j]) {  tmp=num[i]; num[i]=num[x]; num[x]=tmp; int tmp2=sum[i]; sum[i]=sum[x]; sum[x]=tmp2; } System.out.println(num[0]); System.out.println(num[1]); System.out.println(num[n-2]); } } }"], "original_ll": -0.7492728233337402, "sampled_ll": -0.4107069671154022, "all_perturbed_sampled_ll": [-1.399451732635498], "all_perturbed_original_ll": [-1.419654369354248], "perturbed_sampled_ll": -1.399451732635498, "perturbed_original_ll": -1.419654369354248, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n=int(input())\n    if n==0:break\n    a={}\n    for _ in range(n):\n        b=list(map(int,input().split()))\n        a[b[0]]=sum(b[1:8:2])*60+sum(b[2:9:2])\n    a=sorted(a.items(),key=lambda x:x[1])\n    for i in [0,1,-2]:print(a[i][0])", "sampled": "import sys\n\ndef solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        teams = []\n        for _ in range(n):\n            parts = list(map(int, input().split()))\n            team_id = parts[0]\n            \n            # Calculate total time in seconds\n            total_seconds = 0\n            for i in range(1, 9, 2):\n                minutes = parts[i]\n                seconds = parts[i + 1]\n                total_seconds += minutes * 60 + seconds\n            \n            teams.append((total_seconds, team_id))\n        \n        # Sort by total time\n        teams.sort()\n        \n        # Winner: smallest time (index 0)\n        winner = teams[0][1]\n        # Runner-up: second smallest time (index 1)\n        runner_up = teams[1][1]\n        # Booby prize: second to last (index n-2)\n        booby = teams[n - 2][1]\n        \n        print(winner)\n        print(runner_up)\n        print(booby)\n\nsolve()\n", "perturbed_sampled": ["import sys def solve(): while True: n = int(input()) if n == 0: break teams = [] for  list(map(int, input().split())) team_id = parts[0] # Calculate total time in seconds total_seconds = 0 for i in range(1, 9, 2): minutes = parts[i] seconds = parts[i + 1] total_seconds += minutes * 60 + seconds teams.append((total_seconds, team_id)) # Sort by total time teams.sort() # Winner: smallest time  #  1) runner_up  second to   print(booby) solve()"], "perturbed_original": ["while 1: n=int(input()) if n==0:break a={} for _ in range(n):  i in [0,1,-2]:print(a[i][0])"], "original_ll": -1.0230110883712769, "sampled_ll": -0.9270316362380981, "all_perturbed_sampled_ll": [-2.4397013187408447], "all_perturbed_original_ll": [-2.520052433013916], "perturbed_sampled_ll": -2.4397013187408447, "perturbed_original_ll": -2.520052433013916, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[110][110];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j,a,b;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<110;i++){\n      for(j=0;j<110;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d){a=4;b=2;}\n      else {a=2;b=4;}\n\tfor(i=y;i<y+a;i++){\n\t  for(j=x;j<x+b;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n\n    }\n    c=boad[xs][ys];\n \n  \n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    /*for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\nprintf(\"%2d\",boad[i][j]);\n      printf(\"\\n\");\n      }*/\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  if(x<=0||x>w||y<=0||y>h||boad[x][y]!=c)return 0;\n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i)+abs(j)==1 && boad[x+i][y+j]!=-1)\n\tif(dfs(x+i,y+j))return 1;\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 1000000\n\nint hamming[100000];\nint hamming_count = 0;\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nvoid generate_hamming() {\n    hamming[hamming_count++] = 1;\n    \n    int i2 = 0, i3 = 0, i5 = 0;\n    int next_2 = 2, next_3 = 3, next_5 = 5;\n    \n    while (1) {\n        int next = next_2;\n        if (next_3 < next) next = next_3;\n        if (next_5 < next) next = next_5;\n        \n        if (next > MAX) break;\n        \n        hamming[hamming_count++] = next;\n        \n        if (next == next_2) {\n            i2++;\n            next_2 = hamming[i2] * 2;\n        }\n        if (next == next_3) {\n            i3++;\n            next_3 = hamming[i3] * 3;\n        }\n        if (next == next_5) {\n            i5++;\n            next_5 = hamming[i5] * 5;\n        }\n    }\n}\n\nint binary_search_lower(int val) {\n    int left = 0, right = hamming_count - 1;\n    int result = hamming_count;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (hamming[mid] >= val) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return result;\n}\n\nint binary_search_upper(int val) {\n    int left = 0, right = hamming_count - 1;\n    int result = -1;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (hamming[mid] <= val) {\n            result = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    generate_hamming();\n    \n    int m, n;\n    while (1) {\n        scanf(\"%d\", &m);\n        if (m == 0) break;\n        scanf(\"%d\", &n);\n        \n        int lower = binary_search_lower(m);\n        int upper = binary_search_upper(n);\n        \n        if (lower <= upper) {\n            printf(\"%d\\n\", upper - lower + 1);\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #define MAX 1000000 int hamming[100000];  compare(const void *a, const void *b) { return (*(int*)a - *(int*)b); }  1; int i2 = 0, i3 = 0, i5 = 0; int next_2 = 2, next_3 = 3, next_5 = 5; while (1) { int next  next) next = next_3; if (next_5 < next) next = next_5; if (next >  if (next == next_2) { i2++; next_2 =  i3++; next_3 = hamming[i3] * 3; } if (next == next_5) { i5++; next_5 =  { int left = 0, right = hamming_count  hamming_count; while (left <=  (left + right) / 2; if (hamming[mid] >= val) { result = mid; right = mid - 1; } else { left = mid + 1; } } return  0, right = hamming_count - 1; int  <= right) { int mid = (left + right) / 2; if (hamming[mid] <= val) { result = mid; left = mid + 1; } else { right = mid  { generate_hamming(); int m, n; while (1) { scanf(\"%d\", &m); if (m == 0) break; scanf(\"%d\", &n); int lower = binary_search_lower(m); int upper = binary_search_upper(n); if (lower <= upper) { printf(\"%d\\n\", upper - lower + 1); } else {  }"], "perturbed_original": [" main(void){ int x,y,i,j,a,b; while(1){ scanf(\"%d %d\",&w,&h); if(w==0 && h==0)break; scanf(\"%d %d\",&xs,&ys); scanf(\"%d %d\",&xg,&yg); scanf(\"%d\",&n); for(i=0;i<110;i++){ for(j=0;j<110;j++){ boad[i][j]=-1; }  %d %d %d\",&c,&d,&x,&y); if(d){a=4;b=2;} else {a=2;b=4;} for(i=y;i<y+a;i++){ for(j=x;j<x+b;j++){ boad[i][j]=c; } } } c=boad[xs][ys]; if(dfs(xs,ys))printf(\"OK\\n\"); else printf(\"NG\\n\"); /*for(i=0;i<15;i++){ for(j=0;j<15;j++) printf(\"%2d\",boad[i][j]);  } int dfs(int x,int y){ int i,j,res=0; if(x<=0||x>w||y<=0||y>h||boad[x][y]!=c)return 0; if(x==xg && y==yg)return 1; boad[x][y]=-1; for(i=-1;i<2;i++){ for(j=-1;j<2;j++){ if(boad[x+i][y+j]==c  1; } } return 0; }"], "original_ll": -0.8931204676628113, "sampled_ll": -0.32415035367012024, "all_perturbed_sampled_ll": [-1.2754758596420288], "all_perturbed_original_ll": [-1.282478928565979], "perturbed_sampled_ll": -1.2754758596420288, "perturbed_original_ll": -1.282478928565979, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint m, n;\n\t\tint a;\n\t\t\n\t\tint count;\n\t\t\n\t\twhile(true){\n\t\t\tm = scan.nextInt();\n\t\t\tn = scan.nextInt();\n\t\t\tif(m == 0)break;\n\t\t\t\n\t\t\tcount = 0;\n\t\t\tfor(int i = m;i <= n; i++){\n\t\t\t\ta = i;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(a == 1){\n\t\t\t\t\t\tcount++;;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(a % 2 != 0 && a % 3 != 0 && a % 5 != 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(a % 2 == 0)a /= 2;\n\t\t\t\t\telse if(a % 3 == 0)a /= 3;\n\t\t\t\t\telse if(a % 5 == 0)a /= 5;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Precompute all Hamming numbers up to 1000000\n        TreeSet<Long> hammingSet = new TreeSet<>();\n        long limit = 1000000;\n        \n        for (long i = 1; i <= limit; i *= 2) {\n            for (long j = i; j <= limit; j *= 3) {\n                for (long k = j; k <= limit; k *= 5) {\n                    hammingSet.add(k);\n                }\n            }\n        }\n        \n        List<Long> hamming = new ArrayList<>(hammingSet);\n        \n        while (true) {\n            int m = sc.nextInt();\n            if (m == 0) break;\n            int n = sc.nextInt();\n            \n            int count = 0;\n            for (long h : hamming) {\n                if (h >= m && h <= n) {\n                    count++;\n                } else if (h > n) {\n                    break;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[]  new Scanner(System.in); // Precompute all Hamming numbers up to 1000000 TreeSet<Long> hammingSet = new TreeSet<>(); long limit = 1000000; for (long i =  *= 2) { for  <= limit; j *= 3) { for (long  limit; k *= 5) { hammingSet.add(k); } } } List<Long> hamming = new ArrayList<>(hammingSet); while (true) { int m = sc.nextInt(); if (m == 0) break; int n = sc.nextInt(); int count = 0; for (long h : hamming) { if   else if (h > n)  } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class  = new Scanner(System.in); int m, n; int a;  scan.nextInt(); n = scan.nextInt(); if(m == 0)break; count = 0; for(int i = m;i <= n; i++){ a = i; while(true){ if(a == 1){ count++;; break; } if(a % 2 != 0 && a % 3  5 !=  2  if(a % 3 == 0)a /= 3; else if(a % 5 == 0)a /= 5; } } System.out.println(count); } } }"], "original_ll": -0.6280300617218018, "sampled_ll": -0.5164499282836914, "all_perturbed_sampled_ll": [-1.6537994146347046], "all_perturbed_original_ll": [-1.759690523147583], "perturbed_sampled_ll": -1.6537994146347046, "perturbed_original_ll": -1.759690523147583, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\nwhile True:\n    try:\n        m, n = map(int, raw_input().split())\n\n        f2 = int(math.log(n, 2)) + 1\n        f3 = int(math.log(n, 3)) + 1\n        f5 = int(math.log(n, 5)) + 1\n\n        c = 0\n        for i in range(f2):\n            for j in range(f3):\n                for k in range(f5):\n                    if m <= (2 ** i) * (3 ** j) * (5 ** k) <= n:\n                        c += 1\n        print c\n\n    except ValueError:\n        break", "sampled": "import heapq\n\ndef generate_hamming_numbers(limit):\n    hamming = set([1])\n    heap = [1]\n    \n    while heap:\n        h = heapq.heappop(heap)\n        if h > limit:\n            break\n        \n        for factor in [2, 3, 5]:\n            new_num = h * factor\n            if new_num <= limit and new_num not in hamming:\n                hamming.add(new_num)\n                heapq.heappush(heap, new_num)\n    \n    return sorted(hamming)\n\n# Pre-generate all Hamming numbers up to 1000000\nhamming_numbers = generate_hamming_numbers(1000000)\n\nwhile True:\n    line = input().strip()\n    if line == \"0\":\n        break\n    \n    m, n = map(int, line.split())\n    \n    # Binary search for the range\n    count = 0\n    for h in hamming_numbers:\n        if h < m:\n            continue\n        if h > n:\n            break\n        count += 1\n    \n    print(count)\n", "perturbed_sampled": [" [1] while heap: h = heapq.heappop(heap) if h > limit:  3, 5]: new_num = h * factor if new_num <= limit and new_num not in hamming: hamming.add(new_num) heapq.heappush(heap, new_num) return  numbers up to 1000000 hamming_numbers = generate_hamming_numbers(1000000) while True: line = input().strip() if line == \"0\": break m, n = map(int, line.split()) # Binary search for the range count = 0  h < m: continue if h > n: break count += 1 print(count)"], "perturbed_original": ["import math while True: try: m, n = map(int, raw_input().split()) f2 = int(math.log(n,  int(math.log(n, 3)) + 1 f5 = int(math.log(n, 5)) + 1 c = 0 for i in  for k in range(f5): if m  (3 ** j) * (5  += 1 print c except ValueError: break"], "original_ll": -0.7213451862335205, "sampled_ll": -0.7400742173194885, "all_perturbed_sampled_ll": [-1.8477838039398193], "all_perturbed_original_ll": [-2.3425424098968506], "perturbed_sampled_ll": -1.8477838039398193, "perturbed_original_ll": -2.3425424098968506, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  const int d[8][8]={\n    {0,0,  0,  0,  0,  0,   0,  0},\n    {0,0,300,500,600,700,1350,1650},\n    {0,0,  0,350,450,600,1150,1500},\n    {0,0,  0,  0,250,400,1000,1350},\n    {0,0,  0,  0,  0,250, 850,1300},\n    {0,0,  0,  0,  0,  0, 600,1150},\n    {0,1,  0,  0,  0,  0,   0, 500},\n    {0,1,  1,  1,  1,  1,   0,   0}\n  };\n  int n,m,ih,it,oh,ot;\n  int p=0;\n  while(1){\n    scanf(\"%d\",&n);\n    if(!n)break;\n    scanf(\"%d %d %d %d %d\",&ih,&it,&m,&oh,&ot);\n    if(n>m){\n      p=n;\n      n=m;\n      m=p;\n    }\n    p=d[n][m];\n    it+=60*ih;\n    ot+=60*oh;\n    if(d[m][n]==0&&\n       ((17*60+30<=it&&it<=19*60+30)||\n\t17*60+30<=ot&&ot<=19*60+30))p/=2;\n    if(p%50)p+=25;\n    printf(\"%d\\n\",p);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int price[8][8] = {\n        {0, 0, 0, 0, 0, 0, 0, 0},\n        {0, 0, 350, 450, 600, 750, 1050, 1300},\n        {0, 350, 0, 450, 500, 650, 900, 1150},\n        {0, 450, 450, 0, 400, 500, 750, 1050},\n        {0, 600, 500, 400, 0, 350, 600, 850},\n        {0, 750, 650, 500, 350, 0, 450, 700},\n        {0, 1050, 900, 750, 600, 450, 0, 500},\n        {0, 1300, 1150, 1050, 850, 700, 500, 0}\n    };\n    \n    int distance[8][8] = {\n        {0, 0, 0, 0, 0, 0, 0, 0},\n        {0, 0, 9, 12, 19, 25, 39, 58},\n        {0, 9, 0, 12, 16, 22, 36, 55},\n        {0, 12, 12, 0, 10, 16, 30, 49},\n        {0, 19, 16, 10, 0, 10, 24, 43},\n        {0, 25, 22, 16, 10, 0, 18, 37},\n        {0, 39, 36, 30, 24, 18, 0, 19},\n        {0, 58, 55, 49, 43, 37, 19, 0}\n    };\n    \n    int d;\n    while(scanf(\"%d\", &d) == 1 && d != 0) {\n        int hd, md, a, ha, ma;\n        scanf(\"%d %d\", &hd, &md);\n        scanf(\"%d\", &a);\n        scanf(\"%d %d\", &ha, &ma);\n        \n        int start_time = hd * 60 + md;\n        int end_time = ha * 60 + ma;\n        int discount_start = 17 * 60 + 30;\n        int discount_end = 19 * 60 + 30;\n        \n        int dist = distance[d][a];\n        int cost = price[d][a];\n        \n        int is_discount = 0;\n        if ((start_time >= discount_start && start_time <= discount_end) ||\n            (end_time >= discount_start && end_time <= discount_end)) {\n            if (dist <= 40) {\n                is_discount = 1;\n            }\n        }\n        \n        if (is_discount) {\n            int half = cost / 2;\n            if (cost % 2 != 0) {\n                half++;\n            }\n            int remainder = half % 50;\n            if (remainder != 0) {\n                half = half + (50 - remainder);\n            }\n            cost = half;\n        }\n        \n        printf(\"%d\\n\", cost);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int price[8][8] = { {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 350, 450, 600, 750, 1050,  500,  450, 0, 400, 500, 750, 1050}, {0, 600, 500, 400, 0, 350, 600, 850}, {0, 750, 650, 500, 350, 0, 450, 700}, {0, 1050, 900,  850,  distance[8][8]  0,  0, 9, 12, 19, 25, 39, 58}, {0, 9, 0, 12, 16, 22, 36, 55}, {0, 12, 12, 0, 10, 16, 30, 49}, {0,  24, 43}, {0, 25, 22, 16, 10, 0, 18, 37}, {0, 39, 36, 30, 24, 18, 0, 19}, {0,  19, 0} }; int d; while(scanf(\"%d\", &d) == 1  int hd, md, a, ha, ma; scanf(\"%d %d\", &hd, &md); scanf(\"%d\", &a); scanf(\"%d %d\", &ha, &ma); int start_time = hd * 60 + md; int end_time = ha * 60 +  * 60 + 30; int discount_end = 19 * 60 +  int is_discount = 0; if ((start_time >= discount_start && start_time <= discount_end) || (end_time >= discount_start && end_time <= discount_end)) { if (dist <= 40) { is_discount = 1; } } if (is_discount) { int half = cost / 2; if (cost % 2  % 50;  half = half + (50  half; } printf(\"%d\\n\", cost); } return 0; }"], "perturbed_original": ["#include<stdio.h> int  0, 0, 0, 0, 0, 0}, {0,0,300,500,600,700,1350,1650}, {0,0, 0,350,450,600,1150,1500}, {0,0, 0, 0,250,400,1000,1350}, {0,0, 0, 0, 0,250, 850,1300}, {0,0, 0, 0, 0, 0, 600,1150}, {0,1,  500},  0, 0} }; int n,m,ih,it,oh,ot; int p=0; while(1){ scanf(\"%d\",&n); if(!n)break; scanf(\"%d %d %d %d %d\",&ih,&it,&m,&oh,&ot); if(n>m){ p=n; n=m; m=p; } p=d[n][m]; it+=60*ih; ot+=60*oh; if(d[m][n]==0&& ((17*60+30<=it&&it<=19*60+30)||  0; }"], "original_ll": -0.9169138669967651, "sampled_ll": -0.42229679226875305, "all_perturbed_sampled_ll": [-1.220331072807312], "all_perturbed_original_ll": [-1.3963686227798462], "perturbed_sampled_ll": -1.220331072807312, "perturbed_original_ll": -1.3963686227798462, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static int[][] money = new int[][]\n\t\t\t{\n\t\t\t\t{\t0,\t300,\t500,\t600,\t700,\t1350,\t1650},\n\t\t\t\t{\t0,\t0,\t\t350,\t450,\t600,\t1150,\t1500},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t250,\t400,\t1000,\t1350},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t0,\t\t250,\t850,\t1300},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t0,\t\t0,\t\t600,\t1150},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t0,\t\t0,\t\t0,\t\t 500},\n\t\t\t};\n\t\n\tpublic static int[][] dist = new int[][]\n\t\t\t{\n\t\t\t\t{\t0,\t6,\t13,\t18,\t23,\t43,\t58},\n\t\t\t\t{\t0,\t0,\t7,\t12,\t17,\t37,\t52},\n\t\t\t\t{\t0,\t0,\t0,\t5,\t10,\t30,\t45},\n\t\t\t\t{\t0,\t0,\t0,\t0,\t5,\t25,\t40},\n\t\t\t\t{\t0,\t0,\t0,\t0,\t0,\t20,\t35},\n\t\t\t\t{\t0,\t0,\t0,\t0,\t0,\t0,\t15},\n\t\t\t};\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int start = sc.nextInt() - 1;\n\t\t\t\n\t\t\tif(start == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int start_h = sc.nextInt();\n\t\t\tfinal int start_m = sc.nextInt();\n\t\t\tfinal int start_t = start_h * 60 + start_m;\n\t\t\t\n\t\t\tfinal int end = sc.nextInt() - 1;\n\t\t\tfinal int end_h = sc.nextInt();\n\t\t\tfinal int end_m = sc.nextInt();\n\t\t\tfinal int end_t = end_h * 60 + end_m;\n\t\t\t\n\t\t\tint cost = 0;\n\t\t\tif(start_t <= (17 * 60 + 30) && end_t >= (17 * 60 + 30) && end_t <= (19 * 60 + 30) || start_t >= (17 * 60 + 30) && start_t <= (19 * 60 + 30) && end_t >= (19 * 60 + 30)){\n\t\t\t\tif(dist[start][end] <= 40){\n\t\t\t\t\tcost = (int) (Math.ceil((money[start][end] / (2.0 * 50)))) * 50;\n\t\t\t\t}else{\n\t\t\t\t\tcost = money[start][end];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcost = money[start][end];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cost);\n\t\t}\n\t\t\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Distance and price table\n        int[][] distance = new int[8][8];\n        int[][] price = new int[8][8];\n        \n        // Initialize distance table (symmetric)\n        int[][] distData = {\n            {0, 6, 12, 18, 32, 41, 58},\n            {6, 0, 6, 12, 26, 35, 52},\n            {12, 6, 0, 6, 20, 29, 46},\n            {18, 12, 6, 0, 14, 23, 40},\n            {32, 26, 20, 14, 0, 9, 26},\n            {41, 35, 29, 23, 9, 0, 17},\n            {58, 52, 46, 40, 26, 17, 0}\n        };\n        \n        int[][] priceData = {\n            {0, 350, 450, 600, 900, 1150, 1400},\n            {350, 0, 350, 450, 750, 900, 1200},\n            {450, 350, 0, 350, 600, 750, 1050},\n            {600, 450, 350, 0, 450, 600, 850},\n            {900, 750, 600, 450, 0, 350, 600},\n            {1150, 900, 750, 600, 350, 0, 350},\n            {1400, 1200, 1050, 850, 600, 350, 0}\n        };\n        \n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                distance[i+1][j+1] = distData[i][j];\n                price[i+1][j+1] = priceData[i][j];\n            }\n        }\n        \n        while (true) {\n            int d = sc.nextInt();\n            if (d == 0) break;\n            \n            int hd = sc.nextInt();\n            int md = sc.nextInt();\n            int a = sc.nextInt();\n            int ha = sc.nextInt();\n            int ma = sc.nextInt();\n            \n            int dist = distance[d][a];\n            int baseFare = price[d][a];\n            \n            // Check if discount applies\n            // 17:30 - 19:30 (1050 - 1170 minutes from midnight)\n            int departTime = hd * 60 + md;\n            int arriveTime = ha * 60 + ma;\n            \n            boolean discount = false;\n            if (dist <= 40) {\n                // Check if either departure or arrival is in discount time\n                if ((departTime >= 1050 && departTime <= 1170) || \n                    (arriveTime >= 1050 && arriveTime <= 1170)) {\n                    discount = true;\n                }\n            }\n            \n            int fare;\n            if (discount) {\n                // Half price, round up to nearest 50 yen\n                int halfFare = baseFare / 2;\n                fare = ((halfFare + 49) / 50) * 50;\n            } else {\n                fare = baseFare;\n            }\n            \n            System.out.println(fare);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static  sc =  price table int[][] distance = new int[8][8]; int[][] price = new int[8][8]; // Initialize  = { {0, 6, 12, 18, 32, 41, 58}, {6, 0, 6, 12, 26, 35, 52}, {12, 6, 0, 6, 20, 29,  26, 20, 14, 0, 9, 26}, {41, 35, 29, 23, 9,  40, 26, 17, 0} }; int[][] priceData = { {0, 350, 450, 600, 900, 1150, 1400}, {350, 0, 350, 450, 750, 900, 1200},  750, 1050}, {600, 450, 350, 0, 450, 600, 850}, {900, 750, 600, 450, 0, 350, 600}, {1150, 900, 750,  1200, 1050, 850, 600, 350, 0} }; for (int i  i++) { for (int j = 0; j < 7; j++)  = priceData[i][j]; } } while (true) { int d = sc.nextInt(); if (d == 0) break; int hd  sc.nextInt(); int a = sc.nextInt(); int ha = sc.nextInt(); int ma = sc.nextInt();  Check if discount applies // 17:30 - 19:30 (1050 - 1170 minutes from midnight) int departTime = hd * 60 + md; int arriveTime = ha *  = false; if (dist <= 40) { // Check   ((departTime >= 1050 &&  >= 1050 && arriveTime <= 1170)) { discount = true; } } int fare; if (discount) { // Half price, round up to  = baseFare / 2; fare = ((halfFare  50; } else { fare = baseFare; } System.out.println(fare); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main  = new int[][] { { 0, 300, 500, 600, 700, 1350, 1650}, { 0, 0, 350, 450,  0, 0, 250, 400, 1000, 1350}, { 0, 0, 0, 0, 250, 850, 1300}, { 0, 0, 0, 0, 0, 600, 1150}, {  0, 500}, }; public static  { { 0, 6, 13, 18, 23, 43, 58}, { 0, 0, 7, 12, 17, 37,  5, 10, 30, 45}, { 0, 0, 0, 0, 5, 25, 40}, { 0, 0, 0,  0, 0, 15}, }; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){  - 1; if(start == -1){ break; } final int start_h = sc.nextInt(); final int start_m = sc.nextInt(); final  60 + start_m; final int end = sc.nextInt() - 1; final int  * 60  0; if(start_t <= (17 * 60 + 30) && end_t >= (17 * 60 + 30) && end_t <= (19 *  >= (17 * 60 + 30) && start_t <= (19 *  >= (19 * 60 + 30)){ if(dist[start][end] <= 40){ cost = (int) (Math.ceil((money[start][end] /  }else{ cost = money[start][end]; } }else{ cost = money[start][end]; } System.out.println(cost); } } }"], "original_ll": -0.5417076945304871, "sampled_ll": -0.5272404551506042, "all_perturbed_sampled_ll": [-1.4908345937728882], "all_perturbed_original_ll": [-1.2574501037597656], "perturbed_sampled_ll": -1.4908345937728882, "perturbed_original_ll": -1.2574501037597656, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "table=[[0,300,500,600,700,1350,1650],\n       [0,0,350,450,600,1150,1500],\n       [0,0,0,250,400,1000,1350],\n       [0,0,0,0,250,850,1300],\n       [0,0,0,0,0,600,1150],\n       [0,0,0,0,0,0,500]]\nfbd=[(1,6),(1,7),(2,7),(3,7)]\nwhile True:\n    init=input()\n    if init==0:break\n    h1,m1=map(int,raw_input().split())\n    fin=input()\n    h2,m2=map(int,raw_input().split())\n    if init>fin:\n        init,h1,m1,fin,h2,m2=fin,h2,m2,init,h1,m1\n    t1=h1*60+m1\n    t2=h2*60+m2\n    if 1050<=t1<=1170 or 1050<=t2<=1170 and (init,fin) not in fbd:\n        temp=table[init-1][fin-1]/2\n        if temp%100>0:\n            temp+=50-temp%50\n        print temp\n    else:\n        print table[init-1][fin-1]", "sampled": "import math\n\n# Distance and toll matrix\ndistance = [\n    [0, 6, 18, 25, 37, 48, 58],\n    [6, 0, 12, 19, 31, 42, 52],\n    [18, 12, 0, 7, 19, 30, 40],\n    [25, 19, 7, 0, 12, 23, 33],\n    [37, 31, 19, 12, 0, 11, 21],\n    [48, 42, 30, 23, 11, 0, 10],\n    [58, 52, 40, 33, 21, 10, 0]\n]\n\ntoll = [\n    [0, 200, 500, 650, 900, 1150, 1350],\n    [200, 0, 450, 600, 850, 1100, 1300],\n    [500, 450, 0, 250, 500, 750, 950],\n    [650, 600, 250, 0, 350, 600, 800],\n    [900, 850, 500, 350, 0, 300, 550],\n    [1150, 1100, 750, 600, 300, 0, 250],\n    [1350, 1300, 950, 800, 550, 250, 0]\n]\n\ndef in_discount_time(h, m):\n    time_minutes = h * 60 + m\n    start = 17 * 60 + 30  # 17:30\n    end = 19 * 60 + 30    # 19:30\n    return start <= time_minutes <= end\n\nwhile True:\n    d = int(input())\n    if d == 0:\n        break\n    \n    hd, md = map(int, input().split())\n    a = int(input())\n    ha, ma = map(int, input().split())\n    \n    # Convert to 0-indexed\n    d -= 1\n    a -= 1\n    \n    # Get base toll and distance\n    base_toll = toll[d][a]\n    dist = distance[d][a]\n    \n    # Check if discount applies\n    discount = False\n    if (in_discount_time(hd, md) or in_discount_time(ha, ma)) and dist <= 40:\n        discount = True\n    \n    if discount:\n        # Half price, rounded up to nearest 50\n        half_toll = base_toll / 2\n        final_toll = math.ceil(half_toll / 50) * 50\n    else:\n        final_toll = base_toll\n    \n    print(final_toll)\n", "perturbed_sampled": ["import math # Distance and toll matrix distance = [ [0, 6, 18, 25, 37, 48, 58], [6, 0,  [18, 12,  [25, 19, 7, 0, 12, 23, 33], [37, 31, 19, 12, 0, 11, 21], [48, 42,  21, 10, 0] ] toll = [ [0,  1350], [200, 0, 450, 600, 850, 1100, 1300], [500, 450,  [650, 600, 250, 0, 350, 600, 800], [900, 850, 500, 350,  750, 600, 300, 0, 250], [1350, 1300, 950, 800, 550, 250, 0] ] def in_discount_time(h, m): time_minutes = h * 60 + m start = 17 * 60 + 30 # 17:30 end = 19 * 60 + 30 # 19:30  end while True: d = int(input()) if d  = map(int, input().split())  = map(int,  d -=  Get base toll and distance base_toll =  Check if discount applies discount = False if (in_discount_time(hd, md) or in_discount_time(ha, ma)) and dist <= 40: discount = True if discount: # Half price, rounded up to nearest 50 half_toll = base_toll / 2 final_toll = math.ceil(half_toll / 50)  base_toll print(final_toll)"], "perturbed_original": ["table=[[0,300,500,600,700,1350,1650], [0,0,350,450,600,1150,1500], [0,0,0,250,400,1000,1350],  True: init=input() if init==0:break h1,m1=map(int,raw_input().split()) fin=input() h2,m2=map(int,raw_input().split()) if init>fin: init,h1,m1,fin,h2,m2=fin,h2,m2,init,h1,m1 t1=h1*60+m1 t2=h2*60+m2 if 1050<=t1<=1170 or 1050<=t2<=1170 and (init,fin) not in fbd:  temp else: print table[init-1][fin-1]"], "original_ll": -0.9805393218994141, "sampled_ll": -0.5267416834831238, "all_perturbed_sampled_ll": [-1.584702491760254], "all_perturbed_original_ll": [-1.6791398525238037], "perturbed_sampled_ll": -1.584702491760254, "perturbed_original_ll": -1.6791398525238037, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a[];main(f,l,i,n,S){for(;scanf(S=\"%d\\n\",&i)*i;){for(l=0;i--;)scanf(S,a+l++);for(n=32;n;f=!f)n-=f?~-n%5:a[++i%l],printf(S,n*=n>0);}}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int a[25];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        \n        int remaining = 32;\n        int jiro_index = 0;\n        int turn = 0; // 0 for Ichiro, 1 for Jiro\n        \n        while (remaining > 0) {\n            if (turn == 0) {\n                // Ichiro's turn\n                int take = (remaining - 1) % 5;\n                remaining -= take;\n                printf(\"%d\\n\", remaining);\n                turn = 1;\n            } else {\n                // Jiro's turn\n                int take = a[jiro_index];\n                if (take >= remaining) {\n                    take = remaining;\n                }\n                remaining -= take;\n                printf(\"%d\\n\", remaining);\n                jiro_index = (jiro_index + 1) % n;\n                turn = 0;\n            }\n        }\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <extra_id_11>!= 1 { n ==<extra_id_12>jiro_index /<extra_id_13>|| ( n !=<extra_id_14>0 &&<extra_id_15>++ )<extra_id_16>} }<extra_id_17> n; while (scanf(\"%d\", &n) == 1 && n != 0) { int a[25]; for (int i =  {  = 32; int jiro_index = 0; int turn = 0; // 0 for Ichiro,  > 0) { if (turn == 0) { // Ichiro's turn int take = (remaining - 1) % 5; remaining -= take; printf(\"%d\\n\", remaining); turn = 1; } else { // Jiro's  if (take >= remaining) { take = remaining; } remaining -= take; printf(\"%d\\n\", remaining); jiro_index = (jiro_index +  return 0; }"], "perturbed_original": ["a[];main(f,l,i,n,S){for(;scanf(S=\"%d\\n\",&i)*i;){for(l=0;i--;)scanf(S,a+l++);for(n=32;n;f=!f)n-=f?~-n%5:a[++i%l],printf(S,n*=n>0);}}"], "original_ll": -4.017247676849365, "sampled_ll": -0.7036850452423096, "all_perturbed_sampled_ll": [-2.1596086025238037], "all_perturbed_original_ll": [-4.017247676849365], "perturbed_sampled_ll": -2.1596086025238037, "perturbed_original_ll": -4.017247676849365, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import static java.util.Arrays.deepToString;\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = sc.nextInt();\n\t\t\t\n\t\t\tint st = 32;\n\t\t\tfor (int time = 0; st > 0; time++) {\n\t\t\t\tst -= (st - 1) % 5;\n\t\t\t\tSystem.out.println(st);\n\t\t\t\tint g = a[time%a.length];\n\t\t\t\tst -= g;\n\t\t\t\tif (st < 0) {\n\t\t\t\t\tst = 0;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(st);\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt();\n            }\n            \n            int remaining = 32;\n            int jiroIndex = 0;\n            \n            while (remaining > 0) {\n                // Ichiro's turn\n                int ichiroTake = (remaining - 1) % 5;\n                remaining -= ichiroTake;\n                System.out.println(remaining);\n                \n                if (remaining == 0) break;\n                \n                // Jiro's turn\n                int jiroTake = Math.min(a[jiroIndex], remaining);\n                remaining -= jiroTake;\n                System.out.println(remaining);\n                \n                jiroIndex = (jiroIndex + 1) % n;\n                \n                if (remaining == 0) break;\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[]  (int i = 0; i < n; i++) { a[i]  = 32; int jiroIndex = 0; while (remaining > 0) { // Ichiro's turn int ichiroTake = (remaining - 1)  System.out.println(remaining); if (remaining == 0) break; // Jiro's  + 1) % n; if (remaining == 0) break; } } sc.close(); } }"], "perturbed_original": ["import static java.util.Arrays.deepToString;  Main().run(); } void tr(Object... os) { System.err.println(deepToString(os)); } Scanner  void run() { for (;sc.hasNext();) { int n = sc.nextInt(); if (n  = new int[n]; for (int i = 0; i < n; i++) a[i] = sc.nextInt(); int st = 32; for (int time = 0; st > 0;  - 1) % 5; System.out.println(st); int g = a[time%a.length]; st -= g; if (st < 0) { st = 0; } System.out.println(st); } } } }"], "original_ll": -1.0797868967056274, "sampled_ll": -0.7308400273323059, "all_perturbed_sampled_ll": [-1.8063350915908813], "all_perturbed_original_ll": [-1.9666337966918945], "perturbed_sampled_ll": -1.8063350915908813, "perturbed_original_ll": -1.9666337966918945, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n=int(input())\n    if n==0: break\n    a=list(map(int,input().split()))\n    i,s=0,32\n    while s>0:\n        s-=(s-1)%5\n        print(s)\n        s-=a[i%n]\n        i+=1\n        print(max(0,s))", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    sequence = list(map(int, input().split()))\n    \n    remaining = 32\n    jiro_index = 0\n    \n    while remaining > 0:\n        # Ichiro's turn\n        to_take = (remaining - 1) % 5\n        remaining -= to_take\n        print(remaining)\n        \n        if remaining == 0:\n            break\n        \n        # Jiro's turn\n        to_take = min(sequence[jiro_index], remaining)\n        remaining -= to_take\n        print(remaining)\n        \n        jiro_index = (jiro_index + 1) % n\n        \n        if remaining == 0:\n            break\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break sequence = list(map(int, input().split())) remaining = 32 jiro_index = 0 while  turn to_take  5 remaining -= to_take print(remaining)  # Jiro's turn to_take = min(sequence[jiro_index], remaining) remaining -= to_take print(remaining) jiro_index = (jiro_index + 1) % n if remaining == 0: break"], "perturbed_original": ["while 1: n=int(input()) if n==0: break a=list(map(int,input().split())) i,s=0,32 while s>0: s-=(s-1)%5 print(s) s-=a[i%n] i+=1 print(max(0,s))"], "original_ll": -1.5220500230789185, "sampled_ll": -1.1225066184997559, "all_perturbed_sampled_ll": [-2.310394525527954], "all_perturbed_original_ll": [-2.0299417972564697], "perturbed_sampled_ll": -2.310394525527954, "perturbed_original_ll": -2.0299417972564697, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\n#define MAX 10000000\n\nint pp[MAX + 1];\n\nint main(){\n  int n, p, m, i, j, prime, x, res, c;\n  pp[0] = pp[1] = 1;\n  for(i = 2; i < MAX / 2 ; ++i)\n    if(pp[i] != 1)\n      for(j = i * 2; j < MAX; j += i)\n\tpp[j] = 1;\n\n  while(scanf(\"%d\", &n) && n){\n    res = 0;\n    while(n--){\n      scanf(\"%d %d\", &p, &m);\n      c = 0;\n      for(i = ((p - m) < 0 ? 0 : p - m);i < ((p + m) > MAX ? MAX : p + m); ++i)\n\tif(pp[i] == 0) c++;\n      if(c > 0) c--;\n      res += c;\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MP 999983\n#define MAX_PRIMES 80000\n\nint is_prime[MP + 1];\nint primes[MAX_PRIMES];\nint prime_count = 0;\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i <= MP; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= MP; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n    \n    for (int i = 2; i <= MP; i++) {\n        if (is_prime[i]) {\n            primes[prime_count++] = i;\n        }\n    }\n}\n\nint binary_search_lower(int val) {\n    int left = 0, right = prime_count - 1;\n    int result = prime_count;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (primes[mid] >= val) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return result;\n}\n\nint binary_search_upper(int val) {\n    int left = 0, right = prime_count - 1;\n    int result = -1;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (primes[mid] <= val) {\n            result = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result;\n}\n\nint count_primes_in_range(int lower, int upper) {\n    if (lower > MP) return 0;\n    if (upper < 2) return 0;\n    \n    if (lower < 2) lower = 2;\n    if (upper > MP) upper = MP;\n    \n    int lower_idx = binary_search_lower(lower);\n    int upper_idx = binary_search_upper(upper);\n    \n    if (lower_idx > upper_idx || lower_idx >= prime_count || upper_idx < 0) {\n        return 0;\n    }\n    \n    return upper_idx - lower_idx + 1;\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long total = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int p, m;\n            scanf(\"%d %d\", &p, &m);\n            \n            int lower = p - m;\n            int upper = p + m;\n            \n            int X = count_primes_in_range(lower, upper);\n            \n            if (X > 1) {\n                total += (X - 1);\n            } else if (X == 0) {\n                total -= 1;\n            }\n        }\n        \n        if (total < 0) total = 0;\n        \n        printf(\"%lld\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  999983 #define MAX_PRIMES 80000 int is_prime[MP +  = 0; void sieve() { memset(is_prime, 1, sizeof(is_prime)); is_prime[0] = is_prime[1] = 0; for (int i = 2; i  { if (is_prime[i]) { for (int j = i * i; j <= MP; j += i) {  } for (int  (is_prime[i]) { primes[prime_count++] = i; } } } int binary_search_lower(int val) { int left = 0, right = prime_count - 1; int result = prime_count; while (left <= right) { int mid = (left + right) / 2; if (primes[mid] >= val) { result = mid; right  else { left = mid +  }  left = 0, right = prime_count - 1; int result = -1;  + right) /  { result = mid; left = mid + 1; } else { right = mid - 1; } } return result; } int count_primes_in_range(int lower, int upper) { if (lower > MP) return 0; if (upper < 2) return 0; if (lower  if (upper > MP) upper = MP; int lower_idx = binary_search_lower(lower); int upper_idx = binary_search_upper(upper); if (lower_idx > upper_idx || lower_idx >= prime_count || upper_idx  } return upper_idx - lower_idx  { sieve(); int  1 && n != 0) { long long total = 0;  i < n; i++) {  &p, &m); int lower =  = p + m; int X = count_primes_in_range(lower, upper); if (X >  - 1); } else if (X == 0) { total -= 1; } } if (total < 0) total =  0; }"], "perturbed_original": [" int pp[MAX + 1]; int main(){  j, prime, x,  = 1; for(i = 2; i <  if(pp[i] != 1) for(j = i * 2; j < MAX; j += i) pp[j] =  res = 0; while(n--){  = 0; for(i = ((p - m) < 0 ? 0 : p - m);i < ((p + m) > MAX ? MAX : p + m); ++i) if(pp[i] == 0) c++; if(c > 0) c--; res += c; } printf(\"%d\\n\", res); } return 0; }"], "original_ll": -0.8939827680587769, "sampled_ll": -0.36275139451026917, "all_perturbed_sampled_ll": [-1.4062660932540894], "all_perturbed_original_ll": [-1.8673311471939087], "perturbed_sampled_ll": -1.4062660932540894, "perturbed_original_ll": -1.8673311471939087, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tlong[] m = new long[]{ 2, 7, 61 };\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> Ans = new ArrayList<Integer>();\n\t\tString line;\n\t\t\n\t\tint[] prime = new int[1000000];\n\t\t\n\t\twhile((line = in.readLine()) != null){\n\t\t\tint size = Integer.parseInt(line);\n\t\t\tif(size==0) break;\n\t\t\t\n\t\t\tint pay = 0;\n\t\t\tfor(int n=0; n<size; n++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tint center = Integer.parseInt(dst[0]);\n\t\t\t\tint range = Integer.parseInt(dst[1]);\n\t\t\t\t\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i=Math.max(2, center-range); i<=Math.min(center+range, 999983); i++){\n\t\t\t\t\tif(prime[i]==0){\n\t\t\t\t\t\tif(isPrime(i)){\n\t\t\t\t\t\t\tprime[i] = 1;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tprime[i] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(prime[i]==1){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpay += count - 1;\n\t\t\t}\n\t\t\t\n\t\t\tAns.add(Math.max(0, pay));\n\t\t}\n\t\t\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tSystem.out.println(Ans.get(n));\n\t\t}\t\t\n\t}\n\t\n\tpublic boolean isPrime(long x){\n\t\tif(x==2){\n\t\t\treturn true;\n\t\t}\n\t\telse if(x%2 == 0){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\tlong s = 0;\n\t\t\tlong d = x - 1;\n\t\t\twhile(d%2 == 0){\n\t\t\t\td = d / 2;\n\t\t\t\ts++;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<3; i++){\n\t\t\t\tlong a = m[i];\n\t\t\t\tif(a%x == 0) continue;\n\t\t\t\t\n\t\t\t\tlong pow = mod(a, d, x);\n\t\t\t\tif(pow == 1) continue;\n\t\t\t\tif(pow == x - 1) continue;\n\t\t\t\t\n\t\t\t\tboolean con2 = false;\n\t\t\t\tfor(int r=1; r<s; r++){\n\t\t\t\t\tpow = mod(pow, 2, x);\n\t\t\t\t\t//pow = mod(a, (long)(d * Math.pow(2.0, r)), x);\n\t\t\t\t\tif(pow ==  x - 1){\n\t\t\t\t\t\tcon2 = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!con2){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic long mod(long a, long d, long n){\n\t\tif(a==0 || n==0) return 0;\n\t\tif(d==0) return 1 % n;\n\t\t\n\t\tlong currentMod = a % n;\n\t\tlong currentValue = (d%2 == 1) ? currentMod : 1;\n\t\t\n\t\tfor(d>>=1; d>0; d>>=1){\n\t\t\tcurrentMod = (currentMod * currentMod) % n;\n\t\t\tif(d%2 == 1){\n\t\t\t\tcurrentValue = (currentValue * currentMod) % n;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn currentValue;\n\t\t\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MP = 999983;\n    static boolean[] isPrime;\n    static int[] primeCount;\n    \n    static void sieve() {\n        isPrime = new boolean[MP + 1];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i <= MP; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= MP; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        primeCount = new int[MP + 1];\n        int count = 0;\n        for (int i = 0; i <= MP; i++) {\n            if (isPrime[i]) count++;\n            primeCount[i] = count;\n        }\n    }\n    \n    static int countPrimes(int p, int m) {\n        int left = Math.max(0, p - m);\n        int right = Math.min(MP, p + m);\n        \n        int count = primeCount[right];\n        if (left > 0) {\n            count -= primeCount[left - 1];\n        }\n        \n        return count;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        \n        sieve();\n        \n        String line;\n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            long totalRequest = 0;\n            \n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                int p = Integer.parseInt(parts[0]);\n                int m = Integer.parseInt(parts[1]);\n                \n                int x = countPrimes(p, m);\n                \n                if (x == 0) {\n                    totalRequest -= 1;\n                } else {\n                    totalRequest += (x - 1);\n                }\n            }\n            \n            totalRequest = Math.max(0, totalRequest);\n            pw.println(totalRequest);\n        }\n        \n        pw.flush();\n        pw.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static final int MP =  int[] primeCount; static void sieve() { isPrime = new boolean[MP  =  i = 2; i * i <= MP; i++) { if (isPrime[i]) { for (int j = i * i; j <= MP; j += i)  } } primeCount = new int[MP + 1]; int count = 0; for (int i = 0;  if (isPrime[i]) count++; primeCount[i] =  { int left = Math.max(0, p - m); int right = Math.min(MP, p + m); int count = primeCount[right]; if (left > 0) { count -= primeCount[left - 1]; } return count; } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); PrintWriter pw = new PrintWriter(System.out);  = br.readLine()) != null) { int n = Integer.parseInt(line.trim()); if (n ==  0; for (int i = 0; i < n;  == 0) { totalRequest -= 1; } else { totalRequest += (x - 1); } } totalRequest = Math.max(0, totalRequest); pw.println(totalRequest); } pw.flush(); pw.close(); } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static void main(String  e){ e.printStackTrace(); } } long[] m = new long[]{ 2, 7, 61 }; public Main() throws IOException{ BufferedReader in =  line; int[] prime =  !=  if(size==0) break;  = in.readLine(); String[] dst = line.split(\" \"); int center = Integer.parseInt(dst[0]); int range = Integer.parseInt(dst[1]); int count = 0; for(int i=Math.max(2, center-range); i<=Math.min(center+range, 999983); i++){ if(prime[i]==0){ if(isPrime(i)){  else{  if(prime[i]==1){ count++; } } } pay += count -  for(int n=0;  public boolean isPrime(long x){ if(x==2){ return true; }  false; } else{ long s = 0; long d  == 0){ d = d / 2; s++; } for(int i=0; i<3; i++){ long a = m[i]; if(a%x == 0) continue; long pow = mod(a, d, x); if(pow == 1) continue; if(pow == x - 1) continue; boolean con2  r++){ pow = mod(pow, 2, x); //pow = mod(a, (long)(d * Math.pow(2.0, r)), x); if(pow == x - 1){ con2  if(!con2){ return false; } } return true; } } public long mod(long a, long d, long n){ if(a==0 || n==0) return 0; if(d==0) return 1 % n; long currentMod = a % n; long currentValue =  : 1; for(d>>=1; d>0; d>>=1){ currentMod = (currentMod * currentMod) % n; if(d%2 == 1){ currentValue  n; } } return currentValue; } }"], "original_ll": -0.7559167742729187, "sampled_ll": -0.45180654525756836, "all_perturbed_sampled_ll": [-1.289463996887207], "all_perturbed_original_ll": [-1.788207769393921], "perturbed_sampled_ll": -1.289463996887207, "perturbed_original_ll": -1.788207769393921, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nN=1000000\nprime=[1]*(N+1)\nprime[0]=0\nprime[1]=0\nfor i in range(2,int(math.sqrt(N))):\n    if prime[i]==1:\n        j=i\n        while i*j<=N:\n            prime[i*j]=0\n            j+=1\nprime=[i for i in range(N+1) if prime[i]==1]\n\nwhile True:\n    n=input()\n    if n==0:break\n    cnt=0\n    for i in range(n):\n        p,m=map(int,raw_input().split())\n        for j in range(len(prime)):\n            if p-m<=prime[j]<=p+m:\n                cnt+=1\n            if p+m<=prime[j]:\n                break\n    print cnt-n", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    primes = [i for i in range(limit + 1) if is_prime[i]]\n    return primes, is_prime\n\nMP = 999983\nprimes, is_prime = sieve_of_eratosthenes(MP)\n\ndef binary_search_left(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef binary_search_right(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef count_primes_in_range(low, high):\n    left_idx = binary_search_left(primes, low)\n    right_idx = binary_search_right(primes, high)\n    return right_idx - left_idx\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    total_cost = 0\n    for _ in range(n):\n        p, m = map(int, input().split())\n        low = max(0, p - m)\n        high = min(MP, p + m)\n        \n        X = count_primes_in_range(low, high)\n        \n        if X > 0:\n            total_cost += X - 1\n        else:\n            total_cost -= 1\n    \n    total_cost = max(0, total_cost)\n    print(total_cost)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] =<extra_id_3>- 1 if<extra_id_4>(input().split()<extra_id_5>int(input().split()) : X<extra_id_6>(total_cost)/<extra_id_7>3:<extra_id_8>2: break while<extra_id_9>( total_cost/(n + 1) +<extra_id_10>+ 1<extra_id_11>[ 0 ] ==<extra_id_12>for<extra_id_13>i < int<extra_id_14>i: break p = is_prime[1] = False for i in range(2, int(limit**0.5) + 1): if is_prime[i]: for j in range(i*i, limit + 1, i): is_prime[j] = p<extra_id_15>X -<extra_id_16>0 if (m, m + 1) if is_prime[i]] return  primes, is_prime = sieve_of_eratosthenes(MP) def binary_search_left(arr, target): left, right = 0, len(arr) while left < right: mid = (left +  < target: left = mid + 1 else: right = mid return left  = 0, len(arr) while left < right: mid = (left + right)  + 1 else: right = mid return left def count_primes_in_range(low, high): left_idx = binary_search_left(primes, low) right_idx = binary_search_right(primes, high) return right_idx - left_idx while True: n = int(input()) if n == 0: break  in range(n): p, m = map(int, input().split()) low = max(0, p  p + m) X  > 0: total_cost += X - 1 else: total_cost -= 1 total_cost = max(0, total_cost) print(total_cost)"], "perturbed_original": ["import math N=1000000 prime=[1]*(N+1) prime[0]=0 prime[1]=0 for i in range(2,int(math.sqrt(N))): if prime[i]==1:  prime=[i for i in range(N+1) if prime[i]==1] while True: n=input()  in range(n): p,m=map(int,raw_input().split()) for j in range(len(prime)): if p-m<=prime[j]<=p+m: cnt+=1 if p+m<=prime[j]: break print cnt-n"], "original_ll": -0.924961268901825, "sampled_ll": -0.4281202256679535, "all_perturbed_sampled_ll": [-1.8246831893920898], "all_perturbed_original_ll": [-1.6627075672149658], "perturbed_sampled_ll": -1.8246831893920898, "perturbed_original_ll": -1.6627075672149658, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void) {\n  int n, data[100], j, tmp, i, count;\n  while(scanf(\"%d\",&n),n) {\n    count = 0;\n    for(i = 0; i < n; i++ ) {\n      scanf(\"%d\",&data[i]);\n    }\n    for(i = 0; i < n - 1; i++ ) {\n      for(j = 1; j < n - i; j++ ) {\n\tif(data[j] < data[j-1]) {\n\t  tmp = data[j];\n\t  data[j] = data[j-1];\n\t  data[j-1] = tmp;\n\t  count++;\n\t}\n      }\n    }\n    printf(\"%d\\n\",count);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int arr[100];\n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", &arr[i]);\n        }\n        \n        int swaps = 0;\n        for(int i = 0; i < n - 1; i++) {\n            for(int j = 0; j < n - 1 - i; j++) {\n                if(arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swaps++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", swaps);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n;  == 0) break;  0; i < n; i++) { scanf(\"%d\", &arr[i]); } int swaps = 0; for(int i = 0; i <  j < n - 1 - i; j++) { if(arr[j] > arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j  = temp; swaps++; } } } printf(\"%d\\n\", swaps); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int n, data[100], j, tmp, i, count; while(scanf(\"%d\",&n),n)  = 0; i < n; i++ ) { scanf(\"%d\",&data[i]); } for(i = 0; i < n - 1; i++ ) { for(j = 1; j < n - i; j++ ) {  = data[j]; data[j] = data[j-1];  return 0; }"], "original_ll": -0.6416163444519043, "sampled_ll": -0.325618714094162, "all_perturbed_sampled_ll": [-1.3464596271514893], "all_perturbed_original_ll": [-1.4463974237442017], "perturbed_sampled_ll": -1.3464596271514893, "perturbed_original_ll": -1.4463974237442017, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n\tScanner sc = new Scanner(System.in);\n\t\n\tprivate void doit(){\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint [] data = new int[n];\n\t\t\tfor(int i = 0; i  <n; i++){\n\t\t\t\tdata[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor(;;){\n\t\t\t\tboolean flg = false;\n\t\t\t\tfor(int j = 0; j < n-1; j++){\n\t\t\t\t\tif(data[j] > data[j + 1]){\n\t\t\t\t\t\tint temp = data[j];\n\t\t\t\t\t\tdata[j] = data[j+1];\n\t\t\t\t\t\tdata[j+1] = temp;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(! flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = sc.nextInt();\n            }\n            \n            int swapCount = bubbleSort(arr, n);\n            System.out.println(swapCount);\n        }\n        \n        sc.close();\n    }\n    \n    static int bubbleSort(int[] arr, int n) {\n        int count = 0;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - 1 - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0)  int[n]; for (int i = 0; i <  = bubbleSort(arr, n); System.out.println(swapCount);  bubbleSort(int[] arr, int n) {  i < n - 1; i++) { for (int j = 0; j <  j++) { if (arr[j] > arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; count++; } } } return count; } }"], "perturbed_original": ["import java.util.*; public class Main{ Scanner sc = new Scanner(System.in); private void doit(){ while(true){  == 0) break; int [] data = new int[n]; for(int i =  = sc.nextInt(); } int count = 0; for(;;){ boolean flg = false; for(int j = 0; j  data[j +   temp; count++; flg = true; } } if(! flg){ break; } } System.out.println(count); } } private void debug(Object... o)  Arrays.deepToString(o)); } public static void main(String[] args) { new Main().doit(); } }"], "original_ll": -0.7946022748947144, "sampled_ll": -0.24752920866012573, "all_perturbed_sampled_ll": [-1.068041443824768], "all_perturbed_original_ll": [-1.9143134355545044], "perturbed_sampled_ll": -1.068041443824768, "perturbed_original_ll": -1.9143134355545044, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    Num_lis = []\n    cou = 0\n    for i in range(n):\n        Num_lis.append(int(input()))\n    S_lis = sorted(Num_lis)\n    while Num_lis != S_lis:\n        \n        for j in range(n - 1):\n            if Num_lis[j] > Num_lis[j + 1]:\n                Num_lis[j],Num_lis[j + 1] = Num_lis[j + 1],Num_lis[j]\n                cou += 1\n    print(cou)", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    arr = []\n    for _ in range(n):\n        arr.append(int(input()))\n    \n    count = 0\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                count += 1\n    \n    print(count)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break arr = [] for _ in range(n): arr.append(int(input())) count = 0 for   arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] count += 1 print(count)"], "perturbed_original": ["while True: n =  break Num_lis  Num_lis.append(int(input())) S_lis = sorted(Num_lis) while Num_lis != S_lis: for j in range(n - 1): if Num_lis[j] > Num_lis[j + 1]: Num_lis[j],Num_lis[j + 1] = Num_lis[j + 1],Num_lis[j] cou += 1 print(cou)"], "original_ll": -0.7544963955879211, "sampled_ll": -0.4865417778491974, "all_perturbed_sampled_ll": [-1.1257959604263306], "all_perturbed_original_ll": [-1.5295443534851074], "perturbed_sampled_ll": -1.1257959604263306, "perturbed_original_ll": -1.5295443534851074, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  int n, p[31] = {}, i, res;\n  p[0] = 1;\n  p[1] = 1;\n  p[2] = 2;\n\n\n  while(scanf(\"%d\", &n) && n){\n    for(i = 3; i <= n; i++) p[i] = p[i - 1] + p[i - 2] + p[i - 3];\n    res = p[n] / 10 / 365 + 1;\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    long long dp[31];\n    \n    // Calculate number of ways to climb stairs for each n\n    dp[0] = 1;\n    dp[1] = 1;\n    dp[2] = 2;\n    \n    for (int i = 3; i <= 30; i++) {\n        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\n    }\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long ways = dp[n];\n        long long days = (ways + 9) / 10;  // Round up division\n        long long years = (days + 364) / 365;  // Round up division\n        printf(\"%lld\\n\", years);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; long long dp[31]; // Calculate number of ways to climb  = 1; dp[1] = 1; dp[2] = 2; for (int i = 3; i <= 30; i++) { dp[i] = dp[i-1] + dp[i-2] + dp[i-3]; } while (scanf(\"%d\", &n) == 1 && n != 0) { long long ways = dp[n]; long  Round up division long long years =  printf(\"%lld\\n\", years); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ int n, p[31] = {}, i, res; p[0] = 1; p[1] = 1; p[2] = 2; while(scanf(\"%d\", &n) && n){ for(i = 3; i <= n; i++) p[i] =  - 2] + p[i - 3]; res  res); } return 0; }"], "original_ll": -0.9455469846725464, "sampled_ll": -0.684653639793396, "all_perturbed_sampled_ll": [-1.4174429178237915], "all_perturbed_original_ll": [-1.614060401916504], "perturbed_sampled_ll": -1.4174429178237915, "perturbed_original_ll": -1.614060401916504, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,i,j,a[];(n=s.nextInt())>0;System.out.println(a[n]/3650+1))for(a=new int[n+3],a[1]=a[2]=a[3]=1,i=0;i<n;++i)for(j=4;j-->1;)a[i+j]+=a[i];}}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        long[] ways = new long[31];\n        ways[0] = 1;\n        \n        for (int i = 1; i <= 30; i++) {\n            ways[i] = 0;\n            if (i >= 1) ways[i] += ways[i-1];\n            if (i >= 2) ways[i] += ways[i-2];\n            if (i >= 3) ways[i] += ways[i-3];\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            long totalWays = ways[n];\n            long days = (totalWays + 9) / 10;\n            long years = (days + 364) / 365;\n            \n            System.out.println(years);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  static void main(String[] args) { Scanner sc = new Scanner(System.in); long[] ways = new long[31]; ways[0] = 1; for (int i = 1; i <= 30; i++) { ways[i] = 0; if (i >= 1) ways[i]  2) ways[i] += ways[i-2]; if (i >= 3) ways[i] += ways[i-3]; } while (true) { int n = sc.nextInt(); if (n == 0) break; long totalWays =  + 9)  365; System.out.println(years); } sc.close(); } }"], "perturbed_original": ["import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,i,j,a[];(n=s.nextInt())>0;System.out.println(a[n]/3650+1))for(a=new int[n+3],a[1]=a[2]=a[3]=1,i=0;i<n;++i)for(j=4;j-->1;)a[i+j]+=a[i];}}"], "original_ll": -1.9242453575134277, "sampled_ll": -0.5291915535926819, "all_perturbed_sampled_ll": [-1.2774860858917236], "all_perturbed_original_ll": [-1.9242453575134277], "perturbed_sampled_ll": -1.2774860858917236, "perturbed_original_ll": -1.9242453575134277, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a = []\na[:4] = [0, 1, 2, 3]\ninList = []\nwhile True:\n    price = int(input())\n    if price == 0:\n        break\n    inList.append(int(input()))\nn = max(inList)\nfor i in range(4, n + 1):\n    a[i] = a[i-1] + a[i-2] + a[i-3]\nfor i in inList:\n    print((a[i] // 3650) + (a[i] % 3650 != 0))", "sampled": "import sys\n\ndef count_ways(n):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        dp[i] = dp[i-1]\n        if i >= 2:\n            dp[i] += dp[i-2]\n        if i >= 3:\n            dp[i] += dp[i-3]\n    \n    return dp[n]\n\ndef calculate_years(n):\n    ways = count_ways(n)\n    days = (ways + 9) // 10\n    years = (days + 364) // 365\n    return years\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    if n == 0:\n        break\n    print(calculate_years(n))\n", "perturbed_sampled": [" n == 0: return 1 if n <  [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): dp[i] = dp[i-1] if i  if i >= 3: dp[i] += dp[i-3] return dp[n] def calculate_years(n): ways =  = (days + 364) // 365 return years for line in sys.stdin: n = int(line.strip()) if n == 0: break print(calculate_years(n))"], "perturbed_original": ["a = [] a[:4] = [0, 1, 2, 3] inList = [] while True: price = int(input())  inList.append(int(input())) n = max(inList) for  1): a[i] =  for i in inList: print((a[i] // 3650) + (a[i] % 3650 != 0))"], "original_ll": -1.236865520477295, "sampled_ll": -0.5379208326339722, "all_perturbed_sampled_ll": [-1.683983325958252], "all_perturbed_original_ll": [-2.5336313247680664], "perturbed_sampled_ll": -1.683983325958252, "perturbed_original_ll": -2.5336313247680664, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint main(){\n  int i;\n  int c[128],m,n;\n  char s[256],*t;  \n  for(;;){\n    fgets(s,256,stdin);\n    s[strlen(s)-1]='\\0';\n    t=strtok(s,\" \");\n    c[0]=atoi(t)<10?atoi(t):10;\n    if(c[0]==0)\n      break;\n    for(n=1;(t=strtok(NULL,\" \"))!=NULL;n++)\n      c[n]=atoi(t)<10?atoi(t):10;\n    m=0;\n    for(i=0;i<n;i++)\n      m+=c[i];\n    for(i=0;i<n;i++){\n      if(m<12&&c[i]==1)\n\tm+=10;\n    }\n    if(m>21)\n      m=0;\n    printf(\"%d\\n\",m);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int card;\n    \n    while (1) {\n        scanf(\"%d\", &card);\n        if (card == 0) break;\n        \n        int sum = 0;\n        int aces = 0;\n        \n        do {\n            if (card == 1) {\n                sum += 1;\n                aces++;\n            } else if (card >= 2 && card <= 9) {\n                sum += card;\n            } else if (card >= 10 && card <= 13) {\n                sum += 10;\n            }\n            \n            int c = getchar();\n            if (c == '\\n' || c == EOF) break;\n            scanf(\"%d\", &card);\n        } while (1);\n        \n        // Try to maximize score by using 11 for aces\n        while (aces > 0 && sum + 10 <= 21) {\n            sum += 10;\n            aces--;\n        }\n        \n        if (sum > 21) {\n            sum = 0;\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int card; while (1) { scanf(\"%d\", &card); if (card == 0) break; int sum = 0; int aces = 0; do { if (card == 1) { sum += 1; aces++; } else if (card >= 2 && card <= 9) {   sum += 10; } int c = getchar(); if (c == '\\n' || c == EOF)  (1); // Try  11 for aces while (aces > 0 && sum + 10 <= 21) { sum += 10; aces--;  { sum = 0;  0; }"], "perturbed_original": ["#include<stdio.h> #include<stdlib.h> #include<string.h> int main(){ int  for(;;){ fgets(s,256,stdin); s[strlen(s)-1]='\\0'; t=strtok(s,\"  \"))!=NULL;n++) c[n]=atoi(t)<10?atoi(t):10; m=0; for(i=0;i<n;i++) m+=c[i]; for(i=0;i<n;i++){ if(m<12&&c[i]==1) m+=10; } if(m>21) m=0; printf(\"%d\\n\",m); } return 0; }"], "original_ll": -1.0835449695587158, "sampled_ll": -0.6606650948524475, "all_perturbed_sampled_ll": [-1.6629036664962769], "all_perturbed_original_ll": [-1.7560627460479736], "perturbed_sampled_ll": -1.6629036664962769, "perturbed_original_ll": -1.7560627460479736, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile(sc.hasNext()) {\n\t\t\tString[] text = sc.nextLine().split(\" \");\n\t\t\tint[] cards = new int[text.length];\n\t\t\tboolean one = false; //1????????????\n\t\t\tint sum = 0; //????\u00a8??????\u00b0\n\t\t\tboolean flag = false;\n\n\t\t\tfor(int $ = 0; $ < text.length; $++) {\n\t\t\t\tcards[$] = Integer.parseInt(text[$]);\n\t\t\t\tif(cards[0] == 0) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(cards[$] == 1) {\n\t\t\t\t\tone = true;\n\t\t\t\t\tsum++;\n\t\t\t\t} else if(cards[$] >= 10 && cards[$] <=13) {\n\t\t\t\t\tsum += 10;\n\t\t\t\t} else {\n\t\t\t\t\tsum += cards[$];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flag) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(one) {\n\t\t\t\tif(sum + 10 <= 21) {\n\t\t\t\t\tsum += 10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(sum > 21) {\n\t\t\t\tsum = 0;\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String line = sc.nextLine().trim();\n            if (line.equals(\"0\")) {\n                break;\n            }\n            \n            String[] tokens = line.split(\"\\\\s+\");\n            int[] cards = new int[tokens.length];\n            for (int i = 0; i < tokens.length; i++) {\n                cards[i] = Integer.parseInt(tokens[i]);\n            }\n            \n            int result = calculateScore(cards);\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n    \n    private static int calculateScore(int[] cards) {\n        int baseSum = 0;\n        int aceCount = 0;\n        \n        for (int card : cards) {\n            if (card == 1) {\n                aceCount++;\n                baseSum += 1;\n            } else if (card >= 10) {\n                baseSum += 10;\n            } else {\n                baseSum += card;\n            }\n        }\n        \n        // Try to maximize the score by using aces as 11\n        int maxScore = baseSum;\n        for (int i = 0; i <= aceCount; i++) {\n            int score = baseSum + i * 10; // Each ace used as 11 adds 10 more (since base is 1)\n            if (score <= 21) {\n                maxScore = Math.max(maxScore, score);\n            }\n        }\n        \n        if (maxScore > 21) {\n            return 0;\n        }\n        \n        return maxScore;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { String line = sc.nextLine().trim(); if (line.equals(\"0\")) { break; } String[] tokens = line.split(\"\\\\s+\"); int[] cards =  = 0;  cards[i] =  calculateScore(int[] cards) {  aceCount = 0; for (int card : cards) { if (card == 1) { aceCount++; baseSum += 1; } else if (card >= 10) { baseSum += 10; } else { baseSum += card; } } // Try to maximize the score by using aces as 11 int maxScore = baseSum; for (int i = 0; i  score = baseSum  Each ace used as  base is 1) if (score <= 21) { maxScore = Math.max(maxScore, score); } } if (maxScore  } return maxScore; } }"], "perturbed_original": ["import java.util.Scanner;  Scanner sc = new Scanner(System.in); public static void main(String[] args) { while(sc.hasNext()) { String[]  cards = new int[text.length]; boolean one = false; //1???????????? int sum = 0;  for(int $ = 0; $ < text.length;  if(cards[0] == 0) { flag = true; break; } if(cards[$] == 1) { one = true; sum++; } else if(cards[$] >= 10 &&  10; } else { sum  { break; } if(one) { if(sum + 10 <= 21) { sum += 10; } } if(sum > 21) {  } } }"], "original_ll": -0.8465014696121216, "sampled_ll": -0.5413522720336914, "all_perturbed_sampled_ll": [-1.5823403596878052], "all_perturbed_original_ll": [-1.9286651611328125], "perturbed_sampled_ll": -1.5823403596878052, "perturbed_original_ll": -1.9286651611328125, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    h = map(int, raw_input().split())\n    if h[0] == 0:\n        break\n    t = 0\n    a = 0\n    for c in sorted(h, reverse=True):\n        if 2 <= c <= 9:\n            t += c\n        elif 10 <= c:\n            t += 10\n        elif c == 1:\n            a += 1\n            \n    t += a\n    if 21 < t:\n        print 0\n    else:\n        for i in range(a):\n            if 21 < t + 10:\n                print t\n                break\n            else:\n                t += 10\n        else:\n            print t", "sampled": "import sys\n\ndef calculate_hand_value(cards):\n    # Convert card values\n    converted = []\n    ace_count = 0\n    \n    for card in cards:\n        if card == 1:\n            ace_count += 1\n            converted.append(1)\n        elif card >= 10:\n            converted.append(10)\n        else:\n            converted.append(card)\n    \n    # Calculate base sum (all aces as 1)\n    base_sum = sum(converted)\n    \n    # Try to maximize by converting aces from 1 to 11\n    max_value = base_sum\n    \n    # We can convert at most one ace from 1 to 11 (adding 10 to the sum)\n    # because converting more than one would add 20+ which would likely bust\n    for i in range(ace_count + 1):\n        # i is the number of aces we treat as 11\n        current_sum = base_sum + (i * 10)\n        if current_sum <= 21:\n            max_value = max(max_value, current_sum)\n    \n    if max_value > 21:\n        return 0\n    return max_value\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line == '0':\n        break\n    \n    cards = list(map(int, line.split()))\n    result = calculate_hand_value(cards)\n    print(result)\n", "perturbed_sampled": ["import sys def calculate_hand_value(cards): # Convert card values converted = [] ace_count = 0 for card in cards: if card == 1: ace_count += 1 converted.append(1) elif card >= 10: converted.append(10) else: converted.append(card) # Calculate base sum (all aces as = max(max_value, current_sum)<extra_id_4>=<extra_id_5>: value = convert<extra_id_6>if value == '0'<extra_id_7>.<extra_id_8>(<extra_id_9>'0'<extra_id_10>> 10: result = float<extra_id_11>( - 10 +<extra_id_12>( 8 +<extra_id_13>else 0 :<extra_id_14>1<extra_id_15>1: card<extra_id_22>, cards<extra_id_23>7 : card_count = int<extra_id_24>else :<extra_id_25>, card_count , 7 Try to  1 to 11 max_value = base_sum # We can convert at most one ace from 1 to 11 (adding 10 to the sum) # because converting more than one would add 20+  i in range(ace_count + 1): # i is the number of aces we treat as  = max(max_value, current_sum)  0 return max_value  = line.strip() if line == '0': break cards = list(map(int, line.split())) result = calculate_hand_value(cards) print(result)"], "perturbed_original": ["while True: h = map(int, raw_input().split()) if h[0] ==  a = 0 for c in sorted(h, reverse=True): if 2 <= c <= 9: t  c: t +=  a += 1 t += a if  else: for i in range(a): if 21 < t + 10: print t break else: t += 10 else: print t"], "original_ll": -1.0598018169403076, "sampled_ll": -1.047750473022461, "all_perturbed_sampled_ll": [-2.283898115158081], "all_perturbed_original_ll": [-2.340911865234375], "perturbed_sampled_ll": -2.283898115158081, "perturbed_original_ll": -2.340911865234375, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\ntypedef struct i{char f[21];int s,w;} i;\ni g[10];\nint n,t[10],f[10]={0},ans[10],max=0;\n\nvoid rec(int d)\n{\n\tint i,w=0,G=0;\n\tif(d==n)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(w>g[t[i]].s)\n\t\t\t\treturn;\n\t\t\tw+=g[t[i]].w;\n\t\t\tG+=g[t[i]].w*(i+1);\n\t\t}\n\t\tif(max<G)\n\t\t{\n\t\t\tmax=G;\n\t\t\tmemcpy(ans,t,sizeof(t));\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(!f[i])\n\t\t\t{\n\t\t\t\tf[i]=1;\n\t\t\t\tt[d]=i;\n\t\t\t\trec(d+1);\n\t\t\t\tf[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i;\n\tfor(;;)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%s %d%d\",g[i].f,&g[i].w,&g[i].s);\n\t\trec(0);\n\t\twhile(--n>=0)\n\t\t\tputs(g[ans[n]].f);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[25];\n    int weight;\n    int strength;\n    int index;\n} Food;\n\nint n;\nFood foods[10];\nFood current[10];\nFood best[10];\nint visited[10];\ndouble best_center;\n\nint check_valid() {\n    for (int i = 0; i < n; i++) {\n        int weight_above = 0;\n        for (int j = i + 1; j < n; j++) {\n            weight_above += current[j].weight;\n        }\n        if (current[i].strength < weight_above) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ndouble calculate_center() {\n    int numerator = 0;\n    int denominator = 0;\n    for (int i = 0; i < n; i++) {\n        numerator += (i + 1) * current[i].weight;\n        denominator += current[i].weight;\n    }\n    return (double)numerator / denominator;\n}\n\nvoid solve(int depth) {\n    if (depth == n) {\n        if (check_valid()) {\n            double center = calculate_center();\n            if (center < best_center) {\n                best_center = center;\n                for (int i = 0; i < n; i++) {\n                    best[i] = current[i];\n                }\n            }\n        }\n        return;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            visited[i] = 1;\n            current[depth] = foods[i];\n            solve(depth + 1);\n            visited[i] = 0;\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s %d %d\", foods[i].name, &foods[i].weight, &foods[i].strength);\n            foods[i].index = i;\n        }\n        \n        best_center = 1e9;\n        memset(visited, 0, sizeof(visited));\n        \n        solve(0);\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%s\\n\", best[i].name);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef struct { char name[25]; int weight; int strength; int index; } Food; int n; Food foods[10]; Food  double best_center; int check_valid() { for (int i = 0; i < n; i++) { int weight_above  = i + 1; j < n; j++) { weight_above += current[j].weight;  } return 1; } double calculate_center() { int  = 0; for (int i = 0; i < n; i++) {  * current[i].weight; denominator += current[i].weight; } return (double)numerator / denominator; } void solve(int depth) { if (depth == n) { if (check_valid()) { double center = calculate_center(); if (center < best_center) { best_center  = 0;  } } return; } for (int i = 0; i < n; i++) {  1; current[depth] = foods[i]; solve(depth + 1); visited[i]  int main() { while (1) { scanf(\"%d\", &n); if (n ==  = 0; i < n; i++) {   best_center = 1e9; memset(visited, 0, sizeof(visited)); solve(0); for (int i = 0; i < n; i++) { printf(\"%s\\n\", best[i].name); } } return 0; }"], "perturbed_original": [" g[10]; int n,t[10],f[10]={0},ans[10],max=0; void rec(int d) { int i,w=0,G=0; if(d==n) { for(i=0;i<n;i++) { if(w>g[t[i]].s) return; w+=g[t[i]].w; G+=g[t[i]].w*(i+1); } if(max<G) { max=G; memcpy(ans,t,sizeof(t)); } } else { for(i=0;i<n;i++) { if(!f[i]) { f[i]=1; t[d]=i; rec(d+1); f[i]=0; } } } } int  { scanf(\"%d\",&n); if(!n)  rec(0); while(--n>=0) puts(g[ans[n]].f); } return 0; }"], "original_ll": -0.90479576587677, "sampled_ll": -0.46306324005126953, "all_perturbed_sampled_ll": [-1.4952499866485596], "all_perturbed_original_ll": [-1.4313470125198364], "perturbed_sampled_ll": -1.4952499866485596, "perturbed_original_ll": -1.4313470125198364, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Food {\n\tString name;\n\tint w;\n\tint s;\n\n\tpublic Food(String name, int w, int s) {\n\t\tthis.name = name;\n\t\tthis.w = w;\n\t\tthis.s = s;\n\t}\n\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint max = 0;\n\t\t\tList<Food> list = new ArrayList<Food>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString l = scanner.next();\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tlist.add(new Food(l, a, b));\n\t\t\t\tmax += a;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint l = 0;\n\t\t\t\tint k = 0;\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\tint m = max - list.get(j).w;\n\t\t\t\t\tint ss = list.get(j).s;\n\t\t\t\t\tif (m <= ss) {\n\t\t\t\t\t\tif (list.get(j).w > k) {\n\t\t\t\t\t\t\tk = list.get(j).w;\n\t\t\t\t\t\t\tl = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax -= list.get(l).w;\n\t\t\t\tSystem.out.println(list.get(l).name);\n\t\t\t\tlist.get(l).s = -10;\n\t\t\t\tlist.get(l).w = 0;\n\t\t\t}\n\t\t}\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Food {\n        String name;\n        int weight;\n        int strength;\n        \n        Food(String name, int weight, int strength) {\n            this.name = name;\n            this.weight = weight;\n            this.strength = strength;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            Food[] foods = new Food[n];\n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                int weight = sc.nextInt();\n                int strength = sc.nextInt();\n                foods[i] = new Food(name, weight, strength);\n            }\n            \n            int[] bestPerm = null;\n            double minG = Double.MAX_VALUE;\n            \n            int[] perm = new int[n];\n            for (int i = 0; i < n; i++) {\n                perm[i] = i;\n            }\n            \n            do {\n                if (isValid(foods, perm)) {\n                    double g = calculateG(foods, perm);\n                    if (g < minG) {\n                        minG = g;\n                        bestPerm = perm.clone();\n                    }\n                }\n            } while (nextPermutation(perm));\n            \n            for (int i = 0; i < n; i++) {\n                System.out.println(foods[bestPerm[i]].name);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static boolean isValid(Food[] foods, int[] perm) {\n        int n = perm.length;\n        for (int i = 0; i < n; i++) {\n            int weightAbove = 0;\n            for (int j = i + 1; j < n; j++) {\n                weightAbove += foods[perm[j]].weight;\n            }\n            if (foods[perm[i]].strength < weightAbove) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    static double calculateG(Food[] foods, int[] perm) {\n        int n = perm.length;\n        double numerator = 0;\n        double denominator = 0;\n        for (int i = 0; i < n; i++) {\n            numerator += (i + 1) * foods[perm[i]].weight;\n            denominator += foods[perm[i]].weight;\n        }\n        return numerator / denominator;\n    }\n    \n    static boolean nextPermutation(int[] array) {\n        int i = array.length - 2;\n        while (i >= 0 && array[i] >= array[i + 1]) {\n            i--;\n        }\n        \n        if (i < 0) {\n            return false;\n        }\n        \n        int j = array.length - 1;\n        while (array[j] <= array[i]) {\n            j--;\n        }\n        \n        swap(array, i, j);\n        reverse(array, i + 1, array.length - 1);\n        return true;\n    }\n    \n    static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    \n    static void reverse(int[] array, int start, int end) {\n        while (start < end) {\n            swap(array, start, end);\n            start++;\n            end--;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static  Food(String name, int weight, int strength) { this.name = name; this.weight  } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; Food[] foods = new Food[n]; for (int i = 0; i < n; i++) {  weight = sc.nextInt(); int strength = sc.nextInt(); foods[i] = new Food(name, weight, strength); } int[] bestPerm = null; double minG   = 0; i < n; i++) { perm[i] = i; } do { if  = calculateG(foods, perm); if (g < minG) { minG = g; bestPerm = perm.clone(); } } } while (nextPermutation(perm)); for (int i = 0; i < n; i++) { System.out.println(foods[bestPerm[i]].name); } } sc.close(); } static boolean isValid(Food[] foods, int[] perm) {  (int i = 0; i <  = 0; for (int j = i + 1; j < n; j++) { weightAbove += foods[perm[j]].weight; } if (foods[perm[i]].strength   n = perm.length; double numerator = 0; double denominator = 0; for (int i = 0; i < n; i++) { numerator += (i + 1) * foods[perm[i]].weight; denominator += foods[perm[i]].weight; } return numerator / denominator; } static boolean nextPermutation(int[] array) { int i = array.length -  + 1]) { i--; } if (i < 0) { return  array.length - 1; while (array[j] <= array[i]) { j--; } swap(array,  return true; } static void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } static void reverse(int[] array, int  end--; } } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.List; import  name; int w; int s; public Food(String name, int w, int s) { this.name = name; this.w = w; this.s = s; } }  static void  } public void run() { Scanner scanner = new Scanner(System.in); while (true) { int n = scanner.nextInt(); int max = 0; List<Food> list  i = 0; i < n; i++) { String l = scanner.next(); int a  scanner.nextInt(); list.add(new Food(l,  } for (int i = 0; i < n; i++) { int l = 0; int  j  j++) { int m = max - list.get(j).w; int ss = list.get(j).s; if (m <= ss) { if (list.get(j).w > k)  = j; } } } max -= list.get(l).w;  = 0; } } } }"], "original_ll": -0.6728569865226746, "sampled_ll": -0.29792964458465576, "all_perturbed_sampled_ll": [-1.2813197374343872], "all_perturbed_original_ll": [-1.7780044078826904], "perturbed_sampled_ll": -1.2813197374343872, "perturbed_original_ll": -1.7780044078826904, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0170\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom collections import namedtuple\nfrom itertools import permutations\n\n\ndef solve(items):\n    total_weight = 0\n    for i in items:\n        total_weight += i.w\n\n    best_ans = []\n    best_gp = float('inf')\n    # ???????????????????????????????????????????????\u00b0?????????????????\u00a7????????????\n    for perm in permutations(items):\n        ans = []\n        squashed = False\n        cw = 0\n        gp = 0\n        n = len(items)\n\n        for p in perm:\n            if p.s < cw:\n                squashed = True\n                break\n            cw += p.w\n            ans.append(p.name)\n            gp += n * p.w\n            n -= 1\n        # ????????\u00b0???????????\u00a3?????\u00b4????????????????\u00a8???????????????????????????????????????\u00a3?????????????????\u00a7????????????\n        if not squashed:\n            gp /= total_weight\n            if gp < best_gp:\n                best_gp = gp\n                best_ans = ans[:]\n    # ????????????????????????????????\u00a3??????????????\u00a7?????????????\u00b1?????????????????????????????????????????????????\n    best_ans.reverse()\n    return best_ans\n\n\nitem = namedtuple('item', ['name', 'w', 's'])\ndef main(args):\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        items = []\n        for _ in range(n):\n            name, w, s = input().split()\n            items.append(item(name, int(w), int(s)))\n\n        result = solve(items)\n        print('\\n'.join(result))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])", "sampled": "from itertools import permutations\n\ndef is_valid(order, items):\n    # Check if the order is valid (no food is crushed)\n    # order is a list of indices\n    for i in range(len(order)):\n        weight_above = sum(items[order[j]][1] for j in range(i + 1, len(order)))\n        if items[order[i]][2] < weight_above:\n            return False\n    return True\n\ndef calculate_center_of_gravity(order, items):\n    # Calculate center of gravity\n    # Lower is better\n    numerator = sum((i + 1) * items[order[i]][1] for i in range(len(order)))\n    denominator = sum(items[order[i]][1] for i in range(len(order)))\n    return numerator / denominator\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    items = []\n    for _ in range(n):\n        parts = input().split()\n        name = parts[0]\n        weight = int(parts[1])\n        strength = int(parts[2])\n        items.append((name, weight, strength))\n    \n    best_order = None\n    best_cog = float('inf')\n    \n    # Try all permutations\n    for perm in permutations(range(n)):\n        if is_valid(perm, items):\n            cog = calculate_center_of_gravity(perm, items)\n            if cog < best_cog:\n                best_cog = cog\n                best_order = perm\n    \n    # Output the result\n    for idx in best_order:\n        print(items[idx][0])\n", "perturbed_sampled": ["from  items): # Check if the order is valid (no food is crushed) # order is a list of indices for i in range(len(order)): weight_above = sum(items[order[j]][1] for j in range(i + 1, len(order))) if items[order[i]][2] < weight_above: return False return True  center of gravity # Lower is better  * items[order[i]][1] for  sum(items[order[i]][1]  numerator / denominator while True: n = int(input()) if n == 0: break items = [] for _ in range(n): parts = input().split() name = parts[0] weight = int(parts[1]) strength = int(parts[2]) items.append((name, weight, strength)) best_order =  perm in permutations(range(n)): if is_valid(perm,  if cog < best_cog: best_cog = cog  the result for idx in best_order: print(items[idx][0])"], "perturbed_original": ["# -*- coding: utf-8 -*- \"\"\" http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0170 \"\"\" import sys from sys import stdin input =  from itertools import permutations def solve(items): total_weight = 0 for i in items: total_weight += i.w best_ans  in permutations(items): ans = [] squashed = False cw = 0  len(items) for  < cw: squashed = True break cw += p.w ans.append(p.name) gp += n  squashed: gp /= total_weight if gp  best_ans = ans[:] # ????????????????????????????????\u00a3??????????????\u00a7?????????????\u00b1????????????????????????????????????????????????? best_ans.reverse() return best_ans item = namedtuple('item', ['name', 'w', 's']) def main(args): while True: n = int(input()) if n == 0: break items = []  w, s = input().split() items.append(item(name, int(w), int(s))) result = solve(items) print('\\n'.join(result)) if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -1.0658231973648071, "sampled_ll": -0.8111487030982971, "all_perturbed_sampled_ll": [-2.1623923778533936], "all_perturbed_original_ll": [-2.0708022117614746], "perturbed_sampled_ll": -2.1623923778533936, "perturbed_original_ll": -2.0708022117614746, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void)\n{\n\tchar class[20];\n\tint i, am, pm;\n\t\n\tfor(i=0;i<9;i++)\n\t{\n\t\tscanf(\"%s %d %d\",class,&am,&pm);\n\t\tprintf(\"%s %d %d\\n\",class,am+pm,(200*am)+(300*pm));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    char name[16];\n    int morning, afternoon;\n    \n    for (int i = 0; i < 9; i++) {\n        scanf(\"%s %d %d\", name, &morning, &afternoon);\n        int total = morning + afternoon;\n        int revenue = morning * 200 + afternoon * 300;\n        printf(\"%s %d %d\\n\", name, total, revenue);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { char name[16]; int morning, afternoon; for (int i = 0;  &morning, &afternoon); int total = morning  morning * 200 + afternoon * 300; printf(\"%s %d %d\\n\", name, total, revenue); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { char class[20]; int i, am, pm; for(i=0;i<9;i++) { scanf(\"%s  } return 0; }"], "original_ll": -1.4504997730255127, "sampled_ll": -0.9735742807388306, "all_perturbed_sampled_ll": [-2.1108174324035645], "all_perturbed_original_ll": [-2.9682183265686035], "perturbed_sampled_ll": -2.1108174324035645, "perturbed_original_ll": -2.9682183265686035, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/**\n * @author yuichirw\n *\n */\nimport java.util.*;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\tint a,b,rel,sum;\n\t\tString c;\n\n\t\tfor(int i = 0; i < 9; i++) {\n\t\t\tc = sc.next(); a = sc.nextInt(); b = sc.nextInt();\n\t\t\tsum = a + b;\n\t\t\trel = a * 200 + b * 300;\n\t\t\tSystem.out.println(c + \" \" + sum + \" \" + rel);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        for (int i = 0; i < 9; i++) {\n            String name = sc.next();\n            int morning = sc.nextInt();\n            int afternoon = sc.nextInt();\n            \n            int totalVisitors = morning + afternoon;\n            int totalRevenue = morning * 200 + afternoon * 300;\n            \n            System.out.println(name + \" \" + totalVisitors + \" \" + totalRevenue);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); for (int i = 0; i < 9; i++) { String name  sc.nextInt(); int afternoon = sc.nextInt(); int   200  + \" \" + totalVisitors + \" \" + totalRevenue); } sc.close(); } }"], "perturbed_original": ["/** * @author yuichirw * */ import java.util.*; public  sc = new Scanner(System.in); public static void main(String[] args) { int a,b,rel,sum; String c;  < 9; i++) { c = sc.next(); a = sc.nextInt(); b = sc.nextInt(); sum = a  * 300; System.out.println(c + \" \" + sum + \" \" + rel); } } }"], "original_ll": -1.2364200353622437, "sampled_ll": -0.7104507684707642, "all_perturbed_sampled_ll": [-2.105128765106201], "all_perturbed_original_ll": [-2.1959123611450195], "perturbed_sampled_ll": -2.105128765106201, "perturbed_original_ll": -2.1959123611450195, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for i in range(9):\n    name,a,b=list(input().split())\n    print(name,int(a)+int(b),int(a)*200+int(b)*300)\n", "sampled": "for _ in range(9):\n    line = input().split()\n    name = line[0]\n    morning = int(line[1])\n    afternoon = int(line[2])\n    total = morning + afternoon\n    revenue = morning * 200 + afternoon * 300\n    print(name, total, revenue)\n", "perturbed_sampled": ["for _ in range(9):  line[0] morning = int(line[1]) afternoon = int(line[2]) total = morning + afternoon revenue = morning * 200 + afternoon * 300 print(name, total, revenue)"], "perturbed_original": ["for i in range(9): name,a,b=list(input().split()) print(name,int(a)+int(b),int(a)*200+int(b)*300)"], "original_ll": -2.0616767406463623, "sampled_ll": -1.0973564386367798, "all_perturbed_sampled_ll": [-1.9377245903015137], "all_perturbed_original_ll": [-2.4278290271759033], "perturbed_sampled_ll": -1.9377245903015137, "perturbed_original_ll": -2.4278290271759033, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(a,b,c){for(a=b=0,getchar();(c=getchar())!='0';)if(c-'\\n')c=='A'?a++:b++;else{printf(\"%d %d\\n\",a>b?a+1:a,a<b?b+1:b),a=b=0;if(getchar()=='0')break;}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char record[101];\n    \n    while(1) {\n        if(scanf(\"%s\", record) != 1) break;\n        if(strcmp(record, \"0\") == 0) break;\n        \n        int len = strlen(record);\n        int scoreA = 0, scoreB = 0;\n        char lastServer = record[0];\n        \n        for(int i = 0; i < len; i++) {\n            if(record[i] != lastServer) {\n                // Server changed, so the previous server lost the point\n                if(lastServer == 'A') {\n                    scoreB++;\n                } else {\n                    scoreA++;\n                }\n                lastServer = record[i];\n            } else {\n                // Server stayed same, so server won the point\n                if(lastServer == 'A') {\n                    scoreA++;\n                } else {\n                    scoreB++;\n                }\n            }\n            \n            // Check if game ended\n            if(scoreA >= 11 || scoreB >= 11) {\n                if(scoreA >= 11 && scoreB >= 11) {\n                    if(scoreA - scoreB >= 2 || scoreB - scoreA >= 2) {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", scoreA, scoreB);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char record[101]; while(1) { if(scanf(\"%s\", record) != 1) break;  int len =  scoreB = 0; char lastServer = record[0]; for(int i = 0; i < len; i++) { if(record[i] != lastServer) { // Server changed, so the previous server lost  { scoreB++; } else { scoreA++;  else  so server won the point if(lastServer == 'A') { scoreA++; } else { scoreB++;  game ended if(scoreA >= 11 || scoreB >= 11) { if(scoreA >= 11 && scoreB >= 11) { if(scoreA - scoreB >=  >= 2) { break; } } else {  %d\\n\", scoreA, scoreB); } return 0; }"], "perturbed_original": ["main(a,b,c){for(a=b=0,getchar();(c=getchar())!='0';)if(c-'\\n')c=='A'?a++:b++;else{printf(\"%d %d\\n\",a>b?a+1:a,a<b?b+1:b),a=b=0;if(getchar()=='0')break;}exit(0);}"], "original_ll": -2.0948312282562256, "sampled_ll": -0.7050204873085022, "all_perturbed_sampled_ll": [-1.75789475440979], "all_perturbed_original_ll": [-2.0948312282562256], "perturbed_sampled_ll": -1.75789475440979, "perturbed_original_ll": -2.0948312282562256, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main\n{\n    public static void main(String args[])\n    {\n\tScanner scan=new Scanner(System.in);\n\twhile(true)\n\t    {\n\t\tString str=scan.next();\n\t\tif(str.equals(\"0\"))break;\n\t\tint countA=0,countB=0;\n\t\tif(str.charAt(str.length()-1)=='A')\n\t\t    {\n\t\t\tcountA+=1;\n\t\t\t//countB-=1;\n\t\t    }\n\t\telse if(str.charAt(str.length()-1)=='B')\n\t\t    {\n\t\t    countB+=1;\n\t\t    //countA-=1;\n\t\t    }\n\t\tfor(int i=1;i<str.length();i++)\n\t\t    {\n\t\t\tif(str.charAt(i)=='A')countA+=1;\n\t\t\telse countB+=1;\n\t\t    }\n\t\tif(str.charAt(str.length()-1)=='B'&&(countB<countA))\n\t\t    {\n\t\t\tcountB-=1;\n\t\t\tcountA+=1;\n\t\t    }\n\t\telse if(str.charAt(str.length()-1)=='A'&&(countB>countA))\n\t\t    {\n\t\t\tcountA-=1;\n\t\t\tcountB+=1;\n\t\t    }\n\t\tSystem.out.println(countA+\" \"+countB);\n\t    }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String line = sc.nextLine();\n            if (line.equals(\"0\")) break;\n            \n            String game1 = line;\n            String game2 = sc.nextLine();\n            String game3 = sc.nextLine();\n            \n            System.out.println(processGame(game1));\n            System.out.println(processGame(game2));\n            System.out.println(processGame(game3));\n        }\n        \n        sc.close();\n    }\n    \n    static String processGame(String record) {\n        int scoreA = 0;\n        int scoreB = 0;\n        \n        for (int i = 0; i < record.length(); i++) {\n            char server = record.charAt(i);\n            \n            // The server who is recorded is the one who won the point\n            if (server == 'A') {\n                scoreA++;\n            } else {\n                scoreB++;\n            }\n            \n            // Check if game is over\n            if (scoreA >= 11 || scoreB >= 11) {\n                if (scoreA >= 10 && scoreB >= 10) {\n                    // Deuce situation - need 2 point difference\n                    if (Math.abs(scoreA - scoreB) >= 2) {\n                        break;\n                    }\n                } else {\n                    // Normal situation - first to 11\n                    if (scoreA >= 11 || scoreB >= 11) {\n                        break;\n                    }\n                }\n            }\n        }\n        \n        return scoreA + \" \" + scoreB;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc =  String line = sc.nextLine(); if (line.equals(\"0\")) break; String  = sc.nextLine(); String game3 = sc.nextLine(); System.out.println(processGame(game1)); System.out.println(processGame(game2)); System.out.println(processGame(game3)); }  record) { int scoreA = 0; int scoreB = 0; for (int i = 0; i < record.length(); i++) { char server = record.charAt(i); //  is the one who won the point if (server ==  { scoreB++; } // Check if game is over if (scoreA   10  // Deuce situation - need 2 point difference  2) { break; } } else { // Normal situation - first to 11 if (scoreA >= 11 ||  } } } } return scoreA + \" \" + scoreB; } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String args[]) { Scanner scan=new Scanner(System.in); while(true)  countA=0,countB=0; if(str.charAt(str.length()-1)=='A') { countA+=1; //countB-=1; } else  for(int i=1;i<str.length();i++)  if(str.charAt(str.length()-1)=='B'&&(countB<countA)) { countB-=1; countA+=1; } else if(str.charAt(str.length()-1)=='A'&&(countB>countA)) { countA-=1; countB+=1; } System.out.println(countA+\" \"+countB); } } }"], "original_ll": -0.6332377791404724, "sampled_ll": -0.7530702352523804, "all_perturbed_sampled_ll": [-2.086360216140747], "all_perturbed_original_ll": [-1.2759957313537598], "perturbed_sampled_ll": -2.086360216140747, "perturbed_original_ll": -1.2759957313537598, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    ten=input()\n    if ten=='0':\n        break\n    a=ten.count('A')\n    b=ten.count('B')\n    if ten[0]=='A':\n        a-=1\n    elif ten[0]=='B':\n        b-=1\n    if a>b:\n        a+=1\n    else:\n        b+=1\n    print(a,b)\n", "sampled": "import sys\n\ndef solve_game(record):\n    score_a = 0\n    score_b = 0\n    \n    i = 0\n    while i < len(record):\n        server = record[i]\n        \n        # Check if game is over\n        if score_a >= 11 or score_b >= 11:\n            if abs(score_a - score_b) >= 2:\n                break\n            elif score_a >= 11 and score_b >= 11:\n                if abs(score_a - score_b) >= 2:\n                    break\n        \n        # Determine who won the point\n        if i + 1 < len(record):\n            next_server = record[i + 1]\n            if next_server == server:\n                # Same server, so server won the point\n                if server == 'A':\n                    score_a += 1\n                else:\n                    score_b += 1\n            else:\n                # Different server, so server lost the point\n                if server == 'A':\n                    score_b += 1\n                else:\n                    score_a += 1\n        else:\n            # Last serve, determine winner based on current score\n            # The game must end after this serve\n            if score_a < 11 and score_b < 11:\n                # Someone needs to reach 11\n                if server == 'A':\n                    score_a += 1\n                else:\n                    score_b += 1\n            elif score_a >= 10 and score_b >= 10:\n                # In deuce, need 2 point difference\n                if server == 'A':\n                    if score_a == score_b or score_a == score_b + 1:\n                        score_a += 1\n                    else:\n                        score_b += 1\n                else:\n                    if score_b == score_a or score_b == score_a + 1:\n                        score_b += 1\n                    else:\n                        score_a += 1\n            else:\n                if server == 'A':\n                    score_a += 1\n                else:\n                    score_b += 1\n        \n        i += 1\n    \n    return score_a, score_b\n\nwhile True:\n    line = input().strip()\n    if line == \"0\":\n        break\n    \n    game1 = line\n    game2 = input().strip()\n    game3 = input().strip()\n    \n    score1 = solve_game(game1)\n    score2 = solve_game(game2)\n    score3 = solve_game(game3)\n    \n    print(f\"{score1[0]} {score1[1]}\")\n    print(f\"{score2[0]} {score2[1]}\")\n    print(f\"{score3[0]} {score3[1]}\")\n", "perturbed_sampled": ["import sys def solve_game(record): score_a = 0 score_b = 0 i = 0 while i < len(record): server = record[i] # Check if game is over if score_a >= 11 or score_b >= 11: if abs(score_a - score_b) >= 2: break elif score_a >=  if abs(score_a - score_b) >= 2: break # Determine who won the point if i + 1 < len(record): next_server = record[i + 1]   the point if server == 'A': score_a += 1 else: score_b += 1 else: # Different server, so server lost the point if server == 'A': score_b += 1 else: score_a  serve, determine winner based on current score # The game  and score_b < 11: # Someone  server ==  score_b += 1 elif score_a  10: # In deuce, need 2 point  if score_a == score_b or score_a == score_b + 1: score_a += 1 else: score_b += 1 else: if score_b == score_a or score_b == score_a + 1:  += 1 else: if server ==  += 1 return score_a, score_b while True: line = input().strip() if line == \"0\": break game1 = line game2 = input().strip() game3 = input().strip() score1 =  = solve_game(game3)  {score3[1]}\")"], "perturbed_original": ["while True:  b=ten.count('B') if ten[0]=='A': a-=1 elif ten[0]=='B': b-=1 if a>b: a+=1 else: b+=1 print(a,b)"], "original_ll": -1.0657331943511963, "sampled_ll": -0.6151260137557983, "all_perturbed_sampled_ll": [-1.8194903135299683], "all_perturbed_original_ll": [-2.556201219558716], "perturbed_sampled_ll": -1.8194903135299683, "perturbed_original_ll": -2.556201219558716, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\tint n,nbox[10000],temp,i,j,flg;\n\tscanf(\"%d\",&n);\n\twhile(n!=-1){\n\t\ttemp=0;\n\t\ti=0;\n\t\tflg=0;\n\t\twhile(n>=4){\n\t\t\tnbox[i]=n%4;\n\t\t\tn/=4;\n\t\t\ti++;\n\t\t}\n\t\tprintf(\"%d\",n);\n\t\tfor(j=i;j>=0;j--){\n\t\t\tif(flg==0){\n\t\t\t\tflg=1;\n\t\t\t}\n\t\t\telse if(flg==1){\n\t\t\t\tprintf(\"%d\",nbox[j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == -1) break;\n        \n        if(n == 0) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        char result[32];\n        int index = 0;\n        \n        while(n > 0) {\n            result[index++] = '0' + (n % 4);\n            n /= 4;\n        }\n        \n        for(int i = index - 1; i >= 0; i--) {\n            printf(\"%c\", result[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n;  == -1) break; if(n == 0) { printf(\"0\\n\"); continue; } char result[32]; int index = 0; while(n > 0) { result[index++] = '0' + (n % 4); n  = index - 1;  printf(\"%c\", result[i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int n,nbox[10000],temp,i,j,flg; scanf(\"%d\",&n); while(n!=-1){ temp=0; i=0; flg=0; while(n>=4){ nbox[i]=n%4; n/=4;  flg=1; } else if(flg==1){ printf(\"%d\",nbox[j]); } } printf(\"\\n\"); scanf(\"%d\",&n); } return 0; }"], "original_ll": -0.971454918384552, "sampled_ll": -0.5133338570594788, "all_perturbed_sampled_ll": [-1.644060730934143], "all_perturbed_original_ll": [-1.7234785556793213], "perturbed_sampled_ll": -1.644060730934143, "perturbed_original_ll": -1.7234785556793213, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n  public static void main (String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    while (scanner.hasNext()) {\n      int a = scanner.nextInt();\n      if (a < 0) {\n        break;\n      }\n      if (a == 0) {\n        System.out.println(0);\n        continue;\n      }\n      System.out.println(aaa(a));\n    }\n  }\n  public static String aaa (int a) {\n    if (a == 0) {\n      return \"\";\n    }\n    return aaa(a / 4) + a % 4;\n  }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == -1) break;\n            \n            if (n == 0) {\n                System.out.println(0);\n            } else {\n                StringBuilder result = new StringBuilder();\n                while (n > 0) {\n                    result.append(n % 4);\n                    n /= 4;\n                }\n                System.out.println(result.reverse().toString());\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new  n = sc.nextInt(); if (n == -1) break; if (n == 0) { System.out.println(0); } else { StringBuilder result = new StringBuilder();  /= 4; } System.out.println(result.reverse().toString()); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main { public static void main (String[] args) { Scanner scanner  {  (a < 0) { break; } if (a == 0) { System.out.println(0); continue; } System.out.println(aaa(a)); } }  a) { if (a == 0) { return \"\"; }  a % 4; } }"], "original_ll": -0.7473354935646057, "sampled_ll": -0.5158214569091797, "all_perturbed_sampled_ll": [-1.706957221031189], "all_perturbed_original_ll": [-2.24271297454834], "perturbed_sampled_ll": -1.706957221031189, "perturbed_original_ll": -2.24271297454834, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from operator import add\nb2q = {\"00\":\"0\",\"01\":\"1\",\"10\":\"2\",\"11\":\"3\"}\nwhile True:\n    n = input()\n    if n == -1:\n        break\n    s = format(n,\"b\")\n    if len(s) % 2 == 1:\n        s = \"0\" + s\n    print \"\".join(map(b2q.get,map(add,s[::2],s[1::2])))", "sampled": "while True:\n    n = int(input())\n    if n == -1:\n        break\n    \n    if n == 0:\n        print(0)\n    else:\n        result = \"\"\n        while n > 0:\n            result = str(n % 4) + result\n            n //= 4\n        print(result)\n", "perturbed_sampled": ["while True: n  -1: break if n == 0:  while n > 0: result = str(n % 4) + result n //= 4 print(result)"], "perturbed_original": ["from operator import add b2q = {\"00\":\"0\",\"01\":\"1\",\"10\":\"2\",\"11\":\"3\"} while True: n = input() if n == -1: break s  2 == 1: s = \"0\" + s print \"\".join(map(b2q.get,map(add,s[::2],s[1::2])))"], "original_ll": -1.2109355926513672, "sampled_ll": -0.8084076046943665, "all_perturbed_sampled_ll": [-2.7411985397338867], "all_perturbed_original_ll": [-2.003621816635132], "perturbed_sampled_ll": -2.7411985397338867, "perturbed_original_ll": -2.003621816635132, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,r,g,b,d,ans,best;\nchar col[8][15]={\"black\",\"blue\",\"lime\",\"aqua\",\"red\",\"fuchsia\",\"yellow\",\"white\"};\nchar code[24];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%s\",&code);\n\t\tif(code[0]=='0')break;\n\t\tsscanf(code,\"#%2x%2x%2x\",&r,&g,&b);\n\t\tbest=99999999;\n\t\tfor(i=0;i<8;i++){\n\t\t\td=(r-255*(i>3))*(r-255*(i>3))+(g-255*(i%4>1))*(g-255*(i%4>1))+(b-255*(i%2))*(b-255*(i%2));\n\t\t\tif(d<best){best=d;ans=i;}\n\t\t}\n\t\tprintf(\"%s\\n\",col[ans]);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char name[10];\n    int r, g, b;\n} Color;\n\nint main() {\n    Color colors[8] = {\n        {\"black\", 0x00, 0x00, 0x00},\n        {\"blue\", 0x00, 0x00, 0xff},\n        {\"lime\", 0x00, 0xff, 0x00},\n        {\"aqua\", 0x00, 0xff, 0xff},\n        {\"red\", 0xff, 0x00, 0x00},\n        {\"fuchsia\", 0xff, 0x00, 0xff},\n        {\"yellow\", 0xff, 0xff, 0x00},\n        {\"white\", 0xff, 0xff, 0xff}\n    };\n    \n    char input[10];\n    \n    while(1) {\n        scanf(\"%s\", input);\n        if(input[0] == '0') break;\n        \n        int r, g, b;\n        char rstr[3], gstr[3], bstr[3];\n        \n        rstr[0] = input[1];\n        rstr[1] = input[2];\n        rstr[2] = '\\0';\n        \n        gstr[0] = input[3];\n        gstr[1] = input[4];\n        gstr[2] = '\\0';\n        \n        bstr[0] = input[5];\n        bstr[1] = input[6];\n        bstr[2] = '\\0';\n        \n        r = strtol(rstr, NULL, 16);\n        g = strtol(gstr, NULL, 16);\n        b = strtol(bstr, NULL, 16);\n        \n        int minDist = -1;\n        int minIdx = 0;\n        \n        for(int i = 0; i < 8; i++) {\n            int dr = r - colors[i].r;\n            int dg = g - colors[i].g;\n            int db = b - colors[i].b;\n            int dist = dr*dr + dg*dg + db*db;\n            \n            if(minDist == -1 || dist < minDist) {\n                minDist = dist;\n                minIdx = i;\n            }\n        }\n        \n        printf(\"%s\\n\", colors[minIdx].name);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  typedef  r, g, b; } Color; int main() { Color colors[8] = { {\"black\", 0x00, 0x00, 0x00},  0x00, 0xff, 0x00}, {\"aqua\", 0x00,  0xff}, {\"yellow\", 0xff,  0xff} }; char input[10]; while(1) { scanf(\"%s\", input); if(input[0] == '0') break; int r, g, b; char rstr[3], gstr[3], bstr[3]; rstr[0] = input[1]; rstr[1] = input[2]; rstr[2] = '\\0'; gstr[0]  gstr[2] = '\\0'; bstr[0] = input[5]; bstr[1] = input[6]; bstr[2] = '\\0'; r = strtol(rstr, NULL, 16); g = strtol(gstr, NULL, 16); b = strtol(bstr, NULL, 16);  i = 0; i < 8; i++) { int dr = r - colors[i].r; int dg = g  b - colors[i].b; int dist = dr*dr + dg*dg + db*db; if(minDist == -1 || dist < minDist) { minDist = dist; minIdx = i; } } printf(\"%s\\n\", colors[minIdx].name); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <stdlib.h>  code[24]; int main(){ while(1){ scanf(\"%s\",&code); if(code[0]=='0')break; sscanf(code,\"#%2x%2x%2x\",&r,&g,&b); best=99999999; for(i=0;i<8;i++){ d=(r-255*(i>3))*(r-255*(i>3))+(g-255*(i%4>1))*(g-255*(i%4>1))+(b-255*(i%2))*(b-255*(i%2)); if(d<best){best=d;ans=i;} } printf(\"%s\\n\",col[ans]); } return 0; }"], "original_ll": -0.9573379158973694, "sampled_ll": -0.32129162549972534, "all_perturbed_sampled_ll": [-0.898741602897644], "all_perturbed_original_ll": [-1.2992078065872192], "perturbed_sampled_ll": -0.898741602897644, "perturbed_original_ll": -1.2992078065872192, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nimport java.util.HashMap;\nimport java.util.Arrays;\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[\\n#]+\");\n\t\twhile (true)\n\t\t{\n\t\t\tString str = sc.next();\n\t\t\tif (str.equals(\"0\")) break;\n\t\t\tint rk = Integer.parseInt(str.substring(0, 2), 16);\n\t\t\tint gk = Integer.parseInt(str.substring(2, 4), 16);\n\t\t\tint bk = Integer.parseInt(str.substring(4, 6), 16);\n\t\t\tint d[] = new int[8];\n\t\t\tHashMap<Integer, String> map = new HashMap<Integer, String>();\n\t\t\td[0] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[0], \"black\");\n\t\t\td[1] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[1], \"blue\");\n\t\t\td[2] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[2], \"lime\");\n\t\t\td[3] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[3], \"aqua\");\n\t\t\td[4] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[4], \"red\");\n\t\t\td[5] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[5], \"fuchsia\");\n\t\t\td[6] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[6], \"yellow\");\n\t\t\td[7] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[7], \"white\");\n\t\t\tArrays.sort(d);\n\t\t\tSystem.out.println(map.get(d[0]));\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        String[] colorNames = {\"black\", \"blue\", \"lime\", \"aqua\", \"red\", \"fuchsia\", \"yellow\", \"white\"};\n        int[][] colorValues = {\n            {0x00, 0x00, 0x00},  // black\n            {0x00, 0x00, 0xff},  // blue\n            {0x00, 0xff, 0x00},  // lime\n            {0x00, 0xff, 0xff},  // aqua\n            {0xff, 0x00, 0x00},  // red\n            {0xff, 0x00, 0xff},  // fuchsia\n            {0xff, 0xff, 0x00},  // yellow\n            {0xff, 0xff, 0xff}   // white\n        };\n        \n        while (true) {\n            String input = sc.next();\n            if (input.equals(\"0\")) {\n                break;\n            }\n            \n            // Parse color code\n            String colorCode = input.substring(1); // Remove '#'\n            int r = Integer.parseInt(colorCode.substring(0, 2), 16);\n            int g = Integer.parseInt(colorCode.substring(2, 4), 16);\n            int b = Integer.parseInt(colorCode.substring(4, 6), 16);\n            \n            // Find closest color\n            int minDistance = Integer.MAX_VALUE;\n            String closestColor = \"\";\n            \n            for (int i = 0; i < colorNames.length; i++) {\n                int rk = colorValues[i][0];\n                int gk = colorValues[i][1];\n                int bk = colorValues[i][2];\n                \n                int distance = (r - rk) * (r - rk) + (g - gk) * (g - gk) + (b - bk) * (b - bk);\n                \n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestColor = colorNames[i];\n                }\n            }\n            \n            System.out.println(closestColor);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] colorNames = {\"black\", \"blue\", \"lime\", \"aqua\", \"red\", \"fuchsia\", \"yellow\", \"white\"}; int[][] colorValues = { {0x00, 0x00, 0x00}, // black {0x00, 0x00, 0xff}, // blue {0x00, 0xff,   {0xff, 0xff, 0x00}, // yellow {0xff, 0xff, 0xff}  { String input = sc.next(); if (input.equals(\"0\")) { break; } // Parse color code String colorCode = input.substring(1); //  Integer.parseInt(colorCode.substring(0, 2), 16);  16); int b = Integer.parseInt(colorCode.substring(4, 6), 16); //  = Integer.MAX_VALUE; String closestColor  = 0; i < colorNames.length; i++) { int rk = colorValues[i][0]; int gk = colorValues[i][1]; int bk = colorValues[i][2]; int distance = (r - rk) * (r - rk) + (g - gk) *  - bk) * (b - bk); if (distance < minDistance) { minDistance = distance; closestColor = colorNames[i]; } } System.out.println(closestColor); } sc.close(); } }"], "perturbed_original": ["import  class Main { public static void main(String args[]) { Scanner sc = new Scanner(System.in).useDelimiter(\"[\\n#]+\"); while (true) { String str = sc.next(); if (str.equals(\"0\")) break; int rk = Integer.parseInt(str.substring(0, 2), 16);  16); int bk = Integer.parseInt(str.substring(4, 6), 16); int  String>  d[0] = (0x00 - rk) * (0x00 - rk)   - bk) * (0x00 - bk);  - rk) + (0x00 - gk) * (0x00  bk) * (0xff - bk); map.put(d[1], \"blue\"); d[2] = (0x00 - rk) * (0x00 - rk) +  - gk) + (0x00 - bk) * (0x00 - bk); map.put(d[2],  rk) * (0x00 - rk) + (0xff - gk) * (0xff - gk) + (0xff - bk) * (0xff - bk);  - rk) + (0x00 - gk) * (0x00 - gk) + (0x00  bk); map.put(d[4], \"red\"); d[5] = (0xff - rk) * (0xff - rk) + (0x00 - gk) * (0x00 - gk) + (0xff - bk) * (0xff - bk); map.put(d[5], \"fuchsia\"); d[6] = (0xff - rk) * (0xff - rk)  (0xff - gk) + (0x00 - bk) * (0x00 - bk); map.put(d[6], \"yellow\"); d[7] = (0xff - rk) * (0xff - rk) + (0xff - gk) * (0xff  bk) * (0xff - bk); map.put(d[7], \"white\"); Arrays.sort(d); System.out.println(map.get(d[0])); } } }"], "original_ll": -0.302490234375, "sampled_ll": -0.32647931575775146, "all_perturbed_sampled_ll": [-1.2372959852218628], "all_perturbed_original_ll": [-1.0189014673233032], "perturbed_sampled_ll": -1.2372959852218628, "perturbed_original_ll": -1.0189014673233032, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nL=[\n(\"black\",00,00,00),\n(\"blue\",00,00,255),\n(\"lime\",00,255,00),\n(\"aqua\",00,255,255),\n(\"red\",255,00,00),\n(\"fuchsia\",255,00,255),\n(\"yellow\",255,255,00),\n(\"white\",255,255,255)]\nwhile True:\n    c=raw_input()\n    if c==\"0\":break\n    Rk,Gk,Bk=int(c[1:3],16),int(c[3:5],16),int(c[5:7],16)\n    m=10000\n    for cl,r,g,b in L:\n        t=math.sqrt(pow(r-Rk,2)+pow(g-Gk,2)+pow(b-Bk,2))\n        if t<m:\n            m=t\n            color=cl\n    print color", "sampled": "import sys\n\ncolors = [\n    (\"black\", 0x00, 0x00, 0x00),\n    (\"blue\", 0x00, 0x00, 0xff),\n    (\"lime\", 0x00, 0xff, 0x00),\n    (\"aqua\", 0x00, 0xff, 0xff),\n    (\"red\", 0xff, 0x00, 0x00),\n    (\"fuchsia\", 0xff, 0x00, 0xff),\n    (\"yellow\", 0xff, 0xff, 0x00),\n    (\"white\", 0xff, 0xff, 0xff)\n]\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line == \"0\":\n        break\n    \n    # Parse color code\n    color_code = line[1:]  # Remove #\n    R = int(color_code[0:2], 16)\n    G = int(color_code[2:4], 16)\n    B = int(color_code[4:6], 16)\n    \n    # Find closest color\n    min_distance = float('inf')\n    closest_color = \"\"\n    \n    for name, Rk, Gk, Bk in colors:\n        dk = (R - Rk) ** 2 + (G - Gk) ** 2 + (B - Bk) ** 2\n        if dk < min_distance:\n            min_distance = dk\n            closest_color = name\n    \n    print(closest_color)\n", "perturbed_sampled": ["import sys colors = [ (\"black\", 0x00, 0x00, 0x00), (\"blue\", 0x00, 0x00,  (\"aqua\", 0x00, 0xff, 0xff), (\"red\", 0xff, 0x00, 0x00), (\"fuchsia\", 0xff, 0x00, 0xff),   = line.strip() if line == \"0\": break # Parse color code color_code = line[1:] # Remove # R = int(color_code[0:2], 16) G = int(color_code[2:4], 16) B  closest color min_distance = float('inf') closest_color = \"\" for name, Rk, Gk, Bk  - Rk) ** 2 + (G - Gk) ** 2 + (B - Bk) ** 2 if dk  closest_color = name print(closest_color)"], "perturbed_original": ["import math L=[ (\"black\",00,00,00), (\"blue\",00,00,255), (\"lime\",00,255,00), (\"aqua\",00,255,255), (\"red\",255,00,00), (\"fuchsia\",255,00,255), (\"yellow\",255,255,00), (\"white\",255,255,255)] while : if<extra_id_1>) break<extra_id_2>m = 50 for c<extra_id_3>( ) ) m=10000 for cl,r,g,b in L: t=math.sqrt(pow(r-Rk,2)+pow(g-Gk,2)+pow(b-Bk,2)) if t<m: m=t color=cl print color"], "original_ll": -0.8049091100692749, "sampled_ll": -0.45110130310058594, "all_perturbed_sampled_ll": [-1.5717555284500122], "all_perturbed_original_ll": [-1.6562026739120483], "perturbed_sampled_ll": -1.5717555284500122, "perturbed_original_ll": -1.6562026739120483, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n#define PI 3.141592653589793\n#define r 6378.1\nint main(void) {\n\twhile(1){\n\t\tdouble a,b,c,d;\n\t\tscanf(\"%lf %lf %lf %lf\\n\",&a,&b,&c,&d);\n\t\tif(a==(-1)&&b==(-1)&&c==(-1)&&d==(-1)) break;\n\t\tdouble a1,b1,c1,d1;\n\t\ta1=a*PI/180.0;\n\t\tb1=b*PI/180.0;\n\t\tc1=c*PI/180.0;\n\t\td1=d*PI/180.0;\n\t\tdouble e1,f;\n\t\te1=d1-b1;\n\t\tf=r*acos((sin(a1)*sin(c1))+(cos(a1)*cos(c1)*cos(e1)));\n\t\tprintf(\"%.0f\\n\",f);\n\t}\n\treturn 0;\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159265358979323846\n#define RADIUS 6378.1\n\nint main() {\n    double a, b, c, d;\n    \n    while (1) {\n        scanf(\"%lf %lf %lf %lf\", &a, &b, &c, &d);\n        \n        if (a == -1 && b == -1 && c == -1 && d == -1) {\n            break;\n        }\n        \n        double lat1 = a * PI / 180.0;\n        double lon1 = b * PI / 180.0;\n        double lat2 = c * PI / 180.0;\n        double lon2 = d * PI / 180.0;\n        \n        double x1 = RADIUS * cos(lat1) * cos(lon1);\n        double y1 = RADIUS * cos(lat1) * sin(lon1);\n        double z1 = RADIUS * sin(lat1);\n        \n        double x2 = RADIUS * cos(lat2) * cos(lon2);\n        double y2 = RADIUS * cos(lat2) * sin(lon2);\n        double z2 = RADIUS * sin(lat2);\n        \n        double chord = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1));\n        \n        double angle = 2.0 * asin(chord / (2.0 * RADIUS));\n        \n        double distance = RADIUS * angle;\n        \n        int result = (int)(distance + 0.5);\n        \n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #define PI 3.14159265358979323846 #define RADIUS 6378.1 int main() { double a, b, c, d; while (1) { scanf(\"%lf %lf %lf %lf\", &a, &b, &c, &d); if (a == -1 && b == -1 && c == -1 && d == -1)  / 180.0; double lon1 = b * PI / 180.0; double lat2 = c * PI / 180.0; double lon2 = d *  = RADIUS * cos(lat1) * cos(lon1); double y1 =  double  double x2 = RADIUS * cos(lat2) * cos(lon2); double y2  sin(lon2); double z2 = RADIUS * sin(lat2); double  + (z2-z1)*(z2-z1)); double angle  (2.0 * RADIUS)); double distance = RADIUS * angle;  0.5); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h>  6378.1 int main(void) { while(1){ double a,b,c,d; scanf(\"%lf %lf %lf %lf\\n\",&a,&b,&c,&d); if(a==(-1)&&b==(-1)&&c==(-1)&&d==(-1)) break; double a1,b1,c1,d1; a1=a*PI/180.0; b1=b*PI/180.0;  f=r*acos((sin(a1)*sin(c1))+(cos(a1)*cos(c1)*cos(e1))); printf(\"%.0f\\n\",f); } return 0; }"], "original_ll": -0.6682618856430054, "sampled_ll": -0.34773340821266174, "all_perturbed_sampled_ll": [-1.3283792734146118], "all_perturbed_original_ll": [-1.2906955480575562], "perturbed_sampled_ll": -1.3283792734146118, "perturbed_original_ll": -1.2906955480575562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tdouble c = sc.nextDouble();\n\t\t\tdouble d = sc.nextDouble();\n\t\t\tif((a==-1)&&(b==-1)&&(c==-1)&&(d==-1)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdouble vz = Math.sin(Math.toRadians(a));\n\t\t\tdouble vx = Math.cos(Math.toRadians(a))*Math.cos(Math.toRadians(b));\n\t\t\tdouble vy = Math.cos(Math.toRadians(a))*Math.sin(Math.toRadians(b));\n\n\t\t\tdouble wz = Math.sin(Math.toRadians(c));\n\t\t\tdouble wx = Math.cos(Math.toRadians(c))*Math.cos(Math.toRadians(d));\n\t\t\tdouble wy = Math.cos(Math.toRadians(c))*Math.sin(Math.toRadians(d));\n\n\t\t\tdouble dot = vz*wz + vx*wx + vy * wy;\n\t\t\tdouble theta = Math.acos(dot);\n\t\t\tdouble R =6378.1;\n\t\t\tSystem.out.println((int)(R*theta+0.5));\n\t\t}\n\t\t\n\t}\n\tpublic static void main(String[] args){\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            double a = sc.nextDouble();\n            double b = sc.nextDouble();\n            double c = sc.nextDouble();\n            double d = sc.nextDouble();\n            \n            if (a == -1 && b == -1 && c == -1 && d == -1) {\n                break;\n            }\n            \n            double lat1 = Math.toRadians(a);\n            double lon1 = Math.toRadians(b);\n            double lat2 = Math.toRadians(c);\n            double lon2 = Math.toRadians(d);\n            \n            double radius = 6378.1;\n            \n            double centralAngle = Math.acos(\n                Math.sin(lat1) * Math.sin(lat2) + \n                Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1)\n            );\n            \n            double distance = radius * centralAngle;\n            \n            long result = Math.round(distance);\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { public static void main(String[] args) { Scanner sc  { double a  sc.nextDouble(); double c = sc.nextDouble(); double d = sc.nextDouble(); if (a == -1 && b == -1 && c == -1 && d == -1) { break; } double lat1 = Math.toRadians(a); double lon1 =  double centralAngle = Math.acos( Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1) ); double distance = radius * centralAngle; long result = Math.round(distance); System.out.println(result); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.lang.*; import java.math.*; public class Main { Scanner sc = new Scanner(System.in); void run(){ for(;;){ double a  sc.nextDouble(); double c = sc.nextDouble(); double d = sc.nextDouble(); if((a==-1)&&(b==-1)&&(c==-1)&&(d==-1)){ break; } double vz = Math.sin(Math.toRadians(a));  vy = Math.cos(Math.toRadians(a))*Math.sin(Math.toRadians(b)); double wz = Math.sin(Math.toRadians(c));  wy = Math.cos(Math.toRadians(c))*Math.sin(Math.toRadians(d)); double dot = vz*wz + vx*wx + vy * wy;  R =6378.1; System.out.println((int)(R*theta+0.5)); } } public static void main(String[] args){  m.run(); } }"], "original_ll": -0.8178650736808777, "sampled_ll": -0.46055564284324646, "all_perturbed_sampled_ll": [-1.2588143348693848], "all_perturbed_original_ll": [-1.6398332118988037], "perturbed_sampled_ll": -1.2588143348693848, "perturbed_original_ll": -1.6398332118988037, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from math import acos,sin,cos,radians\nwhile 1:\n    a,b,c,d=map(float,input().split())\n    if a==b==c==d==-1:break\n    a,c=radians(a),radians(c)\n    print(int(6378.1*acos(sin(a)*sin(c) + cos(a)*cos(c)*cos(radians(d)-radians(b)))+0.5))", "sampled": "import math\n\nR = 6378.1\n\nwhile True:\n    line = input().split()\n    a, b, c, d = map(float, line)\n    \n    if a == -1 and b == -1 and c == -1 and d == -1:\n        break\n    \n    # Convert degrees to radians\n    lat1 = math.radians(a)\n    lon1 = math.radians(b)\n    lat2 = math.radians(c)\n    lon2 = math.radians(d)\n    \n    # Calculate great circle distance using spherical law of cosines\n    # or using haversine formula for better numerical stability\n    \n    # Using spherical law of cosines:\n    # d = R * arccos(sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2)*cos(lon2-lon1))\n    \n    cos_angle = math.sin(lat1) * math.sin(lat2) + math.cos(lat1) * math.cos(lat2) * math.cos(lon2 - lon1)\n    \n    # Clamp to [-1, 1] to avoid numerical errors\n    cos_angle = max(-1, min(1, cos_angle))\n    \n    angle = math.acos(cos_angle)\n    distance = R * angle\n    \n    print(round(distance))\n", "perturbed_sampled": ["import math R = 6378.1 while True:  line) if a == -1 and b == -1 and c == -1 and d == -1: break  = math.radians(b)  law of cosines # or using haversine formula for better numerical stability # Using spherical law of cosines: # d = R * arccos(sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2)*cos(lon2-lon1)) cos_angle = math.sin(lat1) * math.sin(lat2) + math.cos(lat1) * math.cos(lat2) * math.cos(lon2 - lon1) # Clamp to [-1, 1] to avoid numerical errors cos_angle = max(-1, min(1, cos_angle)) angle = math.acos(cos_angle) distance = R * angle print(round(distance))"], "perturbed_original": ["from math import acos,sin,cos,radians while 1: a,b,c,d=map(float,input().split()) if a==b==c==d==-1:break a,c=radians(a),radians(c) print(int(6378.1*acos(sin(a)*sin(c) + cos(a)*cos(c)*cos(radians(d)-radians(b)))+0.5))"], "original_ll": -1.4473483562469482, "sampled_ll": -0.7234416604042053, "all_perturbed_sampled_ll": [-1.4341763257980347], "all_perturbed_original_ll": [-1.6759307384490967], "perturbed_sampled_ll": -1.4341763257980347, "perturbed_original_ll": -1.6759307384490967, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,d,p,q,m[9999],h;main(b){for(;~scanf(\"%d\",&n),n;d&&printf(\"%d\\n\",p)){for(memset(m,d=0,39996);n--;){scanf(\"%d%d%d\",&d,&p,&q);b=(d-2?~-(1<<p):1)<<q;for(h=9998;~h&&!(m[h]&b);h--)d-2?p=1:0;for(h++;p--;m[h]-62?h++:memmove(m+h,m+h+1,9998-h))m[h]|=b;}for(p=0,h=9999;h--;)for(b=m[h];q=-b&b;b-=q)p++;}}", "sampled": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_HEIGHT 10000\n#define WIDTH 5\n\nint grid[MAX_HEIGHT][WIDTH];\n\nint getHeight(int col) {\n    int h = 0;\n    for (int i = 0; i < MAX_HEIGHT; i++) {\n        if (grid[i][col] == 1) {\n            h = i + 1;\n        }\n    }\n    return h;\n}\n\nvoid dropBlock(int d, int p, int q) {\n    q--; // Convert to 0-indexed\n    \n    if (d == 1) { // Horizontal\n        // Find the highest point where the block can land\n        int maxHeight = 0;\n        for (int i = 0; i < p; i++) {\n            int h = getHeight(q + i);\n            if (h > maxHeight) {\n                maxHeight = h;\n            }\n        }\n        // Place the block\n        for (int i = 0; i < p; i++) {\n            grid[maxHeight][q + i] = 1;\n        }\n    } else { // Vertical (d == 2)\n        int h = getHeight(q);\n        // Place the block\n        for (int i = 0; i < p; i++) {\n            grid[h + i][q] = 1;\n        }\n    }\n}\n\nvoid removeFullRows() {\n    int removed = 0;\n    for (int row = 0; row < MAX_HEIGHT; row++) {\n        int full = 1;\n        for (int col = 0; col < WIDTH; col++) {\n            if (grid[row][col] == 0) {\n                full = 0;\n                break;\n            }\n        }\n        if (full) {\n            // Mark row for removal\n            for (int col = 0; col < WIDTH; col++) {\n                grid[row][col] = 0;\n            }\n            // Shift everything above down\n            for (int r = row; r < MAX_HEIGHT - 1; r++) {\n                for (int col = 0; col < WIDTH; col++) {\n                    grid[r][col] = grid[r + 1][col];\n                }\n            }\n            for (int col = 0; col < WIDTH; col++) {\n                grid[MAX_HEIGHT - 1][col] = 0;\n            }\n            row--; // Check this row again\n        }\n    }\n}\n\nint countBlocks() {\n    int count = 0;\n    for (int i = 0; i < MAX_HEIGHT; i++) {\n        for (int j = 0; j < WIDTH; j++) {\n            if (grid[i][j] == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        // Clear the grid\n        memset(grid, 0, sizeof(grid));\n        \n        for (int i = 0; i < n; i++) {\n            int d, p, q;\n            scanf(\"%d %d %d\", &d, &p, &q);\n            dropBlock(d, p, q);\n            removeFullRows();\n        }\n        \n        printf(\"%d\\n\", countBlocks());\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #define  int grid[MAX_HEIGHT][WIDTH]; int getHeight(int col) { int  i = 0; i < MAX_HEIGHT; i++) { if (grid[i][col] == 1) { h = i + 1; } } return h; } void dropBlock(int d, int  // Convert to 0-indexed if (d == 1) {  highest point where the block can land int maxHeight = 0; for (int i = 0; i < p; i++) { int h = getHeight(q + i); if (h > maxHeight) { maxHeight = h; } } // Place the block for (int i = 0; i < p; i++) { grid[maxHeight][q + i] = 1; } } else { // Vertical  =  for (int i = 0; i < p; i++) { grid[h + i][q] = 1; } } } void removeFullRows() {  (int row = 0; row < MAX_HEIGHT; row++) { int full = 1; for (int col = 0;  if (grid[row][col] == 0) { full  if (full)  removal for (int col  col++) { grid[row][col] = 0; } // Shift everything above down for (int r = row;  col  grid[r + 1][col]; } } for  < WIDTH; col++) { grid[MAX_HEIGHT - 1][col] = 0; } row--; // Check this row   0; for (int i = 0; i < MAX_HEIGHT; i++) {  j < WIDTH; j++) { if (grid[i][j] == 1) { count++;  } int main() { int n;  { // Clear the grid memset(grid, 0, sizeof(grid)); for (int i = 0; i < n; i++) { int d, p, q; scanf(\"%d %d %d\", &d, &p, &q); dropBlock(d, p, q); removeFullRows(); } printf(\"%d\\n\", countBlocks()); } return 0; }"], "perturbed_original": ["n,d,p,q,m[9999],h;main(b){for(;~scanf(\"%d\",&n),n;d&&printf(\"%d\\n\",p)){for(memset(m,d=0,39996);n--;){scanf(\"%d%d%d\",&d,&p,&q);b=(d-2?~-(1<<p):1)<<q;for(h=9998;~h&&!(m[h]&b);h--)d-2?p=1:0;for(h++;p--;m[h]-62?h++:memmove(m+h,m+h+1,9998-h))m[h]|=b;}for(p=0,h=9999;h--;)for(b=m[h];q=-b&b;b-=q)p++;}}"], "original_ll": -2.433109760284424, "sampled_ll": -0.4530812203884125, "all_perturbed_sampled_ll": [-1.455413579940796], "all_perturbed_original_ll": [-2.433109760284424], "perturbed_sampled_ll": -1.455413579940796, "perturbed_original_ll": -2.433109760284424, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n//TETORIS\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tboolean[][] m = new boolean[5000][5];\n\t\t\twhile(n--!=0){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt()-1;\n\t\t\t\tif(d==2){\n\t\t\t\t\tint k = 4999;\n\t\t\t\t\twhile(k>=0&&!m[k][q])k--;\n\t\t\t\t\tk++;\n\t\t\t\t\tfor(int i=k;i<k+p;i++)m[i][q]=true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint k = 4999;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tif(k>=0){\n\t\t\t\t\t\t\tfor(int j=q;j<q+p;j++){\n\t\t\t\t\t\t\t\tif(m[k][j])f = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f||k==-1){\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\tfor(int j=q;j<q+p;j++)m[k][j]=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean con = true;\n\t\t\t\tint k = 0;\n\t\t\t\twhile(k<5000&&con){\n\t\t\t\t\tcon = false;\n\t\t\t\t\tboolean t = true;\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tif(m[k][j])con = true;\n\t\t\t\t\t\telse t = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(t){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tint i = k;\n\t\t\t\t\t\twhile(i<5000&&f){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\t\tif(m[i][j])f = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\t\t\tm[i][j] = m[i+1][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse k++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint s = 0;\n\t\t\tfor(int i=0;i<5000;i++)for(int j=0;j<5;j++)s+=m[i][j]?1:0;\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[][] board = new int[10000][5];\n            int maxHeight = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt() - 1;\n                \n                if (d == 1) {\n                    int dropHeight = 0;\n                    for (int col = q; col < q + p; col++) {\n                        for (int row = 0; row < 10000; row++) {\n                            if (board[row][col] == 1) {\n                                dropHeight = Math.max(dropHeight, row + 1);\n                                break;\n                            }\n                        }\n                    }\n                    \n                    for (int col = q; col < q + p; col++) {\n                        board[dropHeight][col] = 1;\n                    }\n                    maxHeight = Math.max(maxHeight, dropHeight + 1);\n                } else {\n                    int dropHeight = 0;\n                    for (int row = 0; row < 10000; row++) {\n                        if (board[row][q] == 1) {\n                            dropHeight = row + 1;\n                            break;\n                        }\n                    }\n                    \n                    for (int row = dropHeight; row < dropHeight + p; row++) {\n                        board[row][q] = 1;\n                    }\n                    maxHeight = Math.max(maxHeight, dropHeight + p);\n                }\n                \n                boolean cleared = true;\n                while (cleared) {\n                    cleared = false;\n                    for (int row = 0; row < maxHeight; row++) {\n                        boolean full = true;\n                        for (int col = 0; col < 5; col++) {\n                            if (board[row][col] == 0) {\n                                full = false;\n                                break;\n                            }\n                        }\n                        \n                        if (full) {\n                            cleared = true;\n                            for (int r = row; r < maxHeight - 1; r++) {\n                                for (int col = 0; col < 5; col++) {\n                                    board[r][col] = board[r + 1][col];\n                                }\n                            }\n                            for (int col = 0; col < 5; col++) {\n                                board[maxHeight - 1][col] = 0;\n                            }\n                            maxHeight--;\n                            break;\n                        }\n                    }\n                }\n            }\n            \n            int count = 0;\n            for (int row = 0; row < maxHeight; row++) {\n                for (int col = 0; col < 5; col++) {\n                    if (board[row][col] == 1) {\n                        count++;\n                    }\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public  Scanner sc =  int n = sc.nextInt();  int[][] board = new int[10000][5]; int  i = 0; i < n; i++) { int d = sc.nextInt(); int p  sc.nextInt() - 1; if (d == 1) { int dropHeight = 0; for (int col  + p; col++) { for (int row  row++) { if (board[row][col] ==  row +  for (int col = q; col < q + p; col++) { board[dropHeight][col] = 1; } maxHeight = Math.max(maxHeight, dropHeight + 1); } else { int dropHeight = 0; for (int row = 0; row < 10000; row++) { if (board[row][q] == 1) { dropHeight =  = dropHeight; row < dropHeight + p; row++) { board[row][q] =  dropHeight + p); } boolean cleared = true; while (cleared) { cleared = false; for (int row = 0; row < maxHeight; row++) { boolean full =  0; col < 5; col++) { if (board[row][col] == 0) { full = false; break; } }   row;  r++) { for (int col = 0; col < 5;  + 1][col]; } } for (int col = 0; col < 5; col++) { board[maxHeight - 1][col] = 0; } maxHeight--; break; } } } } int count = 0; for (int row = 0; row < maxHeight; row++) { for (int col = 0; col < 5;  1) {  } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; //TETORIS public class Main { public static void   n = sc.nextInt(); if(n==0)break; boolean[][] m = new boolean[5000][5]; while(n--!=0){ int d = sc.nextInt(); int p = sc.nextInt(); int q = sc.nextInt()-1;  while(k>=0&&!m[k][q])k--; k++; for(int i=k;i<k+p;i++)m[i][q]=true; } else{ int  for(int j=q;j<q+p;j++){ if(m[k][j])f =  for(int j=q;j<q+p;j++)m[k][j]=true; break; } k--; } } boolean con = true; int k = 0; while(k<5000&&con){ con = false; boolean t = true; for(int j=0;j<5;j++){ if(m[k][j])con = true; else t =  = true; int i = k; while(i<5000&&f){ f = false; for(int j=0;j<5;j++){ if(m[i][j])f = true; } if(f){ for(int j=0;j<5;j++){ m[i][j] = m[i+1][j]; } } i++; } } else  j=0;j<5;j++)s+=m[i][j]?1:0; System.out.println(s); } } }"], "original_ll": -0.6547034382820129, "sampled_ll": -0.35905274748802185, "all_perturbed_sampled_ll": [-1.4459551572799683], "all_perturbed_original_ll": [-1.4537243843078613], "perturbed_sampled_ll": -1.4459551572799683, "perturbed_original_ll": -1.4537243843078613, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#!/usr/local/bin/python\nfrom itertools import islice\n\ndef init():\n    return [[None] * 5] * 5000\n\nN = 4\n\nwhile True:\n    #N = int(input())\n    if N == 0:\n        break\n    d, l, pos = [int(n) for n in raw_input().split()]\n    lst = init()\n    flwr = 0\n    for i in xrange(N):\n        print d, l, pos\n        # if d == 1:\n        #     for i in xrange(l):\n        #         lst[flwr][pos-1 + i] = 1\n        # else:\n        #     tmp = 0\n        #     for i in xrange(l):\n        #         lst[flwr + tmp][pos-1] = 1\n        #         tmp += 1\n        #print lst[flwr]\n        #print not None in lst[flwr]\n        if not None in lst[flwr]:\n            flwr += 1\n    ret = 0\n    for i in xrange(flwr):\n        ret += len([i for i in lst[i] if not None])\n    #print ret\n    N -= 1\n    break", "sampled": "def solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        # Board: 5 columns, use a list to store heights at each column\n        # We'll use a grid representation where grid[row][col] tells if there's a block\n        grid = []  # Will grow as needed, grid[0] is bottom\n        \n        for _ in range(n):\n            d, p, q = map(int, input().split())\n            q -= 1  # Convert to 0-indexed\n            \n            if d == 1:  # Horizontal block\n                # Find the maximum height among columns q to q+p-1\n                max_height = 0\n                for col in range(q, q + p):\n                    # Find height of column col\n                    h = 0\n                    for row in range(len(grid)):\n                        if grid[row][col]:\n                            h = row + 1\n                    max_height = max(max_height, h)\n                \n                # Place block at row max_height\n                while len(grid) <= max_height:\n                    grid.append([False] * 5)\n                \n                for col in range(q, q + p):\n                    grid[max_height][col] = True\n                    \n            else:  # Vertical block (d == 2)\n                # Find height of column q\n                height = 0\n                for row in range(len(grid)):\n                    if grid[row][q]:\n                        height = row + 1\n                \n                # Place block from row height to height+p-1\n                while len(grid) < height + p:\n                    grid.append([False] * 5)\n                \n                for row in range(height, height + p):\n                    grid[row][q] = True\n            \n            # Check for complete rows and remove them\n            rows_to_remove = []\n            for row_idx in range(len(grid)):\n                if all(grid[row_idx]):\n                    rows_to_remove.append(row_idx)\n            \n            # Remove complete rows (from top to bottom to maintain indices)\n            for row_idx in reversed(rows_to_remove):\n                grid.pop(row_idx)\n        \n        # Count remaining blocks\n        count = 0\n        for row in grid:\n            count += sum(row)\n        \n        print(count)\n\nsolve()\n", "perturbed_sampled": ["def solve(): while True: n = int(input()) if n == 0: break # Board: 5 columns, use a list to store heights at each column  representation where grid[row][col] tells  = [] # Will grow as needed, grid[0] is bottom for _ in range(n): d, p, q = map(int, input().split()) q -= 1 # Convert to 0-indexed if d == 1: # Horizontal block #  columns q to q+p-1 max_height = 0 for col in range(q, q + p): # Find height of column col  in range(len(grid)): if grid[row][col]: h = row + 1 max_height = max(max_height, h) # Place block at row max_height while len(grid) <= max_height: grid.append([False] * 5) for  p): grid[max_height][col] =  (d == 2) # Find height of column q height = 0 for row in range(len(grid)): if grid[row][q]: height = row + 1 # Place  height+p-1 while len(grid) <  5) for row in range(height,  them rows_to_remove = [] for row_idx  # Remove complete rows (from top  for row_idx  remaining blocks count = 0 for row in grid: count += sum(row) print(count) solve()"], "perturbed_original": ["#!/usr/local/bin/python from itertools import islice def init(): return [[None] * 5] <extra_id_1>lst[flwr+tmp][pos-1] = 0 # print<extra_id_2>for i in xrange(d): #<extra_id_3>] #<extra_id_4>) i<extra_id_5>for i<extra_id_6>islice(i, l): # for j<extra_id_7>: # print<extra_id_8>( [i for<extra_id_9>else: for<extra_id_10>i in<extra_id_11>1 if list(tmp))<extra_id_12>i in<extra_id_13>[i]<extra_id_14>- 1<extra_id_15>in lst[flwr]<extra_id_16>(i while True: #N = int(input()) if N == 0: break d, l, pos = [int(n) for n in raw_input().split()] lst = init() flwr = 0 for i in xrange(N): print d, l, pos # if d == 1: # for i   xrange(l): # lst[flwr + tmp][pos-1] = 1 # tmp +=  None in lst[flwr]  flwr += 1 ret = 0 for i in xrange(flwr): ret += len([i for i in lst[i] if not None]) #print ret N -= 1 break"], "original_ll": -1.2951571941375732, "sampled_ll": -0.9075080752372742, "all_perturbed_sampled_ll": [-2.462592363357544], "all_perturbed_original_ll": [-2.136169672012329], "perturbed_sampled_ll": -2.462592363357544, "perturbed_original_ll": -2.136169672012329, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\nchar chk[MAX+10];\nint Q[MAX+10], *top, *end, *qmax = Q + MAX;\nint N, K, mask;\n\nint nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b, step;\n\tint i, k;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) | k;\n\t\t}\n\t\tmask = (1 << N) - 1, r = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;\n\t\ttop = end = Q;\n\t\t*end++ = s, *end++ = -1, chk[s] = 1, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = *top; if (++top >= qmax) top = Q;\n\t\t\tif (s < 0) { step++, *end = -1; if (++end >= qmax) end = Q; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); break; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2, k2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n\t\t\t\tif (!chk[s2]) { chk[s2] = 1, *end = s2; if (++end >= qmax) end = Q; }\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LEN 11\n#define MAX_QUEUE 100000\n\ntypedef struct {\n    char state[MAX_LEN];\n    int steps;\n} QueueItem;\n\ntypedef struct {\n    char state[MAX_LEN];\n} HashItem;\n\nHashItem visited[MAX_QUEUE];\nint visited_count;\n\nint hash_string(char* s) {\n    int h = 0;\n    for (int i = 0; s[i]; i++) {\n        h = h * 31 + s[i];\n    }\n    return abs(h) % MAX_QUEUE;\n}\n\nint is_visited(char* s) {\n    for (int i = 0; i < visited_count; i++) {\n        if (strcmp(visited[i].state, s) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add_visited(char* s) {\n    strcpy(visited[visited_count].state, s);\n    visited_count++;\n}\n\nint is_uniform(char* s) {\n    char first = s[0];\n    for (int i = 1; s[i]; i++) {\n        if (s[i] != first) return 0;\n    }\n    return 1;\n}\n\nchar get_third_color(char a, char b) {\n    if ((a == 'r' && b == 'g') || (a == 'g' && b == 'r')) return 'b';\n    if ((a == 'r' && b == 'b') || (a == 'b' && b == 'r')) return 'g';\n    if ((a == 'g' && b == 'b') || (a == 'b' && b == 'g')) return 'r';\n    return a;\n}\n\nint solve(char* initial) {\n    if (is_uniform(initial)) return 0;\n    \n    QueueItem queue[MAX_QUEUE];\n    int front = 0, rear = 0;\n    \n    visited_count = 0;\n    strcpy(queue[rear].state, initial);\n    queue[rear].steps = 0;\n    rear++;\n    add_visited(initial);\n    \n    while (front < rear) {\n        QueueItem current = queue[front++];\n        \n        int len = strlen(current.state);\n        \n        for (int i = 0; i < len - 1; i++) {\n            if (current.state[i] != current.state[i+1]) {\n                char new_state[MAX_LEN];\n                strcpy(new_state, current.state);\n                \n                char new_color = get_third_color(current.state[i], current.state[i+1]);\n                new_state[i] = new_color;\n                new_state[i+1] = new_color;\n                \n                if (is_uniform(new_state)) {\n                    return current.steps + 1;\n                }\n                \n                if (!is_visited(new_state) && rear < MAX_QUEUE) {\n                    strcpy(queue[rear].state, new_state);\n                    queue[rear].steps = current.steps + 1;\n                    rear++;\n                    add_visited(new_state);\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    char input[MAX_LEN];\n    \n    while (1) {\n        scanf(\"%s\", input);\n        if (strcmp(input, \"0\") == 0) break;\n        \n        int result = solve(input);\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  #define MAX_LEN 11 #define MAX_QUEUE 100000  int steps; } QueueItem; typedef struct { char state[MAX_LEN]; }  int hash_string(char* s) {  (int i  h = h * 31 + s[i]; } return abs(h) % MAX_QUEUE; } int is_visited(char* s)  0; i < visited_count; i++) { if (strcmp(visited[i].state, s) == 0)  return 0; } void add_visited(char* s) {   = s[0]; for (int i  if (s[i] !=  1; } char get_third_color(char a, char b) { if ((a == 'r' && b == 'g') || (a == 'g' && b == 'r')) return 'b'; if ((a == 'r' && b == 'b') || (a == 'b' && b == 'r')) return 'g'; if ((a == 'g' && b == 'b') ||  == 'g')) return 'r'; return a; } int solve(char* initial) { if (is_uniform(initial)) return 0; QueueItem queue[MAX_QUEUE]; int  0; visited_count = 0; strcpy(queue[rear].state, initial); queue[rear].steps = 0; rear++; add_visited(initial);  QueueItem current = queue[front++]; int len = strlen(current.state); for (int i = 0; i <  if (current.state[i] != current.state[i+1]) { char new_state[MAX_LEN]; strcpy(new_state, current.state); char new_color = get_third_color(current.state[i], current.state[i+1]);   current.steps + 1; } if (!is_visited(new_state) && rear < MAX_QUEUE) { strcpy(queue[rear].state, new_state); queue[rear].steps = current.steps + 1; rear++; add_visited(new_state); } } } } return -1; }  while (1) { scanf(\"%s\", input); if (strcmp(input, \"0\") == 0) break; int result = solve(input); if (result == -1) { printf(\"NA\\n\"); } else { printf(\"%d\\n\",  }"], "perturbed_original": ["// Aizu Vol-1 0179: Mysterious Worm // 2017.8.22  #define MAX 0xaaaaa char chk[MAX+10]; int  Q + MAX; int N, K, mask; int  5, 0, 10, 5, 0, 0, 5, 0, 10 }; int main() { int s, r, g, b, step; int i, k; char buf[15], *bp; while (1) { scanf(\"%s\", buf); if (buf[0] == '0') break; memset(chk, 0, sizeof(chk)); for (N = s = 0, bp = buf; *bp; bp++, N +=  'r') k = 0; else if (*bp == 'g') k = 1; else k =  2) | k; } mask = (1 << N) - 1, r = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;  *end++ = s, *end++ = -1, chk[s] = 1, step = 0, K  end) { s = *top; if (++top >= qmax) top = Q; if (s < 0) { step++, *end = -1; if (++end >=  }  s == g || s == b) { printf(\"%d\\n\", step); break; } for (i  i += 2) { int s2, k2; k = (s >> i) & 0xf;   i)) | (k2 << i); if (!chk[s2]) { chk[s2] = 1,   (top >= end) puts(\"NA\"); } return 0; }"], "original_ll": -1.208731770515442, "sampled_ll": -0.44065582752227783, "all_perturbed_sampled_ll": [-1.3250138759613037], "all_perturbed_original_ll": [-2.0759170055389404], "perturbed_sampled_ll": -1.3250138759613037, "perturbed_original_ll": -2.0759170055389404, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Point2D;\nimport java.util.*;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\n\t\tnew AOJ0179();\n\n\n\t}\n\n\tclass AOJ0179{\n\t\tpublic AOJ0179() {\n\t\t\twhile(true){\n\t\t\t\tString warm = in.next();\n\t\t\t\tif(warm.equals(\"0\"))break;\n\t\t\t\tint ans = get_warm(warm);\n\t\t\t\tSystem.out.println(ans==-1? \"NA\":ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint get_warm(String input){\n\t\t\tQueue<String> warm = new LinkedList<String>();\n\t\t\tQueue<Integer> cnt = new LinkedList<Integer>();\n\t\t\tHashMap<String, Boolean> memo = new HashMap<String, Boolean>();\n\t\t\tmemo.put(input,true);\n\t\t\twarm.add(input);\n\t\t\tcnt.add(0);\n\t\t\twhile(warm.size()>0){\n\t\t\t\tString a = warm.remove();\n\t\t\t\tint step = cnt.remove();\n//\t\t\t\tSystem.out.println(a+\" \"+step);//deba\n\t\t\t\tboolean sw = true;\n\t\t\t\tfor(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1))sw=false;\n\t\t\t\tif(sw)return step;\n\t\t\t\t//\u3053\u3053\u304b\u3089\n\t\t\t\tfor(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1)){\n\t\t\t\t\tString b = a.substring(0,i)+getColor(a.charAt(i),a.charAt(i+1))+a.substring(i+2,a.length());\n\t\t\t\t\tif(memo.containsKey(b))continue;\n\t\t\t\t\twarm.add(b);\n\t\t\t\t\tcnt.add(step+1);\n\t\t\t\t\tmemo.put(b, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tString getColor(char a, char b){\n\t\t\tif(a=='r'&&b=='b'||a=='b'&&b=='r')return \"gg\";\n\t\t\telse if(a=='r'&&b=='g'||a=='g'&&b=='r')return \"bb\";\n\t\t\telse return \"rr\";\n\t\t}\n\t\t\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class State {\n        String config;\n        int steps;\n        \n        State(String config, int steps) {\n            this.config = config;\n            this.steps = steps;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String input = sc.next();\n            if (input.equals(\"0\")) break;\n            \n            int result = solve(input);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        sc.close();\n    }\n    \n    static int solve(String initial) {\n        if (isUniform(initial)) {\n            return 0;\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        queue.offer(new State(initial, 0));\n        visited.add(initial);\n        \n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            String config = current.config;\n            int steps = current.steps;\n            \n            // Find all adjacent pairs with different colors\n            for (int i = 0; i < config.length() - 1; i++) {\n                if (config.charAt(i) != config.charAt(i + 1)) {\n                    // Change this pair to the third color\n                    char newColor = getThirdColor(config.charAt(i), config.charAt(i + 1));\n                    String newConfig = config.substring(0, i) + newColor + newColor + config.substring(i + 2);\n                    \n                    if (isUniform(newConfig)) {\n                        return steps + 1;\n                    }\n                    \n                    if (!visited.contains(newConfig)) {\n                        visited.add(newConfig);\n                        queue.offer(new State(newConfig, steps + 1));\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static boolean isUniform(String s) {\n        if (s.length() == 0) return true;\n        char first = s.charAt(0);\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) != first) return false;\n        }\n        return true;\n    }\n    \n    static char getThirdColor(char c1, char c2) {\n        if ((c1 == 'r' && c2 == 'g') || (c1 == 'g' && c2 == 'r')) return 'b';\n        if ((c1 == 'r' && c2 == 'b') || (c1 == 'b' && c2 == 'r')) return 'g';\n        if ((c1 == 'g' && c2 == 'b') || (c1 == 'b' && c2 == 'g')) return 'r';\n        return c1; // Should not happen\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class State { String  { Scanner sc = new Scanner(System.in); while (true) { String input = sc.next(); if  solve(input); if (result == -1) { System.out.println(\"NA\"); } else { System.out.println(result); } } sc.close(); } static int solve(String initial)  0; } Queue<State> queue = new LinkedList<>(); Set<String> visited = new HashSet<>(); queue.offer(new State(initial,  State current = queue.poll(); String config = current.config; int steps =  pairs with different colors for (int i = 0; i < config.length() - 1; i++) { if (config.charAt(i) != config.charAt(i + 1)) { // Change this pair to the third color char  config.substring(0, i) + newColor + newColor + config.substring(i + 2); if (isUniform(newConfig)) { return steps + 1; } if (!visited.contains(newConfig)) { visited.add(newConfig); queue.offer(new State(newConfig, steps + 1)); } } } } return -1; } static boolean isUniform(String s) { if (s.length() == 0) return true; char first = s.charAt(0); for (int i = 1; i  (s.charAt(i) != first) return false; }  getThirdColor(char c1, char c2) { if ((c1 == 'r' && c2 == 'g') || (c1 == 'g' && c2 == 'r')) return 'b'; if ((c1 == 'r'  (c1 == 'b' && c2 == 'r')) return 'g'; if ((c1 ==  ||  == 'g'))  Should not happen } }"], "perturbed_original": ["import java.awt.geom.Point2D; import java.util.*; public class Main { Scanner in = new Scanner(System.in); public static void main(String[] args) { new Main(); }  } class AOJ0179{ public AOJ0179() { while(true){ String warm = in.next(); if(warm.equals(\"0\"))break;  get_warm(String input){  LinkedList<Integer>(); HashMap<String, Boolean> memo = new HashMap<String, Boolean>(); memo.put(input,true); warm.add(input); cnt.add(0); while(warm.size()>0){ String a = warm.remove(); int step = cnt.remove(); //  true; for(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1))sw=false; if(sw)return step;  = a.substring(0,i)+getColor(a.charAt(i),a.charAt(i+1))+a.substring(i+2,a.length()); if(memo.containsKey(b))continue; warm.add(b); cnt.add(step+1); memo.put(b, true); } } return -1; } String getColor(char a, char b){ if(a=='r'&&b=='b'||a=='b'&&b=='r')return \"gg\"; else if(a=='r'&&b=='g'||a=='g'&&b=='r')return \"bb\"; else return \"rr\"; } } }"], "original_ll": -0.9211252927780151, "sampled_ll": -0.383126825094223, "all_perturbed_sampled_ll": [-1.4200410842895508], "all_perturbed_original_ll": [-1.552857518196106], "perturbed_sampled_ll": -1.4200410842895508, "perturbed_original_ll": -1.552857518196106, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import deque\nused = [0]*(3**10)\n\n\nwhile True:\n\ts = raw_input()\n\tif s==\"0\":\n\t\tbreak\n\tn=len(s)\n\tt=0\n\tfor i in range(len(s)):\n\t\tt*=3\n\t\tif s[i]==\"r\":\n\t\t\tt+=0\n\t\tif s[i]==\"g\":\n\t\t\tt+=1\n\t\tif s[i]==\"b\":\n\t\t\tt+=2\n\tf=0\n\tfor i in range(3**n):\n\t\tused[i]=0\n\ttq=[t]\n\tq=deque(tq)\n\tused[t]=1\n\tans=-1\n\tcnt=0\n\twhile len(q)>0:\n\t\tqs=len(q)\n\t\tfor o in range(qs):\n\t\t\ttop=q.popleft()\n\t\t\tv=[0]\n\t\t\tv.pop()\n\t\t\tfor i in range(n):\n\t\t\t\tv.append(top%3)\n\t\t\t\ttop/=3\n\t\t\tok=1\n\t\t\ta=v[0]\n\t\t\tfor i in range(n):\n\t\t\t\tif v[i]!=a:\n\t\t\t\t\tok=0\n\t\t\tif ok==1:\n\t\t\t\tf=1\n\t\t\t\tans=cnt\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif v[i]!=v[i+1]:\n\t\t\t\t\tt1=v[i]\n\t\t\t\t\tt2=v[i+1]\n\t\t\t\t\tv[i]=3-t1-t2\n\t\t\t\t\tv[i+1]=3-t1-t2\n\t\t\t\t\ttmp=0\n\t\t\t\t\tfor j in range(n):\n\t\t\t\t\t\ttmp*=3\n\t\t\t\t\t\ttmp+=v[j]\n\t\t\t\t\tif used[tmp]==0:\n\t\t\t\t\t\tq.append(tmp)\n\t\t\t\t\t\tused[tmp]=1\n\t\t\t\t\tv[i]=t1\n\t\t\t\t\tv[i+1]=t2\n\t\tif f==1:\n\t\t\tbreak\n\t\telse:\n\t\t\tcnt+=1\n\tif ans==-1:\n\t\tprint \"NA\"\n\telse:\n\t\tprint ans", "sampled": "from collections import deque\n\ndef get_other_color(c1, c2):\n    colors = {'r', 'g', 'b'}\n    return list(colors - {c1, c2})[0]\n\ndef get_neighbors(state):\n    neighbors = []\n    for i in range(len(state) - 1):\n        if state[i] != state[i + 1]:\n            new_state = list(state)\n            new_color = get_other_color(state[i], state[i + 1])\n            new_state[i] = new_color\n            new_state[i + 1] = new_color\n            neighbors.append(''.join(new_state))\n    return neighbors\n\ndef solve(state):\n    if len(set(state)) == 1:\n        return 0\n    \n    visited = {state}\n    queue = deque([(state, 0)])\n    \n    while queue:\n        current, steps = queue.popleft()\n        \n        for neighbor in get_neighbors(current):\n            if len(set(neighbor)) == 1:\n                return steps + 1\n            \n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, steps + 1))\n    \n    return \"NA\"\n\nwhile True:\n    line = input().strip()\n    if line == \"0\":\n        break\n    print(solve(line))\n", "perturbed_sampled": [" get_other_color(c1, c2): colors = {'r', 'g', 'b'} return list(colors - {c1, c2})[0] def get_neighbors(state): neighbors = [] for i in range(len(state) - 1):  new_color  neighbors.append(''.join(new_state)) return neighbors def solve(state): if len(set(state)) == 1: return 0 visited = {state} queue = deque([(state, 0)]) while queue: current, steps = queue.popleft() for neighbor in get_neighbors(current): if len(set(neighbor)) == 1: return steps + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, steps + 1)) return \"NA\" while True: line = input().strip() if line == \"0\": break print(solve(line))"], "perturbed_original": [" = [0]*(3**10) while True: s = raw_input() if s==\"0\": break n=len(s) t=0 for i in range(len(s)): t*=3 if s[i]==\"r\": t+=0 if s[i]==\"g\": t+=1 if s[i]==\"b\": t+=2 f=0 for i in range(3**n): used[i]=0 tq=[t] q=deque(tq) used[t]=1 ans=-1 cnt=0 while len(q)>0:  top=q.popleft() v=[0] v.pop()  top/=3 ok=1 a=v[0] for  ok=0 if ok==1: f=1 ans=cnt break for i in range(n-1): if v[i]!=v[i+1]: t1=v[i] t2=v[i+1] v[i]=3-t1-t2 v[i+1]=3-t1-t2 tmp=0 for j in range(n): tmp*=3  v[i]=t1 v[i+1]=t2 if f==1:  print \"NA\" else: print ans"], "original_ll": -0.9062351584434509, "sampled_ll": -0.6443706750869751, "all_perturbed_sampled_ll": [-1.2439172267913818], "all_perturbed_original_ll": [-1.7138639688491821], "perturbed_sampled_ll": -1.2439172267913818, "perturbed_original_ll": -1.7138639688491821, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0180: Demolition of Bridges\n// 2017.8.9\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x77777777\n#define MAX 100\n#define EMAX 500\nint n;\ntypedef struct { int b, c; } ND;\nND d[MAX + 2][MAX + 2];\nint w[MAX + 2];\nint visited[MAX];\n\nint qsize;\ntypedef struct { int a, b, c; } QUE;\nQUE que[EMAX + 1];\n\n#define PARENT(i) ((i)/2)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nstatic void min_heapify(int i)\n{\n\tint l, r, smallest;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].c < que[i].c) smallest = l; else smallest = i;\n\tif (r < qsize && que[r].c < que[smallest].c) smallest = r;\n\tif (smallest != i) {\n\t\tQUE t;\n\t\tmemcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + smallest, sizeof(QUE));\n\t\tmemcpy(que + smallest, &t, sizeof(QUE));\n\t\tmin_heapify(smallest);\n\t}\n}\n\nint deq(QUE *q)\n{\n\tif (qsize == 0) return -1;\n\tmemcpy(q, &que[0], sizeof(QUE));\n\tmemcpy(que, que + --qsize, sizeof(QUE));\n\tmin_heapify(0);\n\treturn 1;\n}\n\nvoid enq(QUE *q)\n{\n\tint i;\n\n\ti = qsize++;\n\tmemcpy(que + i, q, sizeof(QUE));\n\twhile (i > 0 && que[PARENT(i)].c > que[i].c) {\n\t\tQUE t;\n\t\tmemcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + PARENT(i), sizeof(QUE));\n\t\tmemcpy(que + PARENT(i), &t, sizeof(QUE));\n\t\ti = PARENT(i);\n\t}\n}\n\n\nint main()\n{\n\tint m, a, b, c;\n\tint i, k, ans;\n\tQUE q;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &n, &m); if (!n) return 0;\n\t\tmemset(w, 0, sizeof(w));\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\td[a][w[a]].b = b, d[a][w[a]++].c = c;\n\t\t\td[b][w[b]].b = a, d[b][w[b]++].c = c;\n\t\t}\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tans = 0, visited[0] = 1, k = 1, qsize = 0;\n\t\tfor (i = 0; i < w[0]; i++) q.a = 0, q.b = d[0][i].b, q.c = d[0][i].c, enq(&q);\n\t\twhile (k < n) {\n\t\t\tdo deq(&q);\n\t\t\twhile (visited[q.a] && visited[q.b]);\n\t\t\tk++;\n\t\t\ta = visited[q.a] ? q.b : q.a;\n\t\t\tvisited[a] = 1, ans += q.c;\n\t\t\tfor (i = 0; i < w[a]; i++) {\n\t\t\t\tb = d[a][i].b;\n\t\t\t\tif (!visited[b]) q.a = a, q.b = b, q.c = d[a][i].c, enq(&q);\n\t\t\t}\n\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int a, b, cost;\n} Edge;\n\nint parent[100];\n\nint find(int x) {\n    if (parent[x] == x) return x;\n    return parent[x] = find(parent[x]);\n}\n\nint unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return 0;\n    parent[x] = y;\n    return 1;\n}\n\nint compare(const void *a, const void *b) {\n    Edge *ea = (Edge *)a;\n    Edge *eb = (Edge *)b;\n    return ea->cost - eb->cost;\n}\n\nint main() {\n    int n, m;\n    \n    while (1) {\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0) break;\n        \n        Edge edges[500];\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &edges[i].a, &edges[i].b, &edges[i].cost);\n        }\n        \n        qsort(edges, m, sizeof(Edge), compare);\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        int total = 0;\n        int count = 0;\n        \n        for (int i = 0; i < m; i++) {\n            if (unite(edges[i].a, edges[i].b)) {\n                total += edges[i].cost;\n                count++;\n                if (count == n - 1) break;\n            }\n        }\n        \n        printf(\"%d\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  a, b, cost; } Edge; int parent[100]; int find(int x) { if (parent[x] == x) return x; return parent[x] = find(parent[x]); } int unite(int x, int y) { x = find(x); y = find(y); if (x == y) return  1; } int compare(const void *a, const void *b)  *)a; Edge *eb = (Edge *)b; return ea->cost - eb->cost; } int main() { int n, m; while (1) { scanf(\"%d %d\", &n, &m);  Edge edges[500]; for (int i = 0; i < m; i++) { scanf(\"%d %d %d\",  m, sizeof(Edge), compare); for (int  total = 0; int count = 0; for (int i = 0; i < m; i++) { if (unite(edges[i].a, edges[i].b)) { total += edges[i].cost; count++; if (count  } } printf(\"%d\\n\", total); } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0180: Demolition of Bridges // 2017.8.9 #include <stdio.h> #include <stdlib.h> #include <string.h> #define INF 0x77777777 #define MAX 100 #define  struct { int b, c; } ND;  2]; int w[MAX  qsize; typedef struct { int a, b, c;  1]; #define PARENT(i) ((i)/2) #define LEFT(i) ((i)<<1) #define RIGHT(i) (((i)<<1)+1) static void min_heapify(int i) { int l, r, smallest;  RIGHT(i); if (l < qsize && que[l].c < que[i].c) smallest = l; else smallest = i; if (r < qsize && que[r].c < que[smallest].c)   sizeof(QUE)), memcpy(que + i, que + smallest,  sizeof(QUE)); min_heapify(smallest); } } int deq(QUE *q) { if (qsize == 0) return -1; memcpy(q, &que[0], sizeof(QUE)); memcpy(que, que + --qsize, sizeof(QUE)); min_heapify(0); return 1; } void enq(QUE *q) { int i; i = qsize++; memcpy(que + i, q, sizeof(QUE)); while (i   que + i, sizeof(QUE)), memcpy(que + i, que + PARENT(i),  sizeof(QUE)); i = PARENT(i); } } int  k, ans; QUE q; while (1) { scanf(\"%d%d\", &n, &m); if (!n) return 0; memset(w, 0,  i < m;  &c); d[a][w[a]].b = b, d[a][w[a]++].c = c; d[b][w[b]].b = a, d[b][w[b]++].c =  ans =  =  (i = 0; i < w[0]; i++) q.a = 0, q.b = d[0][i].b, q.c = d[0][i].c, enq(&q); while (k < n) { do deq(&q); while (visited[q.a] && visited[q.b]);  q.b : q.a; visited[a] = 1, ans += q.c; for (i = 0; i < w[a]; i++) { b = d[a][i].b;  q.b = b, q.c = d[a][i].c, enq(&q); } } printf(\"%d\\n\", ans); } return 0; }"], "original_ll": -0.6967298984527588, "sampled_ll": -0.27706044912338257, "all_perturbed_sampled_ll": [-1.2036852836608887], "all_perturbed_original_ll": [-1.4117376804351807], "perturbed_sampled_ll": -1.2036852836608887, "perturbed_original_ll": -1.4117376804351807, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tstatic int n, m;\n\tstatic int[][] node;\n\n\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\n\t}\n\n\tstatic boolean read(){\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tif(n == 0 && m == 0)  return false;\n\n\t\tnode = new int[n][n];  //\u008b\u0097\u0097\u00a3\u008ds\u0097\u00f1\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(i==j) node[i][j] = 0;\n\t\t\t\telse     node[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint node1 = sc.nextInt();\n\t\t\tint node2 = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\n\t\t\tnode[node1][node2] = cost;\n\t\t\tnode[node2][node1] = cost;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\t//\u0083v\u0083\u008a\u0083\u0080\u0096@\n\tstatic void solve(){\n\t\tint sum =0;\n\t\tHashSet<Integer> X = new HashSet<Integer>();  //\u008c\u0088\u0092\u00e8\u008d\u00cf\u0082\u00dd\u008fW\u008d\u0087\n\t\tHashSet<Integer> Y = new HashSet<Integer>();  //\u0096\u00a2\u008c\u0088\u0092\u00e8\u008fW\u008d\u0087\n\n\t\t//\u008fW\u008d\u0087\u0082\u00cc\u008f\u0089\u008a\u00fa\u0089\u00bb\n\t\tX.add(0);\n\t\tfor(int i=1; i<n; i++){\n\t\t\tY.add(i);\n\t\t}\n\n\t\t//\u0096\u00a2\u008c\u0088\u0092\u00e8\u0082\u00cc\u008fW\u008d\u0087\u0082\u00aa\u008b\u00f3\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00dc\u0082\u00c5\n\t\twhile(!Y.isEmpty()){\n\n\t\t\t//\u008d\u00c5\u008f\u00ac\u0083R\u0083X\u0083g\u0082\u00cc\u0097\u00d7\u0090\u00da\u0083m\u0081[\u0083h\u0082\u00f0\u0092\u00b2\u0082\u00d7\u0082\u00e9\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint min_num = -1, min_num2 = -1;\n\n\t\t\tfor(Iterator<Integer> i1 = X.iterator(); i1.hasNext();){\n\t\t\t\tint n1 = i1.next();\n\t\t\t\tfor (Iterator<Integer> i2 = Y.iterator(); i2.hasNext();){\n\t\t\t\t\tint n2 = i2.next();\n\t\t\t\t\tif(node[n1][n2] == -1)  continue;\n\n\t\t\t\t\tif(min > node[n1][n2]){\n\t\t\t\t\t\tmin = node[n1][n2];\n\t\t\t\t\t\tmin_num = n1;\n\t\t\t\t\t\tmin_num2 = n2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsum += node[min_num][min_num2];\n\t\t\tY.remove(min_num2);\n\t\t\tX.add(min_num2);\n\t\t}\n\n\t\tSystem.out.println(sum);  //\u008fo\u0097\u00cd\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge implements Comparable<Edge> {\n        int u, v, cost;\n        \n        Edge(int u, int v, int cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(Edge other) {\n            return this.cost - other.cost;\n        }\n    }\n    \n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) {\n                return false;\n            }\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            \n            return true;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) {\n                break;\n            }\n            \n            List<Edge> edges = new ArrayList<>();\n            \n            for (int i = 0; i < m; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int cost = sc.nextInt();\n                edges.add(new Edge(a, b, cost));\n            }\n            \n            Collections.sort(edges);\n            \n            UnionFind uf = new UnionFind(n);\n            int totalCost = 0;\n            int edgeCount = 0;\n            \n            for (Edge edge : edges) {\n                if (uf.union(edge.u, edge.v)) {\n                    totalCost += edge.cost;\n                    edgeCount++;\n                    if (edgeCount == n - 1) {\n                        break;\n                    }\n                }\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static  int u, v, cost; Edge(int u, int v, int cost) { this.u = u; this.v = v; this.cost = cost; } @Override public int compareTo(Edge other) { return this.cost - other.cost; } } static class UnionFind { int[] parent; int[] rank; UnionFind(int n) { parent = new  0; i < n; i++)  = 0; } } int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return  rootY = find(y); if (rootX ==  if (rank[rootX] < rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] > rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; } return true; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); int m = sc.nextInt(); if (n == 0 && m == 0)  = new ArrayList<>(); for (int i = 0; i < m; i++) { int  = sc.nextInt(); int cost = sc.nextInt();  Collections.sort(edges); UnionFind uf = new UnionFind(n); int totalCost = 0;  (Edge edge : edges) {   == n - 1) { break; }  } }"], "perturbed_original": ["import java.util.HashSet; import java.util.Iterator; import java.util.Scanner; public class Main { static Scanner sc = new Scanner(System.in); static int n, m; static int[][] node; public static void main(String[] args) { while(read()){ solve(); } } static boolean read(){ n =  == 0 && m == 0) return false; node =  = -1; } } for(int i=0; i<m; i++){ int node1 = sc.nextInt(); int node2 = sc.nextInt(); int cost = sc.nextInt(); node[node1][node2] = cost; node[node2][node1]  HashSet<Integer> X = new HashSet<Integer>(); //\u008c\u0088\u0092\u00e8\u008d\u00cf\u0082\u00dd\u008fW\u008d\u0087 HashSet<Integer> Y = new HashSet<Integer>(); //\u0096\u00a2\u008c\u0088\u0092\u00e8\u008fW\u008d\u0087 //\u008fW\u008d\u0087\u0082\u00cc\u008f\u0089\u008a\u00fa\u0089\u00bb X.add(0); for(int i=1; i<n; i++){ Y.add(i); } //\u0096\u00a2\u008c\u0088\u0092\u00e8\u0082\u00cc\u008fW\u008d\u0087\u0082\u00aa\u008b\u00f3\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00dc\u0082\u00c5 while(!Y.isEmpty()){ //\u008d\u00c5\u008f\u00ac\u0083R\u0083X\u0083g\u0082\u00cc\u0097\u00d7\u0090\u00da\u0083m\u0081[\u0083h\u0082\u00f0\u0092\u00b2\u0082\u00d7\u0082\u00e9 int min = Integer.MAX_VALUE; int min_num = -1, min_num2 =  i1.hasNext();){ int n1 = i1.next(); for (Iterator<Integer> i2 = Y.iterator(); i2.hasNext();){  == -1) continue; if(min > node[n1][n2]){ min  min_num2 = n2; } } } sum += node[min_num][min_num2]; Y.remove(min_num2); X.add(min_num2); } System.out.println(sum); //\u008fo\u0097\u00cd } }"], "original_ll": -1.0396578311920166, "sampled_ll": -0.16457748413085938, "all_perturbed_sampled_ll": [-1.1680406332015991], "all_perturbed_original_ll": [-1.7223119735717773], "perturbed_sampled_ll": -1.1680406332015991, "perturbed_original_ll": -1.7223119735717773, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f(s, cost, route, ans):\n    route.append(s)\n    ans += cost[s]\n    del cost[s]\n    for k, c in data.items():\n        if s in k:\n            a, b = k\n            if s == a:\n                if not b in route:\n                    if not b in cost or c < cost[b]:\n                        cost[b] = c\n                        del data[(a, b)]\n            elif s == b:\n                if not a in route:\n                    if not a in cost or c < cost[a]:\n                        cost[a] = c\n                        del data[(a, b)]\n    if cost:\n        s = sorted(cost.items(), key=lambda x: x[1])[0][0]\n        return f(s, cost, route, ans)\n    return ans\n\nwhile 1:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    data = {}\n    for i in range(m):\n        a, b, c = map(int, raw_input().split())\n        data[(a, b)] = c\n    print f(0, {0:0}, [], 0)", "sampled": "import sys\nfrom typing import List, Tuple\n\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x: int) -> int:\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x: int, y: int) -> bool:\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False\n        \n        if self.rank[root_x] < self.rank[root_y]:\n            self.parent[root_x] = root_y\n        elif self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        else:\n            self.parent[root_y] = root_x\n            self.rank[root_x] += 1\n        \n        return True\n\ndef kruskal(n: int, edges: List[Tuple[int, int, int]]) -> int:\n    edges.sort(key=lambda x: x[2])\n    uf = UnionFind(n)\n    total_cost = 0\n    edges_added = 0\n    \n    for a, b, cost in edges:\n        if uf.union(a, b):\n            total_cost += cost\n            edges_added += 1\n            if edges_added == n - 1:\n                break\n    \n    return total_cost\n\ndef main():\n    input_lines = sys.stdin.read().strip().split('\\n')\n    i = 0\n    \n    while i < len(input_lines):\n        line = input_lines[i].strip()\n        if not line:\n            i += 1\n            continue\n        \n        parts = line.split()\n        n, m = int(parts[0]), int(parts[1])\n        \n        if n == 0 and m == 0:\n            break\n        \n        i += 1\n        edges = []\n        \n        for j in range(m):\n            line = input_lines[i].strip()\n            parts = line.split()\n            a, b, cost = int(parts[0]), int(parts[1]), int(parts[2])\n            edges.append((a, b, cost))\n            i += 1\n        \n        result = kruskal(n, edges)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from  UnionFind: def __init__(self, n: int): self.parent = list(range(n)) self.rank = [0] * n def find(self, x: int) -> int: if self.parent[x] != x:   self.find(y) if root_x == root_y: return False if self.rank[root_x] < self.rank[root_y]: self.parent[root_x] = root_y elif self.rank[root_x] > self.rank[root_y]: self.parent[root_y] = root_x else: self.parent[root_y] = root_x self.rank[root_x] += 1 return  List[Tuple[int, int, int]])  uf =  = 0 for a, b, cost in edges: if uf.union(a, b): total_cost += cost edges_added += 1 if edges_added == n - 1: break return total_cost def main(): input_lines =  i  if not line: i += 1 continue parts = line.split()  if n == 0 and m == 0: break i += 1 edges = [] for j in range(m): line = input_lines[i].strip() parts = line.split() a, b, cost = int(parts[0]), int(parts[1]), int(parts[2]) edges.append((a, b, cost)) i += 1 result = kruskal(n,  \"__main__\": main()"], "perturbed_original": ["def f(s,   k, c in  a, b = k if s  in route: if not b in cost or c < cost[b]: cost[b] = c del data[(a, b)] elif s == b: if not a in route: if  = c del data[(a, b)] if cost: s = sorted(cost.items(), key=lambda x: x[1])[0][0] return f(s,  while 1: n, m = map(int, raw_input().split()) if n == m == 0: break data = {} for i in range(m): a, b, c = map(int, raw_input().split()) data[(a, b)] = c print f(0, {0:0}, [], 0)"], "original_ll": -0.8625342845916748, "sampled_ll": -0.2534784972667694, "all_perturbed_sampled_ll": [-1.3235410451889038], "all_perturbed_original_ll": [-1.964123249053955], "perturbed_sampled_ll": -1.3235410451889038, "perturbed_original_ll": -1.964123249053955, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void){\n\tint m,n,q,r,a,i,j,t[100],s;\n\tfor(;scanf(\"%d%d\",&m,&n),m;printf(\"%d\\n\",q)){\n\t\tfor(s=i=q=0;i<n;i++){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tt[i]=a;\n\t\t\ts+=a;\n\t\t\tif(q<a)q=a;\n\t\t}\n\t\tr=s>1500000?1500000:s;\n\t\tfor(;q<r;){\n\t\t\tj=m;\n\t\t\ta=q+r>>1;\n\t\t\ts=0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\ts+=t[i];\n\t\t\t\tif(s>a){\n\t\t\t\t\tif(!--j)break;\n\t\t\t\t\ts=t[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==n){\tr=a;\t}\n\t\t\telse{\tq=a+1;\t}\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint m, n;\nint w[105];\nint dp[105][25];\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint solve(int pos, int shelves) {\n    if (pos == n) {\n        if (shelves == 0) return 0;\n        return 1e9;\n    }\n    if (shelves == 0) return 1e9;\n    \n    if (dp[pos][shelves] != -1) return dp[pos][shelves];\n    \n    int result = 1e9;\n    int sum = 0;\n    \n    for (int i = pos; i < n; i++) {\n        sum += w[i];\n        int remaining = solve(i + 1, shelves - 1);\n        if (remaining != 1e9) {\n            result = result < max(sum, remaining) ? result : max(sum, remaining);\n        }\n    }\n    \n    dp[pos][shelves] = result;\n    return result;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &m, &n);\n        if (m == 0 && n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &w[i]);\n        }\n        \n        memset(dp, -1, sizeof(dp));\n        printf(\"%d\\n\", solve(0, m));\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int m, n;  max(int a, int  b ? a : b; } int solve(int pos, int shelves)  { if (shelves == 0) return 0; return 1e9; } if (shelves == 0) return 1e9; if (dp[pos][shelves] != -1) return dp[pos][shelves]; int result = 1e9; int sum = 0; for (int i = pos; i < n; i++) { sum += w[i]; int  shelves - 1);  result = result < max(sum, remaining) ? result : max(sum, remaining); } } dp[pos][shelves] = result;  { while  &n);  n == 0) break; for (int i = 0; i < n; i++) { scanf(\"%d\", &w[i]); } memset(dp,  } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void){ int m,n,q,r,a,i,j,t[100],s; for(;scanf(\"%d%d\",&m,&n),m;printf(\"%d\\n\",q)){ for(s=i=q=0;i<n;i++){ scanf(\"%d\",&a); t[i]=a; s+=a; if(q<a)q=a; } r=s>1500000?1500000:s; for(;q<r;){ j=m; a=q+r>>1; s=0; for(i=0;i<n;i++){ s+=t[i]; if(s>a){ if(!--j)break; s=t[i]; }  q=a+1;  }"], "original_ll": -1.2898679971694946, "sampled_ll": -0.4887351989746094, "all_perturbed_sampled_ll": [-1.6300498247146606], "all_perturbed_original_ll": [-1.6922109127044678], "perturbed_sampled_ll": -1.6300498247146606, "perturbed_original_ll": -1.6922109127044678, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m;\n\tstatic int book[];\n\n\tpublic static int binarySearch(int low, int high) {\n\t\tif (high - low <= 0) {\n\t\t\treturn high;\n\t\t}\n\t\tint mid = (low + high) / 2;\n\t\tint shellId = 0;\n\t\tint sumWidth = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (mid < sumWidth + book[i]) {\n\t\t\t\tshellId++;\n\t\t\t\tsumWidth = book[i];\n\t\t\t} else {\n\t\t\t\tsumWidth += book[i];\n\t\t\t}\n\t\t}\n\n\t\tif (n <= shellId) {\n\t\t\treturn binarySearch(mid + 1, high);\n\t\t} else {\n\t\t\treturn binarySearch(low, mid);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint max;\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();//tana\n\t\t\tm = sc.nextInt();//kann\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbook = new int[m];\n\t\t\tmax = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbook[i] = sc.nextInt();\n\t\t\t\tmax = Math.max(max, book[i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(binarySearch(max, 1500000));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            \n            if (m == 0 && n == 0) break;\n            \n            int[] w = new int[n];\n            for (int i = 0; i < n; i++) {\n                w[i] = sc.nextInt();\n            }\n            \n            // Binary search on the width\n            int left = 0;\n            int right = 1500000;\n            \n            // Find the minimum of maximum widths\n            for (int i = 0; i < n; i++) {\n                left = Math.max(left, w[i]);\n            }\n            \n            while (left < right) {\n                int mid = (left + right) / 2;\n                if (canFit(w, n, m, mid)) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            \n            System.out.println(left);\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean canFit(int[] w, int n, int m, int maxWidth) {\n        int shelves = 1;\n        int currentWidth = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (currentWidth + w[i] <= maxWidth) {\n                currentWidth += w[i];\n            } else {\n                shelves++;\n                currentWidth = w[i];\n                if (shelves > m) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int m = sc.nextInt(); int n = sc.nextInt(); if (m  0) break;  i++) { w[i] = sc.nextInt(); } // Binary search on the  int right = 1500000; // Find the  (int i = 0; i < n; i++) { left = Math.max(left, w[i]);  { int  / 2; if (canFit(w, n, m, mid)) { right =  } } System.out.println(left); } sc.close(); } private  n, int m, int maxWidth) { int shelves = 1; int currentWidth = 0; for (int i = 0; i < n; i++) { if (currentWidth + w[i] <= maxWidth) { currentWidth += w[i]; } else { shelves++; currentWidth = w[i]; if (shelves > m) { return false; } } } return true; } }"], "perturbed_original": [" {  int book[]; public static int binarySearch(int low, int high) { if (high -  high; } int mid = (low +  = 0; int sumWidth = 0; for (int i = 0; i < m; i++) { if (mid  shellId++; sumWidth = book[i]; } else { sumWidth += book[i]; } }  return binarySearch(mid + 1, high); } else { return binarySearch(low, mid); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int max; while (true) { n = sc.nextInt();//tana m =  == 0) { break; } book = new int[m];  i =  { book[i] = sc.nextInt(); max = Math.max(max, book[i]); } System.out.println(binarySearch(max, 1500000)); } } }"], "original_ll": -0.8218260407447815, "sampled_ll": -0.4436812698841095, "all_perturbed_sampled_ll": [-1.4161587953567505], "all_perturbed_original_ll": [-2.0557374954223633], "perturbed_sampled_ll": -1.4161587953567505, "perturbed_original_ll": -2.0557374954223633, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def hondan(w,m):\n    m_sum = b_lis[0]\n    num = 0\n    if w < max(b_lis):\n        return False\n    else:\n        for i in range(len(b_lis) - 1):\n            m_sum += b_lis[i + 1]\n            if m_sum > w:\n\n                m_sum = b_lis[i + 1]\n                num += 1\n\n        if num < m:\n            return True\n        else:\n            return False\n        \ndef nibutan(f_id,e_id,m):\n    \n    \n    m_id = int((f_id + e_id) / 2)\n    m_bo = hondan(m_id,m)\n\n\n    if (f_id > e_id):\n        return m_id + 1\n    else:\n        if m_bo:\n            return(nibutan(f_id,m_id -1,m))\n        elif not m_bo:\n            return(nibutan(m_id + 1,e_id,m))\n        else:\n            return m_id + 1\n\n\n\nwhile True:\n    global w_lis\n    b_lis = []\n    w_lis = []\n    dan_num = [0]\n\n    m,n = map(int,input().split())\n    if m == n == 0:\n        break\n    for i in range(n):\n        num = int(input())\n        b_lis.append(num)\n    s_num = int(sum(b_lis) /m)\n\n    print(nibutan(s_num,1500000,m) )", "sampled": "def can_fit(books, m, max_width):\n    shelves_used = 1\n    current_width = 0\n    \n    for book in books:\n        if book > max_width:\n            return False\n        if current_width + book > max_width:\n            shelves_used += 1\n            current_width = book\n            if shelves_used > m:\n                return False\n        else:\n            current_width += book\n    \n    return True\n\ndef solve(m, n, books):\n    left = max(books)\n    right = sum(books)\n    \n    result = right\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_fit(books, m, mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\nwhile True:\n    line = input().split()\n    m, n = int(line[0]), int(line[1])\n    \n    if m == 0 and n == 0:\n        break\n    \n    books = []\n    for _ in range(n):\n        books.append(int(input()))\n    \n    print(solve(m, n, books))\n", "perturbed_sampled": ["def can_fit(books,  current_width  books: if book > max_width: return False if current_width  += 1 current_width = book if  else: current_width += book return True def solve(m, n, books): left = max(books)  right while left <= right: mid = (left + right) // 2 if can_fit(books, m, mid): result = mid right = mid - 1 else: left = mid + 1 return result while True: line =  int(line[1]) if m == 0 and  = [] for _ in range(n): books.append(int(input())) print(solve(m, n, books))"], "perturbed_original": ["def hondan(w,m): m_sum = b_lis[0] num =  return False else: for i in  b_lis[i + 1] if m_sum > w: m_sum = b_lis[i + 1] num  m_id = int((f_id + e_id) / 2) m_bo = hondan(m_id,m) if (f_id > e_id): return m_id + 1 else: if m_bo: return(nibutan(f_id,m_id -1,m)) elif  else: return m_id + 1 while True: global w_lis b_lis = [] w_lis = [] dan_num = [0] m,n = map(int,input().split()) if m == n == 0: break for i in range(n): num  int(sum(b_lis) /m) print(nibutan(s_num,1500000,m) )"], "original_ll": -1.4594098329544067, "sampled_ll": -0.5417465567588806, "all_perturbed_sampled_ll": [-2.108415365219116], "all_perturbed_original_ll": [-2.6041760444641113], "perturbed_sampled_ll": -2.108415365219116, "perturbed_original_ll": -2.6041760444641113, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\nint b[50]; // beaker status\nint d[50]; // used status\nint f[50]; // filled status\n\nint compare(const void *a, const void *b) {\n  return *(int *)b - *(int *)a;\n}\n\nint dcheck(int n) {\n  int i, r;\n  for (i = 0, r = 0; i < n; i++)\n    r += d[i];\n  if (r == n)\n    return 1;\n  else\n    return 0;\n}\n\nint beaker(int n, int m) {\n  int i, t;\n  f[m] = 0;\n  d[m] = 1;\n\n  if (n == 1) return 1;\n  for (i = m + 1, t = b[m]; i < n; i++) {\n    if (t >= b[i] && f[i] == 0) {\n      t -= b[i];\n      d[i] = f[i] = 1;\n    }\n    if (t == 0)\n      if (dcheck(n))\n        return 1;\n      else\n        beaker(n, m + 1);\n  }\n  return 0;\n}\n\nvoid init() {\n  int i;\n  for (i = 0; i < 50; i++)\n    b[i] = f[i] = d[i] = 0;\n  return;\n}\n\nint main() {\n  int i, n, m;\n\n  for (;;) {\n    scanf(\"%d\", &n);\n    if (n == 0)\n      return 0;\n    init();\n    for (i = 0; i < n; i++)\n      scanf(\"%d\", &b[i]);\n    qsort(b, n, sizeof(int), compare);\n    m = 0; // set max value posion\n    printf(\"%s\", beaker(n, m) ? \"YES\\n\" : \"NO\\n\");\n  }\n  return -1;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint canFill(int *beakers, int n) {\n    int *filled = (int*)calloc(n, sizeof(int));\n    int i, j;\n    \n    filled[0] = beakers[0];\n    \n    for (i = 0; i < n; i++) {\n        if (filled[i] == 0) continue;\n        \n        int water = filled[i];\n        \n        for (j = 0; j < n && water > 0; j++) {\n            if (filled[j] == 0) {\n                int toFill = beakers[j];\n                if (water >= toFill) {\n                    filled[j] = toFill;\n                    water -= toFill;\n                }\n            }\n        }\n        \n        if (water > 0) {\n            free(filled);\n            return 0;\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (filled[i] == 0) {\n            free(filled);\n            return 0;\n        }\n    }\n    \n    free(filled);\n    return 1;\n}\n\nint solve(int *beakers, int n, int index, long long water, int *used) {\n    if (water < 0) return 0;\n    \n    if (index == n) {\n        return (water == 0);\n    }\n    \n    if (used[index]) {\n        return solve(beakers, n, index + 1, water, used);\n    }\n    \n    if (water >= beakers[index]) {\n        used[index] = 1;\n        if (solve(beakers, n, 0, water - beakers[index], used)) {\n            used[index] = 0;\n            return 1;\n        }\n        used[index] = 0;\n    }\n    \n    return solve(beakers, n, index + 1, water, used);\n}\n\nint canFillRecursive(int *beakers, int n, int current, int *used) {\n    if (current == n) {\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) return 0;\n        }\n        return 1;\n    }\n    \n    if (!used[current]) return 0;\n    \n    long long water = beakers[current];\n    int *newUsed = (int*)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) newUsed[i] = used[i];\n    \n    if (solve(beakers, n, 0, water, newUsed)) {\n        if (canFillRecursive(beakers, n, current + 1, newUsed)) {\n            free(newUsed);\n            return 1;\n        }\n    }\n    \n    free(newUsed);\n    return 0;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int *beakers = (int*)malloc(n * sizeof(int));\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &beakers[i]);\n        }\n        \n        qsort(beakers, n, sizeof(int), compare);\n        \n        if (n == 1) {\n            printf(\"YES\\n\");\n            free(beakers);\n            continue;\n        }\n        \n        int *used = (int*)calloc(n, sizeof(int));\n        used[0] = 1;\n        \n        if (canFillRecursive(beakers, n, 0, used)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n        \n        free(used);\n        free(beakers);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  const void *b) { return (*(int*)b - *(int*)a); } int canFill(int *beakers, int n) { int *filled = (int*)calloc(n, sizeof(int)); int i,  (i = 0; i < n; i++)  continue; int water = filled[i]; for (j = 0; j < n && water > 0; j++) { if (filled[j] == 0) { int toFill =  { filled[j] =  } } if (water > 0) { free(filled); return 0; }  i  free(filled); return 0; } } free(filled); return 1;  n, int index, long   (used[index]) { return solve(beakers, n, index + 1, water, used); } if (water >= beakers[index]) { used[index] = 1; if (solve(beakers, n, 0, water - beakers[index], used))  1; } used[index] = 0; } return solve(beakers, n, index + 1,  *beakers, int n, int current, int *used) { if (current ==  n; i++) {  return 1; } if (!used[current]) return 0; long long water = beakers[current]; int *newUsed = (int*)malloc(n * sizeof(int)); for (int i = 0; i < n; i++) newUsed[i] = used[i]; if (solve(beakers, n, 0, water, newUsed)) { if (canFillRecursive(beakers, n, current + 1, newUsed)) { free(newUsed); return 1; } } free(newUsed); return 0;  n; while (scanf(\"%d\", &n) ==  { int *beakers = (int*)malloc(n * sizeof(int)); for (int i = 0; i < n; i++) { scanf(\"%d\", &beakers[i]); } qsort(beakers, n, sizeof(int), compare); if (n == 1) { printf(\"YES\\n\"); free(beakers); continue; } int *used = (int*)calloc(n, sizeof(int)); used[0] = 1; if (canFillRecursive(beakers, n, 0, used)) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } free(used); free(beakers); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> int   int compare(const void *a, const void *b) { return *(int *)b - *(int *)a; } int dcheck(int n) { int i, r; for (i = 0, r = 0; i < n; i++) r += d[i]; if (r == n) return 1; else return 0; } int beaker(int n, int m) { int i, t; f[m] = 0; d[m] = 1; if (n == 1) return 1; for (i = m + 1, t = b[m];  && f[i] == 0) { t -= b[i]; d[i] = f[i] = 1; } if (t == 0) if (dcheck(n)) return 1; else  return 0; }  for (i   d[i]  main() { int i, n, m; for (;;) { scanf(\"%d\", &n); if (n == 0) return 0; init(); for (i =  scanf(\"%d\", &b[i]); qsort(b, n, sizeof(int), compare); m = 0; // set max  ? \"YES\\n\" : \"NO\\n\"); } return -1; }"], "original_ll": -0.8494323492050171, "sampled_ll": -0.41889718174934387, "all_perturbed_sampled_ll": [-1.1773699522018433], "all_perturbed_original_ll": [-1.4758317470550537], "perturbed_sampled_ll": -1.1773699522018433, "perturbed_original_ll": -1.4758317470550537, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Beaker\npublic class Main{\n\n\tint n;\n\tint[] a;\n\tboolean[] have, t;\n\t\n\tboolean dfs(int k, int rest){\n\t\tif(rest==0){\n\t\t\tfor(int i=0;i<n;i++)t[i]=have[i];\n\t\t\treturn greedy();\n\t\t}\n\t\tif(rest < a[k])return false;\n\t\thave[k] = true;\n\t\tif(dfs(k+1, rest-a[k]))return true;\n\t\thave[k] = false;\n\t\treturn dfs(k+1, rest);\n\t}\n\t\n\tboolean choice(int k, int rest){\n\t\tif(rest==0)return true;\n\t\tif(k<0)return false;\n\t\tif(!t[k])return choice(k-1, rest);\n\t\tif(a[k]<=rest){\n\t\t\tt[k] = false;\n\t\t\tif(choice(k-1, rest-a[k]))return true;\n\t\t\tt[k] = true;\n\t\t}\n\t\treturn choice(k-1, rest);\n\t}\n\t\n\tboolean greedy(){\n\t\tfor(int i=0;i<n;i++)if(!t[i]){\n\t\t\tif(!choice(i-1, a[i]))return false;\n\t\t\tt[i] = true;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tt = new boolean[100];\n\t\thave = new boolean[100];\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\ta = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\tArrays.fill(have, false);\n\t\t\thave[0] = true;\n\t\t\tSystem.out.println(dfs(1, a[n-1]-a[0])?\"YES\":\"NO\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] beakers = new int[n];\n            for (int i = 0; i < n; i++) {\n                beakers[i] = sc.nextInt();\n            }\n            \n            if (canFillAll(beakers)) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static boolean canFillAll(int[] beakers) {\n        int n = beakers.length;\n        if (n == 1) return true;\n        \n        Arrays.sort(beakers);\n        int maxIdx = n - 1;\n        \n        return dfs(beakers, new boolean[n], maxIdx, beakers[maxIdx]);\n    }\n    \n    static boolean dfs(int[] beakers, boolean[] used, int currentIdx, int currentWater) {\n        used[currentIdx] = true;\n        \n        if (allUsed(used)) {\n            return true;\n        }\n        \n        return tryPour(beakers, used, currentWater, 0);\n    }\n    \n    static boolean tryPour(int[] beakers, boolean[] used, int water, int startIdx) {\n        if (water == 0) {\n            for (int i = beakers.length - 1; i >= 0; i--) {\n                if (!used[i]) {\n                    boolean[] newUsed = used.clone();\n                    if (dfs(beakers, newUsed, i, beakers[i])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        \n        for (int i = startIdx; i < beakers.length; i++) {\n            if (!used[i] && beakers[i] <= water) {\n                boolean[] newUsed = used.clone();\n                if (tryPour(beakers, newUsed, water - beakers[i], i + 1)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    static boolean allUsed(boolean[] used) {\n        for (boolean u : used) {\n            if (!u) return false;\n        }\n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class () {<extra_id_1>System.out.println(\"YES\"); } }<extra_id_2>if (r ===<extra_id_3>(int[i] == 0) {<extra_id_4>{ return true; } if<extra_id_5>int i<extra_id_6>2 ; i < beakers[i]<extra_id_7>= used.clone(); if (tryPour(beakers,<extra_id_8>i <<extra_id_9>true; } } else if<extra_id_10>true; } }<extra_id_11>return<extra_id_12>{ return  = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[]  (int i = 0; i < n; i++) { beakers[i] = sc.nextInt();  } else { System.out.println(\"NO\"); } } sc.close(); } static boolean canFillAll(int[] beakers) { int n =  maxIdx = n - 1; return dfs(beakers,  static boolean dfs(int[] beakers, boolean[] used, int currentIdx, int currentWater) { used[currentIdx] = true; if (allUsed(used)) { return true; }  } static boolean tryPour(int[] beakers, boolean[] used, int water, int startIdx) { if (water  1; i >= 0; i--) { if (!used[i]) { boolean[] newUsed = used.clone(); if (dfs(beakers, newUsed, i, beakers[i])) { return true; } } } return false; } for (int i = startIdx; i < beakers.length; i++) { if (!used[i] && beakers[i] <= water) { boolean[] newUsed = used.clone(); if (tryPour(beakers, newUsed,   } } return false; } static boolean allUsed(boolean[] used) { for (boolean u : used) {  return true; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; //Beaker public class Main{ int n; int[] a; boolean[] have, t; boolean  for(int i=0;i<n;i++)t[i]=have[i]; return greedy(); } if(rest < a[k])return false; have[k] = true; if(dfs(k+1, rest-a[k]))return true; have[k] = false; return dfs(k+1, rest); } boolean choice(int k, int rest){ if(rest==0)return true; if(k<0)return false; if(!t[k])return  false; if(choice(k-1, rest-a[k]))return true; t[k] = true; } return choice(k-1, rest); } boolean greedy(){ for(int i=0;i<n;i++)if(!t[i]){ if(!choice(i-1, a[i]))return false;  true; } void run(){ Scanner sc  new boolean[100]; for(;;){ n = sc.nextInt(); if(n==0)break; a = new int[n]; for(int i=0;i<n;i++){ a[i]  public static void main(String[] args) { new Main().run(); } }"], "original_ll": -0.7220210433006287, "sampled_ll": -0.4778882563114166, "all_perturbed_sampled_ll": [-1.7050611972808838], "all_perturbed_original_ll": [-1.5685375928878784], "perturbed_sampled_ll": -1.7050611972808838, "perturbed_original_ll": -1.5685375928878784, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(input())\n    if n == 0: break\n    beakers = list(map(int, input().split()))\n    m = max(beakers)\n    beakers.remove(m)\n    beakers.sort()\n    if beakers:\n        beakersum = [beakers[0]]\n        del beakers[0]\n    else:\n        print(\"YES\")\n        continue\n\n    if sum(beakers) < m:\n        print(\"NO\")\n        continue\n    elif sum(beakers) == m:\n        print(\"YES\")\n        continue\n\n    for b in beakers:\n        tmp = [bks + b for bks in beakersum if bks + b <= m]\n        beakersum.extend(tmp)\n        if m in beakersum:\n            break\n    \n    if m in beakersum:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n            \n        ", "sampled": "def can_fill_all_beakers(beakers):\n    n = len(beakers)\n    if n == 1:\n        return True\n    \n    beakers_sorted = sorted(beakers, reverse=True)\n    max_beaker = beakers_sorted[0]\n    \n    # Try DFS to see if we can fill all beakers\n    def dfs(filled, current_water):\n        if len(filled) == n:\n            return current_water == 0\n        \n        if current_water == 0:\n            return False\n        \n        # Try to fill each unfilled beaker\n        for i in range(n):\n            if i not in filled:\n                beaker_capacity = beakers_sorted[i]\n                if beaker_capacity <= current_water:\n                    # Fill this beaker\n                    new_filled = filled | {i}\n                    new_water = current_water - beaker_capacity + beaker_capacity\n                    # After filling, we pour out this beaker's water\n                    if dfs(new_filled, new_water):\n                        return True\n        \n        return False\n    \n    # Different approach: simulate the process\n    # Start with largest beaker filled\n    def solve():\n        # Use bitmask DP or backtracking\n        # State: which beakers have been filled\n        from functools import lru_cache\n        \n        @lru_cache(maxsize=None)\n        def can_fill(filled_mask, available_water):\n            if filled_mask == (1 << n) - 1:\n                return available_water == 0\n            \n            if available_water == 0:\n                return False\n            \n            # Try filling each unfilled beaker\n            for i in range(n):\n                if not (filled_mask & (1 << i)):\n                    capacity = beakers_sorted[i]\n                    if capacity <= available_water:\n                        # Fill beaker i\n                        new_mask = filled_mask | (1 << i)\n                        new_water = available_water - capacity + capacity\n                        if can_fill(new_mask, new_water):\n                            return True\n            \n            return False\n        \n        # Start with the largest beaker (index 0) filled\n        initial_mask = 1\n        initial_water = max_beaker\n        return can_fill(initial_mask, initial_water)\n    \n    return solve()\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    beakers = list(map(int, input().split()))\n    \n    if can_fill_all_beakers(beakers):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["def can_fill_all_beakers(beakers): n = len(beakers) if n == 1: return True beakers_sorted = sorted(beakers, reverse=True) max_beaker = beakers_sorted[0] # Try DFS to see if we can fill all beakers def  0 if current_water == 0: return False # Try to fill each unfilled beaker for i in range(n): if i not in  beaker_capacity <= current_water: # Fill this beaker new_filled = filled  - beaker_capacity  we  if dfs(new_filled, new_water): return True return False # Different approach:  with largest beaker filled def solve(): #  # State: which beakers have been filled from functools import lru_cache @lru_cache(maxsize=None) def can_fill(filled_mask, available_water): if filled_mask == (1 << n) - 1: return available_water == 0 if available_water == 0: return False # Try filling each unfilled beaker for i in range(n): if not (filled_mask & (1 << i)): capacity  available_water: #  filled_mask | (1 << i)  + capacity if can_fill(new_mask, new_water): return True return False # Start  1 initial_water = max_beaker return can_fill(initial_mask, initial_water) return solve() while True: n  0: break beakers = list(map(int, input().split())) if can_fill_all_beakers(beakers): print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["while True: n = int(input()) if n == 0: break beakers = list(map(int, input().split())) m = max(beakers) beakers.remove(m) beakers.sort() if  beakers[0]  < m: print(\"NO\") continue elif sum(beakers) == m: print(\"YES\") continue for b in beakers: tmp = [bks +   m] beakersum.extend(tmp) if m in beakersum: break if m in beakersum: print(\"YES\") else: print(\"NO\")"], "original_ll": -1.0833656787872314, "sampled_ll": -0.8243054747581482, "all_perturbed_sampled_ll": [-1.8535916805267334], "all_perturbed_original_ll": [-1.9163322448730469], "perturbed_sampled_ll": -1.8535916805267334, "perturbed_original_ll": -1.9163322448730469, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\n#include<stdio.h>\nint main(){\n  char c[9],i;\n  int d[]={0,1,2,3,4,5,6,7,8,0,3,6,1,4,7,2,5,8,0,4,8,2,4,6};\n  while(scanf(\" %c\",&c[0]),c[0]-'0'){\n    for(i=1;i<9;i++){\n      scanf(\" %c\",&c[i]);\n    }\n    for(i=0;i<8;i++){\n      if(c[d[i*3+0]]==c[d[i*3+1]]&&c[d[i*3+1]]==c[d[i*3+2]]&&c[d[i*3+0]]-'+'){\n\tprintf(\"%c\\n\",c[d[i*3]]);\n\tbreak;\n      }\n    }\n      if(i==8)printf(\"NA\\n\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint check_win(char board[3][4], char player) {\n    // Check rows\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {\n            return 1;\n        }\n    }\n    \n    // Check columns\n    for (int j = 0; j < 3; j++) {\n        if (board[0][j] == player && board[1][j] == player && board[2][j] == player) {\n            return 1;\n        }\n    }\n    \n    // Check diagonals\n    if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return 1;\n    }\n    if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return 1;\n    }\n    \n    return 0;\n}\n\nint main() {\n    char board[3][4];\n    \n    while (1) {\n        if (scanf(\"%s\", board[0]) != 1) break;\n        if (board[0][0] == '0') break;\n        \n        scanf(\"%s\", board[1]);\n        scanf(\"%s\", board[2]);\n        \n        if (check_win(board, 'b')) {\n            printf(\"b\\n\");\n        } else if (check_win(board, 'w')) {\n            printf(\"w\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int check_win(char board[3][4], char player)  i < 3; i++) { if (board[i][0] == player && board[i][1] == player && board[i][2] == player) { return 1; } } // Check columns for (int j =  { if (board[0][j] == player && board[1][j] == player && board[2][j] == player) { return 1; } }  == player && board[1][1]  player) { return  player && board[1][1] == player && board[2][0] == player)  0; } int main() { char board[3][4]; while (1) { if  if  board[1]); scanf(\"%s\", board[2]); if (check_win(board, 'b')) { printf(\"b\\n\"); } else if (check_win(board, 'w')) { printf(\"w\\n\"); } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ char c[9],i; int d[]={0,1,2,3,4,5,6,7,8,0,3,6,1,4,7,2,5,8,0,4,8,2,4,6}; while(scanf(\" %c\",&c[0]),c[0]-'0'){ for(i=1;i<9;i++){ scanf(\" %c\",&c[i]); } for(i=0;i<8;i++){  if(i==8)printf(\"NA\\n\"); } return 0; }"], "original_ll": -1.1931833028793335, "sampled_ll": -0.3796199560165405, "all_perturbed_sampled_ll": [-1.3540723323822021], "all_perturbed_original_ll": [-1.6889853477478027], "perturbed_sampled_ll": -1.3540723323822021, "perturbed_original_ll": -1.6889853477478027, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[][] board = new char[3][3];\n\t\n\tstatic boolean read() {\n\t\tString line = sc.next();\n\t\tif(line.equals(\"0\")) return false;\n\t\tboard[0][0] = line.charAt(0); board[0][1] = line.charAt(1); board[0][2] = line.charAt(2);\n\t\tfor(int i = 1; i < 3; i++) {\n\t\t\tline = sc.next();\n\t\t\tfor(int j = 0; j < 3; j++) board[i][j] = line.charAt(j);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic String solve() {\n\t\tchar stone;\n\t\tboolean win;\n\t\t\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\twin = true;\n\t\t\tstone = board[i][0];\n\t\t\tfor(int j = 1; j < 3; j++) {\n\t\t\t\tif(stone != board[i][j]) win = false;\n\t\t\t}\n\t\t\tif(win) return \"\" + stone;\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < 3; j++) {\n\t\t\twin = true;\n\t\t\tstone = board[0][j];\n\t\t\tfor(int i = 1; i < 3; i++) {\n\t\t\t\tif(stone != board[i][j]) win = false;\n\t\t\t}\n\t\t\tif(win) return \"\" + stone;\n\t\t}\n\t\t\n\t\tif(board[0][0] == board[1][1] && board[0][0] == board[2][2]) return \"\" + board[0][0];\n\t\t\n\t\tif(board[2][0] == board[1][1]  && board[1][1] == board[0][2]) return \"\" + board[2][0];\n\t\t\n\t\treturn \"NA\";\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String line = sc.nextLine();\n            if (line.equals(\"0\")) {\n                break;\n            }\n            \n            char[][] board = new char[3][3];\n            board[0] = line.toCharArray();\n            board[1] = sc.nextLine().toCharArray();\n            board[2] = sc.nextLine().toCharArray();\n            \n            boolean bWins = checkWin(board, 'b');\n            boolean wWins = checkWin(board, 'w');\n            \n            if (bWins) {\n                System.out.println(\"b\");\n            } else if (wWins) {\n                System.out.println(\"w\");\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean checkWin(char[][] board, char player) {\n        // Check rows\n        for (int i = 0; i < 3; i++) {\n            if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {\n                return true;\n            }\n        }\n        \n        // Check columns\n        for (int j = 0; j < 3; j++) {\n            if (board[0][j] == player && board[1][j] == player && board[2][j] == player) {\n                return true;\n            }\n        }\n        \n        // Check diagonals\n        if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n            return true;\n        }\n        if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) {  (line.equals(\"0\")) { break; } char[][] board = new char[3][3]; board[0] = line.toCharArray(); board[1] = sc.nextLine().toCharArray(); board[2] = sc.nextLine().toCharArray(); boolean     else { System.out.println(\"NA\"); } } sc.close(); } private static boolean checkWin(char[][] board, char  for (int i = 0; i < 3; i++)  && board[i][2] == player) { return true; } } // Check columns for (int j = 0; j < 3; j++) { if (board[0][j] == player && board[1][j] == player  return true; } } // Check diagonals if (board[0][0] == player && board[1][1] == player && board[2][2] == player) { return true; }  board[1][1] == player && board[2][0] == player) { return true; } return false; } }"], "perturbed_original": ["import java.util.*;  Scanner sc = new Scanner(System.in); static char[][] board = new char[3][3]; static boolean read() { String line = sc.next(); if(line.equals(\"0\"))  = line.charAt(2); for(int i   for(int j = 0; j < 3; j++) board[i][j] = line.charAt(j); } return true; } static String solve()  for(int i  i++) { win = true; stone = board[i][0]; for(int j = 1; j < 3; j++)   \"\" + stone; } for(int j = 0; j < 3; j++) { win = true; stone = board[0][j]; for(int i = 1; i < 3; i++) { if(stone != board[i][j]) win = false;  stone; } if(board[0][0] == board[1][1] && board[0][0] == board[2][2]) return \"\" + board[0][0]; if(board[2][0] == board[1][1] && board[1][1] == board[0][2])  \"NA\"; } public static void main(String[] args) { while(read()) { System.out.println(solve()); } } }"], "original_ll": -0.4385029375553131, "sampled_ll": -0.26952099800109863, "all_perturbed_sampled_ll": [-0.9801798462867737], "all_perturbed_original_ll": [-1.2436081171035767], "perturbed_sampled_ll": -0.9801798462867737, "perturbed_original_ll": -1.2436081171035767, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        f = [list(raw_input()) for _ in xrange(3)]\n    except EOFError:\n        break\n    g = map(lambda x:\"\".join(x),f+zip(*f))\n    print \"b\" if \"b\"*3 in g else \"w\" if \"w\"*3 in g else \"NA\"", "sampled": "import sys\n\ndef check_winner(board):\n    # Check rows\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2] and board[i][0] != '+':\n            return board[i][0]\n    \n    # Check columns\n    for i in range(3):\n        if board[0][i] == board[1][i] == board[2][i] and board[0][i] != '+':\n            return board[0][i]\n    \n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] != '+':\n        return board[0][0]\n    \n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] != '+':\n        return board[0][2]\n    \n    return 'NA'\n\nwhile True:\n    line = input().strip()\n    if line == '0':\n        break\n    \n    board = [line]\n    board.append(input().strip())\n    board.append(input().strip())\n    \n    result = check_winner(board)\n    print(result)\n", "perturbed_sampled": ["import sys def  i in range(3): if board[i][0] == board[i][1] == board[i][2] and board[i][0] != '+': return board[i][0] # Check columns for i in range(3): if board[0][i] == board[1][i] == board[2][i] and   and board[0][0] != '+': return board[0][0]  board[2][0] and board[0][2] != '+': return board[0][2] return 'NA' while True: line = input().strip() if line == '0': break board = [line] board.append(input().strip()) board.append(input().strip()) result = check_winner(board) print(result)"], "perturbed_original": ["while True: try: f = [list(raw_input()) for _ in xrange(3)] except EOFError: break g = map(lambda x:\"\".join(x),f+zip(*f)) print \"b\"  \"w\" if \"w\"*3 in g else \"NA\""], "original_ll": -1.647559642791748, "sampled_ll": -0.3976525366306305, "all_perturbed_sampled_ll": [-1.3772786855697632], "all_perturbed_original_ll": [-2.4841649532318115], "perturbed_sampled_ll": -1.3772786855697632, "perturbed_original_ll": -2.4841649532318115, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n    int age0,age1,age2,age3,age4,age5,age6,n,i,x;\n    while(1){\n        age0=0;age1=0;age2=0;age3=0;age4=0;age5=0;age6=0;\n        scanf(\"%d\",&n);\n        if(n==0)break;\n        for(i=0;i<n;i++){\n            scanf(\"%d\",&x);\n            if(x>=60){\n                age6++;\n            }else if(x>=50){\n                age5++;\n            }else if(x>=40){\n                age4++;\n            }else if(x>=30){\n                age3++;\n            }else if(x>=20){\n                age2++;\n            }else if(x>=10){\n                age1++;\n            }else{\n                age0++;\n            }\n        }\n        printf(\"%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n\",age0,age1,age2,age3,age4,age5,age6);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int count[7] = {0};\n        \n        for(int i = 0; i < n; i++) {\n            int age;\n            scanf(\"%d\", &age);\n            \n            if(age < 10) {\n                count[0]++;\n            } else if(age < 20) {\n                count[1]++;\n            } else if(age < 30) {\n                count[2]++;\n            } else if(age < 40) {\n                count[3]++;\n            } else if(age < 50) {\n                count[4]++;\n            } else if(age < 60) {\n                count[5]++;\n            } else {\n                count[6]++;\n            }\n        }\n        \n        for(int i = 0; i < 7; i++) {\n            printf(\"%d\\n\", count[i]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(scanf(\"%d\", &n) == 1 && n != 0) { int count[7] = {0}; for(int i  i++) { int age;  { count[0]++; } else if(age < 20) { count[1]++; } else if(age < 30) { count[2]++; } else if(age < 40) { count[3]++; } else  } else if(age <  for(int i = 0; i < 7; i++) { printf(\"%d\\n\", count[i]); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int age0,age1,age2,age3,age4,age5,age6,n,i,x; while(1){ age0=0;age1=0;age2=0;age3=0;age4=0;age5=0;age6=0; scanf(\"%d\",&n);  }else if(x>=50){  if(x>=30){ age3++; }else if(x>=20){ age2++; }else if(x>=10){ age1++; }else{ age0++; } } printf(\"%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n\",age0,age1,age2,age3,age4,age5,age6); } return 0; }"], "original_ll": -0.42583775520324707, "sampled_ll": -0.3275562524795532, "all_perturbed_sampled_ll": [-1.2313206195831299], "all_perturbed_original_ll": [-0.9977778196334839], "perturbed_sampled_ll": -1.2313206195831299, "perturbed_original_ll": -0.9977778196334839, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main\n{\n    public static void main(String args[])\n    {\n\tScanner scan=new Scanner(System.in);\n\twhile(true)\n\t    {\n\t\t\n\t\tint n=scan.nextInt();\n\t\tif(n==0)break;\n\t\tint s[]=new int[7];\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\t\n\t\t\tint old=scan.nextInt();\n\t\t\tint x=old/10;\n\t\t\tif(x>=6)x=6;\n\t\t\ts[x]++;\n\t\t    }\n\t\tfor(int i=0;i<7;i++)\n\t\t    {\n\t\t\tSystem.out.println(s[i]);\n\t\t    }\n\t    }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] counts = new int[7];\n            \n            for (int i = 0; i < n; i++) {\n                int age = sc.nextInt();\n                \n                if (age < 10) {\n                    counts[0]++;\n                } else if (age < 20) {\n                    counts[1]++;\n                } else if (age < 30) {\n                    counts[2]++;\n                } else if (age < 40) {\n                    counts[3]++;\n                } else if (age < 50) {\n                    counts[4]++;\n                } else if (age < 60) {\n                    counts[5]++;\n                } else {\n                    counts[6]++;\n                }\n            }\n            \n            for (int i = 0; i < 7; i++) {\n                System.out.println(counts[i]);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if  for (int i  i++) { int age = sc.nextInt(); if (age <  if (age < 20) { counts[1]++; } else  counts[2]++; } else if (age < 40) { counts[3]++; } else if (age < 50) { counts[4]++; } else if (age < 60) { counts[5]++; } else { counts[6]++; } } for (int i = 0; i <  } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String args[]) { Scanner scan=new Scanner(System.in); while(true) { int n=scan.nextInt(); if(n==0)break; int s[]=new int[7]; for(int i=0;i<n;i++) { int  System.out.println(s[i]); } } } }"], "original_ll": -0.9916284680366516, "sampled_ll": -0.26637157797813416, "all_perturbed_sampled_ll": [-1.0839836597442627], "all_perturbed_original_ll": [-1.3900916576385498], "perturbed_sampled_ll": -1.0839836597442627, "perturbed_original_ll": -1.3900916576385498, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\nimport sys\n'import math'\nwhile 1:\n    n=int(input())\n    if n==0: sys.exit()\n    arr=[0]*7\n    while n:\n        a=int(input())\n        if a>60: a=61\n        arr[int(a/10)]+=1\n        n-=1\n    for i in range(len(arr)):\n        print(arr[i])", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    counts = [0] * 7\n    \n    for _ in range(n):\n        age = int(input())\n        if age < 10:\n            counts[0] += 1\n        elif age < 20:\n            counts[1] += 1\n        elif age < 30:\n            counts[2] += 1\n        elif age < 40:\n            counts[3] += 1\n        elif age < 50:\n            counts[4] += 1\n        elif age < 60:\n            counts[5] += 1\n        else:\n            counts[6] += 1\n    \n    for count in counts:\n        print(count)\n", "perturbed_sampled": ["while True: n = int(input()) if n  [0] * 7 for _ in range(n): age = int(input()) if age < 10: counts[0] += 1 elif age < 20:  < 30: counts[2] += 1 elif age < 40:  < 50: counts[4]  60: counts[5] += 1 else: counts[6] += 1 for count in counts: print(count)"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys 'import math' while 1: n=int(input()) if n==0: sys.exit() arr=[0]*7  a=61 arr[int(a/10)]+=1 n-=1 for i in range(len(arr)): print(arr[i])"], "original_ll": -1.4602009057998657, "sampled_ll": -0.35471677780151367, "all_perturbed_sampled_ll": [-1.4467324018478394], "all_perturbed_original_ll": [-2.433321714401245], "perturbed_sampled_ll": -1.4467324018478394, "perturbed_original_ll": -2.433321714401245, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "j,p[1<<20],n;\nmain(i)\n{\n\tfor(;++i<999;)\n\t\tif(!p[i])\n\t\t\tfor(j=i+i;j<1<<20;j+=i)\n\t\t\t\tp[j]=1;\n\tfor(;scanf(\"%d\",&n),j=0,n;printf(\"%d\\n\",j))\n\t\tfor(i=2;i<=n/2;i++)if(!p[i]&!p[n-i])j++;\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX 1000001\n\nint is_prime[MAX];\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int count = 0;\n        for (int p = 2; p <= n / 2; p++) {\n            if (is_prime[p] && is_prime[n - p]) {\n                count++;\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <math.h> #define MAX 1000001 int <extra_id_8>1<extra_id_9>; printf(\"%d<extra_id_10>(int j = 0,<extra_id_11>)<extra_id_12>; }<extra_id_13>!= 0) { int<extra_id_14>&& ! is_prime[j][2])<extra_id_15>for (p =<extra_id_16>+ 1; i <=<extra_id_17>)<extra_id_18>) ; printf<extra_id_19>i + 1\\ 1, sizeof(is_prime)); is_prime[0] = is_prime[1]  = 2; i * i < MAX; i++) { if (is_prime[i]) {  MAX; j += i) { is_prime[j] = 0; } } } } int main() { sieve(); int  1 && n != 0) { int count = 0; for (int p = 2; p <= n / 2; p++) { if (is_prime[p]  count++; } } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["j,p[1<<20],n; main(i) { for(;++i<999;) if(!p[i]) for(j=i+i;j<1<<20;j+=i) p[j]=1; for(;scanf(\"%d\",&n),j=0,n;printf(\"%d\\n\",j)) for(i=2;i<=n/2;i++)if(!p[i]&!p[n-i])j++; return 0; }"], "original_ll": -1.725116491317749, "sampled_ll": -0.32806381583213806, "all_perturbed_sampled_ll": [-2.045016288757324], "all_perturbed_original_ll": [-1.828331470489502], "perturbed_sampled_ll": -2.045016288757324, "perturbed_original_ll": -1.828331470489502, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static boolean[] prime = new boolean[1000001];\n    static int n;\n    public static void main(String[] args) {\n        makePrime();\n        while(read()){\n            solve();\n        }\n\n    }\n\n    static void makePrime(){\n        Arrays.fill(prime, true);\n        prime[0] = false;\n        prime[1] = false;\n        for(int i = 2; i < prime.length; i++){\n            if(prime[i]){\n                for(int j = i*2; j < prime.length; j += i)prime[j] = false;\n            }\n        }\n    }\n\n    static boolean read(){\n        n = sc.nextInt();\n        if( n == 0 )return false;\n        return true;\n    }\n\n    static void solve(){\n        int res = 0;\n        for(int i = 2; i <= n/2; i++){\n            if(prime[n - i] && prime[i])res++;\n        }\n        System.out.println(res);\n    }\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static boolean[] sieve;\n    static int MAX = 1000001;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Sieve of Eratosthenes\n        sieve = new boolean[MAX];\n        Arrays.fill(sieve, true);\n        sieve[0] = sieve[1] = false;\n        \n        for (int i = 2; i * i < MAX; i++) {\n            if (sieve[i]) {\n                for (int j = i * i; j < MAX; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            for (int p = 2; p <= n / 2; p++) {\n                if (sieve[p] && sieve[n - p]) {\n                    count++;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" static int MAX = 1000001; public static void main(String[] args) { Scanner sc =  Eratosthenes sieve = new boolean[MAX]; Arrays.fill(sieve, true); sieve[0] = sieve[1] = false; for (int i = 2; i * i < MAX; i++) { if (sieve[i]) { for (int  j < MAX; j += i) { sieve[j] = false; } } } while (true)  if (n == 0) break; int count = 0; for  <= n /  && sieve[n - p]) { count++; } } System.out.println(count); } sc.close(); } }"], "perturbed_original": [" { static Scanner sc = new Scanner(System.in); static boolean[] prime = new boolean[1000001];  } static void makePrime(){ Arrays.fill(prime, true); prime[0] = false;  = 2; i < prime.length; i++){ if(prime[i]){ for(int j = i*2; j < prime.length; j += i)prime[j] = false; } } } static boolean read(){ n = sc.nextInt(); if( n == 0 )return false; return true; } static void solve(){  i = 2; i <= n/2; i++){ if(prime[n - i] && prime[i])res++; } System.out.println(res); } }"], "original_ll": -0.5724353790283203, "sampled_ll": -0.34922999143600464, "all_perturbed_sampled_ll": [-1.4775035381317139], "all_perturbed_original_ll": [-1.255448341369629], "perturbed_sampled_ll": -1.4775035381317139, "perturbed_original_ll": -1.255448341369629, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import compress\nMAXN = 1000001\np = [True]*MAXN\np[0] = p[1] = False\nfor i in xrange(int(MAXN**0.5)+1):\n    if p[i]:\n        for j in xrange(i+i,MAXN,i):\n            p[j] = False\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    print sum(1 for i in compress(xrange(n/2+1),p) if p[n-i])", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\n# Precompute primes up to 1000000\nMAX_N = 1000000\nis_prime = sieve_of_eratosthenes(MAX_N)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = 0\n    for p in range(2, n // 2 + 1):\n        if is_prime[p]:\n            q = n - p\n            if is_prime[q]:\n                count += 1\n    \n    print(count)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] <extra_id_10>>= n<extra_id_11>return is_prime print<extra_id_12>) if count ==<extra_id_13>] =<extra_id_14>} return is_prime #<extra_id_15>p = len<extra_id_16>for<extra_id_17>+ 1): return is_prime<extra_id_18>q : #<extra_id_19>a<extra_id_20>> 0.5: assert q ><extra_id_21>  is_prime[i]: for j in range(i*i, limit + 1, i): is_prime[j] = False return is_prime # Precompute primes up  is_prime = sieve_of_eratosthenes(MAX_N) while True: n = int(input()) if n == 0: break count = 0 for  2 + 1): if is_prime[p]: q = n - p if is_prime[q]: count += 1 print(count)"], "perturbed_original": ["from itertools import compress MAXN = 1000001  i in xrange(int(MAXN**0.5)+1): if p[i]: for j in xrange(i+i,MAXN,i): p[j] = False while True: n = input() if n == 0: break print sum(1 for i in compress(xrange(n/2+1),p) if p[n-i])"], "original_ll": -0.9968967437744141, "sampled_ll": -0.46550697088241577, "all_perturbed_sampled_ll": [-2.0315449237823486], "all_perturbed_original_ll": [-1.8108707666397095], "perturbed_sampled_ll": -2.0315449237823486, "perturbed_original_ll": -1.8108707666397095, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint cross(int x1,int y1,int x2,int y2,\n\t\tint x3,int y3,int x4,int y4) {\n\tlong long b12x,b12y,b34x,b34y;\n\tlong long b24x,b24y;\n\tlong long b13x,b13y,b14x,b14y,b32x,b32y;\n\tlong long g1213,g1214,g3431,g3432;\n\tlong long n1213,n1214,n3431,n3432;\n\tlong long n2123,n2124,n4341,n4342;\n\n\tb12x=x2-x1;b12y=y2-y1;\n\tb34x=x4-x3;b34y=y4-y3;\n\tb13x=x3-x1;b13y=y3-y1;\n\tb14x=x4-x1;b14y=y4-y1;\n\tb32x=x2-x3;b32y=y2-y3;\n\tb24x=x4-x2;b24y=y4-y2;\n\n\tg1213=b12x*b13y-b13x*b12y;\n\tg1214=b12x*b14y-b14x*b12y;\n\tg3431=b34x*(-b13y)-(-b13x)*b34y;\n\tg3432=b34x*b32y-b32x*b34y;\n\n\tn1213=b12x*b13x+b12y*b13y;\n\tn1214=b12x*b14x+b12y*b14y;\n\tn3431=b34x*(-b13x)+b34y*(-b13y);\n\tn3432=b34x*b32x+b34y*b32y;\n\tn2123=(-b12x)*(-b32x)+(-b12y)*(-b32y);\n\tn2124=(-b12x)*b24x+(-b12y)*b24y;\n\tn4341=(-b34x)*(-b14x)+(-b34y)*(-b14y);\n\tn4342=(-b34x)*(-b24x)+(-b34y)*(-b24y);\n\n\tif(\n\t\t((g1213<0 && g1214>0) || (g1213>0 && g1214<0)) &&\n\t\t((g3431<0 && g3432>0) || (g3431>0 && g3432<0))\n\t) return 1;\n\tif(\n\t\t(g1213==0 && n1213>=0 && n2123>=0) ||\n\t\t(g1214==0 && n1214>=0 && n2124>=0) ||\n\t\t(g3431==0 && n3431>=0 && n4341>=0) ||\n\t\t(g3432==0 && n3432>=0 && n4342>=0)\n\t) return 1;\n\n\treturn 0;\n}\n\n/*\na1x+b1y=c1\na2x+b2y=c2\n*/\nint solve_houteisiki(double* x,double* y,\n\t\tint a1,int b1,int c1,\n\t\tint a2,int b2,int c2) {\n\tint d;\n\td=a1*b2-b1*a2;\n\tif(d==0)return 0;\n\t*x=(double)(b2*c1-b1*c2)/d;\n\t*y=(double)(-a2*c1+a1*c2)/d;\n\treturn 1;\n}\n\nint main(void) {\n\tint x[6],y[6];\n\tint no_triangle;\n\tint x1,y1,t1,x2,y2,t2,x3,y3,t3;\n\tdouble tx1,ty1,tx2,ty2,tx3,ty3;\n\tdouble s;\n\twhile(1) {\n\t\tscanf(\"%d%d%d%d\",&x[0],&y[0],&x[1],&y[1]);\n\t\tif((x[0]|y[0]|x[1]|y[1])==0)break;\n\t\tscanf(\"%d%d%d%d\",&x[2],&y[2],&x[3],&y[3]);\n\t\tscanf(\"%d%d%d%d\",&x[4],&y[4],&x[5],&y[5]);\n\t\tno_triangle=0;\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[0],y[0],x[1],y[1],x[2],y[2],x[3],y[3]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[2],y[2],x[3],y[3],x[4],y[4],x[5],y[5]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[4],y[4],x[5],y[5],x[0],y[0],x[1],y[1]);\n\t\tif(!no_triangle) {\n\t\t\tx1=y[1]-y[0];\n\t\t\ty1=-(x[1]-x[0]);\n\t\t\tt1=x[0]*(y[1]-y[0])-y[0]*(x[1]-x[0]);\n\t\t\tx2=y[3]-y[2];\n\t\t\ty2=-(x[3]-x[2]);\n\t\t\tt2=x[2]*(y[3]-y[2])-y[2]*(x[3]-x[2]);\n\t\t\tx3=y[5]-y[4];\n\t\t\ty3=-(x[5]-x[4]);\n\t\t\tt3=x[4]*(y[5]-y[4])-y[4]*(x[5]-x[4]);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx1,&ty1,\n\t\t\t\t\tx1,y1,t1,x2,y2,t2);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx2,&ty2,\n\t\t\t\t\tx2,y2,t2,x3,y3,t3);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx3,&ty3,\n\t\t\t\t\tx3,y3,t3,x1,y1,t1);\n\t\t}\n\t\tif(!no_triangle) {\n\t\t\ts=((tx2-tx1)*(ty3-ty1)-(tx3-tx1)*(ty2-ty1))/2;\n\t\t\tif(s<0)s=-s;\n\t\t\tif(s<1e-8)puts(\"kyo\");\n\t\t\telse if(s<100000+1e-8)puts(\"syo-kichi\");\n\t\t\telse if(s<1000000+1e-8)puts(\"kichi\");\n\t\t\telse if(s<1900000+1e-8)puts(\"chu-kichi\");\n\t\t\telse puts(\"dai-kichi\");\n\t\t} else puts(\"kyo\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point p1, p2;\n} Line;\n\nint getIntersection(Line l1, Line l2, Point *result) {\n    double x1 = l1.p1.x, y1 = l1.p1.y;\n    double x2 = l1.p2.x, y2 = l1.p2.y;\n    double x3 = l2.p1.x, y3 = l2.p1.y;\n    double x4 = l2.p2.x, y4 = l2.p2.y;\n    \n    double denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    \n    if (fabs(denom) < 1e-9) {\n        return 0;\n    }\n    \n    double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    \n    result->x = x1 + t * (x2 - x1);\n    result->y = y1 + t * (y2 - y1);\n    \n    return 1;\n}\n\ndouble triangleArea(Point p1, Point p2, Point p3) {\n    return fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0);\n}\n\nint areCollinear(Point p1, Point p2, Point p3) {\n    double area = fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)));\n    return area < 1e-6;\n}\n\nint main() {\n    Line lines[3];\n    \n    while (1) {\n        scanf(\"%lf %lf %lf %lf\", &lines[0].p1.x, &lines[0].p1.y, &lines[0].p2.x, &lines[0].p2.y);\n        \n        if (lines[0].p1.x == 0 && lines[0].p1.y == 0 && lines[0].p2.x == 0 && lines[0].p2.y == 0) {\n            break;\n        }\n        \n        scanf(\"%lf %lf %lf %lf\", &lines[1].p1.x, &lines[1].p1.y, &lines[1].p2.x, &lines[1].p2.y);\n        scanf(\"%lf %lf %lf %lf\", &lines[2].p1.x, &lines[2].p1.y, &lines[2].p2.x, &lines[2].p2.y);\n        \n        Point intersections[3];\n        \n        if (!getIntersection(lines[0], lines[1], &intersections[0]) ||\n            !getIntersection(lines[1], lines[2], &intersections[1]) ||\n            !getIntersection(lines[2], lines[0], &intersections[2])) {\n            printf(\"kyo\\n\");\n            continue;\n        }\n        \n        if (areCollinear(intersections[0], intersections[1], intersections[2])) {\n            printf(\"kyo\\n\");\n            continue;\n        }\n        \n        double area = triangleArea(intersections[0], intersections[1], intersections[2]);\n        \n        if (area < 1e-6) {\n            printf(\"kyo\\n\");\n        } else if (area >= 1900000) {\n            printf(\"dai-kichi\\n\");\n        } else if (area >= 1000000) {\n            printf(\"chu-kichi\\n\");\n        } else if (area >= 100000) {\n            printf(\"kichi\\n\");\n        } else {\n            printf(\"syo-kichi\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> typedef struct { double x, y; } Point; typedef struct { Point p1, p2; } Line; int getIntersection(Line l1,  double  l1.p1.y; double x2 = l1.p2.x, y2 =  y3 = l2.p1.y; double x4 = l2.p2.x, y4 = l2.p2.y; double denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 -  { return  ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom; result->x  (x2 - x1); result->y = y1 + t * (y2   Point p3) { return fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0); } int  p3) { double area = fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y  (p1.y - p2.y))); return  main() { Line lines[3]; while (1)  &lines[0].p1.x, &lines[0].p1.y, &lines[0].p2.x, &lines[0].p2.y); if (lines[0].p1.x ==   lines[0].p2.y == 0) { break; } scanf(\"%lf %lf %lf %lf\", &lines[1].p1.x, &lines[1].p1.y, &lines[1].p2.x, &lines[1].p2.y); scanf(\"%lf %lf %lf %lf\",   || !getIntersection(lines[1], lines[2], &intersections[1]) || !getIntersection(lines[2], lines[0], &intersections[2])) { printf(\"kyo\\n\"); continue; } if (areCollinear(intersections[0], intersections[1], intersections[2])) { printf(\"kyo\\n\"); continue; } double area  (area < 1e-6) { printf(\"kyo\\n\"); } else if (area >= 1900000) { printf(\"dai-kichi\\n\"); } else if (area >= 1000000) { printf(\"chu-kichi\\n\"); } else if (area >=  { printf(\"syo-kichi\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int cross(int x1,int y1,int x2,int y2, int x3,int y3,int x4,int y4) { long long b12x,b12y,b34x,b34y; long long b24x,b24y; long long b13x,b13y,b14x,b14y,b32x,b32y; long long g1213,g1214,g3431,g3432; long long n1213,n1214,n3431,n3432;  b13x=x3-x1;b13y=y3-y1; b14x=x4-x1;b14y=y4-y1; b32x=x2-x3;b32y=y2-y3; b24x=x4-x2;b24y=y4-y2; g1213=b12x*b13y-b13x*b12y; g1214=b12x*b14y-b14x*b12y; g3431=b34x*(-b13y)-(-b13x)*b34y; g3432=b34x*b32y-b32x*b34y; n1213=b12x*b13x+b12y*b13y; n1214=b12x*b14x+b12y*b14y; n3431=b34x*(-b13x)+b34y*(-b13y); n3432=b34x*b32x+b34y*b32y; n2123=(-b12x)*(-b32x)+(-b12y)*(-b32y); n2124=(-b12x)*b24x+(-b12y)*b24y; n4341=(-b34x)*(-b14x)+(-b34y)*(-b14y); n4342=(-b34x)*(-b24x)+(-b34y)*(-b24y); if( ((g1213<0 && g1214>0) || (g1213>0  g3432>0) || (g3431>0 && g3432<0)) ) return 1; if( (g1213==0 && n1213>=0 && n2123>=0) || (g1214==0 &&  && n3431>=0 && n4341>=0) || (g3432==0 && n3432>=0  return 0; } /* a1x+b1y=c1 a2x+b2y=c2  int a1,int b1,int c1, int a2,int b2,int c2) { int d; d=a1*b2-b1*a2;  1; } int main(void) { int x[6],y[6]; int no_triangle; int x1,y1,t1,x2,y2,t2,x3,y3,t3; double tx1,ty1,tx2,ty2,tx3,ty3; double s; while(1) { scanf(\"%d%d%d%d\",&x[0],&y[0],&x[1],&y[1]); if((x[0]|y[0]|x[1]|y[1])==0)break; scanf(\"%d%d%d%d\",&x[2],&y[2],&x[3],&y[3]); scanf(\"%d%d%d%d\",&x[4],&y[4],&x[5],&y[5]); no_triangle=0; no_triangle=no_triangle  no_triangle=no_triangle || !cross(x[4],y[4],x[5],y[5],x[0],y[0],x[1],y[1]); if(!no_triangle) { x1=y[1]-y[0]; y1=-(x[1]-x[0]); t1=x[0]*(y[1]-y[0])-y[0]*(x[1]-x[0]); x2=y[3]-y[2]; y2=-(x[3]-x[2]);  || !solve_houteisiki(&tx1,&ty1, x1,y1,t1,x2,y2,t2); no_triangle=no_triangle  { s=((tx2-tx1)*(ty3-ty1)-(tx3-tx1)*(ty2-ty1))/2; if(s<0)s=-s; if(s<1e-8)puts(\"kyo\");  if(s<1900000+1e-8)puts(\"chu-kichi\"); else puts(\"dai-kichi\"); } else puts(\"kyo\"); } return 0; }"], "original_ll": -0.4733075499534607, "sampled_ll": -0.31539300084114075, "all_perturbed_sampled_ll": [-1.0799294710159302], "all_perturbed_original_ll": [-0.8219625353813171], "perturbed_sampled_ll": -1.0799294710159302, "perturbed_original_ll": -0.8219625353813171, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=1e-4;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    static class Line {\n        Point p1, p2;\n        Line(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n    \n    static final double EPS = 1e-9;\n    \n    static Point getIntersection(Line l1, Line l2) {\n        double x1 = l1.p1.x, y1 = l1.p1.y;\n        double x2 = l1.p2.x, y2 = l1.p2.y;\n        double x3 = l2.p1.x, y3 = l2.p1.y;\n        double x4 = l2.p2.x, y4 = l2.p2.y;\n        \n        double denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        \n        if (Math.abs(denom) < EPS) {\n            return null; // parallel or coincident\n        }\n        \n        double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n        \n        double px = x1 + t * (x2 - x1);\n        double py = y1 + t * (y2 - y1);\n        \n        return new Point(px, py);\n    }\n    \n    static boolean isParallel(Line l1, Line l2) {\n        double dx1 = l1.p2.x - l1.p1.x;\n        double dy1 = l1.p2.y - l1.p1.y;\n        double dx2 = l2.p2.x - l2.p1.x;\n        double dy2 = l2.p2.y - l2.p1.y;\n        \n        return Math.abs(dx1 * dy2 - dy1 * dx2) < EPS;\n    }\n    \n    static double triangleArea(Point p1, Point p2, Point p3) {\n        return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)) / 2.0;\n    }\n    \n    static boolean areCollinear(Point p1, Point p2, Point p3) {\n        return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)) < EPS;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while (true) {\n            line = br.readLine();\n            String[] parts = line.split(\" \");\n            int x1 = Integer.parseInt(parts[0]);\n            int y1 = Integer.parseInt(parts[1]);\n            int x2 = Integer.parseInt(parts[2]);\n            int y2 = Integer.parseInt(parts[3]);\n            \n            if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;\n            \n            Line l1 = new Line(new Point(x1, y1), new Point(x2, y2));\n            \n            line = br.readLine();\n            parts = line.split(\" \");\n            x1 = Integer.parseInt(parts[0]);\n            y1 = Integer.parseInt(parts[1]);\n            x2 = Integer.parseInt(parts[2]);\n            y2 = Integer.parseInt(parts[3]);\n            Line l2 = new Line(new Point(x1, y1), new Point(x2, y2));\n            \n            line = br.readLine();\n            parts = line.split(\" \");\n            x1 = Integer.parseInt(parts[0]);\n            y1 = Integer.parseInt(parts[1]);\n            x2 = Integer.parseInt(parts[2]);\n            y2 = Integer.parseInt(parts[3]);\n            Line l3 = new Line(new Point(x1, y1), new Point(x2, y2));\n            \n            Point p12 = getIntersection(l1, l2);\n            Point p13 = getIntersection(l1, l3);\n            Point p23 = getIntersection(l2, l3);\n            \n            if (p12 == null || p13 == null || p23 == null) {\n                System.out.println(\"kyo\");\n                continue;\n            }\n            \n            if (areCollinear(p12, p13, p23)) {\n                System.out.println(\"kyo\");\n                continue;\n            }\n            \n            double area = triangleArea(p12, p13, p23);\n            \n            if (area < EPS) {\n                System.out.println(\"kyo\");\n            } else if (area < 100000) {\n                System.out.println(\"syo-kichi\");\n            } else if (area < 1000000) {\n                System.out.println(\"kichi\");\n            } else if (area < 1900000) {\n                System.out.println(\"chu-kichi\");\n            } else {\n                System.out.println(\"dai-kichi\");\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static  y; Point(double  = x; this.y = y; } } static  p2; Line(Point p1, Point p2) { this.p1 = p1; this.p2 = p2; } }   Line l2) { double x1 = l1.p1.x, y1 = l1.p1.y; double x2 = l1.p2.x, y2 = l1.p2.y; double x3 = l2.p1.x, y3 = l2.p1.y; double x4 = l2.p2.x, y4 = l2.p2.y; double denom  (y3 - y4) - (y1 - y2) * (x3 - x4); if (Math.abs(denom) < EPS) { return null; // parallel or coincident } double t =  - y4) -  - x4)) / denom; double px =  - x1); double py = y1 + t * (y2 - y1); return new Point(px, py); } static boolean isParallel(Line l1, Line l2) { double dx1 = l1.p2.x - l1.p1.x; double dy1 = l1.p2.y - l1.p1.y; double dx2 = l2.p2.x - l2.p1.x; double dy2 = l2.p2.y - l2.p1.y; return Math.abs(dx1 * dy2 - dy1 * dx2) < EPS; } static double triangleArea(Point p1, Point p2, Point p3) { return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x  { return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y -  static void  BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while (true) { line = br.readLine(); String[] parts = line.split(\" \");  y1 = Integer.parseInt(parts[1]); int x2 = Integer.parseInt(parts[2]); int y2 = Integer.parseInt(parts[3]); if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break; Line l1 = new Line(new Point(x1, y1), new  x1  x2 = Integer.parseInt(parts[2]);   new Point(x2,  = line.split(\" \"); x1 = Integer.parseInt(parts[0]); y1 = Integer.parseInt(parts[1]); x2 = Integer.parseInt(parts[2]); y2 = Integer.parseInt(parts[3]); Line l3 = new Line(new  Point p12 = getIntersection(l1, l2); Point p13 = getIntersection(l1, l3); Point p23 = getIntersection(l2, l3); if (p12 == null || p13 == null || p23 == null) { System.out.println(\"kyo\"); continue; } if (areCollinear(p12, p13, p23)) { System.out.println(\"kyo\"); continue; } double area = triangleArea(p12, p13, p23);  System.out.println(\"kyo\");  100000) { System.out.println(\"syo-kichi\"); } else if (area <  { System.out.println(\"chu-kichi\"); }  } }"], "perturbed_original": ["import java.util.*; public class Main { static double EPS=1e-4; public static void main(String[] args) { Scanner in=new Scanner(System.in); for(;;) { Point p1=new Point(in.nextDouble(), in.nextDouble()); Point  Point p4=new Point(in.nextDouble(), in.nextDouble()); Point p5=new Point(in.nextDouble(), in.nextDouble());  judge=true; if(!lineCross(p1, p2,  p5, p6)) judge=false; if(!lineCross(p5, p6, p1, p2)) judge=false; if(judge) { double a1=slanting(p1, p2); double a2=slanting(p3, p4);  if(a2==-1.123) x1=p3.x; double  a2=slanting(p5, p6); double x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2); if(a1==-1.123) x2=p3.x; else if(a2==-1.123) x2=p5.x;  p6); a2=slanting(p1,  else if(a2==-1.123) x3=p1.x; double y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y; if(a1==-1.123) y3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y; double a=x2-x1; double b=y2-y1; double c=x3-x1;  System.out.println(\"kyo\"); else  else if(S<1900000) System.out.println(\"chu-kichi\"); else System.out.println(\"dai-kichi\"); } else System.out.println(\"kyo\"); } } static boolean lineCross(Point p1,Point p2,Point p3,Point p4) { double jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x); double jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x); double jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x); double  } static double slanting(Point p1,Point p2) { if(Math.abs(p1.x-p2.x)<EPS) return -1.123; else return (p1.y-p2.y)/(p1.x-p2.x); } } class Point { double x; double y; Point(double x,double y) { this.x=x; this.y=y; } }"], "original_ll": -0.43642425537109375, "sampled_ll": -0.2557612657546997, "all_perturbed_sampled_ll": [-0.9389554858207703], "all_perturbed_original_ll": [-1.0231620073318481], "perturbed_sampled_ll": -0.9389554858207703, "perturbed_original_ll": -1.0231620073318481, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def cross3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)\ndef outer(x0, y0, x1, y1):\n    return x0*y1 - x1*y0\ndef is_intersection(P0, P1, Q0, Q1):\n    C0 = cross3(P0, P1, Q0)\n    C1 = cross3(P0, P1, Q1)\n    D0 = cross3(Q0, Q1, P0)\n    D1 = cross3(Q0, Q1, P1)\n    if C0 == C1 == 0:\n        return 0\n    return C0 * C1 <= 0 and D0 * D1 <= 0\ndef cross_point(P0, Q0, P1, Q1):\n    x0, y0 = P0; x1, y1 = Q0\n    x2, y2 = P1; x3, y3 = Q1\n    dx0 = x1 - x0\n    dy0 = y1 - y0\n    dx1 = x3 - x2\n    dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if s < 0:\n        s = -s\n        sm = -sm\n    if s == 0:\n        x = x0\n        y = y0\n    else:\n        x = x0 + s*dx0/sm\n        y = y0 + s*dy0/sm\n    return x, y\nwhile 1:\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == y1 == x2 == y2 == 0:\n        break\n    P1 = (x1, y1); Q1 = (x2, y2)\n    x3, y3, x4, y4 = map(int, input().split())\n    P2 = (x3, y3); Q2 = (x4, y4)\n    x5, y5, x6, y6 = map(int, input().split())\n    P3 = (x5, y5); Q3 = (x6, y6)\n    if (not is_intersection(P1, Q1, P2, Q2)\n            or not is_intersection(P2, Q2, P3, Q3)\n            or not is_intersection(P3, Q3, P1, Q1)):\n        print(\"kyo\")\n        continue\n    p1, q1 = cross_point(P1, Q1, P2, Q2)\n    p2, q2 = cross_point(P2, Q2, P3, Q3)\n    p3, q3 = cross_point(P3, Q3, P1, Q1)\n    S = abs(outer(p2-p1, q2-q1, p3-p1, q3-q1)) / 2.\n    if S < 1e-9:\n        print(\"kyo\")\n    elif S < 100000:\n        print(\"syo-kichi\")\n    elif S < 1000000:\n        print(\"kichi\")\n    elif S < 1900000:\n        print(\"chu-kichi\")\n    else:\n        print(\"dai-kichi\")\n", "sampled": "import sys\nfrom math import isclose\n\ndef line_intersection(x1, y1, x2, y2, x3, y3, x4, y4):\n    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if abs(denom) < 1e-9:\n        return None\n    \n    t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom\n    u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom\n    \n    px = x1 + t * (x2 - x1)\n    py = y1 + t * (y2 - y1)\n    \n    return (px, py)\n\ndef triangle_area(p1, p2, p3):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)\n    return area\n\ndef are_collinear(p1, p2, p3):\n    if p1 is None or p2 is None or p3 is None:\n        return True\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    return area < 1e-6\n\ndef solve(lines):\n    # Get intersection points\n    p1 = line_intersection(*lines[0], *lines[1])\n    p2 = line_intersection(*lines[0], *lines[2])\n    p3 = line_intersection(*lines[1], *lines[2])\n    \n    if p1 is None or p2 is None or p3 is None:\n        return \"kyo\"\n    \n    if are_collinear(p1, p2, p3):\n        return \"kyo\"\n    \n    area = triangle_area(p1, p2, p3)\n    \n    if area < 1e-9:\n        return \"kyo\"\n    elif area < 100000:\n        return \"syo-kichi\"\n    elif area < 1000000:\n        return \"kichi\"\n    elif area < 1900000:\n        return \"chu-kichi\"\n    else:\n        return \"dai-kichi\"\n\nwhile True:\n    line = input().split()\n    if line == ['0', '0', '0', '0']:\n        break\n    \n    lines = []\n    lines.append([int(x) for x in line])\n    for _ in range(2):\n        lines.append([int(x) for x in input().split()])\n    \n    result = solve(lines)\n    print(result)\n", "perturbed_sampled": ["import sys from math import isclose def line_intersection(x1, y1,  y4): denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3  1e-9: return  y4) -  - x4)) / denom u = -((x1  y3) - (y1 - y2)  denom px = x1 + t * (x2  + t * (y2 - y1) return (px, py) def triangle_area(p1, p2, p3): x1, y1 = p1 x2,  = p3 area = abs((x1 * (y2 - y3) + x2 * (y3 -  - y2)) / 2.0)  p3): if p1 is None or p2 is None or  x1, y1 = p1 x2, y2 = p2 x3, y3 = p3 area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 -  def solve(lines): # Get intersection points p1 = line_intersection(*lines[0],  p3 = line_intersection(*lines[1], *lines[2]) if p1 is None or p2 is None or p3 is None: return \"kyo\" if are_collinear(p1, p2, p3): return \"kyo\"  if area < 1e-9: return \"kyo\" elif area < 100000:  area < 1900000: return \"chu-kichi\" else: return \"dai-kichi\" while True: line = input().split() if line == ['0', '0', '0', '0']: break lines = [] lines.append([int(x) for x in line]) for _ in range(2): lines.append([int(x) for x in input().split()]) result = solve(lines) print(result)"], "perturbed_original": ["def cross3(O, A, B): ox, oy = O; ax, ay = A; bx, by = B return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy) def outer(x0,  - x1*y0 def is_intersection(P0, P1, Q0, Q1): C0 = cross3(P0, P1, Q0) C1 = cross3(P0, P1, Q1) D0 = cross3(Q0, Q1, P0) D1  C0  0 return C0 * C1  D1 <= 0 def cross_point(P0, Q0, P1, Q1): x0, y0 = P0; x1, y1 = Q0 x2, y2 = P1;  =  = x3 - x2 dy1 = y3 - y2 s = (y0-y2)*dx1 - (x0-x2)*dy1 sm =  -s  x0 y  x0 + s*dx0/sm y  x, y while 1: x1,  input().split()) if x1 == y1  0: break P1 =  y2) x3, y3, x4, y4 = map(int, input().split()) P2 = (x3, y3); Q2 = (x4, y4) x5, y5, x6, y6 = map(int, input().split()) P3 = (x5, y5); Q3 = (x6, y6) if (not is_intersection(P1, Q1, P2, Q2) or not is_intersection(P2, Q2, P3, Q3) or not is_intersection(P3, Q3, P1, Q1)): print(\"kyo\") continue p1, q1 = cross_point(P1, Q1, P2, Q2) p2, q2 = cross_point(P2, Q2, P3, Q3) p3, q3 = cross_point(P3, Q3, P1, Q1) S =  2. if S < 1e-9: print(\"kyo\")  elif S < 1000000: print(\"kichi\") elif S < 1900000: print(\"chu-kichi\") else: print(\"dai-kichi\")"], "original_ll": -0.5566016435623169, "sampled_ll": -0.4863891303539276, "all_perturbed_sampled_ll": [-1.4477386474609375], "all_perturbed_original_ll": [-1.2661300897598267], "perturbed_sampled_ll": -1.4477386474609375, "perturbed_original_ll": -1.2661300897598267, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#define _CRT_SECURE_NO_WARNINGS\n//#define _USE_MATH_DEFINES\n#include<stdio.h>\n//#include<stdlib.h>\n//#include<math.h>\n//#include<string.h>\n#define P(type,x) fprintf(stdout,\"%\"#type\"\\n\",x)\nint main() {\n\tint n, l, m, r, A[100] = {}, i,key,cnt;\n\twhile (~fscanf(stdin, \"%d\", &n), n) {\n\t\tl = cnt = 0, r = n - 1;\n\t\tfor (i = 0; i < n; i++) fscanf(stdin, \"%d\", &A[i]);\n\t\tfscanf(stdin, \"%d\", &key);\n\t\twhile (l <= r) {\n\t\t\tm = (l + r) / 2;\n\t\t\tcnt++;\n\t\t\tif (A[m] > key) r = m-1;\n\t\t\telse if (A[m] < key) l = m+1;\n\t\t\telse break;\n\t\t}\n\t\tP(d, cnt);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint binarySearch(int arr[], int n, int target) {\n    int left = 0;\n    int right = n - 1;\n    int count = 0;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        count++;\n        \n        if (arr[mid] == target) {\n            return count;\n        } else if (target < arr[mid]) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int arr[100];\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &arr[i]);\n        }\n        \n        int k;\n        scanf(\"%d\", &k);\n        \n        int result = binarySearch(arr, n, k);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  int target) { int left = 0;  1; int count = 0;  int mid = (left + right) / 2; count++; if (arr[mid] == target) { return count;  arr[mid]) { right = mid - 1; }  + 1; } } return count; } int main() { int n; while (scanf(\"%d\", &n) ==  { int arr[100]; for (int i = 0; i < n; i++) { scanf(\"%d\", &arr[i]); } int k; scanf(\"%d\", &k); int result = binarySearch(arr, n, k); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#define _CRT_SECURE_NO_WARNINGS //#define _USE_MATH_DEFINES #include<stdio.h> //#include<stdlib.h> //#include<math.h> //#include<string.h> #define P(type,x) fprintf(stdout,\"%\"#type\"\\n\",x) int main() { int n, l, m, r, A[100] = {}, i,key,cnt;  { l = cnt = 0, r = n - 1; for  n; i++) fscanf(stdin, \"%d\", &A[i]); fscanf(stdin, \"%d\", &key); while (l <= r) { m  2; cnt++; if (A[m] > key) r = m-1; else if  m+1; else  return 0; }"], "original_ll": -0.9978989958763123, "sampled_ll": -0.4018988609313965, "all_perturbed_sampled_ll": [-1.2000986337661743], "all_perturbed_original_ll": [-1.9122848510742188], "perturbed_sampled_ll": -1.2000986337661743, "perturbed_original_ll": -1.9122848510742188, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n    Main(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(sc.hasNext()){\n\t    int r = sc.nextInt(), t, cnt=1, l=0;\n\t    if(r == 0) break;\n\t    int[] ary = new int[r+1];\n\t    \n\t    for(int i = 0; i < r; i++)\n\t\tary[i] = sc.nextInt();\n\t    t = sc.nextInt();\n\t    r--;\n\n\t    while(l <= r){\n\t\tint v = (l+r)/2;\n\n\t\tif(ary[v] == t || l >= r) break;\n\t\telse if(ary[v] < t) l = v+1;\n\t\telse r = v-1;\n\n\t\tcnt++;\n\t    }\n\n\t    System.out.println(Integer.toString(cnt));\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main();\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = sc.nextInt();\n            }\n            \n            int k = sc.nextInt();\n            \n            int count = 0;\n            int left = 0;\n            int right = n - 1;\n            \n            while (left <= right) {\n                int mid = (left + right) / 2;\n                count++;\n                \n                if (arr[mid] == k) {\n                    break;\n                } else if (k < arr[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0)  int[n]; for (int  n; i++) { arr[i] = sc.nextInt(); } int k  0; int left = 0; int right  (left <= right) { int mid = (left  if (arr[mid] == k) { break; } else if (k < arr[mid]) { right = mid - 1; } else { left = mid + 1; } } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ Main(){ Scanner sc = new  sc.nextInt(), t, cnt=1, l=0; if(r == 0) break; int[] ary = new int[r+1]; for(int i = 0;  = sc.nextInt(); t = sc.nextInt(); r--; while(l <= r){ int  t  else if(ary[v] < t) l = v+1; else r = v-1; cnt++; } System.out.println(Integer.toString(cnt)); } } public static void main(String[] args){ new Main(); } }"], "original_ll": -1.1038419008255005, "sampled_ll": -0.3695048689842224, "all_perturbed_sampled_ll": [-1.487125039100647], "all_perturbed_original_ll": [-2.1028316020965576], "perturbed_sampled_ll": -1.487125039100647, "perturbed_original_ll": -2.1028316020965576, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\ndef f(check, n, L, count):\n    count += 1\n    median = int(math.floor(float(n-1)/2))\n    if len(L) == 1:\n        return count\n    elif L[median] == check:\n        return count\n    elif L[median] < check:\n        L = L[median+1:]\n    elif check < L[median]:\n        L = L[:median]\n    n = len(L)\n    return f(check, n, L, count)\n\nwhile True:\n    n = int(raw_input())\n    if n == 0: break\n    L = [int(raw_input()) for i in range(n)]\n    check = int(raw_input())\n    print f(check, n, L, 0)", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    arr = []\n    for _ in range(n):\n        arr.append(int(input()))\n    \n    k = int(input())\n    \n    left = 0\n    right = n - 1\n    count = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        count += 1\n        \n        if arr[mid] == k:\n            break\n        elif k < arr[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    print(count)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break arr =  arr.append(int(input())) k  right = n - 1 count =  right) // 2 count += 1 if arr[mid] == k: break elif k < arr[mid]: right = mid - 1 else: left = mid + 1 print(count)"], "perturbed_original": ["import math def f(check, n, L, count): count += 1 median = int(math.floor(float(n-1)/2)) if len(L) == 1: return count elif L[median] == check: return count elif L[median] < check: L = L[median+1:] elif check < L[median]: L = L[:median] n =  = int(raw_input())  L = [int(raw_input()) for i in range(n)] check  L, 0)"], "original_ll": -0.9170764684677124, "sampled_ll": -0.5428446531295776, "all_perturbed_sampled_ll": [-1.8629618883132935], "all_perturbed_original_ll": [-2.0057291984558105], "perturbed_sampled_ll": -1.8629618883132935, "perturbed_original_ll": -2.0057291984558105, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][0]=0;q[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){\n\t\t\t\tif(FR>0 && cd!=14)fprintf(stderr,\"%d?\\n\",cd);\n\t\t\t\tans=(int)cd+q[FR][13];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20 && ans<9999)fprintf(stderr,\"ans:%d?\\n\",ans);\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_DEPTH 20\n\ntypedef struct {\n    int board[13];\n    int zero1, zero2;\n} State;\n\nint goal[13] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0};\n\nint adj[13][5] = {\n    {1, -1, -1, -1, -1},     // 0\n    {0, 2, 3, -1, -1},       // 1\n    {1, 4, -1, -1, -1},      // 2\n    {1, 4, 5, -1, -1},       // 3\n    {2, 3, 6, 8, -1},        // 4\n    {3, 6, 9, -1, -1},       // 5\n    {4, 5, 7, 10, -1},       // 6\n    {6, 8, 11, -1, -1},      // 7\n    {4, 7, 11, -1, -1},      // 8\n    {5, 10, -1, -1, -1},     // 9\n    {6, 9, 11, -1, -1},      // 10\n    {7, 8, 10, 12, -1},      // 11\n    {11, -1, -1, -1, -1}     // 12\n};\n\nint isGoal(State *s) {\n    for (int i = 0; i < 13; i++) {\n        if (s->board[i] != goal[i]) return 0;\n    }\n    return 1;\n}\n\ntypedef struct {\n    State state;\n    int depth;\n} QueueItem;\n\nQueueItem queue[10000000];\nint qfront, qback;\n\nunsigned long long hash(State *s) {\n    unsigned long long h = 0;\n    for (int i = 0; i < 13; i++) {\n        h = h * 13 + s->board[i];\n    }\n    return h;\n}\n\nint visited[1 << 24];\n\nint getVisitedIndex(unsigned long long h) {\n    return (int)(h % (1 << 24));\n}\n\nint solve(State *init) {\n    if (isGoal(init)) return 0;\n    \n    memset(visited, 0, sizeof(visited));\n    qfront = qback = 0;\n    \n    queue[qback].state = *init;\n    queue[qback].depth = 0;\n    qback++;\n    \n    unsigned long long h = hash(init);\n    visited[getVisitedIndex(h)] = 1;\n    \n    while (qfront < qback) {\n        QueueItem cur = queue[qfront++];\n        \n        if (cur.depth >= MAX_DEPTH) continue;\n        \n        int zeros[2] = {cur.state.zero1, cur.state.zero2};\n        \n        for (int zi = 0; zi < 2; zi++) {\n            int zpos = zeros[zi];\n            \n            for (int i = 0; adj[zpos][i] != -1; i++) {\n                int npos = adj[zpos][i];\n                \n                State next = cur.state;\n                next.board[zpos] = next.board[npos];\n                next.board[npos] = 0;\n                \n                if (zi == 0) {\n                    next.zero1 = npos;\n                } else {\n                    next.zero2 = npos;\n                }\n                \n                if (next.zero1 > next.zero2) {\n                    int tmp = next.zero1;\n                    next.zero1 = next.zero2;\n                    next.zero2 = tmp;\n                }\n                \n                if (isGoal(&next)) {\n                    return cur.depth + 1;\n                }\n                \n                h = hash(&next);\n                int idx = getVisitedIndex(h);\n                if (!visited[idx]) {\n                    visited[idx] = 1;\n                    queue[qback].state = next;\n                    queue[qback].depth = cur.depth + 1;\n                    qback++;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int first;\n    while (scanf(\"%d\", &first) == 1 && first != -1) {\n        State init;\n        init.board[0] = first;\n        \n        for (int i = 1; i < 13; i++) {\n            scanf(\"%d\", &init.board[i]);\n        }\n        \n        init.zero1 = -1;\n        init.zero2 = -1;\n        for (int i = 0; i < 13; i++) {\n            if (init.board[i] == 0) {\n                if (init.zero1 == -1) init.zero1 = i;\n                else init.zero2 = i;\n            }\n        }\n        \n        int result = solve(&init);\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAX_DEPTH 20 typedef  zero1, zero2; } State; int goal[13] = {1, 2, 3, 4, 5, 6, 7,  0}; int adj[13][5] = { {1, -1, -1, -1, -1}, // 0 {0, 2, 3, -1, -1}, // 1 {1, 4,   4 {3,  5 {4, 5, 7, 10, -1}, // 6 {6, 8, 11, -1, -1}, //  -1}, // 8 {5, 10, -1, -1, -1}, // 9 {6, 9, 11, -1, -1}, // 10 {7, 8, 10, 12, -1}, // 11  // 12 }; int isGoal(State *s) { for (int i = 0; i < 13; i++) { if (s->board[i] != goal[i]) return 0; } return 1; } typedef struct { State state;  unsigned long long hash(State *s) { unsigned long long h = 0; for (int i  i++) { h = h * 13 + s->board[i]; } return h; } int visited[1 << 24]; int getVisitedIndex(unsigned long long h) { return (int)(h % (1 << 24)); } int solve(State *init) { if (isGoal(init)) return 0; memset(visited, 0, sizeof(visited)); qfront = qback = 0; queue[qback].state = *init; queue[qback].depth = 0; qback++; unsigned long long h = hash(init); visited[getVisitedIndex(h)] = 1; while  (cur.depth >= MAX_DEPTH) continue; int zeros[2] = {cur.state.zero1, cur.state.zero2}; for (int zi = 0; zi  zpos  = 0; adj[zpos][i] != -1; i++) { int npos = adj[zpos][i]; State next = cur.state; next.board[zpos] =  (zi == 0) { next.zero1 = npos; } else { next.zero2 = npos; } if (next.zero1  = next.zero1; next.zero1 = next.zero2; next.zero2 = tmp; } if (isGoal(&next)) { return cur.depth + 1;  idx = getVisitedIndex(h); if (!visited[idx]) { visited[idx]  queue[qback].depth = cur.depth + 1; qback++; } } } } return -1; } int main() { int first; while   init; init.board[0] = first; for (int i = 1; i < 13; i++) { scanf(\"%d\",   i  i++) {  if (init.zero1 == -1) init.zero1 = i; else init.zero2 = i;  solve(&init); if (result == -1) { printf(\"NA\\n\"); } else { printf(\"%d\\n\", result); } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> #include <stdlib.h> typedef struct{ long long int code; int steps; } puzz; int q[10000000][14],size[30000],size2[30000]; long long int FR,TO,SW; puzz* hash[30000][100],hash2[30000][100]; void swap (int* x,int* y){ int  long long int convert(int  int i; for(i=0;i<13;i++)ret=ret*13+a[i]; return  int code,int step){ int ccc=code%30000; puzz* ppp=(puzz*)malloc(sizeof(puzz));  hash[ccc][size[ccc]]=ppp; size[ccc]++; } int hashsearch(long long int  for(i--;i>=0;i--){ if(hash[ccc][i]->code==code)return hash[ccc][i]->steps; } return -1; }  k; long long int cd; swap(&q[FR][x],&q[FR][y]); cd=convert(q[FR]); if(SW==1 || hashsearch(cd)<0){ for(k=0;k<14;k++){q[TO][k]=q[FR][k];} q[TO][13]++; if(SW==0)hashadd(cd,q[TO][13]); TO++; } swap(&q[FR][x],&q[FR][y]); } void check(){ if(q[FR][0]==0){mark(0,2);} if(q[FR][1]==0){mark(1,2);mark(1,5);} if(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);} if(q[FR][3]==0){mark(3,2);mark(3,7);} if(q[FR][4]==0){mark(4,5);} if(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);} if(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);} if(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);} if(q[FR][8]==0){mark(8,7);} if(q[FR][9]==0){mark(9,5);mark(9,10);} if(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);} if(q[FR][11]==0){mark(11,7);mark(11,10);} if(q[FR][12]==0){mark(12,10);} } int main(){ int i,ans; long long int cd; for(i=1;i<12;i++)q[0][i]=i; q[0][0]=0;q[0][12]=0;q[0][13]=0;  FR++; } while(scanf(\"%d\",&q[0][0])*q[0][0]>=0){ for(i=1;i<13;i++)scanf(\"%d\",&q[0][i]); q[0][13]=0;FR=0;TO=1;SW=1;ans=9999; //for(i=0;i<30000;i++)size2[i]=0; while(FR<TO){ cd=hashsearch(convert(q[FR])); if(cd>=0){ if(FR>0 && cd!=14)fprintf(stderr,\"%d?\\n\",cd); ans=(int)cd+q[FR][13];  if(ans>20 && ans<9999)fprintf(stderr,\"ans:%d?\\n\",ans); if(ans>20)printf(\"NA\\n\");  }"], "original_ll": -0.8479455709457397, "sampled_ll": -0.4077097475528717, "all_perturbed_sampled_ll": [-1.20734703540802], "all_perturbed_original_ll": [-1.1945769786834717], "perturbed_sampled_ll": -1.20734703540802, "perturbed_original_ll": -1.1945769786834717, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] adj = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };\n\t\tString g = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tint step = 1;\n\t\tdeque.offer(g);\n\t\tm.put(g, 0);\n\t\twhile (!deque.isEmpty() && step < 10) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int k = 0; k < size; k++) {\n\t\t\t\tString s = deque.pop();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (c[i] == '0') {\n\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\tc[i] = c[adj[i][j]];\n\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\tString n = String.valueOf(c);\n\t\t\t\t\t\t\tif (!m.containsKey(n)) {\n\t\t\t\t\t\t\t\tm.put(n, step);\n\t\t\t\t\t\t\t\tdeque.offer(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[adj[i][j]] = c[i];\n\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint p = scanner.nextInt();\n\t\t\tif (p == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cc = new char[13];\n\t\t\tcc[0] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tp = scanner.nextInt();\n\t\t\t\tcc[i] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\t}\n\t\t\tString st = String.valueOf(cc);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tdeque.clear();\n\t\t\tdeque.offer(st);\n\t\t\tstep = 0;\n\t\t\tboolean flag = false;\n\t\t\tString ans = \"\";\n\t\t\tloop: while (!deque.isEmpty() && step < 10) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tfor (int w = 0; w < size; w++) {\n\t\t\t\t\tString s = deque.pop();\n\t\t\t\t\tif (m.containsKey(s)) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tans = s;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] cs = s.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (cs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\t\tcs[i] = cs[adj[i][j]];\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = '0';\n\t\t\t\t\t\t\t\tString news = String.valueOf(cs);\n\t\t\t\t\t\t\t\tif (!set.contains(news)) {\n\t\t\t\t\t\t\t\t\tset.add(news);\n\t\t\t\t\t\t\t\t\tdeque.offer(news);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = cs[i];\n\t\t\t\t\t\t\t\tcs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? m.get(ans) : \"NA\");\n\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static final int[] GOAL = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0};\n    \n    static class State {\n        int[] board;\n        int steps;\n        \n        State(int[] board, int steps) {\n            this.board = board.clone();\n            this.steps = steps;\n        }\n        \n        String hash() {\n            return Arrays.toString(board);\n        }\n    }\n    \n    static int[] readInput(Scanner sc) {\n        int[] board = new int[13];\n        int idx = 0;\n        \n        // Row 1: 1 element\n        board[idx++] = sc.nextInt();\n        \n        // Row 2: 3 elements\n        for (int i = 0; i < 3; i++) {\n            board[idx++] = sc.nextInt();\n        }\n        \n        // Row 3: 5 elements\n        for (int i = 0; i < 5; i++) {\n            board[idx++] = sc.nextInt();\n        }\n        \n        // Row 4: 3 elements\n        for (int i = 0; i < 3; i++) {\n            board[idx++] = sc.nextInt();\n        }\n        \n        // Row 5: 1 element\n        board[idx++] = sc.nextInt();\n        \n        return board;\n    }\n    \n    static int[][] getNeighbors() {\n        int[][] neighbors = new int[13][];\n        neighbors[0] = new int[]{1};\n        neighbors[1] = new int[]{0, 2, 4};\n        neighbors[2] = new int[]{1, 3, 5};\n        neighbors[3] = new int[]{2, 6};\n        neighbors[4] = new int[]{1, 5, 7};\n        neighbors[5] = new int[]{2, 4, 6, 8};\n        neighbors[6] = new int[]{3, 5, 9};\n        neighbors[7] = new int[]{4, 8, 10};\n        neighbors[8] = new int[]{5, 7, 9, 11};\n        neighbors[9] = new int[]{6, 8, 12};\n        neighbors[10] = new int[]{7, 11};\n        neighbors[11] = new int[]{8, 10, 12};\n        neighbors[12] = new int[]{9, 11};\n        return neighbors;\n    }\n    \n    static int solve(int[] initial) {\n        if (Arrays.equals(initial, GOAL)) {\n            return 0;\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        State start = new State(initial, 0);\n        queue.offer(start);\n        visited.add(start.hash());\n        \n        int[][] neighbors = getNeighbors();\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.steps >= 20) {\n                continue;\n            }\n            \n            // Find empty spaces\n            List<Integer> empties = new ArrayList<>();\n            for (int i = 0; i < 13; i++) {\n                if (curr.board[i] == 0) {\n                    empties.add(i);\n                }\n            }\n            \n            // Try moving tiles into empty spaces\n            for (int emptyPos : empties) {\n                for (int neighbor : neighbors[emptyPos]) {\n                    if (curr.board[neighbor] != 0) {\n                        int[] newBoard = curr.board.clone();\n                        newBoard[emptyPos] = newBoard[neighbor];\n                        newBoard[neighbor] = 0;\n                        \n                        if (Arrays.equals(newBoard, GOAL)) {\n                            return curr.steps + 1;\n                        }\n                        \n                        String hash = Arrays.toString(newBoard);\n                        if (!visited.contains(hash)) {\n                            visited.add(hash);\n                            queue.offer(new State(newBoard, curr.steps + 1));\n                        }\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int first = sc.nextInt();\n            if (first == -1) break;\n            \n            int[] board = new int[13];\n            board[0] = first;\n            \n            for (int i = 1; i < 13; i++) {\n                board[i] = sc.nextInt();\n            }\n            \n            int result = solve(board);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  GOAL = {1, 2,    int[] board; int steps;  this.board = board.clone(); this.steps = steps; } String hash() { return Arrays.toString(board); } } static int[] readInput(Scanner sc) { int[] board = new    (int i = 0; i < 3; i++) { board[idx++] = sc.nextInt(); } // Row 3: 5 elements  i < 5;  } // Row 4: 3 elements for (int i = 0; i < 3; i++) { board[idx++] = sc.nextInt(); } // Row 5: 1 element board[idx++] = sc.nextInt(); return board;   neighbors[0] = new int[]{1}; neighbors[1] = new int[]{0, 2, 4}; neighbors[2] = new int[]{1, 3, 5}; neighbors[3]  = new int[]{1, 5, 7}; neighbors[5] = new int[]{2, 4, 6, 8}; neighbors[6]  neighbors[7] = new int[]{4, 8, 10}; neighbors[8] = new int[]{5, 7, 9, 11}; neighbors[9]  neighbors[10] = new int[]{7, 11}; neighbors[11] = new int[]{8, 10, 12}; neighbors[12] = new int[]{9, 11}; return neighbors; } static int solve(int[] initial) { if (Arrays.equals(initial, GOAL)) { return 0; } Queue<State> queue = new LinkedList<>(); Set<String>  start = new State(initial, 0); queue.offer(start); visited.add(start.hash()); int[][] neighbors = getNeighbors(); while (!queue.isEmpty()) { State curr = queue.poll(); if (curr.steps >= 20) { continue; } // Find empty spaces List<Integer> empties = new ArrayList<>();  { if (curr.board[i] == 0) { empties.add(i); } } // Try moving tiles into empty spaces for (int emptyPos : empties) { for (int neighbor : neighbors[emptyPos])  { int[] newBoard = curr.board.clone(); newBoard[emptyPos] = newBoard[neighbor]; newBoard[neighbor] = 0; if  + 1; } String hash = Arrays.toString(newBoard); if (!visited.contains(hash))  + 1)); } } } } } return -1; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int first = sc.nextInt(); if (first == -1) break; int[] board = new int[13]; board[0] = first; for  board[i] = sc.nextInt(); } int result = solve(board); if (result == -1) { System.out.println(\"NA\"); } else  } }"], "perturbed_original": ["import java.util.ArrayDeque; import java.util.Deque; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Scanner;  {  { new Main().run(); } private void run() { Scanner scanner = new Scanner(System.in); int[][] adj = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 }, { 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 }, { 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } }; String g = \"0ABCDEFGHIJK0\"; Map<String, Integer> m = new HashMap<String, Integer>(); Deque<String> deque =  1;  && step  k = 0; k   = s.toCharArray();  i < 13; i++) { if (c[i] == '0') { for (int j = 0;  c[i] = c[adj[i][j]]; c[adj[i][j]] = '0'; String n = String.valueOf(c); if (!m.containsKey(n))  c[adj[i][j]] = c[i]; c[i] = '0'; } } } } step++; } while (true) { int p = scanner.nextInt(); if (p == -1)  char[13]; cc[0] = p == 0 ? '0' :   1; i < 13; i++) { p = scanner.nextInt(); cc[i] = p == 0 ? '0' :  'A'); } String st = String.valueOf(cc); Set<String> set = new HashSet<String>(); deque.clear(); deque.offer(st); step =  String ans = \"\"; loop: while (!deque.isEmpty() && step < 10)  0; w < size;  deque.pop();  true; ans  for (int i = 0;  if (cs[i] == '0') { for (int j = 0; j < adj[i].length; j++) { cs[i] = cs[adj[i][j]]; cs[adj[i][j]] = '0'; String news = String.valueOf(cs); if (!set.contains(news)) { set.add(news); deque.offer(news); } cs[adj[i][j]] = cs[i]; cs[i] = '0'; } } } } step++; } System.out.println(flag ? m.get(ans) : \"NA\"); } } }"], "original_ll": -0.5659579038619995, "sampled_ll": -0.34490281343460083, "all_perturbed_sampled_ll": [-1.1538399457931519], "all_perturbed_original_ll": [-1.4040254354476929], "perturbed_sampled_ll": -1.1538399457931519, "perturbed_original_ll": -1.4040254354476929, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from math import factorial\nfrom Queue import PriorityQueue\n\nFACTORIAL=[factorial(i) for i in xrange(13)]\nLEFT,UP,RIGHT,DOWN=0,1,2,3\nMOVE=[[0] for u in xrange(13)]\nMOVE[0] =[-1,-1,-1, 2]\nMOVE[1] =[-1,-1, 2, 5]\nMOVE[2] =[ 1, 0, 3, 6]\nMOVE[3] =[ 2,-1,-1, 7] \nMOVE[4] =[-1,-1, 5,-1]\nMOVE[5] =[ 4, 1, 6, 9]\nMOVE[6] =[ 5, 2, 7,10]\nMOVE[7] =[ 6, 3, 8,11]\nMOVE[8] =[ 7,-1,-1,-1]\nMOVE[9] =[-1, 5,10,-1]\nMOVE[10]=[ 9, 6,11,12]\nMOVE[11]=[10, 7,-1,-1]\nMOVE[12]=[-1,10,-1,-1]\n\ndef hash(cell):\n    work = cell[:]\n    hash = 0\n    for i in xrange(12):\n        hash += work[i] * FACTORIAL[13-1-i]\n        for ii in xrange(i+1,13):\n            if work[ii]>work[i]:\n                work[ii]-=1\n    return hash\n\ndef dehash(key):\n    cell=[]\n    for i in xrange(13):\n        cell.append(key/FACTORIAL[13-1-i])\n        key %= FACTORIAL[13-1-i]\n    for i in xrange(13-1,-1,-1):\n        for ii in xrange(i+1,13):\n            if cell[i]<=cell[ii]:\n                cell[ii]+=1\n    return cell\n\ndef evaluate(cell):\n    point=[[0,2],\n           [1,1],[1,2],[1,3],\n           [2,0],[2,1],[2,2],[2,3],[2,4],\n           [3,1],[3,2],[3,3],\n           [4,2]]\n    eva=0\n    for i in xrange(0,13):\n        if not (cell[i]==0 or cell[i]==12):\n            eva+=abs(point[cell[i]][0]-point[i][0])\n            eva+=abs(point[cell[i]][1]-point[i][1])\n    return eva\n\nANS_HASH=[hash([0,1,2,3,4,5,6,7,8,9,10,11,12]),hash([12,1,2,3,4,5,6,7,8,9,10,11,0])]          \n\nwhile True:\n    p=[input()]\n    if p==[-1]:\n        break\n    for u in xrange(4):\n        for pp in map(int,raw_input().split()):\n            p.append(pp)\n    p[p.index(0)]=12\n    pq = PriorityQueue()\n    pq.put([evaluate(p),hash(p),0])\n    visited={}\n    visited[hash(p)]=True\n    ans=0 if hash(p) in ANS_HASH else \"NA\"\n    #cur=[eva,hashkey,step]\n    while not pq.empty():\n        eva,cur_hash,cur_step=pq.get()\n        cur_cell=dehash(cur_hash)\n        if not (eva<=20 and ans==\"NA\"):\n            break\n        for i in xrange(13):\n            if cur_cell[i]==0 or cur_cell[i]==12:\n                for ii in [LEFT,UP,RIGHT,DOWN]:\n                    if not MOVE[i][ii]==-1:\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n                        hashkey=hash(cur_cell)\n                        if not hashkey in visited:\n                            if hashkey in ANS_HASH:\n                                ans=cur_step+1\n                                break\n                            pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1])\n                            visited[hashkey]=True\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n    print ans", "sampled": "from collections import deque\n\ndef read_puzzle():\n    line = input().strip()\n    if line == '-1':\n        return None\n    \n    puzzle = []\n    puzzle.append(list(map(int, line.split())))\n    puzzle.append(list(map(int, input().split())))\n    puzzle.append(list(map(int, input().split())))\n    puzzle.append(list(map(int, input().split())))\n    input()  # empty line\n    \n    return puzzle\n\ndef puzzle_to_tuple(puzzle):\n    result = []\n    for row in puzzle:\n        result.extend(row)\n    return tuple(result)\n\ndef tuple_to_puzzle(t):\n    puzzle = []\n    puzzle.append(list(t[0:1]))\n    puzzle.append(list(t[1:4]))\n    puzzle.append(list(t[4:9]))\n    puzzle.append(list(t[9:12]))\n    return puzzle\n\ndef get_neighbors(puzzle):\n    neighbors = []\n    \n    # Find all zeros\n    zeros = []\n    for i in range(len(puzzle)):\n        for j in range(len(puzzle[i])):\n            if puzzle[i][j] == 0:\n                zeros.append((i, j))\n    \n    # For each zero, find adjacent numbers that can move\n    for zi, zj in zeros:\n        # Check all 4 directions\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        for di, dj in directions:\n            ni, nj = zi + di, zj + dj\n            if 0 <= ni < len(puzzle) and 0 <= nj < len(puzzle[ni]):\n                if puzzle[ni][nj] != 0:\n                    # Make a move\n                    new_puzzle = [row[:] for row in puzzle]\n                    new_puzzle[zi][zj] = new_puzzle[ni][nj]\n                    new_puzzle[ni][nj] = 0\n                    neighbors.append(new_puzzle)\n    \n    return neighbors\n\ndef solve_puzzle(start_puzzle):\n    goal = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0)\n    \n    start = puzzle_to_tuple(start_puzzle)\n    \n    if start == goal:\n        return 0\n    \n    queue = deque([(start_puzzle, 0)])\n    visited = {start}\n    \n    while queue:\n        current_puzzle, steps = queue.popleft()\n        \n        if steps >= 20:\n            continue\n        \n        for neighbor in get_neighbors(current_puzzle):\n            neighbor_tuple = puzzle_to_tuple(neighbor)\n            \n            if neighbor_tuple == goal:\n                return steps + 1\n            \n            if neighbor_tuple not in visited:\n                visited.add(neighbor_tuple)\n                queue.append((neighbor, steps + 1))\n    \n    return -1\n\nwhile True:\n    puzzle = read_puzzle()\n    if puzzle is None:\n        break\n    \n    result = solve_puzzle(puzzle)\n    if result == -1:\n        print(\"NA\")\n    else:\n        print(result)\n", "perturbed_sampled": ["from collections import deque  return None puzzle = [] puzzle.append(list(map(int, line.split()))) puzzle.append(list(map(int, input().split())))  # empty line return puzzle  for row in puzzle: result.extend(row) return tuple(result) def tuple_to_puzzle(t): puzzle = [] puzzle.append(list(t[0:1])) puzzle.append(list(t[1:4])) puzzle.append(list(t[4:9])) puzzle.append(list(t[9:12])) return puzzle def get_neighbors(puzzle): neighbors = [] # Find all zeros zeros = [] for i in range(len(puzzle)): for j in  zeros.append((i, j)) # For each zero, find adjacent numbers that can move for zi, zj in  0), (1, 0), (0, -1), (0, 1)] for di, dj in directions: ni, nj = zi + di, zj + dj if 0 <= ni < len(puzzle) and 0  puzzle[ni][nj] != 0: #  [row[:] for row in puzzle] new_puzzle[zi][zj] = new_puzzle[ni][nj] new_puzzle[ni][nj] = 0 neighbors.append(new_puzzle) return neighbors def solve_puzzle(start_puzzle): goal  5, 6,  0, 0) start = puzzle_to_tuple(start_puzzle) if start == goal: return 0 queue =  while queue: current_puzzle, steps = queue.popleft() if steps >= 20: continue  = puzzle_to_tuple(neighbor) if neighbor_tuple == goal: return steps + 1 if neighbor_tuple not in visited:  return -1 while True: puzzle = read_puzzle() if puzzle is None: break  == -1: print(\"NA\") else: print(result)"], "perturbed_original": ["from math import  FACTORIAL=[factorial(i) for i in xrange(13)] LEFT,UP,RIGHT,DOWN=0,1,2,3 MOVE=[[0] for u in xrange(13)] MOVE[0] =[-1,-1,-1, 2] MOVE[1]  MOVE[3] =[ 2,-1,-1, 7] MOVE[4] =[-1,-1, 5,-1] MOVE[5] =[ 4, 1, 6, 9] MOVE[6] =[ 5, 2,  8,11] MOVE[8] =[ 7,-1,-1,-1] MOVE[9] =[-1, 5,10,-1] MOVE[10]=[ 9, 6,11,12] MOVE[11]=[10, 7,-1,-1] MOVE[12]=[-1,10,-1,-1] def hash(cell): work  for i in xrange(12): hash += work[i] * FACTORIAL[13-1-i] for ii in xrange(i+1,13): if work[ii]>work[i]:  cell=[] for i in xrange(13): cell.append(key/FACTORIAL[13-1-i]) key %= FACTORIAL[13-1-i] for  in xrange(i+1,13): if cell[i]<=cell[ii]: cell[ii]+=1 return cell def evaluate(cell): point=[[0,2], [1,1],[1,2],[1,3], [2,0],[2,1],[2,2],[2,3],[2,4], [3,1],[3,2],[3,3], [4,2]] eva=0 for i in xrange(0,13): if not (cell[i]==0 or cell[i]==12):  while True: p=[input()] if p==[-1]: break for u in xrange(4): for pp in map(int,raw_input().split()): p.append(pp)  hash(p) in  not pq.empty(): eva,cur_hash,cur_step=pq.get() cur_cell=dehash(cur_hash) if not (eva<=20 and ans==\"NA\"): break for i in xrange(13): if cur_cell[i]==0 or cur_cell[i]==12: for ii in [LEFT,UP,RIGHT,DOWN]: if not MOVE[i][ii]==-1: cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i] hashkey=hash(cur_cell) if not hashkey in visited: if  pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1]) visited[hashkey]=True cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i] print ans"], "original_ll": -0.8712171316146851, "sampled_ll": -0.5256608128547668, "all_perturbed_sampled_ll": [-1.5752462148666382], "all_perturbed_original_ll": [-1.508649468421936], "perturbed_sampled_ll": -1.5752462148666382, "perturbed_original_ll": -1.508649468421936, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "double g[100][100],G[100],H[100],a;main(n,m,i,j){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%.2f\\n\",a)){for(i=n;i--;G[i]=1)for(j=n;j--;)scanf(\"%lf\",g[i]+j);for(;--m;memcpy(G,H,8*n))for(i=n;i--;)for(H[i]=0,j=n;j--;a>H[i]?H[i]=a:0)a=G[j]*g[j][i];for(a=0;n--;)G[n]>a?a=G[n]:0;}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, m;\n    double g[101][101];\n    double dp[101][101];\n    \n    while (scanf(\"%d %d\", &n, &m) == 2) {\n        if (n == 0 && m == 0) break;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                scanf(\"%lf\", &g[i][j]);\n            }\n        }\n        \n        memset(dp, 0, sizeof(dp));\n        \n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = 1.0;\n        }\n        \n        for (int step = 2; step <= m; step++) {\n            for (int curr = 1; curr <= n; curr++) {\n                dp[step][curr] = 0.0;\n                for (int prev = 1; prev <= n; prev++) {\n                    double val = dp[step-1][prev] * g[prev][curr];\n                    if (val > dp[step][curr]) {\n                        dp[step][curr] = val;\n                    }\n                }\n            }\n        }\n        \n        double max_size = 0.0;\n        for (int i = 1; i <= n; i++) {\n            if (dp[m][i] > max_size) {\n                max_size = dp[m][i];\n            }\n        }\n        \n        printf(\"%.2lf\\n\", max_size);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n, m;  (scanf(\"%d %d\", &n, &m) == 2) { if (n == 0 &&  { for (int j = 1; j <= n; j++) { scanf(\"%lf\", &g[i][j]); } } memset(dp, 0, sizeof(dp)); for (int i = 1; i  = 1.0; } for (int step =  { for (int curr = 1; curr <= n; curr++) { dp[step][curr] = 0.0; for  <= n; prev++) { double val = dp[step-1][prev] * g[prev][curr]; if (val > dp[step][curr]) { dp[step][curr] = val; } } } } double max_size = 0.0; for (int i = 1; i <= n; i++) { if (dp[m][i] > max_size)   0; }"], "perturbed_original": ["double g[100][100],G[100],H[100],a;main(n,m,i,j){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%.2f\\n\",a)){for(i=n;i--;G[i]=1)for(j=n;j--;)scanf(\"%lf\",g[i]+j);for(;--m;memcpy(G,H,8*n))for(i=n;i--;)for(H[i]=0,j=n;j--;a>H[i]?H[i]=a:0)a=G[j]*g[j][i];for(a=0;n--;)G[n]>a?a=G[n]:0;}exit(0);}"], "original_ll": -1.8046499490737915, "sampled_ll": -0.394748717546463, "all_perturbed_sampled_ll": [-1.3229995965957642], "all_perturbed_original_ll": [-1.8046499490737915], "perturbed_sampled_ll": -1.3229995965957642, "perturbed_original_ll": -1.8046499490737915, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static int n, m;\n    static double[][] dp, table;\n\n    public static void main(String[] args) {\n        while(read()){\n            solve();\n        }\n\n    }\n\n    static boolean read(){\n        if(!sc.hasNext())return false;\n        n = sc.nextInt();\n        m = sc.nextInt();\n        if(n == 0 || m == 0)return false;\n        dp = new double[m][n];\n        table = new double[m][n];\n\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                table[i][j] = sc.nextDouble();\n            }\n        }\n\n        for(int i = 0; i < 1; i++){\n            for(int j = 0; j < n; j++){\n                dp[i][j] = 1.0;\n            }\n        }\n\n        return true;\n    }\n\n    static void solve(){\n        int index = 0;\n        double value = 0.0, res = 0.0;\n        double[] array = new double[n];\n        for(int i = 0; i < m-1; i++){\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < n; k++){\n                    array[k] = table[j][k];\n                }\n                for(int k = 0; k < n; k++){\n                    if(value < array[k]){\n                        index = k;\n                        value = array[k];\n                    }\n                }\n                dp[i+1][index] = Math.max(dp[i+1][index], value*dp[i][j]);\n            }\n        }\n\n        for(int j = 0; j < n; j++){\n            res = Math.max(res, dp[m-1][j]);\n        }\n        System.out.printf(\"%.2f\\n\", res);\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) break;\n            \n            double[][] g = new double[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = sc.nextDouble();\n                }\n            }\n            \n            if (m == 1) {\n                System.out.println(\"1.00\");\n                continue;\n            }\n            \n            // dp[step][lastFertilizer] = maximum size after 'step' applications with last fertilizer being 'lastFertilizer'\n            double[][] dp = new double[m + 1][n];\n            \n            // Initialize: after 1 application, size is 1.0 for any fertilizer\n            for (int i = 0; i < n; i++) {\n                dp[1][i] = 1.0;\n            }\n            \n            // Fill DP table\n            for (int step = 2; step <= m; step++) {\n                for (int curr = 0; curr < n; curr++) {\n                    dp[step][curr] = 0.0;\n                    for (int prev = 0; prev < n; prev++) {\n                        if (dp[step - 1][prev] > 0) {\n                            dp[step][curr] = Math.max(dp[step][curr], dp[step - 1][prev] * g[prev][curr]);\n                        }\n                    }\n                }\n            }\n            \n            // Find maximum size after m applications\n            double maxSize = 0.0;\n            for (int i = 0; i < n; i++) {\n                maxSize = Math.max(maxSize, dp[m][i]);\n            }\n            \n            System.out.printf(\"%.2f\\n\", maxSize);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); int m  0 && m == 0)  double[n][n]; for (int i  i++) { for (int j = 0; j < n; j++) { g[i][j] = sc.nextDouble(); } } if (m == 1) { System.out.println(\"1.00\");  maximum   + 1][n]; // Initialize:   i < n; i++) { dp[1][i] = 1.0; } // Fill DP table for (int step = 2; step <= m; step++) { for (int curr = 0; curr < n; curr++) { dp[step][curr] = 0.0; for (int prev = 0; prev < n; prev++) { if (dp[step - 1][prev] > 0) {  1][prev] * g[prev][curr]); } } } } // Find maximum size  = 0.0; for (int i = 0; i < n; i++) { maxSize = Math.max(maxSize, dp[m][i]); } System.out.printf(\"%.2f\\n\", maxSize); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { static Scanner sc = new Scanner(System.in); static int n, m; static double[][] dp, table; public static void main(String[] args) { while(read()){ solve(); } } static boolean read(){ if(!sc.hasNext())return false; n = sc.nextInt(); m =  m == 0)return false; dp = new double[m][n]; table  = 0; i < m; i++){ for(int j =  table[i][j] = sc.nextDouble(); } } for(int i = 0; i < 1; i++){ for(int j = 0; j  1.0; } } return true; } static void  double value = 0.0, res =  double[n]; for(int i = 0; i < m-1; i++){ for(int j = 0; j  n; k++){ array[k] = table[j][k]; } for(int k = 0; k < n; k++){ if(value < array[k]){ index = k;  dp[i+1][index] = Math.max(dp[i+1][index], value*dp[i][j]);  0; j < n; j++){  System.out.printf(\"%.2f\\n\", res); } }"], "original_ll": -0.54366135597229, "sampled_ll": -0.499393105506897, "all_perturbed_sampled_ll": [-1.3204256296157837], "all_perturbed_original_ll": [-1.662007212638855], "perturbed_sampled_ll": -1.3204256296157837, "perturbed_original_ll": -1.662007212638855, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n, m = map(int, raw_input().split())\n    if n==0:\n        exit(0)\n    mat = [map(float, raw_input().split()) for i in xrange(n)]\n    dp = [1.0] * n\n    for t in xrange(m-1):\n        dp2 = [-1.0] * n\n        for i in xrange(n):\n            mat_i = mat[i]; dp_i = dp[i]\n            for j in xrange(n):\n                dp2[j] = max(dp2[j], dp_i * mat_i[j])\n        dp = dp2\n    print \"%.02f\" % round(max(dp), 2)", "sampled": "import sys\n\ndef solve(n, m, growth):\n    if m == 1:\n        return 1.0\n    \n    # dp[step][fertilizer] = maximum growth after 'step' applications, ending with 'fertilizer'\n    dp = [[-1.0] * n for _ in range(m + 1)]\n    \n    # After first application, size is 1.0 for any fertilizer\n    for i in range(n):\n        dp[1][i] = 1.0\n    \n    # For each subsequent application\n    for step in range(2, m + 1):\n        for curr in range(n):\n            # Try all possible previous fertilizers\n            for prev in range(n):\n                if dp[step - 1][prev] > 0:\n                    # Apply fertilizer 'curr' after fertilizer 'prev'\n                    new_size = dp[step - 1][prev] * growth[prev][curr]\n                    dp[step][curr] = max(dp[step][curr], new_size)\n    \n    # Find maximum size after m applications\n    max_size = max(dp[m])\n    return max_size\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    if not line:\n        break\n    \n    parts = line.split()\n    n, m = int(parts[0]), int(parts[1])\n    \n    if n == 0 and m == 0:\n        break\n    \n    growth = []\n    for i in range(n):\n        row = list(map(float, sys.stdin.readline().split()))\n        growth.append(row)\n    \n    result = solve(n, m, growth)\n    print(f\"{result:.2f}\")\n", "perturbed_sampled": ["import sys def  == 1: return 1.0 # dp[step][fertilizer] = maximum growth after 'step' applications, ending with  n for _ in range(m + 1)] # After first application, size is 1.0 for any fertilizer for i in range(n): dp[1][i] = 1.0 # For  in range(2, m +  # Try all possible previous fertilizers for prev in range(n): if dp[step -  fertilizer 'curr' after fertilizer  1][prev]  new_size) # Find maximum size after m applications max_size = max(dp[m]) return max_size while True: line = sys.stdin.readline().strip() if not line: break parts = line.split() n, m = int(parts[0]), int(parts[1]) if n == 0 and m ==  for i in  growth.append(row) result = solve(n, m, growth) print(f\"{result:.2f}\")"], "perturbed_original": ["while 1: n, m = map(int, raw_input().split()) if n==0: exit(0)  i in xrange(n)] dp = [1.0] *  dp2 = [-1.0] * n for i in xrange(n): mat_i = mat[i]; dp_i = dp[i] for j in xrange(n): dp2[j] = max(dp2[j], dp_i  print \"%.02f\" % round(max(dp), 2)"], "original_ll": -0.8603090643882751, "sampled_ll": -0.7850139737129211, "all_perturbed_sampled_ll": [-2.473339796066284], "all_perturbed_original_ll": [-1.9622503519058228], "perturbed_sampled_ll": -2.473339796066284, "perturbed_original_ll": -1.9622503519058228, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,T,C[10][2],c,d,O[10][2],t,s,u,v,h,*p;D(h){p=C[s]+h;*p&&T>=O[s][h]?*p=!printf(\"%d%c\",*p,d<n|--c?32:10):0;}main(m){for(;~scanf(\"%d%d\",&m,&n);)for(memset(C,T=c=d=0,80);d<n|c;T++){for(s=m;s--;C[s][1]||D(0))D(1);for(;T>=d*10&d<n&c<m*2;C[s=~u?u:v][h]=++d,O[s][h]=T+t,c++)for(h=scanf(\"%d\",&t),u=v=-1,s=m;h&&s--;)*C[s]?C[s][1]||(*O[s]<T+t?!~v||*O[s]>*O[v]?v=s:0:!~u||*O[s]<*O[u]?u=s:0):(u=s,h=0);}}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SPACES 10\n#define MAX_CARS 100\n\ntypedef struct {\n    int id;\n    int parking_time;\n    int arrival_time;\n    int exit_time;\n} Car;\n\ntypedef struct {\n    int lower_car;\n    int upper_car;\n} Space;\n\ntypedef struct {\n    int car_id;\n    int arrival_time;\n} WaitingCar;\n\nint main() {\n    int m, n;\n    \n    while (1) {\n        scanf(\"%d %d\", &m, &n);\n        if (m == 0 && n == 0) break;\n        \n        Car cars[MAX_CARS];\n        Space spaces[MAX_SPACES];\n        WaitingCar waiting[MAX_CARS];\n        int waiting_count = 0;\n        int output[MAX_CARS];\n        int output_count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &cars[i].parking_time);\n            cars[i].id = i + 1;\n            cars[i].arrival_time = i * 10;\n            cars[i].exit_time = -1;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            spaces[i].lower_car = -1;\n            spaces[i].upper_car = -1;\n        }\n        \n        int current_car = 0;\n        int time = 0;\n        \n        while (output_count < n) {\n            // Process exits\n            for (int s = 0; s < m; s++) {\n                if (spaces[s].lower_car != -1) {\n                    int lower_id = spaces[s].lower_car;\n                    if (cars[lower_id].exit_time == time) {\n                        output[output_count++] = cars[lower_id].id;\n                        spaces[s].lower_car = -1;\n                        \n                        if (spaces[s].upper_car != -1) {\n                            int upper_id = spaces[s].upper_car;\n                            output[output_count++] = cars[upper_id].id;\n                            spaces[s].upper_car = -1;\n                        }\n                    }\n                }\n            }\n            \n            // Add arriving cars to waiting list\n            while (current_car < n && cars[current_car].arrival_time == time) {\n                waiting[waiting_count].car_id = current_car;\n                waiting[waiting_count].arrival_time = time;\n                waiting_count++;\n                current_car++;\n            }\n            \n            // Park waiting cars\n            int parked_any = 1;\n            while (waiting_count > 0 && parked_any) {\n                parked_any = 0;\n                int car_id = waiting[0].car_id;\n                int park_time = cars[car_id].parking_time;\n                \n                int best_space = -1;\n                int best_type = -1; // 0: empty, 1: one car\n                int best_diff = 999999;\n                \n                for (int s = 0; s < m; s++) {\n                    if (spaces[s].lower_car == -1) {\n                        if (best_type == -1 || best_type > 0) {\n                            best_space = s;\n                            best_type = 0;\n                        }\n                    } else if (spaces[s].upper_car == -1) {\n                        int remaining = cars[spaces[s].lower_car].exit_time - time;\n                        int diff;\n                        if (remaining >= park_time) {\n                            diff = remaining - park_time;\n                            if (best_type == -1 || best_type > 1 || (best_type == 1 && diff < best_diff)) {\n                                best_space = s;\n                                best_type = 1;\n                                best_diff = diff;\n                            }\n                        } else {\n                            diff = park_time - remaining;\n                            if (best_type == -1 || (best_type == 2 && diff < best_diff)) {\n                                best_space = s;\n                                best_type = 2;\n                                best_diff = diff;\n                            }\n                        }\n                    }\n                }\n                \n                if (best_space != -1) {\n                    if (spaces[best_space].lower_car == -1) {\n                        spaces[best_space].lower_car = car_id;\n                    } else {\n                        spaces[best_space].upper_car = car_id;\n                    }\n                    cars[car_id].exit_time = time + park_time;\n                    \n                    for (int i = 0; i < waiting_count - 1; i++) {\n                        waiting[i] = waiting[i + 1];\n                    }\n                    waiting_count--;\n                    parked_any = 1;\n                } else {\n                    break;\n                }\n            }\n            \n            time++;\n        }\n        \n        for (int i = 0; i < output_count; i++) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", output[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> #define MAX_SPACES 10 #define MAX_CARS 100 typedef struct { int id;  exit_time; } Car; typedef struct { int lower_car; int upper_car; } Space; typedef struct { int car_id; int  {  { scanf(\"%d  == 0 && n == 0) break; Car cars[MAX_CARS]; Space spaces[MAX_SPACES]; WaitingCar waiting[MAX_CARS]; int waiting_count = 0; int output[MAX_CARS]; int output_count = 0; for (int i = 0; i < n; i++) { scanf(\"%d\", &cars[i].parking_time); cars[i].id = i + 1; cars[i].arrival_time = i * 10; cars[i].exit_time = -1; } for  < m; i++) {  -1; } int current_car = 0; int time = 0; while (output_count < n) { // Process exits for (int s = 0; s < m; s++) { if   = cars[lower_id].id; spaces[s].lower_car = -1; if (spaces[s].upper_car != -1) { int upper_id  spaces[s].upper_car = -1; } } }  to waiting list while (current_car < n && cars[current_car].arrival_time == time) { waiting[waiting_count].car_id  waiting_count++;  cars int parked_any = 1; while (waiting_count > 0 && parked_any) { parked_any = 0; int car_id = waiting[0].car_id; int park_time = cars[car_id].parking_time; int best_space  -1; // 0: empty, 1: one car int best_diff = 999999; for (int s = 0; s < m; s++) { if (spaces[s].lower_car == -1) { if (best_type == -1 || best_type >  best_type = 0; } } else if (spaces[s].upper_car == -1) { int remaining  diff; if (remaining >= park_time) { diff = remaining - park_time; if (best_type == -1 || best_type > 1 || (best_type ==  { best_space  best_diff  { diff = park_time - remaining; if (best_type == -1  diff <  best_type = 2; best_diff = diff; } } } } if (best_space != -1) { if   spaces[best_space].upper_car = car_id; } cars[car_id].exit_time = time  = 0; i < waiting_count - 1; i++) { waiting[i] = waiting[i +  } for (int i = 0; i < output_count; i++) { if (i > 0) printf(\" \"); printf(\"%d\", output[i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["n,T,C[10][2],c,d,O[10][2],t,s,u,v,h,*p;D(h){p=C[s]+h;*p&&T>=O[s][h]?*p=!printf(\"%d%c\",*p,d<n|--c?32:10):0;}main(m){for(;~scanf(\"%d%d\",&m,&n);)for(memset(C,T=c=d=0,80);d<n|c;T++){for(s=m;s--;C[s][1]||D(0))D(1);for(;T>=d*10&d<n&c<m*2;C[s=~u?u:v][h]=++d,O[s][h]=T+t,c++)for(h=scanf(\"%d\",&t),u=v=-1,s=m;h&&s--;)*C[s]?C[s][1]||(*O[s]<T+t?!~v||*O[s]>*O[v]?v=s:0:!~u||*O[s]<*O[u]?u=s:0):(u=s,h=0);}}"], "original_ll": -2.764087677001953, "sampled_ll": -0.4700777530670166, "all_perturbed_sampled_ll": [-1.4266170263290405], "all_perturbed_original_ll": [-2.764087677001953], "perturbed_sampled_ll": -1.4266170263290405, "perturbed_original_ll": -2.764087677001953, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX_SIZE = 10;\n\tpublic static final int MAX_CAR = 100;\n\t\n\tpublic static final int M_INF = Integer.MIN_VALUE / 2 + 1;\n\t\n\tpublic static boolean try_fst(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] <= M_INF){\n\t\t\t\tspaces[i][0] = remain_time;\n\t\t\t\tnumbers[i][0] = car_number;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void add_time(int[][] spaces, final int m, final int time){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] <= M_INF){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tspaces[i][0] -= time;\n\t\t\tspaces[i][1] -= time;\n\t\t}\n\t}\n\t\n\tpublic static boolean is_finish(int[][] spaces, final int m){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] > M_INF){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean can_upper(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] >= remain_time && spaces[i][1] <= M_INF){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean try_snd(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){\n\t\tfinal boolean can_upper = can_upper(spaces, numbers, m, remain_time, car_number);\n\t\t\n\t\tint pos = -1;\n\t\tint attr = can_upper ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\t//System.out.println(can_upper + \" \" + (spaces[i][0]<= M_INF) + \" \" + (attr < spaces[i][0]));\n\t\t\t\n\t\t\tif(can_upper && spaces[i][1] <= M_INF && spaces[i][0] >= remain_time && attr > spaces[i][0]){\n\t\t\t\tattr = spaces[i][0];\n\t\t\t\tpos = i;\n\t\t\t}else if(!can_upper && spaces[i][1] <= M_INF && attr < spaces[i][0]){\n\t\t\t\tattr = spaces[i][0];\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(attr  + \" \" + pos + \" \" + can_upper);\n\t\t\n\t\tif(pos < 0){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tspaces[pos][1] = Math.max(spaces[pos][0], remain_time);\n\t\tnumbers[pos][1] = numbers[pos][0];\n\t\tspaces[pos][0] = remain_time;\n\t\tnumbers[pos][0] = car_number;\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static void print(int[][] spaces, int[][] numbers, final int m){\n\t\tSystem.out.println(\"-----------------------------------\");\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(spaces[i][0] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(spaces[i][1] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(numbers[i][0] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(numbers[i][1] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"-----------------------------------\");\n\t\t\n\t}\n\t\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[][] spaces = new int[MAX_SIZE][2];\n\t\tint[][] numbers = new int[MAX_SIZE][2];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(m == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tspaces[i][0] = spaces[i][1] = M_INF;\n\t\t\t\tnumbers[i][0] = numbers[i][1] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> remain_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> number_queue = new LinkedList<Integer>();\n\t\t\t//int time = 0;\n\t\t\t\n\t\t\tLinkedList<Integer> out_numbers = new LinkedList<Integer>();\n\t\t\tfor(int car = 0; ; car++){\n\t\t\t\t//\n\t\t\t\tif(car < n){\n\t\t\t\t\tremain_queue.add(sc.nextInt());\n\t\t\t\t\tnumber_queue.add(car + 1);\n\t\t\t\t}else if(remain_queue.isEmpty() && is_finish(spaces, m)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tadd_time(spaces, m, 10);\n\t\t\t\t//print(spaces, numbers, m);\n\t\t\t\t\n\t\t\t\twhile(true){\n\t\t\t\t\tint min = 1;\n\t\t\t\t\tint min_pos = -1;\n\t\t\t\t\tint min_car = -1;\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\t\t\tif(spaces[i][0] <= M_INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(spaces[i][0] < min){\n\t\t\t\t\t\t\tmin = spaces[i][0];\n\t\t\t\t\t\t\tmin_car = numbers[i][0];\n\t\t\t\t\t\t\tmin_pos = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(min_car == -1){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tspaces[min_pos][0] = spaces[min_pos][1];\n\t\t\t\t\tnumbers[min_pos][0] = numbers[min_pos][1];\n\t\t\t\t\tspaces[min_pos][1] = M_INF;\n\t\t\t\t\tnumbers[min_pos][1] = M_INF;\n\t\t\t\t\tout_numbers.add(min_car);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile(!remain_queue.isEmpty()){\n\t\t\t\t\tfinal int remain_time = remain_queue.poll();\n\t\t\t\t\tfinal int car_number  = number_queue.poll();\n\t\t\t\t\t\n\t\t\t\t\tif(try_fst(spaces, numbers, m, remain_time, car_number)){\n\t\t\t\t\t\t//ok\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(try_snd(spaces, numbers, m, remain_time, car_number)){\n\t\t\t\t\t\t//ok\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//System.out.println(\"fail \" + car_number);\n\t\t\t\t\t\tremain_queue.addFirst(remain_time);\n\t\t\t\t\t\tnumber_queue.addFirst(car_number);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean first = true;\n\t\t\tfor(int i : out_numbers){\n\t\t\t\tif(first){\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tSystem.out.print(i);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.print(\" \" + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\t//System.out.println(out_numbers);\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Car {\n        int id;\n        int arrivalTime;\n        int parkingDuration;\n        int departureTime;\n        \n        Car(int id, int arrivalTime, int parkingDuration) {\n            this.id = id;\n            this.arrivalTime = arrivalTime;\n            this.parkingDuration = parkingDuration;\n            this.departureTime = arrivalTime + parkingDuration;\n        }\n    }\n    \n    static class Space {\n        Car lower;\n        Car upper;\n        \n        boolean isEmpty() {\n            return lower == null && upper == null;\n        }\n        \n        boolean hasSpace() {\n            return lower == null || upper == null;\n        }\n        \n        int getRemainingTime(int currentTime) {\n            if (lower != null) {\n                return Math.max(0, lower.departureTime - currentTime);\n            }\n            return 0;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            \n            if (m == 0 && n == 0) break;\n            \n            List<Car> cars = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int duration = sc.nextInt();\n                cars.add(new Car(i + 1, i * 10, duration));\n            }\n            \n            Space[] spaces = new Space[m];\n            for (int i = 0; i < m; i++) {\n                spaces[i] = new Space();\n            }\n            \n            Queue<Car> waitingQueue = new LinkedList<>();\n            List<Integer> exitOrder = new ArrayList<>();\n            int carIndex = 0;\n            int currentTime = 0;\n            \n            while (exitOrder.size() < n) {\n                // Process departures\n                List<Car> departing = new ArrayList<>();\n                for (int i = 0; i < m; i++) {\n                    Space space = spaces[i];\n                    if (space.lower != null && space.lower.departureTime <= currentTime) {\n                        departing.add(space.lower);\n                        if (space.upper != null && space.upper.departureTime <= currentTime) {\n                            departing.add(space.upper);\n                        }\n                    }\n                }\n                \n                Collections.sort(departing, (a, b) -> {\n                    for (int i = 0; i < m; i++) {\n                        if (spaces[i].lower == a) return -1;\n                        if (spaces[i].lower == b) return 1;\n                    }\n                    return 0;\n                });\n                \n                for (Car car : departing) {\n                    exitOrder.add(car.id);\n                    for (int i = 0; i < m; i++) {\n                        if (spaces[i].lower == car) {\n                            spaces[i].lower = spaces[i].upper;\n                            spaces[i].upper = null;\n                            break;\n                        }\n                    }\n                }\n                \n                // Add arriving cars to queue\n                while (carIndex < n && cars.get(carIndex).arrivalTime <= currentTime) {\n                    waitingQueue.add(cars.get(carIndex));\n                    carIndex++;\n                }\n                \n                // Process parking\n                while (!waitingQueue.isEmpty()) {\n                    Car car = waitingQueue.peek();\n                    int bestSpace = findBestSpace(spaces, car, currentTime);\n                    \n                    if (bestSpace == -1) break;\n                    \n                    waitingQueue.poll();\n                    if (spaces[bestSpace].isEmpty()) {\n                        spaces[bestSpace].lower = car;\n                    } else {\n                        spaces[bestSpace].upper = car;\n                    }\n                }\n                \n                currentTime++;\n            }\n            \n            for (int i = 0; i < exitOrder.size(); i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(exitOrder.get(i));\n            }\n            System.out.println();\n        }\n    }\n    \n    static int findBestSpace(Space[] spaces, Car car, int currentTime) {\n        int bestSpace = -1;\n        int bestDiff = Integer.MAX_VALUE;\n        boolean foundEmpty = false;\n        \n        // First check for empty spaces\n        for (int i = 0; i < spaces.length; i++) {\n            if (spaces[i].isEmpty()) {\n                return i;\n            }\n        }\n        \n        // Check for spaces with one car\n        for (int i = 0; i < spaces.length; i++) {\n            if (spaces[i].hasSpace() && !spaces[i].isEmpty()) {\n                int remaining = spaces[i].getRemainingTime(currentTime);\n                int diff = Math.abs(remaining - car.parkingDuration);\n                \n                if (remaining >= car.parkingDuration) {\n                    if (bestSpace == -1 || diff < bestDiff || \n                        (diff == bestDiff && remaining >= car.parkingDuration)) {\n                        bestSpace = i;\n                        bestDiff = diff;\n                    }\n                } else {\n                    if (bestSpace == -1 || spaces[bestSpace].getRemainingTime(currentTime) >= car.parkingDuration || diff < bestDiff) {\n                        bestSpace = i;\n                        bestDiff = diff;\n                    }\n                }\n            }\n        }\n        \n        return bestSpace;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  int id; int arrivalTime; int parkingDuration;  arrivalTime, int parkingDuration)  = arrivalTime; this.parkingDuration = parkingDuration; this.departureTime = arrivalTime + parkingDuration; } } static class Space {   null  boolean hasSpace() { return lower == null || upper == null; } int getRemainingTime(int currentTime) {  return Math.max(0, lower.departureTime - currentTime); } return  void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int m = sc.nextInt(); int n = sc.nextInt();  n == 0) break; List<Car> cars = new  0; i < n; i++) { int duration = sc.nextInt(); cars.add(new Car(i + 1, i * 10, duration)); } Space[] spaces = new Space[m]; for (int i = 0; i < m;  = new LinkedList<>(); List<Integer> exitOrder = new ArrayList<>(); int carIndex = 0; int  < n) { // Process departures List<Car> departing  i = 0; i < m; i++) { Space space = spaces[i]; if (space.lower != null && space.lower.departureTime <= currentTime) { departing.add(space.lower); if (space.upper != null && space.upper.departureTime <=  i = 0; i < m; i++) { if (spaces[i].lower == a) return -1;  }); for (Car car :  < m; i++) { if (spaces[i].lower == car) { spaces[i].lower = spaces[i].upper; spaces[i].upper  } // Add arriving cars to queue  cars.get(carIndex).arrivalTime <=  // Process parking while (!waitingQueue.isEmpty()) { Car car = waitingQueue.peek(); int bestSpace = findBestSpace(spaces, car, currentTime); if (bestSpace == -1) break; waitingQueue.poll(); if (spaces[bestSpace].isEmpty()) { spaces[bestSpace].lower = car; } else { spaces[bestSpace].upper = car; } } currentTime++; } for (int i = 0; i < exitOrder.size(); i++)  System.out.print(\" \"); System.out.print(exitOrder.get(i)); } System.out.println(); } } static int findBestSpace(Space[] spaces, Car car, int currentTime) { int bestSpace = -1; int bestDiff = Integer.MAX_VALUE; boolean foundEmpty = false; // First check for  = 0; i  } } // Check for spaces with one car for (int i = 0; i < spaces.length; i++) { if (spaces[i].hasSpace() && !spaces[i].isEmpty()) { int remaining = spaces[i].getRemainingTime(currentTime); int diff = Math.abs(remaining - car.parkingDuration); if (remaining >= car.parkingDuration) { if (bestSpace == -1 || diff < bestDiff || (diff == bestDiff && remaining >= car.parkingDuration)) { bestSpace = i; bestDiff = diff; } } else   diff < bestDiff) { bestSpace = i; bestDiff = diff; } } } } return bestSpace; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.LinkedList; import   final int MAX_CAR = 100; public static final int M_INF = Integer.MIN_VALUE / 2 + 1; public static boolean try_fst(int[][] spaces, int[][] numbers, final int m, final  for(int i = 0; i < m; i++){  remain_time;  } } return false;  spaces, final int m, final int time){ for(int i = 0; i < m; i++){ if(spaces[i][0] <= M_INF){ continue; } spaces[i][0] -= time; spaces[i][1] -= time; } } public static  m){ for(int i = 0; i < m; i++){ if(spaces[i][0] > M_INF){ return false; } } return  can_upper(int[][] spaces, int[][] numbers, final int m, final int remain_time,  = 0; i < m; i++){ if(spaces[i][0] >= remain_time && spaces[i][1] <=  static boolean try_snd(int[][] spaces,  int car_number){ final  m, remain_time, car_number); int pos = -1; int attr = can_upper ? Integer.MAX_VALUE : Integer.MIN_VALUE; for(int i = 0; i < m; i++){ //System.out.println(can_upper + \" \" + (spaces[i][0]<= M_INF) +  spaces[i][0])); if(can_upper && spaces[i][1] <= M_INF && spaces[i][0] >= remain_time &&  spaces[i][0]; pos = i; }else if(!can_upper && spaces[i][1] <= M_INF && attr < spaces[i][0]){ attr = spaces[i][0]; pos = i; } } //System.out.println(attr  + \"  0){ return false; } spaces[pos][1] = Math.max(spaces[pos][0], remain_time); numbers[pos][1] = numbers[pos][0]; spaces[pos][0] = remain_time; numbers[pos][0] = car_number; return true; } public static void print(int[][] spaces, int[][] numbers, final int m){ System.out.println(\"-----------------------------------\");  < m; i++){ System.out.print(spaces[i][0] + \" \"); } System.out.println(); for(int i = 0; i < m; i++){ System.out.print(spaces[i][1] + \" \");  0; i < m;  } System.out.println(); for(int i = 0; i < m; i++){ System.out.print(numbers[i][1] + \" \"); } System.out.println(); System.out.println(\"-----------------------------------\"); } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int[][]  numbers =  m = sc.nextInt();  if(m ==  = 0; i < m; i++){ spaces[i][0] = spaces[i][1] = M_INF; numbers[i][0] = numbers[i][1] = -1; } LinkedList<Integer> remain_queue = new LinkedList<Integer>(); LinkedList<Integer> number_queue = new LinkedList<Integer>(); //int time = 0; LinkedList<Integer> out_numbers = new LinkedList<Integer>(); for(int car = 0; ; car++){ // if(car < n){ remain_queue.add(sc.nextInt()); number_queue.add(car + 1); }else if(remain_queue.isEmpty() && is_finish(spaces,  10); //print(spaces, numbers, m); while(true){ int min = 1; int min_pos =  for(int i = 0; i < m; i++){ if(spaces[i][0] <= M_INF){ continue; }else if(spaces[i][0]  min_car = numbers[i][0]; min_pos = i; }  numbers[min_pos][0] = numbers[min_pos][1]; spaces[min_pos][1] = M_INF; numbers[min_pos][1] = M_INF; out_numbers.add(min_car); } while(!remain_queue.isEmpty()){ final int remain_time = remain_queue.poll(); final int car_number = number_queue.poll(); if(try_fst(spaces, numbers, m, remain_time, car_number)){ //ok continue; }else if(try_snd(spaces, numbers, m, remain_time,  number_queue.addFirst(car_number); break; } } } boolean first = true; for(int i : out_numbers){ if(first){ first = false;  i); } } System.out.println(); //System.out.println(out_numbers); } } }"], "original_ll": -0.5524575710296631, "sampled_ll": -0.5062803030014038, "all_perturbed_sampled_ll": [-1.4176373481750488], "all_perturbed_original_ll": [-1.3892512321472168], "perturbed_sampled_ll": -1.4176373481750488, "perturbed_original_ll": -1.3892512321472168, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import deque\n\ndef out(time, parking):\n  x = len(parking)\n  outs = []\n  for i in range(x):\n    for j in range(2):\n      if parking[i][j] != None:\n        parking[i][j][0] -= time\n  \n  for i in range(x):\n    c1 = parking[i][0]\n    c2 = parking[i][1]\n    if c1 != None and c2 != None:\n      if c1[0] <= 0 and c2[0] <= 0:\n        outs.append([c2[1], c1[1]])\n        parking[i][0] = None\n        parking[i][1] = None\n      elif c2[0] <= 0:\n        outs.append([c2[1]])\n        parking[i][1] = None\n    elif c1 != None:\n      if c1[0] <= 0:\n        outs.append([c1[1]])\n        parking[i][0] = None\n    elif c2 != None:\n      if c2[0] <= 0:\n        outs.append([c2[1]])\n        parking[i][1] = None\n  outs.sort()\n  lst = []\n  for l in outs:\n    lst += l\n  return lst\n\ndef into(num, time, parking):\n  x = len(parking)\n  times = []\n  for i in range(x):\n    if parking[i] == [None, None]:\n      parking[i][0] = [time, num]\n      return\n    if parking[i][0] == None:\n      times.append((parking[i][1][0], i))\n    elif parking[i][1] == None:\n      times.append((parking[i][0][0], i))\n  times.sort()\n  \n  for t, ind in times:\n    if t >= time:\n      if parking[ind][0] == None:\n        parking[ind][0] = [time, num]\n      else:\n        parking[ind][1] = [time, num]\n      return\n  else:\n    max_t = t\n\n  for t, ind in times:\n    if t == max_t:\n      if parking[ind][0] == None:\n        parking[ind][0] = [time, num]\n      else:\n        parking[ind][1] = [time, num]\n      return\n \nwhile True:\n  m, n = map(int, input().split())\n  if m == 0:\n    break\n  \n  parking = [[None] * 2 for _ in range(m)]\n  wait = deque()\n  space = m * 2\n  ans = []\n  \n  for t in range(120 * n):\n    o = out(1, parking)\n    if o:\n      space += len(o)\n      ans += o\n\n    if t % 10 == 0 and t <= 10 * (n - 1):\n      time = int(input())\n      wait.append((t // 10 + 1, time))\n\n    for i in range(min(space, len(wait))):\n      num, time = wait.popleft()\n      into(num, time, parking)\n      space -= 1\n  print(*ans)\n", "sampled": "import heapq\nfrom collections import deque\n\ndef solve(m, n, parking_times):\n    # spaces[i] = [lower_car, upper_car] where car = (car_id, end_time)\n    spaces = [[None, None] for _ in range(m)]\n    waiting_queue = deque()\n    events = []  # (time, event_type, data)\n    exit_order = []\n    \n    current_time = 0\n    \n    for car_id in range(1, n + 1):\n        arrival_time = (car_id - 1) * 10\n        parking_time = parking_times[car_id - 1]\n        heapq.heappush(events, (arrival_time, 0, car_id, parking_time))  # 0 = arrival\n    \n    while events or waiting_queue:\n        if not events:\n            break\n            \n        current_time, event_type, *data = heapq.heappop(events)\n        \n        if event_type == 0:  # arrival\n            car_id, parking_time = data\n            end_time = current_time + parking_time\n            \n            # Process all exits at current time first\n            exits_now = []\n            temp_events = []\n            while events and events[0][0] == current_time and events[0][1] == 1:\n                temp_events.append(heapq.heappop(events))\n            \n            for ev in temp_events:\n                exits_now.append(ev)\n            \n            # Process exits\n            for exit_event in sorted(exits_now, key=lambda x: x[2]):\n                space_id = x[2]\n                process_exit(spaces, space_id, exit_order)\n            \n            # Put events back\n            for ev in temp_events:\n                if ev not in exits_now:\n                    heapq.heappush(events, ev)\n            \n            # Try to park cars from waiting queue\n            while waiting_queue:\n                w_car_id, w_parking_time, w_arrival = waiting_queue[0]\n                w_end_time = w_arrival + w_parking_time\n                space_idx = find_space(spaces, w_parking_time, current_time)\n                if space_idx == -1:\n                    break\n                waiting_queue.popleft()\n                park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events)\n            \n            # Try to park current car\n            space_idx = find_space(spaces, parking_time, current_time)\n            if space_idx == -1:\n                waiting_queue.append((car_id, parking_time, current_time))\n            else:\n                park_car(spaces, space_idx, car_id, end_time, current_time, events)\n                \n        elif event_type == 1:  # exit\n            space_id = data[0]\n            process_exit(spaces, space_id, exit_order)\n            \n            # Try to park cars from waiting queue\n            while waiting_queue:\n                w_car_id, w_parking_time, w_arrival = waiting_queue[0]\n                w_end_time = current_time + w_parking_time\n                space_idx = find_space(spaces, w_parking_time, current_time)\n                if space_idx == -1:\n                    break\n                waiting_queue.popleft()\n                park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events)\n    \n    return exit_order\n\ndef find_space(spaces, parking_time, current_time):\n    empty_spaces = []\n    one_car_spaces = []\n    \n    for i, space in enumerate(spaces):\n        if space[0] is None:\n            empty_spaces.append(i)\n        elif space[1] is None:\n            remaining_time = space[0][1] - current_time\n            one_car_spaces.append((i, remaining_time))\n    \n    if empty_spaces:\n        return min(empty_spaces)\n    \n    if not one_car_spaces:\n        return -1\n    \n    # Find best space\n    ge_spaces = [(i, rt) for i, rt in one_car_spaces if rt >= parking_time]\n    lt_spaces = [(i, rt) for i, rt in one_car_spaces if rt < parking_time]\n    \n    if ge_spaces:\n        best = min(ge_spaces, key=lambda x: (x[1] - parking_time, x[0]))\n        return best[0]\n    else:\n        best = min(lt_spaces, key=lambda x: (parking_time - x[1], x[0]))\n        return best[0]\n\ndef park_car(spaces, space_idx, car_id, end_time, current_time, events):\n    if spaces[space_idx][0] is None:\n        spaces[space_idx][0] = (car_id, end_time)\n        heapq.heappush(events, (end_time, 1, space_idx))\n    else:\n        spaces[space_idx][1] = (car_id, end_time)\n\ndef process_exit(spaces, space_id, exit_order):\n    if spaces[space_id][1] is not None:\n        exit_order.append(spaces[space_id][0][0])\n        exit_order.append(spaces[space_id][1][0])\n        spaces[space_id][0] = None\n        spaces[space_id][1] = None\n    elif spaces[space_id][0] is not None:\n        exit_order.append(spaces[space_id][0][0])\n        spaces[space_id][0] = None\n\nwhile True:\n    line = input().split()\n    m, n = int(line[0]), int(line[1])\n    if m == 0 and n == 0:\n        break\n    \n    parking_times = []\n    for _ in range(n):\n        parking_times.append(int(input()))\n    \n    result = solve(m, n, parking_times)\n    print(' '.join(map(str, result)))\n", "perturbed_sampled": ["import heapq from collections import deque def solve(m,  [lower_car, upper_car] where car = (car_id, end_time) spaces = [[None, None] for _ in range(m)] waiting_queue = deque() events = [] # (time, event_type,  = 0 for car_id in range(1, n + 1): arrival_time =  parking_time = parking_times[car_id - 1] heapq.heappush(events, (arrival_time, 0, car_id, parking_time)) # 0 = arrival while events or waiting_queue: if not events: break current_time, event_type, *data = heapq.heappop(events) if event_type == 0: # arrival car_id, parking_time = data  # Process all exits at current time first exits_now =   and events[0][1] == 1: temp_events.append(heapq.heappop(events)) for ev in temp_events: exits_now.append(ev) # Process exits for exit_event in sorted(exits_now, key=lambda x: x[2]): space_id = x[2] process_exit(spaces, space_id, exit_order) # Put events back for  not in exits_now: heapq.heappush(events, ev) # Try   w_arrival = waiting_queue[0] w_end_time = w_arrival + w_parking_time space_idx = find_space(spaces, w_parking_time,  break waiting_queue.popleft() park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events) # Try to park current car space_idx = find_space(spaces, parking_time, current_time) if space_idx == -1: waiting_queue.append((car_id, parking_time, current_time))  == 1: # exit  exit_order) # Try to park cars from waiting queue while waiting_queue: w_car_id, w_parking_time, w_arrival =  w_parking_time space_idx = find_space(spaces, w_parking_time, current_time) if space_idx == -1: break waiting_queue.popleft()  events) return exit_order def find_space(spaces,  one_car_spaces = [] for i,  is None: empty_spaces.append(i) elif space[1] is None: remaining_time = space[0][1] - current_time one_car_spaces.append((i, remaining_time)) if empty_spaces: return min(empty_spaces) if not one_car_spaces: return -1 # Find best space  i, rt in one_car_spaces  if rt < parking_time] if ge_spaces: best = min(ge_spaces, key=lambda x: (x[1] - parking_time,  = min(lt_spaces, key=lambda x: (parking_time - x[1], x[0])) return best[0] def park_car(spaces, space_idx, car_id, end_time, current_time, events): if spaces[space_idx][0] is None: spaces[space_idx][0] = (car_id, end_time) heapq.heappush(events, (end_time,  (car_id, end_time) def process_exit(spaces, space_id, exit_order): if spaces[space_id][1] is not None: exit_order.append(spaces[space_id][0][0]) exit_order.append(spaces[space_id][1][0]) spaces[space_id][0] = None spaces[space_id][1] =  None: exit_order.append(spaces[space_id][0][0]) spaces[space_id][0] = None while True: line = input().split() m, n =   break parking_times = [] for _ in range(n):  parking_times) print(' '.join(map(str, result)))"], "perturbed_original": ["from collections  x = len(parking) outs = [] for i in range(x): for j in range(2): if parking[i][j] != None: parking[i][j][0] -= time for i in range(x): c1 = parking[i][0] c2 = parking[i][1] if c1 != None and c2 != None: if c1[0] <= 0 and c2[0] <= 0: outs.append([c2[1], c1[1]]) parking[i][0] = None parking[i][1] =  outs.append([c2[1]]) parking[i][1] = None elif c1 != None: if c1[0] <= 0: outs.append([c1[1]]) parking[i][0] = None elif c2 != None:  parking[i][1] = None outs.sort() lst = [] for l in outs: lst += l return lst def into(num, time, parking): x = len(parking) times = [] for i  [None, None]: parking[i][0] = [time,  parking[i][1] == None: times.append((parking[i][0][0], i)) times.sort() for t, ind in times: if t >=  parking[ind][0] = [time, num] else: parking[ind][1] = [time, num] return else: max_t = t for t, ind in times: if t  None: parking[ind][0] = [time, num] else:  while True: m, n  == 0: break parking = [[None]  range(m)]  m * 2 ans = [] for  if o: space += len(o) ans += o if t  (n - 1): time = int(input()) wait.append((t // 10 + 1, time)) for i in range(min(space, len(wait))): num, time = wait.popleft() into(num, time, parking) space -= 1 print(*ans)"], "original_ll": -0.725325345993042, "sampled_ll": -0.6212821006774902, "all_perturbed_sampled_ll": [-1.6264450550079346], "all_perturbed_original_ll": [-1.7856203317642212], "perturbed_sampled_ll": -1.6264450550079346, "perturbed_original_ll": -1.7856203317642212, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0193: Convenience Store\n// 2017.8.25 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define abs(a) ((a)>=0?(a):(-(a)))\n//#define min(a,b) ((a)<=(b)?(a):(b))\n\ntypedef struct { int r, c, f; } T;\nT shop[25]; int n, S, N;\nint R, C;\n\nint hexDistance(int r1, int c1, int r2, int c2)\n{\n\tint dr, dc, c;\n\tdr = abs(r2 - r1), dc = abs(c2 - c1);\n\tif (r2 == r1) return dc;\n\tif (c2 == c1) return dr;\n\tif (r2 < r1) c = r2, r2 = r1, r1 = c, c = c2, c2 = c1, c1 = c;\n\tif (c2 >= c1) {\n\t\tc = c1 + (dr+1-(r1&1))/2;\n\t\tif (c2 >= c) dr += abs(c-c2);\n\t} else {\n\t\tc = c1 - (dr+(r1&1))/2;\n\t\tif (c2 <= c) dr += abs(c-c2);\n\t}\n\treturn dr;\n}\n\nint belong(int r, int c)\n{\n\tint i, d, k, min;\n\tfor (min = -1, d = -2, k = 0, i = 1; i <= n; i++) {\n\t\td = hexDistance(shop[i].r, shop[i].c, r, c);\n\t\tif (min < 0 || d < min) min = d, k = i;\n\t\telse if (d == min) k = 0;\n\t}\n\treturn k;\n}\n\nint main()\n{\n\tint i, r, c;\n\tint ans;\n\n\twhile (scanf(\"%d%d\", &C, &R) && C) {\n\t\tscanf(\"%d\", &S);\n\t\tfor (n = 1, i = 0; i < S; i++) {\n\t\t\tscanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0;\n\t\t}\n\t\tscanf(\"%d\", &N);\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0;\n\t\t}\n\t\tn--;\n\t\tfor (r = 1; r <= R; r++) for (c = 1; c <= C; c++)\n\t\t\tif ((i = belong(r, c)) > 0) shop[i].f++;\n\t\tfor (ans = -1, i = S+1; i <= n; i++) if (shop[i].f > ans) ans = shop[i].f;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint dx_odd[6] = {0, 1, 1, 0, -1, -1};\nint dy_odd[6] = {-1, -1, 0, 1, 0, -1};\nint dx_even[6] = {-1, 0, 1, 1, 1, 0};\nint dy_even[6] = {-1, -1, 0, 1, 0, -1};\n\ntypedef struct {\n    int x, y, dist;\n} Node;\n\nint dist[101][101];\nint queue[20000][2];\nint qfront, qrear;\n\nvoid bfs(int sx, int sy, int m, int n) {\n    int visited[101][101] = {0};\n    qfront = qrear = 0;\n    queue[qrear][0] = sx;\n    queue[qrear][1] = sy;\n    qrear++;\n    visited[sx][sy] = 1;\n    dist[sx][sy] = 0;\n    \n    while (qfront < qrear) {\n        int cx = queue[qfront][0];\n        int cy = queue[qfront][1];\n        qfront++;\n        \n        int *dx = (cy % 2 == 1) ? dx_odd : dx_even;\n        int *dy = (cy % 2 == 1) ? dy_odd : dy_even;\n        \n        for (int i = 0; i < 6; i++) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n            \n            if (nx >= 1 && nx <= m && ny >= 1 && ny <= n && !visited[nx][ny]) {\n                visited[nx][ny] = 1;\n                dist[nx][ny] = dist[cx][cy] + 1;\n                queue[qrear][0] = nx;\n                queue[qrear][1] = ny;\n                qrear++;\n            }\n        }\n    }\n}\n\nint main() {\n    int m, n;\n    \n    while (scanf(\"%d %d\", &m, &n) == 2) {\n        if (m == 0 && n == 0) break;\n        \n        int s;\n        scanf(\"%d\", &s);\n        Point stores[11];\n        for (int i = 0; i < s; i++) {\n            scanf(\"%d %d\", &stores[i].x, &stores[i].y);\n        }\n        \n        int t;\n        scanf(\"%d\", &t);\n        Point candidates[11];\n        for (int i = 0; i < t; i++) {\n            scanf(\"%d %d\", &candidates[i].x, &candidates[i].y);\n        }\n        \n        int max_coverage = 0;\n        \n        for (int cand = 0; cand < t; cand++) {\n            int coverage = 0;\n            \n            for (int x = 1; x <= m; x++) {\n                for (int y = 1; y <= n; y++) {\n                    int min_dist_cand = 1000000;\n                    int min_dist_store = 1000000;\n                    int count_min_store = 0;\n                    \n                    bfs(candidates[cand].x, candidates[cand].y, m, n);\n                    min_dist_cand = dist[x][y];\n                    \n                    for (int i = 0; i < s; i++) {\n                        bfs(stores[i].x, stores[i].y, m, n);\n                        int d = dist[x][y];\n                        if (d < min_dist_store) {\n                            min_dist_store = d;\n                            count_min_store = 1;\n                        } else if (d == min_dist_store) {\n                            count_min_store++;\n                        }\n                    }\n                    \n                    if (min_dist_cand < min_dist_store) {\n                        coverage++;\n                    } else if (min_dist_cand == min_dist_store && count_min_store == 0) {\n                        coverage++;\n                    }\n                }\n            }\n            \n            if (coverage > max_coverage) {\n                max_coverage = coverage;\n            }\n        }\n        \n        printf(\"%d\\n\", max_coverage);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int x,  = {0, 1, 1, 0, -1, -1}; int   = {-1, 0, 1, 1, 1, 0}; int dy_even[6] = {-1, -1, 0, 1, 0, -1}; typedef  dist; } Node; int dist[101][101]; int queue[20000][2]; int qfront, qrear; void bfs(int sx, int  { int visited[101][101] = {0}; qfront = qrear = 0; queue[qrear][0]   < qrear) { int cx = queue[qfront][0]; int cy = queue[qfront][1]; qfront++; int *dx = (cy % 2 == 1) ? dx_odd : dx_even; int *dy = (cy % 2 == 1) ? dy_odd : dy_even;  i < 6; i++) { int nx = cx  cy + dy[i]; if (nx >= 1 && nx <= m &&   visited[nx][ny] = 1; dist[nx][ny] = dist[cx][cy] + 1; queue[qrear][0]  } int main() {  %d\", &m, &n) == 2) { if (m ==  break; int s; scanf(\"%d\", &s);   &stores[i].x, &stores[i].y); } int t; scanf(\"%d\", &t); Point candidates[11]; for (int  t; i++) { scanf(\"%d %d\", &candidates[i].x, &candidates[i].y); } int max_coverage = 0; for (int cand = 0; cand < t;  0; for (int x = 1; x <= m; x++) { for (int y =  { int min_dist_cand = 1000000; int min_dist_store = 1000000;  candidates[cand].y, m, n); min_dist_cand = dist[x][y]; for (int i = 0; i < s; i++) { bfs(stores[i].x, stores[i].y, m, n); int d = dist[x][y]; if (d < min_dist_store) { min_dist_store = d; count_min_store = 1; } else if (d == min_dist_store) { count_min_store++; } } if (min_dist_cand < min_dist_store) { coverage++; } else if (min_dist_cand == min_dist_store && count_min_store == 0) { coverage++; } } } if (coverage > max_coverage) { max_coverage = coverage; } } printf(\"%d\\n\", max_coverage); } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0193: Convenience Store // 2017.8.25 bal4u@uu #include <stdio.h> #include <string.h> #define abs(a) ((a)>=0?(a):(-(a))) //#define min(a,b) ((a)<=(b)?(a):(b)) typedef <extra_id_5>C <=<extra_id_6>{ int ans = 0<extra_id_7>; for (<extra_id_8>== C;<extra_id_9>(C < C) &&<extra_id_10>(s,<extra_id_11>; if (<extra_id_12>; if (<extra_id_13>= 0 ;<extra_id_14>= 0 ;<extra_id_15>1 ; if (<extra_id_16>R = 0 ; r<extra_id_17>0 ; i<extra_id_18>;<extra_id_19>= 1 ;<extra_id_20>(b = min (<extra_id_21>C >=  int n, S, N; int R, C; int hexDistance(int r1, int c1,  int dr, dc, c; dr = abs(r2 - r1), dc = abs(c2 - c1); if (r2 == r1) return dc; if (c2 == c1) return dr; if (r2 < r1) c = r2,  c, c =  = c; if (c2 >= c1) { c = c1 + (dr+1-(r1&1))/2; if  abs(c-c2); } else { c = c1 -  dr  } int belong(int r, int c) { int i, d, k, min; for (min = -1, d = -2, k = 0, i = 1; i <= n; i++) { d = hexDistance(shop[i].r, shop[i].c, r, c); if (min  min) min = d, k = i; else if (d == min) k = 0; } return k; } int main() { int i, r, c; int  && C) { scanf(\"%d\", &S); for (n =  scanf(\"%d%d\", &shop[n].c, &shop[n].r),  &N); for  N; i++) { scanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0; } n--; for (r = 1; r <= R; r++) for (c  c++) if ((i = belong(r, c))  = -1, i = S+1; i <= n; i++) if (shop[i].f > ans)  } return 0; }"], "original_ll": -0.9315952062606812, "sampled_ll": -0.3970751464366913, "all_perturbed_sampled_ll": [-1.2675282955169678], "all_perturbed_original_ll": [-1.9843885898590088], "perturbed_sampled_ll": -1.2675282955169678, "perturbed_original_ll": -1.9843885898590088, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tfor(int m,n,x,a[][];(m=s.nextInt())>0;){\n\t\t\tn=s.nextInt();\n\t\t\tx=s.nextInt();\n\t\t\ta=new int[n][m];\n\t\t\tDeque<int[]>q=new ArrayDeque<int[]>();\n\t\t\tfor(int i=0;i<x;++i){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\ta[u][v]=1;\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t}\n\t\t\tint[][]dm={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}};\n\t\t\tint[][]dn={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}};\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[]t=q.poll();\n\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\tint u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i];\n\t\t\t\t\tif(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){\n\t\t\t\t\t\tq.add(new int[]{u,v,a[u][v]=t[2]+1});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=0;\n\t\t\tfor(x=s.nextInt();x-->0;){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\tif(a[u][v]>1){\n\t\t\t\t\tint[][] tmp = new int[n][];\n\t\t\t\t\tfor(int i=0;i<n;++i)\n\t\t\t\t\t\ttmp[i]=Arrays.copyOf(a[i],m);\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t\tint c=1;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint[]t=q.poll();\n\t\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\t\tint u1=t[0]+dn[t[0]%2][i],v1=t[1]+dm[t[0]%2][i];\n\t\t\t\t\t\tif(0<=u1&&u1<n&&0<=v1&&v1<m&&tmp[u1][v1]>t[2]+1){\n\t\t\t\t\t\t\t++c;\n\t\t\t\t\t\t\tq.add(new int[]{u1,v1,tmp[u1][v1]=t[2]+1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr=r>c?r:c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int m, n;\n    static int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, -1}, {-1, 1}};\n    \n    static int[][] getNeighbors(int x, int y) {\n        int[][] neighbors = new int[6][2];\n        if (y % 2 == 1) {\n            neighbors[0] = new int[]{x + 1, y};\n            neighbors[1] = new int[]{x - 1, y};\n            neighbors[2] = new int[]{x, y + 1};\n            neighbors[3] = new int[]{x, y - 1};\n            neighbors[4] = new int[]{x - 1, y + 1};\n            neighbors[5] = new int[]{x - 1, y - 1};\n        } else {\n            neighbors[0] = new int[]{x + 1, y};\n            neighbors[1] = new int[]{x - 1, y};\n            neighbors[2] = new int[]{x + 1, y + 1};\n            neighbors[3] = new int[]{x + 1, y - 1};\n            neighbors[4] = new int[]{x, y + 1};\n            neighbors[5] = new int[]{x, y - 1};\n        }\n        return neighbors;\n    }\n    \n    static int[][] computeDistances(int sx, int sy) {\n        int[][] dist = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            Arrays.fill(dist[i], -1);\n        }\n        \n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{sx, sy, 0});\n        dist[sx][sy] = 0;\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int x = curr[0];\n            int y = curr[1];\n            int d = curr[2];\n            \n            int[][] neighbors = getNeighbors(x, y);\n            for (int[] neighbor : neighbors) {\n                int nx = neighbor[0];\n                int ny = neighbor[1];\n                if (nx >= 1 && nx <= m && ny >= 1 && ny <= n && dist[nx][ny] == -1) {\n                    dist[nx][ny] = d + 1;\n                    queue.offer(new int[]{nx, ny, d + 1});\n                }\n            }\n        }\n        \n        return dist;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            m = sc.nextInt();\n            n = sc.nextInt();\n            if (m == 0 && n == 0) break;\n            \n            int s = sc.nextInt();\n            int[][] existing = new int[s][2];\n            for (int i = 0; i < s; i++) {\n                existing[i][0] = sc.nextInt();\n                existing[i][1] = sc.nextInt();\n            }\n            \n            int t = sc.nextInt();\n            int[][] candidates = new int[t][2];\n            for (int i = 0; i < t; i++) {\n                candidates[i][0] = sc.nextInt();\n                candidates[i][1] = sc.nextInt();\n            }\n            \n            int[][][] existingDist = new int[s][][];\n            for (int i = 0; i < s; i++) {\n                existingDist[i] = computeDistances(existing[i][0], existing[i][1]);\n            }\n            \n            int maxCoverage = 0;\n            \n            for (int c = 0; c < t; c++) {\n                int[][] newDist = computeDistances(candidates[c][0], candidates[c][1]);\n                int coverage = 0;\n                \n                for (int x = 1; x <= m; x++) {\n                    for (int y = 1; y <= n; y++) {\n                        boolean isExisting = false;\n                        for (int i = 0; i < s; i++) {\n                            if (existing[i][0] == x && existing[i][1] == y) {\n                                isExisting = true;\n                                break;\n                            }\n                        }\n                        if (isExisting) continue;\n                        \n                        if (candidates[c][0] == x && candidates[c][1] == y) continue;\n                        \n                        int minDist = newDist[x][y];\n                        if (minDist == -1) continue;\n                        \n                        boolean uniqueMin = true;\n                        for (int i = 0; i < s; i++) {\n                            int d = existingDist[i][x][y];\n                            if (d == -1) continue;\n                            if (d < minDist) {\n                                uniqueMin = false;\n                                break;\n                            } else if (d == minDist) {\n                                uniqueMin = false;\n                                break;\n                            }\n                        }\n                        \n                        if (uniqueMin) {\n                            coverage++;\n                        }\n                    }\n                }\n                \n                maxCoverage = Math.max(maxCoverage, coverage);\n            }\n            \n            System.out.println(maxCoverage);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int m, n; static int[][] dirs =  1}, {0, -1}, {1, -1}, {-1, 1}}; static int[][] getNeighbors(int x, int y) { int[][] neighbors = new int[6][2]; if (y % 2 == 1) { neighbors[0] = new int[]{x + 1, y}; neighbors[1] = new  + 1};  - 1}; neighbors[4] = new int[]{x - 1, y + 1}; neighbors[5] =  - 1}; } else { neighbors[0] = new int[]{x + 1, y}; neighbors[1] = new int[]{x - 1, y}; neighbors[2] = new int[]{x + 1, y + 1}; neighbors[3] = new int[]{x + 1, y - 1}; neighbors[4] = new int[]{x,  new  return neighbors; } static int[][] computeDistances(int sx, int sy) { int[][] dist  + 1]; for (int i  i++) { Arrays.fill(dist[i], -1); } Queue<int[]> queue = new LinkedList<>(); queue.offer(new int[]{sx, sy, 0}); dist[sx][sy] = 0;  = queue.poll(); int x = curr[0]; int  = curr[2]; int[][]  (int[] neighbor : neighbors) { int nx = neighbor[0]; int ny = neighbor[1]; if (nx >=  && ny >= 1 && ny <= n && dist[nx][ny]  d + 1; queue.offer(new int[]{nx, ny, d + 1}); } } } return dist; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true)  = sc.nextInt(); if (m  0) break; int s  new int[s][2]; for (int i = 0; i < s; i++) { existing[i][0] = sc.nextInt(); existing[i][1] = sc.nextInt(); } int t =  = 0; i < t; i++)  existingDist = new int[s][][]; for (int i = 0; i < s; i++) { existingDist[i] = computeDistances(existing[i][0],  t; c++) { int[][] newDist = computeDistances(candidates[c][0], candidates[c][1]); int coverage = 0; for (int x  x++) { for (int y =  { boolean isExisting = false; for (int i = 0; i < s; i++) { if (existing[i][0] == x && existing[i][1] == y) { isExisting = true;  continue; if (candidates[c][0] == x && candidates[c][1] == y) continue; int minDist = newDist[x][y]; if (minDist  = true; for (int i  i++) { int d = existingDist[i][x][y]; if (d == -1) continue; if (d < minDist) { uniqueMin = false; break; } else if (d == minDist) { uniqueMin =  } } maxCoverage = Math.max(maxCoverage, coverage); } System.out.println(maxCoverage); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner s=new  a=new int[n][m]; Deque<int[]>q=new ArrayDeque<int[]>(); for(int i=0;i<x;++i){ int v=s.nextInt()-1,u=s.nextInt()-1; a[u][v]=1;  while(!q.isEmpty()){ int[]t=q.poll(); for(int i=0;i<6;++i){ int u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i]; if(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){  int r=0; for(x=s.nextInt();x-->0;){ int v=s.nextInt()-1,u=s.nextInt()-1; if(a[u][v]>1){ int[][] tmp = new int[n][]; for(int i=0;i<n;++i)  while(!q.isEmpty()){ int[]t=q.poll(); for(int i=0;i<6;++i){ int u1=t[0]+dn[t[0]%2][i],v1=t[1]+dm[t[0]%2][i]; if(0<=u1&&u1<n&&0<=v1&&v1<m&&tmp[u1][v1]>t[2]+1){ ++c; q.add(new int[]{u1,v1,tmp[u1][v1]=t[2]+1}); } } } r=r>c?r:c; } } System.out.println(r); } } }"], "original_ll": -0.7162664532661438, "sampled_ll": -0.3137032389640808, "all_perturbed_sampled_ll": [-1.1437026262283325], "all_perturbed_original_ll": [-1.2011728286743164], "perturbed_sampled_ll": -1.1437026262283325, "perturbed_original_ll": -1.2011728286743164, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#Deven-Eleven:\nimport re\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n\nwhile True:\n    data = raw_input().sprit()\n    if data == \"0 0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()", "sampled": "from collections import deque\n\ndef get_neighbors(x, y, m, n):\n    neighbors = []\n    if y % 2 == 1:  # odd row\n        # neighbors for odd row\n        candidates = [\n            (x-1, y-1), (x, y-1),    # upper left, upper right\n            (x-1, y), (x+1, y),       # left, right\n            (x-1, y+1), (x, y+1)      # lower left, lower right\n        ]\n    else:  # even row\n        # neighbors for even row\n        candidates = [\n            (x, y-1), (x+1, y-1),     # upper left, upper right\n            (x-1, y), (x+1, y),       # left, right\n            (x, y+1), (x+1, y+1)      # lower left, lower right\n        ]\n    \n    for nx, ny in candidates:\n        if 1 <= nx <= m and 1 <= ny <= n:\n            neighbors.append((nx, ny))\n    \n    return neighbors\n\ndef bfs_distances(start_x, start_y, m, n):\n    distances = {}\n    queue = deque([(start_x, start_y, 0)])\n    distances[(start_x, start_y)] = 0\n    \n    while queue:\n        x, y, dist = queue.popleft()\n        \n        for nx, ny in get_neighbors(x, y, m, n):\n            if (nx, ny) not in distances:\n                distances[(nx, ny)] = dist + 1\n                queue.append((nx, ny, dist + 1))\n    \n    return distances\n\ndef count_covered_blocks(stores, m, n):\n    # For each block, find the minimum distance to any store\n    min_distances = {}\n    \n    for i, (sx, sy) in enumerate(stores):\n        distances = bfs_distances(sx, sy, m, n)\n        for (x, y), dist in distances.items():\n            if (x, y) not in min_distances:\n                min_distances[(x, y)] = []\n            min_distances[(x, y)].append((dist, i))\n    \n    # Count blocks covered by each store\n    coverage = [0] * len(stores)\n    \n    for (x, y), dists in min_distances.items():\n        dists.sort()\n        if len(dists) > 0:\n            min_dist = dists[0][0]\n            stores_at_min_dist = [store_idx for dist, store_idx in dists if dist == min_dist]\n            \n            # Only count if exactly one store is closest\n            if len(stores_at_min_dist) == 1:\n                coverage[stores_at_min_dist[0]] += 1\n    \n    return coverage\n\nwhile True:\n    m, n = map(int, input().split())\n    if m == 0 and n == 0:\n        break\n    \n    s = int(input())\n    existing_stores = []\n    for _ in range(s):\n        x, y = map(int, input().split())\n        existing_stores.append((x, y))\n    \n    t = int(input())\n    candidates = []\n    for _ in range(t):\n        p, q = map(int, input().split())\n        candidates.append((p, q))\n    \n    max_coverage = 0\n    \n    for candidate in candidates:\n        # Create a list of all stores including the new one\n        all_stores = existing_stores + [candidate]\n        \n        # Count coverage for all stores\n        coverage = count_covered_blocks(all_stores, m, n)\n        \n        # The last store in the list is the new one\n        new_store_coverage = coverage[-1]\n        \n        max_coverage = max(max_coverage, new_store_coverage)\n    \n    print(max_coverage)\n", "perturbed_sampled": ["from collections import  n): neighbors = [] if y % 2 == 1: # odd row # neighbors for odd row candidates = [ (x-1, y-1), (x, y-1), # upper left, upper right (x-1, y), (x+1, y), # left, right (x-1, y+1), (x, y+1) # lower left, lower right ] else:   [ (x,  left, upper right (x-1, y), (x+1, y),  (x+1, y+1) # lower left, lower right ] for  1 <= nx <= m and 1 <= ny <= n:  distances = {} queue = deque([(start_x, start_y, 0)]) distances[(start_x, start_y)] = 0 while queue: x, y, dist = queue.popleft() for nx, ny in get_neighbors(x, y,  not in distances: distances[(nx, ny)] = dist + 1 queue.append((nx, ny, dist + 1)) return  # For each block, find the   distances = bfs_distances(sx, sy, m, n) for (x, y), dist in distances.items(): if (x, y)  = [] min_distances[(x, y)].append((dist, i)) # Count blocks covered  [0] * len(stores) for (x, y), dists in min_distances.items(): dists.sort() if len(dists) >  = [store_idx for dist, store_idx in dists if dist == min_dist] # Only  is closest if len(stores_at_min_dist) == 1: coverage[stores_at_min_dist[0]] += 1  n = map(int, input().split()) if m == 0 and  = int(input())  in range(s): x, y = map(int, input().split()) existing_stores.append((x, y)) t = int(input()) candidates = []  q = map(int, input().split()) candidates.append((p, q)) max_coverage = 0 for candidate in candidates: # Create a list of all stores including the new one all_stores = existing_stores + [candidate] # Count coverage for all stores coverage =  last store in the list is the new one new_store_coverage = coverage[-1] max_coverage = max(max_coverage, new_store_coverage) print(max_coverage)"], "perturbed_original": ["#Deven-Eleven: import re D = (((-1,  (0, 1), (-1, 1), (-1, 0)), ((0, -1),  0)))   [[-1] * m for _ in xrange(n)] while len(q) != 0: y, x, step = q.pop(0)  cover[y][x] = step for dx, dy in D[y % 2]: ny,  x + dx if 0 <= ny < n and 0 <= nx < m: q.append((ny, nx, step + 1)) return cover def solve(): scover = [func(pos[1] - 1, pos[0] - 1)  in scover) for x in xrange(m)] for  ret = 0 for y in xrange(n): for x in xrange(m): if cover[y][x] < min_cover[y][x]: ret += 1 return ret return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos) while True: data = raw_input().sprit() if  m, n = map(int, data.split()) s = input() spos = [map(int, raw_input().split()) for _ in  = [map(int, raw_input().split()) for _ in xrange(t)] print solve()"], "original_ll": -0.9625340700149536, "sampled_ll": -0.5447258949279785, "all_perturbed_sampled_ll": [-1.7672266960144043], "all_perturbed_original_ll": [-2.0829484462738037], "perturbed_sampled_ll": -1.7672266960144043, "perturbed_original_ll": -2.0829484462738037, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "M,N,D;P[101][4][21][21];S[21][21];C[4][21][21];J[4][21][21];h1,h2;i,n,v1,v2,k;xs,ys,xg,yg,T;d,x,y,d1,t1,x1,y1;vx[]={1,0,-1,0},vy[]={0,1,0,-1};void set_road(int A[][21][21],int h1,int v1,int h2,int v2,int d){if(v1==v2){A[h1<h2?1:3][v1][h1-96]=d;A[h1<h2?3:1][v2][h2-96]=d;}else{A[v1<v2?0:2][v1][h1-96]=d;A[v1<v2?2:0][v2][h2-96]=d;}}main(){for(;scanf(\"%d%d%d%d\",&M,&N,&D,&n),M;){memset(P,0,sizeof(P));memset(S,0,sizeof(S));memset(C,0,sizeof(C));memset(J,0,sizeof(J));for(i=0;i<n;i++){scanf(\"\\n%c-%d%d\",&h1,&v1,&k);S[v1][h1-96]=k;}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);set_road(C,h1,v1,h2,v2,1);}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d%d\",&h1,&v1,&h2,&v2,&k);set_road(J,h1,v1,h2,v2,k);}scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);xs=v1;ys=h1-96;xg=v2;yg=h2-96;P[0][0][xs][ys]=1;for(T=0;;T++)for(d=0;d<4;d++){if(P[T][d][xg][yg]){printf(\"%d\\n\",T);goto E;}for(x=1;x<=N;x++)for(y=1;y<=M;y++)if(P[T][d][x][y]&&(!S[x][y]||T/S[x][y]%2!=d%2))for(d1=0;d1<4;d1++){t1=T+D+J[d1][x][y];x1=x+vx[d1];y1=y+vy[d1];if(d1!=(d^2)&&!C[d1][x][y]&&t1<=100&&x1>=1&&x1<=N&&y1>=1&&y1<=M)P[t1][d1][x1][y1]=1;}}E:;}return 0;}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_N 20\n#define INF 1000000\n\ntypedef struct {\n    int r, c, time, dir;\n} State;\n\nint M, N, D;\nint signal[MAX_N][MAX_N];\nint period[MAX_N][MAX_N];\nint construction[MAX_N][MAX_N][MAX_N][MAX_N];\nint traffic[MAX_N][MAX_N][MAX_N][MAX_N];\nint visited[MAX_N][MAX_N][101][4];\n\nState queue[1000000];\nint head, tail;\n\nint dr[] = {0, 0, -1, 1};\nint dc[] = {-1, 1, 0, 0};\n\nvoid parseIntersection(char *s, int *r, int *c) {\n    char h[10];\n    int v;\n    sscanf(s, \"%[^-]-%d\", h, &v);\n    *r = h[0] - 'a';\n    *c = v - 1;\n}\n\nint canPass(int r, int c, int time, int from_dir, int to_dir) {\n    if (signal[r][c] == 0) return 1;\n    \n    int k = period[r][c];\n    int cycle = time % (2 * k);\n    int is_ns_green = (cycle < k);\n    \n    if (to_dir == 2 || to_dir == 3) {\n        return is_ns_green;\n    } else {\n        return !is_ns_green;\n    }\n}\n\nint solve(int sr, int sc, int er, int ec) {\n    memset(visited, 0, sizeof(visited));\n    \n    head = tail = 0;\n    queue[tail].r = sr;\n    queue[tail].c = sc;\n    queue[tail].time = 0;\n    queue[tail].dir = 1;\n    tail++;\n    visited[sr][sc][0][1] = 1;\n    \n    while (head < tail) {\n        State cur = queue[head++];\n        \n        if (cur.r == er && cur.c == ec) {\n            return cur.time;\n        }\n        \n        if (cur.time >= 100) continue;\n        \n        for (int d = 0; d < 4; d++) {\n            if (d == (cur.dir ^ 1)) continue;\n            \n            int nr = cur.r + dr[d];\n            int nc = cur.c + dc[d];\n            \n            if (nr < 0 || nr >= M || nc < 0 || nc >= N) continue;\n            if (construction[cur.r][cur.c][nr][nc]) continue;\n            \n            if (!canPass(cur.r, cur.c, cur.time, cur.dir, d)) continue;\n            \n            int next_time = cur.time + D + traffic[cur.r][cur.c][nr][nc];\n            \n            if (next_time > 100) continue;\n            if (visited[nr][nc][next_time][d]) continue;\n            \n            visited[nr][nc][next_time][d] = 1;\n            queue[tail].r = nr;\n            queue[tail].c = nc;\n            queue[tail].time = next_time;\n            queue[tail].dir = d;\n            tail++;\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &M, &N);\n        if (M == 0 && N == 0) break;\n        \n        scanf(\"%d\", &D);\n        \n        memset(signal, 0, sizeof(signal));\n        memset(period, 0, sizeof(period));\n        memset(construction, 0, sizeof(construction));\n        memset(traffic, 0, sizeof(traffic));\n        \n        int ns;\n        scanf(\"%d\", &ns);\n        for (int i = 0; i < ns; i++) {\n            char s[20];\n            int k, r, c;\n            scanf(\"%s %d\", s, &k);\n            parseIntersection(s, &r, &c);\n            signal[r][c] = 1;\n            period[r][c] = k;\n        }\n        \n        int nc;\n        scanf(\"%d\", &nc);\n        for (int i = 0; i < nc; i++) {\n            char s1[20], s2[20];\n            int r1, c1, r2, c2;\n            scanf(\"%s %s\", s1, s2);\n            parseIntersection(s1, &r1, &c1);\n            parseIntersection(s2, &r2, &c2);\n            construction[r1][c1][r2][c2] = 1;\n            construction[r2][c2][r1][c1] = 1;\n        }\n        \n        int nj;\n        scanf(\"%d\", &nj);\n        for (int i = 0; i < nj; i++) {\n            char s1[20], s2[20];\n            int r1, c1, r2, c2, d;\n            scanf(\"%s %s %d\", s1, s2, &d);\n            parseIntersection(s1, &r1, &c1);\n            parseIntersection(s2, &r2, &c2);\n            traffic[r1][c1][r2][c2] = d;\n            traffic[r2][c2][r1][c1] = d;\n        }\n        \n        char start[20], end[20];\n        int sr, sc, er, ec;\n        scanf(\"%s %s\", start, end);\n        parseIntersection(start, &sr, &sc);\n        parseIntersection(end, &er, &ec);\n        \n        int result = solve(sr, sc, er, ec);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAX_N 20 #define INF 1000000 typedef struct { int r, c, time, dir; } State; int M, N, D; int signal[MAX_N][MAX_N]; int period[MAX_N][MAX_N]; int construction[MAX_N][MAX_N][MAX_N][MAX_N]; int traffic[MAX_N][MAX_N][MAX_N][MAX_N]; int visited[MAX_N][MAX_N][101][4]; State queue[1000000]; int head, tail; int dr[] = {0, 0, -1, 1}; int dc[]  void parseIntersection(char *s, int *r, int *c) { char h[10]; int v; sscanf(s, \"%[^-]-%d\", h, &v); *r = h[0] - 'a'; *c = v - 1; } int canPass(int r, int  int to_dir) { if  int k = period[r][c]; int cycle =  int is_ns_green = (cycle < k); if (to_dir ==  { return is_ns_green; } else { return !is_ns_green; } } int solve(int sr,  ec) { memset(visited, 0, sizeof(visited)); head = tail = 0; queue[tail].r = sr; queue[tail].c = sc; queue[tail].time = 0; queue[tail].dir = 1; tail++; visited[sr][sc][0][1] = 1; while (head <  er && cur.c == ec) { return cur.time; } if (cur.time >= 100) continue; for (int d  continue; int nr = cur.r + dr[d]; int  || nr >= M || nc < 0  d)) continue; int  > 100) continue; if (visited[nr][nc][next_time][d]) continue; visited[nr][nc][next_time][d] = 1; queue[tail].r = nr; queue[tail].c = nc; queue[tail].time = next_time; queue[tail].dir = d; tail++; } } return -1; } int main()  %d\", &M, &N); if (M == 0 && N == 0) break; scanf(\"%d\", &D); memset(signal, 0, sizeof(signal)); memset(period, 0, sizeof(period)); memset(construction, 0, sizeof(construction)); memset(traffic, 0,  for (int i = 0;  char s[20]; int k, r,  parseIntersection(s, &r, &c); signal[r][c] = 1; period[r][c] = k; } int nc; scanf(\"%d\", &nc); for (int  nc; i++) { char s1[20], s2[20]; int r1, c1, r2, c2; scanf(\"%s %s\", s1, s2); parseIntersection(s1, &r1, &c1); parseIntersection(s2, &r2, &c2);  scanf(\"%d\", &nj);  i < nj; i++) { char s1[20], s2[20]; int r1, c1, r2, c2, d; scanf(\"%s %s %d\", s1, s2, &d); parseIntersection(s1, &r1, &c1); parseIntersection(s2, &r2, &c2); traffic[r1][c1][r2][c2] = d; traffic[r2][c2][r1][c1] = d; } char start[20], end[20]; int sr, sc, er, ec; scanf(\"%s %s\", start, end);  &ec); int result = solve(sr, sc,  return 0; }"], "perturbed_original": ["M,N,D;P[101][4][21][21];S[21][21];C[4][21][21];J[4][21][21];h1,h2;i,n,v1,v2,k;xs,ys,xg,yg,T;d,x,y,d1,t1,x1,y1;vx[]={1,0,-1,0},vy[]={0,1,0,-1};void set_road(int A[][21][21],int h1,int v1,int h2,int v2,int d){if(v1==v2){A[h1<h2?1:3][v1][h1-96]=d;A[h1<h2?3:1][v2][h2-96]=d;}else{A[v1<v2?0:2][v1][h1-96]=d;A[v1<v2?2:0][v2][h2-96]=d;}}main(){for(;scanf(\"%d%d%d%d\",&M,&N,&D,&n),M;){memset(P,0,sizeof(P));memset(S,0,sizeof(S));memset(C,0,sizeof(C));memset(J,0,sizeof(J));for(i=0;i<n;i++){scanf(\"\\n%c-%d%d\",&h1,&v1,&k);S[v1][h1-96]=k;}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);set_road(C,h1,v1,h2,v2,1);}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d%d\",&h1,&v1,&h2,&v2,&k);set_road(J,h1,v1,h2,v2,k);}scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);xs=v1;ys=h1-96;xg=v2;yg=h2-96;P[0][0][xs][ys]=1;for(T=0;;T++)for(d=0;d<4;d++){if(P[T][d][xg][yg]){printf(\"%d\\n\",T);goto E;}for(x=1;x<=N;x++)for(y=1;y<=M;y++)if(P[T][d][x][y]&&(!S[x][y]||T/S[x][y]%2!=d%2))for(d1=0;d1<4;d1++){t1=T+D+J[d1][x][y];x1=x+vx[d1];y1=y+vy[d1];if(d1!=(d^2)&&!C[d1][x][y]&&t1<=100&&x1>=1&&x1<=N&&y1>=1&&y1<=M)P[t1][d1][x1][y1]=1;}}E:;}return 0;}"], "original_ll": -1.0215169191360474, "sampled_ll": -0.43885958194732666, "all_perturbed_sampled_ll": [-1.1010427474975586], "all_perturbed_original_ll": [-1.0215169191360474], "perturbed_sampled_ll": -1.1010427474975586, "perturbed_original_ll": -1.0215169191360474, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.awt.Point;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint dx[] = {0,1,0,-1};\n\t\tint dy[] = {-1,0,1,0};\n\t\tboolean pass[] = {true,false,true,false};\n\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tint d = sc.nextInt();\n\n\t\t\tHashMap<Point,Integer> node = new HashMap<Point,Integer>();\n\t\t\tint ns = sc.nextInt();\n\t\t\tfor(int i=0;i<ns;i++){\n\t\t\t\tnode.put(toPoint(sc.next()),sc.nextInt());\n\t\t\t}\n\n\t\t\tHashMap<Point,HashMap<Point,Integer>> edge = new HashMap<Point,HashMap<Point,Integer>>();\n\t\t\tint nc = sc.nextInt();\n\t\t\tfor(int i=0;i<nc;i++){\n\t\t\t\tPoint a = toPoint(sc.next());\n\t\t\t\tPoint b = toPoint(sc.next());\n\t\t\t\tif(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>());\n\t\t\t\tif(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>());\n\t\t\t\tedge.get(a).put(b,-1);\n\t\t\t\tedge.get(b).put(a,-1);\n\t\t\t}\n\n\t\t\tint nj = sc.nextInt();\n\t\t\tfor(int i=0;i<nj;i++){\n\t\t\t\tPoint a = toPoint(sc.next());\n\t\t\t\tPoint b = toPoint(sc.next());\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tif(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>());\n\t\t\t\tif(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>());\n\t\t\t\tedge.get(a).put(b,cost);\n\t\t\t\tedge.get(b).put(a,cost);\n\t\t\t}\n\n\t\t\tPoint start = toPoint(sc.next());\n\t\t\tPoint goal = toPoint(sc.next());\n\n\t\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\t\tHashSet<State> closed = new HashSet<State>();\n\t\t\topen.add(new State(start,1,0));\n\t\t\t//closed.add(new State(start,1,0));\n\t\t\tState ans = null;\n\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState st = open.poll();\n\n\t\t\t\tif(closed.contains(st)) continue;\n\t\t\t\tclosed.add(st);\n\n\t\t\t\tif(st.p.equals(goal)){\n\t\t\t\t\tans = st;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t//U\u0083^\u0081[\u0083\u0093\u0082\u00b5\u0082\u00c4\u0082\u00cd\u0082\u00a2\u0082\u00af\u0082\u00c8\u0082\u00a2\n\t\t\t\t\tif((st.d + 2) % 4 == i) continue;\n\n\t\t\t\t\tPoint np = new Point(st.p.x + dx[i], st.p.y + dy[i]);\n\n\t\t\t\t\tif(np.x>=0 && np.x<w && np.y>=0 && np.y<h){\n\t\t\t\t\t\tint val = 0;\n\t\t\t\t\t\t//st.p\u0082\u00a9\u0082\u00e7np\u0082\u00d6\u0082\u00cc\u0093\u00b9\u008f\u00ee\u0095\u00f1\u0082\u00f0\u008e\u00e6\u0082\u00e8\u008fo\u0082\u00b7\n\t\t\t\t\t\tif(edge.containsKey(st.p) &&\n\t\t\t\t\t\t\t edge.get(st.p).containsKey(np)) val = edge.get(st.p).get(np);\n\t\t\t\t\t\t//\u008dH\u008e\u0096\u0092\u0086\u0082\u00c8\u0082\u00e7\u0092\u00ca\u0082\u00ea\u0082\u00c8\u0082\u00a2\n\t\t\t\t\t\tif(val == -1) continue;\n\n\t\t\t\t\t\tint ncost = st.cost + d + val;\n\n\t\t\t\t\t\t//\u0090M\u008d\u0086\u0082\u00aa\u0082\u00a0\u0082\u00e9\u008f\u00ea\u008d\u0087\u0082\u00cc\u008f\u0088\u0097\u009d\n\t\t\t\t\t\tif(node.containsKey(np)){\n\t\t\t\t\t\t\tint k = node.get(np);\n\t\t\t\t\t\t\tboolean flg = pass[i]; //true:\u0090N\u0093\u00fc\u0089\u00c2\u0094\\\u0082\u00c5\u0082\u00a0\u0082\u00e9\n\t\t\t\t\t\t\tint div = ncost / k;\n\t\t\t\t\t\t\tif(div % 2 == 1) flg = !flg;\n\t\t\t\t\t\t\tif(!flg) continue;\n\t\t\t\t\t\t\t//if(!flg) ncost += k - ncost % k;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\topen.add(new State(np,i,ncost));\n\t\t\t\t\t\tState nst = new State(np,i,ncost);\n\t\t\t\t\t\t//if(closed.contains(nst)) continue;\n\t\t\t\t\t\t//closed.add(nst);\n\t\t\t\t\t\t//open.add(nst);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(ans.cost);\n\t\t}\n\t}\n\n\tprivate static Point toPoint(String s){\n\t\tString[] tmp = s.split(\"-\");\n\t\tint x = Integer.parseInt(tmp[1]) - 1;\n\t\tint y = tmp[0].charAt(0) - 'a';\n\t\treturn new Point(x,y);\n\t}\n}\n\nclass State implements Comparable<State>{\n\tPoint p;\n\tint d,cost;\n\n\tState(Point p,int d,int cost){\n\t\tthis.p = new Point(p.x,p.y);\n\t\tthis.d = d;\n\t\tthis.cost = cost;\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn this.cost - st.cost;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tState st = (State)o;\n\t\treturn p.equals(st.p) && d == st.d;\n\t}\n\n\tpublic int hashCode(){\n\t\treturn p.x + p.y * 100 + d * 10000;\n\t}\n\n\tpublic String toString(){\n\t\treturn String.format(\"[(%d,%d),%d,%d]\",p.x,p.y,d,cost);\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class State implements Comparable<State> {\n        int row, col, time, dir;\n        \n        public State(int row, int col, int time, int dir) {\n            this.row = row;\n            this.col = col;\n            this.time = time;\n            this.dir = dir;\n        }\n        \n        public int compareTo(State other) {\n            return this.time - other.time;\n        }\n    }\n    \n    static final int EAST = 0, WEST = 1, SOUTH = 2, NORTH = 3;\n    static final int[] DR = {0, 0, 1, -1};\n    static final int[] DC = {1, -1, 0, 0};\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] tokens = line.trim().split(\"\\\\s+\");\n            int M = Integer.parseInt(tokens[0]);\n            int N = Integer.parseInt(tokens[1]);\n            \n            if (M == 0 && N == 0) break;\n            \n            int D = Integer.parseInt(br.readLine().trim());\n            \n            int[][] signal = new int[M][N];\n            for (int i = 0; i < M; i++) {\n                Arrays.fill(signal[i], -1);\n            }\n            \n            int ns = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < ns; i++) {\n                tokens = br.readLine().trim().split(\"\\\\s+\");\n                String[] pos = tokens[0].split(\"-\");\n                int row = pos[0].charAt(0) - 'a';\n                int col = Integer.parseInt(pos[1]) - 1;\n                int k = Integer.parseInt(tokens[1]);\n                signal[row][col] = k;\n            }\n            \n            boolean[][][] blocked = new boolean[M][N][4];\n            int nc = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < nc; i++) {\n                tokens = br.readLine().trim().split(\"\\\\s+\");\n                String[] pos1 = tokens[0].split(\"-\");\n                String[] pos2 = tokens[1].split(\"-\");\n                int r1 = pos1[0].charAt(0) - 'a';\n                int c1 = Integer.parseInt(pos1[1]) - 1;\n                int r2 = pos2[0].charAt(0) - 'a';\n                int c2 = Integer.parseInt(pos2[1]) - 1;\n                \n                for (int d = 0; d < 4; d++) {\n                    if (r1 + DR[d] == r2 && c1 + DC[d] == c2) {\n                        blocked[r1][c1][d] = true;\n                        blocked[r2][c2][d ^ 1] = true;\n                    }\n                }\n            }\n            \n            int[][] congestion = new int[M][N];\n            for (int i = 0; i < M; i++) {\n                for (int j = 0; j < N; j++) {\n                    congestion[i][j] = D;\n                }\n            }\n            \n            int nj = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < nj; i++) {\n                tokens = br.readLine().trim().split(\"\\\\s+\");\n                String[] pos1 = tokens[0].split(\"-\");\n                String[] pos2 = tokens[1].split(\"-\");\n                int r1 = pos1[0].charAt(0) - 'a';\n                int c1 = Integer.parseInt(pos1[1]) - 1;\n                int r2 = pos2[0].charAt(0) - 'a';\n                int c2 = Integer.parseInt(pos2[1]) - 1;\n                int d = Integer.parseInt(tokens[2]);\n                \n                congestion[r1][c1] = Math.max(congestion[r1][c1], D + d);\n            }\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            String[] start = tokens[0].split(\"-\");\n            String[] end = tokens[1].split(\"-\");\n            int sr = start[0].charAt(0) - 'a';\n            int sc = Integer.parseInt(start[1]) - 1;\n            int er = end[0].charAt(0) - 'a';\n            int ec = Integer.parseInt(end[1]) - 1;\n            \n            int result = dijkstra(M, N, sr, sc, er, ec, signal, blocked, congestion);\n            System.out.println(result);\n        }\n    }\n    \n    static int dijkstra(int M, int N, int sr, int sc, int er, int ec, \n                        int[][] signal, boolean[][][] blocked, int[][] congestion) {\n        int[][][] dist = new int[M][N][4];\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                Arrays.fill(dist[i][j], Integer.MAX_VALUE);\n            }\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(sr, sc, 0, EAST));\n        dist[sr][sc][EAST] = 0;\n        \n        while (!pq.isEmpty()) {\n            State curr = pq.poll();\n            \n            if (curr.row == er && curr.col == ec) {\n                return curr.time;\n            }\n            \n            if (curr.time > dist[curr.row][curr.col][curr.dir]) continue;\n            \n            for (int d = 0; d < 4; d++) {\n                if (d == (curr.dir ^ 1)) continue;\n                \n                if (blocked[curr.row][curr.col][d]) continue;\n                \n                if (signal[curr.row][curr.col] != -1) {\n                    int k = signal[curr.row][curr.col];\n                    int cycle = curr.time / k;\n                    boolean isNSGreen = (cycle % 2 == 0);\n                    boolean isEWGreen = !isNSGreen;\n                    \n                    if ((d == EAST || d == WEST) && !isEWGreen) continue;\n                    if ((d == NORTH || d == SOUTH) && !isNSGreen) continue;\n                }\n                \n                int nr = curr.row + DR[d];\n                int nc = curr.col + DC[d];\n                \n                if (nr < 0 || nr >= M || nc < 0 || nc >= N) continue;\n                \n                int travelTime = congestion[curr.row][curr.col];\n                int newTime = curr.time + travelTime;\n                \n                if (newTime < dist[nr][nc][d]) {\n                    dist[nr][nc][d] = newTime;\n                    pq.offer(new State(nr, nc, newTime, d));\n                }\n            }\n        }\n        \n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class State implements Comparable<State>  dir; public State(int row, int col, int time, int dir) { this.row = row; this.col = col; this.time = time; this.dir = dir; } public int compareTo(State other)  } } static final  = 1, SOUTH = 2,  int[] DR = {0, 0, 1, -1}; static final int[]  0}; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while  { String[] tokens = line.trim().split(\"\\\\s+\"); int M = Integer.parseInt(tokens[0]); int N = Integer.parseInt(tokens[1]);  N ==  Integer.parseInt(br.readLine().trim()); int[][] signal = new int[M][N]; for (int i =  { Arrays.fill(signal[i], -1); } int ns = Integer.parseInt(br.readLine().trim()); for (int i = 0; i < ns; i++) { tokens = br.readLine().trim().split(\"\\\\s+\"); String[] pos =   = k;  Integer.parseInt(br.readLine().trim()); for (int i = 0; i < nc; i++) { tokens = br.readLine().trim().split(\"\\\\s+\"); String[] pos1 = tokens[0].split(\"-\"); String[] pos2  pos1[0].charAt(0) -  -  - 'a'; int c2 =  d = 0;  if   c2) { blocked[r1][c1][d] = true; blocked[r2][c2][d ^ 1] = true; } } } int[][] congestion = new int[M][N]; for  < M; i++) { for (int j = 0; j < N; j++) { congestion[i][j] = D;  = 0; i < nj; i++)  pos1 = tokens[0].split(\"-\"); String[] pos2 = tokens[1].split(\"-\"); int r1 = pos1[0].charAt(0) - 'a'; int c1 = Integer.parseInt(pos1[1]) - 1; int r2 = pos2[0].charAt(0) - 'a'; int c2 = Integer.parseInt(pos2[1]) - 1; int d  D + d); } tokens = br.readLine().trim().split(\"\\\\s+\"); String[] start = tokens[0].split(\"-\"); String[] end = tokens[1].split(\"-\"); int sr = start[0].charAt(0) - 'a'; int sc = Integer.parseInt(start[1]) - 1; int er = end[0].charAt(0) - 'a'; int ec = Integer.parseInt(end[1]) - 1; int result = dijkstra(M, N, sr, sc, er, ec,  } static  int sr, int sc, int er, int  int[][] congestion) { int[][][] dist = new int[M][N][4];  i < M; i++) { for (int j = 0; j < N; j++) { Arrays.fill(dist[i][j], Integer.MAX_VALUE); } } PriorityQueue<State> pq = new PriorityQueue<>(); pq.offer(new State(sr, sc, 0, EAST)); dist[sr][sc][EAST] = 0; while (!pq.isEmpty()) { State curr = pq.poll(); if (curr.row == er && curr.col == ec) {  > dist[curr.row][curr.col][curr.dir]) continue; for (int d = 0; d < 4; d++)  ^ 1)) continue; if (blocked[curr.row][curr.col][d]) continue; if (signal[curr.row][curr.col] != -1) { int  = curr.time / k; boolean  == 0); boolean isEWGreen = !isNSGreen; if ((d == EAST || d == WEST) && !isEWGreen) continue; if ((d == NORTH || d == SOUTH) && !isNSGreen) continue;  + DR[d]; int nc = curr.col + DC[d]; if (nr < 0 || nr >=  || nc >= N)  int newTime = curr.time + travelTime; if (newTime < dist[nr][nc][d]) { dist[nr][nc][d] = newTime; pq.offer(new State(nr, nc, newTime, d)); } } } return -1; } }"], "perturbed_original": ["import java.util.*; import java.awt.Point; public class Main{  Scanner sc = new Scanner(System.in); int dx[] = {0,1,0,-1}; int dy[] = {-1,0,1,0}; boolean  h = sc.nextInt(); int w = sc.nextInt(); if(w == 0 && h == 0) break; int d = sc.nextInt();  int ns = sc.nextInt(); for(int i=0;i<ns;i++){ node.put(toPoint(sc.next()),sc.nextInt()); } HashMap<Point,HashMap<Point,Integer>> edge = new HashMap<Point,HashMap<Point,Integer>>(); int nc = sc.nextInt(); for(int  Point b = toPoint(sc.next()); if(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>()); if(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>()); edge.get(a).put(b,-1); edge.get(b).put(a,-1); } int nj = sc.nextInt(); for(int i=0;i<nj;i++){ Point a = toPoint(sc.next());  cost = sc.nextInt(); if(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>()); if(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>()); edge.get(a).put(b,cost); edge.get(b).put(a,cost); } Point start =  PriorityQueue<State> open = new PriorityQueue<State>(); HashSet<State> closed = new HashSet<State>(); open.add(new State(start,1,0));  = open.poll(); if(closed.contains(st)) continue; closed.add(st); if(st.p.equals(goal)){ ans = st; break; } for(int i=0;i<4;i++){ //U\u0083^\u0081[\u0083\u0093\u0082\u00b5\u0082\u00c4\u0082\u00cd\u0082\u00a2\u0082\u00af\u0082\u00c8\u0082\u00a2 if((st.d + 2) % 4 == i) continue; Point np = new Point(st.p.x + dx[i], st.p.y + dy[i]); if(np.x>=0 && np.x<w &&  = 0; //st.p\u0082\u00a9\u0082\u00e7np\u0082\u00d6\u0082\u00cc\u0093\u00b9\u008f\u00ee\u0095\u00f1\u0082\u00f0\u008e\u00e6\u0082\u00e8\u008fo\u0082\u00b7 if(edge.containsKey(st.p) && edge.get(st.p).containsKey(np)) val =  continue; int ncost = st.cost + d + val; //\u0090M\u008d\u0086\u0082\u00aa\u0082 \u0082\u00e9\u008f\u00ea\u008d\u0087\u0082\u00cc\u008f\u0088\u0097\u009d if(node.containsKey(np)){  flg = pass[i]; //true:\u0090N\u0093\u00fc\u0089\u00c2\u0094\\\u0082\u00c5\u0082 \u0082\u00e9  k; if(div % 2 ==  continue; //if(!flg) ncost += k - ncost %  nst  } System.out.println(ans.cost); } } private static Point toPoint(String s){ String[] tmp = s.split(\"-\"); int  int y = tmp[0].charAt(0) - 'a'; return new Point(x,y); } } class State implements Comparable<State>{ Point p; int d,cost; State(Point p,int d,int cost){ this.p = new Point(p.x,p.y); this.d = d; this.cost = cost; } public  boolean equals(Object o){ State st = (State)o; return p.equals(st.p)   + p.y * 100 + d * 10000;  String.format(\"[(%d,%d),%d,%d]\",p.x,p.y,d,cost); } }"], "original_ll": -0.9108591675758362, "sampled_ll": -0.35232213139533997, "all_perturbed_sampled_ll": [-1.115524411201477], "all_perturbed_original_ll": [-1.6578131914138794], "perturbed_sampled_ll": -1.115524411201477, "perturbed_original_ll": -1.6578131914138794, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#Byakko Delivery Company\nfrom heapq import heappop, heappush\nfrom string import ascii_lowercase as al\ndic = dict([(c,i) for i, c in enumerate(al)])\nf = lambda (h, v):(dic[h], int(v) - 1)\ng = lambda s:f(s.split(\"-\"))\n\ndef solve():\n    hq = [(0, start[0], start[1])]\n    while len(hq) != 0:\n        cost, cy, cx = heappop(hq)\n        #print \"cost = {}, pos = ({}, {})\".format(cost, cy, cx)\n        if (cy, cx) == goal:\n            return cost\n        for dy, dx in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            ny, nx = cy + dy, cx + dx\n            if 0 <= ny < M and 0 <= nx < N:\n                #print ny, nx, condition[ny][nx][cy][cx]\n                nc = condition[ny][nx][cy][cx] + D + cost\n                if field[ny][nx] == 0:\n                    heappush(hq, (nc, ny, nx))\n                else:\n                    if dy == 0:\n                        if (nc / field[ny][nx]) % 2 == 1:\n                            heappush(hq, (nc, ny, nx))\n                    else:\n                        if (nc / field[ny][nx]) % 2 == 0:\n                            heappush(hq, (nc, ny, nx))\nwhile True:\n    M, N = map(int, raw_input().split())\n    if M | N == 0:\n        break\n    D = input()\n    field = [[0] * N for _ in xrange(M)]\n    condition = [[[[0] * N for _ in xrange(M)] for _ in xrange(N)] for _ in xrange(M)]\n    for _ in xrange(input()):\n        p, k = raw_input().split()\n        h, v = g(p)\n        field[h][v] = int(k)\n\n    for _ in xrange(input()):    \n        (h1, v1), (h2, v2) = map(g, raw_input().split())\n        condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = 1 << 30\n\n    for _ in xrange(input()):\n        p1, p2, d = raw_input().split()\n        h1, v1 = g(p1)\n        h2, v2 = g(p2)\n        condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = int(d)\n\n    start, goal = map(g, raw_input().split())\n    print solve()", "sampled": "import heapq\nfrom collections import defaultdict\n\ndef parse_intersection(s):\n    parts = s.split('-')\n    h = ord(parts[0]) - ord('a')\n    v = int(parts[1]) - 1\n    return (h, v)\n\ndef solve():\n    while True:\n        line = input().split()\n        M, N = int(line[0]), int(line[1])\n        if M == 0 and N == 0:\n            break\n        \n        D = int(input())\n        \n        ns = int(input())\n        signals = {}\n        for _ in range(ns):\n            parts = input().split()\n            pos = parse_intersection(parts[0])\n            k = int(parts[1])\n            signals[pos] = k\n        \n        nc = int(input())\n        blocked = set()\n        for _ in range(nc):\n            parts = input().split()\n            pos1 = parse_intersection(parts[0])\n            pos2 = parse_intersection(parts[1])\n            blocked.add((min(pos1, pos2), max(pos1, pos2)))\n        \n        nj = int(input())\n        jams = {}\n        for _ in range(nj):\n            parts = input().split()\n            pos1 = parse_intersection(parts[0])\n            pos2 = parse_intersection(parts[1])\n            d = int(parts[2])\n            key = (min(pos1, pos2), max(pos1, pos2))\n            jams[key] = d\n        \n        parts = input().split()\n        start = parse_intersection(parts[0])\n        end = parse_intersection(parts[1])\n        \n        # Dijkstra with state (time, pos, direction)\n        # direction: 0=E, 1=W, 2=S, 3=N\n        pq = [(0, start, 0)]\n        visited = set()\n        \n        # Direction vectors: E, W, S, N\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        # EW: 0,1  NS: 2,3\n        \n        while pq:\n            time, pos, prev_dir = heapq.heappop(pq)\n            \n            if pos == end:\n                print(time)\n                break\n            \n            state = (pos, prev_dir)\n            if state in visited:\n                continue\n            visited.add(state)\n            \n            h, v = pos\n            \n            for d in range(4):\n                # No U-turn\n                if prev_dir == 0 and d == 1:\n                    continue\n                if prev_dir == 1 and d == 0:\n                    continue\n                if prev_dir == 2 and d == 3:\n                    continue\n                if prev_dir == 3 and d == 2:\n                    continue\n                \n                dh, dv = dirs[d]\n                nh, nv = h + dh, v + dv\n                \n                if nh < 0 or nh >= M or nv < 0 or nv >= N:\n                    continue\n                \n                new_pos = (nh, nv)\n                edge = (min(pos, new_pos), max(pos, new_pos))\n                \n                if edge in blocked:\n                    continue\n                \n                # Check signal at current position\n                if pos in signals:\n                    k = signals[pos]\n                    cycle_time = time % (2 * k)\n                    # At time 0, NS is green (d=2,3)\n                    # 0 to k-1: NS green (EW red)\n                    # k to 2k-1: EW green (NS red)\n                    \n                    if d in [0, 1]:  # EW direction\n                        if cycle_time < k:  # NS is green, EW is red\n                            continue\n                    else:  # NS direction\n                        if cycle_time >= k:  # EW is green, NS is red\n                            continue\n                \n                travel_time = D\n                if edge in jams:\n                    travel_time += jams[edge]\n                \n                new_time = time + travel_time\n                \n                if new_time <= 100:\n                    heapq.heappush(pq, (new_time, new_pos, d))\n\nsolve()\n", "perturbed_sampled": ["import heapq from collections import defaultdict def parse_intersection(s): parts  int(parts[1]) - 1 return (h, v) def solve(): while True: line = input().split() M, N = int(line[0]), int(line[1]) if M  0: break D = int(input()) ns = int(input()) signals  range(ns): parts = input().split() pos = parse_intersection(parts[0]) k = int(parts[1]) signals[pos] = k  set() for _ in range(nc): parts = input().split() pos1 = parse_intersection(parts[0]) pos2 = parse_intersection(parts[1]) blocked.add((min(pos1, pos2), max(pos1, pos2))) nj = int(input()) jams = {} for _ in range(nj): parts = input().split() pos1 = parse_intersection(parts[0]) pos2 = parse_intersection(parts[1]) d = int(parts[2]) key = (min(pos1, pos2), max(pos1, pos2)) jams[key] = d parts = input().split() start = parse_intersection(parts[0]) end = parse_intersection(parts[1]) # Dijkstra with state (time, pos, direction) #  pq = [(0,  # Direction vectors: E, W, S, N  -1), (1, 0), (-1, 0)] # EW:  time, pos,  == end: print(time) break state = (pos, prev_dir) if state  v = pos for d in range(4):  ==  continue if   == 2 and d == 3: continue if prev_dir == 3 and d == 2: continue dh, dv = dirs[d] nh, nv = h + dh, v + dv if nh < 0 or nh >= M or nv <  continue  = (min(pos, new_pos),  blocked: continue # Check signal at current   time % (2 * k) # At time 0, NS is  k-1: NS green (EW red)  green (NS red) if d in [0, 1]: # EW direction if cycle_time < k: # NS is green, EW is red  if cycle_time >= k: # EW is green, NS is red continue travel_time = D if edge in jams: travel_time += jams[edge] new_time = time + travel_time if new_time <= 100: heapq.heappush(pq, (new_time, new_pos, d)) solve()"], "perturbed_original": ["#Byakko Delivery Company from heapq import  ascii_lowercase as al dic = dict([(c,i) for i, c in  v):(dic[h], int(v)  s:f(s.split(\"-\")) def solve(): hq = [(0, start[0], start[1])] while  cx = heappop(hq) #print \"cost  {})\".format(cost, cy, cx) if (cy, cx) == goal: return cost for dy, dx in ((0, 1), (0, -1),  nx = cy  if 0 <= ny < M and 0 <= nx < N: #print ny,  + D + cost if field[ny][nx]   field[ny][nx]) % 2 == 1: heappush(hq, (nc, ny, nx)) else: if (nc  nx)) while True: M, N = map(int, raw_input().split()) if M | N == 0: break D = input() field = [[0] * N for _ in xrange(M)] condition = [[[[0] * N for _ in xrange(M)] for _ in xrange(N)] for _ in xrange(M)] for _ in xrange(input()): p, k = raw_input().split() h, v = g(p) field[h][v]  xrange(input()): (h1, v1), (h2, v2) = map(g, raw_input().split()) condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = 1  xrange(input()): p1, p2, d = raw_input().split() h1, v1 = g(p1) h2, v2 = g(p2) condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = int(d) start, goal = map(g, raw_input().split()) print solve()"], "original_ll": -0.8300942778587341, "sampled_ll": -0.7739471197128296, "all_perturbed_sampled_ll": [-2.0148439407348633], "all_perturbed_original_ll": [-1.8305363655090332], "perturbed_sampled_ll": -2.0148439407348633, "perturbed_original_ll": -1.8305363655090332, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\t\n\tint i,sum,a,b,c;\n\tint top,topn;\n\t\n\ttop = 0;\n\t\n\twhile(1){\n\t\t\n\t\tscanf(\" %d %d\",&a,&b);\n\t\t\n\t\tif(a == 0 && b == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tc = a + b;\n\t\t\n\t\tif(top > c){\n\t\t\ttop = c;\n\t\t\ttopn = i;\n\t\t}\n\t\t\n\t\ti++;\n\t\t\n\t\tif(i==5){\n\t\t\tswitch(topn){\n\t\t\t\tcase 1:\n\t\t\t\t\tprintf(\"A \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tprintf(\"B \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tprintf(\"C \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tprintf(\"D \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tprintf(\"E \");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tprintf(\" %d\",top);\n\t\t}\n\t}\n\t\n\treturn(0);\n\t\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int s1, s2;\n    char stores[] = {'A', 'B', 'C', 'D', 'E'};\n    int totals[5];\n    \n    while(1) {\n        scanf(\"%d %d\", &s1, &s2);\n        if(s1 == 0 && s2 == 0) break;\n        \n        totals[0] = s1 + s2;\n        \n        for(int i = 1; i < 5; i++) {\n            scanf(\"%d %d\", &s1, &s2);\n            totals[i] = s1 + s2;\n        }\n        \n        int maxIndex = 0;\n        int maxTotal = totals[0];\n        \n        for(int i = 1; i < 5; i++) {\n            if(totals[i] > maxTotal) {\n                maxTotal = totals[i];\n                maxIndex = i;\n            }\n        }\n        \n        printf(\"%c %d\\n\", stores[maxIndex], maxTotal);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  s2; char stores[] = {'A',  totals[5]; while(1) { scanf(\"%d %d\", &s1, &s2); if(s1 == 0 && s2 ==  +  i < 5; i++) { scanf(\"%d %d\", &s1, &s2); totals[i] = s1 + s2; } int maxIndex  totals[0]; for(int i = 1; i < 5; i++) { if(totals[i] > maxTotal) { maxTotal = totals[i]; maxIndex = i; } } printf(\"%c %d\\n\", stores[maxIndex], maxTotal); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int i,sum,a,b,c; int top,topn; top = 0; while(1){ scanf(\" %d %d\",&a,&b); if(a == 0 &&  b; if(top > c){ top = c; topn = i; } i++; if(i==5){  break; case 2: printf(\"B \"); break; case 3: printf(\"C \"); break; case 4: printf(\"D \"); break; case 5:  %d\",top); } } return(0); }"], "original_ll": -0.8859415054321289, "sampled_ll": -0.48454317450523376, "all_perturbed_sampled_ll": [-1.5369583368301392], "all_perturbed_original_ll": [-1.973001480102539], "perturbed_sampled_ll": -1.5369583368301392, "perturbed_original_ll": -1.973001480102539, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tString[] k = new String[]{\"A\",\"B\",\"C\",\"D\",\"E\"};\n\t\twhile(true) {\n\t\t\tint number = 0;\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < 5; i++) {\n\t\t\t\tint tmp = stdIn.nextInt();\n\t\t\t\ttmp += stdIn.nextInt();\n\t\t\t\tif(tmp == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(tmp > max) {\n\t\t\t\t\tmax = tmp;\n\t\t\t\t\tnumber = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(k[number] + \" \" + max);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int s1A = sc.nextInt();\n            int s2A = sc.nextInt();\n            \n            if (s1A == 0 && s2A == 0) {\n                break;\n            }\n            \n            int s1B = sc.nextInt();\n            int s2B = sc.nextInt();\n            int s1C = sc.nextInt();\n            int s2C = sc.nextInt();\n            int s1D = sc.nextInt();\n            int s2D = sc.nextInt();\n            int s1E = sc.nextInt();\n            int s2E = sc.nextInt();\n            \n            int totalA = s1A + s2A;\n            int totalB = s1B + s2B;\n            int totalC = s1C + s2C;\n            int totalD = s1D + s2D;\n            int totalE = s1E + s2E;\n            \n            int max = totalA;\n            String store = \"A\";\n            \n            if (totalB > max) {\n                max = totalB;\n                store = \"B\";\n            }\n            if (totalC > max) {\n                max = totalC;\n                store = \"C\";\n            }\n            if (totalD > max) {\n                max = totalD;\n                store = \"D\";\n            }\n            if (totalE > max) {\n                max = totalE;\n                store = \"E\";\n            }\n            \n            System.out.println(store + \" \" + max);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { public static void main(String[] args) { Scanner sc =  if (s1A == 0 && s2A == 0) { break; } int s1B =  int s1C =  int s1D = sc.nextInt(); int s2D = sc.nextInt(); int s1E = sc.nextInt(); int  = s1A + s2A; int totalB = s1B + s2B; int totalC = s1C + s2C; int totalD  totalE = s1E + s2E; int max = totalA; String store = \"A\"; if (totalB > max) { max  } if (totalC > max) { max = totalC; store = \"C\"; } if (totalD > max) { max = totalD; store = \"D\"; } if (totalE >  store = \"E\"; } System.out.println(store + \" \" + max); } sc.close(); } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Scanner; public  void  = new Scanner(System.in); String[] k = new String[]{\"A\",\"B\",\"C\",\"D\",\"E\"}; while(true)   i = 0; i < 5; i++) { int tmp = stdIn.nextInt(); tmp += stdIn.nextInt(); if(tmp == 0) { return; } if(tmp > max) { max = tmp; number = i; } } System.out.println(k[number] + \" \" + max); } } }"], "original_ll": -0.8315028548240662, "sampled_ll": -0.2955358922481537, "all_perturbed_sampled_ll": [-1.0262775421142578], "all_perturbed_original_ll": [-1.8509581089019775], "perturbed_sampled_ll": -1.0262775421142578, "perturbed_original_ll": -1.8509581089019775, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# Aizu Problem 0195: What is the Most Popular Shop in Tokaichi?\n#\nimport sys, math, os\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\nwhile True:\n    most = 0\n    shop = 'A'\n    a, b = [int(_) for _ in input().split()]\n    if a == b == 0:\n        break\n    most = a + b\n    for s in range(4):\n        a = sum([int(_) for _ in input().split()])\n        if a > most:\n            most = a\n            shop = chr(66 + s)\n    print(shop, most)\n            ", "sampled": "import sys\n\nfor line in sys.stdin:\n    s1_A, s2_A = map(int, line.split())\n    if s1_A == 0 and s2_A == 0:\n        break\n    \n    stores = []\n    stores.append(('A', s1_A + s2_A))\n    \n    for store_name in ['B', 'C', 'D', 'E']:\n        s1, s2 = map(int, input().split())\n        stores.append((store_name, s1 + s2))\n    \n    max_store = max(stores, key=lambda x: x[1])\n    print(max_store[0], max_store[1])\n", "perturbed_sampled": ["import sys for line in sys.stdin: s1_A, s2_A =  0 and s2_A == 0: break stores = [] stores.append(('A',  in ['B', 'C',  map(int, input().split()) stores.append((store_name, s1 + s2)) max_store = max(stores, key=lambda x: x[1]) print(max_store[0], max_store[1])"], "perturbed_original": ["# Aizu Problem 0195: What is the Most Popular Shop in Tokaichi? # import sys, math, os # read input: PYDEV = os.environ.get('PYDEV') if PYDEV==\"True\": sys.stdin = open(\"sample-input.txt\", \"rt\") while True: most  a, b =  if a == b == 0: break most = a +  a = sum([int(_) for _  most: most = a shop = chr(66 + s) print(shop, most)"], "original_ll": -1.7723212242126465, "sampled_ll": -0.963982105255127, "all_perturbed_sampled_ll": [-2.4632980823516846], "all_perturbed_original_ll": [-3.2489378452301025], "perturbed_sampled_ll": -2.4632980823516846, "perturbed_original_ll": -3.2489378452301025, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0196: Baseball Championship\n// 2017.8.3\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar *gets(char *);\nchar buf[500], *p;\n\nint getInt(void)\n{\n\tint n = 0;\n\twhile (isspace(*p)) p++;\n\treturn *p++ - '0';\n}\n\nchar getStr(void)\n{\n\twhile (isspace(*p)) p++;\n\treturn *p++;\n}\n\ntypedef struct { char a; int k, w, l; } T;\nT t[15];\n\nint main()\n{\n\tint i, j, k, n;\n\tT tmp, *tp, *tt;\n\n\twhile (1) {\n\t\tgets(buf);\n\t\tif (!(n = atoi(buf))) break;\n\t\tfor (i = 0, tp = t; i < n; i++, tp++) {\n\t\t\tgets(p = buf);\n\t\t\ttp->a = getStr(), tp->k = i, tp->w = tp->l = 0;\n\t\t\tfor (j = 1; j < n; j++) {\n\t\t\t\tk = getInt();\n\t\t\t\tif (k == 0) tp->w++;\n\t\t\t\telse if (k == 1) tp->l++;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < n; i++) {\n\t\t\ttp = t + i;\n\t\t\tfor (j = i+1, tt = tp+1; j < n; j++, tt++) {\n\t\t\t\tif (tt->w > tp->w) tp = tt;\n\t\t\t\telse if (tt->w == tp->w) {\n\t\t\t\t\tif (tt->l < tp->l) tp = tt;\n\t\t\t\t\telse if (tt->l == tp->l && tt->k < tp->k) tp = tt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tp != t + i) {\n\t\t\t\tmemcpy(&tmp, t+i, sizeof(tmp));\n\t\t\t\tmemcpy(t+i, tp, sizeof(tmp));\n\t\t\t\tmemcpy(tp, &tmp, sizeof(tmp));\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < n; i++) putchar(t[i].a), putchar('\\n');\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name;\n    int wins;\n    int losses;\n    int order;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    \n    if (ta->wins != tb->wins) {\n        return tb->wins - ta->wins;\n    }\n    if (ta->losses != tb->losses) {\n        return ta->losses - tb->losses;\n    }\n    return ta->order - tb->order;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Team teams[10];\n        \n        for (int i = 0; i < n; i++) {\n            char name;\n            scanf(\" %c\", &name);\n            \n            teams[i].name = name;\n            teams[i].wins = 0;\n            teams[i].losses = 0;\n            teams[i].order = i;\n            \n            for (int j = 0; j < n - 1; j++) {\n                int result;\n                scanf(\"%d\", &result);\n                \n                if (result == 0) {\n                    teams[i].wins++;\n                } else if (result == 1) {\n                    teams[i].losses++;\n                }\n            }\n        }\n        \n        qsort(teams, n, sizeof(Team), compare);\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%c\\n\", teams[i].name);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  char name; int wins; int  const void *b) { Team *ta = (Team *)a; Team *tb = (Team *)b; if (ta->wins != tb->wins) { return tb->wins - ta->wins; } if (ta->losses != tb->losses) { return ta->losses - tb->losses; } return ta->order - tb->order; } int main() {  == 1 && n != 0) { Team teams[10]; for (int i = 0; i < n; i++) { char name; scanf(\" %c\", &name); teams[i].name = name; teams[i].wins = 0; teams[i].losses = 0; teams[i].order  = 0; j < n - 1; j++) { int result; scanf(\"%d\", &result); if  }  { teams[i].losses++; } } } qsort(teams, n, sizeof(Team), compare); for (int  teams[i].name); } } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0196:  <stdio.h> #include <stdlib.h> #include <string.h> #include <ctype.h> char *gets(char *); char buf[500],  n = 0; while (isspace(*p)) p++; return *p++ - '0'; } char getStr(void) { while (isspace(*p)) p++; return *p++; } typedef struct { char a; int k, w, l; } T; T t[15]; int main() {  T tmp, *tp, *tt; while (1)  = 0, tp = t; i < n; i++, tp++) { gets(p = buf); tp->a = getStr(), tp->k = i, tp->w = tp->l = 0; for (j = 1; j <  getInt(); if (k == 0) tp->w++; else if (k == 1) tp->l++; } } for (i = 0; i < n; i++)  i; for (j = i+1, tt = tp+1;  tp->w) tp  (tt->l < tp->l) tp = tt; else if (tt->l  tp->k) tp = tt; } } if (tp != t + i) { memcpy(&tmp, t+i, sizeof(tmp)); memcpy(t+i, tp, sizeof(tmp));  for (i = 0; i < n; i++) putchar(t[i].a), putchar('\\n'); } return 0; }"], "original_ll": -0.8585205674171448, "sampled_ll": -0.3739679753780365, "all_perturbed_sampled_ll": [-1.3872175216674805], "all_perturbed_original_ll": [-1.7580162286758423], "perturbed_sampled_ll": -1.3872175216674805, "perturbed_original_ll": -1.7580162286758423, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.*;\nimport java.util.*;\n\n\n// 2011/10/23\n\n// 0196 \u0096\u00ec\u008b\u0085\u0091\u00e5\u0089\u00ef\npublic class Main {\n\t\n\t\n\tclass Team implements Comparable<Team> {\n\t\tString name;\n\t\tint win;\n\t\tint lose;\n\t\tpublic Team(String name, int win, int lose) {\n\t\t\tthis.name = name;\n\t\t\tthis.win = win;\n\t\t\tthis.lose = lose;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Team o) {\n\t\t\tif (win != o.win) {\n\t\t\t\treturn -(win - o.win);\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn (lose - o.lose);\n\t\t}\n\t\t\n\t}\n\t\n\n\t// \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2\n\tboolean main() throws IOException {\n\n\t\tint n = readIntArray()[0];\n\t\tif (n == 0)\n\t\t\treturn false;\n\t\t\n\t\tList<Team> list = new ArrayList<Team>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tString s = reader.readLine();\n\t\t\tString[] sp = s.split(\" \");\n\t\t\t\n\t\t\tint win = 0;\n\t\t\tint lose = 0;\n\t\t\tfor(int j = 0; j < n - 1; j++) {\n\t\t\t\tString r = sp[j + 1];\n\t\t\t\tif (r.equals(\"0\")) {\n\t\t\t\t\twin++;\n\t\t\t\t}\n\t\t\t\telse if (r.equals(\"1\")) {\n\t\t\t\t\tlose++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist.add(new Team(sp[0], win, lose));\n\t\t}\t\n\t\t\n\t\tCollections.sort(list);\n\t\t\n\t\tfor(Team t: list) {\n\t\t\tSystem.out.printf(\"%s\\n\", t.name);\n\t\t}\n\t\t\n//\t\tSystem.out.printf(\"%d\\n\", sum / size);\n\t\t\n\t\treturn true; // \u0090\u00b3\u008f\u00ed\u008fI\u0097\u00b9 \u008e\u009f\u0082\u00d6\n\t}\n\t\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\t\t\t\n\t\t\tString inputStr = \"1:15:\";\n\n\t\t\tinputStr = inputStr.replace(\":\", \"\\n\");\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr)); \n\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // \u008f\u0091\u0082\u00ab\u008e\u00cc\u0082\u00c4\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // \u0083R\u0083\u0093\u0083\\\u0081[\u0083\u008b\u0082\u00a9\u0082\u00e7\n\t\t}\n\t\t\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t}\n\n\t\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\t\n\n\t// \u0095W\u008f\u0080\u0093\u00fc\u0097\u00cd\u0082\u00e6\u0082\u00e81\u008ds\u0095\u00aa\u0082\u00cc\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0095\u00b6\u008e\u009a\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0082\u00c5\u0082\u00cc\u0090\u00ae\u0090\u0094\u0092l\u0082\u00f0\u0093\u00c7\u0082\u00de\n\t// EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7\n\tprivate static int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = reader.readLine();\n//\t\t\tlog.printf(\"%s\\n\", s);\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // \u0081\u00a6\u0081\u00a6\u0081\u00a6\u0081@\u0082\u00c7\u0082\u00a4\u0082\u00e0\u0093\u00cb\u0091R\u008b\u00f3\u008ds\u0082\u00f0\u0093\u00c7\u0082\u00de\u0082\u00b1\u0082\u00c6\u0082\u00aa\u0082\u00a0\u0082\u00e9\u0081B\u0093\u00c7\u0082\u00dd\u0094\u00f2\u0082\u00ce\u0082\u00b7\u0082\u00c6\u0082\u00a4\u0082\u00dc\u0082\u00ad\u0082\u00a2\u0082\u00ad\u0082\u00e7\u0082\u00b5\u0082\u00a2\u0081B\u0081B\u0081B\u0081B\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tString[] sp = s.split(\"[ ,]\"); // \u008b\u00e6\u0090\u00d8\u0082\u00e8\u0095\u00b6\u008e\u009a\u0082\u00cd\u0083X\u0083y\u0081[\u0083X\u0082\u00a9\u0083J\u0083\u0093\u0083}\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\t\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Team {\n        String name;\n        int wins;\n        int losses;\n        int order;\n        \n        Team(String name, int wins, int losses, int order) {\n            this.name = name;\n            this.wins = wins;\n            this.losses = losses;\n            this.order = order;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            List<Team> teams = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                String teamName = sc.next();\n                int wins = 0;\n                int losses = 0;\n                \n                for (int j = 0; j < n - 1; j++) {\n                    int result = sc.nextInt();\n                    if (result == 0) {\n                        wins++;\n                    } else if (result == 1) {\n                        losses++;\n                    }\n                }\n                \n                teams.add(new Team(teamName, wins, losses, i));\n            }\n            \n            Collections.sort(teams, new Comparator<Team>() {\n                @Override\n                public int compare(Team t1, Team t2) {\n                    if (t1.wins != t2.wins) {\n                        return t2.wins - t1.wins;\n                    }\n                    if (t1.losses != t2.losses) {\n                        return t1.losses - t2.losses;\n                    }\n                    return t1.order - t2.order;\n                }\n            });\n            \n            for (Team team : teams) {\n                System.out.println(team.name);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  { String name; int wins; int losses; int order; Team(String  int order) { this.name = name; this.wins = wins; this.losses = losses; this.order  static  sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n  = new ArrayList<>();  i < n; i++) { String teamName = sc.next(); int wins =  for (int j =  1; j++) { int result =  { wins++; } else if (result == 1) { losses++; } } teams.add(new Team(teamName, wins, losses, i)); } Collections.sort(teams, new Comparator<Team>() { @Override public int compare(Team t1, Team t2) { if (t1.wins !=  t1.wins; } if (t1.losses != t2.losses) { return t1.losses - t2.losses; } return t1.order - t2.order; } }); for (Team team : teams) { System.out.println(team.name); } } sc.close(); } }"], "perturbed_original": ["  public class Main { class Team implements Comparable<Team> { String name; int win; int lose; public  lose) { this.name = name; this.win = win; this.lose = lose; } @Override public int compareTo(Team o) { if (win != o.win) { return  return (lose - o.lose); } } // \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2 boolean main() throws IOException { int n = readIntArray()[0]; if (n == 0) return false; List<Team> list = new ArrayList<Team>(); for(int i = 0; i < n; i++) { String s = reader.readLine(); String[] sp = s.split(\" \"); int win = 0;  j = 0; j < n - 1; j++) { String r = sp[j + 1]; if (r.equals(\"0\")) { win++; } else if   Collections.sort(list); for(Team  } // System.out.printf(\"%d\\n\", sum / size); return  boolean DEBUG = true; // debug private final  // release public static void main(String[] args)   inputStr = \"1:15:\"; inputStr = inputStr.replace(\":\", \"\\n\"); reader = new  log = new PrintStream(new OutputStream() { public void write(int b) {} } );  BufferedReader(new InputStreamReader(System.in)); // \u0083R\u0083\u0093\u0083\\\u0081[\u0083\u008b\u0082\u00a9\u0082\u00e7 } int N =  for(int i = 0; i < N; i++) { boolean b = new Main().main(); if  static PrintStream log;  // EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7 private static int[] readIntArray() throws IOException { String s = null; for(;;) { s = reader.readLine(); // log.printf(\"%s\\n\", s); if (s == null) return null; s = s.trim(); if (s.length() != 0) // \u0081\u00a6\u0081\u00a6\u0081\u00a6\u0081@\u0082\u00c7\u0082\u00a4\u0082\u00e0\u0093\u00cb\u0091R\u008b\u00f3\u008ds\u0082\u00f0\u0093\u00c7\u0082\u00de\u0082\u00b1\u0082\u00c6\u0082\u00aa\u0082 \u0082\u00e9\u0081B\u0093\u00c7\u0082\u00dd\u0094\u00f2\u0082\u00ce\u0082\u00b7\u0082\u00c6\u0082\u00a4\u0082\u00dc\u0082\u00ad\u0082\u00a2\u0082\u00ad\u0082\u00e7\u0082\u00b5\u0082\u00a2\u0081B\u0081B\u0081B\u0081B break; } String[] sp = s.split(\"[ ,]\"); //  int[sp.length]; for(int i = 0; i < sp.length;  } return a; } }"], "original_ll": -1.4343832731246948, "sampled_ll": -0.28914400935173035, "all_perturbed_sampled_ll": [-1.3038978576660156], "all_perturbed_original_ll": [-2.0459203720092773], "perturbed_sampled_ll": -1.3038978576660156, "perturbed_original_ll": -2.0459203720092773, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(raw_input())\n    if n == 0: break\n    ans = [[0]*4 for i in range(n)]\n    for i in range(n):\n        line = raw_input().split()\n        ans[i][2] = -i\n        ans[i][3] = line[0]\n        for c in line[1:]:\n            if c == '0':\n                ans[i][0] += 1\n            elif c == '1':\n                ans[i][1] -= 1\n    for a in sorted(ans, key=lambda x: (x[0], x[1], x[2]), reverse=True):\n        print a[3]", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    teams = []\n    for i in range(n):\n        line = input().split()\n        name = line[0]\n        results = list(map(int, line[1:]))\n        \n        wins = results.count(0)\n        losses = results.count(1)\n        \n        teams.append((name, wins, losses, i))\n    \n    # Sort by wins (descending), then losses (ascending), then input order (ascending)\n    teams.sort(key=lambda x: (-x[1], x[2], x[3]))\n    \n    for team in teams:\n        print(team[0])\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break teams = []  = input().split()  list(map(int, line[1:])) wins = results.count(0)  losses, i)) # Sort by wins (descending), then losses (ascending), then input order (ascending) teams.sort(key=lambda x: (-x[1], x[2], x[3])) for team in teams: print(team[0])"], "perturbed_original": ["while True: n = int(raw_input()) if n == 0: break ans = [[0]*4 for i in range(n)] for i in range(n): line  ans[i][3] = line[0] for c in line[1:]:  += 1 elif c == '1': ans[i][1] -= 1 for  (x[0], x[1], x[2]), reverse=True): print a[3]"], "original_ll": -0.8603041172027588, "sampled_ll": -0.7123130559921265, "all_perturbed_sampled_ll": [-2.078361749649048], "all_perturbed_original_ll": [-2.3566718101501465], "perturbed_sampled_ll": -2.078361749649048, "perturbed_original_ll": -2.3566718101501465, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void)\n{    \n    int a, b, r;\n    int count = 1;\n        \n    while(scanf(\"%d %d\", &a, &b) != EOF)\n    {     \n        if(a == 0 && b == 0)\n        {        \n            break;\n        }\n        \n        r = a % b;        \n        while(r!=0){            \n            a = b;            \n            b = r;            \n            r = a % b;            \n            count++;  \n            \n            \n        }\n        printf(\"%d %d\\n\",b,count);\n    }        \n      \n    return(0);\n    \n}\n", "sampled": "#include <stdio.h>\n\nint main() {\n    long long a, b;\n    \n    while (1) {\n        scanf(\"%lld %lld\", &a, &b);\n        \n        if (a == 0 && b == 0) {\n            break;\n        }\n        \n        long long x = a;\n        long long y = b;\n        int steps = 0;\n        long long temp;\n        \n        while (y != 0) {\n            temp = x % y;\n            x = y;\n            y = temp;\n            steps++;\n        }\n        \n        printf(\"%lld %d\\n\", x, steps);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { long long a, b; while (1)  if (a == 0 && b == 0) { break; } long long x = a; long long y = b; int steps =  (y != 0) {  x  steps++; } printf(\"%lld %d\\n\", x, steps); } return 0; }"], "perturbed_original": ["#include <stdio.h> <extra_id_16>; r<extra_id_17>r = b; r =<extra_id_18>a =<extra_id_19>( r!=0){<extra_id_20>(r!=0) { return(0);<extra_id_21>int<extra_id_22>) ,<extra_id_23>\" \u00df<extra_id_24>\u00e7\u00c9 b, r; int count = 1; while(scanf(\"%d %d\",  if(a == 0 && b  r = a % b; while(r!=0){ a = b; b = r; r = a % b; count++; } printf(\"%d %d\\n\",b,count); } return(0); }"], "original_ll": -1.1831579208374023, "sampled_ll": -0.5289129614830017, "all_perturbed_sampled_ll": [-1.9942665100097656], "all_perturbed_original_ll": [-2.4020626544952393], "perturbed_sampled_ll": -1.9942665100097656, "perturbed_original_ll": -2.4020626544952393, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n \n         \n        public static void main(String[] args) throws java.io.IOException{\n            Scanner scan = new Scanner(System.in);\n            while(true){\n                int a =scan.nextInt();\n                int b = scan.nextInt();\n                if((a|b)==0)break;\n                if(b>a){\n                    a=a^b;\n                    b=a^b;\n                    a=a^b;\n                }\n                int c=0;\n                while(b!=0){\n                    a=a%b;\n                    a=a^b;\n                    b=a^b;\n                    a=a^b;\n                    c++;\n                }\n                System.out.println(a+\" \"+c);\n            }\n  \n        }\n   \n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long a = sc.nextLong();\n            long b = sc.nextLong();\n            \n            if (a == 0 && b == 0) {\n                break;\n            }\n            \n            long x = a;\n            long y = b;\n            int steps = 0;\n            \n            while (y != 0) {\n                long temp = x % y;\n                x = y;\n                y = temp;\n                steps++;\n            }\n            \n            System.out.println(x + \" \" + steps);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in);  = sc.nextLong(); long b = sc.nextLong();  b == 0) {  a; long y = b; int steps = 0; while (y != 0) { long temp = x %  = temp; steps++; } System.out.println(x + \" \" + steps); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[] args) throws java.io.IOException{ Scanner scan  a =scan.nextInt(); int b = scan.nextInt(); if((a|b)==0)break;  int c=0; while(b!=0){ a=a%b; a=a^b; b=a^b; a=a^b; c++; } System.out.println(a+\" \"+c); } } }"], "original_ll": -1.0790175199508667, "sampled_ll": -0.44357624650001526, "all_perturbed_sampled_ll": [-1.7158873081207275], "all_perturbed_original_ll": [-1.79573655128479], "perturbed_sampled_ll": -1.7158873081207275, "perturbed_original_ll": -1.79573655128479, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\ndef f(d,x,y):\n    t = x % y\n    x = y\n    y = t\n    if y != 0:\n        return f(d+1,x,y)\n    else:\n        return (x,d+1)\n\nwhile 1:\n    y,x = sorted(list(map(int, input().split())))\n    if x == 0: break\n    ans = f(0,x,y)\n    print(ans[0],ans[1])\n\n\n", "sampled": "while True:\n    a, b = map(int, input().split())\n    if a == 0 and b == 0:\n        break\n    \n    x, y = a, b\n    steps = 0\n    \n    while y != 0:\n        remainder = x % y\n        x = remainder\n        x, y = y, x\n        steps += 1\n    \n    print(x, steps)\n", "perturbed_sampled": ["while True:  if a == 0 and b == 0: break x, y = a, b steps = 0 while y != 0: remainder  = remainder x, y = y, x steps += 1 print(x, steps)"], "perturbed_original": ["import sys def f(d,x,y): t = x % y x = y y  0: return f(d+1,x,y) else: return (x,d+1) while 1: y,x = sorted(list(map(int, input().split())))  ans = f(0,x,y) print(ans[0],ans[1])"], "original_ll": -1.3495498895645142, "sampled_ll": -0.9652212858200073, "all_perturbed_sampled_ll": [-2.2358407974243164], "all_perturbed_original_ll": [-2.2980358600616455], "perturbed_sampled_ll": -2.2358407974243164, "perturbed_original_ll": -2.2980358600616455, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\tint n,i,j,z;\n\tchar c1[1001],c2[1001],c3[1001],c4[1001],c5[1001],c6[1001];\n\twhile(n!=0){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%s %s %s %s %s %s\",&c1[i],&c2[i],&c3[i],&c4[i],&c5[i],&c6[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tz=0;\n\t\tfor(j=0;j<n;j++){\n\t\tif(c1[i]==c1[j] && c2[i]==c2[j] && c3[i]==c3[j] && c4[i]==c4[j] && c5[i]==c5[j] && c6[i]==c6[j]){\n\t\t\tz=z+1;\n\t\t}\n\t\telse if(c4[i]==c4[j] && c1[i]==c1[j] && c3[i]==c3[j] && c6[i]==c6[j]){\n\t\t\tif(c5[i]==c5[j] && c2[i]==c2[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c4[i]==c6[j] && c1[i]==c3[j] && c3[i]==c1[j] && c6[i]==c4[j]){\n\t\t\tif(c5[i]==c2[j] && c2[i]==c5[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c6[j] && c3[i]==c3[j] && c1[i]==c1[j] && c4[i]==c4[j]){\n\t\t\tif(c5[i]==c5[j] && c2[i]==c2[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c4[j] && c3[i]==c1[j] && c1[i]==c3[j] && c4[i]==c6[j]){\n\t\t\tif(c2[i]==c5[j] && c5[i]==c2[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c2[i]==c2[j] && c1[i]==c1[j] && c5[i]==c5[j] && c6[i]==c6[j]){\n\t\t\tif(c4[i]==c4[j] && c3[i]==c3[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c2[i]==c6[j] && c1[i]==c5[j] && c5[i]==c1[j] && c6[i]==c2[j]){\n\t\t\tif(c4[i]==c3[j] && c3[i]==c4[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c6[j] && c5[i]==c5[j] && c1[i]==c1[j] && c2[i]==c2[j]){\n\t\t\tif(c3[i]==c3[j] && c4[i]==c4[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c2[j] && c5[i]==c1[j] && c1[i]==c5[j] && c2[i]==c6[j]){\n\t\t\tif(c3[i]==c4[j] && c4[i]==c3[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",n);\n\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char faces[6][10];\n} Cube;\n\nvoid rotateCube(Cube *c, Cube *result, int rotation) {\n    // 24 rotations of a cube\n    int rotations[24][6] = {\n        {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5},\n        {1,0,3,2,5,4}, {1,2,0,5,3,4}, {1,3,5,0,2,4}, {1,5,2,3,0,4},\n        {2,0,1,4,5,3}, {2,1,5,0,4,3}, {2,4,0,5,1,3}, {2,5,4,1,0,3},\n        {3,0,4,1,5,2}, {3,1,0,5,4,2}, {3,4,5,0,1,2}, {3,5,1,4,0,2},\n        {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1},\n        {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0}\n    };\n    \n    for (int i = 0; i < 6; i++) {\n        strcpy(result->faces[i], c->faces[rotations[rotation][i]]);\n    }\n}\n\nint compareCubes(Cube *c1, Cube *c2) {\n    for (int i = 0; i < 6; i++) {\n        int cmp = strcmp(c1->faces[i], c2->faces[i]);\n        if (cmp != 0) return cmp;\n    }\n    return 0;\n}\n\nint areSameCube(Cube *c1, Cube *c2) {\n    Cube rotated;\n    for (int r = 0; r < 24; r++) {\n        rotateCube(c1, &rotated, r);\n        if (compareCubes(&rotated, c2) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Cube cubes[30];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 6; j++) {\n                scanf(\"%s\", cubes[i].faces[j]);\n            }\n        }\n        \n        int unique[30];\n        int uniqueCount = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int isUnique = 1;\n            for (int j = 0; j < uniqueCount; j++) {\n                if (areSameCube(&cubes[i], &cubes[unique[j]])) {\n                    isUnique = 0;\n                    break;\n                }\n            }\n            if (isUnique) {\n                unique[uniqueCount++] = i;\n            }\n        }\n        \n        printf(\"%d\\n\", n - uniqueCount);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef struct { char faces[6][10];  Cube *result, int rotation) { // 24 rotations of a  {0,1,2,3,4,5},  {1,3,5,0,2,4}, {1,5,2,3,0,4}, {2,0,1,4,5,3}, {2,1,5,0,4,3}, {2,4,0,5,1,3}, {2,5,4,1,0,3}, {3,0,4,1,5,2}, {3,1,0,5,4,2}, {3,4,5,0,1,2}, {3,5,1,4,0,2}, {4,0,2,3,5,1},  {5,3,4,1,2,0}, {5,4,2,3,1,0} }; for (int i = 0; i < 6; i++) { strcpy(result->faces[i], c->faces[rotations[rotation][i]]); } }  { for (int i = 0; i < 6;  strcmp(c1->faces[i], c2->faces[i]); if (cmp != 0) return cmp; } return 0; } int areSameCube(Cube *c1, Cube *c2) { Cube rotated; for (int r = 0; r < 24;  if (compareCubes(&rotated, c2) == 0) {  0; } int main() { int n; while (scanf(\"%d\", &n) == 1 && n != 0) { Cube cubes[30]; for (int i = 0; i < n; i++) { for (int j = 0; j < 6; j++) { scanf(\"%s\",  for (int i = 0; i < n; i++) { int isUnique = 1; for (int j = 0; j < uniqueCount; j++)  isUnique = 0; break; } } if (isUnique) {  } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int n,i,j,z; char c1[1001],c2[1001],c3[1001],c4[1001],c5[1001],c6[1001]; while(n!=0){ scanf(\"%d\",&n); for(i=0;i<n;i++){ scanf(\"%s %s %s %s %s %s\",&c1[i],&c2[i],&c3[i],&c4[i],&c5[i],&c6[i]); }  c2[i]==c2[j] && c3[i]==c3[j] &&  && c1[i]==c1[j] && c3[i]==c3[j] && c6[i]==c6[j]){  } else if(c4[i]==c6[j] && c1[i]==c3[j] && c3[i]==c1[j] && c6[i]==c4[j]){ if(c5[i]==c2[j] && c2[i]==c5[j]){ z=z+1; }  && c1[i]==c1[j] && c4[i]==c4[j]){ if(c5[i]==c5[j] && c2[i]==c2[j]){ z=z+1; } } else if(c6[i]==c4[j] && c3[i]==c1[j] && c1[i]==c3[j] && c4[i]==c6[j]){ if(c2[i]==c5[j] && c5[i]==c2[j]){  && c1[i]==c1[j] && c5[i]==c5[j] && c6[i]==c6[j]){ if(c4[i]==c4[j] && c3[i]==c3[j]){ z=z+1; } } else if(c2[i]==c6[j] && c1[i]==c5[j] && c5[i]==c1[j] && c6[i]==c2[j]){ if(c4[i]==c3[j] && c3[i]==c4[j]){ z=z+1; } } else if(c6[i]==c6[j] && c5[i]==c5[j] && c1[i]==c1[j] && c2[i]==c2[j]){ if(c3[i]==c3[j]  else if(c6[i]==c2[j]   } } } } printf(\"%d\\n\",n); scanf(\"%d\",&n); } return 0; }"], "original_ll": -0.34443604946136475, "sampled_ll": -0.3874909281730652, "all_perturbed_sampled_ll": [-1.0843031406402588], "all_perturbed_original_ll": [-0.7109445929527283], "perturbed_sampled_ll": -1.0843031406402588, "perturbed_original_ll": -0.7109445929527283, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n\n    ArrayList<char[]> color,list;\n    ArrayList<String> clist;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        clist = new ArrayList<String>();\n        clist.add(\"Red\");\n        clist.add(\"Yellow\");\n        clist.add(\"Blue\");\n        clist.add(\"Magenta\");\n        clist.add(\"Green\");\n        clist.add(\"Cyan\");\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            color = new ArrayList<char[]>();\n            int cnt = 0;\n            for(int i=0; i<n; i++){\n                char[] c = new char[6];\n                for(int j=0; j<6; j++) c[j] = (char)clist.indexOf(sc.next());\n                if(same(c)) cnt++;\n                else color.add(c);\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    int[][] rotate = {{1,2,4,3},{0,4,5,1},{0,2,5,3}};\n\n    boolean same(char[] dice){\n        list = new ArrayList<char[]>();\n        for(int i=0; i<4; i++){\n            dice = rotate(dice,0);\n            for(int j=0; j<4; j++){\n                dice = rotate(dice,1);\n                for(int l=0; l<4; l++){\n                    dice = rotate(dice,2);\n                    list.add(dice);\n                }\n            }\n        }\n\n        for(int i=0; i<list.size(); i++){\n            char[] s1 = list.get(i);\n            for(int j=0; j<color.size(); j++){\n                boolean boo = false;\n                char[] s2 = color.get(j);\n                for(int k=0; k<6; k++){\n                    if(s1[k]!=s2[k]){\n                        boo = false;\n                        break;\n                    }\n                    boo = true;\n                }\n                if(boo) return true;\n            }\n        }\n        return false;\n    }\n\n    char[] rotate(char[] dice, int idx){\n        char[] res = new char[6];\n        for(int i=0; i<6; i++) res[i] = dice[i];\n\n        char tmp = res[rotate[idx][3]];\n        for(int i=3; i>0; i--) res[rotate[idx][i]] = res[rotate[idx][i-1]];\n        res[rotate[idx][0]] = tmp;\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Cube {\n        String[] faces = new String[6];\n        \n        Cube(String[] f) {\n            faces = f.clone();\n        }\n        \n        // Generate all 24 rotations of the cube\n        List<String> getAllRotations() {\n            Set<String> rotations = new HashSet<>();\n            \n            // All 24 orientations of a cube\n            int[][] orientations = {\n                {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5},\n                {1,0,3,2,5,4}, {1,2,0,5,3,4}, {1,3,5,0,2,4}, {1,5,2,3,0,4},\n                {2,0,1,4,5,3}, {2,1,5,0,4,3}, {2,4,0,5,1,3}, {2,5,4,1,0,3},\n                {3,0,4,1,5,2}, {3,1,0,5,4,2}, {3,4,5,0,1,2}, {3,5,1,4,0,2},\n                {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1},\n                {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0}\n            };\n            \n            for (int[] orient : orientations) {\n                StringBuilder sb = new StringBuilder();\n                for (int i = 0; i < 6; i++) {\n                    if (i > 0) sb.append(\" \");\n                    sb.append(faces[orient[i]]);\n                }\n                rotations.add(sb.toString());\n            }\n            \n            return new ArrayList<>(rotations);\n        }\n        \n        String getCanonical() {\n            List<String> rotations = getAllRotations();\n            Collections.sort(rotations);\n            return rotations.get(0);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            sc.nextLine();\n            \n            Set<String> uniqueCubes = new HashSet<>();\n            \n            for (int i = 0; i < n; i++) {\n                String[] colors = sc.nextLine().split(\" \");\n                Cube cube = new Cube(colors);\n                String canonical = cube.getCanonical();\n                uniqueCubes.add(canonical);\n            }\n            \n            int needed = n - uniqueCubes.size();\n            System.out.println(needed);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Cube { String[] faces = new String[6]; Cube(String[] f) { faces = f.clone(); } // Generate all 24 rotations of the cube List<String>  new HashSet<>(); //  cube int[][] orientations = { {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5},  {2,0,1,4,5,3}, {2,1,5,0,4,3}, {2,4,0,5,1,3}, {2,5,4,1,0,3}, {3,0,4,1,5,2}, {3,1,0,5,4,2},  {4,5,3,2,0,1}, {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0} }; for (int[] orient : orientations) { StringBuilder sb = new StringBuilder(); for (int  6; i++) { if (i > 0) sb.append(\" \"); sb.append(faces[orient[i]]); } rotations.add(sb.toString()); } return new ArrayList<>(rotations);  rotations = getAllRotations(); Collections.sort(rotations); return rotations.get(0); } } public static void  = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; sc.nextLine(); Set<String> uniqueCubes  i = 0; i < n; i++) { String[] colors = sc.nextLine().split(\"  Cube(colors); String canonical = cube.getCanonical(); uniqueCubes.add(canonical); }  } }"], "perturbed_original": ["import java.util.*; public class Main{ ArrayList<char[]> color,list; ArrayList<String> clist;  new Scanner(System.in); clist = new ArrayList<String>();  clist.add(\"Cyan\"); while(true){ int n = sc.nextInt();  ArrayList<char[]>(); int cnt = 0; for(int i=0; i<n; i++){  c[j] = (char)clist.indexOf(sc.next()); if(same(c)) cnt++; else color.add(c); } System.out.println(cnt); } } int[][] rotate = {{1,2,4,3},{0,4,5,1},{0,2,5,3}}; boolean same(char[] dice){ list = new ArrayList<char[]>(); for(int i=0; i<4; i++){ dice = rotate(dice,0); for(int  rotate(dice,1); for(int l=0; l<4; l++){ dice = rotate(dice,2); list.add(dice); } } } for(int i=0; i<list.size(); i++){ char[] s1 = list.get(i); for(int j=0; j<color.size(); j++){ boolean boo  k++){ if(s1[k]!=s2[k]){ boo = false; break; } boo = true; } if(boo) return  } char[] rotate(char[] dice, int idx){ char[] res = new char[6]; for(int i=0; i<6; i++) res[i] = dice[i]; char tmp = res[rotate[idx][3]]; for(int  res[rotate[idx][i-1]]; res[rotate[idx][0]] =  static void main(String[] args){ new Main().solve(); } }"], "original_ll": -0.7026715874671936, "sampled_ll": -0.4533136785030365, "all_perturbed_sampled_ll": [-1.2389864921569824], "all_perturbed_original_ll": [-1.7265100479125977], "perturbed_sampled_ll": -1.2389864921569824, "perturbed_original_ll": -1.7265100479125977, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def equal(B):\n    temp=B[:]\n    S=set()\n    for i in range(4):\n        for j in range(4):\n            for k in range(4):\n                roll(0,2,5,3,temp)\n                S.add(tuple(temp))\n            roll(0,1,5,4,temp)\n        roll(1,2,4,3,temp)\n    return S\n\ndef roll(i,j,k,l,temp):\n    t=temp[i]\n    temp[i]=temp[j]\n    temp[j]=temp[k]\n    temp[k]=temp[l]\n    temp[l]=t\n\nwhile True:\n    n=input()\n    if n==0:break\n    L=[raw_input().split() for i in range(n)]\n    cnt=0\n    for i in range(n-1):\n        for j in range(i+1,n):\n            S=equal(L[j])\n            if tuple(L[i]) in S:\n                cnt+=1\n    print cnt", "sampled": "def normalize_cube(colors):\n    # Colors: [top, front, right, left, back, bottom]\n    # Indices:  0     1      2     3     4      5\n    \n    # Generate all 24 orientations of the cube\n    orientations = []\n    \n    # Original orientation\n    c = colors\n    \n    # All 24 rotations of a cube\n    # 4 rotations with each of the 6 faces as top\n    \n    def rotate_x(cube):\n        # Rotate around x-axis (right face axis) by 90 degrees\n        return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]]\n    \n    def rotate_y(cube):\n        # Rotate around y-axis (top face axis) by 90 degrees\n        return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]]\n    \n    def rotate_z(cube):\n        # Rotate around z-axis (front face axis) by 90 degrees\n        return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]]\n    \n    # Generate all 24 orientations\n    current = colors[:]\n    \n    for _ in range(4):\n        orientations.append(tuple(current))\n        for _ in range(3):\n            current = rotate_z(current)\n            orientations.append(tuple(current))\n        current = rotate_y(current)\n    \n    current = rotate_x(colors[:])\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.append(tuple(current))\n    \n    current = rotate_x(rotate_x(rotate_x(colors[:])))\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.append(tuple(current))\n    \n    # Return the lexicographically smallest orientation\n    return min(orientations)\n\ndef get_all_orientations(colors):\n    orientations = set()\n    \n    def rotate_x(cube):\n        return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]]\n    \n    def rotate_y(cube):\n        return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]]\n    \n    def rotate_z(cube):\n        return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]]\n    \n    current = colors[:]\n    for _ in range(4):\n        orientations.add(tuple(current))\n        for _ in range(3):\n            current = rotate_z(current)\n            orientations.add(tuple(current))\n        current = rotate_y(current)\n    \n    current = rotate_x(colors[:])\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.add(tuple(current))\n    \n    current = rotate_x(rotate_x(rotate_x(colors[:])))\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.add(tuple(current))\n    \n    return orientations\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    cubes = []\n    for _ in range(n):\n        colors = input().split()\n        cubes.append(colors)\n    \n    unique_cubes = set()\n    \n    for cube in cubes:\n        canonical = normalize_cube(cube)\n        unique_cubes.add(canonical)\n    \n    needed = n - len(unique_cubes)\n    print(needed)\n", "perturbed_sampled": ["def normalize_cube(colors): # Colors: [top, front, right, left,  1 2 3 4 5 # Generate  cube orientations = [] # Original orientation c = colors #  with each  top def rotate_x(cube): # Rotate around x-axis (right face axis) by 90 degrees return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]] def rotate_y(cube): # Rotate around y-axis (top face axis) by 90 degrees return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]] def rotate_z(cube): # Rotate around z-axis (front face axis) by 90 degrees return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]] # Generate all 24 orientations current = colors[:] for _ in range(4): orientations.append(tuple(current)) for _ in range(3): current = rotate_z(current) orientations.append(tuple(current)) current  for _ in range(3):  = rotate_x(rotate_x(rotate_x(colors[:]))) for _ in range(3): current = rotate_z(current) orientations.append(tuple(current)) # Return the  def get_all_orientations(colors): orientations = set() def rotate_x(cube): return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]] def rotate_y(cube): return [cube[0], cube[2], cube[4],  return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]] current = colors[:] for _ in range(4): orientations.add(tuple(current)) for _ in range(3): current = rotate_z(current) orientations.add(tuple(current)) current = rotate_y(current) current  orientations.add(tuple(current)) current =  current = rotate_z(current) orientations.add(tuple(current)) return  int(input()) if n == 0:   input().split() cubes.append(colors) unique_cubes = set()  = normalize_cube(cube) unique_cubes.add(canonical) needed = n - len(unique_cubes) print(needed)"], "perturbed_original": ["def equal(B): temp=B[:] S=set() for i in <extra_id_15>break for  roll(0,1,5,4,temp) roll(1,2,4,3,temp) return S def roll(i,j,k,l,temp): t=temp[i] temp[i]=temp[j] temp[j]=temp[k] temp[k]=temp[l] temp[l]=t while True: n=input() if n==0:break  cnt=0 for i in range(n-1): for j in range(i+1,n): S=equal(L[j]) if tuple(L[i]) in S: cnt+=1 print cnt"], "original_ll": -1.0768722295761108, "sampled_ll": -0.6434895396232605, "all_perturbed_sampled_ll": [-1.3731253147125244], "all_perturbed_original_ll": [-2.3204305171966553], "perturbed_sampled_ll": -1.3731253147125244, "perturbed_original_ll": -2.3204305171966553, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,m,p;\nchar s[2],c[101];\nA(){\n\tfor(p=0;c[p]!='#';p++);\n}\nB(){\n\tfor(p=n-1;p>=0;p--)\n\t\tif(c[p]=='#'&&(p+1==n||c[p+1]!='A')&&(p-1<0||c[p-1]!='A'))\n\t\t\treturn;\n\tA();\n}\nC(){\n\tfor(p=0;p<n;p++){\n\t\tif(c[p]!='#'){\n\t\t\tif(p+1!=n&&c[p+1]=='#'){\n\t\t\t\tp++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(p-1>=0&&c[p-1]=='#'){\n\t\t\t\tp--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tp=n/2;\n}\nD(){\n\tint D[100],d=n,q;\n\tfor(p=-1;++p<n;){\n\t\td++;\n\t\tif(c[p]!='#')\n\t\t\td=0;\n\t\tD[p]=d;\n\t}\n\tfor(d=0;--p>=0;){\n\t\td++;\n\t\tif(c[p]!='#')\n\t\t\td=0;\n\t\tif(d<D[p])\n\t\t\tD[p]=d;\n\t}\n\tfor(p=q=0;q<n;q++)\n\t\tif(D[q]>D[p])\n\t\t\tp=q;\n}\nmain(){\n\tfor(;scanf(\"%d%d\",&n,&m),n;){\n\t\tmemset(c,'#',100);\n\t\tc[n]=0;\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s\",s);\n\t\t\tif(s[0]=='A')\n\t\t\t\tA();\n\t\t\tif(s[0]=='B')\n\t\t\t\tB();\n\t\t\tif(s[0]=='C')\n\t\t\t\tC();\n\t\t\tif(s[0]=='D')\n\t\t\t\tD();\n\t\t\tc[p]=s[0];\n\t\t}\n\t\tputs(c);\n\t}\n\texit(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, m;\n    \n    while(1) {\n        scanf(\"%d %d\", &n, &m);\n        if(n == 0 && m == 0) break;\n        \n        char seats[101];\n        for(int i = 0; i < n; i++) {\n            seats[i] = '#';\n        }\n        \n        for(int i = 0; i < m; i++) {\n            char type;\n            scanf(\" %c\", &type);\n            \n            if(type == 'A') {\n                // Left to right, first empty seat\n                for(int j = 0; j < n; j++) {\n                    if(seats[j] == '#') {\n                        seats[j] = 'A';\n                        break;\n                    }\n                }\n            }\n            else if(type == 'B') {\n                // Right to left, not next to A\n                int pos = -1;\n                for(int j = n-1; j >= 0; j--) {\n                    if(seats[j] == '#') {\n                        int nextToA = 0;\n                        if(j > 0 && seats[j-1] == 'A') nextToA = 1;\n                        if(j < n-1 && seats[j+1] == 'A') nextToA = 1;\n                        if(!nextToA) {\n                            pos = j;\n                            break;\n                        }\n                    }\n                }\n                if(pos == -1) {\n                    // All empty seats are next to A, take leftmost empty\n                    for(int j = 0; j < n; j++) {\n                        if(seats[j] == '#') {\n                            pos = j;\n                            break;\n                        }\n                    }\n                }\n                seats[pos] = 'B';\n            }\n            else if(type == 'C') {\n                // Next to someone, prefer right then left of leftmost person\n                int hasAnyone = 0;\n                for(int j = 0; j < n; j++) {\n                    if(seats[j] != '#') {\n                        hasAnyone = 1;\n                        break;\n                    }\n                }\n                \n                if(!hasAnyone) {\n                    // Sit in middle\n                    int mid = (n % 2 == 1) ? (n+1)/2 - 1 : n/2;\n                    seats[mid] = 'C';\n                } else {\n                    int pos = -1;\n                    for(int j = 0; j < n; j++) {\n                        if(seats[j] != '#') {\n                            if(j+1 < n && seats[j+1] == '#') {\n                                pos = j+1;\n                                break;\n                            } else if(j-1 >= 0 && seats[j-1] == '#') {\n                                pos = j-1;\n                                break;\n                            }\n                        }\n                    }\n                    seats[pos] = 'C';\n                }\n            }\n            else if(type == 'D') {\n                // Maximize minimum distance to nearest person\n                int hasAnyone = 0;\n                for(int j = 0; j < n; j++) {\n                    if(seats[j] != '#') {\n                        hasAnyone = 1;\n                        break;\n                    }\n                }\n                \n                if(!hasAnyone) {\n                    seats[0] = 'D';\n                } else {\n                    int bestPos = -1;\n                    int maxMinDist = -1;\n                    \n                    for(int j = 0; j < n; j++) {\n                        if(seats[j] == '#') {\n                            int minDist = n+1;\n                            for(int k = 0; k < n; k++) {\n                                if(seats[k] != '#') {\n                                    int dist = (j > k) ? (j - k) : (k - j);\n                                    if(dist < minDist) minDist = dist;\n                                }\n                            }\n                            if(minDist > maxMinDist) {\n                                maxMinDist = minDist;\n                                bestPos = j;\n                            }\n                        }\n                    }\n                    seats[bestPos] = 'D';\n                }\n            }\n        }\n        \n        for(int i = 0; i < n; i++) {\n            printf(\"%c\", seats[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int  %d\", &n, &m); if(n ==  break; char seats[101]; for(int i = 0; i < n; i++) { seats[i] = '#'; } for(int i = 0; i  type; scanf(\"  { // Left to right, first empty seat  < n; j++) { if(seats[j] == '#') { seats[j] =  else if(type == 'B') { // Right to left, not next to A int pos = -1; for(int j =  { int nextToA =  seats[j-1] == 'A') nextToA = 1; if(j < n-1  = 1; if(!nextToA)  } } } if(pos == -1) { // All empty seats are next to A, take leftmost empty for(int j =  { pos = j; break; } } } seats[pos] = 'B'; } else if(type == 'C') { // Next to someone,  leftmost person int hasAnyone = 0; for(int j = 0; j < n; j++) { if(seats[j] != '#') { hasAnyone = 1; break; }   1) ? (n+1)/2 - 1 : n/2; seats[mid] = 'C';  = -1; for(int j =  { if(seats[j] != '#') { if(j+1 < n && seats[j+1]  j+1; break; } else if(j-1 >= 0 && seats[j-1] == '#') { pos = j-1; break; } } } seats[pos] = 'C';  minimum distance to nearest person int hasAnyone = 0; for(int j = 0; j < n; j++) { if(seats[j] != '#') { hasAnyone = 1; break;  = 'D'; } else { int bestPos = -1; int maxMinDist = -1; for(int j = 0; j < n; j++) { if(seats[j] == '#') { int minDist = n+1; for(int k = 0; k < n; k++) { if(seats[k] != '#') { int dist =  - k) :  minDist) minDist = dist; } } if(minDist > maxMinDist) { maxMinDist = minDist; bestPos = j; } } } seats[bestPos] = 'D'; } } } for(int i = 0; i <  } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["n,m,p; char s[2],c[101];  if(c[p]=='#'&&(p+1==n||c[p+1]!='A')&&(p-1<0||c[p-1]!='A')) return; A(); }  return; }  } p=n/2;  d++; if(c[p]!='#') d=0; D[p]=d; } for(d=0;--p>=0;){ d++; if(c[p]!='#') d=0; if(d<D[p]) D[p]=d; } for(p=q=0;q<n;q++) if(D[q]>D[p]) p=q; } main(){ for(;scanf(\"%d%d\",&n,&m),n;){ memset(c,'#',100); c[n]=0; for(;m--;){ scanf(\"%s\",s); if(s[0]=='A') A(); if(s[0]=='B') B(); if(s[0]=='C') C(); if(s[0]=='D') D(); c[p]=s[0]; } puts(c); } exit(0); }"], "original_ll": -1.0930947065353394, "sampled_ll": -0.455364465713501, "all_perturbed_sampled_ll": [-1.4071472883224487], "all_perturbed_original_ll": [-1.681281328201294], "perturbed_sampled_ll": -1.4071472883224487, "perturbed_original_ll": -1.681281328201294, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tchar[] a = new char[n+2];\n\t\t\tArrays.fill(a,'#');\n\t\t\ta[0] = 'X';\n\t\t\ta[n+1] = 'X';\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif(c=='A'){\n\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\tif(a[j]=='#'){\n\t\t\t\t\t\t\ta[j] = c;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(c=='B'){\n\t\t\t\t\tboolean flag = true;\n\t\t\t\t\tfor(int j=n;j>0;j--){\n\t\t\t\t\t\tif(a[j]=='#' && a[j-1]!='A' && a[j+1]!='A'){\n\t\t\t\t\t\t\ta[j] = c;\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==true){\n\t\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\t\tif(a[j]=='#'){\n\t\t\t\t\t\t\t\ta[j] = c;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(c=='C'){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tif(n%2==0) a[(n+1)/2] = c;\n\t\t\t\t\t\telse a[n/2+1] = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\t\tif(a[j]!='#'){\n\t\t\t\t\t\t\t\tif(a[j+1]=='#'){\n\t\t\t\t\t\t\t\t\ta[j+1] = c;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(a[j-1]=='#'){\n\t\t\t\t\t\t\t\t\ta[j-1] = c;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(c=='D'){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\ta[1] = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint max = -1;\n\t\t\t\t\t\tint p = -1;\n\t\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\t\tif(a[j]=='#'){\n\t\t\t\t\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\t\t\t\t\tfor(int k=j-1;k>=0;k--){\n\t\t\t\t\t\t\t\t\tif(k==0) break;\n\t\t\t\t\t\t\t\t\tif(a[k]!='#'){\n\t\t\t\t\t\t\t\t\t\tmin = Math.min(min, j-k+1);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j+1;k<=n+1;k++){\n\t\t\t\t\t\t\t\t\tif(k==n+1) break;\n\t\t\t\t\t\t\t\t\tif(a[k]!='#'){\n\t\t\t\t\t\t\t\t\t\tmin = Math.min(min, k-j+1);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min>max){\n\t\t\t\t\t\t\t\t\tmax = min;\n\t\t\t\t\t\t\t\t\tp = j;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[p] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++) System.out.print(a[i]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) break;\n            \n            char[] chairs = new char[n];\n            Arrays.fill(chairs, '#');\n            \n            for (int i = 0; i < m; i++) {\n                String nationality = sc.next();\n                char person = nationality.charAt(0);\n                \n                if (person == 'A') {\n                    // Left to right, first empty chair\n                    for (int j = 0; j < n; j++) {\n                        if (chairs[j] == '#') {\n                            chairs[j] = 'A';\n                            break;\n                        }\n                    }\n                } else if (person == 'B') {\n                    // Right to left, not next to A\n                    boolean found = false;\n                    for (int j = n - 1; j >= 0; j--) {\n                        if (chairs[j] == '#') {\n                            boolean nextToA = false;\n                            if (j > 0 && chairs[j - 1] == 'A') nextToA = true;\n                            if (j < n - 1 && chairs[j + 1] == 'A') nextToA = true;\n                            \n                            if (!nextToA) {\n                                chairs[j] = 'B';\n                                found = true;\n                                break;\n                            }\n                        }\n                    }\n                    \n                    if (!found) {\n                        // Must sit next to A, left to right\n                        for (int j = 0; j < n; j++) {\n                            if (chairs[j] == '#') {\n                                chairs[j] = 'B';\n                                break;\n                            }\n                        }\n                    }\n                } else if (person == 'C') {\n                    // Next to someone, prefer right then left\n                    boolean found = false;\n                    \n                    // Check if anyone is sitting\n                    boolean anyoneSeated = false;\n                    for (int j = 0; j < n; j++) {\n                        if (chairs[j] != '#') {\n                            anyoneSeated = true;\n                            break;\n                        }\n                    }\n                    \n                    if (!anyoneSeated) {\n                        // Sit in middle\n                        int middle = (n % 2 == 1) ? n / 2 : n / 2;\n                        chairs[middle] = 'C';\n                    } else {\n                        // Find leftmost person and try right, then left\n                        for (int j = 0; j < n; j++) {\n                            if (chairs[j] != '#') {\n                                // Try right\n                                if (j + 1 < n && chairs[j + 1] == '#') {\n                                    chairs[j + 1] = 'C';\n                                    found = true;\n                                    break;\n                                }\n                                // Try left\n                                if (j - 1 >= 0 && chairs[j - 1] == '#') {\n                                    chairs[j - 1] = 'C';\n                                    found = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                } else if (person == 'D') {\n                    // Maximize minimum distance\n                    boolean anyoneSeated = false;\n                    for (int j = 0; j < n; j++) {\n                        if (chairs[j] != '#') {\n                            anyoneSeated = true;\n                            break;\n                        }\n                    }\n                    \n                    if (!anyoneSeated) {\n                        chairs[0] = 'D';\n                    } else {\n                        int bestPos = -1;\n                        int maxMinDist = -1;\n                        \n                        for (int j = 0; j < n; j++) {\n                            if (chairs[j] == '#') {\n                                int minDist = Integer.MAX_VALUE;\n                                \n                                for (int k = 0; k < n; k++) {\n                                    if (chairs[k] != '#') {\n                                        minDist = Math.min(minDist, Math.abs(j - k));\n                                    }\n                                }\n                                \n                                if (minDist > maxMinDist) {\n                                    maxMinDist = minDist;\n                                    bestPos = j;\n                                }\n                            }\n                        }\n                        \n                        chairs[bestPos] = 'D';\n                    }\n                }\n            }\n            \n            System.out.println(new String(chairs));\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true)  int m  0 &&  chairs = new char[n]; Arrays.fill(chairs, '#'); for (int i = 0; i < m; i++) {  person = nationality.charAt(0); if (person == 'A') { // Left to right, first empty chair for (int j = 0; j < n; j++) { if (chairs[j] == '#') { chairs[j] = 'A';  if (person  to left, not  j = n - 1; j >= 0; j--) { if (chairs[j] == '#') {  (j > 0 && chairs[j - 1] == 'A') nextToA = true; if (j < n  1] ==  'B'; found = true; break; } } } if (!found) { // Must sit next to A, left to right for (int j = 0; j < n; j++) { if (chairs[j] == '#') { chairs[j] = 'B'; break; } } } } else if (person == 'C') { // Next to someone, prefer right then left boolean found = false; // Check if anyone is sitting boolean anyoneSeated = false; for (int j = 0; j  (chairs[j] != '#') { anyoneSeated = true; break; } } if (!anyoneSeated) { // Sit in middle  2 ==  chairs[middle] = 'C'; } else { // Find leftmost person and try right, then left for (int j = 0; j  (chairs[j] != '#') { // Try  < n && chairs[j +  + 1] = 'C'; found = true; break; } // Try left if (j - 1 >= 0 &&  { chairs[j - 1] = 'C'; found = true; break; } } } } } else if (person == 'D') {  anyoneSeated = false; for (int j = 0; j < n; j++) { if (chairs[j] != '#') { anyoneSeated = true; break; } } if (!anyoneSeated) { chairs[0] = 'D'; } else { int bestPos = -1; int maxMinDist =  0; j < n; j++) { if (chairs[j] == '#') {   if (chairs[k] != '#') { minDist =  }  maxMinDist = minDist;  } chairs[bestPos] = 'D';  } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main  args) { Scanner sc = new Scanner(System.in); while(true){ int n = sc.nextInt(); int m = sc.nextInt(); if(n==0 && m==0) break; char[] a = new char[n+2]; Arrays.fill(a,'#'); a[0] = 'X'; a[n+1] = 'X'; for(int i=0;i<m;i++){ char c   } } }else  for(int j=n;j>0;j--){ if(a[j]=='#' && a[j-1]!='A' && a[j+1]!='A'){ a[j] =  j=1;j<=n;j++){ if(a[j]=='#'){ a[j] = c; break; } } } }else if(c=='C'){ if(i==0){ if(n%2==0) a[(n+1)/2] = c; else a[n/2+1] = c; }else{ for(int j=1;j<=n;j++){ if(a[j]!='#'){ if(a[j+1]=='#'){ a[j+1] = c; break; } if(a[j-1]=='#'){ a[j-1] = c;  }else if(c=='D'){ if(i==0){ a[1] = c;  int p  int min = Integer.MAX_VALUE; for(int k=j-1;k>=0;k--){ if(k==0) break; if(a[k]!='#'){ min = Math.min(min, j-k+1); break; } } for(int k=j+1;k<=n+1;k++){ if(k==n+1)  k-j+1); break; } } if(min>max){ max = min; p = j; } } } a[p] = c; }  System.out.println(); } } }"], "original_ll": -0.438597172498703, "sampled_ll": -0.4190274775028229, "all_perturbed_sampled_ll": [-1.4765833616256714], "all_perturbed_original_ll": [-1.2580575942993164], "perturbed_sampled_ll": -1.4765833616256714, "perturbed_original_ll": -1.2580575942993164, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "INF = 10 ** 20\n\nwhile True:\n  n, m = map(int, input().split())\n  if not n:\n    break\n\n  chairs = list(\"#\" * n)\n\n  def sit(s):\n    if s == \"A\":\n      chairs[chairs.index(\"#\")] = \"A\"\n    elif s == \"B\":\n      for i in range(n - 1, -1, -1):\n        if chairs[i] == \"#\" and (i == 0 or chairs[i - 1] != \"A\") and (i == n - 1 or chairs[i + 1] != \"A\"):\n          chairs[i] = \"B\"\n          break\n      else:\n        chairs[chairs.index(\"#\")] = \"B\"\n\n    elif s == \"C\":\n      for i in range(1, n):\n        if chairs[i] == \"#\" and chairs[i - 1] != \"#\":\n          chairs[i] = \"C\"\n          break\n\n    else:\n      score = [INF for _ in range(n)]\n      dist = INF\n      for i in range(n):\n        if chairs[i] == \"#\":\n          dist += 1\n        else:\n          dist = 0\n        score[i] = dist\n\n      dist = INF\n      for i in range(n - 1, -1, -1):\n        if chairs[i] == \"#\":\n          dist += 1\n        else:\n          dist = 0\n        score[i] = min(score[i], dist)\n      high_score = max(score)\n      chairs[score.index(high_score)] = \"D\"\n  \n  first = input()\n  if first in [\"A\", \"D\"]:\n    chairs[0] = first\n  elif first == \"B\":\n    chairs[-1] = \"B\"\n  else:\n    chairs[n // 2] = \"C\"\n  for _ in range(m - 1):\n    sit(input())\n\n  print(\"\".join(chairs))\n\n", "sampled": "import sys\n\ndef solve(n, m, passengers):\n    seats = ['#'] * n  # 0-indexed\n    \n    for passenger in passengers:\n        if passenger == 'A':\n            # Left to right, first empty\n            for i in range(n):\n                if seats[i] == '#':\n                    seats[i] = 'A'\n                    break\n                    \n        elif passenger == 'B':\n            # Avoid A, right to left\n            # First try to find seat not adjacent to A\n            found = False\n            for i in range(n-1, -1, -1):\n                if seats[i] == '#':\n                    # Check if adjacent to A\n                    adjacent_to_a = False\n                    if i > 0 and seats[i-1] == 'A':\n                        adjacent_to_a = True\n                    if i < n-1 and seats[i+1] == 'A':\n                        adjacent_to_a = True\n                    \n                    if not adjacent_to_a:\n                        seats[i] = 'B'\n                        found = True\n                        break\n            \n            # If not found, sit left to right (adjacent to A is ok)\n            if not found:\n                for i in range(n):\n                    if seats[i] == '#':\n                        seats[i] = 'B'\n                        break\n                        \n        elif passenger == 'C':\n            # Sit next to someone\n            # Find leftmost person, try right then left\n            found = False\n            \n            # Check if anyone is seated\n            someone_seated = any(s != '#' for s in seats)\n            \n            if someone_seated:\n                for i in range(n):\n                    if seats[i] != '#':\n                        # Try right\n                        if i < n-1 and seats[i+1] == '#':\n                            seats[i+1] = 'C'\n                            found = True\n                            break\n                        # Try left\n                        elif i > 0 and seats[i-1] == '#':\n                            seats[i-1] = 'C'\n                            found = True\n                            break\n            \n            if not found:\n                # Sit in middle\n                if n % 2 == 1:\n                    mid = n // 2\n                else:\n                    mid = n // 2\n                seats[mid] = 'C'\n                \n        elif passenger == 'D':\n            # Maximize minimum distance\n            # If no one seated, sit at left end\n            someone_seated = any(s != '#' for s in seats)\n            \n            if not someone_seated:\n                seats[0] = 'D'\n            else:\n                # Find empty seat with max min distance\n                best_seat = -1\n                best_min_dist = -1\n                \n                for i in range(n):\n                    if seats[i] == '#':\n                        # Calculate min distance to any occupied seat\n                        min_dist = float('inf')\n                        for j in range(n):\n                            if seats[j] != '#':\n                                min_dist = min(min_dist, abs(i - j))\n                        \n                        if min_dist > best_min_dist:\n                            best_min_dist = min_dist\n                            best_seat = i\n                \n                seats[best_seat] = 'D'\n    \n    return ''.join(seats)\n\n# Read input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.strip())\n\ni = 0\nwhile i < len(lines):\n    parts = lines[i].split()\n    n, m = int(parts[0]), int(parts[1])\n    \n    if n == 0 and m == 0:\n        break\n    \n    i += 1\n    passengers = []\n    for j in range(m):\n        passengers.append(lines[i])\n        i += 1\n    \n    result = solve(n, m, passengers)\n    print(result)\n", "perturbed_sampled": ["import sys def solve(n, m, passengers): seats = ['#'] * n # 0-indexed  passenger == 'A': # Left to right, first empty for i in range(n): if seats[i] == '#': seats[i] = 'A'  # Avoid A, right to left # First try to find seat not adjacent to A found =  -1, -1): if seats[i] == '#': # Check   0 and seats[i-1] == 'A': adjacent_to_a = True if i < n-1 and seats[i+1] == 'A': adjacent_to_a = True if not adjacent_to_a:  True break # If not found, sit left to right (adjacent to A is ok) if not found: for i in range(n): if seats[i] == '#': seats[i] = 'B' break elif passenger == 'C': # Sit  leftmost person, try right then left found = False  seated someone_seated = any(s != '#' for s in seats) if someone_seated: for i in range(n): if seats[i] != '#': # Try right if i < n-1 and seats[i+1] == '#': seats[i+1] = 'C' found = True break # Try left elif i > 0  found: # Sit in middle if n % 2 == 1: mid = n // 2 else: mid =  'C' elif passenger == 'D': # Maximize minimum distance # If no one seated, sit at left end someone_seated = any(s != '#' for s in seats) if not someone_seated: seats[0] = 'D' else: # Find empty  best_seat  if seats[i] == '#': # Calculate min distance to any  for j in  min_dist  best_min_dist  seats[best_seat]  Read input lines = [] for line in sys.stdin: lines.append(line.strip()) i = 0 while i < len(lines): parts = lines[i].split() n, m = int(parts[0]), int(parts[1]) if n == 0 and m ==  passengers = [] for j in range(m): passengers.append(lines[i]) i  m, passengers) print(result)"], "perturbed_original": ["INF = 10 **  = map(int,  chairs = list(\"#\" * n) def  chairs[chairs.index(\"#\")] = \"A\"  i in range(n - 1, -1, -1): if chairs[i] == \"#\" and (i == 0 or chairs[i  (i == n - 1 or chairs[i + 1] != \"A\"): chairs[i] = \"B\" break else: chairs[chairs.index(\"#\")] = \"B\" elif s == \"C\": for i in range(1, n): if chairs[i] == \"#\" and chairs[i - 1] != \"#\": chairs[i] = \"C\" break else: score = [INF for _   chairs[i] == \"#\": dist += 1 else: dist = 0 score[i] = dist dist = INF for  == \"#\": dist += 1 else:  min(score[i], dist) high_score = max(score) chairs[score.index(high_score)] = \"D\" first = input() if first in [\"A\", \"D\"]: chairs[0] = first elif first == \"B\": chairs[-1] = \"B\" else: chairs[n // 2]  range(m - 1): sit(input()) print(\"\".join(chairs))"], "original_ll": -0.7738449573516846, "sampled_ll": -0.6466282606124878, "all_perturbed_sampled_ll": [-1.958562970161438], "all_perturbed_original_ll": [-1.8748220205307007], "perturbed_sampled_ll": -1.958562970161438, "perturbed_original_ll": -1.8748220205307007, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int i,j,k,l,n,m;\n  int d[2][100][100]={0};\n  while(scanf(\"%d %d\",&m,&n),n||m){\n    for(i=0;i<100;i++){\n      for(j=0;j<100;j++)d[0][i][j]=d[1][i][j]=100000000;\n      d[0][i][i]=d[1][i][i]=0;\n    }\n    while(m--){\n      scanf(\"%d %d %d %d\",&i,&j,&k,&l);\n      d[0][i-1][j-1]=d[0][j-1][i-1]=k;\n      d[1][i-1][j-1]=d[1][j-1][i-1]=l;\n    }\n    for(l=0;l<n;l++){\n      //for(i=0;i<2;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++){\n\t  //for(l=0;l<n;l++){\n\t  for(i=0;i<2;i++){\n\t    if(d[i][j][k]>d[i][j][l]+d[i][l][k]){\n\t       d[i][j][k]=d[i][j][l]+d[i][l][k];\n\t    }\n\t  }\n\t}\n      }\n    }\n    scanf(\"%d\",&l);\n    while(l--){\n      scanf(\"%d %d %d\",&i,&j,&k);\n      printf(\"%d\\n\",d[k][i-1][j-1]);\n    }\n  }\n  return 0;\n}\n      ", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_M 105\n#define INF 1000000000\n\nint n, m, k;\nint cost_graph[MAX_M][MAX_M];\nint time_graph[MAX_M][MAX_M];\n\nint dijkstra(int graph[MAX_M][MAX_M], int start, int end) {\n    int dist[MAX_M];\n    int visited[MAX_M];\n    int i, j;\n    \n    for (i = 1; i <= m; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    \n    dist[start] = 0;\n    \n    for (i = 0; i < m; i++) {\n        int min_dist = INF;\n        int u = -1;\n        \n        for (j = 1; j <= m; j++) {\n            if (!visited[j] && dist[j] < min_dist) {\n                min_dist = dist[j];\n                u = j;\n            }\n        }\n        \n        if (u == -1) break;\n        \n        visited[u] = 1;\n        \n        for (j = 1; j <= m; j++) {\n            if (!visited[j] && graph[u][j] != INF) {\n                if (dist[u] + graph[u][j] < dist[j]) {\n                    dist[j] = dist[u] + graph[u][j];\n                }\n            }\n        }\n    }\n    \n    return dist[end];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0) break;\n        \n        int i, j;\n        \n        for (i = 1; i <= m; i++) {\n            for (j = 1; j <= m; j++) {\n                if (i == j) {\n                    cost_graph[i][j] = 0;\n                    time_graph[i][j] = 0;\n                } else {\n                    cost_graph[i][j] = INF;\n                    time_graph[i][j] = INF;\n                }\n            }\n        }\n        \n        for (i = 0; i < n; i++) {\n            int a, b, cost, time;\n            scanf(\"%d %d %d %d\", &a, &b, &cost, &time);\n            \n            if (cost < cost_graph[a][b]) {\n                cost_graph[a][b] = cost;\n                cost_graph[b][a] = cost;\n            }\n            \n            if (time < time_graph[a][b]) {\n                time_graph[a][b] = time;\n                time_graph[b][a] = time;\n            }\n        }\n        \n        scanf(\"%d\", &k);\n        \n        for (i = 0; i < k; i++) {\n            int p, q, r;\n            scanf(\"%d %d %d\", &p, &q, &r);\n            \n            if (r == 0) {\n                printf(\"%d\\n\", dijkstra(cost_graph, p, q));\n            } else {\n                printf(\"%d\\n\", dijkstra(time_graph, p, q));\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include  INF 1000000000 int n, m, k; int cost_graph[MAX_M][MAX_M]; int time_graph[MAX_M][MAX_M]; int dijkstra(int graph[MAX_M][MAX_M],  int dist[MAX_M]; int visited[MAX_M]; int i, j; for (i = 1;  = 0; } dist[start] = 0; for (i = 0; i < m; i++) { int min_dist = INF;  (j = 1; j <= m; j++)  < min_dist) { min_dist = dist[j]; u = j; } } if (u == -1) break; visited[u] = 1; for  m; j++) { if (!visited[j] &&  (dist[u] + graph[u][j] < dist[j]) { dist[j] = dist[u] + graph[u][j]; } } } } return dist[end]; } int main() { while (1) { scanf(\"%d  == 0 && m == 0) break; int i, j; for (i = 1; i <= m; i++) { for (j = 1; j <= m; j++) { if (i == j) { cost_graph[i][j] = 0; time_graph[i][j] = 0; } else { cost_graph[i][j] = INF; time_graph[i][j] = INF; } } } for (i = 0; i < n; i++) { int a, b, cost, time; scanf(\"%d %d  cost_graph[a][b]) { cost_graph[a][b] =  { time_graph[a][b] = time; time_graph[b][a] = time; } }  0; i <  q, r; scanf(\"%d %d %d\", &p, &q, &r); if (r == 0) { printf(\"%d\\n\",  { printf(\"%d\\n\", dijkstra(time_graph,  return 0; }"], "perturbed_original": ["#include<stdio.h>  d[2][100][100]={0}; while(scanf(\"%d %d\",&m,&n),n||m){ for(i=0;i<100;i++){ for(j=0;j<100;j++)d[0][i][j]=d[1][i][j]=100000000; d[0][i][i]=d[1][i][i]=0; } while(m--){ scanf(\"%d %d %d %d\",&i,&j,&k,&l); d[0][i-1][j-1]=d[0][j-1][i-1]=k; d[1][i-1][j-1]=d[1][j-1][i-1]=l; } for(l=0;l<n;l++){ //for(i=0;i<2;i++){ for(j=0;j<n;j++){ for(k=0;k<n;k++){ //for(l=0;l<n;l++){ for(i=0;i<2;i++){ if(d[i][j][k]>d[i][j][l]+d[i][l][k]){ d[i][j][k]=d[i][j][l]+d[i][l][k]; } }  scanf(\"%d %d %d\",&i,&j,&k); printf(\"%d\\n\",d[k][i-1][j-1]); } } return 0; }"], "original_ll": -0.6384304165840149, "sampled_ll": -0.26441705226898193, "all_perturbed_sampled_ll": [-1.1634122133255005], "all_perturbed_original_ll": [-0.8174389004707336], "perturbed_sampled_ll": -1.1634122133255005, "perturbed_original_ll": -0.8174389004707336, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic final int INF = 1000000000;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] cost = new int[m][m];\n\t\t\tint[][] time = new int[m][m];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t\t\ttime[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tcost[a][b] = sc.nextInt();\n\t\t\t\tcost[b][a] = cost[a][b];\n\t\t\t\ttime[a][b] = sc.nextInt();\n\t\t\t\ttime[b][a] = time[a][b];\n\t\t\t}\n\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\t\tfor(int j = i; j < m; j++){\n\t\t\t\t\t\tcost[i][j] = Math.min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t\t\tcost[j][i] = cost[i][j];\n\t\t\t\t\t\ttime[i][j] = Math.min(time[i][j], time[i][k] + time[k][j]);\n\t\t\t\t\t\ttime[j][i] = time[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint k = sc.nextInt();\n\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\tint p = sc.nextInt() - 1;\n\t\t\t\tint q = sc.nextInt() - 1;\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tif(r == 0){\n\t\t\t\t\tSystem.out.println(cost[p][q]);\n\t\t\t\t}else if(r == 1){\n\t\t\t\t\tSystem.out.println(time[p][q]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, cost, time;\n        Edge(int to, int cost, int time) {\n            this.to = to;\n            this.cost = cost;\n            this.time = time;\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        int node, value;\n        State(int node, int value) {\n            this.node = node;\n            this.value = value;\n        }\n        public int compareTo(State other) {\n            return this.value - other.value;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) break;\n            \n            List<Edge>[] graph = new ArrayList[m + 1];\n            for (int i = 0; i <= m; i++) {\n                graph[i] = new ArrayList<>();\n            }\n            \n            for (int i = 0; i < n; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int cost = sc.nextInt();\n                int time = sc.nextInt();\n                graph[a].add(new Edge(b, cost, time));\n                graph[b].add(new Edge(a, cost, time));\n            }\n            \n            int k = sc.nextInt();\n            for (int i = 0; i < k; i++) {\n                int p = sc.nextInt();\n                int q = sc.nextInt();\n                int r = sc.nextInt();\n                \n                if (r == 0) {\n                    System.out.println(dijkstra(graph, m, p, q, true));\n                } else {\n                    System.out.println(dijkstra(graph, m, p, q, false));\n                }\n            }\n        }\n        sc.close();\n    }\n    \n    static int dijkstra(List<Edge>[] graph, int m, int start, int end, boolean useCost) {\n        int[] dist = new int[m + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(start, 0));\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            int u = current.node;\n            int d = current.value;\n            \n            if (d > dist[u]) continue;\n            \n            for (Edge edge : graph[u]) {\n                int v = edge.to;\n                int weight = useCost ? edge.cost : edge.time;\n                \n                if (dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.offer(new State(v, dist[v]));\n                }\n            }\n        }\n        \n        return dist[end];\n    }\n}\n", "perturbed_sampled": ["  int to, cost, time;   this.cost = cost; this.time = time; } } static class State implements Comparable<State> { int node, value; State(int node, int value) { this.node = node; this.value = value; } public int compareTo(State other) { return this.value - other.value; } } public static  sc =  int n = sc.nextInt(); int m  0 && m == 0) break; List<Edge>[] graph = new ArrayList[m + 1]; for (int i = 0; i <= m; i++) {  for (int i = 0; i < n; i++) { int a = sc.nextInt(); int b = sc.nextInt(); int cost = sc.nextInt(); int time = sc.nextInt(); graph[a].add(new Edge(b, cost, time)); graph[b].add(new Edge(a,  = sc.nextInt(); for (int i = 0; i < k; i++) { int p =  int r = sc.nextInt(); if (r == 0) {  } else { System.out.println(dijkstra(graph, m, p, q, false)); } } } sc.close(); } static int dijkstra(List<Edge>[] graph, int m, int start, int end, boolean useCost) { int[] dist = new int[m + 1]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0;  (!pq.isEmpty()) { State current = pq.poll(); int u  current.value; if (d  edge : graph[u]) { int v = edge.to; int weight = useCost ? edge.cost : edge.time; if (dist[u]  dist[v]  State(v, dist[v])); } } } return dist[end]; } }"], "perturbed_original": ["import  Main { static final int INF = 1000000000; public static void  Auto-generated method stub Scanner sc =  = sc.nextInt(); if(n == 0 && m == 0){ break; } int[][] cost =  new int[m][m]; for(int i = 0; i < m; i++){ for(int j = 0; j < m; j++){  INF; } } for(int i = 0; i < n; i++){ int a = sc.nextInt() - 1; int b = sc.nextInt() - 1;  cost[a][b]; time[a][b] = sc.nextInt(); time[b][a] = time[a][b]; } for(int k = 0; k < m; k++){ for(int i = 0; i < m; i++){ for(int j  j++){ cost[i][j] = Math.min(cost[i][j],  cost[i][j]; time[i][j]  time[j][i] = time[i][j]; } } } int k = sc.nextInt(); for(int i = 0; i < k; i++){  sc.nextInt() - 1; int r = sc.nextInt(); if(r == 0){ System.out.println(cost[p][q]); }else if(r == 1){ System.out.println(time[p][q]); } } } sc.close(); } }"], "original_ll": -0.33844512701034546, "sampled_ll": -0.3199770152568817, "all_perturbed_sampled_ll": [-1.275190830230713], "all_perturbed_original_ll": [-1.1964730024337769], "perturbed_sampled_ll": -1.275190830230713, "perturbed_original_ll": -1.1964730024337769, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nfrom copy import deepcopy\nINF = 1000000000\ndef dj(s, e, r):\n  d = [INF] * 100\n  done = [0] * 100\n  d[s] = 0\n  while True:\n    v = -1\n    for i in VL:\n      if not done[i] and (v == -1 or d[i] < d[v]):\n        v = i\n    if v == e:\n      return d[e]\n    done[v] = True\n    for i in VL:\n      d[i] = min(d[i], d[v] + cost[v][i][r])\n\nL100 = range(100)\ncostPre = [[[INF for k in range(2)] for j in L100] for i in L100]\nwhile True:\n  E, V = map(int, raw_input().split())\n  cost = deepcopy(costPre)\n  VL = range(V)\n  if not E:\n    break\n  for i in range(E):\n    a, b, c, d = map(int, raw_input().split())\n    a -= 1\n    b -= 1\n    cost[a][b][0] = cost[b][a][0] = c\n    cost[a][b][1] = cost[b][a][1] = d\n  k = input()\n  for i in range(k):\n    p, q, r = map(int, raw_input().split())\n    p -= 1\n    q -= 1\n    print dj(p, q, r)", "sampled": "import heapq\nfrom collections import defaultdict\nimport sys\n\ndef dijkstra(graph, start, end, mode):\n    # mode: 0 for cost, 1 for time\n    pq = [(0, start)]\n    visited = set()\n    dist = defaultdict(lambda: float('inf'))\n    dist[start] = 0\n    \n    while pq:\n        current_dist, node = heapq.heappop(pq)\n        \n        if node in visited:\n            continue\n            \n        visited.add(node)\n        \n        if node == end:\n            return current_dist\n        \n        for neighbor, cost, time in graph[node]:\n            weight = cost if mode == 0 else time\n            new_dist = current_dist + weight\n            \n            if new_dist < dist[neighbor]:\n                dist[neighbor] = new_dist\n                heapq.heappush(pq, (new_dist, neighbor))\n    \n    return dist[end]\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    if not line:\n        break\n    n = int(line)\n    m = int(sys.stdin.readline().strip())\n    \n    if n == 0 and m == 0:\n        break\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n):\n        parts = list(map(int, sys.stdin.readline().strip().split()))\n        a, b, cost, time = parts[0], parts[1], parts[2], parts[3]\n        graph[a].append((b, cost, time))\n        graph[b].append((a, cost, time))\n    \n    k = int(sys.stdin.readline().strip())\n    \n    for _ in range(k):\n        parts = list(map(int, sys.stdin.readline().strip().split()))\n        p, q, r = parts[0], parts[1], parts[2]\n        result = dijkstra(graph, p, q, r)\n        print(result)\n", "perturbed_sampled": ["import heapq from collections import defaultdict import sys def dijkstra(graph, start, end, mode): # mode: 0 for cost,  [(0, start)] visited = set() dist  node = heapq.heappop(pq) if node in visited: continue visited.add(node) if node == end: return current_dist for neighbor, cost, time in graph[node]: weight = cost  time new_dist = current_dist + weight if new_dist < dist[neighbor]: dist[neighbor] = new_dist heapq.heappush(pq,  True: line = sys.stdin.readline().strip() if  int(line) m = int(sys.stdin.readline().strip()) if n == 0 and m  defaultdict(list) for _ in range(n): parts = list(map(int, sys.stdin.readline().strip().split())) a, b,   graph[b].append((a, cost, time)) k = int(sys.stdin.readline().strip()) for _ in range(k): parts = list(map(int, sys.stdin.readline().strip().split())) p, q, r = parts[0], parts[1], parts[2] result = dijkstra(graph, p, q, r) print(result)"], "perturbed_original": ["from copy import deepcopy INF = 1000000000 def dj(s, e, r): d = [INF] * 100 done = [0] * 100 d[s] = 0 while True: v = -1 for i   d[i] < d[v]): v = i if v == e: return d[e]  in   costPre = [[[INF for  in L100] for i in L100] while True: E, V = map(int, raw_input().split()) cost = deepcopy(costPre) VL = range(V) if not E: break for i in range(E): a, b, c, d = map(int, raw_input().split()) a -= 1  cost[b][a][0] = c cost[a][b][1] = cost[b][a][1] = d k = input() for  r = map(int, raw_input().split()) p -= 1 q  r)"], "original_ll": -0.7970202565193176, "sampled_ll": -0.4925762414932251, "all_perturbed_sampled_ll": [-1.7121641635894775], "all_perturbed_original_ll": [-1.8884198665618896], "perturbed_sampled_ll": -1.7121641635894775, "perturbed_original_ll": -1.8884198665618896, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-2 0201: Wrought Gold Master\n// 2017.8.17 bal4u@uu\n// ??\u00a2?????????????????????????????\\????????????????????\u00a3?????????\n\n#include <stdio.h>\n#include <string.h>\n\n#define HSIZ 499\ntypedef struct { char *w; int k; } HASH;\nHASH hash[HSIZ + 5];\n\nint lookup(char *w)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\tif (tp->w != NULL) {\n\t\tint inc = *w + (*(w + 1) << 1);\n\t\twhile (1) {\n\t\t\tif (!strcmp(tp->w, w)) return tp->k;\n\t\t\ti += inc; if (i >= HSIZ) i -= HSIZ;\n\t\t\ttp = hash + i;\n\t\t\tif (tp->w == NULL) break;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint insert(char *w, int k)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\tif (tp->w != NULL) {\n\t\tint inc = *w + (*(w + 1) << 1);\n\t\twhile (1) {\n\t\t\tif (!strcmp(tp->w, w)) return -1;\n\t\t\ti += inc; if (i >= HSIZ) i -= HSIZ;\n\t\t\ttp = hash + i;\n\t\t\tif (tp->w == NULL) break;\n\t\t}\n\t}\n\ttp->w = w, tp->k = k;\n\treturn 0;\n}\n\ntypedef struct { char a[102]; int m, k, i[102]; } MONO;\nMONO mono[205]; int no;\n\nint combi(int a)\n{\n\tint i, k, c = -1;\n\tk = mono[a].k;\n\tif (k > 0) for (c = i = 0; i < k; i++) c += combi(mono[a].i[i]);\n\tif (c < 0 || (mono[a].m >= 0 && mono[a].m < c)) c = mono[a].m;\n\treturn c;\n}\n\nint main()\n{\n\tint i, j, k, N, M;\n\tchar b[102];\n\n\twhile (scanf(\"%d\", &N) == 1 && N) {\n\t\tmemset(hash, 0, sizeof(hash)), no = 0;\n\t\twhile (N-- > 0) {\n\t\t\tscanf(\"%s%d\", mono[no].a, &(mono[no].m));\n\t\t\tmono[no].k = 0; insert(mono[no].a, no);\n\t\t\tno++;\n\t\t}\n\t\tscanf(\"%d\", &M);\n\t\twhile (M--) {\n\t\t\tscanf(\"%s%d\", mono[no].a, &k);\n\t\t\tif ((i = lookup(mono[no].a)) < 0) insert(mono[no].a, no), mono[no].m = -1, i = no++;\n\t\t\tmono[i].k = k;\n\t\t\tfor (j = 0; j < mono[i].k; j++) scanf(\"%s\", b), mono[i].i[j] = lookup(b);\n\t\t}\n\t\tscanf(\"%s\", b);\n\t\tprintf(\"%d\\n\", combi(lookup(b)));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_ITEMS 100\n#define MAX_NAME 101\n\ntypedef struct {\n    char name[MAX_NAME];\n    int price;\n    int has_recipe;\n    int num_ingredients;\n    int ingredients[MAX_ITEMS];\n} Item;\n\nItem items[MAX_ITEMS];\nint n, m;\nint memo[MAX_ITEMS];\nint computed[MAX_ITEMS];\n\nint find_item(char *name) {\n    for (int i = 0; i < n; i++) {\n        if (strcmp(items[i].name, name) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint min_cost(int idx) {\n    if (computed[idx]) {\n        return memo[idx];\n    }\n    \n    computed[idx] = 1;\n    int buy_cost = items[idx].price;\n    \n    if (!items[idx].has_recipe) {\n        memo[idx] = buy_cost;\n        return buy_cost;\n    }\n    \n    int craft_cost = 0;\n    for (int i = 0; i < items[idx].num_ingredients; i++) {\n        craft_cost += min_cost(items[idx].ingredients[i]);\n    }\n    \n    memo[idx] = (buy_cost < craft_cost) ? buy_cost : craft_cost;\n    return memo[idx];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s %d\", items[i].name, &items[i].price);\n            items[i].has_recipe = 0;\n            items[i].num_ingredients = 0;\n            computed[i] = 0;\n        }\n        \n        scanf(\"%d\", &m);\n        for (int i = 0; i < m; i++) {\n            char output[MAX_NAME];\n            int k;\n            scanf(\"%s %d\", output, &k);\n            \n            int out_idx = find_item(output);\n            items[out_idx].has_recipe = 1;\n            items[out_idx].num_ingredients = k;\n            \n            for (int j = 0; j < k; j++) {\n                char ingredient[MAX_NAME];\n                scanf(\"%s\", ingredient);\n                int ing_idx = find_item(ingredient);\n                items[out_idx].ingredients[j] = ing_idx;\n            }\n        }\n        \n        char target[MAX_NAME];\n        scanf(\"%s\", target);\n        int target_idx = find_item(target);\n        \n        printf(\"%d\\n\", min_cost(target_idx));\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAX_ITEMS 100 #define MAX_NAME 101 typedef struct { char name[MAX_NAME]; int price;  ingredients[MAX_ITEMS]; } Item; Item items[MAX_ITEMS]; int n, m; int memo[MAX_ITEMS]; int computed[MAX_ITEMS]; int find_item(char *name) { for (int i = 0; i < n; i++) { if (strcmp(items[i].name, name) ==  } return -1; } int min_cost(int idx)  items[idx].price; if (!items[idx].has_recipe) { memo[idx] = buy_cost; return buy_cost; } int craft_cost = 0; for (int i = 0; i < items[idx].num_ingredients; i++) { craft_cost += min_cost(items[idx].ingredients[i]); } memo[idx] = (buy_cost < craft_cost) ? buy_cost : craft_cost; return memo[idx]; } int main() { while (1) { scanf(\"%d\", &n); if (n == 0) break; for (int i =  &items[i].price); items[i].has_recipe = 0; items[i].num_ingredients = 0; computed[i] = 0; } scanf(\"%d\", &m); for (int i = 0; i < m; i++) { char output[MAX_NAME]; int k; scanf(\"%s %d\",  find_item(output); items[out_idx].has_recipe = 1; items[out_idx].num_ingredients =   { char ingredient[MAX_NAME]; scanf(\"%s\", ingredient); int ing_idx = find_item(ingredient); items[out_idx].ingredients[j]  target_idx = find_item(target);  }"], "perturbed_original": ["// Aizu Vol-2 0201: Wrought Gold Master // 2017.8.17 bal4u@uu // ??\u00a2?????????????????????????????\\????????????????????\u00a3????????? #include <stdio.h> #include <string.h> #define HSIZ  *w; int k; } HASH; HASH hash[HSIZ + 5]; int lookup(char *w) { int i, l; HASH *tp; i = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ; tp = hash  NULL) { int inc = *w +   w)) return tp->k; i += inc; if (i >= HSIZ) i -= HSIZ; tp = hash + i; if (tp->w == NULL) break; } } return -1; } int insert(char *w, int k) { int i, l; HASH *tp; i = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107  { int inc = *w + (*(w + 1) << 1); while (1) { if (!strcmp(tp->w, w)) return -1; i += inc; if  + i; if (tp->w == NULL)  return 0; } typedef struct { char a[102]; int m, k, i[102]; } MONO; MONO mono[205]; int no;  i,   0) for (c = i =   < 0  mono[a].m < c)) c = mono[a].m; return c;  i, j, k, N, M; char b[102]; while (scanf(\"%d\", &N) == 1 && N) { memset(hash, 0,  (N-- > 0) { scanf(\"%s%d\", mono[no].a, &(mono[no].m)); mono[no].k = 0; insert(mono[no].a,  while (M--) { scanf(\"%s%d\", mono[no].a, &k); if ((i  no), mono[no].m = -1, i = no++; mono[i].k = k; for (j = 0; j < mono[i].k; j++) scanf(\"%s\", b), mono[i].i[j] = lookup(b); } scanf(\"%s\", b); printf(\"%d\\n\", combi(lookup(b))); } return 0; }"], "original_ll": -0.9538273811340332, "sampled_ll": -0.5253757834434509, "all_perturbed_sampled_ll": [-1.2081515789031982], "all_perturbed_original_ll": [-1.7908897399902344], "perturbed_sampled_ll": -1.2081515789031982, "perturbed_original_ll": -1.7908897399902344, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tprice = new HashMap<String,Integer>();\n\t\t\twhile(n-- > 0){\n\t\t\t\tprice.put(sc.next(),sc.nextInt());\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\tmap = new HashMap<String,ArrayList<String>>();\n\t\t\twhile(n-- > 0){\n\t\t\t\tString s = sc.next();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tmap.put(s,new ArrayList<String>());\n\t\t\t\twhile(m-- > 0){\n\t\t\t\t\tmap.get(s).add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = new HashMap<String,Integer>();\n\t\t\tSystem.out.println(minCost(sc.next()));\n\t\t}\n\t}\n\n\tprivate static HashMap<String,Integer> price;\n\tprivate static HashMap<String,ArrayList<String>> map;\n\tprivate static HashMap<String,Integer> dp;\n\n\tprivate static int minCost(String s){\n\t\tif(map.get(s) == null) return price.get(s);\n\t\tif(dp.get(s) != null) return dp.get(s);\n\n\t\tint sum = 0;\n\n\t\tfor(String tmp : map.get(s)){\n\t\t\tsum += minCost(tmp);\n\t\t}\n\n\t\tdp.put(s, price.get(s) == null ? sum : Math.min(sum,price.get(s)));\n\n\t\treturn dp.get(s);\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static Map<String, Integer> itemPrice;\n    static Map<String, List<String>> recipes;\n    static Map<String, Integer> memo;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            itemPrice = new HashMap<>();\n            recipes = new HashMap<>();\n            memo = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                int price = sc.nextInt();\n                itemPrice.put(name, price);\n            }\n            \n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                String output = sc.next();\n                int k = sc.nextInt();\n                List<String> inputs = new ArrayList<>();\n                for (int j = 0; j < k; j++) {\n                    inputs.add(sc.next());\n                }\n                recipes.put(output, inputs);\n            }\n            \n            String target = sc.next();\n            System.out.println(getMinCost(target));\n        }\n        \n        sc.close();\n    }\n    \n    static int getMinCost(String item) {\n        if (memo.containsKey(item)) {\n            return memo.get(item);\n        }\n        \n        int buyPrice = itemPrice.get(item);\n        int minCost = buyPrice;\n        \n        if (recipes.containsKey(item)) {\n            List<String> ingredients = recipes.get(item);\n            int craftCost = 0;\n            for (String ingredient : ingredients) {\n                craftCost += getMinCost(ingredient);\n            }\n            minCost = Math.min(minCost, craftCost);\n        }\n        \n        memo.put(item, minCost);\n        return minCost;\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  Map<String, List<String>> recipes; static Map<String, Integer> memo; public static void main(String[] args) { Scanner sc = new  n = sc.nextInt(); if (n == 0) break; itemPrice = new HashMap<>(); recipes = new HashMap<>(); memo = new HashMap<>(); for (int i = 0;  String name = sc.next(); int price = sc.nextInt(); itemPrice.put(name, price); } int m = sc.nextInt(); for  < m; i++) { String output = sc.next(); int k = sc.nextInt(); List<String> inputs =  = 0; j < k; j++) { inputs.add(sc.next()); } recipes.put(output, inputs); } String target = sc.next(); System.out.println(getMinCost(target)); } sc.close(); } static int getMinCost(String item) { if (memo.containsKey(item))  buyPrice  buyPrice; if (recipes.containsKey(item)) { List<String> ingredients = recipes.get(item); int craftCost = 0; for (String  += getMinCost(ingredient); }  memo.put(item, minCost); return minCost; } }"], "perturbed_original": ["import java.util.*; public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); while(true){ int n = sc.nextInt(); if(n == 0)   > 0){ String s = sc.next(); int m = sc.nextInt(); map.put(s,new ArrayList<String>()); while(m-- > 0){ map.get(s).add(sc.next()); } } dp = new HashMap<String,Integer>(); System.out.println(minCost(sc.next())); } } private static HashMap<String,Integer> price; private static HashMap<String,ArrayList<String>> map; private  int minCost(String s){ if(map.get(s) == null) return price.get(s);  int sum  map.get(s)){ sum += minCost(tmp); } dp.put(s, price.get(s) == null ? sum : Math.min(sum,price.get(s))); return dp.get(s); } }"], "original_ll": -0.6151684522628784, "sampled_ll": -0.4333738088607788, "all_perturbed_sampled_ll": [-1.544057846069336], "all_perturbed_original_ll": [-1.5089175701141357], "perturbed_sampled_ll": -1.544057846069336, "perturbed_original_ll": -1.5089175701141357, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n  count = int(input())\n  if count == 0: break \n  thing,money=[],[]\n  for i in range(count):\n    hoge = map(str,raw_input().split())\n    t = int(hoge[1])\n    thing.append(hoge[0])\n    money.append(t)\n  count = int(input())\n  if count == 0:\n    hoge = raw_input()\n    if hoge not in thing:\n      print 0\n      continue\n    t = thing.index(hoge)\n    print money[t]\n  else:\n    for i in range(count):\n      hoge = map(str,raw_input().split())\n      if hoge[0] not in thing:\n        print 0\n      t = int(hoge[1])\n      x,y = 2,0\n      for j in range(t):\n        r = thing.index(hoge[x])\n        y += money[r]\n        x+=1\n      e = thing.index(hoge[0])\n      money[e]= y\n    g = raw_input()\n    ans = thing.index(g)\n    print money[ans]", "sampled": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        # Read items and their prices\n        prices = {}\n        for _ in range(n):\n            line = input().split()\n            item_name = line[0]\n            price = int(line[1])\n            prices[item_name] = price\n        \n        # Read recipes\n        m = int(input())\n        recipes = {}\n        for _ in range(m):\n            line = input().split()\n            output_item = line[0]\n            k = int(line[1])\n            ingredients = line[2:2+k]\n            recipes[output_item] = ingredients\n        \n        # Read target item\n        target = input().strip()\n        \n        # Memoization for minimum cost\n        memo = {}\n        \n        def min_cost(item):\n            if item in memo:\n                return memo[item]\n            \n            # Option 1: Buy directly\n            buy_cost = prices[item]\n            \n            # Option 2: Craft using recipe (if available)\n            if item in recipes:\n                craft_cost = 0\n                for ingredient in recipes[item]:\n                    craft_cost += min_cost(ingredient)\n                result = min(buy_cost, craft_cost)\n            else:\n                result = buy_cost\n            \n            memo[item] = result\n            return result\n        \n        print(min_cost(target))\n\nsolve()\n", "perturbed_sampled": ["import sys from collections import defaultdict def solve(): while True: n = int(input())  # Read items and their prices prices = {} for  input().split() item_name = line[0] price = int(line[1]) prices[item_name] =  = int(input()) recipes =  = line[0] k = int(line[1])  ingredients # Read target item target = input().strip() # Memoization for minimum cost memo = {} def min_cost(item): if item in memo: return memo[item] # Option 1: Buy directly buy_cost = prices[item] # Option 2: Craft using recipe (if available) if item in  ingredient in recipes[item]: craft_cost += min_cost(ingredient) result = min(buy_cost, craft_cost)  = result return result print(min_cost(target)) solve()"], "perturbed_original": ["while True: count = int(input()) if  for i in range(count): hoge = map(str,raw_input().split()) t = int(hoge[1]) thing.append(hoge[0]) money.append(t) count = int(input()) if count == 0: hoge = raw_input() if hoge not in thing: print 0 continue t = thing.index(hoge) print money[t] else:  =  thing: print  = 2,0 for j in range(t): r = thing.index(hoge[x]) y += money[r] x+=1  g = raw_input() ans = thing.index(g) print money[ans]"], "original_ll": -1.1882965564727783, "sampled_ll": -0.7553865313529968, "all_perturbed_sampled_ll": [-2.325712203979492], "all_perturbed_original_ll": [-2.3093082904815674], "perturbed_sampled_ll": -2.325712203979492, "perturbed_original_ll": -2.3093082904815674, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_PRIME\t(1000000)\n#define IS_PRIME(n)\t(prime[j]==0?1:0)\n\nint prime[MAX_PRIME + 1];\nint fare[MAX_PRIME + 1];\nint fare_next[MAX_PRIME + 1];\n\n\nvoid make_prime(void)\n{\n    int i;\n    int j;\n    int n;\n    int c;\n    \n    for (i = 2; i * i <= MAX_PRIME; i++){\n        if (prime[i] == 0){\n            for (j = i * 2; j <= MAX_PRIME; j += i){\n\t\t\t\tprime[j] = 1;\n            }\n        }\n    }\n}\n\n\nint main(void)\n{\n\tint n, x;\n\tint price[30];\n\tint i, j, k;\n\t\n\tmake_prime();\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &n, &x);\n\t\tif (n == 0 && x == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &price[i]);\n\t\t}\n\t\t\n\t\tmemset(fare_next, 0, sizeof(fare_next));\n\t\tfare_next[0] = 1;\n\t\tfor (i = 0; i < n; i++){\n\n\t\t\tmemcpy(fare, fare_next, sizeof(fare_next));\n\t\t\tfor (j = price[i]; j <= x; j += price[i]){\n\t\t\t\tfor (k = 0; k <= x; k++){\n\t\t\t\t\tif (fare[k] != 0){\n\t\t\t\t\t\tif (k + j <= x){\n\t\t\t\t\t\t\tfare_next[k + j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemcpy(fare, fare_next, sizeof(fare_next));\n\t\t\n//for (i = 1; i <= x; i++){\n//\tprintf(\"[%d=%d]\", i, fare[i]);\n//}\n\n\t\tfor (i = x; i >= 1; i--){\n\t\t\tif (fare[i] != 0 && prime[i] == 0){\n\t\t\t\tprintf(\"%d\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == 0){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nbool isNotDivisibleByAny(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n, x;\n    \n    while (scanf(\"%d %d\", &n, &x) == 2) {\n        if (n == 0 && x == 0) break;\n        \n        int v[30];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &v[i]);\n        }\n        \n        bool *possible = (bool *)calloc(x + 1, sizeof(bool));\n        possible[0] = true;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = v[i]; j <= x; j++) {\n                if (possible[j - v[i]]) {\n                    possible[j] = true;\n                }\n            }\n        }\n        \n        int result = -1;\n        for (int i = x; i >= 1; i--) {\n            if (possible[i]) {\n                bool divisible = false;\n                for (int d = 2; d <= i; d++) {\n                    if (i % d == 0) {\n                        divisible = true;\n                        break;\n                    }\n                }\n                if (!divisible && i > 1) {\n                    result = i;\n                    break;\n                }\n            }\n        }\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n        \n        free(possible);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdbool.h> int gcd(int a, int  0) { int temp = b; b = a % b; a = temp; } return a; }   for (int i = 2; i * i <= num; i++) { if (num % i == 0) return false; } return true; } int main() { int n, x; while (scanf(\"%d %d\",  if (n  for (int i  i++) { scanf(\"%d\", &v[i]); } bool *possible = (bool *)calloc(x + 1, sizeof(bool)); possible[0] = true; for (int i = 0; i <  j = v[i]; j <= x; j++)  result = -1; for (int i  i--) { if (possible[i]) { bool divisible = false; for (int  i; d++) { if (i % d == 0) { divisible = true; break; } } if (!divisible && i > 1) { result = i; break; } } } if (result == -1) { printf(\"NA\\n\"); } else { printf(\"%d\\n\", result); } free(possible); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include  IS_PRIME(n) (prime[j]==0?1:0) int prime[MAX_PRIME + 1]; int fare[MAX_PRIME + 1]; int fare_next[MAX_PRIME + 1]; void make_prime(void) { int i; int j; int n; int c; for (i = 2; i * i <= MAX_PRIME; i++){ if (prime[i] == 0){ for (j = i * 2;  } } } } int  int price[30]; int i, j, k; make_prime(); while (1){ scanf(\"%d%d\", &n, &x); if (n == 0 &&  for (i = 0; i < n; i++){ scanf(\"%d\", &price[i]); } memset(fare_next, 0, sizeof(fare_next)); fare_next[0] = 1; for (i = 0;  fare_next, sizeof(fare_next)); for (j = price[i]; j <= x; j += price[i]){ for (k = 0; k <= x; k++){ if   + j] = 1; } } } } } memcpy(fare, fare_next, sizeof(fare_next)); //for (i =  // printf(\"[%d=%d]\", i, fare[i]); //} for (i =  if (fare[i] != 0 && prime[i] == 0){ printf(\"%d\\n\", i); break;  return (0); }"], "original_ll": -0.7649291753768921, "sampled_ll": -0.42027607560157776, "all_perturbed_sampled_ll": [-1.3172606229782104], "all_perturbed_original_ll": [-1.6121097803115845], "perturbed_sampled_ll": -1.3172606229782104, "perturbed_original_ll": -1.6121097803115845, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint MAX = 1000000;\n\t\tboolean[] prime = new boolean[MAX + 1];\n\t\tfor (int i = 4; i <= MAX; i += 2) {\n\t\t\tprime[i] = true;\n\t\t}\n\t\tfor (int i = 3; i <= Math.sqrt(MAX); i += 2) {\n\t\t\tif (!prime[i]) {\n\t\t\t\tfor (int j = i * 3; j <= MAX; j += i * 2) {\n\t\t\t\t\tprime[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] a = new int[n];\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tboolean[] f = new boolean[m + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint s = scanner.nextInt();\n\t\t\t\tmin = Math.min(s, min);\n\t\t\t\ta[i] = s;\n\t\t\t\tfor (int j = s; j <= m; j += s) {\n\t\t\t\t\tf[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\tint max = 0;\n\t\t\tfor (int i = min; i <= m; i++) {\n\t\t\t\tif (!f[i])\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (i - a[j] >= 0 && f[i - a[j]]) {\n\t\t\t\t\t\t\tf[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif (f[i] && !prime[i])\n\t\t\t\t\tmax = i;\n\t\t\t}\n\t\t\tSystem.out.println(max == 0 ? \"NA\" : max);\n\n\t\t}\n\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (n == 0 && x == 0) break;\n            \n            int[] prices = new int[n];\n            for (int i = 0; i < n; i++) {\n                prices[i] = sc.nextInt();\n            }\n            \n            // Find all possible sums up to budget x\n            boolean[] possible = new boolean[x + 1];\n            possible[0] = true;\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = prices[i]; j <= x; j++) {\n                    if (possible[j - prices[i]]) {\n                        possible[j] = true;\n                    }\n                }\n            }\n            \n            // Find the maximum sum that is not divisible by any number from 2 to itself-1\n            int result = -1;\n            for (int sum = x; sum >= 2; sum--) {\n                if (possible[sum] && isPrime(sum)) {\n                    result = sum;\n                    break;\n                }\n            }\n            \n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean isPrime(int num) {\n        if (num < 2) return false;\n        if (num == 2) return true;\n        if (num % 2 == 0) return false;\n        \n        for (int i = 3; i * i <= num; i += 2) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n}\n", "perturbed_sampled": ["import  public static void main(String[] args)  Scanner(System.in); while (true) { int n = sc.nextInt();  (n == 0 && x == 0) break; int[] prices = new int[n]; for (int i = 0; i < n; i++) { prices[i] = sc.nextInt(); } // Find all possible sums up to budget x boolean[] possible  possible[0] = true; for (int i = 0; i < n; i++)  prices[i]; j <= x; j++) {  possible[j] = true; } } } // Find the maximum sum that is not divisible by any number from 2 to itself-1 int   2; sum--) { if (possible[sum] && isPrime(sum)) { result = sum;  == -1) { System.out.println(\"NA\"); } else { System.out.println(result); } } sc.close();  num) { if (num < 2)  2) return true; if (num % 2 == 0) return false; for (int i = 3; i * i <= num; i += 2) { if (num % i ==  true; } }"], "perturbed_original": ["import java.io.IOException; import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String[] args) throws IOException { new Main().run(); } private void run() throws IOException { Scanner scanner = new Scanner(System.in);  prime =  (int i = 4; i <= MAX; i += 2) { prime[i] = true; } for (int i = 3;  {   j += i * 2) { prime[j] = true; } } } while (true) { int n =  if ((n | m) ==  new int[n]; int min = Integer.MAX_VALUE; boolean[] f = new boolean[m + 1]; for (int i = 0; i < n; i++) {  = Math.min(s, min); a[i] = s; for (int j =  += s) { f[j]  int max = 0; for (int i = min; i <= m; i++) { if (!f[i]) for (int j = 0; j < n; j++) { if (i - a[j] >= 0 && f[i - a[j]]) { f[i] = true; break; } }  = i; } System.out.println(max == 0  } }"], "original_ll": -0.5391613841056824, "sampled_ll": -0.4738403558731079, "all_perturbed_sampled_ll": [-1.6867749691009521], "all_perturbed_original_ll": [-1.5910378694534302], "perturbed_sampled_ll": -1.6867749691009521, "perturbed_original_ll": -1.5910378694534302, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from array import array\nPRIME_MAX = 1000001\nisPrime = array('b', [1] * PRIME_MAX)\nisPrime[0] = 0\nisPrime[1] = 0\nfor i in xrange(2, PRIME_MAX):\n\tif not isPrime[i]: continue\n\tfor j in xrange(i << 1, PRIME_MAX, i):\n\t\tisPrime[j] = 0\nwhile True:\n\tn, x = map(int, raw_input().split())\n\tif n == x == 0: break\n\tmenu = [input() for i in xrange(n)]\n\tresult = 0\n\texists = set()\n\texists.add(0)\n\tfor i in xrange(x + 1):\n\t\tif i in exists:\n\t\t\texists.remove(i)\n\t\t\tfor v in menu:\n\t\t\t\texists.add(i + v)\n\t\t\tif isPrime[i]:\n\t\t\t\tresult = i\n\tif result:\n\t\tprint result\n\telse:\n\t\tprint \"NA\"", "sampled": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(n, budget, prices):\n    # Dynamic programming to find all possible sums\n    possible = [False] * (budget + 1)\n    possible[0] = True\n    \n    for price in prices:\n        for total in range(budget, price - 1, -1):\n            if possible[total - price]:\n                possible[total] = True\n    \n    # Find the largest sum that is not divisible by all numbers from 2 to sum\n    for total in range(budget, 0, -1):\n        if not possible[total]:\n            continue\n        \n        # Check if total is not divisible by any number from 2 to total-1\n        is_prime_like = True\n        for divisor in range(2, int(math.sqrt(total)) + 1):\n            if total % divisor == 0:\n                is_prime_like = False\n                break\n        \n        if is_prime_like and total > 1:\n            return total\n    \n    return \"NA\"\n\ndef is_not_divisible_by_any(num):\n    # A number is not divisible by any number except 1 and itself if it's prime\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef solve2(n, budget, prices):\n    # Dynamic programming to find all possible sums\n    possible = set([0])\n    \n    for price in prices:\n        new_possible = set()\n        for p in possible:\n            amount = p\n            while amount + price <= budget:\n                amount += price\n                new_possible.add(amount)\n        possible.update(new_possible)\n    \n    # Find the largest sum that is prime\n    for total in range(budget, 1, -1):\n        if total in possible and is_not_divisible_by_any(total):\n            return total\n    \n    return \"NA\"\n\nwhile True:\n    line = input().split()\n    n, x = int(line[0]), int(line[1])\n    \n    if n == 0 and x == 0:\n        break\n    \n    prices = []\n    for _ in range(n):\n        prices.append(int(input()))\n    \n    print(solve2(n, x, prices))\n", "perturbed_sampled": ["import math from functools import reduce  a, b = b, a % b  prices): # Dynamic programming to find all possible sums possible  for total in range(budget, price - 1, -1): if possible[total - price]: possible[total] = True # Find the largest sum that is not divisible by all  for total in range(budget, 0, -1): if not possible[total]: continue # Check if total is not divisible by any number from 2 to total-1  in range(2, int(math.sqrt(total)) + 1): if total %  False break if is_prime_like  total return  number is not divisible by any number except 1 and itself if it's prime  False if num ==  % 2 == 0: return False for i in range(3, int(math.sqrt(num)) + 1, 2): if num % i == 0: return False return True def solve2(n, budget, prices): # Dynamic programming to find all possible sums possible  for p in possible: amount = p while amount + price <= budget: amount += price new_possible.add(amount) possible.update(new_possible) # Find the largest sum that is prime for total in range(budget,  possible and is_not_divisible_by_any(total):  True: line = input().split() n, x = int(line[0]), int(line[1]) if n == 0 and x == 0: break prices = [] for _ in range(n): prices.append(int(input())) print(solve2(n, x, prices))"], "perturbed_original": ["from array import array PRIME_MAX = 1000001 isPrime  isPrime[0] = 0 isPrime[1] = 0 for i in xrange(2, PRIME_MAX): if not  xrange(i << 1, PRIME_MAX, i): isPrime[j] = 0 while True: n, x = map(int, raw_input().split()) if n == x == 0:  = 0 exists = set() exists.add(0)  1): if i in exists: exists.remove(i) for v in menu: exists.add(i + v) if isPrime[i]: result = i if result: print result else: print \"NA\""], "original_ll": -0.9631505608558655, "sampled_ll": -0.6624335050582886, "all_perturbed_sampled_ll": [-1.8728322982788086], "all_perturbed_original_ll": [-1.9551286697387695], "perturbed_sampled_ll": -1.8728322982788086, "perturbed_original_ll": -1.9551286697387695, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\tint w,h,xd[]={1,0,-1},p,u[20][20];\n\tvoid ret(int x,int y){\n\t\tint i,s=x;\n\t\tif(h-1<=y)\n\t\t\tp++;\n\t\telse if(u[y][x]==2)\n\t\t\tret(x,y+2);\n\t\telse if(u[y][x]==0){\n\t\t\ty++;\n\t\t\tfor(i=0;i<3;i++){\n\t\t\t\tx=s+xd[i];\n\t\t\t\tif(x>=0&&x<=w-1){\n\t\t\t\t\tif(u[y][x]==2&&i==1)\n\t\t\t\t\t\tret(x,y+2);\n\t\t\t\t\telse if(u[y][x]==0)\n\t\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint main(){\n\t\tint i,j,x,y;\n\t\twhile(scanf(\"%d %d\",&w,&h),w||h){\n\t\t\tp=0;\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w-1;j++)\n\t\t\t\tscanf(\"%d \",&u[i][j]);\n\t\t\t\tscanf(\"%d\",&u[i][w-1]);\n\t\t\t}\n\t\t\tfor(i=0;i<w;i++){\n\t\t\t\tif(u[0][i]==0){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=0;\n\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t\telse if(u[0][i]==2){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=2;\n\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",p);\n\t\t}\n\t\treturn 0;\n\t}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint X, Y;\nint course[16][16];\nlong long dp[16][16];\n\nlong long countPaths() {\n    memset(dp, 0, sizeof(dp));\n    \n    // Initialize first row (y=1)\n    for (int x = 1; x <= X; x++) {\n        if (course[x][1] != 1) {  // Not an obstacle\n            dp[x][1] = 1;\n        }\n    }\n    \n    // Fill the dp table\n    for (int y = 1; y < Y; y++) {\n        for (int x = 1; x <= X; x++) {\n            if (dp[x][y] == 0) continue;\n            \n            if (course[x][y] == 2) {  // Jump platform\n                // Jump to (x, y+2)\n                if (y + 2 <= Y) {\n                    if (course[x][y+2] != 1) {\n                        dp[x][y+2] += dp[x][y];\n                    }\n                } else {\n                    // Jump goes beyond Y, count as reaching goal\n                    dp[x][Y] += dp[x][y];\n                }\n            } else {  // Normal cell (0)\n                // Move to (x-1, y+1), (x, y+1), (x+1, y+1)\n                for (int dx = -1; dx <= 1; dx++) {\n                    int nx = x + dx;\n                    int ny = y + 1;\n                    \n                    if (nx < 1 || nx > X) continue;\n                    \n                    if (ny > Y) {\n                        // Reached goal\n                        dp[x][Y] += dp[x][y];\n                    } else {\n                        if (course[nx][ny] == 1) {  // Obstacle\n                            continue;\n                        }\n                        if (course[nx][ny] == 2) {  // Jump platform\n                            // Can only enter jump platform from directly above (dx == 0)\n                            if (dx == 0) {\n                                dp[nx][ny] += dp[x][y];\n                            }\n                        } else {  // Normal cell\n                            dp[nx][ny] += dp[x][y];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Sum all paths that reached Y\n    long long total = 0;\n    for (int x = 1; x <= X; x++) {\n        total += dp[x][Y];\n    }\n    \n    return total;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &X, &Y);\n        if (X == 0 && Y == 0) break;\n        \n        for (int y = 1; y <= Y; y++) {\n            for (int x = 1; x <= X; x++) {\n                scanf(\"%d\", &course[x][y]);\n            }\n        }\n        \n        printf(\"%lld\\n\", countPaths());\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int X, Y; int course[16][16]; long long dp[16][16]; long long countPaths() { memset(dp, 0, sizeof(dp)); // Initialize first row (y=1)  x <= X; x++) { if (course[x][1]  an obstacle dp[x][1] = 1; } } // Fill the dp table for (int y = 1; y < Y; y++) { for (int x = 1; x <= X; x++) { if (dp[x][y] == 0) continue; if  Jump platform // Jump to (x, y+2) if  { if (course[x][y+2] !=  // Jump goes beyond Y, count as reaching goal dp[x][Y] += dp[x][y];  Normal cell (0) // Move to (x-1, y+1), (x, y+1), (x+1, y+1) for (int dx = -1; dx <= 1; dx++) { int  int ny  (nx < 1 || nx  > Y) { // Reached goal dp[x][Y] += dp[x][y]; }  1) { // Obstacle continue; } if (course[nx][ny] == 2) { // Jump platform // Can only enter jump platform from directly above (dx == 0) if (dx == 0) { dp[nx][ny] += dp[x][y]; } } else { // Normal cell dp[nx][ny] += dp[x][y]; } } } } } } // Sum all paths  (int x = 1; x <= X; x++)  return total; } int main() { while (1) {  (X == 0 && Y == 0) break; for (int y = 1; y <=  x  } } printf(\"%lld\\n\", countPaths()); } return 0; }"], "perturbed_original": ["#include<stdio.h> int w,h,xd[]={1,0,-1},p,u[20][20]; void ret(int x,int y){ int i,s=x; if(h-1<=y) p++; else if(u[y][x]==2) ret(x,y+2); else if(u[y][x]==0){ y++; for(i=0;i<3;i++){ x=s+xd[i]; if(x>=0&&x<=w-1){ if(u[y][x]==2&&i==1)  } } } int main(){  for(i=0;i<h;i++){ for(j=0;j<w-1;j++) scanf(\"%d \",&u[i][j]); scanf(\"%d\",&u[i][w-1]); }  } else if(u[0][i]==2){ x=i; y=2; ret(x,y); } } printf(\"%d\\n\",p); } return 0; }"], "original_ll": -0.9311797618865967, "sampled_ll": -0.5692476630210876, "all_perturbed_sampled_ll": [-1.6546822786331177], "all_perturbed_original_ll": [-1.7129602432250977], "perturbed_sampled_ll": -1.6546822786331177, "perturbed_original_ll": -1.7129602432250977, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int H,W;\n\tstatic int[][] field;\n\tstatic int[][] dp;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tW=cin.nextInt();\n\t\t\tH=cin.nextInt();\n\t\t\tif(W+H==0)break;\n\t\t\tfield=new int[H+2][W];\n\t\t\tdp=new int[H+2][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<W;i++){\n\t\t\t\tif(field[0][i]==0)dp[0][i]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]==0){\n\t\t\t\t\t\tif(i!=H-1){\n\t\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\t\tif(j+k<0||j+k>=W)continue;\n\t\t\t\t\t\t\t\tif(field[i+1][j+k]==1)continue;\n\t\t\t\t\t\t\t\tif(k!=0&&field[i+1][j+k]==2)continue;\n\t\t\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[i][j]==2){\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=H;i<H+2;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tans+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int X, Y;\n    static int[][] course;\n    static long[][] memo;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            X = sc.nextInt();\n            Y = sc.nextInt();\n            \n            if (X == 0 && Y == 0) break;\n            \n            course = new int[X + 1][Y + 1];\n            memo = new long[X + 1][Y + 1];\n            \n            for (int y = 1; y <= Y; y++) {\n                for (int x = 1; x <= X; x++) {\n                    course[x][y] = sc.nextInt();\n                    memo[x][y] = -1;\n                }\n            }\n            \n            long total = 0;\n            for (int x = 1; x <= X; x++) {\n                if (course[x][1] != 1) {\n                    total += dfs(x, 1);\n                }\n            }\n            \n            System.out.println(total);\n        }\n        \n        sc.close();\n    }\n    \n    static long dfs(int x, int y) {\n        if (y >= Y) {\n            return 1;\n        }\n        \n        if (memo[x][y] != -1) {\n            return memo[x][y];\n        }\n        \n        long count = 0;\n        \n        if (course[x][y] == 2) {\n            // Jump platform - skip to y+2\n            int nextY = y + 2;\n            if (nextY >= Y) {\n                count = 1;\n            } else if (course[x][nextY] != 1) {\n                if (course[x][nextY] == 2) {\n                    count = dfs(x, nextY);\n                } else {\n                    count = dfs(x, nextY);\n                }\n            }\n        } else {\n            // Normal movement to y+1\n            int nextY = y + 1;\n            \n            // Move to (x-1, y+1)\n            if (x - 1 >= 1 && course[x - 1][nextY] != 1) {\n                if (course[x - 1][nextY] == 2) {\n                    // Can't enter jump platform from diagonal\n                } else {\n                    count += dfs(x - 1, nextY);\n                }\n            }\n            \n            // Move to (x, y+1)\n            if (course[x][nextY] != 1) {\n                count += dfs(x, nextY);\n            }\n            \n            // Move to (x+1, y+1)\n            if (x + 1 <= X && course[x + 1][nextY] != 1) {\n                if (course[x + 1][nextY] == 2) {\n                    // Can't enter jump platform from diagonal\n                } else {\n                    count += dfs(x + 1, nextY);\n                }\n            }\n        }\n        \n        memo[x][y] = count;\n        return count;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int X, Y; static int[][] course; static long[][] memo; public static void  = new Scanner(System.in); while (true) { X = sc.nextInt(); Y = sc.nextInt(); if (X == 0 && Y == 0) break; course = new int[X +  + 1]; for (int y  y++) { for  course[x][y] = sc.nextInt();  long total = 0; for (int x = 1; x <= X; x++) {  total += dfs(x, 1); }  static long dfs(int x, int y) { if (y >= Y) { return 1; } if  memo[x][y]; } long count = 0; if (course[x][y] == 2) { //  y+2  2; if (nextY >= Y) { count = 1; } else if (course[x][nextY] != 1) {  count = dfs(x,  = dfs(x, nextY); } } } else { // Normal movement to y+1 int nextY = y + 1;  if (x - 1 >= 1  1) { if (course[x - 1][nextY] == 2) { // Can't enter jump platform from diagonal } else { count += dfs(x  // Move to (x, y+1) if (course[x][nextY] != 1)  } // Move to (x+1, y+1) if (x + 1 <= X &&  { if (course[x + 1][nextY] == 2) { // Can't enter jump platform from diagonal } else { count += dfs(x + 1, nextY); } } } memo[x][y] = count; return count; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { static int H,W; static int[][] field; static int[][] dp; public static void main(String[] args) { Scanner cin = new Scanner(System.in); for(;;){ W=cin.nextInt(); H=cin.nextInt(); if(W+H==0)break; field=new int[H+2][W]; dp=new int[H+2][W]; for(int i=0;i<H;i++){ for(int j=0;j<W;j++){ field[i][j]=cin.nextInt(); } }  i=0;i<H;i++){  k=-1;k<=1;k++){ if(j+k<0||j+k>=W)continue; if(field[i+1][j+k]==1)continue;  dp[i+1][j]+=dp[i][j]; } } else if(field[i][j]==2){ dp[i+2][j]+=dp[i][j]; } } } int ans=0; for(int  } System.out.println(ans); } } }"], "original_ll": -0.5766692757606506, "sampled_ll": -0.4504523277282715, "all_perturbed_sampled_ll": [-1.4800727367401123], "all_perturbed_original_ll": [-1.2733935117721558], "perturbed_sampled_ll": -1.4800727367401123, "perturbed_original_ll": -1.2733935117721558, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n\tX,Y = map(int,raw_input().split())\n\tif X == 0: break\n\tA = [[0]+map(int,raw_input().split())+[0] for i in range(Y)]\n\tS = [[0]*(X+2) for i in range(Y)]\n\tfor x in range(1,X+1): S[0][x] = 1 if A[0][x] != 1 else 0\n\tfor y in range(1,Y):\n\t\tfor x in range(1,X+1):\n\t\t\tif A[y][x] == 0:\n\t\t\t\tfor i in range(-1,2):\n\t\t\t\t\tS[y][x] += (S[y-1][x-i] if A[y-1][x-i] == 0 else 0)\n\t\t\tif A[y][x] == 2:\n\t\t\t\tS[y][x] += S[y-1][x-1]\n\t\t\t\tif y+2 < Y and A[y+2][x] != 1:\n\t\t\t\t\tS[y+2][x] = S[y][x]\n\tans = 0\n\tfor x in range(1,X+1):\n\t\tans += S[Y-1][x] + (S[Y-2][x] if A[Y-2][x] == 2 else 0)\n\tprint ans", "sampled": "import sys\n\ndef solve(X, Y, grid):\n    # dp[y][x] = number of ways to reach position (x, y)\n    dp = [[0] * X for _ in range(Y + 1)]\n    \n    # Initialize starting positions at y=0 (0-indexed, which is y=1 in problem)\n    for x in range(X):\n        if grid[0][x] != 1:  # not an obstacle\n            dp[0][x] = 1\n    \n    # Process each row\n    for y in range(Y):\n        for x in range(X):\n            if dp[y][x] == 0:\n                continue\n            \n            # Check if current position has a jump platform\n            if grid[y][x] == 2:\n                # Jump to (x, y+2)\n                target_y = y + 2\n                if target_y < Y:\n                    if grid[target_y][x] != 1:  # not an obstacle\n                        dp[target_y][x] += dp[y][x]\n                else:\n                    # Reached beyond Y, count as completion\n                    # We need to track completions separately\n                    pass\n            else:\n                # Normal movement to (x-1, y+1), (x, y+1), (x+1, y+1)\n                target_y = y + 1\n                if target_y < Y:\n                    # Move to (x-1, y+1)\n                    if x - 1 >= 0:\n                        if grid[target_y][x-1] == 2:\n                            # Can't enter jump platform from diagonal\n                            pass\n                        elif grid[target_y][x-1] != 1:\n                            dp[target_y][x-1] += dp[y][x]\n                    \n                    # Move to (x, y+1)\n                    if grid[target_y][x] != 1:\n                        dp[target_y][x] += dp[y][x]\n                    \n                    # Move to (x+1, y+1)\n                    if x + 1 < X:\n                        if grid[target_y][x+1] == 2:\n                            # Can't enter jump platform from diagonal\n                            pass\n                        elif grid[target_y][x+1] != 1:\n                            dp[target_y][x+1] += dp[y][x]\n    \n    # Count paths that reach y >= Y\n    total = 0\n    \n    # Add paths from y = Y-1\n    for x in range(X):\n        if dp[Y-1][x] > 0:\n            if grid[Y-1][x] == 2:\n                # Jump from Y-1 goes to Y+1, which is >= Y\n                total += dp[Y-1][x]\n            else:\n                # Normal movement from Y-1 goes to Y, which is >= Y\n                total += dp[Y-1][x]\n    \n    # Add paths from y = Y-2 that jump\n    if Y >= 2:\n        for x in range(X):\n            if dp[Y-2][x] > 0 and grid[Y-2][x] == 2:\n                # Jump from Y-2 goes to Y, which is >= Y\n                # But we need to check if this was already counted\n                # Actually, when we process Y-2, we add to dp[Y][x] if Y < Y, which is false\n                # So we need to handle this separately\n                pass\n    \n    return total\n\n# Read input\nwhile True:\n    line = input().split()\n    X, Y = int(line[0]), int(line[1])\n    \n    if X == 0 and Y == 0:\n        break\n    \n    grid = []\n    for y in range(Y):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Re-implement with better logic\n    dp = [[0] * X for _ in range(Y + 2)]\n    \n    # Initialize\n    for x in range(X):\n        if grid[0][x] != 1:\n            dp[0][x] = 1\n    \n    for y in range(Y + 1):\n        for x in range(X):\n            if dp[y][x] == 0:\n                continue\n            \n            if y >= Y:\n                continue\n            \n            if grid[y][x] == 2:\n                # Jump\n                target_y = y + 2\n                if target_y <= Y:\n                    dp[target_y][x] += dp[y][x]\n            else:\n                # Normal move\n                target_y = y + 1\n                if target_y <= Y:\n                    for dx in [-1, 0, 1]:\n                        nx = x + dx\n                        if 0 <= nx < X:\n                            if target_y < Y:\n                                if grid[target_y][nx] == 2 and dx != 0:\n                                    continue\n                                if grid[target_y][nx] != 1:\n                                    dp[target_y][nx] += dp[y][x]\n                            else:\n                                dp[target_y][nx] += dp[y][x]\n    \n    result = sum(dp[Y])\n    print(result)\n", "perturbed_sampled": ["import sys def solve(X, Y, grid): # dp[y][x] = number of ways to  = [[0] * X  1)]  y=0 (0-indexed, which is y=1 in problem) for x in range(X): if grid[0][x] != 1: # not an obstacle dp[0][x] = 1 # Process each row for y in range(Y):  # Check if current position has a jump platform if grid[y][x] == 2: #  if target_y < Y: if grid[target_y][x] != 1: # not an obstacle  Reached  track completions separately pass else:  y+1), (x,  y + 1 if target_y <  y+1) if x - 1 >= 0: if grid[target_y][x-1] == 2: # Can't enter jump platform from diagonal pass elif  dp[y][x] # Move to (x, y+1) if grid[target_y][x] != 1: dp[target_y][x] += dp[y][x] # Move to (x+1, y+1) if x + 1 < X: if grid[target_y][x+1] == 2: # Can't enter jump platform from diagonal pass elif grid[target_y][x+1]  # Count paths that reach y >= Y total = 0 # Add paths from y = Y-1 for x in range(X): if dp[Y-1][x] > 0: if grid[Y-1][x] == 2: #  from Y-1 goes to Y, which is >= Y total += dp[Y-1][x] #  Y-2 that jump if Y >= 2: for x in range(X): if dp[Y-2][x] > 0 and grid[Y-2][x] == 2: # Jump from Y-2 goes to Y, which is >= Y # But we  was already counted # Actually, when we process Y-2, we add to dp[Y][x] if Y < Y, which is false # So we need to   True: line = input().split() X, Y = int(line[0]), int(line[1]) if X == 0 and  = [] for y in  grid.append(row) # Re-implement with better logic dp = [[0] * X  2)] # Initialize for x in range(X): if grid[0][x] != 1: dp[0][x] = 1 for y in range(Y + 1): for x in range(X): if dp[y][x] == 0: continue if y >= Y: continue if  target_y = y + 2 if target_y <= Y: dp[target_y][x] += dp[y][x] else: # Normal move target_y = y + 1 if target_y <= Y: for dx in [-1, 0, 1]: nx = x +  < X: if  == 2 and dx != 0: continue if grid[target_y][nx] !=  dp[target_y][nx] += dp[y][x] result = sum(dp[Y]) print(result)"], "perturbed_original": ["while 1: X,Y = map(int,raw_input().split()) if X ==  S = [[0]*(X+2) for i in range(Y)] for x in range(1,X+1): S[0][x] = 1  0 for y in range(1,Y): for x in range(1,X+1): if A[y][x] == 0: for i in range(-1,2): S[y][x] += (S[y-1][x-i] if A[y-1][x-i] == 0 else 0) if A[y][x] == 2: S[y][x]  ans = 0 for x in range(1,X+1): ans += S[Y-1][x] + (S[Y-2][x] if A[Y-2][x] == 2 else 0) print ans"], "original_ll": -0.7626677751541138, "sampled_ll": -0.689586877822876, "all_perturbed_sampled_ll": [-1.7756872177124023], "all_perturbed_original_ll": [-1.1229121685028076], "perturbed_sampled_ll": -1.7756872177124023, "perturbed_original_ll": -1.1229121685028076, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-8)\n\ntypedef struct {\n\tdouble x,y;\n\tdouble angle;\n\tint r;\n\tint v;\n\tint arrive;\n} ufo_t;\n\nint N;\nufo_t ufo[100];\nint R;\n\ndouble get_dist(double mx,double my,double x,double y) {\n\treturn fabs(my*x-mx*y)/sqrt(my*my+mx*mx);\n}\n\nint main(void) {\n\tint i;\n\tint target;\n\tdouble target_dist;\n\tint count;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&R,&N);\n\t\tif(R==0 && N==0)break;\n\t\tfor(i=0;i<N;i++) {\n\t\t\tscanf(\"%lf%lf%d%d\",\n\t\t\t\t&ufo[i].x,&ufo[i].y,&ufo[i].r,&ufo[i].v);\n\t\t\tufo[i].arrive=1;\n\t\t\tufo[i].angle=atan2(ufo[i].y,ufo[i].x);\n\t\t}\n\t\ttarget=0;\n\t\twhile(target>=0) {\n\t\t\tfor(i=0;i<N;i++) {\n\t\t\t\tif(R+EPS<sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y)) {\n\t\t\t\t\tdouble prev_x,prev_y;\n\t\t\t\t\tprev_x=ufo[i].x;\n\t\t\t\t\tprev_y=ufo[i].y;\n\t\t\t\t\tufo[i].x-=ufo[i].v*cos(ufo[i].angle);\n\t\t\t\t\tufo[i].y-=ufo[i].v*sin(ufo[i].angle);\n\t\t\t\t\tif(prev_x*ufo[i].x<0)ufo[i].x=0;\n\t\t\t\t\tif(prev_y*ufo[i].y<0)ufo[i].y=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget=-1;\n\t\t\ttarget_dist=1000*1000;\n\t\t\tfor(i=0;i<N;i++) {\n\t\t\t\tdouble dist;\n\t\t\t\tif(!ufo[i].arrive)continue;\n\t\t\t\tdist=sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y);\n\t\t\t\tif(dist<target_dist+EPS && R+EPS<dist) {\n\t\t\t\t\ttarget_dist=dist;\n\t\t\t\t\ttarget=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(target<0)break;\n\t\t\tfor(i=0;i<N;i++) {\n\t\t\t\tif(sqrt(ufo[i].x*ufo[i].x+\n\t\t\t\t\tufo[i].y*ufo[i].y)<R+EPS)continue;\n\t\t\t\tif(get_dist(ufo[target].x,ufo[target].y,\n\t\t\t\t\t\tufo[i].x,ufo[i].y)<ufo[i].r+EPS &&\n\t\t\t\t\t\tufo[target].x*ufo[i].x>=0 &&\n\t\t\t\t\t\tufo[target].y*ufo[i].y>=0) {\n\t\t\t\t\tufo[i].arrive=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount=0;\n\t\tfor(i=0;i<N;i++) {\n\t\t\tif(ufo[i].arrive)count++;\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n#define INF 1e9\n\ntypedef struct {\n    double x, y;\n    double r;\n    double v;\n    bool destroyed;\n    bool entered;\n} UFO;\n\ndouble distance(double x, double y) {\n    return sqrt(x * x + y * y);\n}\n\ndouble distancePointToLine(double px, double py, double lx, double ly) {\n    if (lx == 0 && ly == 0) return INF;\n    double dot = px * lx + py * ly;\n    if (dot < 0) return INF;\n    double len = sqrt(lx * lx + ly * ly);\n    return fabs(px * ly - py * lx) / len;\n}\n\nint main() {\n    int R, N;\n    \n    while (scanf(\"%d %d\", &R, &N) == 2) {\n        if (R == 0 && N == 0) break;\n        \n        UFO ufos[MAX_N];\n        for (int i = 0; i < N; i++) {\n            scanf(\"%lf %lf %lf %lf\", &ufos[i].x, &ufos[i].y, &ufos[i].r, &ufos[i].v);\n            ufos[i].destroyed = false;\n            ufos[i].entered = false;\n        }\n        \n        int time = 1;\n        while (true) {\n            bool any_outside = false;\n            for (int i = 0; i < N; i++) {\n                if (ufos[i].destroyed || ufos[i].entered) continue;\n                \n                double dx = -ufos[i].x;\n                double dy = -ufos[i].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double curr_x = ufos[i].x + dx * ufos[i].v * time;\n                double curr_y = ufos[i].y + dy * ufos[i].v * time;\n                double dist = distance(curr_x, curr_y);\n                \n                if (dist > R) {\n                    any_outside = true;\n                    break;\n                }\n            }\n            \n            if (!any_outside) break;\n            \n            int target = -1;\n            double min_dist = INF;\n            \n            for (int i = 0; i < N; i++) {\n                if (ufos[i].destroyed || ufos[i].entered) continue;\n                \n                double dx = -ufos[i].x;\n                double dy = -ufos[i].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double curr_x = ufos[i].x + dx * ufos[i].v * time;\n                double curr_y = ufos[i].y + dy * ufos[i].v * time;\n                double dist = distance(curr_x, curr_y);\n                \n                if (dist > R && dist < min_dist) {\n                    min_dist = dist;\n                    target = i;\n                }\n            }\n            \n            if (target != -1) {\n                double dx = -ufos[target].x;\n                double dy = -ufos[target].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double target_x = ufos[target].x + dx * ufos[target].v * time;\n                double target_y = ufos[target].y + dy * ufos[target].v * time;\n                \n                for (int i = 0; i < N; i++) {\n                    if (ufos[i].destroyed || ufos[i].entered) continue;\n                    \n                    double dx2 = -ufos[i].x;\n                    double dy2 = -ufos[i].y;\n                    double len2 = sqrt(dx2 * dx2 + dy2 * dy2);\n                    dx2 /= len2;\n                    dy2 /= len2;\n                    \n                    double curr_x = ufos[i].x + dx2 * ufos[i].v * time;\n                    double curr_y = ufos[i].y + dy2 * ufos[i].v * time;\n                    \n                    double dist_to_laser = distancePointToLine(curr_x, curr_y, target_x, target_y);\n                    \n                    if (dist_to_laser <= ufos[i].r) {\n                        ufos[i].destroyed = true;\n                    }\n                }\n            }\n            \n            for (int i = 0; i < N; i++) {\n                if (ufos[i].destroyed || ufos[i].entered) continue;\n                \n                double dx = -ufos[i].x;\n                double dy = -ufos[i].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double curr_x = ufos[i].x + dx * ufos[i].v * time;\n                double curr_y = ufos[i].y + dy * ufos[i].v * time;\n                double dist = distance(curr_x, curr_y);\n                \n                if (dist <= R) {\n                    ufos[i].entered = true;\n                }\n            }\n            \n            time++;\n        }\n        \n        int count = 0;\n        for (int i = 0; i < N; i++) {\n            if (ufos[i].entered) count++;\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #include <stdbool.h> #define MAX_N 100 #define INF 1e9 typedef struct { double x, y;  destroyed; bool entered;   *  double py, double lx, double ly) {  ly == 0) return INF; double dot = px * lx + py * ly; if (dot < 0) return INF; double len = sqrt(lx * lx + ly * ly); return fabs(px * ly - py * lx) / len;  R, N; while (scanf(\"%d %d\", &R, &N) == 2) { if (R == 0 &&  = 0;  scanf(\"%lf %lf  &ufos[i].v); ufos[i].destroyed = false; ufos[i].entered = false; } int time =   i = 0; i < N; i++) { if (ufos[i].destroyed  = -ufos[i].x; double dy = -ufos[i].y; double len = sqrt(dx * dx + dy * dy); dx /= len; dy /= len; double curr_x = ufos[i].x + dx * ufos[i].v * time; double curr_y = ufos[i].y + dy * ufos[i].v * time; double dist = distance(curr_x, curr_y); if (dist > R) { any_outside = true; break; } } if (!any_outside) break; int target = -1; double min_dist = INF; for  < N; i++)  continue; double dx = -ufos[i].x; double dy = -ufos[i].y; double len = sqrt(dx * dx + dy * dy);  len; double  * ufos[i].v * time; double curr_y = ufos[i].y + dy * ufos[i].v * time; double dist = distance(curr_x, curr_y); if (dist > R && dist < min_dist) { min_dist = dist; target = i; } } if (target != -1) { double   sqrt(dx * dx + dy *  * ufos[target].v * time; double target_y = ufos[target].y + dy * ufos[target].v * time; for (int i = 0; i < N; i++)  continue; double dx2 = -ufos[i].x; double dy2 = -ufos[i].y;  dx2 + dy2 * dy2); dx2 /= len2; dy2 /= len2; double curr_x = ufos[i].x + dx2 * ufos[i].v * time; double curr_y = ufos[i].y + dy2  target_x, target_y); if (dist_to_laser <= ufos[i].r) { ufos[i].destroyed = true; }  = 0; i < N; i++) { if (ufos[i].destroyed || ufos[i].entered) continue; double dx = -ufos[i].x; double  = sqrt(dx * dx + dy  dy /= len; double  double curr_y = ufos[i].y + dy * ufos[i].v * time; double dist = distance(curr_x, curr_y); if (dist <= R) { ufos[i].entered = true; } } time++; } int count = 0; for (int i = 0; i  (ufos[i].entered) count++; } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> #define EPS (1e-8) typedef   int arrive; } ufo_t; int N; ufo_t  mx,double my,double x,double y) { return fabs(my*x-mx*y)/sqrt(my*my+mx*mx); } int main(void) { int i; int target; double target_dist; int count; while(1) {  { scanf(\"%lf%lf%d%d\", &ufo[i].x,&ufo[i].y,&ufo[i].r,&ufo[i].v); ufo[i].arrive=1; ufo[i].angle=atan2(ufo[i].y,ufo[i].x); } target=0; while(target>=0) { for(i=0;i<N;i++) { if(R+EPS<sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y)) { double prev_x,prev_y; prev_x=ufo[i].x; prev_y=ufo[i].y; ufo[i].x-=ufo[i].v*cos(ufo[i].angle); ufo[i].y-=ufo[i].v*sin(ufo[i].angle); if(prev_x*ufo[i].x<0)ufo[i].x=0; if(prev_y*ufo[i].y<0)ufo[i].y=0; } } target=-1; target_dist=1000*1000; for(i=0;i<N;i++) { double  R+EPS<dist) { target_dist=dist; target=i;  if(sqrt(ufo[i].x*ufo[i].x+ ufo[i].y*ufo[i].y)<R+EPS)continue; if(get_dist(ufo[target].x,ufo[target].y, ufo[i].x,ufo[i].y)<ufo[i].r+EPS && ufo[target].x*ufo[i].x>=0 && ufo[target].y*ufo[i].y>=0) { ufo[i].arrive=0; } }  } printf(\"%d\\n\",count); } return 0; }"], "original_ll": -0.6870587468147278, "sampled_ll": -0.29976174235343933, "all_perturbed_sampled_ll": [-1.1316617727279663], "all_perturbed_original_ll": [-1.2245911359786987], "perturbed_sampled_ll": -1.1316617727279663, "perturbed_original_ll": -1.2245911359786987, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint r, n;\n\t\twhile ((r = s.nextInt()) != 0 && (n = s.nextInt()) != 0) {\n\t\t\tdouble[][] ufo = new double[n][6];  // x, y, r, v(, dis, fin_step)\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tufo[i][j] = s.nextInt();\n\t\t\t\tufo[i][4] = Math.hypot(ufo[i][0], ufo[i][1]); // \u008b\u0097\u0097\u00a3\n\t\t\t\tufo[i][5] = Math.floor((Math.abs(ufo[i][4]) - r) / ufo[i][3]); // \u0090N\u0093\u00fc\u008e\u009e\u008a\u00d4\n\t\t\t}\n\n\t\t\tint[] st = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\tst[i] = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) { // step\t\t\t\t\n\t\t\t\t // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\u0082\u00f0\u0092T\u0082\u00b5\u0081A\u0093\u00af\u008e\u009e\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00b5\u0082\u00bdUFO\u0082\u00c9\u0083}\u0081[\u0083N\n\t\t\t\tint near = -1;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fcor\u008c\u0082\u0092\u00c4\n\t\t\t\t\tif (ufo[j][5] < i) st[j] = 1;  // \u0090N\u0093\u00fc\u0082\u00b5\u0082\u00bd\n\t\t\t\t\telse if (near == -1 || ufo[near][4] > ufo[j][4])\n\t\t\t\t\t\tnear = j; // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\n\t\t\t\t}\n\t\t\t\tif (near == -1) break;\n\t\t\t\tdouble x0 = ufo[near][0]; // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\n\t\t\t\tdouble y0 = ufo[near][1];\n\n\t\t\t\t// UFO\u0082\u00f0\u008c\u0082\u0092\u00c4\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00a9\u008c\u0082\u0092\u00c4\u008f\u00f3\u0091\u00d4\u0082\u00c8\u0082\u00e7\u0083X\u0083\u008b\u0081[\n\t\t\t\t\tdouble x1 = ufo[j][0];\n\t\t\t\t\tdouble y1 = ufo[j][1];\n\t\t\t\t\t\n\t\t\t\t\tif (y0 == 0) {\n\t\t\t\t\t\tif ((x0 >= 0 && x1 >= 0) || (x0 < 0 && x1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab\n\t\t\t\t\t\t\tif (Math.abs(y1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4\n\t\t\t\t\t} else if (x0 == 0) {\n\t\t\t\t\t\tif ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab\n\t\t\t\t\t\t\tif (Math.abs(x1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdouble a = y0 / x0; // \u008cX\u0082\u00ab\n\t\t\t\t\t\tif ((x0 >= 0 && x1 >= 0) || (x0 < 0 && x1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab\n\t\t\t\t\t\t\tif ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 < 0))\n\t\t\t\t\t\t\t\tif (Math.abs(y1 - a * x1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < n; j++) { // UFO\u0088\u00da\u0093\u00ae\n\t\t\t\t\tif (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00a9\u008c\u0082\u0092\u00c4\u008f\u00f3\u0091\u00d4\u0082\u00c8\u0082\u00e7\u0083X\u0083\u008b\u0081[\n\t\t\t\t\tufo[j][4] -= ufo[j][3];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (st[j] == 1) sum++;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class UFO {\n        double x, y;\n        double r;\n        double v;\n        boolean destroyed;\n        int id;\n        \n        UFO(double x, double y, double r, double v, int id) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n            this.v = v;\n            this.destroyed = false;\n            this.id = id;\n        }\n        \n        double distanceFromOrigin() {\n            return Math.sqrt(x * x + y * y);\n        }\n        \n        void moveTowardsOrigin(double time) {\n            if (destroyed) return;\n            double dist = distanceFromOrigin();\n            if (dist == 0) return;\n            double moveAmount = v * time;\n            if (moveAmount >= dist) {\n                x = 0;\n                y = 0;\n            } else {\n                double ratio = moveAmount / dist;\n                x -= x * ratio;\n                y -= y * ratio;\n            }\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            int R = Integer.parseInt(parts[0]);\n            int N = Integer.parseInt(parts[1]);\n            \n            if (R == 0 && N == 0) break;\n            \n            List<UFO> ufos = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                line = br.readLine();\n                parts = line.trim().split(\"\\\\s+\");\n                double x0 = Double.parseDouble(parts[0]);\n                double y0 = Double.parseDouble(parts[1]);\n                double r = Double.parseDouble(parts[2]);\n                double v = Double.parseDouble(parts[3]);\n                ufos.add(new UFO(x0, y0, r, v, i));\n            }\n            \n            int time = 1;\n            while (true) {\n                // Move all UFOs\n                for (UFO ufo : ufos) {\n                    ufo.moveTowardsOrigin(1);\n                }\n                \n                // Find closest UFO outside R\n                UFO target = null;\n                double minDist = Double.MAX_VALUE;\n                \n                for (UFO ufo : ufos) {\n                    if (!ufo.destroyed && ufo.distanceFromOrigin() > R) {\n                        double dist = ufo.distanceFromOrigin();\n                        if (dist < minDist) {\n                            minDist = dist;\n                            target = ufo;\n                        }\n                    }\n                }\n                \n                if (target == null) break;\n                \n                // Shoot laser through target\n                double tx = target.x;\n                double ty = target.y;\n                \n                for (UFO ufo : ufos) {\n                    if (!ufo.destroyed && ufo.distanceFromOrigin() > R) {\n                        if (laserHits(tx, ty, ufo)) {\n                            ufo.destroyed = true;\n                        }\n                    }\n                }\n                \n                time++;\n                if (time > 10000) break;\n            }\n            \n            int count = 0;\n            for (UFO ufo : ufos) {\n                if (!ufo.destroyed) {\n                    count++;\n                }\n            }\n            \n            System.out.println(count);\n        }\n    }\n    \n    static boolean laserHits(double lx, double ly, UFO ufo) {\n        // Laser goes from origin through (lx, ly)\n        // Check if it intersects circle at (ufo.x, ufo.y) with radius ufo.r\n        \n        double laserLen = Math.sqrt(lx * lx + ly * ly);\n        if (laserLen == 0) return false;\n        \n        // Normalize laser direction\n        double ldx = lx / laserLen;\n        double ldy = ly / laserLen;\n        \n        // Distance from ufo center to laser line\n        double dist = Math.abs(ldy * ufo.x - ldx * ufo.y);\n        \n        if (dist > ufo.r) return false;\n        \n        // Check if UFO is in the direction of the laser\n        double dot = ufo.x * ldx + ufo.y * ldy;\n        return dot > 0;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class  { double x, y; double r; double v; boolean destroyed; int id; UFO(double x, double y, double r, double v, int id) { this.x = x; this.y = y; this.r  this.destroyed = false;  * x + y * y); } void moveTowardsOrigin(double time) { if (destroyed) return; double  == 0) return; double moveAmount = v *  { x = 0; y = 0;  = moveAmount / dist; x -= x * ratio; y -= y * ratio; } } } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String  != null) { String[] parts = line.trim().split(\"\\\\s+\"); int R = Integer.parseInt(parts[0]); int N = Integer.parseInt(parts[1]); if (R == 0 && N == 0) break; List<UFO>  (int i = 0; i < N; i++) { line = br.readLine(); parts = line.trim().split(\"\\\\s+\"); double x0 = Double.parseDouble(parts[0]); double y0 = Double.parseDouble(parts[1]); double r = Double.parseDouble(parts[2]); double v = Double.parseDouble(parts[3]); ufos.add(new UFO(x0, y0, r, v, i)); } int time =  Move all UFOs for  UFO target  Double.MAX_VALUE; for (UFO ufo : ufos) { if (!ufo.destroyed && ufo.distanceFromOrigin() > R) { double dist = ufo.distanceFromOrigin(); if (dist < minDist)  } if (target ==  through target  (UFO ufo : ufos) { if (!ufo.destroyed && ufo.distanceFromOrigin() > R) { if (laserHits(tx,  true; } } }  break; } int count = 0; for (UFO ufo : ufos) { if (!ufo.destroyed) { count++; }  boolean laserHits(double lx, double ly, UFO ufo) { // Laser goes from origin through (lx, ly) // Check if it intersects circle at (ufo.x, ufo.y)  = Math.sqrt(lx * lx + ly * ly); if (laserLen == 0) return false;  ldx = lx  ly / laserLen; // Distance from ufo center to laser line double  - ldx * ufo.y); if (dist > ufo.r) return false; // Check if UFO  the laser double dot = ufo.x * ldx + ufo.y * ldy; return dot > 0; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner s = new Scanner(System.in); int r, n; while ((r = s.nextInt()) != 0 && (n = s.nextInt()) != 0) {  // x, y,   for (int j =  ufo[i][j]  ufo[i][1]); // \u008b\u0097\u0097\u00a3 ufo[i][5] = Math.floor((Math.abs(ufo[i][4]) - r)  int[] st = new int[n]; for (int i = 0; i < n; i++) st[i] = 0; for (int i = 0; i < n; i++) { // step // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\u0082\u00f0\u0092T\u0082\u00b5\u0081A\u0093\u00af\u008e\u009e\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00b5\u0082\u00bdUFO\u0082\u00c9\u0083}\u0081[\u0083N int near = -1; for (int j = 0; j < n; j++) { if (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fcor\u008c\u0082\u0092\u00c4 if (ufo[j][5] < i) st[j] = 1; // \u0090N\u0093\u00fc\u0082\u00b5\u0082\u00bd else if (near == -1 || ufo[near][4] > ufo[j][4]) near = j; // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO } if (near == -1) break; double x0 = ufo[near][0]; // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO double y0 = ufo[near][1]; // UFO\u0082\u00f0\u008c\u0082\u0092\u00c4 for (int j = 0; j < n; j++) {  //  double y1 = ufo[j][1];  && x1 >= 0) || (x0 < 0 && x1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab if (Math.abs(y1) <= r) st[j]  0) { if ((y0 >= 0 && y1 >= 0) || (y0 <  // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab if  =  if ((x0 >= 0 && x1  0 && x1 <  >= 0 && y1 >= 0) || (y0 < 0 && y1 < 0)) if (Math.abs(y1 - a *  2; // \u008c\u0082\u0092\u00c4 } } for (int j = 0; j < n; j++) { // UFO\u0088\u00da\u0093\u00ae if (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00a9\u008c\u0082\u0092\u00c4\u008f\u00f3\u0091\u00d4\u0082\u00c8\u0082\u00e7\u0083X\u0083\u008b\u0081[ ufo[j][4] -= ufo[j][3]; } } int sum = 0;  j < n; j++) if (st[j] == 1) sum++; System.out.println(sum); } } }"], "original_ll": -0.8751683831214905, "sampled_ll": -0.5033857226371765, "all_perturbed_sampled_ll": [-1.5314300060272217], "all_perturbed_original_ll": [-1.6016745567321777], "perturbed_sampled_ll": -1.5314300060272217, "perturbed_original_ll": -1.6016745567321777, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from math import sqrt\nwhile 1:\n    R, N = map(int, raw_input().split())\n    if R == N == 0:\n        break\n    P = []\n    for i in xrange(N):\n        x, y, r, v = map(int, raw_input().split())\n        P.append((sqrt(x**2+y**2), x**2+y**2, x, y, r, v, i))\n    kill = [0]*N\n    ans = 0\n    for t in xrange(1, N+1):\n        j = None; mi = 10**9\n        for l, ll, x, y, r, v, i in P:\n            if kill[i]:\n                continue\n            if ll < (R + t*v)**2:\n                kill[i] = 1\n                ans += 1\n\n            if not kill[i] and l - t*v < mi:\n                mi = l - t*v\n                j = i\n        if j is None:\n            break\n        l0, ll0, x0, y0, r0, v0, j = P[j]\n        for l, ll, x, y, r, v, i in P:\n            if kill[i]:\n                continue\n            if (l - t*v)*abs(x0*y - x*y0) < r*l*l0 + 1e-8:\n                kill[i] = 1\n    print ans", "sampled": "import math\n\ndef distance(x, y):\n    return math.sqrt(x*x + y*y)\n\ndef line_circle_intersection(x0, y0, r, px, py):\n    # Check if line from origin through (px, py) intersects circle at (x0, y0) with radius r\n    # Line can be parameterized as (t*px, t*py) for t >= 0\n    # Circle: (x-x0)^2 + (y-y0)^2 = r^2\n    # Substitute: (t*px - x0)^2 + (t*py - y0)^2 = r^2\n    \n    if px == 0 and py == 0:\n        return distance(x0, y0) <= r\n    \n    # Line direction vector (px, py)\n    # Distance from point (x0, y0) to line through origin with direction (px, py)\n    # d = |x0*py - y0*px| / sqrt(px^2 + py^2)\n    \n    d = abs(x0 * py - y0 * px) / math.sqrt(px*px + py*py)\n    \n    return d <= r\n\nwhile True:\n    line = input().split()\n    R = int(line[0])\n    N = int(line[1])\n    \n    if R == 0 and N == 0:\n        break\n    \n    ufos = []\n    for i in range(N):\n        parts = list(map(int, input().split()))\n        x0, y0, r, v = parts[0], parts[1], parts[2], parts[3]\n        ufos.append([x0, y0, r, v, True])  # True means not destroyed\n    \n    time = 1\n    invaded = 0\n    \n    while True:\n        # Move all UFOs\n        for i in range(N):\n            if ufos[i][4]:  # If not destroyed\n                x0, y0, r, v = ufos[i][0], ufos[i][1], ufos[i][2], ufos[i][3]\n                dist = distance(x0, y0)\n                if dist > 0:\n                    # Move towards origin\n                    dx = -x0 / dist\n                    dy = -y0 / dist\n                    ufos[i][0] += dx * v * time\n                    ufos[i][1] += dy * v * time\n        \n        # Check for invaded UFOs\n        for i in range(N):\n            if ufos[i][4]:\n                dist = distance(ufos[i][0], ufos[i][1])\n                if dist <= R:\n                    invaded += 1\n                    ufos[i][4] = False\n        \n        # Find closest UFO outside R\n        min_dist = float('inf')\n        target_idx = -1\n        for i in range(N):\n            if ufos[i][4]:\n                dist = distance(ufos[i][0], ufos[i][1])\n                if dist > R and dist < min_dist:\n                    min_dist = dist\n                    target_idx = i\n        \n        if target_idx == -1:\n            break\n        \n        # Fire laser at target\n        tx, ty = ufos[target_idx][0], ufos[target_idx][1]\n        \n        # Destroy all UFOs that intersect with this laser line\n        for i in range(N):\n            if ufos[i][4]:\n                dist = distance(ufos[i][0], ufos[i][1])\n                if dist > R:\n                    if line_circle_intersection(ufos[i][0], ufos[i][1], ufos[i][2], tx, ty):\n                        ufos[i][4] = False\n        \n        time = 1\n    \n    print(invaded)\n", "perturbed_sampled": ["import math def distance(x, y): return math.sqrt(x*x + y*y)  py): # Check if line from  circle at (x0, y0) with radius r # Line can be parameterized  >= 0  = r^2 # Substitute: (t*px - x0)^2 + (t*py - y0)^2 = r^2 if px == 0  distance(x0, y0) <= r # Line direction vector (px, py) # Distance from point (x0, y0) to line through  # d = |x0*py - y0*px| / sqrt(px^2 + py^2) d = abs(x0 * py - y0 * px) / math.sqrt(px*px + py*py) return d <= r while True: line  R == 0 and N ==  for i in range(N): parts = list(map(int, input().split())) x0, y0, r, v = parts[0], parts[1], parts[2], parts[3] ufos.append([x0, y0, r, v, True])  time = 1 invaded = 0 while True: # Move all UFOs for i in range(N): if ufos[i][4]: # If not destroyed x0,  ufos[i][1], ufos[i][2], ufos[i][3] dist = distance(x0, y0) if  towards origin dx = -x0 / dist dy = -y0 / dist ufos[i][0] += dx * v * time ufos[i][1] += dy * v * time # Check for invaded UFOs for i in range(N): if ufos[i][4]: dist  <= R: invaded +=  Find closest UFO outside R min_dist =   dist = distance(ufos[i][0], ufos[i][1]) if dist > R and dist < min_dist: min_dist = dist target_idx = i if target_idx ==   all UFOs that intersect with this  = distance(ufos[i][0], ufos[i][1]) if dist > R: if line_circle_intersection(ufos[i][0], ufos[i][1], ufos[i][2], tx, ty): ufos[i][4] = False time = 1 print(invaded)"], "perturbed_original": ["from math import sqrt while 1: R, N = map(int, raw_input().split()) if R == N == 0: break P = [] for i in xrange(N): x, y,  P.append((sqrt(x**2+y**2), x**2+y**2, x, y, r, v, i)) kill = [0]*N ans = 0 for t  None; mi = 10**9 for l, ll, x, y, r, v, i in P: if kill[i]: continue if  kill[i] = 1 ans +=  - t*v j = i if j is  y0, r0, v0, j = P[j] for l, ll,  in P: if kill[i]: continue if (l - t*v)*abs(x0*y - x*y0) < r*l*l0 + 1e-8: kill[i] = 1 print ans"], "original_ll": -1.0629624128341675, "sampled_ll": -0.6735007762908936, "all_perturbed_sampled_ll": [-1.7535895109176636], "all_perturbed_original_ll": [-2.168447732925415], "perturbed_sampled_ll": -1.7535895109176636, "perturbed_original_ll": -2.168447732925415, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n        int point[10][10]={0};\n        int person=0,endFlag=0,result=0,count,repeat,versusCount,myGTP,theyGTP;\n        printf(\"\u5165\u529b\\n\");\n        for(count=0; endFlag==0; count++){\n                for(person=0; person<5 && endFlag==0; person++){\n                        scanf(\"%d\",&point[count][person]);\n                        if(point[count][person]<0||point[count][person]>3){\n                        printf(\"\u30a8\u30e9\u30fc\u3001\u7d42\u4e86\u3057\u307e\u3059\u3002\");\n                        exit(1);\n                                }\n                        if(point[count][person]==0){\n                                endFlag=1;\n                                }\n                        }\n                }\n        repeat=count;\n        printf(\"\\n\u51fa\u529b\\n\");\n        for(count=0; count<repeat; count++){\n                for(person=0; point[count][person]!=0; person++){\n                        for(versusCount=0; point[count][versusCount]!=0; versusCount++){\n                        myGTP=point[count][person];\n                        theyGTP=point[count][versusCount];\n                        if(person!=versusCount){\n                        if(((myGTP+1==theyGTP)||(myGTP-2==theyGTP))&&(result!=1)&&(result!=3)){\n                                result+=1;\n                                }\n                        if(((myGTP+2==theyGTP)||(myGTP-1==theyGTP))&&(result!=2)&&(result!=3)){\n                                result+=2;\n                                }\n                        }\n                        }\n                if(result==0){\n                        result=3;\n                        }\n                                printf(\"\\n%d\",result);\n                                result=0;\n                                }\n                        }\n        return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int h[5];\n    \n    while(1) {\n        scanf(\"%d\", &h[0]);\n        if(h[0] == 0) break;\n        \n        for(int i = 1; i < 5; i++) {\n            scanf(\"%d\", &h[i]);\n        }\n        \n        int count[4] = {0};\n        for(int i = 0; i < 5; i++) {\n            count[h[i]]++;\n        }\n        \n        int types = 0;\n        for(int i = 1; i <= 3; i++) {\n            if(count[i] > 0) types++;\n        }\n        \n        if(types == 1 || types == 3) {\n            for(int i = 0; i < 5; i++) {\n                printf(\"3\\n\");\n            }\n        } else {\n            int winning_hand;\n            if(count[1] > 0 && count[2] > 0) {\n                winning_hand = 1;\n            } else if(count[2] > 0 && count[3] > 0) {\n                winning_hand = 2;\n            } else {\n                winning_hand = 3;\n            }\n            \n            for(int i = 0; i < 5; i++) {\n                if(h[i] == winning_hand) {\n                    printf(\"1\\n\");\n                } else {\n                    printf(\"2\\n\");\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  { scanf(\"%d\", &h[0]); if(h[0] == 0) break; for(int i = 1; i < 5; i++) { scanf(\"%d\", &h[i]); } int count[4] = {0}; for(int i  i++) { count[h[i]]++; }  i = 1;  if(count[i] > 0) types++; } if(types == 1 || types == 3) { for(int i = 0; i < 5; i++) { printf(\"3\\n\"); } } else { int winning_hand; if(count[1] >  { winning_hand  > 0 && count[3] > 0) {  { winning_hand = 3; } for(int i = 0; i < 5; i++) { if(h[i] == winning_hand) { printf(\"1\\n\"); }  } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int point[10][10]={0}; int person=0,endFlag=0,result=0,count,repeat,versusCount,myGTP,theyGTP; printf(\"\u5165\u529b\\n\"); for(count=0; endFlag==0; count++){ for(person=0; person<5 && endFlag==0; person++){ scanf(\"%d\",&point[count][person]); if(point[count][person]<0||point[count][person]>3){ printf(\"\u30a8\u30e9\u30fc\u3001\u7d42\u4e86\u3057\u307e\u3059\u3002\");   count<repeat; count++){ for(person=0; point[count][person]!=0; person++){ for(versusCount=0; point[count][versusCount]!=0; versusCount++){ myGTP=point[count][person]; theyGTP=point[count][versusCount]; if(person!=versusCount){  } } } if(result==0){ result=3; } printf(\"\\n%d\",result); result=0; } } return 0; }"], "original_ll": -1.1242338418960571, "sampled_ll": -0.48143863677978516, "all_perturbed_sampled_ll": [-1.5413920879364014], "all_perturbed_original_ll": [-1.7535830736160278], "perturbed_sampled_ll": -1.5413920879364014, "perturbed_original_ll": -1.7535830736160278, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "//Volume2-0205\nimport java.util.Scanner;\n\nclass Main {\n\n\tprivate static int[] cnt,\n             \t\t     player,\n\t\t                 result;\n\n\tpublic static void main(String[] args){\n\t\tint   victory,loss;\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tcnt    = new int[4];\n\t\t\tplayer = new int[5];\n\t\t\tresult = new int[5];\n\t\t\tplayer[0] = sc.nextInt();\n\t\t\tif(player[0] == 0){break;}\n\t\t\tcnt[player[0]]++;\n\t\t\tfor(int i=1;i<5;i++){\n\t\t\t\tplayer[i] = sc.nextInt();\n\t\t\t\tcnt[player[i]]++;\n\t\t\t}\n\t\t\tscape : {\n\t\t\t\tif(cnt[1] == 5 || cnt[2] == 5 || cnt[3] == 5 ||\n\t\t\t\t  (cnt[1] != 0 && cnt[2] != 0 && cnt[3] != 0    )){\n\t\t\t\t\tfor(int j=0;j<5;j++){result[j] = 3;}\n\t\t\t\t\tbreak scape;\n\t\t\t\t}\n\t\t\t\tvictory = 0; loss = 0;\n\t\t\t\tif       (cnt[1] != 0 && cnt[2] != 0){\n\t\t\t\t\tvictory = 1;\n\t\t\t\t\tloss    = 2;\n\t\t\t\t} else if(cnt[2] != 0 && cnt[3] != 0){\n\t\t\t\t\tvictory = 2;\n\t\t\t\t\tloss    = 3;\n\t\t\t\t} else if(cnt[1] != 0 && cnt[3] != 0){\n\t\t\t\t\tvictory = 3;\n\t\t\t\t\tloss    = 1;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\tif        (player[j] == victory){\n\t\t\t\t\t\tresult[j] = 1;\n\t\t\t\t\t} else if (player[j] == loss){\n\t\t\t\t\t\tresult[j] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i:result){System.out.println(i);}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int h1 = sc.nextInt();\n            if (h1 == 0) break;\n            \n            int h2 = sc.nextInt();\n            int h3 = sc.nextInt();\n            int h4 = sc.nextInt();\n            int h5 = sc.nextInt();\n            \n            int[] hands = {h1, h2, h3, h4, h5};\n            \n            boolean hasRock = false;\n            boolean hasScissors = false;\n            boolean hasPaper = false;\n            \n            for (int hand : hands) {\n                if (hand == 1) hasRock = true;\n                else if (hand == 2) hasScissors = true;\n                else if (hand == 3) hasPaper = true;\n            }\n            \n            int distinctCount = 0;\n            if (hasRock) distinctCount++;\n            if (hasScissors) distinctCount++;\n            if (hasPaper) distinctCount++;\n            \n            if (distinctCount == 1 || distinctCount == 3) {\n                for (int i = 0; i < 5; i++) {\n                    System.out.println(3);\n                }\n            } else {\n                int winningHand;\n                if (hasRock && hasScissors) {\n                    winningHand = 1;\n                } else if (hasScissors && hasPaper) {\n                    winningHand = 2;\n                } else {\n                    winningHand = 3;\n                }\n                \n                for (int hand : hands) {\n                    if (hand == winningHand) {\n                        System.out.println(1);\n                    } else {\n                        System.out.println(2);\n                    }\n                }\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args)  Scanner(System.in); while (true) { int h1 = sc.nextInt(); if (h1 == 0) break; int  = sc.nextInt(); int h4 = sc.nextInt(); int h5 = sc.nextInt(); int[] hands = {h1, h2, h3, h4, h5}; boolean hasRock = false; boolean hasScissors = false; boolean hasPaper = false;  { if (hand ==   = true; else if (hand  } int distinctCount = 0; if (hasRock) distinctCount++; if (hasScissors) distinctCount++; if (hasPaper) distinctCount++; if (distinctCount == 1 || distinctCount == 3) { for (int i  i++) { System.out.println(3); } } else { int winningHand; if (hasRock && hasScissors) { winningHand = 1; } else if  = 2; } else { winningHand = 3; } for (int hand : hands)  { System.out.println(1); } else { System.out.println(2);  } }"], "perturbed_original": ["//Volume2-0205 import java.util.Scanner; class Main {  result; public static void main(String[] args){ int victory,loss; Scanner sc = new Scanner(System.in); while(true){ cnt = new int[4];  = new int[5];  0){break;} cnt[player[0]]++; for(int i=1;i<5;i++){ player[i] = sc.nextInt(); cnt[player[i]]++; } scape : { if(cnt[1] == 5 || cnt[2] == 5 || cnt[3] == 5 || (cnt[1] != 0 && cnt[2] != 0 && cnt[3]  = 3;} break scape; } victory = 0;  != 0){ victory = 1; loss = 2; } else if(cnt[2] != 0 && cnt[3] != 0){ victory =  else if(cnt[1] != 0 && cnt[3] != 0){ victory = 3; loss =  (player[j] == victory){ result[j] = 1; } else if (player[j] ==  } } for(int i:result){System.out.println(i);} } } }"], "original_ll": -0.8920938968658447, "sampled_ll": -0.40067756175994873, "all_perturbed_sampled_ll": [-1.4059630632400513], "all_perturbed_original_ll": [-1.7937911748886108], "perturbed_sampled_ll": -1.4059630632400513, "perturbed_original_ll": -1.7937911748886108, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#5\u500b\u306e\u3046\u30611\u756a\u76ee\u306e\u5165\u529b\u304c0\u306a\u3089\u51e6\u7406\u3092\u7d42\u308f\u308b\u3002\nwhile True:\n    line = []\n    line.append(int(input()))\n    if line[0] == 0:break\n\n    #\u6a19\u6e96\u5165\u529b\u3092\u3057\u30ea\u30b9\u30c8\u3092\u30bb\u30c3\u30c8\u306b\u3057\u305f\u3082\u306e\u3092\u4f5c\u308b\u3002\n    for _ in range(4):line.append(int(input()))\n    se = set(line)\n    \n    #\u5168\u54e1\u304c\u540c\u3058\u6570\u3092\u51fa\u3059\u304b3\u7a2e\u985e\u306e\u624b\u304c\u51fa\u305f\u30895\u3053\"3\"\u3092\u51fa\u529b\u3059\u308b\u3002\n    if len(se) == 1 or len(se) == 3:\n        for _ in range(5):print(\"3\")\n        \"\"\n    #\u3058\u3083\u3093\u3051\u3093\u306e\u52dd\u6557\u306b\u57fa\u3065\u304d\u52dd\u3061\u3060\u3063\u305f\u3089\"1\"\u8ca0\u3051\u3060\u3063\u305f\u3089\"2\"\u3092\u51fa\u529b\u3059\u308b\n    else:\n        if sum(se) == 3:\n            for i in line:\n                if i == 1:print(\"1\")\n                else:print(\"2\")\n        if sum(se) == 4:\n            for i in line:\n                if i == 3:print(\"1\")\n                else:print(\"2\")\n        if sum(se) == 5:\n            for i in line:\n                if i == 2:print(\"1\")\n                else:print(\"2\")\n", "sampled": "while True:\n    h1 = int(input())\n    if h1 == 0:\n        break\n    \n    hands = [h1]\n    for _ in range(4):\n        hands.append(int(input()))\n    \n    unique_hands = set(hands)\n    \n    # Check if it's a draw (all same or all three types)\n    if len(unique_hands) == 1 or len(unique_hands) == 3:\n        for _ in range(5):\n            print(3)\n    else:\n        # Two types of hands - determine winner\n        hand_list = list(unique_hands)\n        h_a, h_b = hand_list[0], hand_list[1]\n        \n        # Determine which hand wins\n        # 1 (rock) beats 2 (scissors)\n        # 2 (scissors) beats 3 (paper)\n        # 3 (paper) beats 1 (rock)\n        if (h_a == 1 and h_b == 2) or (h_a == 2 and h_b == 1):\n            winning_hand = 1\n        elif (h_a == 2 and h_b == 3) or (h_a == 3 and h_b == 2):\n            winning_hand = 2\n        else:  # (h_a == 3 and h_b == 1) or (h_a == 1 and h_b == 3)\n            winning_hand = 3\n        \n        for hand in hands:\n            if hand == winning_hand:\n                print(1)\n            else:\n                print(2)\n", "perturbed_sampled": ["while True: h1 = int(input()) if h1 == 0: break hands = [h1] for _ in range(4): hands.append(int(input())) unique_hands = set(hands) # Check if it's a draw (all same  len(unique_hands) == 1 or len(unique_hands) == 3: for _ in range(5): print(3) else: # Two types of hands - determine winner hand_list = list(unique_hands) h_a, h_b = hand_list[0], hand_list[1] # Determine  (rock) beats 2 (scissors)  (paper) # 3 (paper) beats 1 (rock) if (h_a == 1 and h_b  1): winning_hand = 1 elif (h_a ==  or (h_a  2):  (h_a == 3 and h_b == 1) or (h_a == 1 and h_b == 3) winning_hand = 3 for hand in hands: if  print(2)"], "perturbed_original": ["#5\u500b\u306e\u3046\u30611\u756a\u76ee\u306e\u5165\u529b\u304c0\u306a\u3089\u51e6\u7406\u3092\u7d42\u308f\u308b\u3002 while True: line  _ in range(4):line.append(int(input())) se = set(line) #\u5168\u54e1\u304c\u540c\u3058\u6570\u3092\u51fa\u3059\u304b3\u7a2e\u985e\u306e\u624b\u304c\u51fa\u305f\u30895\u3053\"3\"\u3092\u51fa\u529b\u3059\u308b\u3002 if len(se) == 1 or len(se) == 3: for _ in range(5):print(\"3\") \"\" #\u3058\u3083\u3093\u3051\u3093\u306e\u52dd\u6557\u306b\u57fa\u3065\u304d\u52dd\u3061\u3060\u3063\u305f\u3089\"1\"\u8ca0\u3051\u3060\u3063\u305f\u3089\"2\"\u3092\u51fa\u529b\u3059\u308b else: if sum(se) == 3: for i in line: if i ==  4: for i in line: if i == 3:print(\"1\") else:print(\"2\")  i in line: if i == 2:print(\"1\") else:print(\"2\")"], "original_ll": -1.4847517013549805, "sampled_ll": -0.7928951978683472, "all_perturbed_sampled_ll": [-1.9329560995101929], "all_perturbed_original_ll": [-2.4131879806518555], "perturbed_sampled_ll": -1.9329560995101929, "perturbed_original_ll": -2.4131879806518555, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n\tint i=0,l,n,m,a[12],b;\n\twhile(1){\n\t\tb=0;\n\t\tscanf(\"%d\",&l);\n\t\tif(l==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i=0;i<12;i++){\n\t\t\tscanf(\"%d%d\",&m,&n);\n\t\t\ta[i]=m-n;\n\t\t}\n\t\tfor(i=0;i<12;i++){\n\t\t\tb=b+a[i];\n\t\t\tif(b>=l){\n\t\t\t\tprintf(\"%d\\n\",i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(b<l){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int L;\n    \n    while (scanf(\"%d\", &L) == 1 && L != 0) {\n        int savings = 0;\n        int month = 0;\n        int found = 0;\n        \n        for (int i = 1; i <= 12; i++) {\n            int M, N;\n            scanf(\"%d %d\", &M, &N);\n            \n            if (!found) {\n                savings += (M - N);\n                if (savings >= L) {\n                    month = i;\n                    found = 1;\n                }\n            }\n        }\n        \n        if (found) {\n            printf(\"%d\\n\", month);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int L; while (scanf(\"%d\", &L) == 1 && L != 0) { int savings = 0; int month = 0; int found = 0;  i <= 12;  if (!found) { savings += (M - N); if (savings >= L) { month = i; found = 1; } } } if (found) {  printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h>  b=0; scanf(\"%d\",&l); if(l==0){ break; } for(i=0;i<12;i++){ scanf(\"%d%d\",&m,&n); a[i]=m-n; } for(i=0;i<12;i++){ b=b+a[i]; if(b>=l){ printf(\"%d\\n\",i+1); break; } } if(b<l){ printf(\"NA\\n\"); } } }"], "original_ll": -0.9349135160446167, "sampled_ll": -0.7023061513900757, "all_perturbed_sampled_ll": [-1.6086573600769043], "all_perturbed_original_ll": [-1.6036397218704224], "perturbed_sampled_ll": -1.6086573600769043, "perturbed_original_ll": -1.6036397218704224, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main{\n\tstatic Scanner sc;\n\tstatic int L,M,N,T,mth;\n\t\n\tpublic static void main(String[]args){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tL=sc.nextInt();\n\t\t\tmth=0;\n\t\t\tT=0;M=0;N=0;\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tM=sc.nextInt();\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tT=T+M-N;\n\t\t\t\tif(T>=L && mth==0){\n\t\t\t\t\tmth=i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mth==0){System.out.println(\"NA\");}\n\t\t\telse{System.out.println(mth);}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int L = sc.nextInt();\n            if (L == 0) break;\n            \n            int savings = 0;\n            int month = 0;\n            boolean found = false;\n            \n            for (int i = 1; i <= 12; i++) {\n                int M = sc.nextInt();\n                int N = sc.nextInt();\n                savings += (M - N);\n                \n                if (!found && savings >= L) {\n                    month = i;\n                    found = true;\n                }\n            }\n            \n            if (found) {\n                System.out.println(month);\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int L = sc.nextInt(); if (L == 0) break; int savings = 0;  (int i = 1; i <= 12; i++) { int M = sc.nextInt(); int N = sc.nextInt(); savings += (M - N); if (!found && savings >= L) { month = i;  if (found) { System.out.println(month); }  sc.close(); } }"], "perturbed_original": ["import  public static void main(String[]args){ sc=new Scanner(System.in); while(sc.hasNext()){ L=sc.nextInt(); mth=0; T=0;M=0;N=0; for(int i=0;i<12;i++){ M=sc.nextInt(); N=sc.nextInt(); T=T+M-N; if(T>=L && mth==0){ mth=i+1; } } if(mth==0){System.out.println(\"NA\");} else{System.out.println(mth);} } } }"], "original_ll": -1.0667567253112793, "sampled_ll": -0.618364691734314, "all_perturbed_sampled_ll": [-1.595801591873169], "all_perturbed_original_ll": [-1.6266028881072998], "perturbed_sampled_ll": -1.595801591873169, "perturbed_original_ll": -1.6266028881072998, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    L = int(input())\n    if L == 0:\n        break\n    \n    flag = True\n    ans = -1\n    d = 0\n    for i in range(12):\n        M,N = [int(i) for i in input().split()]\n        d = d + M - N\n        if d >= L and flag:\n            ans = i+1\n            flag = False\n    \n    if ans >= 0:\n        print(ans)\n    else:\n        print(\"NA\")\n\n", "sampled": "while True:\n    L = int(input())\n    if L == 0:\n        break\n    \n    savings = 0\n    months = 0\n    found = False\n    \n    for month in range(1, 13):\n        M, N = map(int, input().split())\n        savings += (M - N)\n        if savings >= L and not found:\n            months = month\n            found = True\n    \n    if found:\n        print(months)\n    else:\n        print(\"NA\")\n", "perturbed_sampled": ["while True: L = int(input()) if L == 0: break savings = 0 months = 0 found = False for month in range(1, 13): M,  if savings >= L and not found: months = month found  else: print(\"NA\")"], "perturbed_original": ["while  L == 0: break flag =  = 0 for i in range(12):  in input().split()] d = d + M - N if d >= L and flag: ans = i+1 flag = False if ans >= 0: print(ans) else: print(\"NA\")"], "original_ll": -1.1602100133895874, "sampled_ll": -1.0161250829696655, "all_perturbed_sampled_ll": [-2.4419004917144775], "all_perturbed_original_ll": [-2.645609140396118], "perturbed_sampled_ll": -2.4419004917144775, "perturbed_original_ll": -2.645609140396118, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0207\nTitle Block\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n#include <setjmp.h>\n//Global data section\nint w,h;\nint xs,ys;\nint xg,yg;\nint n;\nint c[100];\nint d[100];\nint x[100],y[100];\nint bd[100][100];\njmp_buf env;\n\n//\nvoid init()\n{\n  int i,j;\n  for(i=0;i<h;i++)\n    for(j=0;j<w;j++)\n      bd[i][j]=0;\n  for(i=0;i<100;i++)\n    {\n      x[i]=y[i]=d[i]=c[i]=0;\n    }\n}\nint get_block(int px,int py)\n{\n  int i;\n  // printf(\"GB%d,%d\\n\",px,py);\n  for(i=0;i<n;i++)\n    if(d[i]==0)         // yokonaga\n\t{\n\t  if(px-x[i] >=0 && px-x[i] <=3 && \n\t     py-y[i] >=0 && py-y[i] <= 1)\n\t    return(i);\n\t}\n    else if(d[i]==1)         // tatenaga\n      {\n\tif(px-x[i] >=0 && px-x[i] <=1 && \n\t   py-y[i] >=0 && py-y[i] <=3)\n\t  return(i);\n      }\n  return(-1);\n}\nint show()\n{\n  int i,j;\n  for(i=1;i<=h;i++)\n    {\n      for(j=1;j<=w;j++)\n\tprintf(\"%d\",bd[i][j]);\n      printf(\"\\n\");\n    }\n  printf(\"\\n\");\n}\nvoid paint0(int px,int py,int col,int ww,int hh)\n{\n  int i,j;\n  //printf(\"P0 %d %d\\n\",px,py);\n\n    for(i=0;i<hh;i++)\n      for(j=0;j<ww;j++)\n\tbd[py+i][px+j]=col;\n}\nint paint(int px,int py,int col)\n{\n  int cc,blk,dir,bx,by,w0,h0,i,j;\n  //printf(\"xyc=%d %d %d\\n\",px,py,col);\n\n  if(px < 1 ||py < 1) //out of bound\n    return(0);\n  if(bd[py][px])  // already painted\n    return(0);\n  blk=get_block(px,py);  // get block no of this place\n  //printf(\"blk=%d\\n\",blk);\n  if(blk<0)\n    return(0);\n  cc=c[blk];\n  dir=d[blk];\n  if(cc != col)\n    return(0);             // different color\n\n  bx=x[blk];\n  by=y[blk];\n   if(dir==0)         // yokonaga\n     { w0=4;h0=2;}\n   else\n     { w0=2;h0=4;}\n\n  paint0(bx,by,col,w0,h0); // paint this block\n\n  if(xg >= bx && xg <= bx+w0 && \n     yg >= by && yg <= by+h0 )     // reach the goal\n    {\n      longjmp(env,1);\n    }\n\n   for(i=-1;i<w0+1;i++)\n     if(i==-1||i==w0)\n       for(j=0;j<h0;j++)\n\t paint(bx+i,by+j,col);\n     else\n       for(j=-1;j<h0+1;j++)\n\t paint(bx+i,by+j,col);\n\n   return(0);\n}\nmain()\n{\n  int i,bl,col,dir,ret;\n  while(EOF != scanf(\"%d %d\",&w,&h) && (w || h))\n    {\n      init();\n      scanf(\"%d %d\",&xs,&ys);\n      scanf(\"%d %d\",&xg,&yg);\n      scanf(\"%d\",&n);\n      for(i=0;i<n;i++)\n\tscanf(\"%d %d %d %d\",&(c[i]),&(d[i]),&(x[i]),&(y[i]));\n      \n      bl = get_block(xs,ys);\n      col=c[bl];\n      if(setjmp(env)==0)\n\t{\n\t  ret = paint(xs,ys,col);\n\t}\n      else\n\tret=-1;\n      \n      paint(1,1,2);\n      show();\n      printf(\"%s\\n\",ret?\"OK\":\"NG\");\n    }\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint w, h, xs, ys, xg, yg, n;\nint board[105][105];\nint visited[105][105];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint dfs(int x, int y, int color) {\n    if (x == xg && y == yg) {\n        return 1;\n    }\n    \n    visited[y][x] = 1;\n    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        \n        if (nx >= 1 && nx <= w && ny >= 1 && ny <= h) {\n            if (!visited[ny][nx] && board[ny][nx] == color) {\n                if (dfs(nx, ny, color)) {\n                    return 1;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &w, &h);\n        if (w == 0 && h == 0) break;\n        \n        scanf(\"%d %d\", &xs, &ys);\n        scanf(\"%d %d\", &xg, &yg);\n        scanf(\"%d\", &n);\n        \n        memset(board, 0, sizeof(board));\n        memset(visited, 0, sizeof(visited));\n        \n        for (int i = 0; i < n; i++) {\n            int c, d, x, y;\n            scanf(\"%d %d %d %d\", &c, &d, &x, &y);\n            \n            if (d == 0) {\n                // horizontal: 4 wide, 2 tall\n                for (int py = y; py < y + 2 && py <= h; py++) {\n                    for (int px = x; px < x + 4 && px <= w; px++) {\n                        board[py][px] = c;\n                    }\n                }\n            } else {\n                // vertical: 2 wide, 4 tall\n                for (int py = y; py < y + 4 && py <= h; py++) {\n                    for (int px = x; px < x + 2 && px <= w; px++) {\n                        board[py][px] = c;\n                    }\n                }\n            }\n        }\n        \n        int startColor = board[ys][xs];\n        \n        if (startColor == 0 || board[yg][xg] != startColor) {\n            printf(\"NG\\n\");\n        } else {\n            if (dfs(xs, ys, startColor)) {\n                printf(\"OK\\n\");\n            } else {\n                printf(\"NG\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int  yg, n; int board[105][105]; int visited[105][105]; int dx[] = {0, 0, 1, -1}; int dy[]  int dfs(int x, int y,  == xg && y == yg)  = 1; for (int i = 0; i <  = x + dx[i]; int ny  (nx  w && ny >= 1 && ny <= h) { if (!visited[ny][nx] && board[ny][nx] == color) { if  1; } } } } return 0; } int  scanf(\"%d %d\", &w, &h); if (w == 0  scanf(\"%d %d\", &xs, &ys); scanf(\"%d %d\", &xg, &yg); scanf(\"%d\", &n); memset(board, 0, sizeof(board)); memset(visited, 0, sizeof(visited)); for (int i = 0; i < n; i++) { int c,   &y); if (d == 0) { // horizontal: 4 wide, 2 tall for (int py = y; py < y + 2  px <= w; px++) { board[py][px] = c; } } } else { // vertical: 2 wide, 4 tall   && py <= h; py++) { for (int px = x; px < x + 2 && px <= w; px++) { board[py][px] = c; } } } } int startColor = board[ys][xs]; if (startColor == 0 || board[yg][xg] != startColor) { printf(\"NG\\n\"); } else { if (dfs(xs, ys, startColor)) { printf(\"OK\\n\"); } else { printf(\"NG\\n\"); } } } return 0; }"], "perturbed_original": ["/* AizuOnline  <stdio.h> // Select Below //#include <stdlib.h> //#include <string.h>  <limits.h> #include <setjmp.h> //Global data section int w,h; int xs,ys; int xg,yg; int n; int c[100]; int d[100]; int x[100],y[100]; int bd[100][100]; jmp_buf  } } int get_block(int px,int py)  for(i=0;i<n;i++)  && py-y[i] >=0 && py-y[i] <= 1) return(i); } else if(d[i]==1) // tatenaga { if(px-x[i] >=0 && px-x[i] <=1  <=3) return(i); } return(-1); } int show() { int i,j; for(i=1;i<=h;i++) { for(j=1;j<=w;j++) printf(\"%d\",bd[i][j]); printf(\"\\n\"); } printf(\"\\n\"); } void paint0(int px,int py,int col,int ww,int hh) { int i,j; //printf(\"P0 %d %d\\n\",px,py); for(i=0;i<hh;i++) for(j=0;j<ww;j++) bd[py+i][px+j]=col; } int paint(int px,int py,int  %d %d\\n\",px,py,col); if(px < 1 ||py < 1) //out of bound return(0); if(bd[py][px]) // already painted return(0); blk=get_block(px,py); // get block no of this place //printf(\"blk=%d\\n\",blk); if(blk<0)  col) return(0); // different color  { w0=4;h0=2;}  paint this block if(xg >= bx && xg <= bx+w0  yg <= by+h0 )  longjmp(env,1); } for(i=-1;i<w0+1;i++) if(i==-1||i==w0) for(j=0;j<h0;j++) paint(bx+i,by+j,col); else for(j=-1;j<h0+1;j++) paint(bx+i,by+j,col); return(0); } main() { int i,bl,col,dir,ret; while(EOF != scanf(\"%d %d\",&w,&h) && (w || h)) { init(); scanf(\"%d %d\",&xs,&ys); scanf(\"%d %d\",&xg,&yg); scanf(\"%d\",&n); for(i=0;i<n;i++) scanf(\"%d %d %d %d\",&(c[i]),&(d[i]),&(x[i]),&(y[i])); bl = get_block(xs,ys); col=c[bl]; if(setjmp(env)==0) { ret = paint(xs,ys,col);  printf(\"%s\\n\",ret?\"OK\":\"NG\"); } return(0); }"], "original_ll": -1.0815677642822266, "sampled_ll": -0.3756895661354065, "all_perturbed_sampled_ll": [-1.309504508972168], "all_perturbed_original_ll": [-1.6275007724761963], "perturbed_sampled_ll": -1.309504508972168, "perturbed_original_ll": -1.6275007724761963, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 0, -1, 0};\n    int[] dirY = {0, 1, 0, -1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\t    makeRoute();\n\t    //show();\n\n\t    if(!route[ys][xs] || !route[yg][xg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\t    else System.out.println(search(xs, ys) ? \"OK\":\"NG\");\n\t}\n    }\n\n    /*\n      \u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2\u304c\u8fd1\u304f\u306a\u308b\u3088\u3046\u306b\u9053\u3092\u9078\u3076\n      (\u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u77ed\u7e2e\u3092\u898b\u3064\u3051\u3089\u308c\u306a\u3051\u308c\u3070)\u884c\u3051\u308b\u6240\u306b\u884c\u304f\n      \u3069\u3053\u306b\u3082\u884c\u3051\u306a\u3051\u308c\u3070\u307b\u3052\u3002\n    */\n    boolean search(int x, int y){\n\tint d = getD(x, y);\n\tboolean[] goodRoute = new boolean[4];\n\tboolean[] canRoute = new boolean[4];\n\tint gc = 0;\n\tint cc = 0;\n\tif(d==0) return true;\n\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<w && b>0 && b<h && route[b][a]){\n\t\tcanRoute[i] = true;\n\t\tcc++;\n\t\tif(getD(a, b)<d){\n\t\t    goodRoute[i] = true;\n\t\t    gc++;\n\t\t}\n\t    }\n\t}\n\t\n\tif(gc!=0){\n\t    for(int i=0; i<4; i++)\n\t\tif(goodRoute[i]) \n\t\t    if(search(x+dirX[i], y+dirY[i])) return true;\n\t}\n\telse if(cc!=0){\n\t    for(int i=0; i<4; i++)\n\t\tif(canRoute[i]) \n\t\t    if(search(x+dirX[i], y+dirY[i])) return true;\n\t}\n\t\t    \n\treturn false;\n    }\n\n    int getD(int x, int y){ return Math.abs(xg-x) + Math.abs(yg-y); }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"\u25a1\":\"\u25a0\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[h][w];\n\troute = new boolean[h][w];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[b][a] = c;    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[b][a] = c;\n\t}\n    }\n\n    void makeRoute(){\n\tint tcolor = block[ys][xs];\n\tfor(int i=0; i<w; i++)\n\t    for(int k=0; k<h; k++)\n\t\tif(block[k][i]==tcolor) route[k][i] = true;\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Block {\n        int color;\n        int dir;\n        int x;\n        int y;\n        \n        Block(int color, int dir, int x, int y) {\n            this.color = color;\n            this.dir = dir;\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            \n            if (w == 0 && h == 0) break;\n            \n            int xs = sc.nextInt();\n            int ys = sc.nextInt();\n            int xg = sc.nextInt();\n            int yg = sc.nextInt();\n            int n = sc.nextInt();\n            \n            int[][] board = new int[h + 1][w + 1];\n            \n            for (int i = 0; i < n; i++) {\n                int c = sc.nextInt();\n                int d = sc.nextInt();\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                \n                if (d == 0) { // horizontal (2 high, 4 wide)\n                    for (int dy = 0; dy < 2; dy++) {\n                        for (int dx = 0; dx < 4; dx++) {\n                            if (y + dy <= h && x + dx <= w) {\n                                board[y + dy][x + dx] = c;\n                            }\n                        }\n                    }\n                } else { // vertical (4 high, 2 wide)\n                    for (int dy = 0; dy < 4; dy++) {\n                        for (int dx = 0; dx < 2; dx++) {\n                            if (y + dy <= h && x + dx <= w) {\n                                board[y + dy][x + dx] = c;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            int startColor = board[ys][xs];\n            int goalColor = board[yg][xg];\n            \n            if (startColor == 0 || goalColor == 0 || startColor != goalColor) {\n                System.out.println(\"NG\");\n                continue;\n            }\n            \n            boolean[][] visited = new boolean[h + 1][w + 1];\n            Queue<int[]> queue = new LinkedList<>();\n            queue.offer(new int[]{xs, ys});\n            visited[ys][xs] = true;\n            \n            boolean found = false;\n            int[] dx = {0, 0, 1, -1};\n            int[] dy = {1, -1, 0, 0};\n            \n            while (!queue.isEmpty()) {\n                int[] curr = queue.poll();\n                int cx = curr[0];\n                int cy = curr[1];\n                \n                if (cx == xg && cy == yg) {\n                    found = true;\n                    break;\n                }\n                \n                for (int dir = 0; dir < 4; dir++) {\n                    int nx = cx + dx[dir];\n                    int ny = cy + dy[dir];\n                    \n                    if (nx >= 1 && nx <= w && ny >= 1 && ny <= h \n                        && !visited[ny][nx] \n                        && board[ny][nx] == startColor) {\n                        visited[ny][nx] = true;\n                        queue.offer(new int[]{nx, ny});\n                    }\n                }\n            }\n            \n            System.out.println(found ? \"OK\" : \"NG\");\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  { int color; int dir; int x; int  int x, int y) { this.color = color; this.dir = dir; this.x = x; this.y = y; } } public static void main(String[]  new Scanner(System.in); while (true) {  h = sc.nextInt(); if (w == 0 && h == 0) break; int xs = sc.nextInt(); int ys = sc.nextInt(); int xg = sc.nextInt(); int yg = sc.nextInt(); int  = new int[h + 1][w + 1]; for (int i = 0; i < n; i++) { int c = sc.nextInt(); int d = sc.nextInt(); int x = sc.nextInt(); int y = sc.nextInt(); if (d == 0) { // horizontal (2 high, 4 wide) for (int dy = 0; dy < 2; dy++) { for (int  4; dx++) { if (y + dy <= h && x + dx <= w) { board[y + dy][x + dx]  } else { // vertical (4 high, 2 wide) for (int dy = 0; dy < 4; dy++) { for (int dx = 0; dx  (y + dy <= h && x + dx <= w)  dx]  = board[yg][xg]; if (startColor == 0 || goalColor == 0 || startColor != goalColor) { System.out.println(\"NG\"); continue; } boolean[][] visited = new boolean[h + 1][w  new  = true; boolean found = false;  1, -1}; int[] dy = {1, -1, 0, 0}; while (!queue.isEmpty()) { int[] curr   if (cx ==  {  for  < 4; dir++) { int nx = cx + dx[dir]; int ny = cy + dy[dir]; if (nx >= 1 && nx <= w && ny >= 1 && ny <= h && !visited[ny][nx] && board[ny][nx] ==  \"OK\" : \"NG\"); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ public static void main(String[] args){ new Main().run(); } Scanner sc = new  ys, xg, yg, n; int c, d, x, y; int[][] block; boolean[][] route; int[] dirX = {1, 0, -1, 0}; int[] dirY = {0, 1, 0, -1}; void run(){ while(sc.hasNext()){ w = sc.nextInt()+1; h =  put(); makeRoute(); //show(); if(!route[ys][xs] || !route[yg][xg]){ System.out.println(\"NG\"); continue; } else System.out.println(search(xs, ys) ? \"OK\":\"NG\"); } } /* \u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2\u304c\u8fd1\u304f\u306a\u308b\u3088\u3046\u306b\u9053\u3092\u9078\u3076 (\u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u77ed\u7e2e\u3092\u898b\u3064\u3051\u3089\u308c\u306a\u3051\u308c\u3070)\u884c\u3051\u308b\u6240\u306b\u884c\u304f \u3069\u3053\u306b\u3082\u884c\u3051\u306a\u3051\u308c\u3070\u307b\u3052\u3002 */  int d = getD(x, y); boolean[] goodRoute = new boolean[4]; boolean[] canRoute = new boolean[4]; int gc = 0; int cc = 0; if(d==0) return true;  a = x+dirX[i]; int b = y+dirY[i]; if(a>0 && a<w && b>0 && b<h && route[b][a]){ canRoute[i] = true; cc++; if(getD(a, b)<d){ goodRoute[i] = true; gc++; } }  i++) if(goodRoute[i]) if(search(x+dirX[i], y+dirY[i])) return true; } else if(cc!=0){ for(int i=0; i<4; i++) if(canRoute[i]) if(search(x+dirX[i], y+dirY[i])) return true; } return false; }  i=1;  k++) System.out.print(route[i][k] ? \"\u25a1\":\"\u25a0\"); System.out.println();   sc.nextInt(); xg = sc.nextInt(); yg  route = new boolean[h][w]; for(int i=0; i<n; i++){ c =  sc.nextInt(); if(d==0) for(int a=x; a<x+4; a++) for(int b=y; b<y+2; b++) block[b][a] = c; else for(int a=x; a<x+2; a++) for(int b=y; b<y+4; b++) block[b][a] = c; }   i++) for(int k=0; k<h; k++) if(block[k][i]==tcolor) route[k][i] = true; } }"], "original_ll": -0.8782771825790405, "sampled_ll": -0.3458445966243744, "all_perturbed_sampled_ll": [-1.4079320430755615], "all_perturbed_original_ll": [-1.6348896026611328], "perturbed_sampled_ll": -1.4079320430755615, "perturbed_original_ll": -1.6348896026611328, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "sys.setrecursionlimit(10000) \n\ndef tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal\n    [clx,cly]=cl\n    for i in range(clx-1,clx+2):\n        for j in range(cly-1,cly+2):\n            if [i,j] in nc:\n                nc.remove([i,j])\n                ok.append([i,j])\n                tansaku([i,j],nc,ok,goal)\n\n\nwhile(1):\n    [boardw,boardh]=[int(x) for x in raw_input().split()]\n    if boardw==0 and boardh==0:\n        break\n    else:\n        [startx,starty]=[int(x) for x in raw_input().split()]\n        [goalx,goaly]=[int(x) for x in raw_input().split()]\n        blockn=int(raw_input())\n        blist={1:[],2:[],3:[],4:[],5:[]}\n        startc=-1\n        goalc=-1\n        #mark location of block\n        for i in range(blockn):\n            [c,d,x,y]=[int(x) for x in raw_input().split()]\n            if d: #d=1,tatenaga\n                for xx in range(x,x+2):\n                    for yy in range(y,y+4):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n            else:\n                for xx in range(x,x+4):\n                    for yy in range(y,y+2):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n        if startc==-1 or goalc==-1:\n            print \"NG\"\n        elif startc != goalc:\n            print \"NG\"\n        else:\n            #check if connected\n            cl=[startx,starty]\n            nc=blist[c]\n            nc.remove(cl)\n            ok=[cl]\n            goal=[goalx,goaly]\n            tansaku(cl,nc,ok,goal)\n            if goal in ok:\n                print \"OK\"\n            else:\n                print \"NG\"", "sampled": "from collections import deque\n\ndef solve():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n        \n        xs, ys = map(int, input().split())\n        xg, yg = map(int, input().split())\n        n = int(input())\n        \n        # Create board to store color at each position\n        board = [[0] * (w + 1) for _ in range(h + 1)]\n        \n        for _ in range(n):\n            c, d, x, y = map(int, input().split())\n            if d == 0:  # horizontal (2 height, 4 width)\n                for dy in range(2):\n                    for dx in range(4):\n                        if 1 <= y + dy <= h and 1 <= x + dx <= w:\n                            board[y + dy][x + dx] = c\n            else:  # vertical (4 height, 2 width)\n                for dy in range(4):\n                    for dx in range(2):\n                        if 1 <= y + dy <= h and 1 <= x + dx <= w:\n                            board[y + dy][x + dx] = c\n        \n        # BFS from start to goal\n        start_color = board[ys][xs]\n        if start_color == 0 or board[yg][xg] != start_color:\n            print(\"NG\")\n            continue\n        \n        visited = [[False] * (w + 1) for _ in range(h + 1)]\n        queue = deque([(xs, ys)])\n        visited[ys][xs] = True\n        found = False\n        \n        while queue:\n            x, y = queue.popleft()\n            if x == xg and y == yg:\n                found = True\n                break\n            \n            # Check 4 adjacent cells\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 1 <= nx <= w and 1 <= ny <= h:\n                    if not visited[ny][nx] and board[ny][nx] == start_color:\n                        visited[ny][nx] = True\n                        queue.append((nx, ny))\n        \n        print(\"OK\" if found else \"NG\")\n\nsolve()\n", "perturbed_sampled": ["from collections import deque def solve(): while True: w, h = map(int, input().split()) if w == 0 and h == 0: break  xg, yg =  # Create board to store color at each position board = [[0] * (w + 1) for _  _ in range(n): c, d,  if d == 0:  width) for dy in range(2): for dx in range(4): if 1 <= y  1 <= x +  dy][x + dx] = c else: # vertical (4 height, 2 width) for dy in range(4): for dx in range(2): if 1 <= y + dy <= h  dx <= w: board[y + dy][x + dx] =  to goal start_color = board[ys][xs] if start_color == 0 or board[yg][xg] != start_color: print(\"NG\") continue visited = [[False]  _ in range(h + 1)]  = True found = False while queue: x, y = queue.popleft() if x == xg and  True break # Check 4 adjacent cells for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]: nx, ny = x + dx, y + dy if 1 <= nx <=  start_color: visited[ny][nx] = True queue.append((nx, ny)) print(\"OK\" if found else \"NG\") solve()"], "perturbed_original": ["sys.setrecursionlimit(10000) def tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal [clx,cly]=cl for i in range(clx-1,clx+2): for j in range(cly-1,cly+2): if [i,j] in nc: nc.remove([i,j]) ok.append([i,j]) tansaku([i,j],nc,ok,goal) while(1): [boardw,boardh]=[int(x)  boardw==0 and boardh==0: break else: [startx,starty]=[int(x) for x in raw_input().split()] [goalx,goaly]=[int(x) for x in raw_input().split()] blockn=int(raw_input()) blist={1:[],2:[],3:[],4:[],5:[]} startc=-1 goalc=-1 #mark location of block for i in range(blockn): [c,d,x,y]=[int(x) for x in raw_input().split()] if d: #d=1,tatenaga for xx in range(x,x+2): for  [xx,yy]==[startx,starty]: startc=c if   range(y,y+2): blist[c].append([xx,yy]) if [xx,yy]==[startx,starty]: startc=c if [xx,yy]==[goalx,goaly]: goalc=c if  print  cl=[startx,starty] nc=blist[c] nc.remove(cl) ok=[cl] goal=[goalx,goaly] tansaku(cl,nc,ok,goal) if goal in ok: print \"OK\" else: print \"NG\""], "original_ll": -0.8774564862251282, "sampled_ll": -0.5174987316131592, "all_perturbed_sampled_ll": [-1.7938728332519531], "all_perturbed_original_ll": [-1.5247949361801147], "perturbed_sampled_ll": -1.7938728332519531, "perturbed_original_ll": -1.5247949361801147, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "long long table[8]={0,1,2,3,5,7,8,9},r;main(n,i){for(;scanf(\"%d\",&n),n;printf(\"%lld\\n\",r))for(r=0,i=1;n;n/=8,i*=10)r+=table[n&7]*i;exit(0);}", "sampled": "#include <stdio.h>\n\nlong long convert(long long n) {\n    long long result = 0;\n    long long base = 1;\n    \n    while (n > 0) {\n        long long digit = n % 10;\n        n /= 10;\n        \n        if (digit >= 4) digit++;\n        if (digit >= 6) digit++;\n        \n        result = digit * base + result;\n        base *= 10;\n    }\n    \n    return result;\n}\n\nlong long solve(long long n) {\n    long long left = 1, right = 10000000000LL;\n    long long answer = 1;\n    \n    while (left <= right) {\n        long long mid = left + (right - left) / 2;\n        long long converted = convert(mid);\n        \n        if (converted == n) {\n            return n;\n        } else if (converted < n) {\n            answer = converted;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return answer;\n}\n\nlong long count_valid(long long n) {\n    if (n == 0) return 0;\n    \n    long long result = 0;\n    long long power = 1;\n    long long temp = n;\n    int digits = 0;\n    \n    while (temp > 0) {\n        digits++;\n        temp /= 10;\n    }\n    \n    for (int d = 1; d < digits; d++) {\n        long long count = 1;\n        for (int i = 0; i < d; i++) {\n            count *= 8;\n        }\n        result += count;\n    }\n    \n    temp = n;\n    long long prefix = 0;\n    for (int pos = digits; pos >= 1; pos--) {\n        long long divisor = 1;\n        for (int i = 1; i < pos; i++) {\n            divisor *= 10;\n        }\n        \n        long long digit = temp / divisor;\n        temp %= divisor;\n        \n        long long count_before = digit;\n        if (digit > 4) count_before--;\n        if (digit > 6) count_before--;\n        \n        long long suffix_count = 1;\n        for (int i = 1; i < pos; i++) {\n            suffix_count *= 8;\n        }\n        \n        result += count_before * suffix_count;\n        \n        if (digit == 4 || digit == 6) {\n            return result;\n        }\n    }\n    \n    result++;\n    return result;\n}\n\nlong long find_nth(long long n) {\n    long long left = 1, right = 10000000000LL;\n    long long answer = 1;\n    \n    while (left <= right) {\n        long long mid = left + (right - left) / 2;\n        long long count = count_valid(mid);\n        \n        if (count == n) {\n            while (mid % 10 == 4 || mid % 10 == 6) {\n                mid--;\n            }\n            long long temp = mid;\n            int has_4_or_6 = 0;\n            while (temp > 0) {\n                int d = temp % 10;\n                if (d == 4 || d == 6) {\n                    has_4_or_6 = 1;\n                    break;\n                }\n                temp /= 10;\n            }\n            if (!has_4_or_6) {\n                return mid;\n            }\n            right = mid - 1;\n        } else if (count < n) {\n            left = mid + 1;\n        } else {\n            answer = mid;\n            right = mid - 1;\n        }\n    }\n    \n    while (left <= 10000000000LL) {\n        long long count = count_valid(left);\n        if (count == n) {\n            long long temp = left;\n            int has_4_or_6 = 0;\n            while (temp > 0) {\n                int d = temp % 10;\n                if (d == 4 || d == 6) {\n                    has_4_or_6 = 1;\n                    break;\n                }\n                temp /= 10;\n            }\n            if (!has_4_or_6) {\n                return left;\n            }\n        }\n        left++;\n    }\n    \n    return answer;\n}\n\nint main() {\n    long long n;\n    while (scanf(\"%lld\", &n) == 1 && n != 0) {\n        printf(\"%lld\\n\", find_nth(n));\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  { long long result =  1;  long  10; n /= 10; if (digit >= 4) digit++; if (digit >= 6) digit++;  + result; base *= 10; } return result; } long long solve(long long n) { long long left = 1, right = 10000000000LL; long long answer = 1; while (left  mid =  converted = convert(mid); if  (converted < n) { answer = converted; left = mid + 1; } else  1; } }   = 0; long long power  = 0; while (temp > 0) { digits++; temp /= 10; } for (int d = 1; d < digits; d++) { long long count = 1; for (int i = 0; i < d; i++) { count  count; } temp = n; long long prefix = 0; for (int pos = digits; pos >= 1; pos--) { long long divisor = 1; for (int i = 1; i < pos; i++) { divisor *= 10; } long long digit = temp / divisor; temp %= divisor; long long count_before =  count_before--; if (digit > 6) count_before--; long long suffix_count = 1; for (int i = 1; i < pos; i++) { suffix_count  count_before  4 || digit ==  } result++; return result; } long long find_nth(long long n) { long long left = 1, right  <= right) { long long mid  left) / 2; long long count = count_valid(mid); if (count == n)  == 4 || mid % 10 == 6) { mid--; } long long temp = mid; int has_4_or_6 = 0; while (temp > 0) { int d = temp % 10; if (d == 4 || d == 6) { has_4_or_6 = 1; break; } temp /= 10; } if (!has_4_or_6) { return mid; } right = mid - 1; } else if (count < n) { left = mid + 1; } else { answer  - 1; } } while (left <= 10000000000LL) { long long  long temp = left; int has_4_or_6 = 0; while (temp > 0)  % 10; if (d == 4 || d == 6) { has_4_or_6 = 1; break; } temp /= 10; } if (!has_4_or_6) { return left; }  } int main() { long long n; while (scanf(\"%lld\", &n) == 1 && n != 0) { printf(\"%lld\\n\", find_nth(n)); } return 0; }"], "perturbed_original": ["long long table[8]={0,1,2,3,5,7,8,9},r;main(n,i){for(;scanf(\"%d\",&n),n;printf(\"%lld\\n\",r))for(r=0,i=1;n;n/=8,i*=10)r+=table[n&7]*i;exit(0);}"], "original_ll": -1.901314616203308, "sampled_ll": -0.42996740341186523, "all_perturbed_sampled_ll": [-1.233994722366333], "all_perturbed_original_ll": [-1.901314616203308], "perturbed_sampled_ll": -1.233994722366333, "perturbed_original_ll": -1.901314616203308, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nimport java.util.regex.Pattern;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tPattern pattern = Pattern.compile(\"^4|^6\");\n\t\tPattern pattern2 = Pattern.compile(\".*4.*|.*6.*\");\n\n\t\twhile(true){\n\t\t\tlong oldNumber = stdIn.nextLong();\n\t\t\tlong newNumber = 0;\n\n\t\t\tif(oldNumber == 0){break;}\n\n\t\t\tint count = 0;\n\t\t\twhile(count < oldNumber){\n\t\t\t\tnewNumber++;\n\t\t\t\tString stringNewNumber = Long.toString(newNumber);\n\t\t\t\tif(pattern.matcher(stringNewNumber).find()){\n\t\t\t\t\tnewNumber += Math.pow(10, stringNewNumber.length()-1);\n\t\t\t\t}else if(pattern2.matcher(stringNewNumber).find()){\n\t\t\t\t\twhile(pattern2.matcher(Long.toString(newNumber)).find()){\n\t\t\t\t\t\tnewNumber++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tSystem.out.println(newNumber);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long n = sc.nextLong();\n            if (n == 0) break;\n            \n            System.out.println(convertToNewRoomNumber(n));\n        }\n        \n        sc.close();\n    }\n    \n    static long convertToNewRoomNumber(long oldNumber) {\n        long result = 0;\n        long multiplier = 1;\n        long remaining = oldNumber;\n        \n        while (remaining > 0) {\n            long digit = remaining % 10;\n            remaining /= 10;\n            \n            // Map digit to new system (base 8 excluding 4 and 6)\n            // 0->0, 1->1, 2->2, 3->3, 4->5, 5->7, 6->8, 7->9\n            long mappedDigit;\n            if (digit <= 3) {\n                mappedDigit = digit;\n            } else if (digit == 4) {\n                mappedDigit = 5;\n            } else if (digit == 5) {\n                mappedDigit = 7;\n            } else if (digit == 6) {\n                mappedDigit = 8;\n            } else {\n                mappedDigit = 9;\n            }\n            \n            result += mappedDigit * multiplier;\n            multiplier *= 10;\n        }\n        \n        return result;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { long n = sc.nextLong();  System.out.println(convertToNewRoomNumber(n)); } sc.close(); } static long convertToNewRoomNumber(long oldNumber) { long result = 0; long multiplier = 1; long remaining = oldNumber; while (remaining > 0) { long digit = remaining  // Map digit to new system (base 8 excluding 4 and 6) // 0->0, 1->1, 2->2, 3->3, 4->5, 5->7, 6->8, 7->9 long mappedDigit; if (digit <= 3) { mappedDigit = digit; } else if (digit ==  == 5) {  { mappedDigit = 8; } else { mappedDigit = 9; }  multiplier *= 10; } return result; } }"], "perturbed_original": ["import java.util.Scanner; import java.util.regex.Pattern; class Main{ public  stdIn = new Scanner(System.in); Pattern  = Pattern.compile(\".*4.*|.*6.*\"); while(true){ long oldNumber = stdIn.nextLong(); long newNumber = 0; if(oldNumber == 0){break;} int count = 0; while(count < oldNumber){ newNumber++; String stringNewNumber = Long.toString(newNumber); if(pattern.matcher(stringNewNumber).find()){ newNumber += Math.pow(10, stringNewNumber.length()-1); }else if(pattern2.matcher(stringNewNumber).find()){ while(pattern2.matcher(Long.toString(newNumber)).find()){ newNumber++; }  } }"], "original_ll": -0.9200530648231506, "sampled_ll": -0.595868706703186, "all_perturbed_sampled_ll": [-1.5058646202087402], "all_perturbed_original_ll": [-1.598502278327942], "perturbed_sampled_ll": -1.5058646202087402, "perturbed_original_ll": -1.598502278327942, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def testcase_ends():\n    n = int(input())\n    if n == 0:\n        return 1\n\n    n = oct(n)[2:]\n    n = n.replace('7', '9')\n    n = n.replace('6', '8')\n    n = n.replace('5', '7')\n    n = n.replace('4', '5')\n    print(n)\n    return 0\n\ndef main():\n    while not testcase_ends():\n        pass\n\nif __name__ == '__main__':\n    main()\n\n", "sampled": "def convert_to_new_room(n):\n    # Convert n to base-8 representation, treating digits 0-7 as valid\n    # Then map: 0->1, 1->2, 2->3, 3->5, 4->7, 5->8, 6->9, 7->10\n    # This is essentially converting to a number system without 4 and 6\n    \n    # First, convert n to base 8\n    if n == 0:\n        return 0\n    \n    result = 0\n    multiplier = 1\n    temp_n = n\n    \n    while temp_n > 0:\n        digit = temp_n % 8\n        temp_n //= 8\n        \n        # Map the digit (0-7 in base 8 concept) to actual digit without 4 and 6\n        # digit 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 5, 4 -> 7, 5 -> 8, 6 -> 9, 7 -> 10\n        if digit == 0:\n            mapped = 1\n        elif digit == 1:\n            mapped = 2\n        elif digit == 2:\n            mapped = 3\n        elif digit == 3:\n            mapped = 5\n        elif digit == 4:\n            mapped = 7\n        elif digit == 5:\n            mapped = 8\n        elif digit == 6:\n            mapped = 9\n        else:  # digit == 7\n            mapped = 10\n        \n        result += mapped * multiplier\n        multiplier *= 10\n    \n    return result\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(convert_to_new_room(n))\n", "perturbed_sampled": ["def convert_to_new_room(n): # Convert n to base-8 representation, treating digits 0-7 as valid # Then map: 0->1, 1->2, 2->3, 3->5,  This is essentially converting to a number system without 4 and 6 # First, convert n to base 8 if  result = 0 multiplier = 1  > 0: digit = temp_n % 8 temp_n //= 8 # Map the digit (0-7  actual digit without 4 and 6  1 ->  -> 5, 4 -> 7, 5 -> 8, 6 -> 9, 7  0: mapped  1: mapped = 2 elif digit == 2: mapped = 3 elif digit == 3: mapped = 5 elif digit == 4: mapped    9 else: # digit == 7 mapped = 10 result += mapped * multiplier multiplier *= 10 return result while True: n = int(input()) if n == 0: break print(convert_to_new_room(n))"], "perturbed_original": ["def testcase_ends(): n = int(input()) if n   '9') n = n.replace('6', '8') n = n.replace('5', '7') n = n.replace('4', '5') print(n) return 0 def main(): while not testcase_ends(): pass if __name__ == '__main__': main()"], "original_ll": -1.174167513847351, "sampled_ll": -0.745367705821991, "all_perturbed_sampled_ll": [-2.102013349533081], "all_perturbed_original_ll": [-2.078644037246704], "perturbed_sampled_ll": -2.102013349533081, "perturbed_original_ll": -2.078644037246704, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\n\ntypedef struct{\n  int x;\n  int y;\n  int ny;\n  int nx;\n  char dir;\n  int movable;\n}man;\ntypedef struct{\n  int x;\n  int y;\n}d;\n\nchar map[30][31];\nint w,h;\nman ms[900];\nint msize;\nd dir[4]={{1,0},{0,-1},{-1,0},{0,1}};\n//memo 0:east 1:north 2:west 3:south\nchar n2d(int d){\n  return d==0?'E':d==1?'N':d==2?'W':'S';\n}\nint d2n(char d){\n  return d=='E'?0:d=='N'?1:d=='W'?2:d=='S'?3:-1;\n}\nint main(){\n  int i,j,l,k,nx,ny;\n  do{\n    scanf(\"%d %d\",&w,&h);\n    if(w==0&&h==0) break;\n    msize=0;\n    for(i=0;i<h;i++){      \n      scanf(\"%s\",map+i);\n      for(j=0;j<w;j++){\n\tif(map[i][j]!='#'&&map[i][j]!='.'&&map[i][j]!='X'){\n\t  ms[msize].x=j;\n\t  ms[msize].y=i;\n\t  ms[msize].dir=d2n(map[i][j]);\n\t  msize++;\n\t}\n      }\n    }\n    for(i=1;i<181;i++){\n      /*            for(j=0;j<h;j++)\n\tprintf(\"%s\\n\",map+j);\n\tprintf(\"\\n\");*/\n      for(j=0;j<msize;j++){\n\tms[j].movable=0;\n\tfor(k=-1;k<3;k++){\n\t  ms[j].nx=ms[j].x+dir[(4+ms[j].dir+k)%4].x;\n\t  ms[j].ny=ms[j].y+dir[(4+ms[j].dir+k)%4].y;\n\t  if(map[ms[j].ny][ms[j].nx]=='X'){\n\t    ms[j].movable=1;\n\t    break;\t    \n\t  }else if(map[ms[j].ny][ms[j].nx]=='.'){\n\t    ms[j].dir=(4+ms[j].dir+k)%4;\n\t    ms[j].movable=1;\n\t    break;\n\t  }\t  \n\t}\n      }\n      for(j=0;j<msize;j++){\n\tif(map[ms[j].ny][ms[j].nx]!='X'&&ms[j].movable)\n\t  for(k=0;k<4;k++){\n\t    nx=ms[j].nx+dir[k].x;\n\t    ny=ms[j].ny+dir[k].y;\n\t    //\t    printf(\"(%d %d %c) \",ny,nx,map[ny][nx]);\n\t    if(isalpha(map[ny][nx])\n\t       &&map[ny][nx]!='X'\n\t       &&((d2n(map[ny][nx])+2)%4)==k){\n//\t      printf(\"%d %d %c\\n\",ny,nx,map[ny][nx]);\n\t      if(ms[j].x!=nx||ms[j].y!=ny){\n\t\tms[j].movable=0;\t\t\n\t      }\n\t      break;\n\t    }else if(ms[j].x==nx&&ms[j].y==ny){\n\t      map[ms[j].y][ms[j].x]=n2d(ms[j].dir);\n\t      break;\n\t    }\n\t  }\n\t//\tprintf(\"\\n\");\n      }\n      for(j=0;j<msize;j++){\n\tif(map[ms[j].ny][ms[j].nx]=='X'){\n\t  map[ms[j].y][ms[j].x]='.';\n\t  for(l=j;l<msize;l++){\n\t    ms[l]=ms[l+1];\n\t  }\t    \n\t  j--;\n\t  msize--;\n\t}else if(ms[j].movable){\n\t  map[ms[j].y][ms[j].x]='.';\n\t  map[ms[j].ny][ms[j].nx]=n2d(ms[j].dir);\n\t  ms[j].x=ms[j].nx;\n\t  ms[j].y=ms[j].ny;\n\t}\n      }\n      if(msize==0){\n\tprintf(\"%d\\n\",i);\n\tbreak;\n      }\n    }\n    if(i==181)\n      printf(\"NA\\n\");\n  }while(1);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 30\n\ntypedef struct {\n    int x, y;\n    char dir;\n} Person;\n\nchar grid[MAX][MAX];\nint W, H;\nPerson people[MAX*MAX];\nint num_people;\n\nint dx[] = {1, 0, -1, 0}; // E, N, W, S\nint dy[] = {0, -1, 0, 1};\nchar dirs[] = \"ENWS\";\n\nint get_dir_idx(char d) {\n    for(int i = 0; i < 4; i++) {\n        if(dirs[i] == d) return i;\n    }\n    return 0;\n}\n\nint is_passable(int x, int y) {\n    if(x < 0 || x >= W || y < 0 || y >= H) return 0;\n    return grid[y][x] == '.' || grid[y][x] == 'X';\n}\n\nvoid simulate() {\n    int time = 0;\n    \n    while(num_people > 0 && time <= 180) {\n        time++;\n        \n        // Step 1: Change direction\n        for(int i = 0; i < num_people; i++) {\n            int dir_idx = get_dir_idx(people[i].dir);\n            int found = 0;\n            \n            // Check right, front, left, back\n            int order[] = {(dir_idx + 3) % 4, dir_idx, (dir_idx + 1) % 4, (dir_idx + 2) % 4};\n            \n            for(int j = 0; j < 4; j++) {\n                int d = order[j];\n                int nx = people[i].x + dx[d];\n                int ny = people[i].y + dy[d];\n                \n                if(is_passable(nx, ny)) {\n                    people[i].dir = dirs[d];\n                    found = 1;\n                    break;\n                }\n            }\n        }\n        \n        // Step 2: Move\n        int target_count[MAX][MAX];\n        int target_who[MAX][MAX][4];\n        memset(target_count, 0, sizeof(target_count));\n        \n        for(int i = 0; i < num_people; i++) {\n            int dir_idx = get_dir_idx(people[i].dir);\n            int nx = people[i].x + dx[dir_idx];\n            int ny = people[i].y + dy[dir_idx];\n            \n            if(is_passable(nx, ny)) {\n                target_who[ny][nx][target_count[ny][nx]++] = i;\n            }\n        }\n        \n        int moved[MAX*MAX];\n        memset(moved, 0, sizeof(moved));\n        \n        for(int y = 0; y < H; y++) {\n            for(int x = 0; x < W; x++) {\n                if(target_count[y][x] > 1) {\n                    // Multiple people want this spot\n                    // Priority: E, N, W, S of the target\n                    int priority_order[] = {0, 1, 2, 3}; // E, N, W, S\n                    int selected = -1;\n                    \n                    for(int p = 0; p < 4; p++) {\n                        int check_x = x - dx[priority_order[p]];\n                        int check_y = y - dy[priority_order[p]];\n                        \n                        for(int k = 0; k < target_count[y][x]; k++) {\n                            int who = target_who[y][x][k];\n                            if(people[who].x == check_x && people[who].y == check_y) {\n                                selected = who;\n                                break;\n                            }\n                        }\n                        if(selected != -1) break;\n                    }\n                    \n                    if(selected != -1) {\n                        moved[selected] = 1;\n                    }\n                } else if(target_count[y][x] == 1) {\n                    moved[target_who[y][x][0]] = 1;\n                }\n            }\n        }\n        \n        // Apply moves\n        for(int i = 0; i < num_people; i++) {\n            if(moved[i]) {\n                int dir_idx = get_dir_idx(people[i].dir);\n                people[i].x += dx[dir_idx];\n                people[i].y += dy[dir_idx];\n            }\n        }\n        \n        // Remove people at exits\n        int new_num = 0;\n        for(int i = 0; i < num_people; i++) {\n            if(grid[people[i].y][people[i].x] != 'X') {\n                people[new_num++] = people[i];\n            }\n        }\n        num_people = new_num;\n    }\n    \n    if(num_people == 0) {\n        printf(\"%d\\n\", time);\n    } else {\n        printf(\"NA\\n\");\n    }\n}\n\nint main() {\n    while(1) {\n        scanf(\"%d %d\", &W, &H);\n        if(W == 0 && H == 0) break;\n        \n        num_people = 0;\n        for(int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n            for(int j = 0; j < W; j++) {\n                if(grid[i][j] == 'E' || grid[i][j] == 'N' || \n                   grid[i][j] == 'W' || grid[i][j] == 'S') {\n                    people[num_people].x = j;\n                    people[num_people].y = i;\n                    people[num_people].dir = grid[i][j];\n                    num_people++;\n                    grid[i][j] = '.';\n                }\n            }\n        }\n        \n        simulate();\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #define MAX 30 typedef struct { int x, y; char dir; } Person; char grid[MAX][MAX]; int W, H;  dx[] = {1, 0, -1, 0}; // E, N, W, S int dy[] = {0, -1, 0, 1}; char dirs[] =  for(int i = 0; i < 4; i++) { if(dirs[i] == d) return i; } return 0; } int is_passable(int x, int y) { if(x < 0 || x >=  || y >= H) return 0; return grid[y][x] == '.' || grid[y][x] == 'X'; } void simulate() { int time = 0; while(num_people > 0 && time <= 180) { time++; // Step 1:  0; i < num_people; i++) { int dir_idx = get_dir_idx(people[i].dir); int found = 0; // Check  order[] = {(dir_idx +  + 1) %   j < 4; j++) { int d   = people[i].y + dy[d]; if(is_passable(nx, ny)) { people[i].dir = dirs[d]; found = 1; break; } } } // Step 2: Move int target_count[MAX][MAX]; int target_who[MAX][MAX][4]; memset(target_count, 0, sizeof(target_count)); for(int i = 0; i < num_people;  get_dir_idx(people[i].dir); int nx = people[i].x + dx[dir_idx]; int ny = people[i].y + dy[dir_idx]; if(is_passable(nx, ny)) { target_who[ny][nx][target_count[ny][nx]++] = i; } } int moved[MAX*MAX]; memset(moved, 0, sizeof(moved)); for(int y = 0; y < H; y++) { for(int x = 0; x < W; x++) { if(target_count[y][x] > 1) { // Multiple people want this spot // Priority: E, N, W, S of the target int priority_order[]  // E, N, W, S int selected = -1; for(int p = 0; p <  = x  k = 0; k < target_count[y][x]; k++)  people[who].y == check_y) {  } if(selected != -1) break; } if(selected != -1)  1) { moved[target_who[y][x][0]] = 1; } } }  = 0; i  { int dir_idx = get_dir_idx(people[i].dir); people[i].x += dx[dir_idx]; people[i].y += dy[dir_idx]; } } // Remove people at exits int  = 0; i  !=  } } num_people  0) { printf(\"%d\\n\", time);  } int main() { while(1)  if(W == 0 && H ==  for(int i = 0; i < H; i++) { scanf(\"%s\", grid[i]); for(int j  j++) { if(grid[i][j] == 'E' || grid[i][j] == 'N' || grid[i][j] == 'W' || grid[i][j] == 'S') { people[num_people].x = j; people[num_people].y = i; people[num_people].dir = grid[i][j]; num_people++; grid[i][j] = '.'; }  0; }"], "perturbed_original": ["#include<stdio.h> typedef struct{ int x; int y; int ny; int nx;  typedef  }d; char map[30][31]; int w,h; man ms[900]; int  1:north 2:west 3:south char n2d(int d){ return d==0?'E':d==1?'N':d==2?'W':'S'; } int d2n(char d){ return d=='E'?0:d=='N'?1:d=='W'?2:d=='S'?3:-1;  do{ scanf(\"%d %d\",&w,&h); if(w==0&&h==0)  if(map[i][j]!='#'&&map[i][j]!='.'&&map[i][j]!='X'){ ms[msize].x=j; ms[msize].y=i; ms[msize].dir=d2n(map[i][j]); msize++; } } } for(i=1;i<181;i++){ /* for(j=0;j<h;j++) printf(\"%s\\n\",map+j); printf(\"\\n\");*/ for(j=0;j<msize;j++){ ms[j].movable=0; for(k=-1;k<3;k++){ ms[j].nx=ms[j].x+dir[(4+ms[j].dir+k)%4].x; ms[j].ny=ms[j].y+dir[(4+ms[j].dir+k)%4].y; if(map[ms[j].ny][ms[j].nx]=='X'){ ms[j].movable=1; break;  } } } for(j=0;j<msize;j++){ if(map[ms[j].ny][ms[j].nx]!='X'&&ms[j].movable) for(k=0;k<4;k++){ nx=ms[j].nx+dir[k].x; ny=ms[j].ny+dir[k].y; // printf(\"(%d %d %c) \",ny,nx,map[ny][nx]); if(isalpha(map[ny][nx]) &&map[ny][nx]!='X' &&((d2n(map[ny][nx])+2)%4)==k){ // printf(\"%d %d %c\\n\",ny,nx,map[ny][nx]); if(ms[j].x!=nx||ms[j].y!=ny){ ms[j].movable=0; } break; }else if(ms[j].x==nx&&ms[j].y==ny){ map[ms[j].y][ms[j].x]=n2d(ms[j].dir); break; } } // printf(\"\\n\"); } for(j=0;j<msize;j++){ if(map[ms[j].ny][ms[j].nx]=='X'){ map[ms[j].y][ms[j].x]='.'; for(l=j;l<msize;l++){ ms[l]=ms[l+1]; } j--; msize--; }else if(ms[j].movable){ map[ms[j].y][ms[j].x]='.'; map[ms[j].ny][ms[j].nx]=n2d(ms[j].dir); ms[j].x=ms[j].nx; ms[j].y=ms[j].ny;  }while(1); return 0; }"], "original_ll": -0.7496730089187622, "sampled_ll": -0.48740828037261963, "all_perturbed_sampled_ll": [-1.332823395729065], "all_perturbed_original_ll": [-1.0684109926223755], "perturbed_sampled_ll": -1.332823395729065, "perturbed_original_ll": -1.0684109926223755, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n\tint [] vx = {1,0,-1,0};\n\tint [] vy = {0,-1,0,1};\n\tboolean [] isgoal;\n\t\n\tclass C{\n\t\tint x,y,dir;\n\t\tpublic C(int x, int y, int dir) {\n\t\t\tthis.x = x;this.y = y;\n\t\t\tif(dir == 'E')\n\t\t\t\tdir = 0;\n\t\t\telse if(dir == 'N')\n\t\t\t\tdir = 1;\n\t\t\telse if(dir == 'S')\n\t\t\t\tdir = 3;\n\t\t\telse if(dir == 'W')\n\t\t\t\tdir = 2;\n\t\t\telse{\n\t\t\t\t\n\t\t\t}\n\t\t\tthis.dir = dir;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", dir=\" + dir + \"]\";\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tchar [][] map = new char[h][w];\n\t\t\tArrayList<C> humlist = new ArrayList<C>();\n\t\t\tfor(int i=0; i < h;i++){\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=0; j < w;j++){\n\t\t\t\t\tchar c = line.charAt(j);\n\t\t\t\t\tif(c == 'E' || c == 'N' || c == 'W' || c == 'S'){\n\t\t\t\t\t\thumlist.add(new C(j,i,(int)c));\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[i][j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//debug\n//\t\t\tfor(int i=0; i < h; i++){\n//\t\t\t\tfor(int j = 0; j < w; j++){\n//\t\t\t\t\tSystem.out.print(map[i][j]);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\tSystem.out.println(\"list= \" + humlist.toString());\n\t\t\tint step = 0;\n\t\t\tLinkedList<Integer> open = new LinkedList<Integer>();\n\t\t\topen.add(step);\n\t\t\tint len = humlist.size();\n\t\t\tisgoal = new boolean[len];\n\t\t\tboolean isachieve = true;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tstep = open.removeFirst();\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(humlist.toString());\n\t\t\t\t//change dir\n\t\t\t\tfor(int i = 0; i < len;i++){\n\t\t\t\t\tif(isgoal[i])continue;\n\t\t\t\t\tC nowhum = humlist.get(i);\n\t\t\t\t\tint nowdir = nowhum.dir;\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tnowdir = (j + 4 + nowhum.dir - 1) % 4;\n\t\t\t\t\t\tint xx = nowhum.x + vx[nowdir];\n\t\t\t\t\t\tint yy = nowhum.y + vy[nowdir];\n\t\t\t\t\t\tif(map[yy][xx] == '#') continue;\n\t\t\t\t\t\tif((map[yy][xx] == 'X' || map[yy][xx] == '.') && ! isin(xx,yy,humlist)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnowhum.dir = nowdir;\n\t\t\t\t\thumlist.set(i, nowhum);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//move\n\t\t\t\tArrayList<C> humlistrecord = valueC(humlist);\n\t\t\t\tfor(int i=0; i < len; i++){\n\t\t\t\t\tif(isgoal[i]) continue;\n\t\t\t\t\tC nowhum = humlist.get(i);\n\t\t\t\t\tint xx = nowhum.x + vx[nowhum.dir];\n\t\t\t\t\tint yy = nowhum.y + vy[nowhum.dir];\n\t\t\t\t\tif(map[yy][xx] == '#' || isin(xx,yy,humlist)) continue;\n\t\t\t\t\tint movehum = getmove(xx,yy,humlistrecord);\n\t\t\t\t\tif(movehum == i){\n\t\t\t\t\t\tnowhum.x = xx;\n\t\t\t\t\t\tnowhum.y = yy;\n\t\t\t\t\t\thumlist.set(i, nowhum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//escape\n\t\t\t\tfor(int i = 0; i < len;i++){\n\t\t\t\t\tC nowhum = humlist.get(i);\n\t\t\t\t\tint humx = nowhum.x,humy = nowhum.y;\n\t\t\t\t\tif(map[humy][humx] == 'X'){\n\t\t\t\t\t\tisgoal[i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//fin\n\t\t\t\tif(isAllGoal()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(step + 1 > 180){\n\t\t\t\t\tisachieve = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\topen.add(step + 1);\n\t\t\t}\n\t\t\tif(isachieve){\n\t\t\t\tif(humlist.size() == 0){\n\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(step + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean isAllGoal(){\n\t\tfor(int i=0; i < isgoal.length;i++){\n\t\t\tif(! isgoal[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate int getmove(int x, int y, ArrayList<C> list){\n\t\tfor(int i=0; i < 4;i++){\n\t\t\tint xx = x + vx[i];\n\t\t\tint yy = y + vy[i];\n\t\t\tfor(int j=0; j < list.size(); j++){\n\t\t\t\tif(isgoal[j])continue;\n\t\t\t\tC now = list.get(j);\n\t\t\t\tboolean cond1 = (xx == now.x && yy == now.y);\n\t\t\t\tboolean cond2 = ((now.x + vx[now.dir]) == x && (now.y + vy[now.dir]) == y);\n\t\t\t\tif(cond1 && cond2){\n\t\t\t\t\treturn j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprivate ArrayList<C> valueC(ArrayList<C> list){\n\t\tArrayList<C> res =  new ArrayList<C>();\n\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\tC now = list.get(i);\n\t\t\tres.add(new C(now.x, now.y, now.dir));\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tprivate boolean isin(int x, int y,ArrayList<C> list){\n\t\tfor(int i=0; i < list.size();i++){\n\t\t\tif(isgoal[i])continue;\n\t\t\tC now = list.get(i);\n\t\t\tif(now.x == x && now.y == y){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Person {\n        int x, y;\n        char dir;\n        \n        Person(int x, int y, char dir) {\n            this.x = x;\n            this.y = y;\n            this.dir = dir;\n        }\n    }\n    \n    static int[] dx = {1, 0, -1, 0}; // E, N, W, S\n    static int[] dy = {0, -1, 0, 1};\n    static Map<Character, Integer> dirMap = new HashMap<>();\n    \n    static {\n        dirMap.put('E', 0);\n        dirMap.put('N', 1);\n        dirMap.put('W', 2);\n        dirMap.put('S', 3);\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\" \");\n            int W = Integer.parseInt(parts[0]);\n            int H = Integer.parseInt(parts[1]);\n            \n            if (W == 0 && H == 0) break;\n            \n            char[][] grid = new char[H][W];\n            List<Person> people = new ArrayList<>();\n            \n            for (int i = 0; i < H; i++) {\n                String str = br.readLine();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = str.charAt(j);\n                    if (dirMap.containsKey(grid[i][j])) {\n                        people.add(new Person(j, i, grid[i][j]));\n                        grid[i][j] = '.';\n                    }\n                }\n            }\n            \n            int result = simulate(grid, people, W, H);\n            if (result > 180) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n    }\n    \n    static int simulate(char[][] grid, List<Person> people, int W, int H) {\n        int time = 0;\n        \n        while (!people.isEmpty() && time <= 180) {\n            time++;\n            \n            // Step 1: Update directions\n            for (Person p : people) {\n                int currentDir = dirMap.get(p.dir);\n                int[] checkOrder = {(currentDir + 3) % 4, currentDir, (currentDir + 1) % 4, (currentDir + 2) % 4};\n                \n                for (int d : checkOrder) {\n                    int nx = p.x + dx[d];\n                    int ny = p.y + dy[d];\n                    \n                    if (nx >= 0 && nx < W && ny >= 0 && ny < H && \n                        (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) {\n                        p.dir = getDir(d);\n                        break;\n                    }\n                }\n            }\n            \n            // Step 2: Determine moves\n            Map<String, List<Person>> targetMap = new HashMap<>();\n            \n            for (Person p : people) {\n                int d = dirMap.get(p.dir);\n                int nx = p.x + dx[d];\n                int ny = p.y + dy[d];\n                \n                if (nx >= 0 && nx < W && ny >= 0 && ny < H && \n                    (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) {\n                    String key = nx + \",\" + ny;\n                    targetMap.putIfAbsent(key, new ArrayList<>());\n                    targetMap.get(key).add(p);\n                }\n            }\n            \n            // Step 3: Move people\n            Set<Person> toRemove = new HashSet<>();\n            \n            for (String key : targetMap.keySet()) {\n                List<Person> candidates = targetMap.get(key);\n                \n                if (candidates.size() == 1) {\n                    Person p = candidates.get(0);\n                    String[] coords = key.split(\",\");\n                    p.x = Integer.parseInt(coords[0]);\n                    p.y = Integer.parseInt(coords[1]);\n                    \n                    if (grid[p.y][p.x] == 'X') {\n                        toRemove.add(p);\n                    }\n                } else {\n                    // Priority: E, N, W, S (by position of source)\n                    Person selected = null;\n                    int[] priority = {0, 1, 2, 3}; // E, N, W, S\n                    \n                    for (int pri : priority) {\n                        for (Person p : candidates) {\n                            int d = dirMap.get(p.dir);\n                            if (d == pri) {\n                                selected = p;\n                                break;\n                            }\n                        }\n                        if (selected != null) break;\n                    }\n                    \n                    if (selected != null) {\n                        String[] coords = key.split(\",\");\n                        selected.x = Integer.parseInt(coords[0]);\n                        selected.y = Integer.parseInt(coords[1]);\n                        \n                        if (grid[selected.y][selected.x] == 'X') {\n                            toRemove.add(selected);\n                        }\n                    }\n                }\n            }\n            \n            people.removeAll(toRemove);\n        }\n        \n        return time;\n    }\n    \n    static char getDir(int d) {\n        switch (d) {\n            case 0: return 'E';\n            case 1: return 'N';\n            case 2: return 'W';\n            case 3: return 'S';\n        }\n        return 'E';\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main  int x,  int y, char dir) { this.x = x; this.y = y; this.dir = dir; } } static int[] dx = {1, 0, -1, 0}; // E, N, W, S static int[] dy = {0, -1, 0, 1}; static Map<Character, Integer> dirMap = new HashMap<>(); static { dirMap.put('E', 0); dirMap.put('N', 1); dirMap.put('W', 2); dirMap.put('S', 3); } public static void main(String[] args) throws IOException    { String[] parts = line.trim().split(\"  int H = Integer.parseInt(parts[1]); if (W == 0 && H == 0) break; char[][] grid = new char[H][W]; List<Person> people = new ArrayList<>(); for (int i = 0; i < H; i++) { String str = br.readLine(); for (int j = 0; j  = str.charAt(j); if (dirMap.containsKey(grid[i][j])) {   int result = simulate(grid, people, W, H); if (result > 180) { System.out.println(\"NA\"); } else { System.out.println(result); } } } static int  int  && time <= 180) { time++; // Step 1: Update directions for (Person p : people)  int[] checkOrder =  currentDir, (currentDir + 1) % 4, (currentDir + 2) % 4}; for (int d : checkOrder) { int nx = p.x + dx[d]; int ny = p.y + dy[d]; if (nx >= 0 &&  >= 0 && ny < H && (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) { p.dir = getDir(d); break; } } } //  List<Person>> targetMap = new HashMap<>(); for (Person p : people) { int d = dirMap.get(p.dir); int nx = p.x + dx[d]; int ny = p.y + dy[d];  nx < W && ny >= 0 && ny < H && (grid[ny][nx] == '.'  String key =  targetMap.putIfAbsent(key, new ArrayList<>()); targetMap.get(key).add(p); } } // Step  = new HashSet<>(); for (String key : targetMap.keySet()) { List<Person> candidates = targetMap.get(key); if (candidates.size()  = key.split(\",\"); p.x = Integer.parseInt(coords[0]); p.y = Integer.parseInt(coords[1]); if (grid[p.y][p.x] ==   position of source) Person selected = null; int[] priority = {0, 1, 2, 3}; // E, N, W, S for (int pri : priority) { for (Person p : candidates) {  (d == pri) { selected = p; break; } } if (selected != null) break; } if (selected != null) { String[] coords = key.split(\",\"); selected.x = Integer.parseInt(coords[0]); selected.y = Integer.parseInt(coords[1]); if (grid[selected.y][selected.x] == 'X') { toRemove.add(selected);  { switch (d) { case 0:  'S'; } return 'E'; } }"], "perturbed_original": ["import java.util.*; public class Main { int [] vx = {1,0,-1,0}; int  [] isgoal; class C{  int y, int dir) { this.x = x;this.y = y; if(dir == 'E') dir = 0; else if(dir  else if(dir == 'S') dir = 3; else if(dir   } public String toString() { return \"C [x=\" + x + \", y=\" + y + \", dir=\" + dir + \"]\"; } }  Scanner(System.in); while(true){ int w = sc.nextInt(), h = sc.nextInt(); if((w|h) == 0) break;  char[h][w]; ArrayList<C> humlist =  = sc.next(); for(int j=0; j < w;j++){   'N' ||  == 'S'){ humlist.add(new C(j,i,(int)c)); map[i][j] = '.'; } else{ map[i][j] = c; } }  i=0; i < h; i++){ // for(int j  j++){ // System.out.print(map[i][j]); // } // System.out.println(); // } // System.out.println(); // System.out.println(\"list= \" + humlist.toString()); int  = new LinkedList<Integer>(); open.add(step);  = new boolean[len]; boolean isachieve = true; while(! open.isEmpty()){ step = open.removeFirst(); //debug //System.out.println(humlist.toString()); //change dir for(int i = 0; i < len;i++){ if(isgoal[i])continue; C nowhum = humlist.get(i);  j = 0; j < 4; j++){ nowdir  nowhum.dir - 1) % 4; int xx = nowhum.x + vx[nowdir]; int yy = nowhum.y + vy[nowdir]; if(map[yy][xx] == '#') continue; if((map[yy][xx]  '.') &&  nowhum.dir = nowdir; humlist.set(i, nowhum); } //move ArrayList<C> humlistrecord = valueC(humlist); for(int i=0; i <  nowhum = humlist.get(i); int xx = nowhum.x +  + vy[nowhum.dir]; if(map[yy][xx] == '#' || isin(xx,yy,humlist)) continue; int movehum = getmove(xx,yy,humlistrecord); if(movehum == i){ nowhum.x = xx; nowhum.y = yy; humlist.set(i, nowhum);  = 0; i < len;i++){ C nowhum = humlist.get(i); int humx = nowhum.x,humy = nowhum.y; if(map[humy][humx] == 'X'){ isgoal[i] = true; } } //fin if(isAllGoal()){ break; } if(step + 1 > 180){ isachieve = false; break; } open.add(step + 1); } if(isachieve){ if(humlist.size() ==  + 1); } } else{ System.out.println(\"NA\"); } } } private boolean isAllGoal(){ for(int i=0; i < isgoal.length;i++){ if(! isgoal[i]) return false; } return true; } private int getmove(int x, int y, ArrayList<C> list){ for(int i=0; i < 4;i++){ int  int yy = y + vy[i]; for(int j=0;  C now =  == now.x && yy == now.y); boolean  == x && (now.y + vy[now.dir]) == y); if(cond1 && cond2){  return -1; } private ArrayList<C> valueC(ArrayList<C> list){ ArrayList<C> res = new ArrayList<C>(); for(int i = 0; i < list.size(); i++){ C now =  } return res; } private boolean isin(int x, int y,ArrayList<C> list){ for(int i=0; i <  list.get(i); if(now.x == x && now.y == y){ return true;  args) {  obj.doit(); } }"], "original_ll": -0.6564801335334778, "sampled_ll": -0.4019593298435211, "all_perturbed_sampled_ll": [-1.3060880899429321], "all_perturbed_original_ll": [-1.6555808782577515], "perturbed_sampled_ll": -1.3060880899429321, "perturbed_original_ll": -1.6555808782577515, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\ndirection = {'N' : 0, 'E' : 1, 'S' : 2, 'W' : 3}\nstep = [( -1, 0 ), ( 0, 1 ), ( 1, 0 ), ( 0, -1 )]\nvv = []\n\nwhile True:\n    W, H = map( int, sys.stdin.readline().rstrip().split() )\n    if W == 0 and H == 0: break\n    m = [ list( sys.stdin.readline().strip() ) for i in xrange( H ) ]\n    people = [ ( i, j, direction[ m[i][j] ] ) for i in xrange( H ) for j in range( W )\n               if m[i][j] in \"NESW\" ]\n    time = 0\n    while any( people ):\n        time += 1\n        if time > 180:\n            time = -1\n            break\n        sched = []\n        for n in xrange( len( people ) ):\n            if people[n] is None: continue\n            x, y, d = people[n]\n            for i in range(1, -3, -1):\n                    dx, dy = step[(d + i) % 4]\n                    if 0 <= x+dx < H and 0 <= y+dy < W and m[x+dx][y+dy] in \"X.\":\n                        people[n][2] = (d + i) % 4\n                        beat = True\n                        for k in range( len( sched ) ):\n                            xx, yy, dd = sched[k][1:]\n                            if ( x+dx, y+dy ) == ( xx, yy ):\n                                if dd < (d + i) % 4:\n                                    sched[k] = ( n, x+dx, y+dy, (d + i) % 4 )\n                                    beat = False\n                                    break\n                                else:\n                                    beat = False\n                                    break\n                        if beat:\n                            sched.append( ( n, x+dx, y+dy, (d + i) % 4 ) )\n\t\t\tbreak\n        for ( k, x, y, d ) in sched:\n            m[ people[k][0] ][ people[k][1] ] = '.'\n            if m[x][y] == 'X':\n                people[k] = None\n            else:\n                m[x][y] = 'H'\n                people[k] = x, y, d\n    if time >= 0:\n        vv.append(time)\n    else:\n        vv.append('NA')\n\nfor v in vv:\n    print v", "sampled": "from collections import deque\n\ndef solve():\n    while True:\n        W, H = map(int, input().split())\n        if W == 0 and H == 0:\n            break\n        \n        grid = []\n        people = []\n        \n        for i in range(H):\n            row = input().strip()\n            grid.append(list(row))\n            for j in range(len(row)):\n                if row[j] in 'ENSW':\n                    people.append([i, j, row[j]])\n                    grid[i][j] = '.'\n        \n        # Direction mappings\n        dir_map = {\n            'E': (0, 1),\n            'W': (0, -1),\n            'N': (-1, 0),\n            'S': (1, 0)\n        }\n        \n        dir_names = ['E', 'W', 'N', 'S']\n        \n        # Right, front, left, back relative to current direction\n        turn_order = {\n            'E': ['S', 'E', 'N', 'W'],\n            'W': ['N', 'W', 'S', 'E'],\n            'N': ['E', 'N', 'W', 'S'],\n            'S': ['W', 'S', 'E', 'N']\n        }\n        \n        time = 0\n        \n        while people and time <= 180:\n            # Step 1: Update directions\n            new_people = []\n            for person in people:\n                r, c, facing = person\n                \n                # Check right, front, left, back\n                found_dir = None\n                for check_dir in turn_order[facing]:\n                    dr, dc = dir_map[check_dir]\n                    nr, nc = r + dr, c + dc\n                    \n                    if 0 <= nr < H and 0 <= nc < W:\n                        cell = grid[nr][nc]\n                        if cell == '.' or cell == 'X':\n                            # Check if occupied by another person\n                            occupied = False\n                            for other in people:\n                                if other[0] == nr and other[1] == nc:\n                                    occupied = True\n                                    break\n                            \n                            if not occupied:\n                                found_dir = check_dir\n                                break\n                \n                if found_dir:\n                    new_people.append([r, c, found_dir])\n                else:\n                    new_people.append([r, c, facing])\n            \n            people = new_people\n            \n            # Step 2: Move people\n            # Calculate target positions for each person\n            targets = {}\n            for idx, person in enumerate(people):\n                r, c, facing = person\n                dr, dc = dir_map[facing]\n                nr, nc = r + dr, c + dc\n                \n                if 0 <= nr < H and 0 <= nc < W:\n                    cell = grid[nr][nc]\n                    if cell == '.' or cell == 'X':\n                        if (nr, nc) not in targets:\n                            targets[(nr, nc)] = []\n                        targets[(nr, nc)].append((idx, r, c))\n            \n            # Resolve conflicts\n            moved = set()\n            new_people = []\n            \n            for target, candidates in targets.items():\n                if len(candidates) == 1:\n                    idx, r, c = candidates[0]\n                    moved.add(idx)\n                else:\n                    # Priority: E, N, W, S\n                    priority_order = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n                    tr, tc = target\n                    \n                    selected = None\n                    for dr, dc in priority_order:\n                        sr, sc = tr - dr, tc - dc\n                        for idx, r, c in candidates:\n                            if r == sr and c == sc:\n                                selected = idx\n                                break\n                        if selected is not None:\n                            break\n                    \n                    if selected is not None:\n                        moved.add(selected)\n            \n            # Update people positions\n            final_people = []\n            for idx, person in enumerate(people):\n                r, c, facing = person\n                if idx in moved:\n                    dr, dc = dir_map[facing]\n                    nr, nc = r + dr, c + dc\n                    \n                    # Check if it's an exit\n                    if grid[nr][nc] == 'X':\n                        # Person escapes\n                        continue\n                    else:\n                        final_people.append([nr, nc, facing])\n                else:\n                    final_people.append([r, c, facing])\n            \n            people = final_people\n            time += 1\n        \n        if people:\n            print(\"NA\")\n        else:\n            print(time)\n\nsolve()\n", "perturbed_sampled": ["from collections import deque def solve(): while True: W, H = map(int, input().split()) if W == 0 and H == 0: break grid = [] people = [] for i in range(H): row = input().strip() grid.append(list(row)) for j in range(len(row)): if row[j] in 'ENSW': people.append([i, j, row[j]]) grid[i][j] = '.' # Direction mappings dir_map = { 'E': (0, 1), 'W': (0,  (1, 0) } dir_names = ['E', 'W', 'N', 'S'] # Right, front, left, back relative to current direction turn_order = { 'E': ['S', 'E', 'N', 'W'], 'W': ['N', 'W', 'S',  'S'], 'S': ['W', 'S', 'E', 'N'] } time = 0 while people and time <= 180: # Step 1: Update directions new_people = [] for person in people: r, c,  right, front, left, back found_dir = None for check_dir in turn_order[facing]: dr, dc = dir_map[check_dir] nr, nc = r + dr, c + dc if 0 <= nr < H and 0 <= nc < W: cell = grid[nr][nc] if cell == '.' or  and  True break if not occupied: found_dir = check_dir break  else: new_people.append([r, c, facing]) people = new_people  # Calculate target positions for each person targets = {} for  c, facing = person dr, dc =  dc if  and 0 <= nc < W: cell = grid[nr][nc] if cell == '.'  (nr, nc) not in targets: targets[(nr,  r, c)) # Resolve conflicts moved = set() new_people = [] for target, candidates in  idx, r, c = candidates[0] moved.add(idx) else: # Priority: E, N, W, S  0), (0,  = target selected = None for dr, dc in priority_order: sr, sc = tr - dr, tc - dc for idx, r, c in candidates: if r  break if selected is not None: break if selected  Update people positions final_people = [] for idx, person in enumerate(people): r, c, facing = person if idx in moved: dr, dc = dir_map[facing]  dr, c  grid[nr][nc] == 'X': # Person escapes continue else: final_people.append([nr, nc, facing]) else: final_people.append([r, c, facing]) people = final_people time  else: print(time) solve()"], "perturbed_original": ["import sys direction = {'N' : 0, 'E' : 1, 'S' : 2,  [( -1, 0 ), ( 0, 1 ), ( 1, 0 ),  = [] while True: W, H = map( int, sys.stdin.readline().rstrip().split() ) if W == 0 and H == 0: break m =  i in xrange( H ) ] people = [ ( i, j, direction[ m[i][j] ] ) for i in xrange( H ) for j in range( W ) if  = 0 while any( people ): time += 1 if time > 180: time = -1 break sched = [] for n in xrange( len( people ) ): if people[n] is  in range(1, -3, -1): dx, dy = step[(d + i) % 4] if 0 <= x+dx < H  W and m[x+dx][y+dy] in \"X.\": people[n][2] = (d + i) % 4 beat = True   == ( xx, yy ): if dd  4: sched[k] = ( n, x+dx, y+dy, (d + i) % 4 )   beat: sched.append( ( n, x+dx,  for ( k, x, y, d  ][ people[k][1] ] = '.' if m[x][y] == 'X': people[k] = None else: m[x][y] = 'H' people[k] = x, y, d if time >= 0: vv.append(time) else: vv.append('NA') for v in vv: print v"], "original_ll": -0.8710459470748901, "sampled_ll": -0.6236153244972229, "all_perturbed_sampled_ll": [-1.8389514684677124], "all_perturbed_original_ll": [-1.9659615755081177], "perturbed_sampled_ll": -1.8389514684677124, "perturbed_original_ll": -1.9659615755081177, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#define N 10\ntypedef unsigned long long int INT;\nINT GCD(INT a, INT b){\n\tif( b == 0 ) return a;\n\telse return GCD(b,a%b);\n}\nINT LCM(INT a, INT b){\n\treturn (a/GCD(a,b))*b;\n}\nint main(){\n\twhile(1){\n\t\tint i,n;\n\t\tINT d[N];\n\t\tINT v[N];\n\t\tINT Rates[N];\n\t\tINT lcmV = 1;\n\t\tINT gcdRates = 1;\n\t\tINT lcmRates = 1;\n\n\t\tscanf(\"%d\",&n);\n\t\tif(0==n)break;\n\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tint td, tv;\n\t\t\tint gcd;\n\t\t\tscanf(\"%d%d\",&td,&tv);\n\t\t\tgcd = GCD(td,tv);\n\t\t\td[i] = (INT)td/gcd;\n\t\t\tv[i] = (INT)tv/gcd;\n\t\t}\n\t\t\n\t\tlcmV = LCM( v[0], v[1] );\n\t\tfor(i = 2; i < n; ++i){\n\t\t\tlcmV = LCM( lcmV, v[i] );\n\t\t}\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tRates[i] = (lcmV / v[i])*d[i];\n\t\t}\n\t\tgcdRates = GCD( Rates[0], Rates[1] );\n\t\tfor(i = 2; i < n; ++i){\n\t\t\tgcdRates = GCD( gcdRates, Rates[i] );\n\t\t}\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tRates[i] /= gcdRates;\n\t\t}\n\t\tlcmRates = LCM( Rates[0], Rates[1] );\n\t\tfor(i = 2; i < n; ++i){\n\t\t\tlcmRates = LCM( lcmRates, Rates[i] );\n\t\t}\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tprintf(\"%u\\n\", (unsigned int)(lcmRates / Rates[i]));\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long lcm(long long a, long long b) {\n    return (a / gcd(a, b)) * b;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long times[10];\n        long long d, v;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%lld %lld\", &d, &v);\n            long long g = gcd(d, v);\n            d /= g;\n            v /= g;\n            times[i] = d;\n        }\n        \n        long long lcm_time = times[0];\n        for (int i = 1; i < n; i++) {\n            lcm_time = lcm(lcm_time, times[i]);\n        }\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%lld\\n\", lcm_time / times[i]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> long long gcd(long long a, long long b) { while (b != 0) { long long temp = b; b = a % b; a =  long long lcm(long long a, long long b) { return (a / gcd(a, b)) * b; } int main() { int n; while (scanf(\"%d\", &n) == 1   d, v; for (int i = 0; i < n; i++) { scanf(\"%lld %lld\", &d, &v); long long g = gcd(d, v); d /= g;  d; } long long lcm_time = times[0]; for (int i = 1;  lcm_time = lcm(lcm_time, times[i]); } for (int i =  0; }"], "perturbed_original": ["#include<stdio.h> #define N 10 typedef  INT GCD(INT a, INT b){ if( b ==  return GCD(b,a%b); } INT LCM(INT a, INT b){ return (a/GCD(a,b))*b; } int main(){ while(1){ int i,n; INT d[N]; INT v[N];  1; INT gcdRates = 1; INT lcmRates = 1; scanf(\"%d\",&n); if(0==n)break; for(i  ++i){ int td, tv; int gcd; scanf(\"%d%d\",&td,&tv); gcd  v[i] = (INT)tv/gcd; } lcmV = LCM( v[0], v[1] ); for(i = 2; i < n; ++i){ lcmV = LCM( lcmV, v[i]  i < n; ++i){ Rates[i] = (lcmV / v[i])*d[i]; } gcdRates = GCD( Rates[0], Rates[1]  < n; ++i){ gcdRates = GCD( gcdRates,  0; i < n; ++i){ Rates[i] /= gcdRates; } lcmRates = LCM( Rates[0],   = LCM( lcmRates, Rates[i] ); } for(i = 0; i < n; ++i){ printf(\"%u\\n\", (unsigned int)(lcmRates / Rates[i])); } } return 0; }"], "original_ll": -0.6895124316215515, "sampled_ll": -0.41011619567871094, "all_perturbed_sampled_ll": [-1.3021103143692017], "all_perturbed_original_ll": [-1.711484432220459], "perturbed_sampled_ll": -1.3021103143692017, "perturbed_original_ll": -1.711484432220459, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.Scanner;\nimport java.math.BigInteger;\n\npublic class Main\n{\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner cin = new Scanner(System.in);\n\t\t\n\t\tint n;\n\t\twhile(true)\n\t\t{\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\n\t\t\tBigInteger   p = new BigInteger(\"1\"); \n\t\t\tBigInteger[] s = new BigInteger[10];\n\t\t\tBigInteger[] t = new BigInteger[10];\n\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\ts[i] = new BigInteger(cin.next());\n\t\t\t\tt[i] = new BigInteger(cin.next());\n\t\t\t\t\n\t\t\t\tp = t[i].multiply( p.divide( p.gcd(t[i]) ));\n\t\t\t}\n\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\ts[i] = s[i].multiply( p.divide(t[i]) );\n\t\t\t}\n\t\t\t\n\t\t\tp = new BigInteger(\"1\");\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tp = s[i].multiply( p.divide( p.gcd(s[i]) ));\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tSystem.out.println(p.divide(s[i]));\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            long[] d = new long[n];\n            long[] v = new long[n];\n            \n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                d[i] = Long.parseLong(parts[0]);\n                v[i] = Long.parseLong(parts[1]);\n            }\n            \n            // Calculate time for each student to complete one lap\n            // time = distance / speed = d / v\n            // We need to find LCM of all times\n            // time_i = d_i / v_i\n            // To avoid floating point, we work with fractions\n            \n            // Reduce each fraction d_i / v_i\n            long[] numerators = new long[n];\n            long[] denominators = new long[n];\n            \n            for (int i = 0; i < n; i++) {\n                long g = gcd(d[i], v[i]);\n                numerators[i] = d[i] / g;\n                denominators[i] = v[i] / g;\n            }\n            \n            // Find LCM of fractions: LCM(a/b, c/d) = LCM(a,c) / GCD(b,d)\n            long lcmNum = numerators[0];\n            long lcmDen = denominators[0];\n            \n            for (int i = 1; i < n; i++) {\n                lcmNum = lcm(lcmNum, numerators[i]);\n                lcmDen = gcd(lcmDen, denominators[i]);\n            }\n            \n            // The total time when all meet is lcmNum / lcmDen\n            // Number of laps for student i = (lcmNum / lcmDen) / (numerators[i] / denominators[i])\n            //                               = (lcmNum / lcmDen) * (denominators[i] / numerators[i])\n            //                               = (lcmNum * denominators[i]) / (lcmDen * numerators[i])\n            \n            for (int i = 0; i < n; i++) {\n                long laps = (lcmNum * denominators[i]) / (lcmDen * numerators[i]);\n                System.out.println(laps);\n            }\n        }\n    }\n    \n    static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n    \n    static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line  int n = Integer.parseInt(line.trim()); if (n == 0) break; long[] d =  i = 0; i <  = br.readLine().trim().split(\"\\\\s+\"); d[i] = Long.parseLong(parts[0]); v[i]  time for each student to complete one lap // time = distance / speed = d / v // We need to find LCM  = d_i  floating point, we work with fractions // Reduce each fraction d_i / v_i long[] numerators = new long[n]; long[] denominators =  = 0; i < n; i++) { long g = gcd(d[i], v[i]); numerators[i] = d[i] / g; denominators[i] = v[i] /  of fractions: LCM(a/b, c/d) = LCM(a,c) / GCD(b,d) long lcmNum = numerators[0]; long lcmDen =  1; i < n; i++) { lcmNum = lcm(lcmNum, numerators[i]); lcmDen = gcd(lcmDen, denominators[i]); } // The total time when all meet is lcmNum / lcmDen // Number of laps for student  / (numerators[i] / denominators[i]) // =  / numerators[i]) // =  *  0;   denominators[i]) / (lcmDen * numerators[i]); System.out.println(laps); } } } static long gcd(long a, long b) { while (b != 0) { long temp = b; b =  temp; } return a; } static long lcm(long a, long b) {  * b; } }"], "perturbed_original": ["import java.io.*;  class Main { public  Scanner(System.in); int n; while(true) { n  p = new BigInteger(\"1\"); BigInteger[] s = new  BigInteger[10]; for(int i=0; i<n; i++) { s[i] = new BigInteger(cin.next()); t[i] = new BigInteger(cin.next()); p = t[i].multiply( p.divide( p.gcd(t[i]) )); } for(int i=0; i<n; i++) { s[i] = s[i].multiply( p.divide(t[i]) );  for(int i=0; i<n; i++) { p = s[i].multiply( p.divide( p.gcd(s[i]) )); } for(int i=0; i<n; i++) { System.out.println(p.divide(s[i])); } } } }"], "original_ll": -0.7431703209877014, "sampled_ll": -0.5624958276748657, "all_perturbed_sampled_ll": [-1.701352596282959], "all_perturbed_original_ll": [-1.4507920742034912], "perturbed_sampled_ll": -1.701352596282959, "perturbed_original_ll": -1.4507920742034912, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\"\"\" Created by Jieyi on 10/4/16. \"\"\"\nimport io\nimport sys\n\nif len(sys.argv) > 1:\n    filename = sys.argv[1]\n    inp = ''.join(open(filename, \"r\").readlines())\n    sys.stdin = io.StringIO(inp)\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n\n    return x\n\n\ndef lcm(x, y):\n    l_lcm = (x * y) // gcd(x, y)\n    return l_lcm\n\n\ndef mul_lcm(array):\n    l = lcm(array[0], array[1])\n    if len(array) > 3:\n        for i in range(2, len(array)):\n            l = lcm(array[i], l)\n    return l\n\n\ndef algorithm(students):\n    denominator_lcm = mul_lcm([y for _, y in students])\n    for i in range(len(students)):\n        students[i][0] *= int(denominator_lcm / students[i][1])\n    molecular_lcm = mul_lcm([x for x, _ in students])\n\n    return [int(molecular_lcm / students[i][0]) for i in range(len(students))]\n\n\ndef input_sample():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n\n        students = []\n        for _ in range(n):\n            students.append(list(map(int, input().split())))\n        answer_list = algorithm(students)\n        for ans in answer_list:\n            print(ans)\n\n\ndef main():\n    input_sample()\n\n\nif __name__ == '__main__':\n    main()", "sampled": "from math import gcd\nfrom fractions import Fraction\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef lcm_multiple(numbers):\n    result = numbers[0]\n    for num in numbers[1:]:\n        result = lcm(result, num)\n    return result\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    students = []\n    for _ in range(n):\n        d, v = map(int, input().split())\n        students.append((d, v))\n    \n    # Calculate time for one lap for each student as a fraction\n    times = []\n    for d, v in students:\n        times.append(Fraction(d, v))\n    \n    # Find LCM of all times\n    # LCM of fractions a/b and c/d is LCM(a,c)/GCD(b,d)\n    numerators = [t.numerator for t in times]\n    denominators = [t.denominator for t in times]\n    \n    lcm_num = lcm_multiple(numerators)\n    gcd_den = denominators[0]\n    for den in denominators[1:]:\n        gcd_den = gcd(gcd_den, den)\n    \n    meeting_time = Fraction(lcm_num, gcd_den)\n    \n    # Calculate laps for each student\n    for time in times:\n        laps = meeting_time / time\n        print(int(laps))\n", "perturbed_sampled": ["from math import gcd from fractions import Fraction def lcm(a, b): return a * b // gcd(a, b) def lcm_multiple(numbers): result =  result = lcm(result, num) return result while True: n = int(input()) if  = [] for _ in range(n): d, v = map(int, input().split()) students.append((d, v)) # Calculate time   =  students: times.append(Fraction(d, v)) # Find LCM of all times # LCM of fractions a/b and c/d is LCM(a,c)/GCD(b,d)  in times] denominators = [t.denominator for t in times] lcm_num = lcm_multiple(numerators) gcd_den = denominators[0] for den in denominators[1:]: gcd_den  Fraction(lcm_num, gcd_den) # Calculate  time in times: laps = meeting_time / time print(int(laps))"], "perturbed_original": ["\"\"\" Created  import io import sys if len(sys.argv) > 1: filename = sys.argv[1] inp = ''.join(open(filename, \"r\").readlines()) sys.stdin = io.StringIO(inp) def gcd(x, y): while y: x, y = y, x % y return x def lcm(x, y): l_lcm = (x * y) // gcd(x, y) return l_lcm def mul_lcm(array): l  > 3: for i in range(2, len(array)): l = lcm(array[i], l)  = mul_lcm([y for _, y in students]) for i in range(len(students)):  molecular_lcm = mul_lcm([x for x, _ in students]) return [int(molecular_lcm / students[i][0]) for i in range(len(students))]  = int(input()) if n == 0:   answer_list = algorithm(students) for ans in answer_list: print(ans) def  '__main__': main()"], "original_ll": -0.9410833716392517, "sampled_ll": -0.7795513272285461, "all_perturbed_sampled_ll": [-2.0912117958068848], "all_perturbed_original_ll": [-1.8460593223571777], "perturbed_sampled_ll": -2.0912117958068848, "perturbed_original_ll": -1.8460593223571777, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\n#define INF 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[11][101];\n\nint W[101][101];\nint c, V, n, s, d;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nvoid dijkstra(int start) {\n    int i, x, p, step;\n    for (i = 0; i <= c; i++) {\n\tfor (x = 1; x <= n; x++) {\n\t    vertex[i][x].distance = INF; vertex[i][x].state = 0;\n\t}\n\tvertex[i][start].distance = 0; \n    }\n    for (i = 0; i <= c; i++) {\n\tfor (step = 1; step <= n; step++) {\n\t    int minimum = INF;\n\t    for (x = 1; x <= n; x++)\n\t\tif (vertex[i][x].state == 0 && vertex[i][x].distance < minimum) {\n\t\t    p = x; minimum = vertex[i][x].distance;\n\t\t}\n\t    vertex[i][p].state = 1;\n\t    for (x = 1 ; x <= n; x++)\n\t\tif (vertex[i][x].state == 0) {\n\t\t    if (i == 0)\n\t\t\tvertex[i][x].distance = min(vertex[i][x].distance, \n\t\t\t\t\t\t    vertex[i][p].distance+W[p][x]);\n\t\t    else\n\t\t\tvertex[i][x].distance = min(vertex[i][x].distance, \n\t\t\t\t\t\t    min(vertex[i][p].distance+W[p][x],\n\t\t\t\t\t\t\tvertex[i-1][p].distance+W[p][x]/2));\n\t\t}\n\t}\n    }\n}\n\nint main(void) {\n    int i, j;\n    int from, to, m;\n     \n    while (1) {\n\tscanf(\"%d%d%d%d%d\", &c, &V, &n, &s, &d);\n        if (c + V + n + s + d == 0) break;\n         \n        for (i = 0; i <= V; i++)\n            for (j = 0; j <= V; j++)\n                W[i][j] = INF;\n         \n\tfor (i = 0; i < n; i++) {\n            scanf(\"%d%d%d\", &from, &to, &m);\n            W[from][to] = m;\n\t    W[to][from] = m;\n        }\n         \n        dijkstra(s);\n\tprintf(\"%d\\n\", vertex[c][d].distance);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 101\n#define MAX_M 501\n#define INF INT_MAX\n\ntypedef struct {\n    int to;\n    int cost;\n} Edge;\n\nEdge edges[MAX_M * 2];\nint head[MAX_N];\nint next_edge[MAX_M * 2];\nint edge_count;\n\nvoid add_edge(int from, int to, int cost) {\n    edges[edge_count].to = to;\n    edges[edge_count].cost = cost;\n    next_edge[edge_count] = head[from];\n    head[from] = edge_count;\n    edge_count++;\n}\n\ntypedef struct {\n    int node;\n    int tickets_used;\n    int cost;\n} State;\n\nState queue[MAX_N * 12];\nint queue_start, queue_end;\n\nvoid enqueue(int node, int tickets, int cost) {\n    queue[queue_end].node = node;\n    queue[queue_end].tickets_used = tickets;\n    queue[queue_end].cost = cost;\n    queue_end++;\n}\n\nState dequeue() {\n    return queue[queue_start++];\n}\n\nint min_cost[MAX_N][12];\n\nint dijkstra(int n, int s, int d, int c) {\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= c; j++) {\n            min_cost[i][j] = INF;\n        }\n    }\n    \n    queue_start = 0;\n    queue_end = 0;\n    enqueue(s, 0, 0);\n    min_cost[s][0] = 0;\n    \n    while (queue_start < queue_end) {\n        State current = dequeue();\n        int u = current.node;\n        int tickets = current.tickets_used;\n        int curr_cost = current.cost;\n        \n        if (curr_cost > min_cost[u][tickets]) {\n            continue;\n        }\n        \n        for (int e = head[u]; e != -1; e = next_edge[e]) {\n            int v = edges[e].to;\n            int edge_cost = edges[e].cost;\n            \n            // Without using discount\n            int new_cost = curr_cost + edge_cost;\n            if (new_cost < min_cost[v][tickets]) {\n                min_cost[v][tickets] = new_cost;\n                enqueue(v, tickets, new_cost);\n            }\n            \n            // With discount\n            if (tickets < c) {\n                int discounted_cost = curr_cost + edge_cost / 2;\n                if (discounted_cost < min_cost[v][tickets + 1]) {\n                    min_cost[v][tickets + 1] = discounted_cost;\n                    enqueue(v, tickets + 1, discounted_cost);\n                }\n            }\n        }\n    }\n    \n    int result = INF;\n    for (int i = 0; i <= c; i++) {\n        if (min_cost[d][i] < result) {\n            result = min_cost[d][i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    int c, n, m, s, d;\n    \n    while (1) {\n        scanf(\"%d %d %d %d %d\", &c, &n, &m, &s, &d);\n        if (c == 0 && n == 0 && m == 0 && s == 0 && d == 0) {\n            break;\n        }\n        \n        edge_count = 0;\n        for (int i = 0; i <= n; i++) {\n            head[i] = -1;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int a, b, f;\n            scanf(\"%d %d %d\", &a, &b, &f);\n            add_edge(a, b, f);\n            add_edge(b, a, f);\n        }\n        \n        int result = dijkstra(n, s, d, c);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  MAX_M 501 #define INF INT_MAX typedef struct { int to; int cost; } Edge; Edge edges[MAX_M  next_edge[MAX_M * 2]; int edge_count; void add_edge(int  { edges[edge_count].to = to;  head[from]; head[from] = edge_count; edge_count++; } typedef struct { int node; int tickets_used; int cost; } State; State queue[MAX_N *   queue[queue_end].cost = cost; queue_end++; } State dequeue() { return queue[queue_start++]; } int min_cost[MAX_N][12];  = 0; i <= n; i++) { for (int j = 0; j <= c; j++) { min_cost[i][j] = INF; } } queue_start = 0; queue_end = 0; enqueue(s, 0, 0); min_cost[s][0] =  { State current = dequeue(); int u = current.node; int tickets = current.tickets_used; int curr_cost  min_cost[u][tickets]) { continue; } for (int  -1; e = next_edge[e]) { int v  edges[e].cost; // Without using discount int new_cost = curr_cost + edge_cost; if (new_cost < min_cost[v][tickets]) { min_cost[v][tickets] = new_cost; enqueue(v, tickets, new_cost); } // With discount if (tickets < c) { int discounted_cost  2; if (discounted_cost < min_cost[v][tickets + 1]) { min_cost[v][tickets + 1] = discounted_cost; enqueue(v,  } } } int result = INF; for (int i = 0; i <= c; i++) { if (min_cost[d][i] < result) { result = min_cost[d][i]; } } return result; } int main() { int c, n, m, s, d; while (1) { scanf(\"%d %d %d %d %d\", &c, &n, &m, &s, &d); if (c == 0 && n == 0 && m == 0 && s == 0 && d == 0)   0; i <= n; i++) { head[i] =   i++) { int a, b, f; scanf(\"%d %d %d\", &a, &b, &f); add_edge(a, b, f); add_edge(b, a, f); } int result = dijkstra(n, s, d,  0; }"], "perturbed_original": ["#include <stdio.h> #define INF 100000000 struct  state; } vertex[11][101]; int W[101][101]; int c, V, n, s, d; int min(int a, int b) { return (a > b ? b : a); } void dijkstra(int start) { int i, x, p, step; for (i = 0;  for (x = 1;  vertex[i][x].distance = INF;  = 0; } for (i = 0; i <= c; i++) { for (step = 1; step <= n; step++) { int minimum  1; x  == 0  p = x; minimum = vertex[i][x].distance; } vertex[i][p].state  1 ; x <= n; x++) if (vertex[i][x].state == 0)  else vertex[i][x].distance = min(vertex[i][x].distance, min(vertex[i][p].distance+W[p][x], vertex[i-1][p].distance+W[p][x]/2)); }  int from, to, m; while (1) {  &d); if (c + V + n + s + d == 0) break; for (i = 0; i <= V; i++) for (j = 0; j <= V; j++) W[i][j] = INF; for (i = 0; i < n; i++) { scanf(\"%d%d%d\", &from, &to, &m); W[from][to] = m; W[to][from] = m; } dijkstra(s);  }"], "original_ll": -0.6391676068305969, "sampled_ll": -0.3601705729961395, "all_perturbed_sampled_ll": [-1.210431694984436], "all_perturbed_original_ll": [-1.4321365356445312], "perturbed_sampled_ll": -1.210431694984436, "perturbed_original_ll": -1.4321365356445312, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String arg[])\n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=1000001;\n\t\tfor(;;)\n\t\t{\n\t\t\tint c=in.nextInt();//\u30c1\u30b1\u30c3\u30c8\u306e\u6570\n\t\t\tint n=in.nextInt(),m=in.nextInt();//\u30d0\u30b9\u505c\u306e\u6570,\u9053\u306e\u6570\n\t\t\tint s=in.nextInt(),d=in.nextInt();//\u30b9\u30bf\u30fc\u30c8&\u30b4\u30fc\u30eb\n\t\t\tif((c|n|m|s|d)==0)\n\t\t\t\treturn;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tfor(int q[]: cost) {\n\t\t\t\tArrays.fill(q, M);\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint a=in.nextInt();\n\t\t\t\tint b=in.nextInt();\n\t\t\t\tint f=in.nextInt();\n\t\t\t\tcost[a][b]=f;\n\t\t\t\tcost[b][a]=f;\n\t\t\t}\n\t\t\tint p=0,w=0;\n\t\t\tint v[][] = new int[n+1][c+1];// decision flag\n\t\t\tint leng[][]=new int[n+1][c+1];// minimum distance\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int k=0;k<=c;k++)\n\t\t\t\t{\n\t\t\t\t\tleng[i][k]=M;\n\t\t\t\t\tv[i][k]=0;\n\t\t\t\t}\n\t\t\tleng[s][c]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tint min=M;//\u6700\u5c0f\u306e\u7bc0\u70b9\u3092\u63a2\u3059\n\t\t\t\tfor(int l=1;l<=n;l++)\n\t\t\t\t\tfor(int k=1;k<=c;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(v[l][k]==0&&leng[l][k]<min)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp=l;\n\t\t\t\t\t\t\tw=k;\n\t\t\t\t\t\t\tmin=leng[l][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(min==M)\n\t\t\t\t\tbreak;\n\t\t\t\tv[p][w]=1;//\u78ba\u5b9a\u30d5\u30e9\u30b0\n\t\t\t\tfor(int l=1;l<=n;l++) //p\u3092\u7d4c\u7531\u3057\u3066l\u306b\u81f3\u308b\u9577\u3055\u304c\u305d\u308c\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\u3088\u308a\u5c0f\u3055\u3051\u308c\u3070\u66f4\u65b0\n\t\t\t\t{\n\t\t\t\t\tleng[l][w]=Math.min(leng[l][w], leng[p][w]+cost[p][l]);\n\t\t\t\t\tif (w>0)\n\t\t\t\t\t\tleng[l][w-1]=Math.min(leng[l][w-1], leng[p][w]+cost[p][l]/2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(leng[d][0]);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, cost;\n        Edge(int to, int cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        int node, couponsUsed, cost;\n        \n        State(int node, int couponsUsed, int cost) {\n            this.node = node;\n            this.couponsUsed = couponsUsed;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int c = sc.nextInt();\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            int d = sc.nextInt();\n            \n            if (c == 0 && n == 0 && m == 0 && s == 0 && d == 0) {\n                break;\n            }\n            \n            List<List<Edge>> graph = new ArrayList<>();\n            for (int i = 0; i <= n; i++) {\n                graph.add(new ArrayList<>());\n            }\n            \n            for (int i = 0; i < m; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int f = sc.nextInt();\n                graph.get(a).add(new Edge(b, f));\n                graph.get(b).add(new Edge(a, f));\n            }\n            \n            int result = dijkstra(graph, n, c, s, d);\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n    \n    static int dijkstra(List<List<Edge>> graph, int n, int c, int s, int d) {\n        int[][] dist = new int[n + 1][c + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(dist[i], Integer.MAX_VALUE);\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(s, 0, 0));\n        dist[s][0] = 0;\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            if (current.node == d) {\n                return current.cost;\n            }\n            \n            if (current.cost > dist[current.node][current.couponsUsed]) {\n                continue;\n            }\n            \n            for (Edge edge : graph.get(current.node)) {\n                // Without using coupon\n                int newCost = current.cost + edge.cost;\n                if (newCost < dist[edge.to][current.couponsUsed]) {\n                    dist[edge.to][current.couponsUsed] = newCost;\n                    pq.offer(new State(edge.to, current.couponsUsed, newCost));\n                }\n                \n                // With using coupon\n                if (current.couponsUsed < c) {\n                    int discountedCost = current.cost + edge.cost / 2;\n                    if (discountedCost < dist[edge.to][current.couponsUsed + 1]) {\n                        dist[edge.to][current.couponsUsed + 1] = discountedCost;\n                        pq.offer(new State(edge.to, current.couponsUsed + 1, discountedCost));\n                    }\n                }\n            }\n        }\n        \n        int minCost = Integer.MAX_VALUE;\n        for (int i = 0; i <= c; i++) {\n            minCost = Math.min(minCost, dist[d][i]);\n        }\n        \n        return minCost;\n    }\n}\n", "perturbed_sampled": [" { static class Edge { int to, cost;  this.to = to; this.cost = cost; } } static class State implements Comparable<State> { int node, couponsUsed, cost; State(int node, int couponsUsed,  this.cost = cost; } @Override public int compareTo(State  } } public  Scanner sc = new Scanner(System.in); while (true) { int c = sc.nextInt(); int n = sc.nextInt(); int m = sc.nextInt(); int s = sc.nextInt(); int d = sc.nextInt(); if (c == 0 && n == 0 && m == 0 && s == 0 &&  }  for (int i  = 0;  int a = sc.nextInt(); int b  sc.nextInt(); graph.get(a).add(new Edge(b, f)); graph.get(b).add(new Edge(a, f)); } int result  d); System.out.println(result); } sc.close(); } static int dijkstra(List<List<Edge>> graph, int n,  d) { int[][] dist = new int[n + 1][c + 1]; for (int i = 0; i <= n; i++) { Arrays.fill(dist[i], Integer.MAX_VALUE); } PriorityQueue<State> pq = new PriorityQueue<>(); pq.offer(new State(s, 0, 0)); dist[s][0] = 0; while  d) { return current.cost; } if (current.cost > dist[current.node][current.couponsUsed]) {  : graph.get(current.node)) { // Without using coupon int  if (newCost < dist[edge.to][current.couponsUsed]) { dist[edge.to][current.couponsUsed] = newCost; pq.offer(new State(edge.to, current.couponsUsed, newCost)); } // With using coupon if (current.couponsUsed < c) { int discountedCost = current.cost + edge.cost / 2; if (discountedCost < dist[edge.to][current.couponsUsed + 1]) { dist[edge.to][current.couponsUsed + 1] = discountedCost; pq.offer(new State(edge.to, current.couponsUsed + 1, discountedCost)); } } } } int minCost = Integer.MAX_VALUE; for (int i = 0; i <= c; i++) { minCost =  } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String arg[]) { Scanner in=new Scanner(System.in); int M=1000001; for(;;) { int c=in.nextInt();//\u30c1\u30b1\u30c3\u30c8\u306e\u6570 int n=in.nextInt(),m=in.nextInt();//\u30d0\u30b9\u505c\u306e\u6570,\u9053\u306e\u6570 int s=in.nextInt(),d=in.nextInt();//\u30b9\u30bf\u30fc\u30c8&\u30b4\u30fc\u30eb if((c|n|m|s|d)==0) return; int cost[][]=new int[n+1][n+1]; for(int i=0;i<=n;i++) Arrays.fill(cost[i], M); b=0;b=0;b<=c;b++) {<extra_id_4>b[e]=p[p][v];<extra_id_5>w|s|d;<extra_id_6>} } void<extra_id_7>++ ) { i<extra_id_8>i<extra_id_9>i = 0<extra_id_10>i <<extra_id_11>; ] = i ;<extra_id_12>i ; i ++<extra_id_13>i]=n; } int<extra_id_14>= b<extra_id_15>++ ) M); }  { int a=in.nextInt();  cost[b][a]=f; } int p=0,w=0; int v[][] = new int[n+1][c+1];// decision flag int  i=0;i<=n;i++) for(int k=0;k<=c;k++)  for(;;) { int min=M;//\u6700\u5c0f\u306e\u7bc0\u70b9\u3092\u63a2\u3059 for(int l=1;l<=n;l++) for(int k=1;k<=c;k++) { if(v[l][k]==0&&leng[l][k]<min) { p=l; w=k; min=leng[l][k]; } } if(min==M) break;  leng[l][w]=Math.min(leng[l][w], leng[p][w]+cost[p][l]); if (w>0) leng[l][w-1]=Math.min(leng[l][w-1], leng[p][w]+cost[p][l]/2); } } System.out.println(leng[d][0]); } } }"], "original_ll": -0.9020626544952393, "sampled_ll": -0.2897029221057892, "all_perturbed_sampled_ll": [-1.1027034521102905], "all_perturbed_original_ll": [-1.9405105113983154], "perturbed_sampled_ll": -1.1027034521102905, "perturbed_original_ll": -1.9405105113983154, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from sys import stdin\nreadline = stdin.readline\n\n\n\nfrom collections import namedtuple\nRunner = namedtuple('Runner', 'd v')\n\ndef main():\n    while True:\n        ticket, vertex, edge, start, destination = map(int, readline().split())\n        if ticket == 0:\n            break\n\n        start -= 1\n        destination -= 1\n        g = defaultdict(list)\n        for i in range(edge):\n            s, t, length = map(int, readline().split())\n            s -= 1\n            t -= 1\n            g[s].append((length, t))\n            g[t].append((length, s))\n        \n        d = ex_dijkstra(g, vertex, start, ticket)\n        print(min(d[destination]))\n\n\n\nfrom heapq import heappush, heappop\nfrom collections import defaultdict\ndef ex_dijkstra(g, size, start, ticket):\n    d = [[float('inf')] * (ticket + 1) for i in range(size)]\n    d[start][ticket] = 0\n    heap = [(d[start][ticket], start, ticket)]\n    while heap:\n        du, u, ticket = heappop(heap)\n        for length, v in g[u]:\n            if d[v][ticket] > du + length:\n                d[v][ticket] = du + length\n                heappush(heap,(d[v][ticket], v, ticket))\n            if ticket and d[v][ticket - 1] > du + length // 2:\n                d[v][ticket - 1] = du + length // 2\n                heappush(heap,(d[v][ticket - 1], v, ticket - 1))\n\n    return d\n\nmain()", "sampled": "import heapq\nfrom sys import stdin\n\ndef solve(c, n, m, s, d, edges):\n    # Build adjacency list\n    graph = [[] for _ in range(n + 1)]\n    for a, b, f in edges:\n        graph[a].append((b, f))\n        graph[b].append((a, f))\n    \n    # Dijkstra with state (cost, node, discounts_used)\n    # We need to track how many discounts we've used\n    dist = {}  # (node, discounts_used) -> min_cost\n    pq = [(0, s, 0)]  # (cost, node, discounts_used)\n    dist[(s, 0)] = 0\n    \n    while pq:\n        cost, node, discounts_used = heapq.heappop(pq)\n        \n        if node == d:\n            continue\n        \n        if (node, discounts_used) in dist and dist[(node, discounts_used)] < cost:\n            continue\n        \n        for next_node, fare in graph[node]:\n            # Option 1: Don't use discount\n            new_cost = cost + fare\n            if (next_node, discounts_used) not in dist or dist[(next_node, discounts_used)] > new_cost:\n                dist[(next_node, discounts_used)] = new_cost\n                heapq.heappush(pq, (new_cost, next_node, discounts_used))\n            \n            # Option 2: Use discount if available\n            if discounts_used < c:\n                new_cost = cost + fare // 2\n                if (next_node, discounts_used + 1) not in dist or dist[(next_node, discounts_used + 1)] > new_cost:\n                    dist[(next_node, discounts_used + 1)] = new_cost\n                    heapq.heappush(pq, (new_cost, next_node, discounts_used + 1))\n    \n    # Find minimum cost to reach destination with any number of discounts used\n    min_cost = float('inf')\n    for i in range(c + 1):\n        if (d, i) in dist:\n            min_cost = min(min_cost, dist[(d, i)])\n    \n    return min_cost\n\n# Read input\nlines = []\nfor line in stdin:\n    lines.append(line.strip())\n\ni = 0\nwhile i < len(lines):\n    parts = lines[i].split()\n    c, n, m, s, d = map(int, parts)\n    if c == 0 and n == 0 and m == 0 and s == 0 and d == 0:\n        break\n    \n    edges = []\n    for j in range(m):\n        i += 1\n        a, b, f = map(int, lines[i].split())\n        edges.append((a, b, f))\n    \n    result = solve(c, n, m, s, d, edges)\n    print(result)\n    \n    i += 1\n", "perturbed_sampled": ["import heapq from   #   + 1)] for a, b, f in edges: graph[a].append((b, f)) graph[b].append((a, f)) # Dijkstra with state (cost, node, discounts_used) # We need to track how many discounts we've used dist = {}  0)] # (cost, node,  while pq: cost, node, discounts_used = heapq.heappop(pq) if node == d: continue if (node, discounts_used) in dist and dist[(node, discounts_used)] < cost: continue for next_node, fare in graph[node]:  discount new_cost = cost + fare if (next_node, discounts_used) not  > new_cost: dist[(next_node, discounts_used)] = new_cost heapq.heappush(pq, (new_cost, next_node, discounts_used)) # Option 2: Use discount if available if  cost + fare // 2 if (next_node, discounts_used  or  new_cost: dist[(next_node, discounts_used + 1)] = new_cost heapq.heappush(pq, (new_cost, next_node, discounts_used + 1)) # Find minimum cost to reach destination  for i in range(c + 1): if  = min(min_cost, dist[(d, i)]) return min_cost # Read input lines = [] for line in stdin: lines.append(line.strip()) i = 0 while i < len(lines): parts = lines[i].split() c, n, m, s, d = map(int, parts) if c == 0 and n == 0  s == 0 and d == 0: break edges = [] for j in range(m): i += 1 a, b, f =  result = solve(c, n, m, s, d, edges) print(result) i += 1"], "perturbed_original": ["from sys import stdin readline = stdin.readline from collections import namedtuple Runner = namedtuple('Runner', 'd v') def main(): while True: ticket, vertex, edge, start, destination = map(int, readline().split()) if ticket == 0: break start  t, length = map(int, readline().split()) s -= 1 t -= 1 g[s].append((length,  ex_dijkstra(g, vertex, start, ticket) print(min(d[destination])) from heapq import heappush, heappop from collections import defaultdict def ex_dijkstra(g, size,  for i in range(size)] d[start][ticket] =  ticket)] while heap: du, u, ticket = heappop(heap) for length, v in g[u]: if d[v][ticket] > du  + length heappush(heap,(d[v][ticket], v, ticket))  1] > du + length // 2: d[v][ticket - 1] = du + length // 2 heappush(heap,(d[v][ticket - 1], v, ticket - 1)) return d main()"], "original_ll": -0.7874248623847961, "sampled_ll": -0.49975448846817017, "all_perturbed_sampled_ll": [-1.6711863279342651], "all_perturbed_original_ll": [-2.0590906143188477], "perturbed_sampled_ll": -1.6711863279342651, "perturbed_original_ll": -2.0590906143188477, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu 0213: Subdivide The Land\n// 2017.9.24 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { int id, x, y, k; } T;\nT tbl[16]; \nint X, Y, n;\nchar map[10][10];\nchar ans[10][10], cnt;\nint pair[101][13][2], plen[101];\n\nint cmp(T *a, T *b) { if (a->y - b->y) return a->y - b->y; return a->x - b->x; }\n\nvoid mark(int c, int x, int y, int w, int h)\n{\n\tint yy;\n\tfor (yy = 0; yy < h; yy++) memset(map[y+yy]+x, c, w);\n}\n\nint check(int c, int x, int y, int w, int h)\n{\n\tint xx, yy;\n\tfor (yy = 0; yy < h; yy++) for (xx = 0; xx < w; xx++) \n\t\tif (map[y+yy][x+xx] > 0 && map[y+yy][x+xx] != c) return 0;\n\treturn 1;\n}\n\nint combi(int i)\n{\n\tint x, y, x0, y0, id, x1, y1, h, w, j, k;\n\n\tif (i == n+1) {\n\t\tif (cnt) return 0;\n\t\tcnt = 1, memcpy(ans, map, sizeof(map));\n\t\treturn 1;\n\t}\n\tk = tbl[i].k;\n\tif (k == 1) return combi(i+1);\n\tx0 = tbl[i].x, y0 = tbl[i].y, id = tbl[i].id;\n\n\tfor (j = 0; j < plen[k]; j++) {\n\t\tw = pair[k][j][0], h = pair[k][j][1];\n\t\tx1 = x0 - w + 1, y1 = y0 - h + 1;\n\t\tif (x1 < 0) x1 = 0; if (y1 < 0) y1 = 0;\n\t\tfor (y = y1; y <= y0; y++) for (x = x1; x <= x0; x++) {\n\t\t\tif (x + w > X || y + h > Y) goto Next;\n\t\t\tif (!check(id, x, y, w, h)) continue;\n\t\t\tmark(id, x, y, w, h);\n\t\t\tif (!combi(i+1)) return 0;\n\t\t\tmark(0, x, y, w, h);\n\t\t}\nNext:;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n    int i, b, t, s, x, y;\n\n\tfor (x = 1; x <= 100; x++) for (y = 1; y <= 100; y++)\n\t\tif ((t = x * y) <= 100) pair[t][plen[t]][0] = x, pair[t][plen[t]++][1] = y;\n\n\twhile (scanf(\"%d%d%d\", &X, &Y, &n) && n > 0) {\n\t\tfor (s = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &b, &t);\n\t\t\ttbl[b].k = t, tbl[b].id = b;\n\t\t\ts += t;\n\t\t}\n\t\tfor (y = 0; y < Y; y++) for (x = 0; x < X; x++) {\n\t\t\tscanf(\"%d\", &b), map[y][x] = b;\n\t\t\tif (b > 0) tbl[b].x = x, tbl[b].y = y;\n\t\t}\n\t\tif (s != X*Y) { puts(\"NA\"); continue; }\n\t\tqsort(tbl+1, n, sizeof(T), cmp);\n\n\t\tcnt = 0;\n\t\tif (!combi(1)) puts(\"NA\");\n\t\telse for (y = 0; y < Y; y++) {\n\t\t\tprintf(\"%d\", ans[y][0]);\n\t\t\tfor (x = 1; x < X; x++) printf(\" %d\", ans[y][x]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint X, Y, n;\nint b[16], k[16];\nint s[11][11];\nint grid[11][11];\nint solutions;\n\nint isValidRectangle(int buyer, int x1, int y1, int x2, int y2) {\n    int count = 0;\n    int hasSign = 0;\n    \n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            if (grid[i][j] != 0) return 0;\n            count++;\n            if (s[i][j] == buyer) hasSign = 1;\n        }\n    }\n    \n    if (count != k[buyer] || !hasSign) return 0;\n    return 1;\n}\n\nvoid fillRectangle(int x1, int y1, int x2, int y2, int buyer) {\n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            grid[i][j] = buyer;\n        }\n    }\n}\n\nvoid clearRectangle(int x1, int y1, int x2, int y2) {\n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            grid[i][j] = 0;\n        }\n    }\n}\n\nvoid solve(int buyer) {\n    if (solutions > 1) return;\n    \n    if (buyer > n) {\n        solutions++;\n        return;\n    }\n    \n    for (int x1 = 1; x1 <= X; x1++) {\n        for (int y1 = 1; y1 <= Y; y1++) {\n            for (int x2 = x1; x2 <= X; x2++) {\n                for (int y2 = y1; y2 <= Y; y2++) {\n                    if (isValidRectangle(buyer, x1, y1, x2, y2)) {\n                        fillRectangle(x1, y1, x2, y2, buyer);\n                        solve(buyer + 1);\n                        if (solutions > 1) {\n                            clearRectangle(x1, y1, x2, y2);\n                            return;\n                        }\n                        clearRectangle(x1, y1, x2, y2);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d\", &X, &Y, &n);\n        if (X == 0 && Y == 0 && n == 0) break;\n        \n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d %d\", &b[i], &k[i]);\n        }\n        \n        for (int j = 1; j <= Y; j++) {\n            for (int i = 1; i <= X; i++) {\n                scanf(\"%d\", &s[i][j]);\n            }\n        }\n        \n        memset(grid, 0, sizeof(grid));\n        solutions = 0;\n        solve(1);\n        \n        if (solutions == 1) {\n            for (int j = 1; j <= Y; j++) {\n                for (int i = 1; i <= X; i++) {\n                    if (i > 1) printf(\" \");\n                    printf(\"%d\", grid[i][j]);\n                }\n                printf(\"\\n\");\n            }\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int X, Y, n; int b[16], k[16]; int s[11][11]; int grid[11][11]; int solutions; int isValidRectangle(int buyer, int  int y2) { int count  0; for (int i  j = y1; j <= y2; j++) { if (grid[i][j] != 0) return 0;  hasSign = 1; } } if (count != k[buyer] || !hasSign) return 0; return 1; } void fillRectangle(int x1, int y1, int  {  i <= x2; i++) { for (int j = y1; j <= y2; j++) { grid[i][j] = buyer; } } } void clearRectangle(int x1, int y1, int x2, int y2) { for (int i =  = y1; j <= y2; j++) { grid[i][j] = 0; } }  if (solutions > 1) return;  (int x1 =  {  { for (int x2 = x1; x2 <= X; x2++) { for (int y2 = y1; y2   { fillRectangle(x1, y1, x2, y2, buyer); solve(buyer + 1); if (solutions > 1) { clearRectangle(x1, y1, x2, y2); return; } clearRectangle(x1, y1, x2, y2); } } } } } } int main()  %d %d\", &X,   && n == 0) break; for (int  n; i++) { scanf(\"%d %d\", &b[i], &k[i]); } for (int j = 1; j <= Y; j++) { for (int i = 1; i <= X; i++) { scanf(\"%d\", &s[i][j]); } } memset(grid, 0, sizeof(grid)); solutions = 0; solve(1); if (solutions ==  = 1; j <= Y; j++) { for (int i = 1; i <= X; i++) { if (i > 1) printf(\" \"); printf(\"%d\", grid[i][j]); } printf(\"\\n\"); } } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["// Aizu 0213: Subdivide The Land // 2017.9.24 bal4u@uu #include <stdio.h> #include <stdlib.h> #include <string.h> typedef struct { int id, x, y, k; } T; T tbl[16]; int X, Y, n;   *a, T *b) { if (a->y - b->y) return a->y     } int check(int c, int x, int  { int xx, yy; for (yy = 0; yy < h; yy++) for (xx = 0; xx < w; xx++) if (map[y+yy][x+xx] > 0 && map[y+yy][x+xx] != c) return 0; return 1; } int combi(int i)  h,  == n+1) { if (cnt) return 0;  sizeof(map)); return 1; } k = tbl[i].k; if (k == 1) return combi(i+1); x0 = tbl[i].x, y0 = tbl[i].y, id = tbl[i].id; for (j = 0; j < plen[k]; j++) { w = pair[k][j][0], h = pair[k][j][1]; x1 = x0 - w + 1, y1 = y0 - h + 1; if (x1 < 0) x1 = 0;  = 0; for (y = y1; y  = x1; x <= x0; x++) { if (x + w > X || y  Next; if (!check(id,  mark(id, x, y, w, h); if (!combi(i+1)) return 0; mark(0, x, y, w, h); } Next:; } return 1; } int main() { int i, b, t, s, x, y;  <= 100; x++)  <= 100; y++) if ((t = x * y) <= 100) pair[t][plen[t]][0] = x, pair[t][plen[t]++][1] = y; while (scanf(\"%d%d%d\", &X, &Y, &n) && n > 0) { for (s  scanf(\"%d%d\", &b, &t); tbl[b].k = t, tbl[b].id = b; s += t; } for (y = 0; y < Y; y++) for (x  x++) { scanf(\"%d\", &b), map[y][x] = b; if (b > 0) tbl[b].x = x, tbl[b].y = y; } if (s != X*Y) { puts(\"NA\"); continue; } qsort(tbl+1,  else for (y = 0; y  ans[y][0]); for (x = 1; x < X; x++) printf(\" %d\", ans[y][x]); printf(\"\\n\"); } } return 0; }"], "original_ll": -0.8258897066116333, "sampled_ll": -0.4083781838417053, "all_perturbed_sampled_ll": [-1.2312116622924805], "all_perturbed_original_ll": [-1.5433684587478638], "perturbed_sampled_ll": -1.2312116622924805, "perturbed_original_ll": -1.5433684587478638, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport scala.languageFeature.postfixOps;\nimport sun.tools.jar.resources.jar;\nimport lombok.Data;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((w | h | n) == 0)\n\t\t\t\tbreak;\n\t\t\tsize = new int[n + 1];\n\t\t\tpos = new int[n + 1][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tsize[b] = k;\n\t\t\t}\n\t\t\tm = new int[h][w];\n\t\t\t\n\t\t\tfor (int[] a : m)\n\t\t\t\tArrays.fill(a, -1);\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tm[i][j] = x;\n\t\t\t\t\tif (x > 0) {\n\t\t\t\t\t\tpos[x][0] = i;\n\t\t\t\t\t\tpos[x][1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassign = new int[n + 1][4];\n\t\t\tc = 0;\n\t\t\tans = new int[h][w];\n\t\t\tf(1);\n\t\t\tif (c == 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate void f(int k) {\n\t\tif (k == n + 1) {\n\t\t\tc++;\n\t\t\tif (c == 2)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint a = m[i][j];\n\t\t\t\t\tans[i][j] = a >= 100 ? a / 100 : a;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = size[k];\n\t\tfor (int x = 1; x <= s; x++) {\n\t\t\tif (s % x != 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int lj = pos[k][1] + 1 - x; lj <= pos[k][1]; lj++) {\n\t\t\t\tif (lj < 0 || lj > w)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int li = pos[k][0] + 1 - s / x; li <= pos[k][0]; li++) {\n\t\t\t\t\tif (li < 0 || li > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint rj = lj + x;\n\t\t\t\t\tint ri = li + s / x;\n\t\t\t\t\tif (rj > w)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (ri > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != 0 && m[i][j] != k)\n\t\t\t\t\t\t\t\tcontinue loop;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = k * 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf(k + 1);\n\t\t\t\t\tif (c == 2)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tint[][] m;\n\tint[] size;\n\tint[][] pos;\n\tint[][] assign;\n\tint w, h, n, c;\n\tint[][] ans;\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int X, Y, n;\n    static int[] buyers;\n    static int[] counts;\n    static int[][] signs;\n    static List<int[][]> validSolutions;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            X = sc.nextInt();\n            Y = sc.nextInt();\n            n = sc.nextInt();\n            \n            if (X == 0 && Y == 0 && n == 0) break;\n            \n            buyers = new int[n];\n            counts = new int[n];\n            \n            for (int i = 0; i < n; i++) {\n                buyers[i] = sc.nextInt();\n                counts[i] = sc.nextInt();\n            }\n            \n            signs = new int[Y][X];\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    signs[i][j] = sc.nextInt();\n                }\n            }\n            \n            validSolutions = new ArrayList<>();\n            int[][] grid = new int[Y][X];\n            boolean[] used = new boolean[n];\n            \n            backtrack(grid, used, 0);\n            \n            if (validSolutions.size() == 0) {\n                System.out.println(\"NA\");\n            } else if (validSolutions.size() > 1) {\n                System.out.println(\"NA\");\n            } else {\n                int[][] sol = validSolutions.get(0);\n                for (int i = 0; i < Y; i++) {\n                    for (int j = 0; j < X; j++) {\n                        if (j > 0) System.out.print(\" \");\n                        System.out.print(sol[i][j]);\n                    }\n                    System.out.println();\n                }\n            }\n        }\n    }\n    \n    static void backtrack(int[][] grid, boolean[] used, int buyerIdx) {\n        if (buyerIdx == n) {\n            if (isValidComplete(grid)) {\n                int[][] copy = new int[Y][X];\n                for (int i = 0; i < Y; i++) {\n                    for (int j = 0; j < X; j++) {\n                        copy[i][j] = grid[i][j];\n                    }\n                }\n                validSolutions.add(copy);\n            }\n            return;\n        }\n        \n        if (validSolutions.size() > 1) return;\n        \n        int buyer = -1;\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                buyer = i;\n                break;\n            }\n        }\n        \n        if (buyer == -1) return;\n        \n        int buyerNum = buyers[buyer];\n        int count = counts[buyer];\n        \n        for (int y1 = 0; y1 < Y; y1++) {\n            for (int x1 = 0; x1 < X; x1++) {\n                for (int y2 = y1; y2 < Y; y2++) {\n                    for (int x2 = x1; x2 < X; x2++) {\n                        int w = x2 - x1 + 1;\n                        int h = y2 - y1 + 1;\n                        if (w * h != count) continue;\n                        \n                        if (canPlace(grid, x1, y1, x2, y2, buyerNum)) {\n                            place(grid, x1, y1, x2, y2, buyerNum);\n                            used[buyer] = true;\n                            backtrack(grid, used, buyerIdx + 1);\n                            used[buyer] = false;\n                            place(grid, x1, y1, x2, y2, 0);\n                            \n                            if (validSolutions.size() > 1) return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    static boolean canPlace(int[][] grid, int x1, int y1, int x2, int y2, int buyerNum) {\n        boolean hasSign = false;\n        for (int y = y1; y <= y2; y++) {\n            for (int x = x1; x <= x2; x++) {\n                if (grid[y][x] != 0) return false;\n                if (signs[y][x] != 0) {\n                    if (signs[y][x] != buyerNum) return false;\n                    hasSign = true;\n                }\n            }\n        }\n        return hasSign;\n    }\n    \n    static void place(int[][] grid, int x1, int y1, int x2, int y2, int buyerNum) {\n        for (int y = y1; y <= y2; y++) {\n            for (int x = x1; x <= x2; x++) {\n                grid[y][x] = buyerNum;\n            }\n        }\n    }\n    \n    static boolean isValidComplete(int[][] grid) {\n        for (int i = 0; i < Y; i++) {\n            for (int j = 0; j < X; j++) {\n                if (grid[i][j] == 0) return false;\n            }\n        }\n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int  buyers; static int[] counts; static int[][] signs; static  sc = new Scanner(System.in); while (true)  = sc.nextInt(); n = sc.nextInt(); if (X == 0 && Y ==  break; buyers = new int[n]; counts = new int[n]; for (int i = 0; i < n; i++) { buyers[i] = sc.nextInt(); counts[i] = sc.nextInt(); } signs = new int[Y][X]; for (int i = 0; i < Y; i++) { for (int j  j++) { signs[i][j] = sc.nextInt(); } } validSolutions = new ArrayList<>(); int[][]  (validSolutions.size() == 0) { System.out.println(\"NA\"); } else if (validSolutions.size() > 1) { System.out.println(\"NA\"); } else { int[][] sol = validSolutions.get(0); for (int i = 0; i < Y; i++) { for (int j = 0; j < X; j++) { if (j >  grid, boolean[] used, int buyerIdx) { if (buyerIdx ==  int[][] copy = new int[Y][X]; for (int i  i++) { for (int j = 0; j < X; j++) { copy[i][j] = grid[i][j]; } } validSolutions.add(copy); } return; } if (validSolutions.size() > 1) return; int  i = 0; i < n; i++) { if (!used[i]) { buyer = i; break;  -1) return; int buyerNum = buyers[buyer]; int count = counts[buyer]; for (int y1 = 0; y1 < Y; y1++) {  x1 < X; x1++) { for (int y2 = y1; y2 < Y; y2++) { for (int x2 = x1; x2 < X; x2++) { int w =  int h = y2 - y1 + 1; if (w * h != count) continue; if (canPlace(grid, x1, y1, x2,  y1, x2, y2, buyerNum); used[buyer] = true; backtrack(grid,  if (validSolutions.size() > 1) return; } }   int y1, int x2, int y2, int buyerNum) { boolean hasSign = false; for (int y = y1; y <= y2; y++)  x1; x <=  != 0) return false; if (signs[y][x] != 0) { if (signs[y][x] != buyerNum) return false; hasSign = true;  } static void place(int[][] grid, int x1, int y1, int x2, int y2, int buyerNum) { for (int y = y1; y <= y2; y++) { for (int  x2; x++) { grid[y][x] = buyerNum; } } } static boolean isValidComplete(int[][] grid) { for (int i = 0;  for (int j = 0; j < X; j++) {  true; } }"], "perturbed_original": ["import java.io.IOException; import java.util.ArrayList; import java.util.Arrays; import  import scala.languageFeature.postfixOps; import sun.tools.jar.resources.jar; import lombok.Data; public class Main { public static void main(String[] args) throws IOException { new Main().run(); } private void run() throws IOException { Scanner scanner = new Scanner(System.in); while (true) { w = scanner.nextInt(); h = scanner.nextInt(); n = scanner.nextInt(); if ((w | h | n) == 0)   int[n + 1][2]; for (int i = 0; i < n; i++) { int b = scanner.nextInt(); int  k; } m = new int[h][w];  Arrays.fill(a, -1); for (int i = 0; i < h; i++)  j++)  m[i][j] = x; if (x > 0) { pos[x][0] = i; pos[x][1] = j; } } } assign  c = 0; ans = new int[h][w]; f(1); if (c == 1) { for  < h; i++) { for (int j = 0; j < w; j++) { if (j > 0) System.out.print(\" \"); System.out.print(ans[i][j]); } System.out.println(); } } else { System.out.println(\"NA\"); } } } private void f(int k) { if (k == n + 1) {  return; for (int i = 0; i < h; i++) { for (int j = 0; j < w; j++) { int a = m[i][j]; ans[i][j] = a >= 100 ? a / 100 : a; }  = size[k]; for (int x = 1; x <= s;  x != 0) continue; for (int lj = pos[k][1]  <= pos[k][1]; lj++) { if  > w) continue; loop: for (int li = pos[k][0] + 1 - s / x;  if (li < 0 || li > h) continue;  li + s / x; if (rj > w) continue; if (ri > h) continue; for (int i  i++) { for (int j = lj; j < rj; j++) { if (m[i][j] != 0 && m[i][j]  } for  for (int j =  { if (m[i][j] != k) m[i][j] = k * 100; } }  == 2)  li; i < ri;  = lj;  if (m[i][j] != k) m[i][j] = 0; } } } } } } int[][] m; int[] size; int[][] pos;  n, c; int[][] ans; }"], "original_ll": -0.5864824652671814, "sampled_ll": -0.3100259304046631, "all_perturbed_sampled_ll": [-1.2290104627609253], "all_perturbed_original_ll": [-1.5788675546646118], "perturbed_sampled_ll": -1.2290104627609253, "perturbed_original_ll": -1.5788675546646118, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import copy\n\ndef main(land, b):\n    for h in range(H):\n        for w in range(W):\n            if land[h][w] == b:\n                if f1(land, h, w, b, data[land[h][w]]):\n                    return\n            \ndef f1(land, h, w, b, k):\n    for q in range(1, k+1):\n        if k%q == 0:\n            if f2(land, h, w, q, k/q, b):\n                return True\n    else:\n        return\n        \ndef f2(land, h, w, r, c, b):\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h-_h and 0 <= w-_w:\n                if f3(land, h-_h, w-_w, r, c, b):\n                    return True\n    else:\n        return\n                \ndef f3(land, h, w, r, c, b):\n    _land = copy.deepcopy(land)\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h+_h <= H-1 and 0 <= w+_w <= W-1:\n                if _land[h+_h][w+_w] == 0 or _land[h+_h][w+_w] == b:\n                    _land[h+_h][w+_w] = b\n                else:\n                    return\n            else:\n                return\n    else:\n        if b < n:\n            return main(_land, b+1)\n        else:\n            for line in _land:\n                print ' '.join(map(str, line))\n            return True\n\nwhile True:\n    W, H, n = map(int, raw_input().split())\n    if H == W == n == 0: break\n    data = {}\n    for i in range(n):\n        b, k = map(int, raw_input().split())\n        data[b] = k\n    land = [map(int, raw_input().split()) for i in range(H)]\n    main(land, 1)", "sampled": "import sys\nfrom itertools import product\n\ndef read_input():\n    datasets = []\n    lines = sys.stdin.read().strip().split('\\n')\n    i = 0\n    while i < len(lines):\n        parts = lines[i].split()\n        X, Y, n = int(parts[0]), int(parts[1]), int(parts[2])\n        if X == 0 and Y == 0 and n == 0:\n            break\n        \n        i += 1\n        memo = []\n        for _ in range(n):\n            b, k = map(int, lines[i].split())\n            memo.append((b, k))\n            i += 1\n        \n        signs = []\n        for _ in range(Y):\n            row = list(map(int, lines[i].split()))\n            signs.append(row)\n            i += 1\n        \n        datasets.append((X, Y, n, memo, signs))\n    \n    return datasets\n\ndef get_all_rectangles(X, Y):\n    rectangles = []\n    for x1 in range(X):\n        for y1 in range(Y):\n            for x2 in range(x1, X):\n                for y2 in range(y1, Y):\n                    rectangles.append((x1, y1, x2, y2))\n    return rectangles\n\ndef solve(X, Y, n, memo, signs):\n    rectangles = get_all_rectangles(X, Y)\n    \n    # Group rectangles by size\n    size_to_rects = {}\n    for rect in rectangles:\n        x1, y1, x2, y2 = rect\n        size = (x2 - x1 + 1) * (y2 - y1 + 1)\n        if size not in size_to_rects:\n            size_to_rects[size] = []\n        size_to_rects[size].append(rect)\n    \n    # For each buyer, get possible rectangles\n    buyer_rects = {}\n    for b, k in memo:\n        if k in size_to_rects:\n            buyer_rects[b] = size_to_rects[k]\n        else:\n            return \"NA\"\n    \n    # Try all combinations\n    def check_assignment(assignment):\n        grid = [[0] * Y for _ in range(X)]\n        \n        for buyer, rect in assignment.items():\n            x1, y1, x2, y2 = rect\n            for x in range(x1, x2 + 1):\n                for y in range(y1, y2 + 1):\n                    if grid[x][y] != 0:\n                        return None\n                    grid[x][y] = buyer\n        \n        # Check if signs match\n        for x in range(X):\n            for y in range(Y):\n                if signs[y][x] != 0:\n                    if grid[x][y] != signs[y][x]:\n                        return None\n        \n        return grid\n    \n    valid_grids = []\n    \n    def backtrack(buyers, assignment):\n        if not buyers:\n            grid = check_assignment(assignment)\n            if grid:\n                valid_grids.append(grid)\n            return\n        \n        buyer = buyers[0]\n        for rect in buyer_rects[buyer]:\n            assignment[buyer] = rect\n            backtrack(buyers[1:], assignment)\n            del assignment[buyer]\n    \n    buyers = [b for b, k in memo]\n    backtrack(buyers, {})\n    \n    if len(valid_grids) == 0:\n        return \"NA\"\n    elif len(valid_grids) == 1:\n        grid = valid_grids[0]\n        result = []\n        for y in range(Y):\n            row = []\n            for x in range(X):\n                row.append(str(grid[x][y]))\n            result.append(' '.join(row))\n        return '\\n'.join(result)\n    else:\n        return \"NA\"\n\ndatasets = read_input()\nfor X, Y, n, memo, signs in datasets:\n    result = solve(X, Y, n, memo, signs)\n    print(result)\n", "perturbed_sampled": ["import sys from itertools import  [] lines =  i < len(lines): parts  = int(parts[0]), int(parts[1]), int(parts[2]) if X == 0 and Y == 0 and n  1 memo = [] for _ in range(n): b, k = map(int, lines[i].split()) memo.append((b, k)) i += 1 signs = [] for _ in range(Y): row = list(map(int, lines[i].split())) signs.append(row) i += 1 datasets.append((X, Y, n, memo, signs)) return datasets def get_all_rectangles(X, Y): rectangles = [] for x1 in range(X): for y1 in range(Y): for x2 in range(x1, X):  rectangles.append((x1, y1, x2, y2)) return rectangles def  rectangles = get_all_rectangles(X, Y)  size_to_rects = {} for rect in rectangles: x1, y1, x2, y2  - x1 + 1) * (y2 - y1 +  buyer_rects = {} for  k in size_to_rects: buyer_rects[b] = size_to_rects[k] else: return \"NA\" # Try all  [[0] * Y for _ in  assignment.items(): x1, y1, x2, y2  range(x1, x2 + 1): for y in range(y1, y2 + 1): if grid[x][y] != 0: return None grid[x][y] = buyer # Check if signs match for x in range(X): for y  0: if grid[x][y] != signs[y][x]: return  []  buyers: grid = check_assignment(assignment) if grid: valid_grids.append(grid) return buyer = buyers[0] for rect in buyer_rects[buyer]: assignment[buyer] = rect backtrack(buyers[1:], assignment) del assignment[buyer] buyers = [b for b,  if len(valid_grids) == 0: return \"NA\" elif len(valid_grids) == 1: grid = valid_grids[0] result = [] for  [] for x in range(X): row.append(str(grid[x][y])) result.append(' '.join(row)) return '\\n'.join(result) else: return \"NA\" datasets = read_input() for X, Y, n, memo, signs in datasets: result = solve(X, Y, n, memo, signs) print(result)"], "perturbed_original": ["import copy def main(land, b): for h in range(H): for w in range(W): if land[h][w] == b: if f1(land, h, w, b, data[land[h][w]]):  b, k): for q in range(1, k+1):  f2(land, h, w, q, k/q, b): return True else: return def f2(land, h, w, r, c, b): for _h in range(r): for _w in range(c):  0 <= w-_w: if f3(land, h-_h, w-_w, r, c, b): return True else: return def f3(land, h, w, r, c, b): _land = copy.deepcopy(land) for _h  range(c): if 0 <= h+_h <= H-1 and 0 <= w+_w <= W-1: if _land[h+_h][w+_w] ==  return else: return else: if b < n: return  in _land: print ' '.join(map(str, line)) return True while True:  raw_input().split()) if H == W == n == 0: break  = map(int, raw_input().split()) data[b] = k  i in range(H)] main(land, 1)"], "original_ll": -0.7474166750907898, "sampled_ll": -0.5178781747817993, "all_perturbed_sampled_ll": [-1.669359803199768], "all_perturbed_original_ll": [-1.8255586624145508], "perturbed_sampled_ll": -1.669359803199768, "perturbed_original_ll": -1.8255586624145508, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nlong z(long a,long b,long c,long d,long e,long f){\n    return (c-a)*(f-b)-(e-a)*(d-b);\n}\nint x(int (*a)[8],int (*b)[8]){\n    int i,j;\n    for(i=0;i<4;i++){\n        for(j=0;j<4;j++){\n            if(z((*a)[j*2],(*a)[j*2+1],(*a)[(j*2+2)%8],(*a)[(j*2+2)%8+1],(*b)[i*2],(*b)[i*2+1])>0)break;\n        }\n        if(j==4)return 1;\n    }\n    return 0;\n}\n\nint main(){\n    int n,m;\n    int a[100],l[100][8],b[100];\n    int i,j,k;\n    int min,ii,jj,kk;\n    while(scanf(\"%d\",&n)&&n){\n        while(n--){\n            scanf(\"%d\",&m);\n            for(i=0;i<m;i++){\n                a[i]=i;\n                for(j=0;j<8;j++)scanf(\"%d\",&l[i][j]);\n            }\n            for(i=0;i<m;i++){\n                for(j=i+1;j<m;j++){\n                    if(x(&l[i],&l[j])){\n                        k=0;\n                        ii=i;\n                        while((b[k++]=ii),a[ii]!=ii)ii=a[ii];\n                        jj=j;\n                        while((b[k++]=jj),a[jj]!=jj)jj=a[jj];\n                        min=ii<jj?ii:jj;\n                        for(kk=0;kk<k;kk++)a[b[kk]]=min;\n                    }\n                }\n            }\n            for(i=0;i<m;i++){\n                j=i;\n                while(a[j]!=j)j=a[j];\n                a[i]=j;\n            }\n            k=0;\n            for(i=0;i<m;i++){\n                for(j=0;j<i;j++){\n                    if(a[i]==a[j])break;\n                }\n                if(j==i)k++;\n            }\n            printf(\"%d\\n\",k);\n        }\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point vertices[4];\n} Rectangle;\n\nbool segmentsIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int d1 = (q1.x - p1.x) * (p2.y - p1.y) - (q1.y - p1.y) * (p2.x - p1.x);\n    int d2 = (q1.x - p1.x) * (q2.y - p1.y) - (q1.y - p1.y) * (q2.x - p1.x);\n    int d3 = (q2.x - p2.x) * (p1.y - p2.y) - (q2.y - p2.y) * (p1.x - p2.x);\n    int d4 = (q2.x - p2.x) * (q1.y - p2.y) - (q2.y - p2.y) * (q1.x - p2.x);\n    \n    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool pointOnSegment(Point p, Point q, Point r) {\n    if (q.x <= (p.x > r.x ? p.x : r.x) && q.x >= (p.x < r.x ? p.x : r.x) &&\n        q.y <= (p.y > r.y ? p.y : r.y) && q.y >= (p.y < r.y ? p.y : r.y))\n        return true;\n    return false;\n}\n\nbool segmentsTouchOrIntersect(Point p1, Point q1, Point p2, Point q2) {\n    long long d1 = (long long)(q1.x - p1.x) * (p2.y - p1.y) - (long long)(q1.y - p1.y) * (p2.x - p1.x);\n    long long d2 = (long long)(q1.x - p1.x) * (q2.y - p1.y) - (long long)(q1.y - p1.y) * (q2.x - p1.x);\n    long long d3 = (long long)(q2.x - p2.x) * (p1.y - p2.y) - (long long)(q2.y - p2.y) * (p1.x - p2.x);\n    long long d4 = (long long)(q2.x - p2.x) * (q1.y - p2.y) - (long long)(q2.y - p2.y) * (q1.x - p2.x);\n    \n    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n        return true;\n    }\n    \n    if (d1 == 0 && pointOnSegment(p1, p2, q1)) return true;\n    if (d2 == 0 && pointOnSegment(p1, q2, q1)) return true;\n    if (d3 == 0 && pointOnSegment(p2, p1, q2)) return true;\n    if (d4 == 0 && pointOnSegment(p2, q1, q2)) return true;\n    \n    return false;\n}\n\nbool pointInRectangle(Point p, Rectangle r) {\n    int crossings = 0;\n    for (int i = 0; i < 4; i++) {\n        Point p1 = r.vertices[i];\n        Point p2 = r.vertices[(i + 1) % 4];\n        \n        if ((p1.y <= p.y && p2.y > p.y) || (p1.y > p.y && p2.y <= p.y)) {\n            double vt = (double)(p.y - p1.y) / (p2.y - p1.y);\n            if (p.x < p1.x + vt * (p2.x - p1.x)) {\n                crossings++;\n            }\n        }\n    }\n    return (crossings % 2) == 1;\n}\n\nbool rectanglesTouchOrOverlap(Rectangle r1, Rectangle r2) {\n    for (int i = 0; i < 4; i++) {\n        if (pointInRectangle(r1.vertices[i], r2)) return true;\n        if (pointInRectangle(r2.vertices[i], r1)) return true;\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            if (segmentsTouchOrIntersect(r1.vertices[i], r1.vertices[(i+1)%4],\n                                        r2.vertices[j], r2.vertices[(j+1)%4])) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nint find(int parent[], int i) {\n    if (parent[i] != i)\n        parent[i] = find(parent, parent[i]);\n    return parent[i];\n}\n\nvoid unionSet(int parent[], int rank[], int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n    \n    if (rank[xroot] < rank[yroot])\n        parent[xroot] = yroot;\n    else if (rank[xroot] > rank[yroot])\n        parent[yroot] = xroot;\n    else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\nint main() {\n    int N;\n    \n    while (scanf(\"%d\", &N) && N != 0) {\n        for (int i = 0; i < N; i++) {\n            int M;\n            scanf(\"%d\", &M);\n            \n            Rectangle rectangles[100];\n            for (int j = 0; j < M; j++) {\n                for (int k = 0; k < 4; k++) {\n                    scanf(\"%d %d\", &rectangles[j].vertices[k].x, &rectangles[j].vertices[k].y);\n                }\n            }\n            \n            int parent[100], rank[100];\n            for (int j = 0; j < M; j++) {\n                parent[j] = j;\n                rank[j] = 0;\n            }\n            \n            for (int j = 0; j < M; j++) {\n                for (int k = j + 1; k < M; k++) {\n                    if (rectanglesTouchOrOverlap(rectangles[j], rectangles[k])) {\n                        unionSet(parent, rank, j, k);\n                    }\n                }\n            }\n            \n            int count = 0;\n            for (int j = 0; j < M; j++) {\n                if (find(parent, j) == j) {\n                    count++;\n                }\n            }\n            \n            printf(\"%d\\n\", count);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <stdbool.h> typedef struct { int x, y; } Point; typedef struct {   p2, Point q2) { int d1 = (q1.x - p1.x) *  -  int d2 = (q1.x - p1.x) * (q2.y - p1.y) - (q1.y - p1.y) * (q2.x - p1.x); int d3 = (q2.x - p2.x) * (p1.y - p2.y) - (q2.y - p2.y) * (p1.x - p2.x); int d4 =  - p2.y)  (((d1 > 0 &&  < 0 && d2 > 0)) && ((d3 > 0  (d3 < 0 && d4 > 0))) { return true; } return false; } bool pointOnSegment(Point p, Point  (q.x <= (p.x > r.x ? p.x : r.x) && q.x >= (p.x < r.x ? p.x : r.x)  r.y ? p.y : r.y)  r.y ?  return false; } bool segmentsTouchOrIntersect(Point p1, Point q1, Point p2,  d1 = (long long)(q1.x - p1.x) * (p2.y - p1.y) - (long long)(q1.y - p1.y) * (p2.x - p1.x); long long d2  * (q2.y - p1.y) - (long long)(q1.y  p1.x); long long d3 = (long long)(q2.x - p2.x) * (p1.y - p2.y) - (long long)(q2.y - p2.y) * (p1.x - p2.x); long long d4 = (long long)(q2.x - p2.x) * (q1.y - p2.y) - (long long)(q2.y - p2.y) * (q1.x - p2.x); if (((d1  0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) { return true; } if (d1 == 0  0 && pointOnSegment(p1, q2, q1)) return true; if  p1, q2)) return true; if (d4 == 0 &&  pointInRectangle(Point p, Rectangle r) { int crossings = 0; for (int i = 0;  Point p1 = r.vertices[i]; Point p2 = r.vertices[(i  ((p1.y <= p.y && p2.y > p.y) || (p1.y > p.y && p2.y <= p.y)) { double vt = (double)(p.y - p1.y) / (p2.y - p1.y); if (p.x < p1.x + vt  crossings++; }  2) == 1; } bool rectanglesTouchOrOverlap(Rectangle r1, Rectangle r2) { for (int i = 0; i < 4; i++) { if (pointInRectangle(r1.vertices[i], r2))   i = 0; i < 4; i++) { for (int j = 0; j < 4; j++) { if (segmentsTouchOrIntersect(r1.vertices[i], r1.vertices[(i+1)%4],  } } }  parent[], int i) { if (parent[i] != i) parent[i] = find(parent, parent[i]); return  int rank[], int x, int y) { int xroot = find(parent, x); int yroot = find(parent, y); if (rank[xroot] < rank[yroot]) parent[xroot] = yroot; else if (rank[xroot] > rank[yroot]) parent[yroot] = xroot; else { parent[yroot] = xroot; rank[xroot]++; } } int main() { int N;  != 0) { for (int i = 0;  int  for (int j = 0;  for (int k  k++) { scanf(\"%d %d\", &rectangles[j].vertices[k].x, &rectangles[j].vertices[k].y); } } int parent[100], rank[100]; for (int  M; j++)  j < M; j++) { for (int k = j + 1; k < M; k++) { if (rectanglesTouchOrOverlap(rectangles[j], rectangles[k])) { unionSet(parent, rank, j, k); } } } int count = 0; for (int j =  { if (find(parent, j) == j) { count++; } } printf(\"%d\\n\",  }"], "perturbed_original": ["#include <stdio.h> long z(long a,long b,long c,long d,long e,long f){ return (c-a)*(f-b)-(e-a)*(d-b); } int x(int (*a)[8],int (*b)[8]){ int i,j; k] =k;<extra_id_3>k]=k; 1; } return 0; } int main(){ int n,m; int a[100],l[100][8],b[100]; int i,j,k; int min,ii,jj,kk; while(scanf(\"%d\",&n)&&n){ while(n--){ scanf(\"%d\",&m); for(i=0;i<m;i++){ a[i]=i; for(j=0;j<8;j++)scanf(\"%d\",&l[i][j]); =0;<extra_id_4>{ p = (<extra_id_5>0<extra_id_6>] ; x<extra_id_7>0xffff); int * i<extra_id_8>=<extra_id_9>] ) {<extra_id_10>] =<extra_id_11>- 1 ) & 0xffff<extra_id_12>;<extra_id_13>j = f<<extra_id_14>] ;<extra_id_15>] =<extra_id_16>| (b [<extra_id_17>{<extra_id_18>] <<extra_id_19>&0xffff ) ;<extra_id_20>] min=ii<jj?ii:jj; for(kk=0;kk<k;kk++)a[b[kk]]=min; } } } for(i=0;i<m;i++){ j=i; while(a[j]!=j)j=a[j]; a[i]=j; } k=0; for(i=0;i<m;i++){ for(j=0;j<i;j++){ if(a[i]==a[j])break; } if(j==i)k++; }  }"], "original_ll": -0.8058727383613586, "sampled_ll": -0.22475393116474152, "all_perturbed_sampled_ll": [-1.072712779045105], "all_perturbed_original_ll": [-1.805858850479126], "perturbed_sampled_ll": -1.072712779045105, "perturbed_original_ll": -1.805858850479126, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Autumnal Illumination\npublic class Main{\n\n\tint n;\n\tint[][][] p;\n\t\n\tint cross(int[] s, int[] t, int[] r){\n\t\tint x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];\n\t\treturn x1*y2-x2*y1;\n\t}\n\tboolean online(int[] s, int[] t, int[] r){\n\t\tif(cross(s, t, r)!=0)return false;\n\t\tint minx = Math.min(s[0], t[0]), maxx = Math.max(s[0], t[0]);\n\t\tint miny = Math.min(s[1], t[1]), maxy = Math.max(s[1], t[1]);\n\t\treturn minx<=r[0]&&r[0]<=maxx&&miny<=r[1]&&r[1]<=maxy;\n\t}\n\tboolean isCross(int[] a, int[] b, int[] s, int[] t){\n\t\tif(cross(a, b, s)*cross(a, b, t)>=0)return false;\n\t\treturn cross(b, a, s)*cross(b, a, t)<0;\n\t}\n\t\n\tboolean col(int a, int b){\n\t\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++){\n\t\t\tif(online(p[a][i], p[a][(i+1)%4], p[b][j]))return true;\n\t\t\tif(online(p[b][i], p[b][(i+1)%4], p[a][j]))return true;\n\t\t\tif(isCross(p[a][i], p[a][(i+1)%4], p[b][j], p[b][(j+1)%4]))return true;\n\t\t}\n\t\tfor(int j=0;j<4;j++){\n\t\t\tboolean in = true;\n\t\t\tfor(int i=0;i<4;i++)if(cross(p[a][i], p[a][(i+1)%4], p[b][j])>=0)in = false;\n\t\t\tif(in)return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint m = sc.nextInt();\n\t\t\tif(m==0)break;\n\t\t\twhile(m--!=0){\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tp = new int[n][4][2];\n\t\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<4;j++)for(int k=0;k<2;k++)p[i][j][k]=sc.nextInt();\n\t\t\t\tUnionFind u = new UnionFind(n);\n\t\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\t\tif(u.find(i, j))continue;\n\t\t\t\t\tif(col(i, j))u.union(i, j);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(u.num);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass UnionFind {\n\t\tfinal int[] tree;\n\t\tint num;\n\t\tpublic UnionFind(int n) {\n\t\t\tthis.tree = new int[n];\n\t\t\tArrays.fill(tree, -1);\n\t\t\tnum=n;\n\t\t}\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif(x != y) {\n\t\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t\t}\n\t\t\t\ttree[x] += tree[y];\n\t\t\t\ttree[y] = x;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tboolean find(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\t\tint root(int x) {\n\t\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t\t}\n\t\tint size(int x) {\n\t\t\treturn -tree[root(x)];\n\t\t}\n\t\tint getNum() {\n\t\t\treturn num;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    static class Quad {\n        Point[] points;\n        Quad(Point[] points) {\n            this.points = points;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            for (int i = 0; i < n; i++) {\n                int m = Integer.parseInt(br.readLine().trim());\n                Quad[] quads = new Quad[m];\n                \n                for (int j = 0; j < m; j++) {\n                    String[] tokens = br.readLine().trim().split(\"\\\\s+\");\n                    Point[] points = new Point[4];\n                    for (int k = 0; k < 4; k++) {\n                        points[k] = new Point(\n                            Double.parseDouble(tokens[k * 2]),\n                            Double.parseDouble(tokens[k * 2 + 1])\n                        );\n                    }\n                    quads[j] = new Quad(points);\n                }\n                \n                int components = countComponents(quads);\n                System.out.println(components);\n            }\n        }\n    }\n    \n    static int countComponents(Quad[] quads) {\n        int n = quads.length;\n        boolean[] visited = new boolean[n];\n        int count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, quads, visited);\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    static void dfs(int idx, Quad[] quads, boolean[] visited) {\n        visited[idx] = true;\n        \n        for (int i = 0; i < quads.length; i++) {\n            if (!visited[i] && intersectsOrTouches(quads[idx], quads[i])) {\n                dfs(i, quads, visited);\n            }\n        }\n    }\n    \n    static boolean intersectsOrTouches(Quad q1, Quad q2) {\n        // Check if q1 and q2 overlap or touch\n        if (polygonsIntersect(q1.points, q2.points)) return true;\n        if (polygonContainsPolygon(q1.points, q2.points)) return true;\n        if (polygonContainsPolygon(q2.points, q1.points)) return true;\n        return false;\n    }\n    \n    static boolean polygonsIntersect(Point[] p1, Point[] p2) {\n        // Check edge intersections or touching\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                if (segmentsIntersectOrTouch(p1[i], p1[(i+1)%4], p2[j], p2[(j+1)%4])) {\n                    return true;\n                }\n            }\n        }\n        \n        // Check if any vertex of one is inside the other\n        for (int i = 0; i < 4; i++) {\n            if (pointInOrOnPolygon(p1[i], p2)) return true;\n            if (pointInOrOnPolygon(p2[i], p1)) return true;\n        }\n        \n        return false;\n    }\n    \n    static boolean polygonContainsPolygon(Point[] p1, Point[] p2) {\n        for (int i = 0; i < 4; i++) {\n            if (pointInPolygon(p2[i], p1)) return true;\n        }\n        return false;\n    }\n    \n    static boolean segmentsIntersectOrTouch(Point p1, Point p2, Point p3, Point p4) {\n        double d1 = direction(p3, p4, p1);\n        double d2 = direction(p3, p4, p2);\n        double d3 = direction(p1, p2, p3);\n        double d4 = direction(p1, p2, p4);\n        \n        if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n            ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n            return true;\n        }\n        \n        if (Math.abs(d1) < 1e-9 && onSegment(p3, p4, p1)) return true;\n        if (Math.abs(d2) < 1e-9 && onSegment(p3, p4, p2)) return true;\n        if (Math.abs(d3) < 1e-9 && onSegment(p1, p2, p3)) return true;\n        if (Math.abs(d4) < 1e-9 && onSegment(p1, p2, p4)) return true;\n        \n        return false;\n    }\n    \n    static double direction(Point p1, Point p2, Point p3) {\n        return (p3.x - p1.x) * (p2.y - p1.y) - (p2.x - p1.x) * (p3.y - p1.y);\n    }\n    \n    static boolean onSegment(Point p1, Point p2, Point p) {\n        return Math.min(p1.x, p2.x) <= p.x + 1e-9 && p.x <= Math.max(p1.x, p2.x) + 1e-9 &&\n               Math.min(p1.y, p2.y) <= p.y + 1e-9 && p.y <= Math.max(p1.y, p2.y) + 1e-9;\n    }\n    \n    static boolean pointInOrOnPolygon(Point p, Point[] poly) {\n        return pointInPolygon(p, poly) || pointOnPolygonBoundary(p, poly);\n    }\n    \n    static boolean pointInPolygon(Point p, Point[] poly) {\n        int n = poly.length;\n        boolean inside = false;\n        for (int i = 0, j = n - 1; i < n; j = i++) {\n            if ((poly[i].y > p.y) != (poly[j].y > p.y) &&\n                p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) {\n                inside = !inside;\n            }\n        }\n        return inside;\n    }\n    \n    static boolean pointOnPolygonBoundary(Point p, Point[] poly) {\n        int n = poly.length;\n        for (int i = 0; i < n; i++) {\n            if (Math.abs(direction(poly[i], poly[(i+1)%n], p)) < 1e-9 &&\n                onSegment(poly[i], poly[(i+1)%n], p)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class Point { double x, y; Point(double x, double y) { this.x = x; this.y = y; } } static class Quad { Point[] points; Quad(Point[] points) {  args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { int  == 0) break; for (int i = 0; i  m = Integer.parseInt(br.readLine().trim());  for (int j = 0; j < m; j++) { String[] tokens = br.readLine().trim().split(\"\\\\s+\"); Point[] points = new Point[4]; for (int k = 0; k < 4; k++) { points[k] = new Point( Double.parseDouble(tokens[k * 2]), Double.parseDouble(tokens[k * 2 + 1]) ); } quads[j] = new Quad(points); } int components = countComponents(quads); System.out.println(components); } } } static int countComponents(Quad[] quads) { int n = quads.length; boolean[] visited = new boolean[n]; int count  = 0; i < n;  dfs(i, quads,  count; } static void dfs(int idx, Quad[] quads, boolean[] visited) { visited[idx] = true; for (int i = 0; i < quads.length; i++) { if (!visited[i] && intersectsOrTouches(quads[idx],  } } } static boolean intersectsOrTouches(Quad q1, Quad q2)  and q2 overlap or  true; if (polygonContainsPolygon(q1.points, q2.points)) return true; if (polygonContainsPolygon(q2.points, q1.points)) return true; return false; } static boolean polygonsIntersect(Point[] p1, Point[] p2)  or touching for (int i = 0; i <  j = 0; j < 4;  p2[j],  } } // Check if any vertex of one is inside the other for (int i =  {  if (pointInOrOnPolygon(p2[i], p1)) return true; } return false; } static boolean polygonContainsPolygon(Point[] p1, Point[] p2) { for (int i  p1)) return true;  boolean segmentsIntersectOrTouch(Point p1,  p4) {  direction(p3, p4, p2); double d3 = direction(p1, p2, p3); double d4 = direction(p1, p2, p4); if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3  0))) { return true; } if (Math.abs(d1) < 1e-9 && onSegment(p3, p4, p1))  p2)) return  return true; if  p2, p4)) return  p2, Point p3) { return (p3.x - p1.x)  (p3.y - p1.y); } static boolean onSegment(Point p1, Point p2, Point p) { return Math.min(p1.x, p2.x) <=  <= Math.max(p1.x, p2.x) + 1e-9 && Math.min(p1.y, p2.y) <= p.y + 1e-9 && p.y <= Math.max(p1.y, p2.y)  pointInOrOnPolygon(Point p, Point[] poly) { return pointInPolygon(p, poly) || pointOnPolygonBoundary(p, poly); } static boolean pointInPolygon(Point p, Point[] poly) { int n = poly.length;  (int i = 0, j = n - 1; i < n; j = i++) { if ((poly[i].y > p.y) != (poly[j].y > p.y) && p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) { inside = !inside; } } return inside; } static  poly.length; for (int i  i++) { if (Math.abs(direction(poly[i], poly[(i+1)%n], p)) < 1e-9 && onSegment(poly[i], poly[(i+1)%n], p)) { return true; } } return false; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; //Autumnal Illumination public class Main{ int n; int[][][] p; int cross(int[] s, int[] t, int[] r){ int x1 = t[0]-s[0], y1 = t[1]-s[1], x2 =  s, int[] t, int[] r){ if(cross(s, t, r)!=0)return false; int minx = Math.min(s[0], t[0]), maxx = Math.max(s[0], t[0]); int miny  Math.max(s[1], t[1]); return minx<=r[0]&&r[0]<=maxx&&miny<=r[1]&&r[1]<=maxy; } boolean isCross(int[] a, int[] b, int[] s, int[] t){ if(cross(a, b, s)*cross(a,  a, s)*cross(b, a, t)<0; } boolean col(int a, int b){ for(int i=0;i<4;i++)for(int j=0;j<4;j++){ if(online(p[a][i], p[a][(i+1)%4], p[b][j]))return true; if(online(p[b][i], p[b][(i+1)%4], p[a][j]))return true; if(isCross(p[a][i],  for(int j=0;j<4;j++){ boolean  p[a][(i+1)%4], p[b][j])>=0)in = false; if(in)return true; } return false;  =  = sc.nextInt(); if(m==0)break; while(m--!=0){ n = sc.nextInt(); p = new int[n][4][2]; for(int i=0;i<n;i++)for(int j=0;j<4;j++)for(int  if(u.find(i, j))continue; if(col(i, j))u.union(i, j); } System.out.println(u.num); } } } class UnionFind { final int[] tree;  { this.tree = new int[n]; Arrays.fill(tree, -1);  int y) { x = root(x); y = root(y); if(x  tree[y]) { x ^= y; y ^= x; x^= y; } tree[x] += tree[y]; tree[y] = x; num--; } } boolean find(int x,  root(int x) { return tree[x] < 0  root(tree[x])); } int size(int x) { return -tree[root(x)]; } int getNum() { return num; } } public static void main(String[] args) { new Main().run(); } }"], "original_ll": -0.5799993276596069, "sampled_ll": -0.2735598087310791, "all_perturbed_sampled_ll": [-1.0616093873977661], "all_perturbed_original_ll": [-1.3476253747940063], "perturbed_sampled_ll": -1.0616093873977661, "perturbed_original_ll": -1.3476253747940063, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from sys import stdin\nfrom itertools import product\n\ndef chk_in_rect(xy1,xy2):\n    chk = True\n    for i in range(4):\n        for j in range(4):\n            a = (xy1[(2*i+2)&7]-xy1[(2*i  )&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+1)&7])\n            b = (xy1[(2*i+3)&7]-xy1[(2*i+1)&7]) * (xy2[(2*j  )&7]-xy1[(2*i  )&7])\n            if a > b: chk = False; break\n    if chk: return True\n    else: return False\n\ndef chk_intersect(xy1,xy2):\n    for i,j in product(range(4),repeat=2):\n        a = (xy1[(2*i  )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+3)&7])\n        a+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i  )&7]-xy1[(2*j  )&7])\n        b = (xy1[(2*i  )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+3)&7]-xy1[(2*i+3)&7])\n        b+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i  )&7]-xy1[(2*j+2)&7])\n        if a*b < 0 : return True\n    else:\n        return False\n\nwhile(True):\n    try:\n        n = int(stdin.readline())\n        if not n: break\n    except:\n        break\n    for _ in range(n):\n        m = int(stdin.readline())\n        p = list(range(m))\n        xys = [ list(map(int, stdin.readline().split())) for i in range(m) ]\n        # print(n,m,xys)\n        for i in range(m):\n            if len(set(p)) == 1: print(1); break\n            for j in range(i+1,m):\n                if p[i] == p[j]:\n                    continue\n                if chk_in_rect(xys[i],xys[j]):\n                    # print(\"in_rect\")\n                    p = [i if e==j else e for e in p]\n                    continue\n                if chk_intersect(xys[i],xys[j]):\n                    # print(\"intersect\")\n                    p = [i if e==j else e for e in p]\n                    continue\n        else: print(len(set(p)))\n\n\n\n\n", "sampled": "def rectangles_overlap_or_touch(rect1, rect2):\n    # Check if two rectangles overlap or touch (including edges)\n    # rect is list of 4 points [(x1,y1), (x2,y2), (x3,y3), (x4,y4)]\n    \n    # Check if rectangles are separated (no overlap or touch)\n    # Use Separating Axis Theorem (SAT)\n    \n    def get_edges(rect):\n        edges = []\n        for i in range(4):\n            p1 = rect[i]\n            p2 = rect[(i+1)%4]\n            edges.append((p2[0]-p1[0], p2[1]-p1[1]))\n        return edges\n    \n    def get_normals(edges):\n        normals = []\n        for edge in edges:\n            normals.append((-edge[1], edge[0]))\n        return normals\n    \n    def project(rect, axis):\n        dots = []\n        for point in rect:\n            dots.append(point[0]*axis[0] + point[1]*axis[1])\n        return min(dots), max(dots)\n    \n    def overlap(proj1, proj2):\n        return proj1[1] >= proj2[0] and proj2[1] >= proj1[0]\n    \n    edges1 = get_edges(rect1)\n    edges2 = get_edges(rect2)\n    normals = get_normals(edges1) + get_normals(edges2)\n    \n    for normal in normals:\n        proj1 = project(rect1, normal)\n        proj2 = project(rect2, normal)\n        if not overlap(proj1, proj2):\n            return False\n    \n    return True\n\ndef find_connected_components(rectangles):\n    n = len(rectangles)\n    if n == 0:\n        return 0\n    \n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if rectangles_overlap_or_touch(rectangles[i], rectangles[j]):\n                adj[i].append(j)\n                adj[j].append(i)\n    \n    # DFS to count connected components\n    visited = [False] * n\n    components = 0\n    \n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            components += 1\n    \n    return components\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    for _ in range(n):\n        m = int(input())\n        rectangles = []\n        for _ in range(m):\n            coords = list(map(int, input().split()))\n            rect = [(coords[i], coords[i+1]) for i in range(0, 8, 2)]\n            rectangles.append(rect)\n        \n        result = find_connected_components(rectangles)\n        print(result)\n", "perturbed_sampled": ["def rectangles_overlap_or_touch(rect1,  rectangles overlap or touch (including edges) # rect is list of 4 points [(x1,y1), (x2,y2), (x3,y3), (x4,y4)] # Check if rectangles are separated (no overlap or touch) # Use Separating Axis Theorem  [] for i in range(4): p1 = rect[i] p2 = rect[(i+1)%4] edges.append((p2[0]-p1[0], p2[1]-p1[1])) return edges def get_normals(edges):  in edges: normals.append((-edge[1], edge[0])) return normals  [] for point in rect: dots.append(point[0]*axis[0] + point[1]*axis[1]) return min(dots), max(dots) def overlap(proj1, proj2): return proj1[1] >= proj2[0] and proj2[1] >= proj1[0] edges1 = get_edges(rect1) edges2 = get_edges(rect2) normals = get_normals(edges1) + get_normals(edges2) for normal in normals: proj1 = project(rect1, normal) proj2 = project(rect2, normal) if not overlap(proj1, proj2): return False return True def find_connected_components(rectangles): n = len(rectangles) if n == 0: return 0 # Build  for j in range(i+1, n): if rectangles_overlap_or_touch(rectangles[i],  to count connected  adj[node]: if not visited[neighbor]: dfs(neighbor) for i in range(n): if not visited[i]: dfs(i) components += 1 return components while True: n = int(input()) if n == 0: break for _ in range(n): m = int(input())  in range(m): coords = list(map(int, input().split())) rect =  range(0, 8, 2)] rectangles.append(rect) result = find_connected_components(rectangles) print(result)"], "perturbed_original": ["from sys import stdin  for i in range(4): for j in range(4): a = (xy1[(2*i+2)&7]-xy1[(2*i  (xy1[(2*i+3)&7]-xy1[(2*i+1)&7]) * (xy2[(2*j )&7]-xy1[(2*i )&7]) if a > b: chk = False; break if chk: return True else:  i,j in product(range(4),repeat=2): a = (xy1[(2*i )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+3)&7]) a+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) *  b+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i )&7]-xy1[(2*j+2)&7]) if a*b <  return False while(True): try: n = int(stdin.readline()) if not n: break except: break for _ in  = list(range(m)) xys = [ list(map(int, stdin.readline().split())) for i in range(m) ] # print(n,m,xys) for i in range(m): if len(set(p)) == 1: print(1); break for j in range(i+1,m): if  chk_in_rect(xys[i],xys[j]): # print(\"in_rect\") p = [i if e==j else e for e in p] continue if chk_intersect(xys[i],xys[j]): # print(\"intersect\") p = [i if e==j  p] continue else: print(len(set(p)))"], "original_ll": -0.7595723271369934, "sampled_ll": -0.5037705302238464, "all_perturbed_sampled_ll": [-1.3938730955123901], "all_perturbed_original_ll": [-1.6554120779037476], "perturbed_sampled_ll": -1.3938730955123901, "perturbed_original_ll": -1.6554120779037476, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "mx,my;pn[7];px[7][1000],py[7][1000];M[5][7][1000];a0;Calc(a1,a2){int n1,n2,m,mm;for(n2=0;n2<pn[a2];n2++){mm=1e9;for(n1=0;n1<pn[a1];n1++){m=M[a0][a1][n1]+abs(px[a1][n1]-px[a2][n2])+abs(py[a1][n1]-py[a2][n2]);if(m<mm)mm=m;}M[a0][a2][n2]=mm;}}main(){int x,y,c,a,am;for(;scanf(\"%d%d\\n\",&mx,&my),mx;){memset(pn,0,sizeof(pn));for(y=0;y<my;y++){for(x=0;x<=mx;x++){c=getchar();if(c>='1'){if(c<='5')a=c-'0';else if(c=='S')a=0;else if(c=='G')a=6;px[a][pn[a]]=x;py[a][pn[a]++]=y;}}}am=0;for(a0=0;a0<5;a0++){M[a0][0][0]=0;Calc(0,1+(a0+1)%5);for(a=0;a<3;a++)Calc(1+(a0+a+1)%5,1+(a0+a+2)%5);Calc(1+(a0+4)%5,6);if(M[a0][6][0]<M[am][6][0])am=a0;}printf(M[am][6][0]!=1e9?\"%d %d\\n\":\"NA\\n\",1+am,M[am][6][0]);}{int n;for(n=1000000;n--;)getchar();}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX 1000\n#define INF 1000000000\n\ntypedef struct {\n    int x, y, mask;\n} State;\n\ntypedef struct {\n    int x, y;\n} Point;\n\nchar map[MAX][MAX];\nint W, H;\nPoint start, goal;\nPoint creatures[5][MAX];\nint creature_count[5];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\ntypedef struct {\n    State data[MAX * MAX * 32];\n    int front, rear;\n} Queue;\n\nvoid init_queue(Queue *q) {\n    q->front = 0;\n    q->rear = 0;\n}\n\nvoid enqueue(Queue *q, State s) {\n    q->data[q->rear++] = s;\n}\n\nState dequeue(Queue *q) {\n    return q->data[q->front++];\n}\n\nint is_empty(Queue *q) {\n    return q->front == q->rear;\n}\n\nint bfs(int start_attr) {\n    int dist[MAX][MAX][32];\n    int i, j, k;\n    \n    for (i = 0; i < H; i++) {\n        for (j = 0; j < W; j++) {\n            for (k = 0; k < 32; k++) {\n                dist[i][j][k] = INF;\n            }\n        }\n    }\n    \n    Queue q;\n    init_queue(&q);\n    \n    State s;\n    s.x = start.x;\n    s.y = start.y;\n    s.mask = (1 << start_attr);\n    dist[s.x][s.y][s.mask] = 0;\n    enqueue(&q, s);\n    \n    while (!is_empty(&q)) {\n        State cur = dequeue(&q);\n        int cx = cur.x;\n        int cy = cur.y;\n        int cmask = cur.mask;\n        \n        if (cx == goal.x && cy == goal.y && cmask == 31) {\n            return dist[cx][cy][cmask];\n        }\n        \n        for (i = 0; i < 4; i++) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n            \n            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            \n            int nmask = cmask;\n            \n            if (map[nx][ny] >= '1' && map[nx][ny] <= '5') {\n                int attr = map[nx][ny] - '1';\n                int can_catch = 0;\n                \n                for (j = 0; j < 5; j++) {\n                    if (cmask & (1 << j)) {\n                        int catchable = (j + 1) % 5;\n                        if (catchable == attr) {\n                            can_catch = 1;\n                            break;\n                        }\n                    }\n                }\n                \n                if (can_catch) {\n                    nmask |= (1 << attr);\n                }\n            }\n            \n            if (dist[nx][ny][nmask] > dist[cx][cy][cmask] + 1) {\n                dist[nx][ny][nmask] = dist[cx][cy][cmask] + 1;\n                State ns;\n                ns.x = nx;\n                ns.y = ny;\n                ns.mask = nmask;\n                enqueue(&q, ns);\n            }\n        }\n    }\n    \n    return INF;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &W, &H);\n        if (W == 0 && H == 0) break;\n        \n        int i, j;\n        for (i = 0; i < 5; i++) {\n            creature_count[i] = 0;\n        }\n        \n        for (i = 0; i < H; i++) {\n            scanf(\"%s\", map[i]);\n            for (j = 0; j < W; j++) {\n                if (map[i][j] == 'S') {\n                    start.x = i;\n                    start.y = j;\n                } else if (map[i][j] == 'G') {\n                    goal.x = i;\n                    goal.y = j;\n                } else if (map[i][j] >= '1' && map[i][j] <= '5') {\n                    int attr = map[i][j] - '1';\n                    creatures[attr][creature_count[attr]].x = i;\n                    creatures[attr][creature_count[attr]].y = j;\n                    creature_count[attr]++;\n                }\n            }\n        }\n        \n        int min_dist = INF;\n        int best_attr = -1;\n        \n        for (i = 0; i < 5; i++) {\n            int d = bfs(i);\n            if (d < min_dist) {\n                min_dist = d;\n                best_attr = i;\n            }\n        }\n        \n        if (min_dist == INF) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d %d\\n\", best_attr + 1, min_dist);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  1000 #define  int  typedef struct { int x, y; } Point; char map[MAX][MAX]; int W, H; Point start, goal; Point creatures[5][MAX]; int  0, 1, -1}; int dy[] = {1, -1, 0, 0}; typedef struct { State data[MAX * MAX *  Queue; void init_queue(Queue *q) { q->front = 0; q->rear = 0; } void enqueue(Queue *q, State s)  State dequeue(Queue  int is_empty(Queue *q) { return q->front ==  { int dist[MAX][MAX][32]; int i, j, k; for (i = 0; i < H; i++)  j < W; j++) { for (k = 0; k < 32; k++) { dist[i][j][k] = INF; } } } Queue  = start.x; s.y = start.y; s.mask  =  { State cur = dequeue(&q); int cx = cur.x; int cy = cur.y; int cmask = cur.mask; if (cx  goal.y && cmask == 31) { return dist[cx][cy][cmask]; } for (i = 0; i < 4; i++) { int nx =  if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue; int nmask = cmask; if (map[nx][ny] >= '1' && map[nx][ny] <= '5') { int  for (j = 0; j < 5; j++) { if  { int catchable = (j + 1) %  { can_catch = 1;  (can_catch) { nmask |= (1 << attr); } }  1) { dist[nx][ny][nmask] = dist[cx][cy][cmask] + 1; State ns; ns.x  ns.mask = nmask; enqueue(&q, ns); } } } return INF; } int main() { while (1) { scanf(\"%d %d\", &W, &H); if (W == 0 && H == 0) break; int i, j; for (i = 0; i < 5; i++) { creature_count[i] = 0; } for (i = 0; i < H; i++) { scanf(\"%s\", map[i]); for (j = 0; j  (map[i][j] == 'S') { start.x = i; start.y = j; } else if (map[i][j] == 'G') { goal.x = i; goal.y  (map[i][j] >= '1' && map[i][j] <= '5') { int attr = map[i][j] -  = j; creature_count[attr]++; } } } int min_dist = INF; int best_attr = -1; for (i = 0; i < 5;  bfs(i); if (d   INF)  printf(\"%d %d\\n\", best_attr + 1, min_dist); } } return 0; }"], "perturbed_original": ["mx,my;pn[7];px[7][1000],py[7][1000];M[5][7][1000];a0;Calc(a1,a2){int n1,n2,m,mm;for(n2=0;n2<pn[a2];n2++){mm=1e9;for(n1=0;n1<pn[a1];n1++){m=M[a0][a1][n1]+abs(px[a1][n1]-px[a2][n2])+abs(py[a1][n1]-py[a2][n2]);if(m<mm)mm=m;}M[a0][a2][n2]=mm;}}main(){int x,y,c,a,am;for(;scanf(\"%d%d\\n\",&mx,&my),mx;){memset(pn,0,sizeof(pn));for(y=0;y<my;y++){for(x=0;x<=mx;x++){c=getchar();if(c>='1'){if(c<='5')a=c-'0';else if(c=='S')a=0;else if(c=='G')a=6;px[a][pn[a]]=x;py[a][pn[a]++]=y;}}}am=0;for(a0=0;a0<5;a0++){M[a0][0][0]=0;Calc(0,1+(a0+1)%5);for(a=0;a<3;a++)Calc(1+(a0+a+1)%5,1+(a0+a+2)%5);Calc(1+(a0+4)%5,6);if(M[a0][6][0]<M[am][6][0])am=a0;}printf(M[am][6][0]!=1e9?\"%d %d\\n\":\"NA\\n\",1+am,M[am][6][0]);}{int n;for(n=1000000;n--;)getchar();}exit(0);}"], "original_ll": -1.2062004804611206, "sampled_ll": -0.3254285156726837, "all_perturbed_sampled_ll": [-1.2788816690444946], "all_perturbed_original_ll": [-1.2062004804611206], "perturbed_sampled_ll": -1.2788816690444946, "perturbed_original_ll": -1.2062004804611206, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\t/** ????\u00a7??????? */\n\tstatic final String WHITE_SPACE = \" \";\n\n\t/** ??????????????????_X */\n\tstatic int mapSizeX = 0;\n\n\t/** ??????????????????_Y */\n\tstatic int mapSizeY = 0;\n\n\t/** ??????????????\u00b0 */\n\tstatic int maxNode = 0;\n\n\t/** ????????\u00a2??????????????? */\n\tstatic List<Point> pachimonList = new ArrayList<Point>();\n\n\t/** ?????????????\u00a8??????????????????????????\u00b4??????? */\n\tstatic boolean[] visited = new boolean[5003];\n\n\t/** ??????????????????????????? */\n\tstatic int[] cost = new int[5003];\n\n\t/** ?????????????????? */\n\tstatic int startIdx = 0;\n\n\t/** ??\u00b4???????????? */\n\tstatic int goalIdx = 0;\n\n\t/**\n\t * @param args\n\t * @throws IOException\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\tString[] mapSizeLine = new String[2];\n\t\tPoint output = createPos(0, Integer.MAX_VALUE);\n\t\twhile (true) {\n\t\t\tmapSizeLine = br.readLine().split(WHITE_SPACE);\n\t\t\tmapSizeX = Integer.parseInt(mapSizeLine[0]);\n\t\t\tmapSizeY = Integer.parseInt(mapSizeLine[1]);\n\t\t\tif (mapSizeX == 0 && mapSizeY == 0)\n\t\t\t\tbreak;\n\n\t\t\treadMap(br);\n\t\t\toutput.x = 0;\n\t\t\toutput.y = Integer.MAX_VALUE;\n\t\t\tif (maxNode > 5) {\n\t\t\t\tfor (int type = 1; type <= 5; type++) {\n\t\t\t\t\t// ??????????????????????????\u00a2??????????????????????????????????????????????\u00b4\u00a2\n\t\t\t\t\tint cost = searchRoute(type);\n\t\t\t\t\tif (cost < output.y && cost > 0) {\n\t\t\t\t\t\toutput.x = type;\n\t\t\t\t\t\toutput.y = cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ???????????????\n\t\t\tif (output.y == Integer.MAX_VALUE) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(output.x + WHITE_SPACE + output.y);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * ?????????????????????????????????\n\t * @param scanner ????????\u00a3??????\n\t * @throws IOException\n\t */\n\tprivate static void readMap(BufferedReader br) throws IOException {\n\t\t// ??????????????\u00b1????????????\n\t\tpachimonList.removeAll(pachimonList);\n\t\tmaxNode = 0;\n\t\tstartIdx = 0;\n\n\t\tfor (int i = 0; i < mapSizeY; i++) {\n\t\t\tfor (int j = 0; j < mapSizeX; j++) {\n\t\t\t\tint val = convertInt(br.read());\n\t\t\t\tif (val < 9) {\n\t\t\t\t\t// ???????????\u00a2????????\u00b0????\u00a8????\n\t\t\t\t\tif (val == 0)\n\t\t\t\t\t\tstartIdx = pachimonList.size();\n\t\t\t\t\tif (val == 6)\n\t\t\t\t\t\tgoalIdx = pachimonList.size();\n\t\t\t\t\tpachimonList.add(createPos(val, calcIndex(j, i)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????????????\u00a3???\u00b0???\n\t\t\tbr.readLine();\n\t\t}\n\t\tmaxNode = pachimonList.size();\n\t}\n\n\t/**\n\t * ??\u00a2????????????????????????int??????????????????\n\t * @param target ????\u00b1??????????\n\t * @return ???????????????\n\t */\n\tprivate static int convertInt(int target) {\n\t\tif (target == 83)\n\t\t\treturn 0;\n\t\tif (target == 71)\n\t\t\treturn 6;\n\t\tif (target >= 49 && target <= 53)\n\t\t\treturn target - 48;\n\t\treturn 9;\n\t}\n\n\t/**\n\t * X????????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7????\u00a8????<br>\n\t * ????????????:0?????\u00b4??????:6???????????\u00a2???????\u00b1???\u00a7:1???5<br>\n\t * Y????????????????????????????????????????\u00b4?\n\t * @param type ?????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7\n\t * @param index ??????????????????????????????\n\t * @return\n\t */\n\tprivate static Point createPos(int type, int index) {\n\t\treturn new Point(type, index);\n\t}\n\n\t/**\n\t * ?????\u00a8????????\u00a2???????????????????????????????????????????????\u00a2???????\u00b1???\u00a7?????????\n\t * @param currentType ??????????????????????????\u00a2???????\u00b1???\u00a7\n\t * @return ?????????????????????????????\u00a2???????\u00b1???\u00a7\n\t */\n\tprivate static int getNextType(int currentType) {\n\t\tif (currentType == 5)\n\t\t\treturn 1;\n\t\treturn currentType + 1;\n\t}\n\n\t/**\n\t * ??????????????????????????\u00a2?????????????????????????????????????????\u00a2???????\u00b1???\u00a7?????????\n\t * @param firstType ??????????????????????????\u00a2???????\u00b1???\u00a7\n\t * @return ?????????????????????????????\u00a2???????\u00b1???\u00a7\n\t */\n\tprivate static int getEndType(int firstType) {\n\t\tif (firstType == 1)\n\t\t\treturn 5;\n\t\treturn firstType - 1;\n\t}\n\n\t/**\n\t * ??\u00a3??\\??????????\u00a8?????????????????????????????????\u00b4???????????\u00a7???<br>\n\t * ????????????????????????????\u00b1???????\n\t * @param adjacent ??\u00a3??\\??????\n\t * @return ????????????????????????\n\t */\n\tprivate static int searchRoute(int firstType) {\n\n\t\tfor (int i = 0; i < maxNode; i++) {\n\t\t\tcost[i] = Integer.MAX_VALUE;\n\t\t\tvisited[i] = false;\n\t\t}\n\n\t\t// ??????????????\u00b0????????\u00a7???????????????0\n\t\tcost[startIdx] = 0;\n\n\t\twhile (true) {\n\t\t\t// ?\u00a8?????????????????????????????????\u00a7?????????????????????????\u00b1???????\n\t\t\tint node = minIndex(cost, visited);\n\t\t\tif (node < 0) {\n\t\t\t\treturn cost[goalIdx];\n\t\t\t}\n\t\t\t// ??\u00a2?\u00b4\u00a2???????????????????????????????????\u00b0????????????\n\t\t\tvisited[node] = true;\n\t\t\tfor (int j = 0; j < maxNode; j++) {\n\t\t\t\tif (isLinked(node, j, firstType) && !visited[j]) {\n\t\t\t\t\tint nextNodeCost = cost[node] + clucCost(pachimonList.get(node), pachimonList.get(j));\n\t\t\t\t\t// ????????\u00a7????????\u00a2??????????\u00b0????????????\u00b0???????????\u00a2??\u00a8???????\u00a8???\u00b6\n\t\t\t\t\tif (nextNodeCost < cost[j]) {\n\t\t\t\t\t\tcost[j] = nextNodeCost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * ?????\u00a8??????????????\u00a8????\u00b1??????????????????\\?\u00b6?????????????????????????????????\\\n\t * @param node ?????\u00a8????????????\n\t * @param target ????\u00b1?????????????\n\t * @return ?????\\??????\n\t */\n\tprivate static boolean isLinked(int node, int target, int firstType) {\n\t\tint currentType = pachimonList.get(node).x;\n\t\tint targetType = pachimonList.get(target).x;\n\t\t// ??????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????????????????????????????????????????\\?\u00b6????????????????\n\t\tif (currentType == firstType)\n\t\t\treturn false;\n\t\t// ????\u00b1??????????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????\u00b4????????\\?\u00b6????????????????\n\t\tif (targetType == firstType)\n\t\t\treturn false;\n\t\t// ??????????????\u00b4???????????\u00b4????????\\?\u00b6??????????????????????????????????\n\t\tif (currentType == maxNode)\n\t\t\treturn false;\n\n\t\t// ????????????????????????(\"0\")?????\u00b4??????????\u00b1???????????????????????????\u00a2???????\u00b1???\u00a7????\u00ac?????????\\?\u00b6????????????????\n\t\tif (currentType == 0)\n\t\t\treturn targetType == getNextType(firstType);\n\n\t\t// ?????\u00a8????????????????\u00b1???\u00a7????????????????????????????????\u00a2????????\u00b4????????\u00b4??????????????\\?\u00b6?\n\t\tif (currentType == getEndType(firstType))\n\t\t\treturn targetType == 6;\n\n\t\treturn getNextType(currentType) == targetType;\n\t}\n\n\t/**\n\t * ?\u00a8???????????????????????????????????????????????????????????????????????????????????\u00b1???????\n\t * @param cost ???????????????????????????\n\t * @param visited ?????????????\u00a8??????????????????????????\u00b4???????\n\t * @return ??????????????????\n\t */\n\tprivate static int minIndex(int[] cost, boolean[] visited) {\n\t\tint index = 0;\n\t\tfor (; index < maxNode; index++) {\n\t\t\tif (!visited[index])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (index == maxNode)\n\t\t\treturn -1;\n\t\tfor (int i = index + 1; i < maxNode; i++) {\n\t\t\tif (!visited[i] && cost[i] < cost[index])\n\t\t\t\tindex = i;\n\t\t}\n\t\treturn index;\n\t}\n\n\t/**\n\t * ????????????????????????????????\u00b4???????????\u00a7????????????????\u00a8?????????????\n\t * @param sx ???????????????X??\u00a7?\u00a8?\n\t * @param sy ???????????????Y??\u00a7?\u00a8?\n\t * @param gx ??\u00b4?????????X??\u00a7?\u00a8?\n\t * @param gy ??\u00b4?????????Y??\u00a7?\u00a8?\n\t * @param nextType ?\u00ac????????????????????????\u00a2????\u00b1???\u00a7\n\t */\n\tprivate static int clucCost(Point from, Point to) {\n\t\tint fx = from.y / mapSizeY;\n\t\tint fy = from.y % mapSizeY;\n\t\tint tx = to.y / mapSizeY;\n\t\tint ty = to.y % mapSizeY;\n\t\treturn Math.abs(tx - fx) + Math.abs(ty - fy);\n\t}\n\n\t/**\n\t * X??\u00a7?\u00a8???\u00a8Y??\u00a7?\u00a8???????????????\u00a3?????????????????????????????????????????\u00b4?????????\n\t *\n\t * @param x X??\u00a7?\u00a8?\n\t * @param y Y??\u00a7?\u00a8?\n\t * @return\n\t */\n\tprivate static int calcIndex(int x, int y) {\n\t\treturn x * mapSizeY + y;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] tokens = line.trim().split(\"\\\\s+\");\n            int W = Integer.parseInt(tokens[0]);\n            int H = Integer.parseInt(tokens[1]);\n            \n            if (W == 0 && H == 0) break;\n            \n            char[][] map = new char[H][W];\n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            \n            for (int i = 0; i < H; i++) {\n                String row = br.readLine();\n                for (int j = 0; j < W; j++) {\n                    map[i][j] = row.charAt(j);\n                    if (map[i][j] == 'S') {\n                        sx = i;\n                        sy = j;\n                    } else if (map[i][j] == 'G') {\n                        gx = i;\n                        gy = j;\n                    }\n                }\n            }\n            \n            int minDist = Integer.MAX_VALUE;\n            int bestAttr = -1;\n            \n            for (int startAttr = 1; startAttr <= 5; startAttr++) {\n                int dist = solve(map, H, W, sx, sy, gx, gy, startAttr);\n                if (dist != -1 && dist < minDist) {\n                    minDist = dist;\n                    bestAttr = startAttr;\n                }\n            }\n            \n            if (bestAttr == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(bestAttr + \" \" + minDist);\n            }\n        }\n    }\n    \n    static int solve(char[][] map, int H, int W, int sx, int sy, int gx, int gy, int startAttr) {\n        int targetMask = 0;\n        for (int i = 1; i <= 5; i++) {\n            if (i != startAttr) {\n                targetMask |= (1 << i);\n            }\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Map<String, Integer> visited = new HashMap<>();\n        \n        int initialMask = (1 << startAttr);\n        State start = new State(sx, sy, initialMask, 0);\n        queue.offer(start);\n        visited.put(sx + \",\" + sy + \",\" + initialMask, 0);\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.x == gx && curr.y == gy && (curr.mask & targetMask) == targetMask) {\n                return curr.dist;\n            }\n            \n            for (int d = 0; d < 4; d++) {\n                int nx = curr.x + dx[d];\n                int ny = curr.y + dy[d];\n                \n                if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                \n                int newMask = curr.mask;\n                char cell = map[nx][ny];\n                \n                if (cell >= '1' && cell <= '5') {\n                    int attr = cell - '0';\n                    if (canCatch(curr.mask, attr)) {\n                        newMask |= (1 << attr);\n                    }\n                }\n                \n                String key = nx + \",\" + ny + \",\" + newMask;\n                if (!visited.containsKey(key) || visited.get(key) > curr.dist + 1) {\n                    visited.put(key, curr.dist + 1);\n                    queue.offer(new State(nx, ny, newMask, curr.dist + 1));\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static boolean canCatch(int mask, int target) {\n        int[] catchMap = {0, 2, 3, 4, 5, 1}; // 1->2, 2->3, 3->4, 4->5, 5->1\n        for (int i = 1; i <= 5; i++) {\n            if ((mask & (1 << i)) != 0 && catchMap[i] == target) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    static class State {\n        int x, y, mask, dist;\n        \n        State(int x, int y, int mask, int dist) {\n            this.x = x;\n            this.y = y;\n            this.mask = mask;\n            this.dist = dist;\n        }\n    }\n}\n", "perturbed_sampled": ["import  Main { static int[] dx  static int[] dy = {1, -1, 0, 0}; public static void main(String[]  br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] tokens =  int H = Integer.parseInt(tokens[1]); if (W == 0  char[][] map = new char[H][W]; int sx = -1, sy = -1, gx = -1, gy  = 0; i < H;  br.readLine(); for (int j =  { map[i][j]  'S') { sx = i; sy = j; }  { gx = i; gy = j;  = Integer.MAX_VALUE; int bestAttr  = 1; startAttr <= 5;  solve(map, H, W, sx, sy, gx, gy, startAttr); if (dist != -1 && dist < minDist)   (bestAttr == -1) { System.out.println(\"NA\"); } else { System.out.println(bestAttr + \" \" + minDist); } } } static int solve(char[][] map, int H, int W, int sx, int sy, int gx, int gy, int startAttr) { int targetMask = 0;  i <= 5; i++) { if (i !=  Queue<State> queue = new LinkedList<>(); Map<String, Integer> visited = new HashMap<>(); int initialMask = (1 << startAttr); State start = new State(sx, sy, initialMask, 0); queue.offer(start);  + \",\" + initialMask, 0); while (!queue.isEmpty()) { State   gy && (curr.mask & targetMask)  = 0; d < 4; d++) { int nx =  = curr.y + dy[d]; if (nx  H || ny < 0 || ny >= W) continue; int newMask = curr.mask; char cell = map[nx][ny]; if (cell >= '1' && cell  = cell - '0'; if (canCatch(curr.mask, attr)) { newMask |= (1 << attr); } } String key = nx + \",\" + ny + \",\" + newMask; if (!visited.containsKey(key) || visited.get(key) > curr.dist + 1) { visited.put(key, curr.dist + 1); queue.offer(new State(nx, ny, newMask, curr.dist + 1)); } }  boolean canCatch(int mask, int target) { int[] catchMap =  1}; // 1->2, 2->3, 3->4, 4->5, 5->1 for (int i = 1; i <= 5; i++) {  i)) != 0 && catchMap[i] == target) { return true; } } return false; } static class State { int x, y, mask, dist;  mask, int dist) { this.x = x; this.y = y; this.mask = mask; this.dist = dist; } } }"], "perturbed_original": ["import java.awt.Point;  java.io.InputStreamReader; import java.util.ArrayList; import java.util.List; public class Main { /** ????\u00a7??????? */ static final String WHITE_SPACE = \" \"; /** ??????????????????_X */ static int mapSizeX = 0; /** ??????????????????_Y */ static int mapSizeY = 0; /**  = 0;  pachimonList = new ArrayList<Point>(); /** ?????????????\u00a8??????????????????????????\u00b4??????? */ static boolean[] visited = new boolean[5003]; /** ??????????????????????????? */ static int[] cost = new int[5003]; /** ?????????????????? */ static int startIdx = 0; /**   args * @throws IOException  args) throws IOException { InputStreamReader is =  new BufferedReader(is); String[] mapSizeLine = new String[2]; Point output = createPos(0, Integer.MAX_VALUE); while (true) { mapSizeLine = br.readLine().split(WHITE_SPACE); mapSizeX = Integer.parseInt(mapSizeLine[0]); mapSizeY = Integer.parseInt(mapSizeLine[1]); if (mapSizeX == 0 && mapSizeY == 0) break; readMap(br); output.x = 0; output.y = Integer.MAX_VALUE; if (maxNode > 5) { for (int type = 1; type <= 5; type++) { // ??????????????????????????\u00a2??????????????????????????????????????????????\u00b4\u00a2 int cost = searchRoute(type); if (cost < output.y && cost > 0) { output.x = type; output.y = cost; } } } // ??????????????? if (output.y ==  { System.out.println(output.x + WHITE_SPACE + output.y); } } } /** * ?????????????????????????????????  @throws IOException  br)  pachimonList.removeAll(pachimonList); maxNode = 0; startIdx =  0; i  { int val  9) { //  startIdx = pachimonList.size(); if (val ==  // ????????????????\u00a3???\u00b0??? br.readLine(); } maxNode = pachimonList.size(); } /** * ??\u00a2????????????????????????int?????????????????? * @param target ????\u00b1?????????? * @return ??????????????? */ private static int convertInt(int target) { if (target == 83) return 0; if (target == 71) return 6; if (target >= 49 && target <= 53) return target - 48; return 9; } /** * X????????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7????\u00a8????<br> * ????????????:0?????\u00b4??????:6???????????\u00a2???????\u00b1???\u00a7:1???5<br> * Y????????????????????????????????????????\u00b4? * @param type ?????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7 * @param index ?????????????????????????????? * @return */ private static Point createPos(int type, int  index); } /** *  * @return ?????????????????????????????\u00a2???????\u00b1???\u00a7 */ private static int getNextType(int currentType) { if   /** * ??????????????????????????\u00a2?????????????????????????????????????????\u00a2???????\u00b1???\u00a7????????? * @param firstType ??????????????????????????\u00a2???????\u00b1???\u00a7 * @return   return firstType - 1;  ????????????????????????????\u00b1??????? * @param adjacent ??\u00a3??\\?????? * @return ???????????????????????? */ private static int searchRoute(int firstType) { for (int i =  { cost[i]  } // ??????????????\u00b0????????\u00a7???????????????0 cost[startIdx] = 0; while (true) { // ?\u00a8?????????????????????????????????\u00a7?????????????????????????\u00b1??????? int node = minIndex(cost, visited); if  cost[goalIdx];  true; for (int j = 0; j < maxNode; j++) { if  cost[node] + clucCost(pachimonList.get(node), pachimonList.get(j)); // ????????\u00a7????????\u00a2??????????\u00b0????????????\u00b0???????????\u00a2??\u00a8???????\u00a8???\u00b6 if (nextNodeCost < cost[j]) { cost[j] = nextNodeCost; } } } } } /** * ?????\u00a8??????????????\u00a8????\u00b1??????????????????\\?\u00b6?????????????????????????????????\\ * @param node ?????\u00a8???????????? * @param target ????\u00b1????????????? * @return ?????\\?????? */ private  target, int firstType)  int targetType = pachimonList.get(target).x; //  return false; // ????\u00b1??????????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????\u00b4????????\\?\u00b6???????????????? if (targetType == firstType) return false;  maxNode) return false; // ????????????????????????(\"0\")?????\u00b4??????????\u00b1???????????????????????????\u00a2???????\u00b1???\u00a7????\u00ac?????????\\?\u00b6???????????????? if (currentType == 0) return targetType == getNextType(firstType); // ?????\u00a8????????????????\u00b1???\u00a7????????????????????????????????\u00a2????????\u00b4????????\u00b4??????????????\\?\u00b6? if (currentType == getEndType(firstType)) return targetType == 6; return getNextType(currentType) == targetType; } /** * ?\u00a8???????????????????????????????????????????????????????????????????????????????????\u00b1??????? * @param cost ??????????????????????????? * @param visited ?????????????\u00a8??????????????????????????\u00b4???????  static int minIndex(int[] cost, boolean[] visited) { int index = 0; for (; index < maxNode; index++) { if (!visited[index]) break; } if (index == maxNode) return -1; for (int i = index + 1; i < maxNode; i++) { if (!visited[i] && cost[i]  } return index; } /**  ???????????????X??\u00a7?\u00a8? *  gx  * @param nextType ?\u00ac????????????????????????\u00a2????\u00b1???\u00a7 */ private static int   mapSizeY; int fy = from.y % mapSizeY; int tx = to.y / mapSizeY; int ty = to.y % mapSizeY; return Math.abs(tx - fx) + Math.abs(ty - fy); } /** * X??\u00a7?\u00a8???\u00a8Y??\u00a7?\u00a8???????????????\u00a3?????????????????????????????????????????\u00b4????????? * * @param x X??\u00a7?\u00a8?   calcIndex(int x, int y) { return x * mapSizeY + y; } }"], "original_ll": -0.9313032627105713, "sampled_ll": -0.34275561571121216, "all_perturbed_sampled_ll": [-1.4701899290084839], "all_perturbed_original_ll": [-1.7325448989868164], "perturbed_sampled_ll": -1.4701899290084839, "perturbed_original_ll": -1.7325448989868164, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import product\n# from line_profiler import LineProfiler\ndef main():\n    while(True):\n        W, H = map(int,input().split())\n        if not W: break\n        # ma = [[-1]*(W+2) for _ in range(H+2)]\n        ps = [[] for _ in range(5)]\n        ans = 10**10\n        for i in range(H):\n            for j,a in enumerate(input()):\n                if a == \"S\": ss = [[i,j]]\n                elif a == \"G\": gg = [[i,j]]\n                elif a != \".\": ps[int(a)-1].append([i,j])\n        # if [1 for i in range(5) if len(ps[i])==0]:\n        #     print(\"NA\"); continue\n        # print(ps)\n        B = float(\"inf\")\n        Bi = -1\n        for mon1 in range(5):\n            dp = [[float(\"inf\")]*1000 for _ in range(5)]\n            cand = [[0,ss[0][0],ss[0][1]]]\n            for mon2 in range(5):\n                dpCacheNow = dp[mon2]\n                dpCacheNxt = dp[(mon1+mon2+1)%5]\n                dpCacheNow[0] = 0\n                nxt = ps[(mon1+mon2+1)%5] if mon2<4 else gg\n                # print(nxt)\n                # print(cand)\n                tmp = []\n                for i,[ty,tx] in enumerate(nxt):\n                    # if dpCacheNow[i] >= B:\n                    #     continue\n                    tc = float(\"inf\")\n                    # for cc,cy,cx in cand:\n                    for cc,cy,cx in cand:\n                        if cc > B:\n                            # print(\"a\",end=\"\")\n                            tc = float(\"inf\")\n                            break\n                        else:\n                            tc = min(tc,abs(ty-cy)+abs(tx-cx)+cc)\n                    tmp.append([tc,ty,tx])\n                    dpCacheNxt[i] = min(dpCacheNxt[i],tc)\n                cand = tmp\n            if cand[0][0] < B:\n                B = cand[0][0]\n                Bi = mon1\n        if(Bi == -1):\n            print(\"NA\")\n        else:\n            print(\"%d %d\"%(Bi+1,B))\n        # for mon1 in range(5):\n        #     mon2 = (mon1+1)%5\n        #     dp = [[10**10]*1000 for _ in range(5)]\n        #     for i,yx in enumerate(ps[mon2]):\n        #         dp[mon2][i] = abs(ss[0]-yx[0])+abs(ss[1]-yx[1])\n        #     mon3 = mon2\n        #     for mon3 in range(mon2,mon2+3):\n        #         mon3 = mon3%5\n        #         mon4 = (mon3+1)%5\n        #         for [i,yx],[j,nyx] in product(enumerate(ps[mon3]),enumerate(ps[mon4])):\n        #             dp[mon4][j] = min(dp[mon4][j],dp[mon3][i]+abs(yx[0]-nyx[0])+abs(yx[1]-nyx[1]))\n        #     mon5 = (mon1-1)%5\n        #     for i,yx in enumerate(ps[mon5]):\n        #         d = dp[mon5][i] + abs(gg[0]-yx[0])+abs(gg[1]-yx[1])\n        #         if ans > d:\n        #             ans,ansi = d,mon1\n        # print(ansi+1,ans)\n\nif __name__ == \"__main__\":\n    # prf = LineProfiler()\n    # prf.add_function(main)\n    # prf.runcall(main)\n    # prf.print_stats()\n    main()\n", "sampled": "from collections import deque\nimport sys\n\ndef bfs(grid, start, H, W):\n    \"\"\"BFS to find shortest distances from start to all positions\"\"\"\n    dist = [[-1] * W for _ in range(H)]\n    queue = deque([start])\n    dist[start[0]][start[1]] = 0\n    \n    while queue:\n        r, c = queue.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and dist[nr][nc] == -1:\n                dist[nr][nc] = dist[r][c] + 1\n                queue.append((nr, nc))\n    \n    return dist\n\ndef solve(W, H, grid):\n    # Find S and G positions\n    start = goal = None\n    creatures = {1: [], 2: [], 3: [], 4: [], 5: []}\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n            elif grid[i][j] in '12345':\n                creatures[int(grid[i][j])].append((i, j))\n    \n    # can_catch[attr] gives which attribute attr can catch\n    can_catch = {1: 2, 2: 3, 3: 4, 4: 5, 5: 1}\n    \n    # Compute distances from start and goal\n    dist_from_start = bfs(grid, start, H, W)\n    dist_from_goal = bfs(grid, goal, H, W)\n    \n    # For each creature position, compute distance from start and to goal\n    creature_dists = {}\n    for attr in range(1, 6):\n        creature_dists[attr] = []\n        for pos in creatures[attr]:\n            ds = dist_from_start[pos[0]][pos[1]]\n            dg = dist_from_goal[pos[0]][pos[1]]\n            if ds != -1 and dg != -1:\n                creature_dists[attr].append((ds, dg, pos))\n    \n    best_attr = None\n    best_dist = float('inf')\n    \n    # Try each starting attribute\n    for start_attr in range(1, 6):\n        # Need to catch the other 4 attributes\n        to_catch = [attr for attr in range(1, 6) if attr != start_attr]\n        \n        # Check if we can catch all required attributes\n        can_solve = True\n        for attr in to_catch:\n            if not creature_dists[attr]:\n                can_solve = False\n                break\n        \n        if not can_solve:\n            continue\n        \n        # State: (current_attr, caught_set) where caught_set is a frozenset of caught attributes\n        # We want to find minimum distance to reach goal with all attributes caught\n        \n        # Use Dijkstra-like approach with states\n        from heapq import heappush, heappop\n        \n        initial_state = (start_attr, frozenset([start_attr]))\n        # dist_state[(attr, caught)] = minimum distance to have attr and caught set\n        dist_state = {}\n        dist_state[initial_state] = 0\n        pq = [(0, start_attr, frozenset([start_attr]))]\n        \n        min_dist_to_goal = float('inf')\n        \n        while pq:\n            d, curr_attr, caught = heappop(pq)\n            \n            if d > dist_state.get((curr_attr, caught), float('inf')):\n                continue\n            \n            # Check if we have all attributes and can go to goal\n            if len(caught) == 5:\n                min_dist_to_goal = min(min_dist_to_goal, d + dist_from_goal[start[0]][start[1]])\n                continue\n            \n            # Try to catch next creature\n            next_attr = can_catch[curr_attr]\n            if next_attr not in caught and creature_dists[next_attr]:\n                # Find closest creature of next_attr from current position\n                # We need to track position too...\n                \n                for ds, dg, pos in creature_dists[next_attr]:\n                    new_caught = caught | {next_attr}\n                    new_dist = ds  # Distance from start to this creature\n                    new_state = (next_attr, new_caught)\n                    \n                    if new_dist < dist_state.get(new_state, float('inf')):\n                        dist_state[new_state] = new_dist\n                        heappush(pq, (new_dist, next_attr, new_caught))\n        \n        # This approach is getting complex. Let me try simpler state space.\n        # State: frozenset of caught attributes\n        # For each state, track minimum distance and where we are\n        \n        # Actually, let's use different approach\n        # Try all permutations of catching order and compute minimum\n        \n        from itertools import permutations\n        \n        for order in permutations(to_catch):\n            # Check if this order is valid (can catch in sequence)\n            current_attr = start_attr\n            valid = True\n            for attr in order:\n                if can_catch[current_attr] != attr:\n                    valid = False\n                    break\n                current_attr = attr\n            \n            if not valid:\n                continue\n            \n            # Compute minimum distance for this order\n            total_dist = 0\n            prev_pos = start\n            valid_path = True\n            \n            for attr in order:\n                # Find closest creature of this attribute from prev_pos\n                min_d = float('inf')\n                next_pos = None\n                \n                for pos in creatures[attr]:\n                    # BFS from prev_pos to pos\n                    d = dist_from_start[pos[0]][pos[1]]  # This is wrong, need distance from prev_pos\n                    \n                # This is getting complicated. Need to precompute all distances\n                \n        # Let me use a simpler DP approach with memoization\n        \n    # Simpler approach: try all orderings using DP\n    # Actually the constraints make this feasible\n    \n    # For each starting attribute, do BFS on state space\n    for start_attr in range(1, 6):\n        # BFS on (position, caught_set)\n        initial = (start, frozenset([start_attr]), start_attr)\n        queue = deque([initial])\n        visited = {(start, frozenset([start_attr]), start_attr): 0}\n        \n        while queue:\n            pos, caught, curr_attr = queue.popleft()\n            dist = visited[(pos, caught, curr_attr)]\n            \n            # If we have all 5 attributes and at goal\n            if len(caught) == 5 and pos == goal:\n                if dist < best_dist or (dist == best_dist and start_attr < best_attr):\n                    best_dist = dist\n                    best_attr = start_attr\n                continue\n            \n            # Try moving to adjacent cells\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = pos[0] + dr, pos[1] + dc\n                if 0 <= nr < H and 0 <= nc < W:\n                    new_pos = (nr, nc)\n                    new_caught = caught\n                    new_attr = curr_attr\n                    \n                    # Check if we catch a creature here\n                    cell = grid[nr][nc]\n                    if cell in '12345':\n                        creature_attr = int(cell)\n                        if can_catch[curr_attr] == creature_attr:\n                            new_caught = caught | {creature_attr}\n                            new_attr = creature_attr\n                    \n                    new_state = (new_pos, new_caught, new_attr)\n                    if new_state not in visited or visited[new_state] > dist + 1:\n                        visited[new_state] = dist + 1\n                        queue.append(new_state)\n    \n    if best_attr is None:\n        return \"NA\"\n    else:\n        return f\"{best_attr} {best_dist}\"\n\nwhile True:\n    line = input().split()\n    W, H = int(line[0]), int(line[1])\n    if W == 0 and H == 0:\n        break\n    \n    grid = []\n    for _ in range(H):\n        grid.append(input().strip())\n    \n    print(solve(W, H, grid))\n", "perturbed_sampled": ["from collections import deque import sys def  to find shortest distances from  = [[-1] * W for _ in range(H)] queue = deque([start]) dist[start[0]][start[1]] = 0 while  for dr, dc in [(0, 1), (0,  nr, nc = r + dr, c  nr < H and 0  dist[nr][nc] == -1: dist[nr][nc] = dist[r][c] + 1 queue.append((nr, nc)) return dist def solve(W, H, grid): # Find S and G positions start = goal  [], 2: [], 3: [], 4: [], 5: []} for i in range(H): for j in range(W): if grid[i][j] == 'S': start = (i, j) elif  (i, j) elif grid[i][j] in '12345': creatures[int(grid[i][j])].append((i, j)) # can_catch[attr] gives which attribute attr can catch can_catch = {1: 2, 2: 3, 3: 4, 4: 5, 5: 1}  and goal dist_from_start = bfs(grid, start,  For each creature position, compute distance from start and to goal creature_dists = {} for attr in range(1, 6):  in creatures[attr]:  dist_from_goal[pos[0]][pos[1]] if ds != -1  dg, pos)) best_attr = None best_dist = float('inf') #  # Need   attr in range(1, 6) if attr != start_attr]  catch all required attributes can_solve = True  not creature_dists[attr]: can_solve = False break if not can_solve: continue # State: (current_attr, caught_set) where caught_set is a frozenset of caught attributes #  distance to reach goal with all attributes caught # Use Dijkstra-like approach with states from heapq import heappush, heappop initial_state = (start_attr, frozenset([start_attr])) # dist_state[(attr, caught)] = minimum distance to have attr and caught set dist_state = {} dist_state[initial_state] = 0 pq = [(0, start_attr, frozenset([start_attr]))] min_dist_to_goal = float('inf') while pq: d,  d > dist_state.get((curr_attr, caught), float('inf')): continue # Check if we have all attributes and can go to goal if len(caught) == 5: min_dist_to_goal = min(min_dist_to_goal, d + dist_from_goal[start[0]][start[1]]) continue  creature next_attr = can_catch[curr_attr] if next_attr not in caught and creature_dists[next_attr]: # Find closest creature of next_attr  need to track position too... for ds, dg, pos in creature_dists[next_attr]: new_caught = caught | {next_attr} new_dist = ds # Distance from start to this  if new_dist < dist_state.get(new_state, float('inf')): dist_state[new_state] = new_dist heappush(pq, (new_dist, next_attr, new_caught))  complex. Let me try simpler state  distance and where we are # Actually, let's use different approach # Try all  compute minimum from itertools import permutations for order in permutations(to_catch): # Check if  catch in sequence) current_attr = start_attr valid = True for attr in  valid = False break  valid: continue # Compute minimum distance for this order total_dist = 0 prev_pos = start valid_path = True for attr in order: # Find closest creature of this attribute from prev_pos min_d = float('inf') next_pos = None  BFS from prev_pos to pos d = dist_from_start[pos[0]][pos[1]] # This is wrong, need distance  getting complicated. Need to precompute all  a simpler DP approach with memoization # Simpler approach: try all orderings using DP # Actually the constraints make this feasible # For each starting attribute, do  start_attr in range(1, 6): # BFS on (position, caught_set) initial = (start, frozenset([start_attr]), start_attr) queue = deque([initial]) visited = {(start, frozenset([start_attr]), start_attr): 0} while queue: pos, caught,  visited[(pos, caught, curr_attr)] # If we have all 5 attributes and at goal if len(caught) == 5 and pos == goal: if dist < best_dist or (dist == best_dist and start_attr < best_attr): best_dist = dist best_attr = start_attr continue # Try  dr, dc in [(0, 1), (0, -1),  nc  +  < H and  = curr_attr # Check if we catch a  if cell in '12345': creature_attr  creature_attr: new_caught = caught | {creature_attr} new_attr = creature_attr new_state = (new_pos, new_caught, new_attr) if new_state not  dist + 1: visited[new_state] = dist + 1 queue.append(new_state) if best_attr is None: return  while True: line  int(line[0]), int(line[1]) if W == 0  _ in range(H): grid.append(input().strip()) print(solve(W, H, grid))"], "perturbed_original": ["from itertools import   ma = [[-1]*(W+2) for _ in range(H+2)]  in range(5)] ans = 10**10 for i in range(H): for  [[i,j]] elif a == \"G\": gg = [[i,j]]  # if [1 for i in range(5) if len(ps[i])==0]: # print(\"NA\"); continue # print(ps) B = float(\"inf\") Bi = -1 for mon1 in range(5): dp = [[float(\"inf\")]*1000 for _ in range(5)] cand = [[0,ss[0][0],ss[0][1]]] for mon2 in range(5): dpCacheNow = dp[mon2] dpCacheNxt = dp[(mon1+mon2+1)%5] dpCacheNow[0] = 0 nxt = ps[(mon1+mon2+1)%5] if mon2<4 else gg # print(nxt) # print(cand) tmp = [] for i,[ty,tx] in enumerate(nxt): # if dpCacheNow[i] >= B: # continue tc  in cand: for cc,cy,cx in cand: if cc > B: # print(\"a\",end=\"\") tc = float(\"inf\") break else: tc  min(dpCacheNxt[i],tc) cand = tmp if cand[0][0] < B: B = cand[0][0] Bi = mon1 if(Bi == -1): print(\"NA\") else: print(\"%d %d\"%(Bi+1,B)) # for mon1 in range(5): # mon2 = (mon1+1)%5 # dp = [[10**10]*1000 for _ in range(5)] # for i,yx in enumerate(ps[mon2]): #  = mon2 # for mon3 in range(mon2,mon2+3): # mon3 = mon3%5 # mon4 = (mon3+1)%5 # for [i,yx],[j,nyx] in product(enumerate(ps[mon3]),enumerate(ps[mon4])): #   #  ans,ansi = d,mon1 # print(ansi+1,ans) if __name__ == \"__main__\": # prf = LineProfiler() # prf.add_function(main) # prf.runcall(main) # prf.print_stats() main()"], "original_ll": -1.0055713653564453, "sampled_ll": -0.8013255000114441, "all_perturbed_sampled_ll": [-2.027935743331909], "all_perturbed_original_ll": [-1.8601648807525635], "perturbed_sampled_ll": -2.027935743331909, "perturbed_original_ll": -1.8601648807525635, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\t\tint n,t,i,k,j,g,s,r,a,w,z,o;\n\twhile(1)\t{\n\t\tscanf(\"%d\",&t);\n\t\tif(t==-1)\tbreak;\n\t\tif(10>=t){\n\t\t\tprintf(\"3130\\n\");\n\t\t\t}\n\t\tif(t>10&&t<20){\n\t\t\tn=t-10;\n\t\t\ti=4280-(n*125+1150);\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\t}\n\t\tif(t>20&&t<30){\n\t\t\tk=t-20;\n\t\t\tj=4280-((k*140)+2400);\n\t\t\tprintf(\"%d\\n\",j);\n\t\t}\n\t\tif(t>30){\n\t\t\ts=t-30;\n\t\t\tg=4280-((s*160)+3800);\n\t\t\tprintf(\"%d\\n\",g);\n\t\t}\t\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint calculate_bill(int w) {\n    int bill = 1150; // base charge\n    \n    if (w <= 10) {\n        return bill;\n    }\n    \n    if (w <= 20) {\n        bill += (w - 10) * 125;\n        return bill;\n    }\n    \n    bill += 10 * 125;\n    \n    if (w <= 30) {\n        bill += (w - 20) * 140;\n        return bill;\n    }\n    \n    bill += 10 * 140;\n    bill += (w - 30) * 160;\n    \n    return bill;\n}\n\nint main() {\n    int w;\n    int last_month = 4280;\n    \n    while (1) {\n        scanf(\"%d\", &w);\n        if (w == -1) break;\n        \n        int current_bill = calculate_bill(w);\n        int savings = last_month - current_bill;\n        \n        printf(\"%d\\n\", savings);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  bill = 1150; // base  { return bill; } if (w <= 20) { bill += (w - 10) * 125; return bill; } bill += 10 * 125; if  +=  return bill; } bill += 10 * 140; bill += (w - 30) * 160; return bill; } int main() { int  while (1) { scanf(\"%d\", &w); if (w == -1) break; int current_bill = calculate_bill(w); int savings = last_month -  0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int n,t,i,k,j,g,s,r,a,w,z,o; while(1) { scanf(\"%d\",&t); if(t==-1) break; if(10>=t){ printf(\"3130\\n\"); } if(t>10&&t<20){ n=t-10; i=4280-(n*125+1150); printf(\"%d\\n\",i); } if(t>20&&t<30){  s=t-30; g=4280-((s*160)+3800); printf(\"%d\\n\",g); } } return 0; }"], "original_ll": -1.2633799314498901, "sampled_ll": -0.774692177772522, "all_perturbed_sampled_ll": [-2.110976219177246], "all_perturbed_original_ll": [-1.718326449394226], "perturbed_sampled_ll": -2.110976219177246, "perturbed_original_ll": -1.718326449394226, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\twhile(kbd.hasNext()) {\n\t    int w = kbd.nextInt();\n\t    if(w!=-1){\n\t\tSystem.out.println(4280-solve(w));\n\t    }\n\t}\n    }\n\n    static int solve(int w) {\n\tint r = 0;\n\tint bill = 0;\n\twhile(w>=0){\n\t    bill += cost(w, r);\n\t    w -= 10;\n\t    r ++;\n\t    //System.out.println(\"p\");\n\t}\n\treturn bill;\n    }\n\n    static int cost(int w, int r){\n\tif(r==0){ return 1150; }\n\telse if(r==1){ \n\t    if(w>=10) return 125*10;\n\t    else return 125*w;\n\t}\n\telse if(r==2){\n\t    if(w>=10) return 140*10;\n\t    else return 140*w;\n\t}\n\telse if(r>2){\n\t    if(w>=10) return 160*10;\n\t    else return 160*w;\n\t}\n\telse return 0;\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int w = sc.nextInt();\n            if (w == -1) break;\n            \n            int currentBill = calculateBill(w);\n            int difference = 4280 - currentBill;\n            System.out.println(difference);\n        }\n        \n        sc.close();\n    }\n    \n    static int calculateBill(int w) {\n        int bill = 1150; // Base charge\n        \n        if (w <= 10) {\n            return bill;\n        }\n        \n        // Second tier: 10 < w <= 20\n        if (w <= 20) {\n            bill += (w - 10) * 125;\n            return bill;\n        }\n        \n        bill += 10 * 125; // Full second tier\n        \n        // Third tier: 20 < w <= 30\n        if (w <= 30) {\n            bill += (w - 20) * 140;\n            return bill;\n        }\n        \n        bill += 10 * 140; // Full third tier\n        \n        // Fourth tier: w > 30\n        bill += (w - 30) * 160;\n        \n        return bill;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) {  while (true) { int w  -1) break; int currentBill = calculateBill(w); int difference = 4280  } static int calculateBill(int w) { int bill  if (w <= 10) { return bill; } // Second tier: 10 < w <= 20 if (w   return bill; } bill += 10 * 125; // Full second tier // Third tier: 20 < w <= 30 if (w <= 30) { bill += (w - 20) * 140; return bill; } bill  Full third tier // Fourth tier: w > 30  * 160; return bill; } }"], "perturbed_original": ["import java.util.*; public class Main { static Scanner kbd = new Scanner(System.in); public static void main(String[] args){ while(kbd.hasNext()) { int w = kbd.nextInt(); if(w!=-1){ System.out.println(4280-solve(w)); }   0; while(w>=0){ bill += cost(w, r); w -= 10; r ++; //System.out.println(\"p\"); } return bill; } static int cost(int w, int r){  if(r==1){ if(w>=10) return 125*10; else return 125*w; } else if(r==2){ if(w>=10) return 140*10;  if(r>2){ if(w>=10) return 160*10; else return 160*w; } else return 0; } }"], "original_ll": -1.0164531469345093, "sampled_ll": -0.663398802280426, "all_perturbed_sampled_ll": [-1.865119457244873], "all_perturbed_original_ll": [-1.6020947694778442], "perturbed_sampled_ll": -1.865119457244873, "perturbed_original_ll": -1.6020947694778442, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def fee(w):\n    if w>30:\n        return (w-30)*160+10*140+10*125+1150\n    if w>20:\n        return (w-20)*140+10*125+1150\n    if w>10:\n        return (w-10)*125+1150\n    return 1150\n\nprev_m=4280\nwhile True:\n    W=int(input())\n    if W==-1:\n        break\n    print(prev_m-fee(W))\n    # prev_m=fee(W)\n\n", "sampled": "def calculate_water_bill(w):\n    if w <= 10:\n        return 1150\n    elif w <= 20:\n        return 1150 + (w - 10) * 125\n    elif w <= 30:\n        return 1150 + 10 * 125 + (w - 20) * 140\n    else:\n        return 1150 + 10 * 125 + 10 * 140 + (w - 30) * 160\n\nlast_month_bill = 4280\n\nwhile True:\n    w = int(input())\n    if w == -1:\n        break\n    \n    current_bill = calculate_water_bill(w)\n    savings = last_month_bill - current_bill\n    print(savings)\n", "perturbed_sampled": ["def calculate_water_bill(w): if w <= 10: return 1150 elif w <= 20: return  * 125 elif w <= 30: return 1150 + 10 * 125 + (w - 20) * 140 else: return  + 10 * 140 + (w - 30) * 160  w = int(input()) if w == -1: break current_bill =  current_bill print(savings)"], "perturbed_original": ["def  if w>20: return (w-20)*140+10*125+1150 if w>10: return (w-10)*125+1150 return 1150 prev_m=4280 while True: W=int(input()) if W==-1: break print(prev_m-fee(W)) # prev_m=fee(W)"], "original_ll": -1.1446994543075562, "sampled_ll": -0.802867591381073, "all_perturbed_sampled_ll": [-1.8817212581634521], "all_perturbed_original_ll": [-2.231616497039795], "perturbed_sampled_ll": -1.8817212581634521, "perturbed_original_ll": -2.231616497039795, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main()\n{\n\tint i,a,b,c,d,max=0,s=0;\n\tscanf(\"%d\",&a);\n\twhile(a!=0){\n\t\ts=0;\nmax=0;\n\tfor(i=0;i<a;i++){\n\t\tscanf(\"%d %d %d\",&b,&c,&d);\n\t\tc=c+d;\n\t\tif(max<c){\n\t\t\tmax=c;\n\t\t\ts=b;\n\t\t}\n\t}\n\t\n\tprintf(\"%d %d\\n\",s,max);\n\tscanf(\"%d\",&a);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int max_id = 0;\n        int max_distance = -1;\n        \n        for(int i = 0; i < n; i++) {\n            int p, d1, d2;\n            scanf(\"%d %d %d\", &p, &d1, &d2);\n            int total = d1 + d2;\n            \n            if(total > max_distance) {\n                max_distance = total;\n                max_id = p;\n            }\n        }\n        \n        printf(\"%d %d\\n\", max_id, max_distance);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) <extra_id_6>(D(2));else<extra_id_7>P(M(3)<extra_id_8>1, &d1, &d2); if(P(10),<extra_id_9>{ printf(\"%d %d\\n\",<extra_id_10>;<extra_id_11>; n<extra_id_12>; p = n;<extra_id_13>+= A2;<extra_id_14>a2);<extra_id_15>=<extra_id_16>* 10; if( 0) break; int  = -1; for(int i = 0; i < n; i++) { int p, d1,  &d1, &d2); int total = d1 + d2; if(total > max_distance)  = p; } } printf(\"%d %d\\n\", max_id, max_distance); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main() { int i,a,b,c,d,max=0,s=0; scanf(\"%d\",&a); while(a!=0){ s=0; max=0; for(i=0;i<a;i++){ scanf(\"%d %d %d\",&b,&c,&d); c=c+d; if(max<c){ max=c; s=b;  } return 0; }"], "original_ll": -1.1264793872833252, "sampled_ll": -0.5757142305374146, "all_perturbed_sampled_ll": [-2.3577661514282227], "all_perturbed_original_ll": [-1.647499442100525], "perturbed_sampled_ll": -2.3577661514282227, "perturbed_original_ll": -1.647499442100525, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\n\n\npublic class Main {\n\n\tprivate BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1);\n\n\tprivate String inputData = null;\n\n\tpublic String[] data = null;\n\n\tpublic int num = 0;\n\n\tpublic int count = 0;\n\n\tpublic HashMap<Integer, Integer> humanData = new HashMap<Integer, Integer>();\n\n\tpublic ArrayList<Integer> topId = new ArrayList<Integer>();\n\n\tpublic ArrayList<Integer> topLength = new ArrayList<Integer>();\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().start();\n\t\tSystem.exit(0);\n\t}\n\n\tpublic void start() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\tif (this.data.length == 1) {\n\t\t\t\tif (this.data[0].equals(\"0\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.num = Integer.parseInt(this.data[0]);\n\t\t\t}\n\n\t\t\tthis.humanData.clear();\n\n\t\t\tfor (int i = 0; i < this.num; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\t\tthis.humanData.put(Integer.parseInt(data[0]),\n\t\t\t\t\t\tInteger.parseInt(data[1]) + Integer.parseInt(data[2]));\n\n\t\t\t}\n\n\t\t\tIterator<Integer> itId = this.humanData.keySet().iterator();\n\t\t\tint numCount = 0;\n\t\t\twhile (itId.hasNext()) {\n\t\t\t\tint id = itId.next();\n\t\t\t\tif (numCount == 0) {\n\t\t\t\t\tthis.topId.add(id);\n\t\t\t\t\tthis.topLength.add(this.humanData.get(id));\n\t\t\t\t} else {\n\t\t\t\t\tif (this.topLength.get(count) <= this.humanData.get(id)) {\n\t\t\t\t\t\tthis.topId.set(this.count, id);\n\t\t\t\t\t\tthis.topLength.set(this.count, this.humanData.get(id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnumCount++;\n\t\t\t}\n\n\t\t\tthis.count++;\n\n\t\t}\n\n\t\tfor (int i = 0; i < this.topId.size(); i++) {\n\t\t\tSystem.out.println(this.topId.get(i) + \" \" + this.topLength.get(i));\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int maxPatient = 0;\n            int maxDistance = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int p = sc.nextInt();\n                int d1 = sc.nextInt();\n                int d2 = sc.nextInt();\n                int total = d1 + d2;\n                \n                if (total > maxDistance) {\n                    maxDistance = total;\n                    maxPatient = p;\n                }\n            }\n            \n            System.out.println(maxPatient + \" \" + maxDistance);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while  sc.nextInt(); if  maxPatient  0; for (int i = 0; i < n; i++) { int p = sc.nextInt(); int d1 = sc.nextInt(); int d2 = sc.nextInt(); int total = d1 + d2; if (total > maxDistance)  = p; }  + maxDistance); } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException;  java.util.HashMap; import java.util.Iterator; public class Main { private BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1); private  String[] data = null; public int num = 0; public int count = 0; public HashMap<Integer, Integer> humanData = new HashMap<Integer, Integer>(); public ArrayList<Integer> topId = new ArrayList<Integer>();  ArrayList<Integer>(); public static void main(String[] args) { new Main().start();  { while (true) { try { this.inputData  e) { e.printStackTrace(); } this.data = this.inputData.split(\" \"); if (this.data.length == 1) { if (this.data[0].equals(\"0\")) { break; } this.num = Integer.parseInt(this.data[0]); } this.humanData.clear(); for (int i =  { try { this.inputData = reader.readLine(); } catch (IOException e) { e.printStackTrace();  } Iterator<Integer>  = 0;  = itId.next(); if (numCount == 0) { this.topId.add(id); this.topLength.add(this.humanData.get(id)); } else { if (this.topLength.get(count) <= this.humanData.get(id)) { this.topId.set(this.count, id); this.topLength.set(this.count, this.humanData.get(id)); } } numCount++; } this.count++; } for (int i = 0;  System.out.println(this.topId.get(i) + \"  }"], "original_ll": -0.5777104496955872, "sampled_ll": -0.5270640254020691, "all_perturbed_sampled_ll": [-1.8827316761016846], "all_perturbed_original_ll": [-1.5352598428726196], "perturbed_sampled_ll": -1.8827316761016846, "perturbed_original_ll": -1.5352598428726196, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(input())\n    if n == 0:\n        break\n\n    patients = []\n    for _ in range(n):\n        p, d1, d2 = map(int, input().split())\n        patients.append((p, d1+d2))\n    print(*max(patients, key=lambda x: x[1]))", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    max_distance = -1\n    max_patient = -1\n    \n    for _ in range(n):\n        data = list(map(int, input().split()))\n        patient_id = data[0]\n        d1 = data[1]\n        d2 = data[2]\n        total_distance = d1 + d2\n        \n        if total_distance > max_distance:\n            max_distance = total_distance\n            max_patient = patient_id\n    \n    print(max_patient, max_distance)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break max_distance = -1 max_patient = -1 for _ in range(n): data   = data[2] total_distance  total_distance > max_distance: max_distance = total_distance max_patient = patient_id print(max_patient, max_distance)"], "perturbed_original": ["while True: n = int(input()) if n  [] for _ in range(n): p, d1, d2 = map(int, input().split()) patients.append((p, d1+d2)) print(*max(patients, key=lambda x: x[1]))"], "original_ll": -1.0328561067581177, "sampled_ll": -0.7540817260742188, "all_perturbed_sampled_ll": [-2.293928623199463], "all_perturbed_original_ll": [-1.9891592264175415], "perturbed_sampled_ll": -2.293928623199463, "perturbed_original_ll": -1.9891592264175415, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "m,e,j,s;main(n){for(;scanf(\"%d\",&n)*n;)for(;n--;puts(m>99|e>99|j>99|m+e>179|s>239?\"A\":s>209||s>149&&m>79|e>79?\"B\":\"C\"))scanf(\"%d%d%d\",&m,&e,&j),s=m+e+j;}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        for(int i = 0; i < n; i++) {\n            int pm, pe, pj;\n            scanf(\"%d %d %d\", &pm, &pe, &pj);\n            \n            char cls = 'C';\n            \n            // Check conditions for A class\n            if(pm == 100 || pe == 100 || pj == 100) {\n                cls = 'A';\n            }\n            else if((pm + pe) / 2.0 >= 90) {\n                cls = 'A';\n            }\n            else if((pm + pe + pj) / 3.0 >= 80) {\n                cls = 'A';\n            }\n            // Check conditions for B class\n            else if((pm + pe + pj) / 3.0 >= 70) {\n                cls = 'B';\n            }\n            else if((pm + pe + pj) / 3.0 >= 50 && (pm >= 80 || pe >= 80)) {\n                cls = 'B';\n            }\n            \n            printf(\"%c\\n\", cls);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) { scanf(\"%d\", &n); if(n == 0) break; for(int i = 0; i < n; i++) { int pm, pe, pj; scanf(\"%d %d %d\", &pm, &pe, &pj); char  conditions for A class if(pm == 100 || pe == 100 || pj == 100) { cls =  pe) / 2.0 >= 90) { cls =  cls = 'A'; } // Check conditions for B class else if((pm + pe + pj) / 3.0 >= 70) { cls  +  >= 80 || pe >= 80)) { cls = 'B'; } printf(\"%c\\n\", cls); } } return 0; }"], "perturbed_original": ["m,e,j,s;main(n){for(;scanf(\"%d\",&n)*n;)for(;n--;puts(m>99|e>99|j>99|m+e>179|s>239?\"A\":s>209||s>149&&m>79|e>79?\"B\":\"C\"))scanf(\"%d%d%d\",&m,&e,&j),s=m+e+j;}"], "original_ll": -2.1598589420318604, "sampled_ll": -0.6371092200279236, "all_perturbed_sampled_ll": [-1.7271947860717773], "all_perturbed_original_ll": [-2.1598589420318604], "perturbed_sampled_ll": -1.7271947860717773, "perturbed_original_ll": -2.1598589420318604, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tchar c[]=new char[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint pm=sc.nextInt();\n\t\t\t\tint pe=sc.nextInt();\n\t\t\t\tint pj=sc.nextInt();\n\t\t\t\tif(pm==100||pe==100||pj==100)c[i]='A';\n\t\t\t\telse if((pm+pe)/2>=90)c[i]='A';\n\t\t\t\telse if((pm+pe+pj)/3>=80)c[i]='A';\n\t\t\t\telse if((pm+pe+pj)/3>=70)c[i]='B';\n\t\t\t\telse if((pm+pe+pj)/3>=50&&(pm>=80||pe>=80))c[i]='B';\n\t\t\t\telse c[i]='C';\n\t\t\t\tSystem.out.println(c[i]);\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            for (int i = 0; i < n; i++) {\n                int pm = sc.nextInt();\n                int pe = sc.nextInt();\n                int pj = sc.nextInt();\n                \n                String cls = getClass(pm, pe, pj);\n                System.out.println(cls);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static String getClass(int pm, int pe, int pj) {\n        // Check for class A conditions\n        if (pm == 100 || pe == 100 || pj == 100) {\n            return \"A\";\n        }\n        \n        double mathEngAvg = (pm + pe) / 2.0;\n        if (mathEngAvg >= 90) {\n            return \"A\";\n        }\n        \n        double threeAvg = (pm + pe + pj) / 3.0;\n        if (threeAvg >= 80) {\n            return \"A\";\n        }\n        \n        // Check for class B conditions\n        if (threeAvg >= 70) {\n            return \"B\";\n        }\n        \n        if (threeAvg >= 50 && (pm >= 80 || pe >= 80)) {\n            return \"B\";\n        }\n        \n        // Otherwise class C\n        return \"C\";\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; for (int i = 0; i < n; i++) { int pm = sc.nextInt(); int pe = sc.nextInt(); int pj = sc.nextInt();   if (pm == 100 || pe == 100 || pj == 100) { return \"A\"; } double mathEngAvg =  if (mathEngAvg >= 90) {  = (pm + pe + pj) / 3.0; if (threeAvg >= 80) { return \"A\"; } // Check for class B conditions  return \"B\"; } if (threeAvg >= 50 && (pm >= 80 || pe >= 80)) { return \"B\"; } // Otherwise class C return \"C\"; } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc=new Scanner(System.in); while(true){ int n=sc.nextInt(); if(n==0)break; char c[]=new char[n]; for(int i=0;i<n;i++){ int  if(pm==100||pe==100||pj==100)c[i]='A'; else  else if((pm+pe+pj)/3>=50&&(pm>=80||pe>=80))c[i]='B'; else c[i]='C'; System.out.println(c[i]); } } } }"], "original_ll": -0.7470335364341736, "sampled_ll": -0.6726406216621399, "all_perturbed_sampled_ll": [-1.4069690704345703], "all_perturbed_original_ll": [-1.4601703882217407], "perturbed_sampled_ll": -1.4069690704345703, "perturbed_original_ll": -1.4601703882217407, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n = int(input())\n    if n == 0: break\n    i = 0\n    while True:\n        if i == n: break\n        m, e, j = map(int, input().split())\n        sum = m + e + j\n        if m==100 or e==100 or j==100:\n            print(\"A\")\n        elif (m+e)/2 >= 90:\n            print(\"A\")\n        elif sum/3 >= 80:\n            print(\"A\")\n        elif sum/3 >= 70:\n            print(\"B\")\n        elif sum/3 >= 50 and m >= 80 or e >= 80:\n            print(\"B\")\n        else:\n            print(\"C\")\n        i += 1\n    \n", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    for _ in range(n):\n        pm, pe, pj = map(int, input().split())\n        \n        # Check conditions for class A\n        if pm == 100 or pe == 100 or pj == 100:\n            print(\"A\")\n            continue\n        \n        if (pm + pe) / 2 >= 90:\n            print(\"A\")\n            continue\n        \n        if (pm + pe + pj) / 3 >= 80:\n            print(\"A\")\n            continue\n        \n        # Check conditions for class B\n        if (pm + pe + pj) / 3 >= 70:\n            print(\"B\")\n            continue\n        \n        if (pm + pe + pj) / 3 >= 50 and (pm >= 80 or pe >= 80):\n            print(\"B\")\n            continue\n        \n        # Otherwise class C\n        print(\"C\")\n", "perturbed_sampled": ["while True: n = int(input()) if  _ in range(n): pm, pe, pj = map(int, input().split()) # Check conditions for class A if  ==  print(\"A\") continue if (pm + pe) / 2 >= 90: print(\"A\") continue  pj) / 3 >= 80: print(\"A\") continue # Check conditions for  pe + pj) / 3 >= 70: print(\"B\") continue if (pm + pe + pj) / 3 >= 50 and (pm >= 80 or pe >=  class C print(\"C\")"], "perturbed_original": ["while 1: n = int(input()) if n == 0: break i = 0 while True: if i == n: break m,  sum  j if m==100 or e==100 or j==100: print(\"A\") elif (m+e)/2  >= 80: print(\"A\") elif sum/3 >= 70: print(\"B\") elif sum/3 >= 50 and m >= 80 or e >= 80:  1"], "original_ll": -0.8289682269096375, "sampled_ll": -0.7510015964508057, "all_perturbed_sampled_ll": [-2.169252395629883], "all_perturbed_original_ll": [-1.7714425325393677], "perturbed_sampled_ll": -2.169252395629883, "perturbed_original_ll": -1.7714425325393677, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main()\n{\n    int n;\n    int c;\n\n    while (scanf(\"%d\", &n), n != 0) {\n        int cnt[10] = {};\n\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &c);\n\n            cnt[c]++;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            if (cnt[i] == 0) {\n                putchar('-');\n            }\n            else {\n                for (int j = 0; j < cnt[i]; j++) {\n                    putchar('*');\n                }\n            }\n\n            putchar('\\n');\n        }\n    }\n\n    return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int count[10] = {0};\n        \n        for(int i = 0; i < n; i++) {\n            int c;\n            scanf(\"%d\", &c);\n            count[c]++;\n        }\n        \n        for(int i = 0; i < 10; i++) {\n            if(count[i] == 0) {\n                printf(\"-\\n\");\n            } else {\n                for(int j = 0; j < count[i]; j++) {\n                    printf(\"*\");\n                }\n                printf(\"\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(scanf(\"%d\", &n) == 1 && n != 0) { int count[10] = {0}; for(int i = 0; i < n; i++) { <extra_id_3>{<extra_id_4>><extra_id_5>sprintf(\"%v\\t\", *n); return -1; }<extra_id_6>(i<extra_id_7>{ printf(\"%d\\n\"); }<extra_id_8>] {<extra_id_9>n ); for<extra_id_10>i=0; i<n; i++) {<extra_id_11>%D<extra_id_12>d<extra_id_13>\"A<extra_id_14>1); } for(var n=1; t<extra_id_15><= 10; t } for(int  10; i++) { if(count[i] == 0)  for(int  count[i]; j++) { printf(\"*\"); } printf(\"\\n\"); } } } return 0; }"], "perturbed_original": ["#include <stdio.h> int main() { int n; int c; while (scanf(\"%d\", &n), n != 0) { int cnt[10] = {}; for (int i = 0; i < n; i++) {  (int  (cnt[i] == 0) { putchar('-'); } else { for (int  cnt[i]; j++) { putchar('*'); } } putchar('\\n'); } } return 0; }"], "original_ll": -0.6378297805786133, "sampled_ll": -0.46559852361679077, "all_perturbed_sampled_ll": [-2.2446234226226807], "all_perturbed_original_ll": [-1.753956913948059], "perturbed_sampled_ll": -2.2446234226226807, "perturbed_original_ll": -1.753956913948059, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] num = new int[10];\n\t\t\twhile(n-->0){\n\t\t\t\tnum[scanner.nextInt()]++;\n\t\t\t}\n\t\t\tfor(int a:num){\n\t\t\t\tif(a==0)\n\t\t\t\t\tSystem.out.println('-');\n\t\t\t\telse{\n\t\t\t\t\tchar[] c = new char[a];\n\t\t\t\t\tArrays.fill(c, '*');\n\t\t\t\t\tSystem.out.println(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] count = new int[10];\n            \n            for (int i = 0; i < n; i++) {\n                int c = sc.nextInt();\n                count[c]++;\n            }\n            \n            for (int i = 0; i < 10; i++) {\n                if (count[i] == 0) {\n                    System.out.println(\"-\");\n                } else {\n                    for (int j = 0; j < count[i]; j++) {\n                        System.out.print(\"*\");\n                    }\n                    System.out.println();\n                }\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void  (true) { int n =  break; int[] count = new int[10]; for (int i = 0; i <  = sc.nextInt(); count[c]++; } for (int i = 0; i < 10; i++) { if (count[i] == 0) { System.out.println(\"-\"); } else { for (int j = 0; j < count[i]; j++) { System.out.print(\"*\"); }  } }"], "perturbed_original": ["import java.io.IOException; import java.util.Arrays; import java.util.Scanner; public class Main  args)  } private void run() throws IOException { Scanner scanner = new Scanner(System.in);  = scanner.nextInt(); if (n == 0) break; int[] num = new int[10]; while(n-->0){ num[scanner.nextInt()]++; } for(int a:num){ if(a==0) System.out.println('-'); else{ char[] c = new char[a]; Arrays.fill(c,  } }"], "original_ll": -0.7898843884468079, "sampled_ll": -0.423195481300354, "all_perturbed_sampled_ll": [-1.429482340812683], "all_perturbed_original_ll": [-1.896106243133545], "perturbed_sampled_ll": -1.429482340812683, "perturbed_original_ll": -1.896106243133545, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    q={}\n    a=input()\n    if a==0:break\n    for i in range(10): q[i]=0\n    for i in range(a): q[input()]+=1\n    for i in range(10):  print \"*\"*q[i] if q[i] != 0 else \"-\"", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = [0] * 10\n    for _ in range(n):\n        c = int(input())\n        count[c] += 1\n    \n    for i in range(10):\n        if count[i] == 0:\n            print('-')\n        else:\n            print('*' * count[i])\n", "perturbed_sampled": [" if n  [0] * 10 for _ in range(n): c = int(input()) count[c] += 1 for i in range(10): if count[i] == 0: print('-') else: print('*' * count[i])"], "perturbed_original": ["while True: q={} a=input() if a==0:break  for i in range(a): q[input()]+=1 for i in range(10): print \"*\"*q[i] if q[i] != 0 else \"-\""], "original_ll": -1.6992006301879883, "sampled_ll": -0.7539748549461365, "all_perturbed_sampled_ll": [-1.6584538221359253], "all_perturbed_original_ll": [-2.5384726524353027], "perturbed_sampled_ll": -1.6584538221359253, "perturbed_original_ll": -2.5384726524353027, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  double n;\n  char a[12];\n  int m,i;\n  while(1){\n    scanf(\"%lf\",&n);\n    if(n<0)break;\n    n*=16;\n    m=n;\n    if(m-n){\n      printf(\"NA\\n\");\n      continue;\n    }\n    for(i=12;i;i--){\n      a[i-1]=m%2+'0';\n      m/=2;\n    }\n    if(m){\n      printf(\"NA\\n\");\n      continue;\n    }\n    for(i=0;i<12;i++){\n      if(i==8)printf(\".\");\n      printf(\"%c\",a[i]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\nint main() {\n    double n;\n    \n    while (scanf(\"%lf\", &n) == 1) {\n        if (n < 0) break;\n        \n        // Extract integer and fractional parts\n        int int_part = (int)n;\n        double frac_part = n - int_part;\n        \n        // Check if integer part fits in 8 bits\n        if (int_part > 255) {\n            printf(\"NA\\n\");\n            continue;\n        }\n        \n        // Convert integer part to binary (8 bits)\n        char int_binary[9];\n        for (int i = 7; i >= 0; i--) {\n            int_binary[i] = (int_part % 2) + '0';\n            int_part /= 2;\n        }\n        int_binary[8] = '\\0';\n        \n        // Convert fractional part to binary (4 bits)\n        char frac_binary[5];\n        int valid = 1;\n        double temp_frac = frac_part;\n        \n        for (int i = 0; i < 4; i++) {\n            temp_frac *= 2;\n            if (temp_frac >= 1) {\n                frac_binary[i] = '1';\n                temp_frac -= 1;\n            } else {\n                frac_binary[i] = '0';\n            }\n        }\n        frac_binary[4] = '\\0';\n        \n        // Check if there's remaining fractional part\n        temp_frac *= 2;\n        if (temp_frac > 0.0001) {  // Allow small floating point error\n            valid = 0;\n        }\n        \n        // Alternative check: reconstruct the number and compare\n        double reconstructed = 0;\n        int int_val = 0;\n        for (int i = 0; i < 8; i++) {\n            int_val = int_val * 2 + (int_binary[i] - '0');\n        }\n        reconstructed = int_val;\n        \n        double frac_val = 0;\n        for (int i = 0; i < 4; i++) {\n            frac_val = frac_val + (frac_binary[i] - '0') * pow(0.5, i + 1);\n        }\n        reconstructed += frac_val;\n        \n        if (fabs(reconstructed - n) > 0.0001) {\n            valid = 0;\n        }\n        \n        if (valid) {\n            printf(\"%s.%s\\n\", int_binary, frac_binary);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  int main() { double n; while  if (n < 0) break; // Extract integer and fractional parts int int_part = (int)n; double frac_part = n - int_part; // Check if integer part fits in 8 bits if (int_part  } // Convert integer part to binary (8 bits) char int_binary[9]; for (int i = 7; i >= 0; i--) { int_binary[i] = (int_part % 2) + '0'; int_part /= 2; } int_binary[8] = '\\0'; // Convert fractional part to binary (4 bits) char frac_binary[5]; int valid = 1; double  i =  { frac_binary[i] = '1'; temp_frac -= 1;  '0'; } } frac_binary[4] = '\\0'; // Check if there's remaining fractional part temp_frac *= 2; if  Allow small floating point error valid = 0; } // Alternative check: reconstruct the number and compare double reconstructed = 0; int int_val = 0; for (int i = 0; i < 8; i++) {  } reconstructed = int_val; double  i = 0; i  = frac_val + (frac_binary[i] - '0') * pow(0.5, i + 1); } reconstructed += frac_val; if (fabs(reconstructed -  = 0;  int_binary, frac_binary); } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ double n; char a[12]; int m,i; while(1){ scanf(\"%lf\",&n); if(n<0)break; n*=16;  if(m){ printf(\"NA\\n\"); continue; } for(i=0;i<12;i++){ if(i==8)printf(\".\"); printf(\"%c\",a[i]); } printf(\"\\n\"); } return 0; }"], "original_ll": -1.075714111328125, "sampled_ll": -0.5452044010162354, "all_perturbed_sampled_ll": [-1.7073214054107666], "all_perturbed_original_ll": [-1.831387996673584], "perturbed_sampled_ll": -1.7073214054107666, "perturbed_original_ll": -1.831387996673584, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/**\n * Problem E: Binary Digit A Doctor Loved\n */\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tif (line.charAt(0) == '-') {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint ni;\n\t\t\tdouble nd;\n\t\t\tni = Integer.parseInt(line.substring(0, line.indexOf('.')));\n\t\t\tif (line.indexOf('.') != -1) {\n\t\t\t\tnd = Double.parseDouble(\"0\"\n\t\t\t\t\t\t+ (line.substring(line.indexOf('.')))) * 16;\n\t\t\t} else {\n\t\t\t\tnd = 0.0;\n\t\t\t}\n\t\t\tif (ni > 255 || nd % 1.0 > 0.0) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else {\n\t\t\t\tchar[] si, sd;\n\t\t\t\tsi = new char[8];\n\t\t\t\tsd = new char[4];\n\n\t\t\t\tfor (int i = 7; i >= 0; i--) {\n\t\t\t\t\tif ((ni & (int) (Math.pow(2, i))) != 0) {\n\t\t\t\t\t\tsi[7 - i] = '1';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsi[7 - i] = '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 3; i >= 0; i--) {\n\t\t\t\t\tif (((int) nd & (int) (Math.pow(2, i))) != 0) {\n\t\t\t\t\t\tsd[3 - i] = '1';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsd[3 - i] = '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(new String(si) + \".\" + new String(sd));\n\t\t\t}\n\t\t}\n\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double n = sc.nextDouble();\n            if (n < 0) break;\n            \n            // Split into integer and fractional parts\n            int intPart = (int) n;\n            double fracPart = n - intPart;\n            \n            // Check if integer part fits in 8 bits\n            if (intPart > 255) {\n                System.out.println(\"NA\");\n                continue;\n            }\n            \n            // Convert integer part to binary (8 digits)\n            String intBinary = String.format(\"%8s\", Integer.toBinaryString(intPart)).replace(' ', '0');\n            \n            // Convert fractional part to binary (4 digits)\n            StringBuilder fracBinary = new StringBuilder();\n            boolean valid = true;\n            double temp = fracPart;\n            \n            for (int i = 0; i < 4; i++) {\n                temp *= 2;\n                if (temp >= 1) {\n                    fracBinary.append('1');\n                    temp -= 1;\n                } else {\n                    fracBinary.append('0');\n                }\n            }\n            \n            // Check if there's remaining fractional part\n            if (temp > 1e-9) {\n                valid = false;\n            }\n            \n            if (valid) {\n                System.out.println(intBinary + \".\" + fracBinary.toString());\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while  sc.nextDouble(); if (n < 0) break; // Split into integer and fractional parts int  fracPart = n  8 bits if (intPart > 255) { System.out.println(\"NA\"); continue; } // Convert integer part  intBinary = String.format(\"%8s\", Integer.toBinaryString(intPart)).replace(' ', '0'); // Convert fractional part to  = new StringBuilder(); boolean valid = true;  (int i = 0; i < 4; i++) { temp *= 2;  fracBinary.append('1'); temp -= 1; } else { fracBinary.append('0'); } } // Check if there's remaining fractional part if (temp > 1e-9) { valid = false; } if (valid) { System.out.println(intBinary + \".\" + fracBinary.toString()); } else  } }"], "perturbed_original": ["/** * Problem E: Binary Digit A Doctor Loved */ import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public  void main(String[]  br.readLine()) !=  (line.charAt(0) == '-') { break; } int ni; double nd; ni = Integer.parseInt(line.substring(0, line.indexOf('.'))); if (line.indexOf('.') != -1) { nd = Double.parseDouble(\"0\" + (line.substring(line.indexOf('.')))) * 16; } else { nd = 0.0; } if (ni > 255 || nd % 1.0  else { char[] si, sd; si = new char[8]; sd = new char[4];  { if ((ni & (int) (Math.pow(2, i))) !=   si[7 - i] = '0'; } } for (int i = 3; i >= 0; i--) { if (((int) nd & (int) (Math.pow(2, i))) != 0) { sd[3 - i] = '1'; } else { sd[3 - i] = '0'; } } System.out.println(new String(si) + \".\" + new String(sd)); } } } }"], "original_ll": -0.7916605472564697, "sampled_ll": -0.5752732157707214, "all_perturbed_sampled_ll": [-1.6981316804885864], "all_perturbed_original_ll": [-1.6481600999832153], "perturbed_sampled_ll": -1.6981316804885864, "perturbed_original_ll": -1.6481600999832153, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# Aizu Problem 0220: Binary Digit A Doctor Loved\n\nimport sys, math, os, struct\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\n\nwhile True:\n    n = float(input())\n    if n < 0:\n        break\n    pre = int(n)\n    post = n - int(n)\n    res = bin(pre)[2:].zfill(8) + '.'\n    for k in range(4):\n        post *= 2\n        res += str(int(post))\n        post -= int(post)\n    if pre > 255 or post > 0:\n        print(\"NA\")\n    else:\n        print(res)\n    #m = int(n * 16)\n    #if n == m / 16. and m < 4096:\n    #    res = \"\"\n    #    for k in range(12):\n    #        res += str(m % 2)\n    #        m //= 2\n    #        if k == 7:\n    #            res += '.'\n    #    print(res)\n    #else:\n    #    print(\"NA\")", "sampled": "import sys\n\ndef decimal_to_binary(n):\n    if n < 0:\n        return None\n    \n    # Split into integer and fractional parts\n    integer_part = int(n)\n    fractional_part = n - integer_part\n    \n    # Check if integer part fits in 8 bits\n    if integer_part >= 256:  # 2^8\n        return \"NA\"\n    \n    # Convert integer part to binary\n    int_binary = bin(integer_part)[2:].zfill(8)\n    \n    # Convert fractional part to binary (up to 4 digits)\n    frac_binary = \"\"\n    for _ in range(4):\n        fractional_part *= 2\n        bit = int(fractional_part)\n        frac_binary += str(bit)\n        fractional_part -= bit\n    \n    # Check if there's remaining fractional part (can't be represented exactly)\n    if fractional_part > 1e-9:  # small epsilon for floating point errors\n        return \"NA\"\n    \n    return int_binary + \".\" + frac_binary\n\nfor line in sys.stdin:\n    n = float(line.strip())\n    if n < 0:\n        break\n    result = decimal_to_binary(n)\n    print(result)\n", "perturbed_sampled": ["import sys def decimal_to_binary(n): if n < 0: i += integer and fractional parts integer_part = int(n) fractional_part =  if integer part fits in  256: # 2^8 return \"NA\" # Convert integer part to  Convert fractional part to binary (up to 4 digits) frac_binary = \"\" for _ in  = int(fractional_part) frac_binary += str(bit) fractional_part -= bit # Check  (can't be represented exactly) if fractional_part > 1e-9: # small epsilon for floating point errors return \"NA\" return int_binary + \".\" + frac_binary for line in sys.stdin: n = float(line.strip())  result = decimal_to_binary(n) print(result)"], "perturbed_original": ["# Aizu Problem 0220: Binary Digit A Doctor Loved import sys, math, os, struct # read input: PYDEV = os.environ.get('PYDEV') if  while  n <  post = n - int(n) res = bin(pre)[2:].zfill(8) + '.' for k in range(4): post *= 2 res += str(int(post)) post -= int(post)   print(res) #m = int(n * 16) #if n == m / 16. and m < 4096: # res = \"\" # for  += str(m  2 # if k == 7: # res += '.' # print(res) #else: # print(\"NA\")"], "original_ll": -1.4388587474822998, "sampled_ll": -0.9024179577827454, "all_perturbed_sampled_ll": [-2.721592426300049], "all_perturbed_original_ll": [-3.062811851501465], "perturbed_sampled_ll": -2.721592426300049, "perturbed_original_ll": -3.062811851501465, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\nint main(){\n  int n,m,t;\n  int i,c;\n  char s[12];\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0)break;\n    scanf(\"\\n\");\n    t=1;\n    c=n;\n    int p[1001]={0};\n    p[n+1]=-1;\n    for(i=1;i<=m;i++){\n      if(t==c+1)t=1;\n      for(;p[t]==-1;t++);\n      if(t==c+1)t=1;\n      for(;p[t]==-1;t++);\n      fgets(s,10,stdin);\n      if(n!=1){\n\tif(i%3==0){\n\t  if(i%5==0){\n\t    if(strcmp(s,\"FizzBuzz\\n\\0\")!=0)p[t]=-1;\n\t  }\n\t  else{\n\t    if(strcmp(s,\"Fizz\\n\\0\")!=0)p[t]=-1;\n\t  }\n\t}\n\telse{\n\t  if(i%5==0){\n\t    if(strcmp(s,\"Buzz\\n\\0\")!=0)p[t]=-1;\n\t  }\n\t  else{\n\t    if(!(s[0]==i+'0'&&s[1]==10))p[t]=-1;\n\t  }\n\t}\n\tif(p[t]==-1)n--;\n      }\n      t++;\n    }\n    n=0;\n    for(i=1;i<=c;i++){\n      if(p[i]==0){\n\tif(n==1)printf(\" \");\n\tprintf(\"%d\",i);\n\tn=1;\n      }\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int m, n;\n    \n    while(1) {\n        scanf(\"%d %d\", &m, &n);\n        if(m == 0 && n == 0) break;\n        \n        int active[1001];\n        for(int i = 1; i <= m; i++) {\n            active[i] = 1;\n        }\n        \n        int current_player = 1;\n        int current_number = 1;\n        int remaining_players = m;\n        \n        for(int i = 0; i < n; i++) {\n            char statement[10];\n            scanf(\"%s\", statement);\n            \n            if(remaining_players == 1) {\n                continue;\n            }\n            \n            // Find next active player\n            while(active[current_player] == 0) {\n                current_player++;\n                if(current_player > m) current_player = 1;\n            }\n            \n            // Check if statement is correct\n            int correct = 0;\n            \n            if(current_number % 15 == 0) {\n                if(strcmp(statement, \"FizzBuzz\") == 0) correct = 1;\n            }\n            else if(current_number % 3 == 0) {\n                if(strcmp(statement, \"Fizz\") == 0) correct = 1;\n            }\n            else if(current_number % 5 == 0) {\n                if(strcmp(statement, \"Buzz\") == 0) correct = 1;\n            }\n            else {\n                int num;\n                if(sscanf(statement, \"%d\", &num) == 1 && num == current_number) {\n                    correct = 1;\n                }\n            }\n            \n            if(!correct) {\n                active[current_player] = 0;\n                remaining_players--;\n            }\n            \n            current_number++;\n            \n            // Move to next player\n            current_player++;\n            if(current_player > m) current_player = 1;\n        }\n        \n        int first = 1;\n        for(int i = 1; i <= m; i++) {\n            if(active[i]) {\n                if(!first) printf(\" \");\n                printf(\"%d\", i);\n                first = 0;\n            }\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int m, <extra_id_4>== i ? current_number +=<extra_id_5>, i :<extra_id_6>{ switch (<extra_id_7>case<extra_id_8>m ) :<extra_id_9>: if(n > 1 &&<extra_id_10>active [ i ] ==<extra_id_11>else<extra_id_12>} } if(p <<extra_id_13>++) { if(n<extra_id_14>,<extra_id_15>break ; } catch (<extra_id_16>int x<extra_id_17>( i - 1 ;<extra_id_18>if<extra_id_19>* n = 1001<extra_id_20>current_player &m, &n); if(m == 0 && n == 0) break; int active[1001]; for(int i = 1; i <= m; i++) { active[i] = 1; } int current_player = 1; int current_number = 1; int remaining_players = m; for(int i =  { char statement[10]; scanf(\"%s\", statement); if(remaining_players == 1) { continue;  player while(active[current_player] == 0)  current_player = 1; } // Check if statement is correct int correct = 0; if(current_number % 15 ==  } else if(current_number % 3 == 0) { if(strcmp(statement, \"Fizz\") == 0) correct = 1; } else if(current_number % 5 == 0) { if(strcmp(statement, \"Buzz\") == 0) correct = 1;  if(sscanf(statement, \"%d\", &num) == 1 && num == current_number) { correct = 1; } } if(!correct) { active[current_player]   current_player++; if(current_player > m)  first = 1; for(int i = 1;  if(active[i])  i); first = 0; } } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> int main(){ int n,m,t; int i,c; char s[12]; while(1){ scanf(\"%d %d\",&n,&m); if(n==0&&m==0)break; scanf(\"\\n\");  for(i=1;i<=m;i++){ if(t==c+1)t=1; for(;p[t]==-1;t++); if(t==c+1)t=1; for(;p[t]==-1;t++); fgets(s,10,stdin); if(n!=1){ if(i%3==0){ if(i%5==0){ if(strcmp(s,\"FizzBuzz\\n\\0\")!=0)p[t]=-1; } else{ if(strcmp(s,\"Fizz\\n\\0\")!=0)p[t]=-1; } } else{ if(i%5==0){ if(strcmp(s,\"Buzz\\n\\0\")!=0)p[t]=-1; } else{ if(!(s[0]==i+'0'&&s[1]==10))p[t]=-1;  if(n==1)printf(\" \"); printf(\"%d\",i); n=1; } } printf(\"\\n\"); } return 0; }"], "original_ll": -1.0291650295257568, "sampled_ll": -0.5509333610534668, "all_perturbed_sampled_ll": [-1.9330236911773682], "all_perturbed_original_ll": [-1.4457916021347046], "perturbed_sampled_ll": -1.9330236911773682, "perturbed_original_ll": -1.4457916021347046, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m,n;\n\t\tFizzBuzz fb;\n\t\tfor(;;) {\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(m==0 && n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfb = new FizzBuzz(m);\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tif(!fb.sayNextStatement(sc.next())) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfb.showPlayer();\n\t\t}\n\t}\n}\n\nclass FizzBuzz {\n\tprivate int current,currentPlayer;\n\tprivate int m;\n\tprivate int[] player;\n\t\n\tpublic FizzBuzz(int m) {\n\t\tcurrent = 0;\n\t\tcurrentPlayer = 0;\n\t\tthis.m = m;\n\t\tplayer = new int[m];\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tplayer[i] = i+1;\n\t\t}\n\t}\n\t\n\tpublic void showPlayer() {\n\t\tfor(int pl:player){\n\t\t\tif(pl != -1){\n\t\t\t\tSystem.out.println(pl);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic boolean sayNextStatement(String statement) {\n\t\ttry {\n\t\t\tint num = Integer.valueOf(statement);\n\t\t\tif(!checkFizzBuzz(num)) {\n\t\t\t\tplayer[currentPlayer] = -1;\n\t\t\t}\n\t\t} catch(NumberFormatException e) {\n\t\t\tif(!checkFizzBuzz(statement)) {\n\t\t\t\tplayer[currentPlayer] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!setCurrentPlayer()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate boolean setCurrentPlayer() {\n\t\tint prev = currentPlayer;\n\t\t\n\t\tif(currentPlayer+1 == m) {\n\t\t\tcurrentPlayer = 0;\n\t\t} else {\n\t\t\tcurrentPlayer ++;\n\t\t}\n\t\t\n\t\twhile(player[currentPlayer] == -1) {\n\t\t\tif(currentPlayer+1 == m) {\n\t\t\t\tcurrentPlayer = 0;\n\t\t\t} else {\n\t\t\t\tcurrentPlayer ++;\n\t\t\t}\n\t\t\t\n\t\t\tif(prev == currentPlayer) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate boolean checkFizzBuzz(int statement) {\n\t\tcurrent ++;\n\t\t\n\t\tif((current % 3 == 0) || (current % 5 == 0)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif(current == statement) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean checkFizzBuzz(String statement) {\n\t\tcurrent ++;\n\t\tif((current % 3 == 0) && (current % 5 == 0)) {\n\t\t\tif(statement.equals(\"FizzBuzz\")) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(current % 3 == 0) {\n\t\t\tif(statement.equals(\"Fizz\")) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(current % 5 == 0) {\n\t\t\tif(statement.equals(\"Buzz\")) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            \n            if (m == 0 && n == 0) break;\n            \n            boolean[] active = new boolean[m + 1];\n            for (int i = 1; i <= m; i++) {\n                active[i] = true;\n            }\n            \n            int currentNumber = 1;\n            int currentPlayer = 1;\n            int activePlayers = m;\n            \n            for (int i = 0; i < n; i++) {\n                String statement = sc.next();\n                \n                if (activePlayers == 1) {\n                    continue;\n                }\n                \n                while (!active[currentPlayer]) {\n                    currentPlayer++;\n                    if (currentPlayer > m) currentPlayer = 1;\n                }\n                \n                String correct = getCorrectStatement(currentNumber);\n                \n                if (!statement.equals(correct)) {\n                    active[currentPlayer] = false;\n                    activePlayers--;\n                } else {\n                    currentNumber++;\n                }\n                \n                if (activePlayers > 1) {\n                    currentPlayer++;\n                    if (currentPlayer > m) currentPlayer = 1;\n                }\n            }\n            \n            List<Integer> result = new ArrayList<>();\n            for (int i = 1; i <= m; i++) {\n                if (active[i]) {\n                    result.add(i);\n                }\n            }\n            \n            for (int i = 0; i < result.size(); i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(result.get(i));\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n    \n    static String getCorrectStatement(int num) {\n        if (num % 15 == 0) {\n            return \"FizzBuzz\";\n        } else if (num % 3 == 0) {\n            return \"Fizz\";\n        } else if (num % 5 == 0) {\n            return \"Buzz\";\n        } else {\n            return String.valueOf(num);\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) {  n = sc.nextInt(); if (m == 0 && n == 0)  boolean[m + 1]; for  <= m; i++) { active[i] = true; } int currentNumber = 1; int currentPlayer = 1; int activePlayers = m; for (int i = 0; i  statement = sc.next(); if (activePlayers == 1) { continue; } while (!active[currentPlayer]) { currentPlayer++; if (currentPlayer > m) currentPlayer = 1; } String correct = getCorrectStatement(currentNumber); if (!statement.equals(correct)) { active[currentPlayer]  { currentNumber++; } if (activePlayers > 1) { currentPlayer++; if (currentPlayer >  } List<Integer>  i <= m; i++)  } } for (int i = 0;  System.out.print(\" \"); System.out.print(result.get(i)); } System.out.println(); } sc.close(); } static String getCorrectStatement(int  15 == 0) { return \"FizzBuzz\"; } else if (num % 3  } else if (num % 5 == 0) { return \"Buzz\"; } else { return String.valueOf(num); } } }"], "perturbed_original": ["import java.util.*; class Main { public static void main (String[] args) { Scanner sc = new Scanner(System.in); int  m = sc.nextInt(); n = sc.nextInt();  } fb = new FizzBuzz(m); for(int i=0; i<n; i++) { if(!fb.sayNextStatement(sc.next())) { break; } } fb.showPlayer(); } } } class FizzBuzz { private int current,currentPlayer; private int m; private int[] player; public FizzBuzz(int m) { current = 0; currentPlayer = 0; this.m = m; player =   } } public void  != -1){ System.out.println(pl); } } } public boolean sayNextStatement(String statement) { try { int num = Integer.valueOf(statement); if(!checkFizzBuzz(num)) { player[currentPlayer] = -1; } } catch(NumberFormatException e) { if(!checkFizzBuzz(statement)) { player[currentPlayer] = -1; } } if(!setCurrentPlayer())   currentPlayer; if(currentPlayer+1 == m) { currentPlayer = 0; } else { currentPlayer  { if(currentPlayer+1  0; } else { currentPlayer ++; } if(prev == currentPlayer) { return false;  private boolean checkFizzBuzz(int statement) { current ++; if((current % 3 == 0) || (current % 5 == 0)) {  if(current == statement) { return true; } else { return false; } } } private boolean checkFizzBuzz(String statement) { current ++; if((current % 3  5 == 0)) { if(statement.equals(\"FizzBuzz\")) { return  false; }  else { return false; } } else if(current % 5 == 0)  } else { return false; } } else { return false; } } }"], "original_ll": -0.5714502930641174, "sampled_ll": -0.4894731640815735, "all_perturbed_sampled_ll": [-1.677233338356018], "all_perturbed_original_ll": [-1.5949655771255493], "perturbed_sampled_ll": -1.677233338356018, "perturbed_original_ll": -1.5949655771255493, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# Aizu Problem 0221: Fizz Buzz\n\nimport sys, math, os, struct\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\ndef valid(k, a):\n    if k % 3 == 0 and k % 5 == 0:\n        return a == \"FizzBuzz\"\n    elif k % 3 == 0:\n        return a == \"Fizz\"\n    elif k % 5 == 0:\n        return a == \"Buzz\"\n    else:\n        return int(a) == k\n\n    \ndef fizz_buzz(m, n, A):\n    players = list(range(1, m + 1))\n    p = 0\n    k = 0\n    while len(A) > 0:\n        k += 1\n        a = A.pop(0)\n        if valid(k, a):\n            p = (p + 1) % m\n        else:\n            if len(players) == 0:\n                print()\n                return\n            players.pop(p)\n            if len(players) == 1:\n                break\n            m -= 1\n            if p == m:\n                p = 0\n    print(' '.join([str(p) for p in players]))\n    \n    \nwhile True:\n    m, n = [int(_) for _ in input().split()]\n    if m == 0:\n        break\n    A = [input().strip() for _ in range(n)]\n    fizz_buzz(m, n, A)", "sampled": "def get_expected(num):\n    if num % 15 == 0:\n        return \"FizzBuzz\"\n    elif num % 3 == 0:\n        return \"Fizz\"\n    elif num % 5 == 0:\n        return \"Buzz\"\n    else:\n        return str(num)\n\nwhile True:\n    line = input().split()\n    m, n = int(line[0]), int(line[1])\n    \n    if m == 0 and n == 0:\n        break\n    \n    players = set(range(1, m + 1))\n    current_num = 1\n    current_player = 1\n    \n    for _ in range(n):\n        statement = input().strip()\n        \n        if len(players) == 1:\n            continue\n        \n        while current_player not in players:\n            current_player += 1\n            if current_player > m:\n                current_player = 1\n        \n        expected = get_expected(current_num)\n        \n        if statement != expected:\n            players.discard(current_player)\n        \n        current_num += 1\n        current_player += 1\n        if current_player > m:\n            current_player = 1\n    \n    result = sorted(list(players))\n    print(' '.join(map(str, result)))\n", "perturbed_sampled": ["def get_expected(num): if num % 15 == 0:  \"Fizz\" elif num % 5 == 0: return \"Buzz\" else: return str(num)  m, n = int(line[0]), int(line[1]) if m == 0 and n == 0: break players = set(range(1, m + 1)) current_num = 1  in range(n): statement = input().strip() if len(players)  not in players: current_player += 1 if current_player > m: current_player = 1 expected = get_expected(current_num) if statement != expected: players.discard(current_player) current_num += 1  > m: current_player = 1 result = sorted(list(players)) print(' '.join(map(str, result)))"], "perturbed_original": ["# Aizu  sys, math, os, struct  os.environ.get('PYDEV') if PYDEV==\"True\": sys.stdin = open(\"sample-input.txt\", \"rt\") def valid(k, a): if k % 3 == 0 and k  a == \"FizzBuzz\" elif k % 3 == 0: return a == \"Fizz\" elif k % 5 == 0: return a == \"Buzz\" else: return int(a) == k def fizz_buzz(m,  m  k = 0 while len(A)  a = A.pop(0)  (p + 1) %  0: print() return players.pop(p) if len(players) == 1: break m -= 1 if p == m: p = 0 print(' '.join([str(p) for p in players])) while True: m, n = [int(_) for _ in input().split()] if m == 0: break A =  fizz_buzz(m, n, A)"], "original_ll": -1.054895043373108, "sampled_ll": -0.7580963969230652, "all_perturbed_sampled_ll": [-1.770504117012024], "all_perturbed_original_ll": [-2.257280111312866], "perturbed_sampled_ll": -1.770504117012024, "perturbed_original_ll": -2.257280111312866, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "c[1<<23],*p,n=1e7;main(a,b){for(;a+=2,a<n;)for(b=a/2;(b+=a)<n;)c[b]=1;for(;scanf(\"%d\",&n)*n;printf(\"%d\\n\",n))for(;p=c+n/2-4,~n&1|p[4]|p[3]|p[1]|*p;n--);}", "sampled": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX 10000010\n\nbool is_prime[MAX];\nint quadruplets[MAX];\n\nvoid sieve() {\n    memset(is_prime, true, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n}\n\nvoid find_quadruplets() {\n    memset(quadruplets, 0, sizeof(quadruplets));\n    \n    for (int a = 2; a + 8 < MAX; a++) {\n        if (is_prime[a] && is_prime[a+2] && is_prime[a+6] && is_prime[a+8]) {\n            int size = a + 8;\n            quadruplets[size] = size;\n        }\n    }\n    \n    int max_so_far = 0;\n    for (int i = 0; i < MAX; i++) {\n        if (quadruplets[i] > 0) {\n            max_so_far = quadruplets[i];\n        }\n        quadruplets[i] = max_so_far;\n    }\n}\n\nint main() {\n    sieve();\n    find_quadruplets();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        printf(\"%d\\n\", quadruplets[n]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  10000010 bool is_prime[MAX]; int quadruplets[MAX]; void sieve() { memset(is_prime, true, sizeof(is_prime)); is_prime[0] = is_prime[1] = false; for (int i  < MAX; i++) { if (is_prime[i]) { for (int j = i * i; j <  } } } void find_quadruplets() { memset(quadruplets, 0, sizeof(quadruplets)); for    && is_prime[a+6] && is_prime[a+8]) { int size = a + 8; quadruplets[size] = size; } } int max_so_far = 0; for (int i = 0; i < MAX; i++) { if (quadruplets[i] > 0) { max_so_far = quadruplets[i];  } int main() { sieve(); find_quadruplets(); int n; while (scanf(\"%d\", &n) == 1 && n != 0) { printf(\"%d\\n\", quadruplets[n]); } return 0; }"], "perturbed_original": ["c[1<<23],*p,n=1e7;main(a,b){for(;a+=2,a<n;)for(b=a/2;(b+=a)<n;)c[b]=1;for(;scanf(\"%d\",&n)*n;printf(\"%d\\n\",n))for(;p=c+n/2-4,~n&1|p[4]|p[3]|p[1]|*p;n--);}"], "original_ll": -2.653404951095581, "sampled_ll": -0.45914971828460693, "all_perturbed_sampled_ll": [-1.2479544878005981], "all_perturbed_original_ll": [-2.653404951095581], "perturbed_sampled_ll": -1.2479544878005981, "perturbed_original_ll": -2.653404951095581, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tfinal int MAX = 10000000;\n\n\tboolean[] prime = new boolean[MAX + 10];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tArrays.fill(prime, true);\n\n\t\t//\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\n\t\tprime[0] = prime[1] = false;\n\t\tfor (int i = 2; i * i < MAX + 10; i++) {\n\t\t\tif (prime[i]) {\n\t\t\t\tfor (int j = i + i; j < MAX + 10; j += i) {\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint max = 0;\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = n; i >= 8; i--) {\n\t\t\t\tif (prime[i] && prime[i - 2] && prime[i - 6] && prime[i - 8]) {\n\t\t\t\t\tmax = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int MAX = 10000000;\n        boolean[] isPrime = new boolean[MAX + 10];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i <= MAX + 8; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= MAX + 8; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        List<Integer> quadPrimes = new ArrayList<>();\n        for (int a = 2; a <= MAX; a++) {\n            if (isPrime[a] && isPrime[a + 2] && isPrime[a + 6] && isPrime[a + 8]) {\n                quadPrimes.add(a + 8);\n            }\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int result = 0;\n            for (int size : quadPrimes) {\n                if (size <= n) {\n                    result = size;\n                } else {\n                    break;\n                }\n            }\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc  =  boolean[MAX + 10]; Arrays.fill(isPrime, true); isPrime[0] =  i = 2; i * i <=  if (isPrime[i]) { for (int j = i * i; j <= MAX + 8; j += i) { isPrime[j] = false; } } }   a <= MAX;  isPrime[a + 8]) { quadPrimes.add(a + 8); } } while (true) { int n = sc.nextInt(); if (n == 0) break; int result = 0; for (int size : quadPrimes) { if (size <= n) { result = size; } else { break; } } System.out.println(result); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { final int MAX =  boolean[MAX + 10]; void run() { Scanner sc  //\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9 prime[0] = prime[1] = false; for (int i =  MAX + 10; i++) { if (prime[i]) { for (int j = i + i; j < MAX + 10; j += i) {  } while (true) { int  = 0; if (n == 0) { break; } for (int i  && prime[i - 2] && prime[i  8]) { max = i; break; } } System.out.println(max); } } public static void main(String[] args) { new Main().run(); } }"], "original_ll": -0.576786994934082, "sampled_ll": -0.49576953053474426, "all_perturbed_sampled_ll": [-1.5154772996902466], "all_perturbed_original_ll": [-1.7188715934753418], "perturbed_sampled_ll": -1.5154772996902466, "perturbed_original_ll": -1.7188715934753418, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def get_quad(n, p):\n    for ni in range(n,0,-1):\n        if p[ni] and p[ni - 2] and p[ni - 6] and p[ni - 8]:\n            return ni\n        \ndef sieve():\n    n = 10000001\n    p = [1] * n\n    p[0] = p[1] = 0\n    \n    for i in range(int(n ** 0.5)):\n        if p[i]:\n            for j in range(2 * i, len(p), i):\n                p[j] = 0\n    return p\nimport sys\nf = sys.stdin\n\nprime = sieve()\nwhile True:\n    n = f.readline()\n    if not n.isnumeric():\n        continue\n    n = int(n)\n    if n == 0:\n        break\n    print(get_quad(ni, prime))", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\ndef find_quadruplet_primes(limit):\n    is_prime = sieve_of_eratosthenes(limit)\n    quadruplets = []\n    \n    for a in range(2, limit - 7):\n        if is_prime[a] and is_prime[a+2] and is_prime[a+6] and is_prime[a+8]:\n            quadruplets.append(a + 8)\n    \n    return quadruplets\n\n# Precompute all quadruplet primes up to 10,000,000\nMAX_LIMIT = 10000000\nquadruplet_sizes = find_quadruplet_primes(MAX_LIMIT)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    # Binary search for the largest quadruplet size <= n\n    result = 0\n    for size in quadruplet_sizes:\n        if size <= n:\n            result = size\n        else:\n            break\n    \n    print(result)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime  1) is_prime[0] = is_prime[1] = False for i in range(2, int(limit**0.5) + 1): if is_prime[i]: for j in range(i*i, limit  False return is_prime def find_quadruplet_primes(limit): is_prime = sieve_of_eratosthenes(limit) quadruplets = [] for a  if is_prime[a] and is_prime[a+2] and is_prime[a+6] and is_prime[a+8]: quadruplets.append(a + 8) return quadruplets # Precompute all quadruplet primes up to 10,000,000 MAX_LIMIT = 10000000 quadruplet_sizes = find_quadruplet_primes(MAX_LIMIT) while True: n  0:  the largest quadruplet size <= n result = 0 for size in quadruplet_sizes: if size <=  break print(result)"], "perturbed_original": ["def  range(n,0,-1): if p[ni] and p[ni - 2] and p[ni - 6] and p[ni - 8]: return ni  p = [1] * n p[0] = p[1] = 0 for i in range(int(n ** 0.5)): if p[i]: for j in range(2 *  sys  sieve() while True: n = f.readline() if not n.isnumeric(): continue n = int(n) if n == 0: break print(get_quad(ni, prime))"], "original_ll": -1.112264633178711, "sampled_ll": -0.6371775269508362, "all_perturbed_sampled_ll": [-1.4416505098342896], "all_perturbed_original_ll": [-2.169151544570923], "perturbed_sampled_ll": -1.4416505098342896, "perturbed_original_ll": -2.169151544570923, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\n#include<stdbool.h>\n\n#define MIN(x,y) (((x)<(y))?(x):(y))\n#define INFTY (1<<21)\n\n\nint m, n, k, d, C[7], G[110][110], N, D[110][64];\n\nint getID(char *str);\nint isC(int x);\nint bellman(void);\n\nint main(void){\n  char source[16], target[16];\n  int cost,s,t;\n  int i,j;\n  while(scanf(\"%d%*c%d%*c%d%*c%d%*c\",&m,&n,&k,&d) && m ){\n    N = 2 + n + m;\n    for(i=1;i<m+1;i++) scanf(\"%d%*c\",&C[i]);\n    for(i=0;i<N;i++) for(j=0;j<N;j++) G[i][j] = INFTY;\n    for(i=0;i<d;i++){\n      scanf(\"%s%*c%s%*c%d%*c\",source,target,&cost);\n      s = getID(source);\n      t = getID(target);\n      G[t][s] = G[s][t] = MIN(G[s][t], cost * k);\n    }\n    printf(\"%d\\n\",bellman());\n  }\n  return 0;\n}\n\nint getID(char *str){\n  char num[16];\n  if ( str[0] == 'H' ) return 0;\n  if ( str[0] == 'D' ) return N - 1;\n  strcpy(num,str+1);\n  if ( str[0] == 'C' ) return atoi(num);\n  return atoi(num) + m;\n}\n\nint isC(int x){\n  return 1 <= x && x <= m;\n}\nint bellman(void){\n  bool change=0;\n  int minv;\n  int i,o,u,v,b,j;\n\n  for(i=0;i<N;i++) for(j=0;j<(1<<m);j++) D[i][j] = INFTY;\n  D[0][0] = 0;\n  for(o=0;o<N*(1<<m);o++){\n    for(u=0;u<N;u++){\n      for(v=0;v<N;v++){\n\tif ( u == v || G[u][v] == INFTY ) continue;\n\tfor(b=0;b<(1<<m);b++){\n\t  if (isC(v) && (b&(1<<(v-1))) != 0 ) continue;\n\t  if ( isC(v) ) {\n\t    if ( D[u][b] + G[u][v] - C[v] < D[v][b|(1<<(v-1))] ) {\n\t      D[v][b|(1<<(v-1))] = D[u][b] + G[u][v] - C[v];\n\t      change = true;\n\t    }\n\t  } else {\n\t    if ( D[u][b] + G[u][v] < D[v][b] ){\n\t      D[v][b] = D[u][b] + G[u][v];\n\t      change = true;\n\t    }\n\t  }\n\t}\n      }\n    }\n    if ( !change ) break;\n  }\n  minv = INFTY;\n  for(i=0;i<(1<<m);i++) minv = MIN(minv, D[N-1][i]);\n  return minv;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define INF 1000000000\n#define MAX_NODES 110\n\nint m, n, k, d;\nint calories[10];\nint dist[MAX_NODES][MAX_NODES];\nint H_idx, D_idx;\nint C_idx[10];\nint L_idx[110];\n\nint parse_node(char *s) {\n    if (s[0] == 'H') return H_idx;\n    if (s[0] == 'D') return D_idx;\n    if (s[0] == 'C') {\n        int num;\n        sscanf(s + 1, \"%d\", &num);\n        return C_idx[num - 1];\n    }\n    if (s[0] == 'L') {\n        int num;\n        sscanf(s + 1, \"%d\", &num);\n        return L_idx[num - 1];\n    }\n    return -1;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid floyd_warshall(int nodes) {\n    for (int k = 0; k < nodes; k++) {\n        for (int i = 0; i < nodes; i++) {\n            for (int j = 0; j < nodes; j++) {\n                if (dist[i][k] != INF && dist[k][j] != INF) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d %d\", &m, &n, &k, &d);\n        if (m == 0 && n == 0 && k == 0 && d == 0) break;\n\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d\", &calories[i]);\n        }\n\n        int nodes = 2 + m + n;\n        H_idx = 0;\n        D_idx = 1;\n        for (int i = 0; i < m; i++) C_idx[i] = 2 + i;\n        for (int i = 0; i < n; i++) L_idx[i] = 2 + m + i;\n\n        for (int i = 0; i < nodes; i++) {\n            for (int j = 0; j < nodes; j++) {\n                if (i == j) dist[i][j] = 0;\n                else dist[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < d; i++) {\n            char s[10], t[10];\n            int e;\n            scanf(\"%s %s %d\", s, t, &e);\n            int u = parse_node(s);\n            int v = parse_node(t);\n            dist[u][v] = min(dist[u][v], e);\n            dist[v][u] = min(dist[v][u], e);\n        }\n\n        floyd_warshall(nodes);\n\n        int min_cost = INF;\n        for (int mask = 0; mask < (1 << m); mask++) {\n            int perm[10];\n            int cnt = 0;\n            for (int i = 0; i < m; i++) {\n                if (mask & (1 << i)) {\n                    perm[cnt++] = i;\n                }\n            }\n\n            if (cnt == 0) {\n                int total_dist = dist[H_idx][D_idx];\n                int cost = total_dist * k;\n                min_cost = min(min_cost, cost);\n            } else {\n                int fact = 1;\n                for (int i = 1; i <= cnt; i++) fact *= i;\n                \n                for (int p = 0; p < fact; p++) {\n                    int temp_perm[10];\n                    for (int i = 0; i < cnt; i++) temp_perm[i] = perm[i];\n                    \n                    int temp = p;\n                    for (int i = 0; i < cnt; i++) {\n                        int j = i + temp % (cnt - i);\n                        temp /= (cnt - i);\n                        int t = temp_perm[i];\n                        temp_perm[i] = temp_perm[j];\n                        temp_perm[j] = t;\n                    }\n\n                    int total_dist = dist[H_idx][C_idx[temp_perm[0]]];\n                    int total_cal = calories[temp_perm[0]];\n                    for (int i = 1; i < cnt; i++) {\n                        total_dist += dist[C_idx[temp_perm[i - 1]]][C_idx[temp_perm[i]]];\n                        total_cal += calories[temp_perm[i]];\n                    }\n                    total_dist += dist[C_idx[temp_perm[cnt - 1]]][D_idx];\n\n                    int cost = total_dist * k - total_cal;\n                    min_cost = min(min_cost, cost);\n                }\n            }\n        }\n\n        printf(\"%d\\n\", min_cost);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include  #define INF 1000000000 #define MAX_NODES 110 int m, n, k, d; int calories[10]; int dist[MAX_NODES][MAX_NODES]; int H_idx, D_idx; int C_idx[10]; int L_idx[110];  (s[0] == 'H') return H_idx; if (s[0] == 'D') return D_idx; if  num; sscanf(s + 1, \"%d\", &num); return C_idx[num - 1]; } if (s[0] == 'L') { int num; sscanf(s + 1, \"%d\", &num); return L_idx[num  } int min(int a, int   { for (int k = 0; k < nodes; k++) { for (int i = 0; i < nodes; i++) { for (int j = 0; j <  != INF && dist[k][j] != INF) { dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } } } }  (1) { scanf(\"%d %d %d %d\", &m, &n, &k, &d); if (m == 0 && n == 0 && k == 0 && d == 0)  0; i < m; i++) { scanf(\"%d\", &calories[i]); } int nodes = 2  = 0; D_idx = 1;  i < m; i++) C_idx[i] = 2 + i; for (int i = 0; i < n; i++) L_idx[i] = 2 + m + i; for (int i  i++) { for (int j = 0; j < nodes;  j) dist[i][j] = 0; else dist[i][j] = INF; } } for (int i = 0;  char s[10], t[10]; int e; scanf(\"%s %s %d\", s, t, &e); int u = parse_node(s); int v = parse_node(t); dist[u][v] = min(dist[u][v], e); dist[v][u] = min(dist[v][u], e); } floyd_warshall(nodes); int min_cost = INF; for (int mask = 0; mask < (1 << m); mask++) { int perm[10]; int cnt = 0; for (int i = 0; i < m; i++) { if (mask &  = i; } } if (cnt == 0) { int total_dist = dist[H_idx][D_idx]; int cost = total_dist * k; min_cost =  int  i = 1; i <= cnt;  (int p = 0; p < fact;  (int  cnt; i++) temp_perm[i] = perm[i]; int  i =  { int j = i    = t; } int total_dist = dist[H_idx][C_idx[temp_perm[0]]];  (int i = 1; i < cnt; i++) { total_dist += dist[C_idx[temp_perm[i - 1]]][C_idx[temp_perm[i]]]; total_cal += calories[temp_perm[i]]; } total_dist += dist[C_idx[temp_perm[cnt - 1]]][D_idx]; int cost = total_dist * k - total_cal; min_cost  return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> #include<stdbool.h> #define MIN(x,y) (((x)<(y))?(x):(y)) #define INFTY (1<<21) int m, n, k, d, C[7], G[110][110], N, D[110][64]; int getID(char *str);  int main(void){ char source[16], target[16]; int cost,s,t; int  N = 2 + n + m; for(i=1;i<m+1;i++) scanf(\"%d%*c\",&C[i]); for(i=0;i<N;i++) for(j=0;j<N;j++) G[i][j] = INFTY; for(i=0;i<d;i++){ scanf(\"%s%*c%s%*c%d%*c\",source,target,&cost); s = getID(source); t = getID(target); G[t][s] = G[s][t] = MIN(G[s][t], cost * k); } printf(\"%d\\n\",bellman()); } return 0; } int getID(char *str){ char num[16]; if ( str[0]  if ( str[0] ==  1; strcpy(num,str+1); if ( str[0] == 'C' ) return atoi(num); return atoi(num) + m; } int isC(int x){ return 1 <= x && x  bool  INFTY; D[0][0] = 0; for(o=0;o<N*(1<<m);o++){ for(u=0;u<N;u++){  v || G[u][v] == INFTY ) continue; for(b=0;b<(1<<m);b++){ if (isC(v) && (b&(1<<(v-1))) != 0 ) continue; if ( isC(v) ) {  - C[v] < D[v][b|(1<<(v-1))] ) { D[v][b|(1<<(v-1))] =  change = true; } } else {  < D[v][b] ){ D[v][b] = D[u][b] +   ( !change ) break; } minv = INFTY; for(i=0;i<(1<<m);i++) minv = MIN(minv, D[N-1][i]); return minv; }"], "original_ll": -0.8313256502151489, "sampled_ll": -0.39361000061035156, "all_perturbed_sampled_ll": [-1.2401608228683472], "all_perturbed_original_ll": [-1.5758662223815918], "perturbed_sampled_ll": -1.2401608228683472, "perturbed_original_ll": -1.5758662223815918, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tstatic int m;\n\tstatic int n;\n\tstatic int k;\n\tstatic int d;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tk = sc.nextInt();\n\t\t\td = sc.nextInt();\n\t\t\tif(m == 0 && n == 0 && k == 0 && d == 0) break;\n\t\t\tint[] c = new int[m];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] node = new Node[m + n + 2];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tnode[i] = new Node();\n\t\t\t\tnode[i].type = 2;\n\t\t\t}\n\t\t\tfor(int i = m; i < m + n; i++) {\n\t\t\t\tnode[i] = new Node();\n\t\t\t\tnode[i].type = 3;\n\t\t\t}\n\t\t\tnode[m + n    ] = new Node();\n\t\t\tnode[m + n    ].type = 0;\n\t\t\tnode[m + n + 1] = new Node();\n\t\t\tnode[m + n + 1].type = 1;\n\t\t\t\n\t\t\tfor(int i = 0; i < d; i++) {\n\t\t\t\tString a = sc.next();\n\t\t\t\tString b = sc.next();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tint idA = -100;\n\t\t\t\tint idB = -100;\n\t\t\t\tif(a.length() == 1) {\n\t\t\t\t\tif(a.equals(\"H\")) idA = m + n;\n\t\t\t\t\telse \t\t\t  idA = m + n + 1;\n\t\t\t\t}\n\t\t\t\tif(b.length() == 1) {\n\t\t\t\t\tif(b.equals(\"H\")) idB = m + n;\n\t\t\t\t\telse\t\t\t  idB = m + n + 1;\n\t\t\t\t}\n\t\t\t\tif(idA == -100) {\n\t\t\t\t\tif(a.charAt(0) == 'C') {\n\t\t\t\t\t\tidA = Integer.parseInt(a.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tidA = m + Integer.parseInt(a.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(idB == -100) {\n\t\t\t\t\tif(b.charAt(0) == 'C') {\n\t\t\t\t\t\tidB = Integer.parseInt(b.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tidB = m + Integer.parseInt(b.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode[idA].edge_to.add(idB);\n\t\t\t\tnode[idA].edge_cost.add(cost);\n\t\t\t\tnode[idB].edge_to.add(idA);\n\t\t\t\tnode[idB].edge_cost.add(cost);\n\t\t\t}\n\t\t\tint[][] dp = new int[n + m + 2][1 << m];\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tfor(int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\tdp[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Data> queue = new PriorityQueue<Data>();\n\t\t\tqueue.add(new Data(m + n,new boolean[m],0));\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tData tmp = queue.poll();\n\t\t\t\tint V = 0;\n\t\t\t\tfor(int i = 0; i < tmp.v.length; i++) {\n\t\t\t\t\tif(tmp.v[i]) {\n\t\t\t\t\t\tV |= 1 << i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dp[tmp.now][V] <= tmp.cost) continue;\n\t\t\t\tdp[tmp.now][V] = tmp.cost;\n\t\t\t\tNode now = node[tmp.now];\n\t\t\t\tfor(int i = 0; i < now.edge_to.size(); i++) {\n\t\t\t\t\tif(node[now.edge_to.get(i)].type == 2 && tmp.v[now.edge_to.get(i)]) continue;\n\t\t\t\t\tif(node[now.edge_to.get(i)].type == 2) {\n\t\t\t\t\t\tboolean[] copy = Arrays.copyOf(tmp.v, tmp.v.length);\n\t\t\t\t\t\tcopy[now.edge_to.get(i)] = true; \n\t\t\t\t\t\tqueue.add(new Data(now.edge_to.get(i),copy, tmp.cost - c[now.edge_to.get(i)] + now.edge_cost.get(i) * k));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tqueue.add(new Data(now.edge_to.get(i),tmp.v, tmp.cost + now.edge_cost.get(i) * k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint MIN = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < dp[m + n + 1].length; i++) {\n\t\t\t\tMIN = Math.min(MIN, dp[m + n + 1][i]);\n\t\t\t}\n\t\t\tSystem.out.println(MIN);\n\t\t}\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint cost;\n\t\tboolean[] v;\n\t\tint now;\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t\tData(int c, boolean[] b, int a) {\n\t\t\tcost = a;\n\t\t\tv    = b;\n\t\t\tnow  = c;\n\t\t}\n\t}\n\tstatic class Node {\n\t\tint type; // 0 H, 1 D, 2 C, 3 L\n\t\tboolean c;\n\t\tArrayList<Integer> edge_to = new ArrayList<Integer>();\n\t\tArrayList<Integer> edge_cost = new ArrayList<Integer>();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Edge {\n        String to;\n        int dist;\n        Edge(String to, int dist) {\n            this.to = to;\n            this.dist = dist;\n        }\n    }\n    \n    static Map<String, List<Edge>> graph;\n    static int[] cakeCals;\n    static int m, n, k, d;\n    static Map<String, Integer> nodeToIdx;\n    static String[] idxToNode;\n    static int numNodes;\n    static int[][] dist;\n    static final int INF = 1000000000;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            m = Integer.parseInt(parts[0]);\n            n = Integer.parseInt(parts[1]);\n            k = Integer.parseInt(parts[2]);\n            d = Integer.parseInt(parts[3]);\n            \n            if (m == 0 && n == 0 && k == 0 && d == 0) break;\n            \n            cakeCals = new int[m + 1];\n            parts = br.readLine().trim().split(\"\\\\s+\");\n            for (int i = 1; i <= m; i++) {\n                cakeCals[i] = Integer.parseInt(parts[i - 1]);\n            }\n            \n            graph = new HashMap<>();\n            Set<String> nodes = new HashSet<>();\n            \n            for (int i = 0; i < d; i++) {\n                parts = br.readLine().trim().split(\"\\\\s+\");\n                String s = parts[0];\n                String t = parts[1];\n                int e = Integer.parseInt(parts[2]);\n                \n                nodes.add(s);\n                nodes.add(t);\n                \n                graph.putIfAbsent(s, new ArrayList<>());\n                graph.putIfAbsent(t, new ArrayList<>());\n                graph.get(s).add(new Edge(t, e));\n                graph.get(t).add(new Edge(s, e));\n            }\n            \n            nodeToIdx = new HashMap<>();\n            idxToNode = new String[nodes.size()];\n            int idx = 0;\n            for (String node : nodes) {\n                nodeToIdx.put(node, idx);\n                idxToNode[idx] = node;\n                idx++;\n            }\n            numNodes = nodes.size();\n            \n            // Floyd-Warshall\n            dist = new int[numNodes][numNodes];\n            for (int i = 0; i < numNodes; i++) {\n                Arrays.fill(dist[i], INF);\n                dist[i][i] = 0;\n            }\n            \n            for (String from : graph.keySet()) {\n                int fromIdx = nodeToIdx.get(from);\n                for (Edge e : graph.get(from)) {\n                    int toIdx = nodeToIdx.get(e.to);\n                    dist[fromIdx][toIdx] = Math.min(dist[fromIdx][toIdx], e.dist);\n                }\n            }\n            \n            for (int kk = 0; kk < numNodes; kk++) {\n                for (int i = 0; i < numNodes; i++) {\n                    for (int j = 0; j < numNodes; j++) {\n                        if (dist[i][kk] != INF && dist[kk][j] != INF) {\n                            dist[i][j] = Math.min(dist[i][j], dist[i][kk] + dist[kk][j]);\n                        }\n                    }\n                }\n            }\n            \n            int minCal = INF;\n            \n            // Try all permutations of visiting cake shops\n            for (int mask = 0; mask < (1 << m); mask++) {\n                List<Integer> cakeShops = new ArrayList<>();\n                for (int i = 0; i < m; i++) {\n                    if ((mask & (1 << i)) != 0) {\n                        cakeShops.add(i + 1);\n                    }\n                }\n                \n                if (cakeShops.isEmpty()) {\n                    int hIdx = nodeToIdx.get(\"H\");\n                    int dIdx = nodeToIdx.get(\"D\");\n                    int totalDist = dist[hIdx][dIdx];\n                    int cal = totalDist * k;\n                    minCal = Math.min(minCal, cal);\n                } else {\n                    int[] perm = new int[cakeShops.size()];\n                    for (int i = 0; i < cakeShops.size(); i++) {\n                        perm[i] = cakeShops.get(i);\n                    }\n                    \n                    permute(perm, 0, minCal);\n                }\n            }\n            \n            System.out.println(minCal);\n        }\n    }\n    \n    static int minCal;\n    \n    static void permute(int[] arr, int start, int currentMin) {\n        if (start == arr.length) {\n            int hIdx = nodeToIdx.get(\"H\");\n            int dIdx = nodeToIdx.get(\"D\");\n            \n            int totalDist = dist[hIdx][nodeToIdx.get(\"C\" + arr[0])];\n            int totalCakeCal = cakeCals[arr[0]];\n            \n            for (int i = 1; i < arr.length; i++) {\n                totalDist += dist[nodeToIdx.get(\"C\" + arr[i - 1])][nodeToIdx.get(\"C\" + arr[i])];\n                totalCakeCal += cakeCals[arr[i]];\n            }\n            \n            totalDist += dist[nodeToIdx.get(\"C\" + arr[arr.length - 1])][dIdx];\n            \n            int cal = totalDist * k - totalCakeCal;\n            minCal = Math.min(minCal, cal);\n            return;\n        }\n        \n        for (int i = start; i < arr.length; i++) {\n            swap(arr, i, start);\n            permute(arr, start + 1, currentMin);\n            swap(arr, i, start);\n        }\n    }\n    \n    static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static  dist; } } static Map<String, List<Edge>> graph; static int[] cakeCals; static int m, n, k, d; static Map<String, Integer> nodeToIdx; static String[] idxToNode; static int numNodes; static int[][] dist; static final int INF = 1000000000; public static void main(String[] args)  = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[]  k = Integer.parseInt(parts[2]); d = Integer.parseInt(parts[3]); if (m == 0 && n == 0 && k == 0 &&  = new int[m + 1]; parts =  1;  cakeCals[i] = Integer.parseInt(parts[i  new HashMap<>(); Set<String> nodes = new  0; i < d; i++) { parts = br.readLine().trim().split(\"\\\\s+\"); String s = parts[0]; String t = parts[1]; int e = Integer.parseInt(parts[2]); nodes.add(s); nodes.add(t); graph.putIfAbsent(s, new ArrayList<>()); graph.putIfAbsent(t, new ArrayList<>()); graph.get(s).add(new Edge(t, e)); graph.get(t).add(new Edge(s, e)); } nodeToIdx = new HashMap<>();  idx = 0; for (String node : nodes) { nodeToIdx.put(node, idx); idxToNode[idx] = node; idx++; } numNodes = nodes.size(); // Floyd-Warshall dist =  = 0; i < numNodes; i++) { Arrays.fill(dist[i], INF); dist[i][i] = 0; } for (String from :  nodeToIdx.get(from); for (Edge e : graph.get(from))  dist[fromIdx][toIdx] =  (int kk = 0; kk < numNodes;  = 0; i < numNodes; i++) { for (int j =  { if (dist[i][kk] != INF  + dist[kk][j]); } } } } int minCal = INF; // Try all permutations of visiting cake  0; mask < (1 << m); mask++) { List<Integer> cakeShops = new ArrayList<>(); for (int i = 0; i < m; i++) { if ((mask & (1  cakeShops.add(i + 1); } } if (cakeShops.isEmpty()) { int hIdx = nodeToIdx.get(\"H\"); int dIdx = nodeToIdx.get(\"D\"); int totalDist = dist[hIdx][dIdx]; int cal = totalDist * k; minCal = Math.min(minCal, cal); } else { int[] perm = new int[cakeShops.size()]; for (int i =  {  0, minCal);  void permute(int[] arr, int start, int  arr.length) { int hIdx =  int totalDist = dist[hIdx][nodeToIdx.get(\"C\" +  for (int i = 1; i < arr.length; i++) { totalDist += dist[nodeToIdx.get(\"C\" + arr[i - 1])][nodeToIdx.get(\"C\" + arr[i])]; totalCakeCal += cakeCals[arr[i]]; }  - 1])][dIdx]; int cal = totalDist * k - totalCakeCal; minCal = Math.min(minCal, cal); return; } for (int i =  { swap(arr, i, start); permute(arr, start + 1, currentMin); swap(arr, i, start); } } static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } }"], "perturbed_original": ["import java.util.*; import java.math.*; public class Main{ static int INF = 2 << 27; static int m; static int n; static int k; static int d; public static void main(String[]  new Scanner(System.in); while(true) {  sc.nextInt(); k = sc.nextInt(); d =  n == 0 && k == 0 && d == 0) break; int[] c = new int[m];   = sc.nextInt(); } Node[] node = new Node[m + n + 2]; for(int i  i++) { node[i] = new Node(); node[i].type = 2; }  < m + n; i++) { node[i] =  } node[m + n ] =  ].type = 0; node[m + n + 1] = new Node(); node[m + n + 1].type = 1; for(int i = 0; i < d; i++) { String a  sc.next(); int cost = sc.nextInt(); int idA = -100; int idB = -100;  idA = m + n; else idA = m + n + 1; } if(b.length() == 1) { if(b.equals(\"H\")) idB = m + n; else  + 1; } if(idA == -100) { if(a.charAt(0) == 'C') { idA = Integer.parseInt(a.substring(1)) - 1; } else { idA = m + Integer.parseInt(a.substring(1)) - 1; } } if(idB ==  { idB = Integer.parseInt(b.substring(1))  idB = m + Integer.parseInt(b.substring(1)) - 1;  node[idB].edge_cost.add(cost); }  + m + 2][1 << m]; for(int i = 0; i < dp.length; i++) { for(int j = 0; j  = INF; } } PriorityQueue<Data> queue = new PriorityQueue<Data>(); queue.add(new Data(m  Data tmp = queue.poll();   tmp.v.length; i++) { if(tmp.v[i]) { V |= 1 << i; }  dp[tmp.now][V]   i < now.edge_to.size(); i++) { if(node[now.edge_to.get(i)].type == 2 && tmp.v[now.edge_to.get(i)]) continue; if(node[now.edge_to.get(i)].type == 2) { boolean[] copy =  queue.add(new Data(now.edge_to.get(i),copy, tmp.cost -  } else { queue.add(new Data(now.edge_to.get(i),tmp.v, tmp.cost + now.edge_cost.get(i) * k)); } } } int  dp[m + n + 1].length; i++) { MIN = Math.min(MIN, dp[m + n + 1][i]); } System.out.println(MIN); } } static  compareTo(Data o) { return this.cost - o.cost; } Data(int c, boolean[] b, int a) { cost = a; v = b; now = c; } } static class Node { int type; // 0 H, 1 D, 2 C, 3 L boolean c; ArrayList<Integer> edge_to = new ArrayList<Integer>(); ArrayList<Integer> edge_cost = new ArrayList<Integer>(); } }"], "original_ll": -0.5291683673858643, "sampled_ll": -0.368179053068161, "all_perturbed_sampled_ll": [-1.2781728506088257], "all_perturbed_original_ll": [-1.560417652130127], "perturbed_sampled_ll": -1.2781728506088257, "perturbed_original_ll": -1.560417652130127, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import combinations\nfrom heapq import heappop, heappush\nimport sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef convert(s, m, n):\n  if s == \"H\":\n    return 0\n  if s == \"D\":\n    return 1\n  if s[0] == \"C\":\n    return int(s[1]) + 1\n  if s[0] == \"L\":\n    return int(s[1]) + m + 1\n\ndef get_cost(start, m, n, edges):\n  cost = [INF] * (m + n + 2)\n  cost[start] = 0\n  que = []\n  heappush(que, (0, start))\n  while que:\n    total, node = heappop(que)\n    for dist, to in edges[node]:\n      if cost[to] > total + dist:\n        cost[to] = total + dist\n        if not (2 <= to <= m + 1):\n          heappush(que, (total + dist, to))\n  return cost\n\n\ndef shortest_path(start, goal, rest, cakes_dist, dic):\n  if not rest:\n    return cakes_dist[start][goal]\n  if (start, rest) in dic:\n    return dic[(now, rest)]\n  \n  ret = INF\n  for to in rest:\n    ret = min(ret, shortest_path(to, goal, tuple((i for i in rest if i != to)), cakes_dist, dic) + cakes_dist[start][to])\n  dic[(start, rest)] = ret\n  return ret\n\nwhile True:\n  m, n, k, d = map(int, input().split())\n  if m == 0:\n    break\n  clst = list(map(int, input().split()))\n  \"\"\"\n  Home ... 0\n  D ... 1\n  Cake ... 2, 3, ... m + 1\n  Land ... m + 2, m + 3, ... m + n + 1\n  \"\"\"\n  edges = [[] for _ in range(m + n + 2)]\n  for _ in range(d):\n    s, t, e = input().split()\n    e = int(e)\n    s = convert(s, m, n)\n    t = convert(t, m, n)\n    edges[s].append((e, t))\n    edges[t].append((e, s))\n  \n  cakes_dist = [[INF] * (m + 2) for _ in range(m + 2)]\n  for start in range(m + 2):\n    cost = get_cost(start, m, n, edges)\n    for to in range(m + 2):\n      if to != start:\n        cakes_dist[start][to] = cost[to]\n\n", "sampled": "import sys\nfrom itertools import permutations\nfrom collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start, end, avoid_set):\n    \"\"\"Find shortest path avoiding nodes in avoid_set\"\"\"\n    dist = defaultdict(lambda: float('inf'))\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        if u == end:\n            return d\n        for v, w in graph[u]:\n            if v in avoid_set:\n                continue\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    \n    return float('inf')\n\ndef solve(m, n, k, d, calories, edges):\n    # Build graph\n    graph = defaultdict(list)\n    for s, t, e in edges:\n        graph[s].append((t, e))\n        graph[t].append((s, e))\n    \n    # Get all cake shops\n    cake_shops = [f'C{i+1}' for i in range(m)]\n    \n    min_cost = float('inf')\n    \n    # Try all subsets of cake shops (including empty set)\n    for r in range(m + 1):\n        for perm in permutations(cake_shops, r):\n            # For this permutation, calculate the cost\n            # We need to go from H to each shop in order, then to D\n            # avoiding already visited shops\n            \n            visited_shops = set()\n            current = 'H'\n            total_distance = 0\n            total_calories = 0\n            valid = True\n            \n            for shop in perm:\n                # Find shortest path from current to shop, avoiding visited shops\n                dist = dijkstra(graph, current, shop, visited_shops)\n                if dist == float('inf'):\n                    valid = False\n                    break\n                total_distance += dist\n                visited_shops.add(shop)\n                # Eat cake at this shop\n                shop_idx = int(shop[1:]) - 1\n                total_calories += calories[shop_idx]\n                current = shop\n            \n            if not valid:\n                continue\n            \n            # Go from current to D, avoiding visited shops\n            dist = dijkstra(graph, current, 'D', visited_shops)\n            if dist == float('inf'):\n                continue\n            total_distance += dist\n            \n            # Calculate net calorie consumption\n            net_calories = total_distance * k - total_calories\n            min_cost = min(min_cost, net_calories)\n    \n    return min_cost\n\ndef main():\n    while True:\n        line = sys.stdin.readline().strip()\n        if not line:\n            break\n        m, n, k, d = map(int, line.split())\n        if m == 0 and n == 0 and k == 0 and d == 0:\n            break\n        \n        calories = list(map(int, sys.stdin.readline().split()))\n        \n        edges = []\n        for _ in range(d):\n            parts = sys.stdin.readline().split()\n            s, t, e = parts[0], parts[1], int(parts[2])\n            edges.append((s, t, e))\n        \n        result = solve(m, n, k, d, calories, edges)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from itertools import permutations from collections import defaultdict import heapq def dijkstra(graph, start, end, avoid_set): \"\"\"Find shortest path  = defaultdict(lambda: float('inf')) dist[start] = 0 pq = [(0,  = heapq.heappop(pq) if d > dist[u]: continue if u == end: return d for v, w in graph[u]: if v in avoid_set:  < dist[v]: dist[v] = dist[u] + w heapq.heappush(pq, (dist[v],  n, k, d, calories, edges): # Build graph graph = defaultdict(list)  edges: graph[s].append((t, e)) graph[t].append((s, e)) # Get all cake shops cake_shops = [f'C{i+1}' for i in range(m)] min_cost = float('inf') #  shops (including empty  + 1): for  For this permutation, calculate the cost # We need to  shop in order, then to D # avoiding already visited shops visited_shops = set() current = 'H' total_distance = 0 total_calories  for   shop, avoiding visited shops dist = dijkstra(graph, current, shop, visited_shops) if dist == float('inf'): valid = False break total_distance += dist visited_shops.add(shop) # Eat cake at this shop  total_calories += calories[shop_idx] current = shop if not valid: continue  D, avoiding visited shops dist = dijkstra(graph, current, 'D', visited_shops) if dist == float('inf'):  Calculate net calorie consumption net_calories = total_distance * k - total_calories min_cost = min(min_cost, net_calories) return min_cost def main(): while True: line = sys.stdin.readline().strip() if not line: break m, n, k, d = map(int, line.split()) if m == 0 and n == 0  edges = [] for _ in range(d): parts =  t, e)) result = solve(m, n, k, d, calories, edges) print(result) if __name__ == \"__main__\": main()"], "perturbed_original": ["from itertools import combinations from heapq import heappop, heappush import sys sys.setrecursionlimit(1000000) INF =  == \"H\": return 0 if s == \"D\": return 1 if s[0] == \"C\": return int(s[1]) + 1 if s[0] == \"L\": return  def  = [INF]  2) cost[start] = 0 que = [] heappush(que, (0, start)) while que: total, node = heappop(que)  total + dist if not (2 <=  heappush(que, (total + dist, to))  not rest: return cakes_dist[start][goal] if (start, rest) in dic: return dic[(now, rest)] ret = INF for to in rest: ret = min(ret, shortest_path(to, goal, tuple((i for i in rest if i != to)), cakes_dist, dic) + cakes_dist[start][to]) dic[(start, rest)] = ret return ret while True: m, n, k, d = map(int, input().split()) if m == 0: break clst = list(map(int, input().split())) \"\"\" Home ... 0 D ... 1 Cake ... 2, 3, ... m  + 2, m + 3, ... m + n + 1  _ in range(m +  in range(d): s, t, e = input().split() e = int(e) s  = convert(t, m, n) edges[s].append((e, t)) edges[t].append((e, s)) cakes_dist = [[INF] * (m + 2) for _ in range(m + 2)]  m, n, edges) for to in range(m + 2): if to != start: cakes_dist[start][to] = cost[to]"], "original_ll": -0.8364154100418091, "sampled_ll": -0.6717803478240967, "all_perturbed_sampled_ll": [-1.911873459815979], "all_perturbed_original_ll": [-1.9196250438690186], "perturbed_sampled_ll": -1.911873459815979, "perturbed_original_ll": -1.9196250438690186, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0225\nTitle\n@kankichi573\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint n;\nint dir[26];     // in +1 out -1\nint alpha[26];   // tunagatte iruka\nchar buf[33];\nchar con[26][26];  //char a->b connection\nchar con_flag[26]; \n//\nint count_char()\n{\n        int i,cnt=0;\n\n        for(i=0;i<26;i++)\n        {\n                if (alpha[i])\n                {\n                        cnt ++;\n                        //printf(\"CH %c\\n\",'a'+i);\n                }\n        }\n        return(cnt);\n}\nint find_first()\n{\n        int i,cnt=0;\n\n        for(i=0;i<26;i++)\n                if(alpha[i]>0)\n                        return(i);\n        return(-1);\n}\n\nint connected()\n{\n        int from;\n\n        from=find_first();\n        //printf(\"FF=%c\\n\",'a'+from);\n        con_flag[from]=1;\n        return(connected2(from));\n}\nint connected2(int node)\n{\n        int i;\n        int cnt=1;\n        //printf(\"CN2=%c\\n\",'a'+node);\n\n        for(i=0;i<26;i++)\n        {\n                if(i==node)\n                        continue;\n                if(con[node][i] && !con_flag[i])\n                {\n                        //printf(\"CN2_2=%c\\n\",'a'+i);\n\n                        con_flag[i]=1;\n                        cnt += connected2(i);\n                        con_flag[i]=0;\n                }\n        }\n        return(cnt);\n}\nmain()\n{\n        int i,j;\n        int stt,end,ret,ret1;\n        while(EOF!=scanf(\"%d\",&n) && n)\n        {\n                for(i=0;i<26;i++)\n                {\n                        alpha[i]=0;\n                        dir[i]=0;\n                        con_flag[i]=0;\n                        for(j=0;j<26;j++)\n                                con[i][j]=0;\n                }\n                for(i=0;i<n;i++)\n                {\n                        scanf(\"%s\",buf);\n                        stt=buf[0]-'a';\n                        end=buf[strlen(buf)-1]-'a';\n                        dir[stt]++;\n                        dir[end]--;\n                        alpha[stt]=alpha[end]=1;\n                        con[stt][end]=1;\n                }\n\n                ret=connected();   // saisho ni toujou suru\n                                   //node to tunagatte iru suu\n                ret1=count_char(); // node no kazu\n\n                //printf(\"r=%d %d\\n\",ret,ret1);\n\n                if(ret != ret1)   // subeteno node ga tunagaruka\n                {\n                        printf(\"NG\\n\");\n                        continue;\n                }\n\n                for(i=0;i<26;i++) //zenbu guuten ka siraberu\n                        if(dir[i])\n                        {\n                                printf(\"NG\\n\");\n                                goto NEXT;\n                        }\n                printf(\"OK\\n\");\n        NEXT:\n                ;\n        }\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        char words[10000][33];\n        int first[10000], last[10000];\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", words[i]);\n            first[i] = words[i][0] - 'a';\n            last[i] = words[i][strlen(words[i]) - 1] - 'a';\n        }\n        \n        int in_degree[26] = {0};\n        int out_degree[26] = {0};\n        int char_used[26] = {0};\n        \n        for (int i = 0; i < n; i++) {\n            out_degree[first[i]]++;\n            in_degree[last[i]]++;\n            char_used[first[i]] = 1;\n            char_used[last[i]] = 1;\n        }\n        \n        int start_count = 0;\n        int end_count = 0;\n        int ok = 1;\n        \n        for (int i = 0; i < 26; i++) {\n            if (out_degree[i] - in_degree[i] == 1) {\n                start_count++;\n            } else if (in_degree[i] - out_degree[i] == 1) {\n                end_count++;\n            } else if (in_degree[i] != out_degree[i]) {\n                ok = 0;\n                break;\n            }\n        }\n        \n        if (ok) {\n            if (!((start_count == 0 && end_count == 0) || (start_count == 1 && end_count == 1))) {\n                ok = 0;\n            }\n        }\n        \n        if (ok) {\n            int adj[26][26] = {0};\n            for (int i = 0; i < n; i++) {\n                adj[first[i]][last[i]] = 1;\n            }\n            \n            int visited[26] = {0};\n            int start_node = -1;\n            for (int i = 0; i < 26; i++) {\n                if (char_used[i]) {\n                    start_node = i;\n                    break;\n                }\n            }\n            \n            int stack[26];\n            int top = 0;\n            stack[top++] = start_node;\n            visited[start_node] = 1;\n            \n            while (top > 0) {\n                int node = stack[--top];\n                for (int i = 0; i < 26; i++) {\n                    if ((adj[node][i] || adj[i][node]) && !visited[i]) {\n                        visited[i] = 1;\n                        stack[top++] = i;\n                    }\n                }\n            }\n            \n            for (int i = 0; i < 26; i++) {\n                if (char_used[i] && !visited[i]) {\n                    ok = 0;\n                    break;\n                }\n            }\n        }\n        \n        printf(\"%s\\n\", ok ? \"OK\" : \"NG\");\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; while (scanf(\"%d\", &n) == 1 && n  int first[10000], last[10000]; for (int i  i++) { scanf(\"%s\", words[i]); first[i] = words[i][0] - 'a'; last[i] = words[i][strlen(words[i]) - 1]  = {0}; for (int i = 0; i < n; i++) { out_degree[first[i]]++; in_degree[last[i]]++; char_used[first[i]] = 1; char_used[last[i]] = 1; } int start_count = 0; int end_count = 0; int ok = 1; for (int i = 0; i < 26; i++) { if (out_degree[i] - in_degree[i] == 1) { start_count++; } else if (in_degree[i] - out_degree[i] == 1) { end_count++;  0; break; } } if (ok) { if (!((start_count == 0 && end_count == 0) || (start_count == 1 &&  = 0; } } if (ok)  for (int i = 0; i < n;  } int visited[26]  = 0; i < 26; i++) { if (char_used[i]) { start_node  int stack[26];  = start_node; visited[start_node] = 1; while  node = stack[--top]; for  < 26; i++) { if ((adj[node][i] || adj[i][node]) && !visited[i]) { visited[i] = 1; stack[top++] = i; } } } for (int i = 0; i < 26; i++) { if (char_used[i] && !visited[i]) { ok = 0; break; } } } printf(\"%s\\n\", ok ?  0; }"], "perturbed_original": ["/*  #include <stdio.h> // Select Below  int n; int dir[26]; // in +1 out -1 int alpha[26];   char con_flag[26];  i,cnt=0; for(i=0;i<26;i++) { if (alpha[i]) { cnt  return(cnt); } int find_first() {  return(-1); } int connected() { int from; from=find_first(); //printf(\"FF=%c\\n\",'a'+from); con_flag[from]=1; return(connected2(from)); } int connected2(int node) { int i; int cnt=1; //printf(\"CN2=%c\\n\",'a'+node); for(i=0;i<26;i++) { if(i==node) continue; if(con[node][i] && !con_flag[i]) { //printf(\"CN2_2=%c\\n\",'a'+i); con_flag[i]=1; cnt += connected2(i); con_flag[i]=0; } } return(cnt); } main() { int i,j; int stt,end,ret,ret1; while(EOF!=scanf(\"%d\",&n) && n) { for(i=0;i<26;i++) { alpha[i]=0; dir[i]=0; con_flag[i]=0; for(j=0;j<26;j++) con[i][j]=0; } for(i=0;i<n;i++) { scanf(\"%s\",buf); stt=buf[0]-'a'; end=buf[strlen(buf)-1]-'a'; dir[stt]++; dir[end]--; alpha[stt]=alpha[end]=1;  ni toujou suru //node to tunagatte iru suu ret1=count_char(); // node no kazu //printf(\"r=%d %d\\n\",ret,ret1);  node ga tunagaruka { printf(\"NG\\n\"); continue; } for(i=0;i<26;i++) //zenbu guuten ka siraberu if(dir[i]) { printf(\"NG\\n\"); goto NEXT; } printf(\"OK\\n\"); NEXT: ; } return(0); }"], "original_ll": -1.4612845182418823, "sampled_ll": -0.3549233376979828, "all_perturbed_sampled_ll": [-1.1641510725021362], "all_perturbed_original_ll": [-1.9262030124664307], "perturbed_sampled_ll": -1.1641510725021362, "perturbed_original_ll": -1.9262030124664307, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tvoid run() {\n\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true) {\n\n\t\t\tint N = Integer.parseInt(in.next());\n\t\t\t\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tList<String> wordList = new ArrayList<String>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tString word = in.next();\n\t\t\t\twordList.add(word.substring(0, 1));\n\t\t\t\twordList.add(word.substring(word.length() - 1, word.length()));\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(wordList);\n\t\t\t\n\t\t\tif(check(wordList)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean check(List<String> wordList) {\n\t\t\n\t\tint count = 1;\n\t\tString word1 = wordList.get(0);\n\t\tfor(int i = 1; i < wordList.size(); i++) {\n\t\t\tString word2 = wordList.get(i);\n\t\t\tif(word1.equals(word2)) { \n\t\t\t\tcount++; \n\t\t\t} else {\n\t\t\t\tif(count % 2 != 0) return false;\n\t\t\t\tword1 = word2;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t\tif(count % 2 != 0) { \n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static Map<Character, List<String>> startMap;\n    static Map<Character, List<String>> endMap;\n    static Set<String> used;\n    static List<String> words;\n    static int n;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            n = sc.nextInt();\n            if (n == 0) break;\n            \n            words = new ArrayList<>();\n            startMap = new HashMap<>();\n            endMap = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                String word = sc.next();\n                words.add(word);\n                \n                char start = word.charAt(0);\n                char end = word.charAt(word.length() - 1);\n                \n                startMap.putIfAbsent(start, new ArrayList<>());\n                startMap.get(start).add(word);\n                \n                endMap.putIfAbsent(end, new ArrayList<>());\n                endMap.get(end).add(word);\n            }\n            \n            boolean found = false;\n            for (String firstWord : words) {\n                used = new HashSet<>();\n                used.add(firstWord);\n                char startChar = firstWord.charAt(0);\n                char endChar = firstWord.charAt(firstWord.length() - 1);\n                \n                if (dfs(endChar, startChar, 1)) {\n                    found = true;\n                    break;\n                }\n            }\n            \n            System.out.println(found ? \"OK\" : \"NG\");\n        }\n        \n        sc.close();\n    }\n    \n    static boolean dfs(char currentEnd, char targetStart, int count) {\n        if (count == n) {\n            return currentEnd == targetStart;\n        }\n        \n        if (!startMap.containsKey(currentEnd)) {\n            return false;\n        }\n        \n        for (String word : startMap.get(currentEnd)) {\n            if (!used.contains(word)) {\n                used.add(word);\n                char nextEnd = word.charAt(word.length() - 1);\n                if (dfs(nextEnd, targetStart, count + 1)) {\n                    return true;\n                }\n                used.remove(word);\n            }\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {  Map<Character, List<String>> endMap; static Set<String> used; static List<String> words;  void main(String[] args) { Scanner sc = new Scanner(System.in); while  if (n == 0) break; words = new ArrayList<>(); startMap = new HashMap<>();  i < n; i++) { String word = sc.next(); words.add(word); char start = word.charAt(0); char end = word.charAt(word.length() - 1); startMap.putIfAbsent(start, new ArrayList<>()); startMap.get(start).add(word); endMap.putIfAbsent(end, new ArrayList<>()); endMap.get(end).add(word); } boolean found = false; for (String firstWord : words)  used.add(firstWord); char startChar = firstWord.charAt(0); char endChar = firstWord.charAt(firstWord.length() - 1); if (dfs(endChar, startChar, 1)) { found = true; break; } } System.out.println(found ? \"OK\" : \"NG\"); } sc.close(); } static  int count)  { return currentEnd == targetStart; } if (!startMap.containsKey(currentEnd)) { return false; } for (String word : startMap.get(currentEnd)) { if (!used.contains(word))  word.charAt(word.length() - 1); if  { return  return false; } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Collections; import  Main { void run() { Scanner in = new Scanner(System.in); while(true)  break; List<String> wordList = new ArrayList<String>(); for(int i = 0; i < N; i++) { String word = in.next(); wordList.add(word.substring(0, 1)); wordList.add(word.substring(word.length() - 1, word.length())); } Collections.sort(wordList); if(check(wordList)) {  }  { int count = 1; String word1 = wordList.get(0);  < wordList.size(); i++) { String word2 = wordList.get(i); if(word1.equals(word2)) { count++; } else { if(count % 2 != 0) return false; word1  } } if(count % 2 != 0) { return false; } else  public static void main(String[] args) { new Main().run(); } }"], "original_ll": -0.5638260841369629, "sampled_ll": -0.3976239264011383, "all_perturbed_sampled_ll": [-1.338382601737976], "all_perturbed_original_ll": [-1.3490180969238281], "perturbed_sampled_ll": -1.338382601737976, "perturbed_original_ll": -1.3490180969238281, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import defaultdict\nwhile True:\n    try:\n        n=input()\n    except SyntaxError:\n        pass\n    if n==0:break\n    dic=defaultdict(int)\n    for i in range(n):\n        w=raw_input()\n        dic[w[0]]+=1\n        dic[w[-1]]+=1\n    if len(set(dic.values()))==1:\n        print \"OK\"\n    else:\n        print \"NG\"", "sampled": "import sys\nfrom collections import defaultdict, deque\n\ndef can_form_shiritori(words):\n    if len(words) == 1:\n        return words[0][0] == words[0][-1]\n    \n    # Build graph of first and last characters\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    out_degree = defaultdict(int)\n    \n    for word in words:\n        first = word[0]\n        last = word[-1]\n        graph[first].append(last)\n        out_degree[first] += 1\n        in_degree[last] += 1\n    \n    # Get all vertices\n    vertices = set(in_degree.keys()) | set(out_degree.keys())\n    \n    # Check if Eulerian circuit exists\n    # For Eulerian circuit: in_degree == out_degree for all vertices\n    for v in vertices:\n        if in_degree[v] != out_degree[v]:\n            return False\n    \n    # Check if graph is connected (considering it as undirected for connectivity)\n    # We need to check if all edges form one connected component\n    if not vertices:\n        return True\n    \n    # Build undirected graph for connectivity check\n    undirected = defaultdict(set)\n    for word in words:\n        first = word[0]\n        last = word[-1]\n        undirected[first].add(last)\n        undirected[last].add(first)\n    \n    # BFS to check connectivity\n    start = next(iter(vertices))\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in undirected[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    # Check if all vertices with non-zero degree are visited\n    return len(visited) == len(vertices)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    words = []\n    for _ in range(n):\n        words.append(input().strip())\n    \n    if can_form_shiritori(words):\n        print(\"OK\")\n    else:\n        print(\"NG\")\n", "perturbed_sampled": ["import sys from collections import defaultdict, deque def can_form_shiritori(words): if len(words) == 1: return words[0][0] == words[0][-1] # Build graph of first and last characters graph = defaultdict(list) in_degree = defaultdict(int) out_degree = defaultdict(int) for word in words: first = word[0] last   Get all  set(out_degree.keys()) # Check if Eulerian circuit  in_degree == out_degree for all vertices for v in  return False # Check if graph is connected (considering   if all edges form one connected component if  Build undirected graph for connectivity check undirected = defaultdict(set) for word in words: first = word[0] last = word[-1] undirected[first].add(last) undirected[last].add(first) # BFS to check connectivity start = next(iter(vertices))  deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in undirected[node]:  visited.add(neighbor) queue.append(neighbor) # Check if all vertices with non-zero degree are visited return len(visited) == len(vertices)   words = [] for _ in range(n): words.append(input().strip()) if can_form_shiritori(words): print(\"OK\") else: print(\"NG\")"], "perturbed_original": ["from collections import defaultdict while True: try: n=input() except SyntaxError: pass if n==0:break dic=defaultdict(int) for i  if len(set(dic.values()))==1: print \"OK\" else: print \"NG\""], "original_ll": -1.2126497030258179, "sampled_ll": -0.755643367767334, "all_perturbed_sampled_ll": [-1.701816439628601], "all_perturbed_original_ll": [-2.648770809173584], "perturbed_sampled_ll": -1.701816439628601, "perturbed_original_ll": -2.648770809173584, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<string.h>\n#include<stdio.h>\nint main()\n{\n\tint h,b,i,j;\n\tchar r[5],a[5];\n\twhile(1){\n\t\tscanf(\"%s %s\",r,a);\n\t\tif(strcmp(r,\"0\")==0&&strcmp(a,\"0\")==0){\n\t\t\tbreak;\n\t\t}\n\t\th=0;\n\t\tb=0;\n\t\tfor(i=0;i<4;i++){\n\t\t\tif(r[i]==a[i]){\n\t\t\t\th++;\n\t\t\t\tr[i]='r';\n\t\t\t\ta[i]='a';\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<4;i++){\n\t\t\tfor(j=0;j<4;j++){\n\t\t\t\tif(r[i]==a[j]){\n\t\t\t\t\tb++;\n\t\t\t\t\tr[i]='r';\n\t\t\t\t\ta[j]='a';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",h,b);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char r[5], a[5];\n    \n    while (1) {\n        scanf(\"%s %s\", r, a);\n        \n        if (strcmp(r, \"0\") == 0 && strcmp(a, \"0\") == 0) {\n            break;\n        }\n        \n        int hit = 0, blow = 0;\n        \n        // Count hits\n        for (int i = 0; i < 4; i++) {\n            if (r[i] == a[i]) {\n                hit++;\n            }\n        }\n        \n        // Count blows\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                if (i != j && r[i] == a[j]) {\n                    blow++;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", hit, blow);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char r[5], a[5]; while (1) { scanf(\"%s %s\", r, a); if (strcmp(r, \"0\") == 0 && strcmp(a, \"0\") == 0) { break;   hits for  < 4; i++) { if (r[i]  } // Count blows for (int i = 0; i < 4; i++) { for  < 4; j++) { if (i != j && r[i] == a[j]) { blow++; }  blow); } return 0; }"], "perturbed_original": ["#include<string.h> #include<stdio.h> int main() { int h,b,i,j; char r[5],a[5]; while(1){ scanf(\"%s %s\",r,a); if(strcmp(r,\"0\")==0&&strcmp(a,\"0\")==0){ break; } h=0; b=0; for(i=0;i<4;i++){ if(r[i]==a[i]){ h++; r[i]='r'; a[i]='a'; } }  a[j]='a'; }  return 0; }"], "original_ll": -0.6297264099121094, "sampled_ll": -0.4211735427379608, "all_perturbed_sampled_ll": [-1.8876298666000366], "all_perturbed_original_ll": [-1.403804063796997], "perturbed_sampled_ll": -1.8876298666000366, "perturbed_original_ll": -1.403804063796997, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\tScanner s=new Scanner (System.in);\n\t\twhile(true){\n\t\t\tString a=s.next();\n\t\t\tString b=s.next();\n\t\t\tif(a.length()==1)System.exit(0);\n\t\t\tint hit=0;\n\t\t\tfor(int i=0;i<4;i++)if(a.charAt(i)==b.charAt(i))hit++;\n\t\t\tint blow=0;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\tif(a.charAt(i)==b.charAt(j)&&i!=j)blow++;\n\t\t\tSystem.out.println(hit+\" \"+blow);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String r = sc.next();\n            String a = sc.next();\n            \n            if (r.equals(\"0\") && a.equals(\"0\")) {\n                break;\n            }\n            \n            int hits = 0;\n            int blows = 0;\n            \n            // Count hits\n            for (int i = 0; i < 4; i++) {\n                if (r.charAt(i) == a.charAt(i)) {\n                    hits++;\n                }\n            }\n            \n            // Count blows\n            for (int i = 0; i < 4; i++) {\n                for (int j = 0; j < 4; j++) {\n                    if (i != j && r.charAt(i) == a.charAt(j)) {\n                        blows++;\n                    }\n                }\n            }\n            \n            System.out.println(hits + \" \" + blows);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class { public<extra_id_1>A a<extra_id_2>C<extra_id_3>a) {<extra_id_4>r =<extra_id_5>; break ;<extra_id_6>r<extra_id_7>)<extra_id_8>a .<extra_id_9>else<extra_id_10>void blows(C<extra_id_11>r.charAt(0)) {<extra_id_23>r.intAt(0);<extra_id_24>if(a.charAt(0) != r.charAt(0)) {<extra_id_25>++ main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { String  = sc.next(); if (r.equals(\"0\") && a.equals(\"0\")) { break; } int hits = 0; int blows  for (int i = 0; i < 4; i++) { if (r.charAt(i) == a.charAt(i))  Count blows for (int i = 0; i < 4; i++)  0; j < 4; j++) {  r.charAt(i) == a.charAt(j)) { blows++; } } } System.out.println(hits + \" \" + blows); } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main{ public static void main(String args[]){ Scanner s=new Scanner (System.in); while(true){ String a=s.next(); String  i=0;i<4;i++) for(int j=0;j<4;j++) if(a.charAt(i)==b.charAt(j)&&i!=j)blow++; System.out.println(hit+\" \"+blow); } } }"], "original_ll": -0.8224539756774902, "sampled_ll": -0.39437612891197205, "all_perturbed_sampled_ll": [-1.831441879272461], "all_perturbed_original_ll": [-1.9012316465377808], "perturbed_sampled_ll": -1.831441879272461, "perturbed_original_ll": -1.9012316465377808, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    a,b=raw_input().split()\n    if a==b==\"0\":break\n    hit,blow=0,0\n    for i,j in zip(a,b):\n        if i==j:\n            hit+=1\n    for i in a:\n        if i in b:\n            blow+=1\n    print hit,blow-hit", "sampled": "import sys\n\nfor line in sys.stdin:\n    parts = line.strip().split()\n    if len(parts) < 2:\n        continue\n    r, a = parts[0], parts[1]\n    if r == '0' and a == '0':\n        break\n    \n    hits = 0\n    blows = 0\n    \n    for i in range(4):\n        if r[i] == a[i]:\n            hits += 1\n    \n    for i in range(4):\n        if r[i] != a[i]:\n            for j in range(4):\n                if i != j and r[i] == a[j] and r[j] != a[j]:\n                    blows += 1\n                    break\n    \n    print(hits, blows)\n", "perturbed_sampled": ["import sys for line in sys.stdin: parts = line.strip().split() if len(parts) < 2: continue r, a =   break hits = 0 blows = 0 for i in range(4): if r[i] == a[i]: hits   for j in range(4): if i != j and r[i] == a[j] and r[j] != a[j]: blows += 1 break print(hits, blows)"], "perturbed_original": [" hit,blow=0,0 for i,j in zip(a,b): if i==j: hit+=1 for i in a: if i in b: blow+=1 print hit,blow-hit"], "original_ll": -1.224846363067627, "sampled_ll": -0.8260875940322876, "all_perturbed_sampled_ll": [-1.8017312288284302], "all_perturbed_original_ll": [-1.9857642650604248], "perturbed_sampled_ll": -1.8017312288284302, "perturbed_original_ll": -1.9857642650604248, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,m,i,p[1000],P;\n//M(int*a){return*1[&a]-*a;}\nM(int*a,int*b){return*b-*a;}\nmain(){\n\tfor(;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",p+i);\n\t\t}\n\t\tqsort(p,n,4,M);\n\t\tP=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(i%m!=m-1)\n\t\t\t\tP+=p[i];\n\t\t}\n\t\tprintf(\"%d\\n\",P);\n\t}\n\texit(0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int n, m;\n    \n    while(1) {\n        scanf(\"%d %d\", &n, &m);\n        if(n == 0 && m == 0) break;\n        \n        int prices[1000];\n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", &prices[i]);\n        }\n        \n        qsort(prices, n, sizeof(int), compare);\n        \n        int total = 0;\n        int count = 0;\n        \n        for(int i = 0; i < n; i++) {\n            count++;\n            if(count == m) {\n                count = 0;\n            } else {\n                total += prices[i];\n            }\n        }\n        \n        printf(\"%d\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" (*(int*)b - *(int*)a); } int main() { int n, m; while(1) { scanf(\"%d %d\", &n, &m); if(n == 0 && m == 0) break; int prices[1000]; for(int i = 0; i < n; i++)  n, sizeof(int), compare); int total = 0; int count = 0; for(int i =  { count++; if(count == m) { count = 0; } else { total += prices[i]; } } printf(\"%d\\n\", total); } return 0; }"], "perturbed_original": ["n,m,i,p[1000],P; //M(int*a){return*1[&a]-*a;}  } qsort(p,n,4,M); P=0; for(i=0;i<n;i++){ if(i%m!=m-1) P+=p[i]; } printf(\"%d\\n\",P); } exit(0); }"], "original_ll": -1.7095175981521606, "sampled_ll": -0.47488319873809814, "all_perturbed_sampled_ll": [-1.2618248462677002], "all_perturbed_original_ll": [-2.8348400592803955], "perturbed_sampled_ll": -1.2618248462677002, "perturbed_original_ll": -2.8348400592803955, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] num = new int[n];\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tnum[i] = scanner.nextInt();\n\t\t\t\tsum += num[i];\n\t\t\t}\n\t\t\tint mod = n % m;\n\t\t\tArrays.sort(num);\n\n\t\t\tfor (int i = mod; i < n; i += m) {\n\t\t\t\tsum -= num[i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) {\n                break;\n            }\n            \n            Integer[] prices = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                prices[i] = sc.nextInt();\n            }\n            \n            // Sort in descending order to maximize discount\n            Arrays.sort(prices, Collections.reverseOrder());\n            \n            int totalCost = 0;\n            \n            // Process full bags of m items\n            for (int i = 0; i < n; i++) {\n                // Every m-th item (0-indexed: m-1, 2m-1, 3m-1, ...) is free\n                if ((i + 1) % m == 0) {\n                    // This item is free (cheapest in its bag)\n                    continue;\n                }\n                totalCost += prices[i];\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  main(String[] args) { Scanner sc  { int n = sc.nextInt(); int  == 0 && m == 0) { break; } Integer[] prices = new Integer[n]; for (int i = 0; i < n;  } // Sort in descending order to maximize discount Arrays.sort(prices, Collections.reverseOrder()); int  full bags of m items for (int i = 0; i < n; i++)  (0-indexed: m-1, 2m-1, 3m-1, ...) is free if  == 0) { // This item is free (cheapest in its bag) continue; } totalCost += prices[i]; } System.out.println(totalCost); } sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String[]  run() throws IOException { Scanner  (true) { int n = scanner.nextInt(); int m = scanner.nextInt(); if ((n | m) == 0) break; int[] num  = 0; for (int i = 0; i < n; i++) { num[i] = scanner.nextInt(); sum += num[i]; } int  = mod; i < n; i += m) { sum -= num[i]; } System.out.println(sum); } } }"], "original_ll": -0.6229953765869141, "sampled_ll": -0.7621711492538452, "all_perturbed_sampled_ll": [-2.2806813716888428], "all_perturbed_original_ll": [-1.8155680894851685], "perturbed_sampled_ll": -2.2806813716888428, "perturbed_original_ll": -1.8155680894851685, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    a = raw_input()\n    print 'a'", "sampled": "import sys\n\ndef solve(n, m, prices):\n    # Sort prices in descending order\n    prices.sort(reverse=True)\n    \n    total = 0\n    i = 0\n    \n    while i < n:\n        # Take up to m items for this bag\n        bag_size = min(m, n - i)\n        \n        if bag_size == m:\n            # Full bag - the cheapest (last) item is free\n            for j in range(bag_size - 1):\n                total += prices[i + j]\n            # prices[i + bag_size - 1] is free (the cheapest in this bag)\n        else:\n            # Incomplete bag - no discount\n            for j in range(bag_size):\n                total += prices[i + j]\n        \n        i += bag_size\n    \n    return total\n\n# Read input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.strip())\n\ni = 0\nwhile i < len(lines):\n    parts = lines[i].split()\n    n, m = int(parts[0]), int(parts[1])\n    \n    if n == 0 and m == 0:\n        break\n    \n    i += 1\n    prices = list(map(int, lines[i].split()))\n    i += 1\n    \n    result = solve(n, m, prices)\n    print(result)\n", "perturbed_sampled": ["import sys def solve(n, m, prices): # Sort prices in descending order prices.sort(reverse=True) total = 0  < n: # Take up to m  = min(m, n - i) if bag_size == m: # Full bag - the cheapest (last) item is free for  j] # prices[i + bag_size - 1] is free (the cheapest in this bag) else: # Incomplete bag - no discount for j  bag_size return total # Read input lines = [] for line in sys.stdin: lines.append(line.strip()) i = 0 while i < len(lines): parts = lines[i].split()  if n == 0 and m == 0: break i  lines[i].split())) i += 1 result = solve(n, m, prices) print(result)"], "perturbed_original": ["while True: a = raw_input() print 'a'"], "original_ll": -3.00580096244812, "sampled_ll": -0.9069462418556213, "all_perturbed_sampled_ll": [-2.352966785430908], "all_perturbed_original_ll": [-3.9289016723632812], "perturbed_sampled_ll": -2.352966785430908, "perturbed_original_ll": -3.9289016723632812, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  int i,j,n,num,prev;\n  char segment[]=\"0000000\";\n  char nums[][8]={\"0111111\",\"0000110\",\"1011011\",\"1001111\",\n\t\t  \"1100110\",\"1101101\",\"1111101\",\"0100111\",\n\t\t  \"1111111\",\"1101111\",\"0000000\"};\n  do{\n    scanf(\"%d\",&n);\n    if(n==-1) break;\n    for(prev=10,i=0;i<n;i++,prev=num){\n      scanf(\"%d\",&num);\n      for(j=0;j<7;j++){\n\tif(nums[prev][j]==nums[num][j]){\n\t  segment[j]='0';\n\t}else{\n\t  segment[j]='1';\n\t}\n      }\n      printf(\"%s\\n\",segment);\n    }\n  }while(1);\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int segments[10] = {\n        0b0111111,  // 0\n        0b0000110,  // 1\n        0b1011011,  // 2\n        0b1001111,  // 3\n        0b1100110,  // 4\n        0b1101101,  // 5\n        0b1111101,  // 6\n        0b0000111,  // 7\n        0b1111111,  // 8\n        0b1101111   // 9\n    };\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != -1) {\n        int current = 0;  // Initial state: all segments off\n        \n        for (int i = 0; i < n; i++) {\n            int digit;\n            scanf(\"%d\", &digit);\n            \n            int target = segments[digit];\n            int signal = current ^ target;  // XOR to get the toggle bits\n            \n            // Print signal in binary (7 bits, from bit 6 to bit 0)\n            for (int j = 6; j >= 0; j--) {\n                printf(\"%d\", (signal >> j) & 1);\n            }\n            printf(\"\\n\");\n            \n            current = target;  // Update current state\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int segments[10] =  // 1 0b1011011, // 2 0b1001111, // 3  5 0b1111101, // 6 0b0000111, // 7 0b1111111, // 8 0b1101111 // 9 }; int  1 && n != -1) { int current = 0; // Initial state: all segments off for (int i = 0; i < n; i++) { int digit; scanf(\"%d\", &digit); int target = segments[digit];   the toggle bits // Print signal in binary (7 bits, from bit 6 to bit 0) for (int j = 6; j >= 0; j--) {   target; // Update current state } } return 0; }"], "perturbed_original": [" char segment[]=\"0000000\"; char nums[][8]={\"0111111\",\"0000110\",\"1011011\",\"1001111\", \"1100110\",\"1101101\",\"1111101\",\"0100111\", \"1111111\",\"1101111\",\"0000000\"}; do{ scanf(\"%d\",&n); if(n==-1) break; for(prev=10,i=0;i<n;i++,prev=num){ scanf(\"%d\",&num); for(j=0;j<7;j++){ if(nums[prev][j]==nums[num][j]){ segment[j]='0'; }else{ segment[j]='1'; } } printf(\"%s\\n\",segment); } }while(1); return 0; }"], "original_ll": -1.0468730926513672, "sampled_ll": -0.5656563639640808, "all_perturbed_sampled_ll": [-1.7883648872375488], "all_perturbed_original_ll": [-1.150918960571289], "perturbed_sampled_ll": -1.7883648872375488, "perturbed_original_ll": -1.150918960571289, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tString [] digit = {\"0111111\",\"0000110\",\"1011011\",\"1001111\",\"1100110\",\n\t\t\t\"1101101\",\"1111101\", \"0100111\",\"1111111\",\"1101111\"};\n\t\n\tprivate void doit() {\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1) break;\n\t\t\tStringBuilder nowstate = new StringBuilder(\"0000000\");\n\t\t\twhile(n-- > 0){\n\t\t\t\tint num = sc.nextInt();\n\t\t\t\tString numstr = digit[num];\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(int i = 0; i < numstr.length(); i++){\n\t\t\t\t\tif(numstr.charAt(i) == nowstate.charAt(i)){\n\t\t\t\t\t\tsb.append(0);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tsb.append(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sb.toString());\n\t\t\t\tnowstate = new StringBuilder(numstr);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Define 7-segment patterns for digits 0-9\n        // Pattern is in order: abcdefg (bits 0-6)\n        int[] patterns = {\n            0b0111111, // 0\n            0b0000110, // 1\n            0b1011011, // 2\n            0b1001111, // 3\n            0b1100110, // 4\n            0b1101101, // 5\n            0b1111101, // 6\n            0b0000111, // 7\n            0b1111111, // 8\n            0b1101111  // 9\n        };\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == -1) break;\n            \n            int currentState = 0; // Initially all segments are off\n            \n            for (int i = 0; i < n; i++) {\n                int digit = sc.nextInt();\n                int targetState = patterns[digit];\n                \n                // Calculate XOR to get the signal needed\n                int signal = currentState ^ targetState;\n                \n                // Output the signal in reverse bit order (gfedcba)\n                StringBuilder sb = new StringBuilder();\n                for (int bit = 6; bit >= 0; bit--) {\n                    sb.append((signal >> bit) & 1);\n                }\n                System.out.println(sb.toString());\n                \n                // Update current state\n                currentState = targetState;\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main {  { Scanner sc = new Scanner(System.in); // Define 7-segment patterns for digits 0-9 // Pattern is in order: abcdefg (bits 0-6) int[]  0 0b0000110, // 1 0b1011011,  0b1100110, // 4 0b1101101, // 5 0b1111101, // 6 0b0000111, // 7 0b1111111,  }; while (true) { int n = sc.nextInt(); if (n == -1) break; int currentState = 0; // Initially all segments are off for (int i = 0; i < n; i++) { int  = patterns[digit]; // Calculate XOR to get the  currentState  signal in reverse bit order (gfedcba) StringBuilder sb = new StringBuilder(); for (int bit = 6; bit >= 0; bit--) { sb.append((signal >> bit)  Update  } } sc.close(); } }"], "perturbed_original": ["import java.util.*;  sc = new Scanner(System.in); String  \"0100111\",\"1111111\",\"1101111\"}; private void doit() { while (true)   nowstate = new StringBuilder(\"0000000\"); while(n-- > 0){ int num = sc.nextInt(); String numstr =  StringBuilder(); for(int i = 0; i < numstr.length(); i++){ if(numstr.charAt(i) == nowstate.charAt(i)){ sb.append(0); } else{ sb.append(1); } } System.out.println(sb.toString()); nowstate =  private void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); } public static void main(String[] args) { new Main().doit(); } }"], "original_ll": -0.9870535731315613, "sampled_ll": -0.5418260097503662, "all_perturbed_sampled_ll": [-1.6988131999969482], "all_perturbed_original_ll": [-1.9519098997116089], "perturbed_sampled_ll": -1.6988131999969482, "perturbed_original_ll": -1.9519098997116089, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# AOJ 0228: Seven Segments\n# Python3 2018.6.25 bal4u\n \np = [[1,1,1,1,1,1,0], [0,1,1,0,0,0,0], [1,1,0,1,1,0,1], [1,1,1,1,0,0,1], [0,1,1,0,0,1,1], \\\n     [1,0,1,1,0,1,1], [1,0,1,1,1,1,1], [1,1,1,0,0,1,0], [1,1,1,1,1,1,1], [1,1,1,1,0,1,1]]\n \nwhile True:\n    n = int(input())\n    if n < 0: break\n    a = [0]*7\n    for i in range(n):\n        d = int(input())\n        ans = ''\n        for j in range(6,-1,-1):\n            k = (a[j] ^ p[d][j]) & 1\n            ans += '1' if k else '0'\n            if k: a[j] = 1-a[j]\n        print(ans)\n", "sampled": "def get_segments(digit):\n    segments = {\n        0: \"0111111\",\n        1: \"0000110\",\n        2: \"1011011\",\n        3: \"1001111\",\n        4: \"1100110\",\n        5: \"1101101\",\n        6: \"1111101\",\n        7: \"0000111\",\n        8: \"1111111\",\n        9: \"1101111\"\n    }\n    return segments[digit]\n\ndef xor_bits(a, b):\n    result = \"\"\n    for i in range(7):\n        if a[i] != b[i]:\n            result += \"1\"\n        else:\n            result += \"0\"\n    return result\n\nwhile True:\n    n = int(input())\n    if n == -1:\n        break\n    \n    current_state = \"0000000\"\n    \n    for _ in range(n):\n        digit = int(input())\n        target_state = get_segments(digit)\n        signal = xor_bits(current_state, target_state)\n        print(signal)\n        current_state = target_state\n", "perturbed_sampled": ["def get_segments(digit): segments  \"0000110\", 2: \"1011011\", 3: \"1001111\", 4: \"1100110\", 5: \"1101101\", 6: \"1111101\", 7: \"0000111\", 8: \"1111111\", 9: \"1101111\" } return segments[digit] def xor_bits(a, b): result = \"\" for i  b[i]: result  True: n = int(input()) if n == -1: break current_state = \"0000000\" for _ in range(n): digit = int(input()) target_state = get_segments(digit) signal = xor_bits(current_state, target_state) print(signal) current_state = target_state"], "perturbed_original": ["# AOJ 0228: Seven Segments # Python3 2018.6.25  [1,1,0,1,1,0,1], [1,1,1,1,0,0,1], [0,1,1,0,0,1,1], \\ [1,0,1,1,0,1,1], [1,0,1,1,1,1,1],  n = int(input()) if n < 0: break a = [0]*7 for i in  = '' for j in range(6,-1,-1): k = (a[j] ^ p[d][j])  if k else '0' if k: a[j] = 1-a[j] print(ans)"], "original_ll": -0.9040422439575195, "sampled_ll": -0.516766369342804, "all_perturbed_sampled_ll": [-1.282434105873108], "all_perturbed_original_ll": [-1.8222875595092773], "perturbed_sampled_ll": -1.282434105873108, "perturbed_original_ll": -1.8222875595092773, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(b,r,g,c,s,t){for(;~scanf(\"%d%d%d%d%d%d\",&b,&r,&g,&c,&s,&t)&&t;printf(\"%d\\n\",b*95+r*63+g*7+c*2+s*3-t*3+100));}", "sampled": "#include <stdio.h>\n\nint main() {\n    int b, r, g, c, s, t;\n    \n    while (1) {\n        scanf(\"%d %d %d %d %d %d\", &b, &r, &g, &c, &s, &t);\n        \n        if (b == 0 && r == 0 && g == 0 && c == 0 && s == 0 && t == 0) {\n            break;\n        }\n        \n        int medals = 100;\n        \n        // Big bonus games: 5 games each, 2 medals in, 15 medals out per game\n        int big_bonus_games = b * 5;\n        medals += big_bonus_games * (15 - 2);\n        \n        // Regular bonus games: 3 games each, 2 medals in, 15 medals out per game\n        int regular_bonus_games = r * 3;\n        medals += regular_bonus_games * (15 - 2);\n        \n        // Total bonus games\n        int bonus_games = big_bonus_games + regular_bonus_games;\n        \n        // Normal games\n        int normal_games = t - bonus_games;\n        \n        // For normal games, we need to account for:\n        // - Games that triggered bonuses (b + r games, cost 3 medals each, no payout from trigger itself)\n        // - Games with grapes (g games, cost 3 medals, get 15 medals)\n        // - Games with cherries (c games, cost 3 medals, get 3 medals)\n        // - Games with stars (s games, cost 3 medals first time, get 0 medals but next game is free)\n        // - Games that got nothing\n        \n        // Star games: first star costs 3, gets 0, then next game is free (costs 0)\n        // So s stars means s games cost 3 medals and s games cost 0 medals\n        // But we need to be careful about counting\n        \n        // Actually, let's think differently:\n        // - b games triggered big bonus: cost 3, no payout\n        // - r games triggered regular bonus: cost 3, no payout\n        // - g games got grapes: cost 3, payout 15\n        // - c games got cherries: cost 3, payout 3\n        // - s games got stars: cost 3, payout 0, but next game is free\n        // - remaining games got nothing: cost 3, payout 0\n        \n        // Total normal games played\n        // Some of these are free (after stars)\n        // Games that cost medals: normal_games - s (since s games following a star are free)\n        \n        medals -= (normal_games - s) * 3;  // Cost of normal games (excluding free games after stars)\n        medals += b * 0;  // Big bonus triggers give no payout\n        medals += r * 0;  // Regular bonus triggers give no payout\n        medals += g * 15; // Grape payouts in normal games\n        medals += c * 3;  // Cherry payouts in normal games\n        medals += s * 0;  // Star payouts (none)\n        \n        printf(\"%d\\n\", medals);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int b, r, g, c, s,  %d %d %d %d %d\", &b, &r, &g, &c, &s, &t); if (b == 0 && r ==  && c == 0 && s == 0 && t == 0) { break; } int medals = 100; // Big bonus games: 5 games each, 2 medals in, 15 medals out per game int big_bonus_games  += big_bonus_games * (15 - 2); // Regular bonus games: 3 games each, 2 medals in, 15 medals  = r * 3; medals += regular_bonus_games * (15 - 2); // Total bonus games  int normal_games = t - bonus_games; // For normal games, we need  Games that triggered bonuses (b + r games, cost 3 medals each,  // - Games with grapes (g games, cost 3 medals, get 15 medals) // - Games with cherries (c games, cost 3 medals, get 3 medals) // - Games with stars (s games, cost 3 medals first time, get 0 medals but next game  that got nothing // Star games: first star costs 3, gets 0, then next  // So   // But we need to be careful about counting // Actually, let's think differently: // - b games triggered big bonus: cost 3,  games  no payout // - g games got grapes: cost 3, payout 15 // - c games got cherries: cost 3, payout 3 //  cost 3, payout 0, but next game is free // - remaining games got nothing: cost 3, payout  these are free  cost  s games following a star are free) medals -= (normal_games - s) *  after stars) medals += b * 0;  no payout medals += r  triggers give no payout medals += g * 15; // Grape payouts in normal games medals += c * 3; // Cherry payouts in normal games  // Star payouts (none) printf(\"%d\\n\", medals); } return 0; }"], "perturbed_original": ["main(b,r,g,c,s,t){for(;~scanf(\"%d%d%d%d%d%d\",&b,&r,&g,&c,&s,&t)&&t;printf(\"%d\\n\",b*95+r*63+g*7+c*2+s*3-t*3+100));}"], "original_ll": -2.098954439163208, "sampled_ll": -1.202185034751892, "all_perturbed_sampled_ll": [-2.37532901763916], "all_perturbed_original_ll": [-2.098954439163208], "perturbed_sampled_ll": -2.37532901763916, "perturbed_original_ll": -2.098954439163208, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        for(;;) {\n         int b=sc.nextInt()*5,r=sc.nextInt()*3,g=sc.nextInt(),c=sc.nextInt(),s=sc.nextInt(),t=sc.nextInt();\n         if((b|r|g|c|s|t)==0) {\n             break;\n         }\n         System.out.println(100+b+b*18+r+r*20+g*7+c*2-(t-s)*3);\n        }\n    }\n}\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int b = sc.nextInt();\n            int r = sc.nextInt();\n            int g = sc.nextInt();\n            int c = sc.nextInt();\n            int s = sc.nextInt();\n            int t = sc.nextInt();\n            \n            if (b == 0 && r == 0 && g == 0 && c == 0 && s == 0 && t == 0) {\n                break;\n            }\n            \n            int medals = 100;\n            \n            // Big bonus games: 5 games each, spend 2 medals, get 15 medals\n            int bigBonusGames = b * 5;\n            medals += bigBonusGames * (15 - 2);\n            \n            // Regular bonus games: 3 games each, spend 2 medals, get 15 medals\n            int regularBonusGames = r * 3;\n            medals += regularBonusGames * (15 - 2);\n            \n            // Total bonus games\n            int totalBonusGames = bigBonusGames + regularBonusGames;\n            \n            // Normal games\n            int normalGames = t - totalBonusGames;\n            \n            // Calculate medals from normal games\n            // Grape in normal game: spend 3, get 15, net +12\n            medals += g * (15 - 3);\n            \n            // Cherry in normal game: spend 3, get 8, net +5\n            medals += c * (8 - 3);\n            \n            // Star in normal game: spend 3, get 0, but next game is free\n            // Net effect: -3 for star game, +3 for free game = 0\n            // But we need to count that star games are part of normal games\n            \n            // Games that cost 3 medals (normal games minus free games from stars)\n            int paidNormalGames = normalGames - s;\n            \n            // Games where nothing special happened\n            int noWinGames = paidNormalGames - g - c - s;\n            \n            // These games cost 3 medals with no return\n            medals -= noWinGames * 3;\n            \n            System.out.println(medals);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int b = sc.nextInt(); int r = sc.nextInt(); int g = sc.nextInt(); int c = sc.nextInt(); int s = sc.nextInt(); int t = sc.nextInt(); if (b == 0 && r == 0 && g ==  && s == 0 && t == 0) { break; } int medals = 100; // Big bonus games: 5 games each, spend 2 medals, get 15 medals int bigBonusGames   2); // Regular  15 medals int regularBonusGames = r * 3; medals += regularBonusGames * (15  games int totalBonusGames = bigBonusGames +  totalBonusGames; // Calculate medals from normal games // Grape in normal game: spend 3, get 15, net +12 medals += g * (15 - 3); // Cherry in normal game: spend 3,  += c * (8 - 3);  but next game   for free game = 0 // But  star games are part of normal games // Games that cost 3 medals (normal games minus free games from stars) int paidNormalGames  Games where nothing special happened int noWinGames = paidNormalGames - g - c - s; // These games cost 3 medals with no return medals -= noWinGames * 3; System.out.println(medals); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); for(;;) { int b=sc.nextInt()*5,r=sc.nextInt()*3,g=sc.nextInt(),c=sc.nextInt(),s=sc.nextInt(),t=sc.nextInt(); if((b|r|g|c|s|t)==0) {  }"], "original_ll": -1.6344847679138184, "sampled_ll": -1.0583350658416748, "all_perturbed_sampled_ll": [-2.374286651611328], "all_perturbed_original_ll": [-1.7252612113952637], "perturbed_sampled_ll": -2.374286651611328, "perturbed_original_ll": -1.7252612113952637, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    b,r,g,c,s,t=map(int,input().split())\n    if [b,r,g,c,s,t].count(0)==6:break\n    print(100+(b+r)*15+g*7+c*2+(b*5+r*3)*13-(t-(s+b*5+r*3))*3)", "sampled": "while True:\n    line = input().split()\n    b, r, g, c, s, t = map(int, line)\n    \n    if b == 0 and r == 0 and g == 0 and c == 0 and s == 0 and t == 0:\n        break\n    \n    medals = 100\n    \n    # Big bonus games: 5 games each\n    big_bonus_games = b * 5\n    # Regular bonus games: 3 games each\n    regular_bonus_games = r * 3\n    # Total bonus games\n    bonus_games = big_bonus_games + regular_bonus_games\n    # Normal games\n    normal_games = t - bonus_games\n    \n    # Bonus games: spend 2, get 15 (net +13 per game)\n    medals += bonus_games * (15 - 2)\n    \n    # Normal games cost 3 medals each\n    medals -= normal_games * 3\n    \n    # Grape in normal games: get 15\n    medals += g * 15\n    \n    # Cherry in normal games: get 8\n    medals += c * 8\n    \n    # Star games are free (refund 3 medals)\n    medals += s * 3\n    \n    print(medals)\n", "perturbed_sampled": ["while True: line  c, s,  b  0  t == 0: break medals = 100 # Big bonus games: 5 games each big_bonus_games = b * 5 # Regular bonus games: 3 games each regular_bonus_games = r * 3 # Total bonus games bonus_games = big_bonus_games  normal_games = t  spend 2, get 15 (net +13 per game) medals += bonus_games * (15 - 2) # Normal games cost 3 medals each medals -=  in normal games: get 15 medals += g * 15 # Cherry in normal games: get 8 medals += c * 8 # Star games are free (refund 3 medals) medals += s * 3 print(medals)"], "perturbed_original": ["while 1: b,r,g,c,s,t=map(int,input().split()) if [b,r,g,c,s,t].count(0)==6:break print(100+(b+r)*15+g*7+c*2+(b*5+r*3)*13-(t-(s+b*5+r*3))*3)"], "original_ll": -1.8500282764434814, "sampled_ll": -1.3422671556472778, "all_perturbed_sampled_ll": [-2.7348103523254395], "all_perturbed_original_ll": [-2.102109670639038], "perturbed_sampled_ll": -2.7348103523254395, "perturbed_original_ll": -2.102109670639038, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "short*p,v[][99];main(c,n,m,i,y){for(;m=scanf(\"%d %[^\\n] %[^\\n]\",&n,v,v+1)*n;printf(m>n?\"NA\\n\":\"%d\\n\",m))for(i=2;i--;m=c)for(c=0,y=n;y>1&c<m;y+=y==n|*p&2?2:*p&p[-1]&1?0:!++c-1)p=--y+v[c+i&1];}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 101\n#define INF 999999\n\nint n;\nint a[MAX_N], b[MAX_N];\nint ladder_top[2][MAX_N];\nint dist[2][MAX_N];\n\nint process_position(int building, int floor) {\n    if (floor > n) return floor;\n    \n    if (a[floor] == 0 || b[floor] == 0) {\n        int wall = (building == 0) ? a[floor] : b[floor];\n        if (wall == 0) return floor;\n        else if (wall == 1) return ladder_top[building][floor];\n        else return floor;\n    }\n    \n    int wall = (building == 0) ? a[floor] : b[floor];\n    \n    if (wall == 0) {\n        return floor;\n    } else if (wall == 1) {\n        return ladder_top[building][floor];\n    } else {\n        for (int f = floor - 1; f >= 1; f--) {\n            int w = (building == 0) ? a[f] : b[f];\n            if (w == 0) return f;\n            if (w == 1) return ladder_top[building][f];\n        }\n        return 1;\n    }\n}\n\nint main() {\n    while (scanf(\"%d\", &n) && n != 0) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &b[i]);\n        }\n        \n        for (int building = 0; building < 2; building++) {\n            for (int i = 1; i <= n; i++) {\n                int wall = (building == 0) ? a[i] : b[i];\n                if (wall == 1) {\n                    int top = i;\n                    while (top < n) {\n                        int next_wall = (building == 0) ? a[top + 1] : b[top + 1];\n                        if (next_wall == 1) top++;\n                        else break;\n                    }\n                    ladder_top[building][i] = top;\n                } else {\n                    ladder_top[building][i] = i;\n                }\n            }\n        }\n        \n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j <= n; j++) {\n                dist[i][j] = INF;\n            }\n        }\n        \n        int queue[MAX_N * 2][2];\n        int front = 0, rear = 0;\n        \n        int pos0 = process_position(0, 1);\n        int pos1 = process_position(1, 1);\n        \n        dist[0][pos0] = 1;\n        queue[rear][0] = 0;\n        queue[rear][1] = pos0;\n        rear++;\n        \n        dist[1][pos1] = 1;\n        queue[rear][0] = 1;\n        queue[rear][1] = pos1;\n        rear++;\n        \n        while (front < rear) {\n            int cur_building = queue[front][0];\n            int cur_floor = queue[front][1];\n            front++;\n            \n            int other_building = 1 - cur_building;\n            \n            for (int delta = 0; delta <= 2; delta++) {\n                int next_floor = cur_floor + delta;\n                int final_floor = process_position(other_building, next_floor);\n                \n                if (final_floor >= 1 && final_floor <= n) {\n                    if (dist[other_building][final_floor] > dist[cur_building][cur_floor] + 1) {\n                        dist[other_building][final_floor] = dist[cur_building][cur_floor] + 1;\n                        queue[rear][0] = other_building;\n                        queue[rear][1] = final_floor;\n                        rear++;\n                    }\n                }\n            }\n        }\n        \n        int result = INF;\n        if (dist[0][n] < result) result = dist[0][n];\n        if (dist[1][n] < result) result = dist[1][n];\n        \n        if (result == INF) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdbool.h> #define MAX_N 101 #define INF 999999 int n; int  dist[2][MAX_N]; int  if  if (a[floor] == 0 || b[floor]  = (building == 0) ? a[floor] :  return floor; else if (wall == 1) return  int wall = (building == 0) ? a[floor] : b[floor]; if (wall == 0) { return floor; } else if (wall == 1) { return ladder_top[building][floor]; } else { for (int f = floor - 1; f >= 1; f--) { int w = (building == 0) ?  == 0) return f; if (w == 1) return ladder_top[building][f]; } return 1; } } int main() { while (scanf(\"%d\", &n) && n != 0) { for  <= n; i++) { scanf(\"%d\", &a[i]); } for (int i = 1; i <= n; i++) { scanf(\"%d\", &b[i]); } for (int building = 0; building < 2; building++) { for (int i = 1; i <= n; i++) { int  ? a[i]  = i; while (top < n) { int next_wall = (building == 0) ? a[top + 1] : b[top + 1]; if (next_wall == 1) top++; else break; } ladder_top[building][i] = top; } else { ladder_top[building][i] = i; } } } for (int i = 0; i < 2; i++) {  j <= n; j++) { dist[i][j] = INF; } }  front = 0, rear = 0; int pos0 = process_position(0, 1); int pos1 = process_position(1, 1); dist[0][pos0] = 1; queue[rear][0] =  dist[1][pos1] = 1; queue[rear][0]   queue[front][0]; int cur_floor = queue[front][1]; front++; int other_building  (int delta = 0; delta <=  int final_floor = process_position(other_building, next_floor); if (final_floor >= 1 && final_floor   dist[other_building][final_floor] =  rear++;  result = INF; if (dist[0][n] < result) result = dist[0][n]; if (dist[1][n] < result) result = dist[1][n]; if (result == INF) { printf(\"NA\\n\"); } else { printf(\"%d\\n\", result); } } return 0; }"], "perturbed_original": ["short*p,v[][99];main(c,n,m,i,y){for(;m=scanf(\"%d %[^\\n] %[^\\n]\",&n,v,v+1)*n;printf(m>n?\"NA\\n\":\"%d\\n\",m))for(i=2;i--;m=c)for(c=0,y=n;y>1&c<m;y+=y==n|*p&2?2:*p&p[-1]&1?0:!++c-1)p=--y+v[c+i&1];}"], "original_ll": -3.373260974884033, "sampled_ll": -0.4251067638397217, "all_perturbed_sampled_ll": [-1.3092129230499268], "all_perturbed_original_ll": [-3.373260974884033], "perturbed_sampled_ll": -1.3092129230499268, "perturbed_original_ll": -3.373260974884033, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    void run() {\n        for (;;) {\n            // 1 \u884c\u76ee \u30d3\u30eb\u306e\u968e\u6570 n(\u6574\u6570)\n            // 2 \u884c\u76ee 1 \u3064\u76ee\u306e\u30d3\u30eb a \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 a1 a2 ... an(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a)\n            // \u5404 ai \u306f\u3001i \u968e\u76ee\u306e\u58c1\u306e\u60c5\u5831\u3092\u8868\u3057\u3001\u610f\u5473\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3067\u3059\u3002\n            // 0:\u666e\u901a\u306e\u58c1\n            // 1:\u306f\u3057\u3054(i \u968e\u3068 i+1 \u968e\u306b\u307e\u305f\u304c\u308b)\n            // 2:\u3059\u3079\u308b\u58c1\n            // 3 \u884c\u76ee 2 \u3064\u76ee\u306e\u30d3\u30eb b \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 b1 b2 ... bn(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a)\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int fs[][] = new int[2][n];\n            for (int i = 0; i < n; i++) {\n                fs[0][i] = sc.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                fs[1][i] = sc.nextInt();\n            }\n            Queue<Data> q = new LinkedList<Data>();\n            int sfa = 0;\n            int sfb = 0;\n            if (fs[0][0] == 1)\n                while (sfa + 1 < n && fs[0][sfa + 1] == 1)\n                    sfa++;\n            if (fs[1][0] == 1)\n                while (sfb + 1 < n && fs[1][sfb + 1] == 1)\n                    sfb++;\n            q.add(new Data(0, sfa, 0));\n            q.add(new Data(1, sfb, 0));\n            Set<String> set = new HashSet<String>();\n            boolean na = true;\n            while (!q.isEmpty()) {\n                Data d = q.poll();\n                int b = d.b;\n                int f = d.f;\n                if (set.contains(b + \" \" + f))\n                    continue;\n                set.add(b + \" \" + f);\n                int t = d.t;\n                if (f == n - 1 && fs[b][n - 1] != 2) {\n                    System.out.println(t);\n                    na = false;\n                    break;\n                }\n                int nb = b ^ 1;\n                for (int i = 0; i < 3; i++) {\n                    // \u5411\u304b\u3044\u5074\u306e\u30d3\u30eb\u3078\u30b8\u30e3\u30f3\u30d7\u3059\u308b\u3068\u304d\u306b\u306f\u3001\n                    // \u540c\u3058\u968e\u30fb1\u3064\u4e0a\u306e\u968e\u30fb2 \u3064\u4e0a\u306e\u968e\u306e\u3001\u3044\u305a\u308c\u304b\u306b\u98db\u3073\u79fb\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n                    if (i + f >= n)\n                        continue;\n                    int nf = f + i;\n                    switch (fs[nb][i + f]) {\n                    case 0:\n                        q.add(new Data(nb, nf, t + 1));\n                        break;\n                    case 1:\n                        while (nf + 1 < n && fs[nb][nf + 1] == 1)\n                            nf++;\n                        q.add(new Data(nb, nf, t + 1));\n                        break;\n                    case 2:\n                        while (fs[nb][nf] == 2)\n                            nf--;\n                        q.add(new Data(nb, nf, t + 1));\n                        break;\n                    }\n                }\n\n            }\n            if (na)\n                System.out.println(\"NA\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n\nclass Data {\n    int b;\n    int f;\n    int t;\n\n    Data(int b, int f, int t) {\n        this.b = b;\n        this.f = f;\n        this.t = t;\n    }\n\n    public String toString() {\n        return b + \" \" + f + \" \" + t;\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class State {\n        int building; // 0 or 1\n        int floor;\n        int jumps;\n        \n        State(int building, int floor, int jumps) {\n            this.building = building;\n            this.floor = floor;\n            this.jumps = jumps;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] a = new int[n + 1];\n            int[] b = new int[n + 1];\n            \n            for (int i = 1; i <= n; i++) {\n                a[i] = sc.nextInt();\n            }\n            for (int i = 1; i <= n; i++) {\n                b[i] = sc.nextInt();\n            }\n            \n            int result = solve(n, a, b);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        sc.close();\n    }\n    \n    static int solve(int n, int[] a, int[] b) {\n        int[][] walls = {a, b};\n        boolean[][] visited = new boolean[2][n + 1];\n        Queue<State> queue = new LinkedList<>();\n        \n        // Start from floor 1 of either building\n        int floor0 = processFloor(0, 1, walls, n);\n        int floor1 = processFloor(1, 1, walls, n);\n        \n        if (floor0 != -1) {\n            queue.add(new State(0, floor0, 0));\n            visited[0][floor0] = true;\n        }\n        if (floor1 != -1) {\n            queue.add(new State(1, floor1, 0));\n            visited[1][floor1] = true;\n        }\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.floor == n) {\n                return curr.jumps;\n            }\n            \n            int otherBuilding = 1 - curr.building;\n            \n            // Jump to same floor, +1, or +2\n            for (int delta = 0; delta <= 2; delta++) {\n                int targetFloor = curr.floor + delta;\n                if (targetFloor > n) continue;\n                \n                int finalFloor = processFloor(otherBuilding, targetFloor, walls, n);\n                \n                if (finalFloor != -1 && !visited[otherBuilding][finalFloor]) {\n                    visited[otherBuilding][finalFloor] = true;\n                    queue.add(new State(otherBuilding, finalFloor, curr.jumps + 1));\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static int processFloor(int building, int floor, int[][] walls, int n) {\n        int[] wall = walls[building];\n        \n        if (wall[floor] == 0) {\n            return floor;\n        } else if (wall[floor] == 1) {\n            // Climb ladder to the top\n            int top = floor;\n            while (top < n && wall[top] == 1) {\n                top++;\n            }\n            return top;\n        } else { // wall[floor] == 2\n            // Slide down\n            int slideFloor = floor;\n            while (slideFloor > 1) {\n                slideFloor--;\n                if (wall[slideFloor] == 0) {\n                    return slideFloor;\n                } else if (wall[slideFloor] == 1) {\n                    // Find top of ladder\n                    int top = slideFloor;\n                    while (top < n && wall[top] == 1) {\n                        top++;\n                    }\n                    return top;\n                }\n                // If wall[slideFloor] == 2, continue sliding\n            }\n            // Slid all the way to floor 1 or below, cannot start here\n            return -1;\n        }\n    }\n}\n", "perturbed_sampled": [" { static class State { int building; // 0 or  State(int building, int floor, int jumps)  = floor; this.jumps = jumps; } } public static void main(String[] args) { Scanner sc = new  n = sc.nextInt(); if (n == 0) break; int[] a = new int[n +  int[n + 1]; for (int i = 1; i <= n; i++) { a[i] = sc.nextInt(); } for (int i = 1; i <= n; i++) { b[i] = sc.nextInt(); } int result = solve(n, a, b); if (result == -1) { System.out.println(\"NA\"); } else { System.out.println(result); }  solve(int n, int[] a, int[] b) { int[][]  visited = new  = new LinkedList<>(); // Start from floor 1 of either building int floor0 = processFloor(0, 1, walls, n); int floor1 = processFloor(1, 1, walls, n); if (floor0 != -1)  visited[0][floor0] = true; } if (floor1 != -1) { queue.add(new State(1, floor1, 0)); visited[1][floor1] = true; } while (!queue.isEmpty())  if (curr.floor == n) { return curr.jumps; } int  // Jump to same floor, +1, or +2 for (int delta = 0; delta <= 2; delta++) { int targetFloor = curr.floor +  continue; int finalFloor = processFloor(otherBuilding, targetFloor, walls,  && !visited[otherBuilding][finalFloor]) { visited[otherBuilding][finalFloor] = true; queue.add(new State(otherBuilding, finalFloor, curr.jumps + 1)); } } } return -1;  int floor, int[][] walls, int n) { int[] wall = walls[building]; if (wall[floor] == 0) { return floor; } else  // Climb ladder to  floor; while  else { // wall[floor] == 2 // Slide down int slideFloor =   } else if (wall[slideFloor] == 1) { // Find top of ladder int top =   top++; } return top; } // If wall[slideFloor] == 2, continue sliding } // Slid all the way to floor 1 or below, cannot start here return -1; } } }"], "perturbed_original": ["import java.util.HashSet; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; import java.util.Set; public class Main { Scanner sc = new Scanner(System.in); void run() { for (;;)  1 \u3064\u76ee\u306e\u30d3\u30eb a \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 a1 a2 ... an(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a) // \u5404 ai \u306f\u3001i \u968e\u76ee\u306e\u58c1\u306e\u60c5\u5831\u3092\u8868\u3057\u3001\u610f\u5473\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3067\u3059\u3002 // 0:\u666e\u901a\u306e\u58c1 // 1:\u306f\u3057\u3054(i \u968e\u3068 i+1 \u968e\u306b\u307e\u305f\u304c\u308b) // 2:\u3059\u3079\u308b\u58c1 // 3 \u884c\u76ee 2 \u3064\u76ee\u306e\u30d3\u30eb b \u306e 1  ... bn(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a) int n = sc.nextInt(); if (n  =  = 0;  fs[0][i] = sc.nextInt(); } for (int i = 0; i < n; i++) { fs[1][i] = sc.nextInt(); } Queue<Data> q = new LinkedList<Data>(); int sfa = 0; int sfb = 0;   && fs[0][sfa + 1] == 1) sfa++; if (fs[1][0] == 1) while (sfb + 1 < n && fs[1][sfb + 1] == 1) sfb++; q.add(new Data(0, sfa, 0)); q.add(new Data(1, sfb, 0)); Set<String> set = new HashSet<String>();  (!q.isEmpty()) { Data d = q.poll(); int b = d.b; int   \" + f); int t = d.t;  1 && fs[b][n - 1] != 2) { System.out.println(t); na = false; break; } int nb = b ^ 1; for (int i = 0; i < 3; i++) {  if (i + f >= n) continue; int nf = f + i; switch (fs[nb][i + f])  nf, t + 1)); break; case 1:  n && fs[nb][nf + 1] == 1) nf++; q.add(new Data(nb, nf,  2: while (fs[nb][nf] == 2) nf--; q.add(new Data(nb, nf, t + 1)); break; } } } if (na)   Data { int b; int f; int t; Data(int b, int f, int t) { this.b = b; this.f = f;  String toString() { return b + \" \"  + t; } }"], "original_ll": -0.8344951868057251, "sampled_ll": -0.5269590020179749, "all_perturbed_sampled_ll": [-1.6858645677566528], "all_perturbed_original_ll": [-1.6336133480072021], "perturbed_sampled_ll": -1.6858645677566528, "perturbed_original_ll": -1.6336133480072021, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import Queue\nwhile True:\n    n = input()\n    if n==0:\n        break\n    a = []\n    nxt = [range(n) for i in xrange(2)]\n    for i in xrange(2):\n        a.append(map(int, raw_input().split()))\n    for i in xrange(2):\n        back = 0\n        for j in xrange(n):\n            if a[i][j]==2:\n                nxt[i][j] = back\n            else:\n                back = j\n        forw = n-1\n        for j in xrange(n-1,-1,-1):\n            if a[i][j]==1:\n                nxt[i][j] = forw\n            else:\n                forw = j-1\n    cost = [[10**9] * n for i in xrange(2)]\n    que = Queue.PriorityQueue()\n    que.put((0, 0, 0))\n    que.put((0, 1, 0))\n    ans = -1\n    while not que.empty():\n        co, sd, st = que.get()\n        if st==n-1:\n            ans = co\n            break\n        if cost[sd][st] < co:\n            continue\n        for i in xrange(3 if st+2<n else 2):\n            step = nxt[sd^1][st+i]\n            if co+1 < cost[sd^1][step]:\n                cost[sd^1][step] = co+1\n                que.put((co+1, sd^1, step))\n    print \"NA\" if ans==-1 else ans", "sampled": "from collections import deque\n\ndef solve(n, a, b):\n    # Preprocess ladders - find top of each ladder\n    def find_ladder_top(walls):\n        tops = list(range(n))\n        i = 0\n        while i < n:\n            if walls[i] == 1:\n                j = i\n                while j < n and walls[j] == 1:\n                    j += 1\n                for k in range(i, j):\n                    tops[k] = j - 1\n                i = j\n            else:\n                i += 1\n        return tops\n    \n    ladder_tops_a = find_ladder_top(a)\n    ladder_tops_b = find_ladder_top(b)\n    \n    # Function to find where we end up after landing on floor i of building side\n    def land_on(floor, side):\n        if side == 0:\n            walls = a\n            ladder_tops = ladder_tops_a\n        else:\n            walls = b\n            ladder_tops = ladder_tops_b\n        \n        if walls[floor] == 0:  # Normal wall\n            return floor\n        elif walls[floor] == 1:  # Ladder\n            return ladder_tops[floor]\n        else:  # walls[floor] == 2, sliding wall\n            # Slide down to normal wall or top of ladder\n            for f in range(floor - 1, -1, -1):\n                if walls[f] == 0:\n                    return f\n                elif walls[f] == 1:\n                    return ladder_tops[f]\n            return -1  # Should not happen as floor 0 is not sliding\n    \n    # BFS\n    queue = deque()\n    visited = set()\n    \n    # Start from floor 0 of either building\n    start_a = land_on(0, 0)\n    start_b = land_on(0, 1)\n    \n    if start_a >= 0:\n        queue.append((0, start_a, 0))  # (side, floor, jumps)\n        visited.add((0, start_a))\n    if start_b >= 0:\n        queue.append((1, start_b, 0))\n        visited.add((1, start_b))\n    \n    while queue:\n        side, floor, jumps = queue.popleft()\n        \n        # Check if we can reach rooftop\n        if floor == n - 1:\n            return jumps\n        \n        # Try jumping to other building\n        other_side = 1 - side\n        for delta in [0, 1, 2]:\n            next_floor = floor + delta\n            if next_floor < n:\n                final_floor = land_on(next_floor, other_side)\n                if final_floor >= 0 and (other_side, final_floor) not in visited:\n                    visited.add((other_side, final_floor))\n                    queue.append((other_side, final_floor, jumps + 1))\n    \n    return \"NA\"\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    result = solve(n, a, b)\n    print(result)\n", "perturbed_sampled": ["from collections import  #  of each ladder def  = 0 while i < n: if walls[i] == 1: j  n and walls[j] ==  k in range(i, j): tops[k] = j -  i += 1 return tops ladder_tops_a = find_ladder_top(a) ladder_tops_b = find_ladder_top(b) # Function to find where we end up after landing on floor i of building side  == 0: walls = a ladder_tops = ladder_tops_a else: walls = b ladder_tops = ladder_tops_b if walls[floor] == 0: # Normal wall return floor elif walls[floor] == 1: #  walls[floor] == 2, sliding wall # Slide down to normal wall or  in range(floor - 1, -1, -1): if walls[f] == 0: return f elif walls[f] == 1: return ladder_tops[f] return -1 # Should not happen as floor 0 is not sliding # BFS queue = deque() visited = set() # Start from floor 0 of either building start_a = land_on(0, 0) start_b = land_on(0, 1) if start_a >= 0: queue.append((0, start_a, 0)) # (side, floor, jumps) visited.add((0, start_a)) if start_b >= 0: queue.append((1, start_b,  side, floor, jumps =  floor ==  # Try jumping to other  side for delta in [0, 1, 2]: next_floor = floor + delta  =  0 and (other_side, final_floor) not in visited:  while True: n = int(input()) if n == 0: break a = list(map(int, input().split())) b = list(map(int, input().split())) result = solve(n, a, b) print(result)"], "perturbed_original": ["import Queue while True: n = input() if n==0: break a = [] nxt = [range(n) for i in xrange(2)] for i in xrange(2): a.append(map(int, raw_input().split())) for i in xrange(2): back = 0 for j in xrange(n): if a[i][j]==2: nxt[i][j] = back else: back = j forw = n-1 for j in xrange(n-1,-1,-1): if a[i][j]==1: nxt[i][j] = forw else: forw  * n for i in xrange(2)] que = Queue.PriorityQueue()  0)) ans = -1 while not   co break if cost[sd][st] < co: continue for i   = co+1 que.put((co+1, sd^1, step)) print \"NA\" if ans==-1 else ans"], "original_ll": -0.9225606322288513, "sampled_ll": -0.7288434505462646, "all_perturbed_sampled_ll": [-2.2029812335968018], "all_perturbed_original_ll": [-2.0734145641326904], "perturbed_sampled_ll": -2.2029812335968018, "perturbed_original_ll": -2.0734145641326904, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "m[100],a[100],b[100],i,j,M,B;main(n){for(;scanf(\"%d\",&n)*n;puts(B?\"NG\":\"OK\")){for(i=n;i--;B=0)scanf(\"%d%d%d\",m+i,a+i,b+i);for(i=n;i--;B|=M>150)for(M=0,j=n;j--;)M+=a[i]>=a[j]&&a[i]<b[j]?m[j]:0;}}\nm[100],a[100],b[100],i,j,M,B;", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int time;\n    int weight;\n    int type; // 0 for start, 1 for end\n} Event;\n\nint compare(const void *a, const void *b) {\n    Event *ea = (Event *)a;\n    Event *eb = (Event *)b;\n    if (ea->time != eb->time) {\n        return ea->time - eb->time;\n    }\n    // If times are equal, process end events before start events\n    return ea->type - eb->type;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Event events[200];\n        int eventCount = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int m, a, b;\n            scanf(\"%d %d %d\", &m, &a, &b);\n            \n            events[eventCount].time = a;\n            events[eventCount].weight = m;\n            events[eventCount].type = 0;\n            eventCount++;\n            \n            events[eventCount].time = b;\n            events[eventCount].weight = m;\n            events[eventCount].type = 1;\n            eventCount++;\n        }\n        \n        qsort(events, eventCount, sizeof(Event), compare);\n        \n        int currentWeight = 0;\n        int broken = 0;\n        \n        for (int i = 0; i < eventCount; i++) {\n            if (events[i].type == 0) {\n                // Person starts crossing\n                currentWeight += events[i].weight;\n                if (currentWeight > 150) {\n                    broken = 1;\n                    break;\n                }\n            } else {\n                // Person finishes crossing\n                currentWeight -= events[i].weight;\n            }\n        }\n        \n        if (broken) {\n            printf(\"NG\\n\");\n        } else {\n            printf(\"OK\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int time; int weight; int type; // 0 for start,  int compare(const void *a, const void *b) { Event *ea  = (Event *)b; if (ea->time != eb->time) { return ea->time - eb->time; } // If times are equal, process  return ea->type - eb->type; } int main() { int n; while (scanf(\"%d\", &n) == 1 && n != 0) { Event events[200]; int eventCount = 0; for (int i = 0; i < n; i++) {  &b); events[eventCount].time  events[eventCount].type  b; events[eventCount].weight = m; events[eventCount].type = 1;  compare); int currentWeight = 0; int broken = 0; for (int i = 0; i < eventCount; i++) { if (events[i].type ==  crossing currentWeight += events[i].weight; if (currentWeight > 150)  } } else { // Person  } } if (broken) { printf(\"NG\\n\"); } else { printf(\"OK\\n\"); } } return 0; }"], "perturbed_original": ["m[100],a[100],b[100],i,j,M,B;main(n){for(;scanf(\"%d\",&n)*n;puts(B?\"NG\":\"OK\")){for(i=n;i--;B=0)scanf(\"%d%d%d\",m+i,a+i,b+i);for(i=n;i--;B|=M>150)for(M=0,j=n;j--;)M+=a[i]>=a[j]&&a[i]<b[j]?m[j]:0;}} m[100],a[100],b[100],i,j,M,B;"], "original_ll": -1.7404495477676392, "sampled_ll": -0.4474373757839203, "all_perturbed_sampled_ll": [-1.5399094820022583], "all_perturbed_original_ll": [-1.7369858026504517], "perturbed_sampled_ll": -1.5399094820022583, "perturbed_original_ll": -1.7369858026504517, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n//Dangerous Bridge\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tboolean[][] map = new boolean[n*2][250];\n\t\t\tint[] w = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tfor(int j=a;j<b;j++)map[i][j] = true;\n\t\t\t}\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<231;i++){\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(map[j][i])sum+=w[j];\n\t\t\t\t}\n\t\t\t\tif(sum>150){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(f?\"OK\":\"NG\");\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            List<Event> events = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                int m = sc.nextInt();\n                long a = sc.nextLong();\n                long b = sc.nextLong();\n                \n                events.add(new Event(a, m, true));\n                events.add(new Event(b, m, false));\n            }\n            \n            Collections.sort(events);\n            \n            int currentWeight = 0;\n            boolean broken = false;\n            \n            for (Event e : events) {\n                if (e.isEnter) {\n                    currentWeight += e.weight;\n                    if (currentWeight > 150) {\n                        broken = true;\n                        break;\n                    }\n                } else {\n                    currentWeight -= e.weight;\n                }\n            }\n            \n            System.out.println(broken ? \"NG\" : \"OK\");\n        }\n        \n        sc.close();\n    }\n    \n    static class Event implements Comparable<Event> {\n        long time;\n        int weight;\n        boolean isEnter;\n        \n        Event(long time, int weight, boolean isEnter) {\n            this.time = time;\n            this.weight = weight;\n            this.isEnter = isEnter;\n        }\n        \n        @Override\n        public int compareTo(Event other) {\n            if (this.time != other.time) {\n                return Long.compare(this.time, other.time);\n            }\n            // Exit events should come before enter events at the same time\n            if (this.isEnter != other.isEnter) {\n                return this.isEnter ? 1 : -1;\n            }\n            return 0;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner <extra_id_7>events)<extra_id_8>if (!broken<extra_id_9>} if (events<extra_id_10>return (Long) events.indexOf(new<extra_id_11>Event(time,<extra_id_12>weight, boolean isEnter) {<extra_id_13>1 ; } if (this.weight<extra_id_14>+=<extra_id_15>} if<extra_id_16>public final long nextInt() {<extra_id_17>if<extra_id_18>}<extra_id_19> (true) { int n = sc.nextInt(); if (n  = new ArrayList<>(); for (int i = 0; i  m = sc.nextInt(); long a =  events.add(new Event(a, m,   0; boolean broken = false; for (Event e : events) { if (e.isEnter) { currentWeight += e.weight; if (currentWeight > 150) { broken = true; break; } } else { currentWeight -= e.weight; } }   Event implements Comparable<Event> { long time; int weight; boolean isEnter; Event(long time, int weight, boolean isEnter) { this.time = time; this.weight = weight; this.isEnter = isEnter; } @Override  if (this.time != other.time) { return Long.compare(this.time, other.time); } // Exit events  at the  other.isEnter) { return this.isEnter ? 1 : -1; } return 0; } } }"], "perturbed_original": ["import java.util.Scanner;  { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){ int n = sc.nextInt();  new int[n]; for(int i=0;i<n;i++){  = sc.nextInt(); int b = sc.nextInt(); for(int j=a;j<b;j++)map[i][j] = true; } boolean f = true; for(int i=0;i<231;i++){ int sum = 0; for(int j=0;j<n;j++){ if(map[j][i])sum+=w[j]; } if(sum>150){ f = false; break; } } System.out.println(f?\"OK\":\"NG\"); } } }"], "original_ll": -0.8024237155914307, "sampled_ll": -0.4381779134273529, "all_perturbed_sampled_ll": [-1.966117024421692], "all_perturbed_original_ll": [-1.4619649648666382], "perturbed_sampled_ll": -1.966117024421692, "perturbed_original_ll": -1.4619649648666382, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n=input()\n    if n==0: break\n    d=[map(int,raw_input().split()) for i in range(n)]\n    w=max([sum([d2[0] for d2 in d if d2[1]<=d1[1]<d2[2]]) for d1 in d])\n    print \"OK\" if w<151 else \"NG\"", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    people = []\n    for _ in range(n):\n        m, a, b = map(int, input().split())\n        people.append((m, a, b))\n    \n    # Collect all time points\n    times = set()\n    for m, a, b in people:\n        times.add(a)\n        times.add(b)\n    \n    times = sorted(times)\n    \n    broken = False\n    for t in times:\n        total_weight = 0\n        for m, a, b in people:\n            if a <= t < b:\n                total_weight += m\n        if total_weight > 150:\n            broken = True\n            break\n    \n    if broken:\n        print(\"NG\")\n    else:\n        print(\"OK\")\n", "perturbed_sampled": [" if n == 0: break people = [] for _ in range(n): m, a, b = map(int, input().split()) people.append((m, a, b)) # Collect  set() for m, a, b in people: times.add(a) times.add(b) times = sorted(times) broken = False for  b in people: if a <= t < b: total_weight += m if total_weight > 150: broken = True break if broken: print(\"NG\") else: print(\"OK\")"], "perturbed_original": ["while 1: n=input() if n==0: break d=[map(int,raw_input().split()) for i in range(n)] w=max([sum([d2[0] for d2 in  in d]) print \"OK\" if w<151 else \"NG\""], "original_ll": -1.3409409523010254, "sampled_ll": -0.7262316942214966, "all_perturbed_sampled_ll": [-1.858547568321228], "all_perturbed_original_ll": [-2.2556416988372803], "perturbed_sampled_ll": -1.858547568321228, "perturbed_original_ll": -2.2556416988372803, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "char z[];n,a;main(r){for(;scanf(\"%d\",&a)*a;puts(z+n))for(n=30;a;a=(r-a)/10)r=a%10,z[--n]=r+48;}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    long long n;\n    \n    while(scanf(\"%lld\", &n) == 1 && n != 0) {\n        if(n == 0) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        char result[100];\n        int idx = 0;\n        \n        long long num = n;\n        while(num != 0) {\n            long long remainder = num % (-10);\n            num = num / (-10);\n            \n            if(remainder < 0) {\n                remainder += 10;\n                num += 1;\n            }\n            \n            result[idx++] = '0' + remainder;\n        }\n        \n        for(int i = idx - 1; i >= 0; i--) {\n            printf(\"%c\", result[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { long  1 && n != 0) { if(n == 0) { printf(\"0\\n\"); continue; } char result[100]; int idx =  n; while(num != 0) { long long remainder  if(remainder < 0) { remainder += 10; num  '0' + remainder; } for(int i = idx - 1; i >= 0; i--) { printf(\"%c\", result[i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["char z[];n,a;main(r){for(;scanf(\"%d\",&a)*a;puts(z+n))for(n=30;a;a=(r-a)/10)r=a%10,z[--n]=r+48;}"], "original_ll": -2.924003839492798, "sampled_ll": -0.5489943623542786, "all_perturbed_sampled_ll": [-1.7804230451583862], "all_perturbed_original_ll": [-2.924003839492798], "perturbed_sampled_ll": -1.7804230451583862, "perturbed_original_ll": -2.924003839492798, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint ss = sc.nextInt();\n\t\t\tif(ss == 0) break;\n\t\t\tboolean minus = false;\n\t\t\tif(ss < 0) minus = true;\n\t\t\tchar[] in = String.valueOf(ss).toCharArray();\n\t\t\tint[] ar0 = new int[32];\n\t\t\tint[] ar1 = new int[32];\n\t\t\tfor(int i = 0; i < in.length; i++) {\n\t\t\t\tif(in[in.length - i - 1] == '-') continue;\n\t\t\t\tar0[i] = in[in.length -1 - i] - '0';\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tif(!minus)\n\t\t\tfor(int i = 0; i < 32; i++) {\n\t\t\t\tif(ar0[i] == 0) continue;\n\t\t\t\tmax = i;\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\tar1[i] += ar0[i];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tar0[i+1] += ar0[i]/10;\n\t\t\t\t\t\tar1[i] += ar0[i] % 10;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tar0[i+1] += ar0[i] / 10;\n\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\tif(ar0[i] % 10 != 0)\n\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < 32; i++) {\n\t\t\t\t\tif(ar0[i] == 0) continue;\n\t\t\t\t\tif(i % 2 != 0) {\n\t\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\t\tar1[i] += ar0[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tar0[i+1] += ar0[i]/10;\n\t\t\t\t\t\t\tar1[i] += ar0[i] % 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tar0[i+1] += ar0[i] / 10;\n\t\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\t\tif(ar0[i] % 10 != 0)\n\t\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint check = 0;\n\t\t\tfor(int i = 0; i < 32; i++) {\n\t\t\t\tif(ar1[i] != 0) {\n\t\t\t\t\tcheck = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = check; i >= 0; i--) {\n\t\t\t\tSystem.out.print(ar1[i]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long A = sc.nextLong();\n            if (A == 0) break;\n            \n            if (A == 0) {\n                System.out.println(\"0\");\n                continue;\n            }\n            \n            StringBuilder result = new StringBuilder();\n            long num = A;\n            \n            while (num != 0) {\n                long remainder = num % (-10);\n                num = num / (-10);\n                \n                if (remainder < 0) {\n                    remainder += 10;\n                    num += 1;\n                }\n                \n                result.append(remainder);\n            }\n            \n            System.out.println(result.reverse().toString());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import extends public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { long A = sc.nextLong(); if (A == 0) break; if (A == 0) <extra_id_1>if (C ==<extra_id_2>{ case C<extra_id_3>e.printWarning(new Exception(\"Too<extra_id_4>{ //<extra_id_5>Exception e) e.printWarning(exception); } // if<extra_id_6>} /*<extra_id_7>int j = int.valueOf(J); */<extra_id_8>EOS<extra_id_9>EOS<extra_id_10>else; for (long c<extra_id_11>in.current()<extra_id_12>double f=0 ; i <<extra_id_13>i ;<extra_id_14>++<extra_id_15>{ e.printWarning(exception); } for result = new StringBuilder(); long num = A; while (num != 0) { long remainder = num % (-10); num = num /  num += 1; } result.append(remainder); } System.out.println(result.reverse().toString()); } sc.close(); } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.HashMap;  java.math.*; import java.io.*; public  void main(String[] args) { Scanner sc = new Scanner(System.in); while(true) { int ss = sc.nextInt(); if(ss == 0)  if(ss < 0) minus = true; char[] in =  int[32]; int[] ar1 = new int[32]; for(int i = 0; i < in.length; i++) { if(in[in.length - i - 1] == '-') continue; ar0[i] =  '0'; } int max =  0; i < 32; i++) { if(ar0[i] == 0) continue; max = i; if(i % 2 == 0) { if(ar0[i] < 10) { ar1[i] += ar0[i]; } else { ar0[i+1] += ar0[i]/10;  } } else { if(ar0[i]  10; ar0[i+1] += 1; } else { ar0[i+1] += ar0[i] / 10; ar1[i] += 10 - ar0[i] % 10; if(ar0[i] % 10 != 0) ar0[i+1] += 1; } }  = 0; i < 32; i++) {   if(ar0[i] < 10)  ar0[i]/10; ar1[i] += ar0[i] % 10; } } else { if(ar0[i] < 10) { ar1[i] += 10 - ar0[i] % 10; ar0[i+1] += 1; }  / 10; ar1[i] += 10 - ar0[i] % 10; if(ar0[i] % 10 != 0) ar0[i+1]  } int check = 0; for(int i = 0; i < 32; i++) { if(ar1[i] != 0) { check  >= 0; i--) { System.out.print(ar1[i]); } System.out.println(); } } }"], "original_ll": -0.4426286816596985, "sampled_ll": -0.5797029733657837, "all_perturbed_sampled_ll": [-2.3691349029541016], "all_perturbed_original_ll": [-1.1917810440063477], "perturbed_sampled_ll": -2.3691349029541016, "perturbed_original_ll": -1.1917810440063477, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n\tn = raw_input()[::-1]\n\tif n == \"0\": break\n\tans = \"\"\n\tm = 1 if n[-1] == \"-\" else 0\n\tfor i in range(0, len(n) - m, 2):\n\t\tif int(n[i]) > 0:\n\t\t\tif i < len(n) - 1 - m:\n\t\t\t\tans += str(10 - int(n[i])) + str(int(n[i + 1]) + 1)\n\t\t\telse:\n\t\t\t\tans += str(10 - int(n[i])) + \"1\"\n\t\telse:\n\t\t\tans += \"0\" + n[i + 1]\n\tif len(n) == 1 or (m == 0 and n[0] == \"0\"):\n\t\tans = int(\"2\"+\"0\"*len(n)) - int(ans[::-1]) \n\telse:\n\t\tans = int(ans[::-1])\n\tprint ans", "sampled": "import sys\n\ndef to_negadecimal(n):\n    if n == 0:\n        return \"0\"\n    \n    result = []\n    while n != 0:\n        if n > 0:\n            remainder = n % (-10)\n            n = n // (-10)\n            if remainder < 0:\n                remainder += 10\n                n += 1\n        else:\n            remainder = n % (-10)\n            n = n // (-10)\n            if remainder < 0:\n                remainder += 10\n                n += 1\n        result.append(str(remainder))\n    \n    return ''.join(reversed(result))\n\nfor line in sys.stdin:\n    a = int(line.strip())\n    if a == 0 and line.strip() == \"0\":\n        # Check if this is the last zero (terminator)\n        break\n    print(to_negadecimal(a))\n```\n\nWait, let me reconsider the termination condition:\n\n```python\nimport sys\n\ndef to_negadecimal(n):\n    if n == 0:\n        return \"0\"\n    \n    result = []\n    while n != 0:\n        remainder = n % (-10)\n        n = n // (-10)\n        if remainder < 0:\n            remainder += 10\n            n += 1\n        result.append(str(remainder))\n    \n    return ''.join(reversed(result))\n\nfor line in sys.stdin:\n    a = int(line.strip())\n    if a == 0:\n        break\n    print(to_negadecimal(a))\n", "perturbed_sampled": ["import sys def to_negadecimal(n): if n == 0: return \"0\" result = [] while n  0: remainder = n % (-10) n = n // (-10) if remainder < 0: remainder  else: remainder = n % (-10) n = n // (-10) if remainder < 0: remainder += 10 n += 1 result.append(str(remainder))  sys.stdin: a = int(line.strip()) if a == 0 and line.strip() == \"0\": # Check if this  break print(to_negadecimal(a)) ``` Wait, let me reconsider the termination condition: ```python import  == 0: return \"0\" result = [] while n != 0: remainder = n % (-10) n   result.append(str(remainder)) return ''.join(reversed(result))  = int(line.strip()) if a == 0: break print(to_negadecimal(a))"], "perturbed_original": ["while 1: n = raw_input()[::-1] if n == \"0\": break ans = \"\" m =  else 0 for i in  if int(n[i]) > 0: if  - m: ans += str(10 - int(n[i])) + str(int(n[i + 1]) + 1)  int(n[i])) + \"1\" else: ans += \"0\" + n[i + 1] if len(n) == 1 or (m ==  ans = int(\"2\"+\"0\"*len(n)) - int(ans[::-1]) else: ans = int(ans[::-1]) print ans"], "original_ll": -1.0079280138015747, "sampled_ll": -0.6850851774215698, "all_perturbed_sampled_ll": [-1.933663010597229], "all_perturbed_original_ll": [-2.0212278366088867], "perturbed_sampled_ll": -1.933663010597229, "perturbed_original_ll": -2.0212278366088867, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "W,H,m,c[10][10];\nDP[10][10][10][10][51];//\u008ec\u008b\u00e0[y\u008d\u00c0\u0095W][x\u008d\u00c0\u0095W][\u008d\u00b6\u0092[][\u0089E\u0092[][\u008e_\u0091f\u008ec\u0097\u00ca]\n#define Update(d,v) ((v)>(d)?d=(v):0)\nCalcO(o,x,y){//\u008e_\u0091f\u008ec\u0097\u00ca\u0082\u00cc\u008cv\u008eZ\n\tif(c[x][y]>0){\n\t\to+=c[x][y];\n\t\tif(o>m)\n\t\t\to=m;\n\t}\n\treturn o;\n}\nCalcF(f,x,y){//\u008ec\u008b\u00e0\u0082\u00cc\u008cv\u008eZ\n\tif(c[x][y]<0)\n\t\tf+=c[x][y];\n\treturn f;\n}\nmain(){\n\tint x,y,range,d,dx,f,o,xl,xr,fn,on,f0;\n\tfor(;scanf(\"%d%d%d%d%d\",&W,&H,&f0,&m,&o),W;){\n\t\tfor(y=0;y<H;y++)\n\t\t\tfor(x=0;x<W;x++)\n\t\t\t\tscanf(\"%d\",&c[x][y]);\n\t\tf0++;//\u008ec\u008b\u00e00\u0082\u00c5\u0082\u00e0DP\u0082\u00cd1\u0082\u00c6\u0082\u00b5\u0082\u00c4\u0081ANA\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00cc\u0082\u00f0\u0096h\u0082\u00ae\n\t\tfor(y=0,x=0;x<W;x++)\n\t\t\tDP[y][x][x][x][CalcO(o-1,x,y)]=CalcF(f0,x,y);\n\t\tfor(y=0;y<H-1;y++){\n\t\t\tfor(range=0;range<W;range++){//\u008d\u00b6\u0089E\u0082\u00c9\u008c@\u0082\u00e9\u008dL\u0082\u00b3\n\t\t\t\tfor(d=0;d<2;d++){//\u008c\u00bb\u008d\u00dd\u0088\u00ca\u0092ux\u0082\u00f0\u0089\u009d\u0095\u009c\u0082\u00b3\u0082\u00b9\u0082\u00e9\n\t\t\t\t\tfor(xl=0;xl<W-range;xl++){//\u008d\u00b6\u0092[\n\t\t\t\t\t\tfor(dx=0;dx<=range;dx++){//x\u0095\u00cf\u0088\u00ca\n\t\t\t\t\t\t\txr=xl+range;\n\t\t\t\t\t\t\tx=d?xr-dx:xl+dx;\n\t\t\t\t\t\t\t//printf(\"range=%d, d=%d, xl=%d, dx=%d, xr=%d, x=%d\\n\",range,d,xl,dx,xr,x);\n\t\t\t\t\t\t\tfor(o=m;o>0;o--){\n\t\t\t\t\t\t\t\tif(f=DP[y][x][xl][xr][o]){\n\t\t\t\t\t\t\t\t\tif(x>0){\n\t\t\t\t\t\t\t\t\t\tif(x==xl){//\u008d\u00b6\u0082\u00d6\u008c@\u0082\u00e9\n\t\t\t\t\t\t\t\t\t\t\tfn=CalcF(f,x-1,y);\n\t\t\t\t\t\t\t\t\t\t\ton=CalcO(o-1,x-1,y);\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x-1][x-1][xr][on],fn);\n\t\t\t\t\t\t\t\t\t\t}else{//\u008d\u00b6\u0082\u00d6\u0090i\u0082\u00de\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x-1][xl][xr][o-1],f);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(x<W-1){\n\t\t\t\t\t\t\t\t\t\tif(x==xr){//\u0089E\u0082\u00d6\u008c@\u0082\u00e9\n\t\t\t\t\t\t\t\t\t\t\tfn=CalcF(f,x+1,y);\n\t\t\t\t\t\t\t\t\t\t\ton=CalcO(o-1,x+1,y);\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x+1][xl][x+1][on],fn);\n\t\t\t\t\t\t\t\t\t\t}else{//\u0089E\u0082\u00d6\u0090i\u0082\u00de\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x+1][xl][xr][o-1],f);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//\u0089\u00ba\u0082\u00d6\u008c@\u0082\u00e9\n\t\t\t\t\t\t\t\t\tfn=CalcF(f,x,y+1);\n\t\t\t\t\t\t\t\t\ton=CalcO(o-1,x,y+1);\n\t\t\t\t\t\t\t\t\tUpdate(DP[y+1][x][x][x][on],fn);\n\t\t\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}//o\n\t\t\t\t\t\t}//dx\n\t\t\t\t\t}//xl\n\t\t\t\t}//d\n\t\t\t}//range\n\t\t}//y\n#if 0\n\t\tfor(y=0;y<H;y++){\n\t\t\tfor(x=0;x<W;x++){\n\t\t\t\tfor(o=m;o>0;o--){\n\t\t\t\t\tif(f=DP[y][x][x][x][o]){\n\t\t\t\t\t\tprintf(\"%4d \",f-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(o==0)\n\t\t\t\t\tprintf(\"---- \");\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n#endif\n\t\tfn=0;\n\t\tfor(x=0;x<W;x++){\n\t\t\tfor(o=m;o>0;o--){\n\t\t\t\tf=DP[H-1][x][x][x][o];\n\t\t\t\tif(f>fn)\n\t\t\t\t\tfn=f;\n\t\t\t}\n\t\t}\n\t\tprintf(fn?\"%d\\n\":\"NA\\n\",f0-fn);\n\t\tmemset(DP,0,sizeof(DP));\n\t}\n\tputs(\"\");\n\texit(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_W 10\n#define MAX_H 10\n#define MAX_O 50\n\nint W, H, f, m, o;\nint grid[MAX_W + 1][MAX_H + 1];\nint visited[MAX_W + 1][MAX_H + 1][MAX_O + 1];\nint cost[MAX_W + 1][MAX_H + 1][MAX_O + 1];\n\ntypedef struct {\n    int x, y, oxygen, c;\n} State;\n\nState queue[1000000];\nint front, rear;\n\nvoid enqueue(int x, int y, int oxygen, int c) {\n    queue[rear].x = x;\n    queue[rear].y = y;\n    queue[rear].oxygen = oxygen;\n    queue[rear].c = c;\n    rear++;\n}\n\nState dequeue() {\n    return queue[front++];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &W, &H);\n        if (W == 0 && H == 0) break;\n        \n        scanf(\"%d %d %d\", &f, &m, &o);\n        \n        for (int j = 1; j <= H; j++) {\n            for (int i = 1; i <= W; i++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        \n        memset(visited, 0, sizeof(visited));\n        for (int i = 0; i <= W; i++) {\n            for (int j = 0; j <= H; j++) {\n                for (int k = 0; k <= m; k++) {\n                    cost[i][j][k] = INT_MAX;\n                }\n            }\n        }\n        \n        front = 0;\n        rear = 0;\n        \n        for (int i = 1; i <= W; i++) {\n            if (grid[i][1] > 0) {\n                int new_o = o - 1 + grid[i][1];\n                if (new_o > m) new_o = m;\n                if (new_o > 0) {\n                    enqueue(i, 1, new_o, 0);\n                    cost[i][1][new_o] = 0;\n                }\n            } else {\n                int dig_cost = -grid[i][1];\n                if (o > 1) {\n                    enqueue(i, 1, o - 1, dig_cost);\n                    cost[i][1][o - 1] = dig_cost;\n                }\n            }\n        }\n        \n        int min_cost = INT_MAX;\n        \n        while (front < rear) {\n            State s = dequeue();\n            int x = s.x;\n            int y = s.y;\n            int oxy = s.oxygen;\n            int c = s.c;\n            \n            if (visited[x][y][oxy]) continue;\n            visited[x][y][oxy] = 1;\n            \n            if (y == H) {\n                if (c < min_cost) {\n                    min_cost = c;\n                }\n                continue;\n            }\n            \n            int dx[] = {-1, 1, 0};\n            int dy[] = {0, 0, 1};\n            \n            for (int d = 0; d < 3; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                \n                if (nx < 1 || nx > W || ny < 1 || ny > H) continue;\n                \n                if (grid[nx][ny] > 0) {\n                    int new_oxy = oxy - 1 + grid[nx][ny];\n                    if (new_oxy > m) new_oxy = m;\n                    if (new_oxy > 0 && !visited[nx][ny][new_oxy]) {\n                        if (cost[nx][ny][new_oxy] > c) {\n                            cost[nx][ny][new_oxy] = c;\n                            enqueue(nx, ny, new_oxy, c);\n                        }\n                    }\n                } else {\n                    int dig_cost = -grid[nx][ny];\n                    int new_cost = c + dig_cost;\n                    int new_oxy = oxy - 1;\n                    if (new_oxy > 0 && !visited[nx][ny][new_oxy]) {\n                        if (cost[nx][ny][new_oxy] > new_cost) {\n                            cost[nx][ny][new_oxy] = new_cost;\n                            enqueue(nx, ny, new_oxy, new_cost);\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (min_cost == INT_MAX || min_cost > f) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", min_cost);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h> #define MAX_W 10 #define MAX_H 10 #define  f, m, o; int grid[MAX_W + 1][MAX_H + 1]; int visited[MAX_W + 1][MAX_H + 1][MAX_O +  + 1][MAX_O + 1]; typedef struct { int x, y, oxygen, c; } State; State queue[1000000]; int front, rear; void enqueue(int x, int y, int oxygen, int c) { queue[rear].x = x; queue[rear].y = y; queue[rear].oxygen = oxygen; queue[rear].c = c; rear++; } State dequeue() { return queue[front++]; } int main() { while (1) {  (W == 0 && H == 0) break;  &o); for (int j = 1; j <= H; j++) { for (int i = 1; i <= W; i++) { scanf(\"%d\",  sizeof(visited)); for (int i = 0; i <= W; i++) { for (int j = 0; j <=  k =  {  rear = 0; for (int i = 1; i <=  > 0) { int new_o = o - 1 + grid[i][1]; if (new_o > m) new_o = m; if (new_o > 0)  cost[i][1][new_o] = 0; } } else { int dig_cost = -grid[i][1]; if (o > 1) {  dig_cost); cost[i][1][o - 1] = dig_cost; } } } int min_cost = INT_MAX; while  y = s.y; int oxy = s.oxygen; int c = s.c; if (visited[x][y][oxy]) continue; visited[x][y][oxy] =  { if (c  c; } continue; }  {0, 0, 1}; for (int d = 0;  = y + dy[d]; if (nx < 1 || nx > W || ny < 1 || ny > H) continue; if (grid[nx][ny] > 0) { int new_oxy = oxy - 1 + grid[nx][ny]; if (new_oxy > m) new_oxy = m; if (new_oxy > 0 && !visited[nx][ny][new_oxy]) { if (cost[nx][ny][new_oxy] > c) { cost[nx][ny][new_oxy] =   int dig_cost = -grid[nx][ny]; int new_cost = c + dig_cost; int new_oxy = oxy -  && !visited[nx][ny][new_oxy])  { cost[nx][ny][new_oxy] = new_cost; enqueue(nx, ny, new_oxy, new_cost); } } } } } if (min_cost ==  { printf(\"NA\\n\"); } else { printf(\"%d\\n\", min_cost); } } return 0; }"], "perturbed_original": ["W,H,m,c[10][10]; DP[10][10][10][10][51];//\u008ec\u008b\u00e0[y\u008d\u00c0\u0095W][x\u008d\u00c0\u0095W][\u008d\u00b6\u0092[][\u0089E\u0092[][\u008e_\u0091f\u008ec\u0097\u00ca] #define Update(d,v) ((v)>(d)?d=(v):0) CalcO(o,x,y){//\u008e_\u0091f\u008ec\u0097\u00ca\u0082\u00cc\u008cv\u008eZ if(c[x][y]>0){ o+=c[x][y]; if(o>m)   for(;scanf(\"%d%d%d%d%d\",&W,&H,&f0,&m,&o),W;){ for(y=0;y<H;y++) for(x=0;x<W;x++) scanf(\"%d\",&c[x][y]); f0++;//\u008ec\u008b\u00e00\u0082\u00c5\u0082\u00e0DP\u0082\u00cd1\u0082\u00c6\u0082\u00b5\u0082\u00c4\u0081ANA\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00cc\u0082\u00f0\u0096h\u0082\u00ae for(y=0,x=0;x<W;x++) DP[y][x][x][x][CalcO(o-1,x,y)]=CalcF(f0,x,y); for(y=0;y<H-1;y++){ for(range=0;range<W;range++){//\u008d\u00b6\u0089E\u0082\u00c9\u008c@\u0082\u00e9\u008dL\u0082\u00b3 for(d=0;d<2;d++){//\u008c\u00bb\u008d\u00dd\u0088\u00ca\u0092ux\u0082\u00f0\u0089\u009d\u0095\u009c\u0082\u00b3\u0082\u00b9\u0082\u00e9 for(xl=0;xl<W-range;xl++){//\u008d\u00b6\u0092[  xl=%d, dx=%d, xr=%d,  fn=CalcF(f,x-1,y); on=CalcO(o-1,x-1,y); Update(DP[y][x-1][x-1][xr][on],fn); }else{//\u008d\u00b6\u0082\u00d6\u0090i\u0082\u00de Update(DP[y][x-1][xl][xr][o-1],f); } } if(x<W-1){ if(x==xr){//\u0089E\u0082\u00d6\u008c@\u0082\u00e9 fn=CalcF(f,x+1,y); on=CalcO(o-1,x+1,y); Update(DP[y][x+1][xl][x+1][on],fn); }else{//\u0089E\u0082\u00d6\u0090i\u0082\u00de Update(DP[y][x+1][xl][xr][o-1],f); } } //\u0089\u00ba\u0082\u00d6\u008c@\u0082\u00e9 fn=CalcF(f,x,y+1); on=CalcO(o-1,x,y+1); Update(DP[y+1][x][x][x][on],fn); //break; } }//o }//dx }//xl }//d }//range }//y #if 0 for(y=0;y<H;y++){ for(x=0;x<W;x++){ for(o=m;o>0;o--){  } if(o==0) printf(\"---- \"); } puts(\"\"); } #endif fn=0; for(x=0;x<W;x++){ for(o=m;o>0;o--){ f=DP[H-1][x][x][x][o]; if(f>fn) fn=f; } } printf(fn?\"%d\\n\":\"NA\\n\",f0-fn); memset(DP,0,sizeof(DP)); } puts(\"\"); exit(0); }"], "original_ll": -1.3000727891921997, "sampled_ll": -0.4011501371860504, "all_perturbed_sampled_ll": [-1.2242597341537476], "all_perturbed_original_ll": [-1.9443814754486084], "perturbed_sampled_ll": -1.2242597341537476, "perturbed_original_ll": -1.9443814754486084, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n   \n   \npublic class Main {\n\tstatic int INF = 2 << 28;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tint f = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint o = sc.nextInt();\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][][] memo = new int[h][w][m+1];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tArrays.fill(memo[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Data> queue = new PriorityQueue<Data>();\n\t\t\tfor(int i = 0; i < w; i++) {\n\t\t\t\tboolean[] tmp = new boolean[w];\n\t\t\t\tif(map[0][i] > 0) {\n\t\t\t\t\tqueue.add(new Data(0,i,0,Math.min(m, o - 1 + map[0][i]),tmp));\n\t\t\t\t}\n\t\t\t\telse  {\n\t\t\t\t\tqueue.add(new Data(0,i,-map[0][i],o - 1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans = -1;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tData tmp = queue.poll();\n\t\t\t\t\n\t\t\t\tif(tmp.o <= 0) continue;\n\t\t\t\ttmp.al[tmp.x] = true;\n\t\t\t\t\n\t\t\t\tif(tmp.y == h-1) {\n\t\t\t\t\tans = tmp.c;\n\t\t\t\t\tqueue.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(tmp.c >= memo[tmp.y][tmp.x][tmp.o]) continue;\n\t\t\t\tmemo[tmp.y][tmp.x][tmp.o] = tmp.c;\n\t\t\t\t\n\t\t\t\tif(tmp.x != w-1) {\n\t\t\t\t\tif(tmp.al[tmp.x+1]) {\n\t\t\t\t\t\t    queue.add(new Data(tmp.y,tmp.x+1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(map[tmp.y][tmp.x+1] > 0 && tmp.o != 1) {\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x+1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x+1]),Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(map[tmp.y][tmp.x+1] < 0){\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x+1,tmp.c - map[tmp.y][tmp.x+1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp.x != 0) {\n\t\t\t\t\tif(tmp.al[tmp.x-1]) {\n\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x-1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(map[tmp.y][tmp.x-1] > 0 && tmp.o != 1) {\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x-1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x-1]),Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(map[tmp.y][tmp.x-1] < 0){\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x-1,tmp.c - map[tmp.y][tmp.x-1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp.y != h-1) {\n\t\t\t\t\tif(map[tmp.y+1][tmp.x] > 0 && tmp.o != 1) {\n\t\t\t\t\t\tqueue.add(new Data(tmp.y+1,tmp.x,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y+1][tmp.x]),new boolean[w]));\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[tmp.y+1][tmp.x] < 0){\n\t\t\t\t\t\tqueue.add(new Data(tmp.y+1,tmp.x,tmp.c - map[tmp.y+1][tmp.x],tmp.o-1,new boolean[w]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(ans == -1 || ans >= f) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic class Data implements Comparable<Data> {\n\t\tint y;\n\t\tint x;\n\t\tint c;\n\t\tint o;\n\t\tboolean[] al;\n\t\t\n\t\tData(int y, int x, int c, int o, boolean[] al) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.c = c;\n\t\t\tthis.o = o;\n\t\t\tthis.al = al;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.c - o.c;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class State implements Comparable<State> {\n        int x, y, oxygen, cost;\n        \n        State(int x, int y, int oxygen, int cost) {\n            this.x = x;\n            this.y = y;\n            this.oxygen = oxygen;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            int W = Integer.parseInt(parts[0]);\n            int H = Integer.parseInt(parts[1]);\n            \n            if (W == 0 && H == 0) break;\n            \n            parts = br.readLine().trim().split(\"\\\\s+\");\n            int f = Integer.parseInt(parts[0]);\n            int m = Integer.parseInt(parts[1]);\n            int o = Integer.parseInt(parts[2]);\n            \n            int[][] grid = new int[H][W];\n            for (int j = 0; j < H; j++) {\n                parts = br.readLine().trim().split(\"\\\\s+\");\n                for (int i = 0; i < W; i++) {\n                    grid[j][i] = Integer.parseInt(parts[i]);\n                }\n            }\n            \n            int result = solve(W, H, f, m, o, grid);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n    }\n    \n    static int solve(int W, int H, int f, int m, int o, int[][] grid) {\n        int[][][] dist = new int[H][W][m + 1];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                Arrays.fill(dist[i][j], Integer.MAX_VALUE);\n            }\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        \n        // Start from any cell in the first row\n        for (int x = 0; x < W; x++) {\n            int cost = 0;\n            int oxygen = o;\n            \n            if (grid[0][x] < 0) {\n                cost = -grid[0][x];\n            } else {\n                oxygen = Math.min(m, oxygen + grid[0][x]);\n            }\n            \n            if (cost <= f && oxygen > 0) {\n                pq.offer(new State(x, 0, oxygen, cost));\n                dist[0][x][oxygen] = cost;\n            }\n        }\n        \n        int[] dx = {-1, 1, 0};\n        int[] dy = {0, 0, 1};\n        \n        int minCost = Integer.MAX_VALUE;\n        \n        while (!pq.isEmpty()) {\n            State curr = pq.poll();\n            \n            if (curr.y == H - 1) {\n                minCost = Math.min(minCost, curr.cost);\n                continue;\n            }\n            \n            if (curr.cost > dist[curr.y][curr.x][curr.oxygen]) {\n                continue;\n            }\n            \n            for (int d = 0; d < 3; d++) {\n                int nx = curr.x + dx[d];\n                int ny = curr.y + dy[d];\n                \n                if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n                \n                int newOxygen = curr.oxygen - 1;\n                if (newOxygen <= 0) continue;\n                \n                int newCost = curr.cost;\n                \n                if (grid[ny][nx] < 0) {\n                    newCost += -grid[ny][nx];\n                } else {\n                    newOxygen = Math.min(m, newOxygen + grid[ny][nx]);\n                }\n                \n                if (newCost > f) continue;\n                \n                if (newCost < dist[ny][nx][newOxygen]) {\n                    dist[ny][nx][newOxygen] = newCost;\n                    pq.offer(new State(nx, ny, newOxygen, newCost));\n                }\n            }\n        }\n        \n        return minCost == Integer.MAX_VALUE ? -1 : minCost;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class State implements Comparable<State> { int x, y, oxygen, cost; State(int x, int y, int oxygen, int cost) { this.x = x; this.y = y; this.oxygen = oxygen; this.cost = cost; } @Override public int compareTo(State other) { return Integer.compare(this.cost, other.cost); } } public static void main(String[]  br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine())   Integer.parseInt(parts[0]); int H = Integer.parseInt(parts[1]); if (W == 0 && H == 0) break; parts  Integer.parseInt(parts[0]); int m = Integer.parseInt(parts[1]); int o = Integer.parseInt(parts[2]); int[][] grid = new int[H][W]; for (int j = 0; j < H; j++)  (int i = 0; i < W; i++)  } int result  o,  { System.out.println(\"NA\"); } else { System.out.println(result); } } } static int solve(int W, int H, int  int[][] grid) { int[][][] dist =  (int i = 0; i < H; i++) { for  < W; j++) { Arrays.fill(dist[i][j], Integer.MAX_VALUE); } } PriorityQueue<State>  Start from any cell in the  = 0; x < W; x++) { int cost = 0; int oxygen = o; if (grid[0][x] < 0) { cost  oxygen = Math.min(m, oxygen + grid[0][x]); } if (cost <= f && oxygen > 0) { pq.offer(new State(x, 0,  } } int[] dx =  = {0, 0, 1}; int minCost = Integer.MAX_VALUE; while (!pq.isEmpty()) { State curr = pq.poll(); if (curr.y == H - 1) { minCost = Math.min(minCost, curr.cost); continue; } if (curr.cost > dist[curr.y][curr.x][curr.oxygen]) { continue; } for (int d = 0; d < 3;  curr.x + dx[d]; int ny = curr.y + dy[d]; if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue; int newOxygen  (newOxygen  = curr.cost; if (grid[ny][nx] < 0)  else { newOxygen = Math.min(m, newOxygen  dist[ny][nx][newOxygen]  newOxygen, newCost)); } }  ? -1 : minCost; } }"], "perturbed_original": ["import java.util.*; import java.math.*; import java.awt.geom.*; import java.io.*; public class Main { static int INF = 2 << 28; public static void main(String[]  new Scanner(System.in); while(true) { int w = sc.nextInt(); int  0 && h ==  sc.nextInt(); int m = sc.nextInt(); int o = sc.nextInt(); int[][] map = new int[h][w]; for(int i = 0; i < h;  0; j < w; j++) { map[i][j] = sc.nextInt(); } } int[][][]  i = 0; i  j = 0; j < w; j++) { Arrays.fill(memo[i][j], INF); } } PriorityQueue<Data> queue =  0; i < w; i++) { boolean[] tmp = new  queue.add(new Data(0,i,0,Math.min(m, o - 1 + map[0][i]),tmp)); } else { queue.add(new Data(0,i,-map[0][i],o - 1,tmp)); } } int ans = -1; while(!queue.isEmpty()) { Data tmp =  == h-1) { ans = tmp.c; queue.clear(); break; } if(tmp.c >= memo[tmp.y][tmp.x][tmp.o]) continue; memo[tmp.y][tmp.x][tmp.o] = tmp.c;  { queue.add(new Data(tmp.y,tmp.x+1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length))); } else { if(map[tmp.y][tmp.x+1] >  { queue.add(new Data(tmp.y,tmp.x+1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x+1]),Arrays.copyOf(tmp.al,tmp.al.length))); } else if(map[tmp.y][tmp.x+1] < 0){ queue.add(new Data(tmp.y,tmp.x+1,tmp.c  } else { if(map[tmp.y][tmp.x-1] > 0 && tmp.o != 1) { queue.add(new Data(tmp.y,tmp.x-1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x-1]),Arrays.copyOf(tmp.al,tmp.al.length))); } else if(map[tmp.y][tmp.x-1] < 0){ queue.add(new Data(tmp.y,tmp.x-1,tmp.c - map[tmp.y][tmp.x-1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length))); } } } if(tmp.y != h-1) { if(map[tmp.y+1][tmp.x] > 0  1 + map[tmp.y+1][tmp.x]),new boolean[w]));  queue.add(new  } } if(ans == -1 || ans >= f) { System.out.println(\"NA\"); } else { System.out.println(ans); } } } static  int y; int x; int c;  y, int x, int c, int o, boolean[] al)  = x; this.c = c; this.o = o; this.al = al; } @Override public int compareTo(Data o) { return this.c - o.c; } } }"], "original_ll": -0.4536621570587158, "sampled_ll": -0.33493444323539734, "all_perturbed_sampled_ll": [-1.2967283725738525], "all_perturbed_original_ll": [-1.2826303243637085], "perturbed_sampled_ll": -1.2967283725738525, "perturbed_original_ll": -1.2826303243637085, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "INF = 10 ** 20\n\ndef update_state(state, newx):\n  tmp = list(state)\n  tmp[newx] = 1\n  return tuple(tmp)\n\ndef get_co(x, y):\n  dc = do = 0\n  score = mp[y][x]\n  if score < 0:\n    dc = -score\n  else:\n    do = score\n  return dc, do\n\ndef minimum_cost(nowx, nowy, state, ox, goal, dic, w, m):\n  if (nowx, nowy, state, ox) in dic:\n    return dic[(nowx, nowy, state, ox)]\n  if nowy == goal:\n    return 0\n  if ox <= 1:\n    return INF\n  \n  ret = INF\n  \n  left = right = None\n  for i in range(nowx + 1, w):\n    if state[i] == 0:\n      right = i\n      break\n\n  for i in range(nowx - 1, -1, -1):\n    if state[i] == 0:\n      left = i\n      break\n\n  if left != None:\n    dc, do = get_co(left, nowy)\n    ret = min(ret, minimum_cost(left, nowy, update_state(state, left), min(ox + do - 1, m), goal, dic, w, m) + dc)\n    for i in range(left + 1, nowx):\n      ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic, w, m))\n  \n  if right != None:\n    dc, do = get_co(right, nowy)\n    ret = min(ret, minimum_cost(right, nowy, update_state(state, right), min(ox + do - 1, m), goal, dic, w, m) + dc)\n    for i in range(nowx + 1, right):\n      ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic, w, m))\n  \n  dc, do = get_co(nowx, nowy + 1)\n  ret = min(ret, minimum_cost(nowx, nowy + 1, tuple((1 if i == nowx else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m) + dc)\n  dic[(nowx, nowy, state, ox)] = ret\n  return ret\n\nwhile True:\n  w, h = map(int, input().split())\n  if w == 0:\n    break\n  f, m, o = map(int, input().split())\n  if o <= 1:\n    print(\"NA\")\n    continue\n  mp = [list(map(int, input().split())) for _ in range(h)]\n  dic = {}\n  ans = INF\n  for i in range(w):\n    dc, do = get_co(i, 0)\n    ans = min(ans, minimum_cost(i, 0, tuple(1 if i == j else 0 for j in range(w)), min(o + do - 1, m), h - 1, dic, w, m) + dc)\n  if ans > f:\n    print(\"NA\")\n  else:\n    print(ans)\n", "sampled": "import heapq\nfrom collections import defaultdict\n\ndef solve(W, H, f, m, o, grid):\n    # State: (x, y, oxygen, used_oxygen_cells)\n    # used_oxygen_cells is a frozenset of (x, y) tuples\n    \n    # Priority queue: (cost, x, y, oxygen, used_oxygen_cells)\n    pq = []\n    \n    # Start from any cell in the first row (y=0)\n    for x in range(W):\n        cell_value = grid[0][x]\n        if cell_value < 0:  #\u571f\n            cost = -cell_value\n            new_oxygen = o - 1\n            if new_oxygen >= 0 and cost <= f:\n                heapq.heappush(pq, (cost, x, 0, new_oxygen, frozenset()))\n        else:  # \u9178\u7d20\n            new_oxygen = min(m, o + cell_value) - 1\n            if new_oxygen >= 0:\n                heapq.heappush(pq, (0, x, 0, new_oxygen, frozenset([(x, 0)])))\n    \n    # Best cost for each state (x, y, oxygen, used_oxygen_cells)\n    visited = {}\n    \n    while pq:\n        cost, x, y, oxygen, used = heapq.heappop(pq)\n        \n        # Check if we reached the bottom\n        if y == H - 1 and oxygen > 0:\n            return cost\n        \n        # Skip if we've seen this state with better or equal cost\n        state = (x, y, oxygen, used)\n        if state in visited:\n            continue\n        visited[state] = cost\n        \n        # Try moving to adjacent cells: left, right, down\n        directions = []\n        if x > 0:\n            directions.append((x - 1, y))\n        if x < W - 1:\n            directions.append((x + 1, y))\n        if y < H - 1:\n            directions.append((x, y + 1))\n        \n        for nx, ny in directions:\n            cell_value = grid[ny][nx]\n            \n            if cell_value < 0:  # \u571f\n                dig_cost = -cell_value\n                new_cost = cost + dig_cost\n                new_oxygen = oxygen - 1\n                \n                if new_oxygen >= 0 and new_cost <= f:\n                    new_state = (nx, ny, new_oxygen, used)\n                    if new_state not in visited:\n                        heapq.heappush(pq, (new_cost, nx, ny, new_oxygen, used))\n            else:  # \u9178\u7d20\n                if (nx, ny) in used:\n                    # Already used this oxygen cell\n                    new_oxygen = oxygen - 1\n                    if new_oxygen >= 0:\n                        new_state = (nx, ny, new_oxygen, used)\n                        if new_state not in visited:\n                            heapq.heappush(pq, (cost, nx, ny, new_oxygen, used))\n                else:\n                    # Use oxygen from this cell\n                    new_oxygen = min(m, oxygen + cell_value) - 1\n                    if new_oxygen >= 0:\n                        new_used = used | frozenset([(nx, ny)])\n                        new_state = (nx, ny, new_oxygen, new_used)\n                        if new_state not in visited:\n                            heapq.heappush(pq, (cost, nx, ny, new_oxygen, new_used))\n    \n    return None\n\nwhile True:\n    line = input().split()\n    W, H = int(line[0]), int(line[1])\n    if W == 0 and H == 0:\n        break\n    \n    line = input().split()\n    f, m, o = int(line[0]), int(line[1]), int(line[2])\n    \n    grid = []\n    for _ in range(H):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    result = solve(W, H, f, m, o, grid)\n    if result is None:\n        print(\"NA\")\n    else:\n        print(result)\n", "perturbed_sampled": ["import heapq from collections import defaultdict def solve(W, H,  State: (x, y, oxygen, used_oxygen_cells) # used_oxygen_cells  y) tuples # Priority queue: (cost, x, y, oxygen, used_oxygen_cells) pq = [] # Start from any cell in the first row (y=0) for x  if cell_value < 0: #\u571f cost =  1 if new_oxygen >= 0 and cost <= f: heapq.heappush(pq, (cost, x,  \u9178\u7d20 new_oxygen = min(m, o + cell_value) - 1 if new_oxygen >=  new_oxygen, frozenset([(x, 0)]))) # Best cost for each state (x, y, oxygen, used_oxygen_cells) visited = {} while pq: cost, x, y, oxygen, used = heapq.heappop(pq) # Check if we reached the bottom if y == H - 1 and oxygen > 0: return cost # Skip if we've seen this state with better or equal cost  visited: continue visited[state] = cost # Try moving to adjacent cells: left, right,  x  W  y)) if  directions.append((x, y +  directions: cell_value = grid[ny][nx] if cell_value < 0: # \u571f dig_cost = -cell_value new_cost = cost + dig_cost new_oxygen = oxygen - 1 if new_oxygen >= 0 and new_cost <= f: new_state =  new_state not in visited: heapq.heappush(pq,  else:  in  oxygen cell new_oxygen = oxygen - 1 if new_oxygen >= 0: new_state = (nx, ny, new_oxygen, used) if new_state not  ny, new_oxygen, used)) else: # Use oxygen from this cell new_oxygen = min(m, oxygen + cell_value) - 1 if new_oxygen >= 0: new_used = used | frozenset([(nx, ny)]) new_state = (nx, ny,  in visited: heapq.heappush(pq, (cost, nx, ny, new_oxygen, new_used)) return None while True: line = input().split() W,  W == 0 and H == 0: break line = input().split() f, m, o = int(line[0]),  for _ in  grid.append(row) result = solve(W, H, f, m, o, grid)  else: print(result)"], "perturbed_original": ["INF = 10 ** 20 def update_state(state, newx): tmp = list(state) tmp[newx] = 1 return tuple(tmp) def get_co(x, y): dc = do = 0 score = mp[y][x] if score  else: do = score return dc, do def minimum_cost(nowx, nowy, state, ox, goal, dic, w, m): if (nowx, nowy,  dic[(nowx, nowy, state, ox)] if   left = right = None for i in range(nowx + 1, w): if state[i] == 0: right = i break for i in range(nowx - 1, -1, -1): if state[i] == 0: left = i break if left != None: dc, do  min(ret, minimum_cost(left, nowy, update_state(state, left), min(ox + do - 1,  + dc) for i in range(left + 1, nowx): ret = min(ret, minimum_cost(i, nowy, state, ox - 1,  right  get_co(right, nowy) ret = min(ret, minimum_cost(right, nowy, update_state(state, right), min(ox + do - 1, m), goal, dic, w,  in range(nowx + 1,  1, goal, dic, w, m)) dc, do = get_co(nowx, nowy + 1) ret = min(ret, minimum_cost(nowx, nowy + 1, tuple((1 if i == nowx  range(w))), min(ox + do - 1, m), goal, dic, w, m) + dc) dic[(nowx, nowy, state, ox)]  m,   mp = [list(map(int, input().split())) for _ in range(h)] dic = {} ans = INF for i in range(w): dc, do = get_co(i, 0) ans = min(ans, minimum_cost(i, 0, tuple(1 if i == j else 0 for j in range(w)), min(o + do - 1, m), h -  dc) if ans > f: print(\"NA\") else: print(ans)"], "original_ll": -0.7175218462944031, "sampled_ll": -0.6071824431419373, "all_perturbed_sampled_ll": [-1.9974092245101929], "all_perturbed_original_ll": [-1.6352514028549194], "perturbed_sampled_ll": -1.9974092245101929, "perturbed_original_ll": -1.6352514028549194, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}], "metrics": {"roc_auc": 0.7216444444444445, "fpr": [0.0, 0.0, 0.0033333333333333335, 0.0033333333333333335, 0.005, 0.005, 0.006666666666666667, 0.006666666666666667, 0.008333333333333333, 0.008333333333333333, 0.011666666666666667, 0.011666666666666667, 0.015, 0.015, 0.016666666666666666, 0.016666666666666666, 0.018333333333333333, 0.018333333333333333, 0.02, 0.02, 0.021666666666666667, 0.021666666666666667, 0.02666666666666667, 0.02666666666666667, 0.028333333333333332, 0.028333333333333332, 0.03, 0.03, 0.03333333333333333, 0.03333333333333333, 0.035, 0.035, 0.03666666666666667, 0.03666666666666667, 0.03833333333333333, 0.03833333333333333, 0.041666666666666664, 0.041666666666666664, 0.043333333333333335, 0.043333333333333335, 0.045, 0.045, 0.04833333333333333, 0.04833333333333333, 0.05, 0.05, 0.051666666666666666, 0.051666666666666666, 0.05333333333333334, 0.05333333333333334, 0.055, 0.055, 0.056666666666666664, 0.056666666666666664, 0.058333333333333334, 0.058333333333333334, 0.06, 0.06, 0.06333333333333334, 0.06333333333333334, 0.065, 0.065, 0.06833333333333333, 0.06833333333333333, 0.07, 0.07, 0.07166666666666667, 0.07166666666666667, 0.07333333333333333, 0.07333333333333333, 0.07666666666666666, 0.07666666666666666, 0.07833333333333334, 0.07833333333333334, 0.08, 0.08, 0.08333333333333333, 0.08333333333333333, 0.08666666666666667, 0.08666666666666667, 0.08833333333333333, 0.08833333333333333, 0.09, 0.09, 0.09166666666666666, 0.09166666666666666, 0.095, 0.095, 0.09666666666666666, 0.09666666666666666, 0.09833333333333333, 0.09833333333333333, 0.1, 0.1, 0.10166666666666667, 0.10166666666666667, 0.10333333333333333, 0.10333333333333333, 0.105, 0.105, 0.10666666666666667, 0.10666666666666667, 0.10833333333333334, 0.10833333333333334, 0.11, 0.11, 0.11166666666666666, 0.11166666666666666, 0.11333333333333333, 0.11333333333333333, 0.115, 0.115, 0.11833333333333333, 0.11833333333333333, 0.12, 0.12, 0.12166666666666667, 0.12166666666666667, 0.125, 0.125, 0.12833333333333333, 0.12833333333333333, 0.13, 0.13, 0.13166666666666665, 0.13166666666666665, 0.13333333333333333, 0.13333333333333333, 0.135, 0.135, 0.13833333333333334, 0.13833333333333334, 0.14, 0.14, 0.14166666666666666, 0.14166666666666666, 0.14333333333333334, 0.14333333333333334, 0.145, 0.145, 0.14666666666666667, 0.14666666666666667, 0.14833333333333334, 0.14833333333333334, 0.15, 0.15, 0.15166666666666667, 0.15166666666666667, 0.155, 0.155, 0.15666666666666668, 0.15666666666666668, 0.16, 0.16, 0.16166666666666665, 0.16166666666666665, 0.16333333333333333, 0.16333333333333333, 0.16833333333333333, 0.16833333333333333, 0.17333333333333334, 0.17333333333333334, 0.175, 0.175, 0.17833333333333334, 0.17833333333333334, 0.18333333333333332, 0.18333333333333332, 0.185, 0.185, 0.19, 0.19, 0.19166666666666668, 0.19166666666666668, 0.19833333333333333, 0.19833333333333333, 0.20166666666666666, 0.20166666666666666, 0.20833333333333334, 0.20833333333333334, 0.21166666666666667, 0.21166666666666667, 0.21333333333333335, 0.21333333333333335, 0.215, 0.215, 0.21666666666666667, 0.21666666666666667, 0.22, 0.22, 0.22166666666666668, 0.22166666666666668, 0.22333333333333333, 0.22333333333333333, 0.225, 0.225, 0.22833333333333333, 0.22833333333333333, 0.23, 0.23, 0.23166666666666666, 0.23166666666666666, 0.23333333333333334, 0.23333333333333334, 0.235, 0.235, 0.23666666666666666, 0.23666666666666666, 0.23833333333333334, 0.23833333333333334, 0.24, 0.24, 0.24166666666666667, 0.24166666666666667, 0.245, 0.245, 0.24666666666666667, 0.24666666666666667, 0.24833333333333332, 0.24833333333333332, 0.25, 0.25, 0.25333333333333335, 0.25333333333333335, 0.255, 0.255, 0.26, 0.26, 0.26666666666666666, 0.26666666666666666, 0.2683333333333333, 0.2683333333333333, 0.27, 0.27, 0.2733333333333333, 0.2733333333333333, 0.275, 0.275, 0.2816666666666667, 0.2816666666666667, 0.2833333333333333, 0.2833333333333333, 0.285, 0.285, 0.28833333333333333, 0.28833333333333333, 0.2916666666666667, 0.2916666666666667, 0.29333333333333333, 0.29333333333333333, 0.295, 0.295, 0.2966666666666667, 0.2966666666666667, 0.29833333333333334, 0.29833333333333334, 0.30833333333333335, 0.30833333333333335, 0.31166666666666665, 0.31166666666666665, 0.31333333333333335, 0.31333333333333335, 0.315, 0.315, 0.31666666666666665, 0.31666666666666665, 0.32, 0.32, 0.32166666666666666, 0.32166666666666666, 0.3233333333333333, 0.3233333333333333, 0.325, 0.325, 0.33166666666666667, 0.33166666666666667, 0.3333333333333333, 0.3333333333333333, 0.34, 0.34, 0.3433333333333333, 0.3433333333333333, 0.3466666666666667, 0.3466666666666667, 0.34833333333333333, 0.34833333333333333, 0.35333333333333333, 0.35333333333333333, 0.3566666666666667, 0.3566666666666667, 0.36, 0.36, 0.3616666666666667, 0.3616666666666667, 0.36333333333333334, 0.36333333333333334, 0.36666666666666664, 0.36666666666666664, 0.37, 0.37, 0.37333333333333335, 0.37333333333333335, 0.37666666666666665, 0.37666666666666665, 0.38333333333333336, 0.38333333333333336, 0.385, 0.385, 0.395, 0.395, 0.39666666666666667, 0.39666666666666667, 0.3983333333333333, 0.3983333333333333, 0.4, 0.4, 0.405, 0.405, 0.4083333333333333, 0.4083333333333333, 0.4166666666666667, 0.4166666666666667, 0.42, 0.42, 0.4216666666666667, 0.4216666666666667, 0.42333333333333334, 0.42333333333333334, 0.425, 0.425, 0.4266666666666667, 0.4266666666666667, 0.44, 0.44, 0.44166666666666665, 0.44166666666666665, 0.4483333333333333, 0.4483333333333333, 0.45, 0.45, 0.45166666666666666, 0.45166666666666666, 0.45666666666666667, 0.45666666666666667, 0.4633333333333333, 0.4633333333333333, 0.465, 0.465, 0.47, 0.47, 0.4716666666666667, 0.4716666666666667, 0.475, 0.475, 0.48, 0.48, 0.48333333333333334, 0.48333333333333334, 0.485, 0.485, 0.4866666666666667, 0.4866666666666667, 0.49166666666666664, 0.49166666666666664, 0.495, 0.495, 0.49666666666666665, 0.49666666666666665, 0.5, 0.5, 0.5033333333333333, 0.5033333333333333, 0.5083333333333333, 0.5083333333333333, 0.51, 0.51, 0.515, 0.515, 0.5166666666666667, 0.5166666666666667, 0.5183333333333333, 0.5183333333333333, 0.5216666666666666, 0.5216666666666666, 0.5233333333333333, 0.5233333333333333, 0.5283333333333333, 0.5283333333333333, 0.5316666666666666, 0.5316666666666666, 0.5333333333333333, 0.5333333333333333, 0.535, 0.535, 0.5383333333333333, 0.5383333333333333, 0.54, 0.54, 0.5416666666666666, 0.5416666666666666, 0.5433333333333333, 0.5433333333333333, 0.5483333333333333, 0.5483333333333333, 0.55, 0.55, 0.5516666666666666, 0.5516666666666666, 0.5583333333333333, 0.5583333333333333, 0.5616666666666666, 0.5616666666666666, 0.5633333333333334, 0.5633333333333334, 0.5683333333333334, 0.5683333333333334, 0.5716666666666667, 0.5716666666666667, 0.575, 0.575, 0.58, 0.58, 0.5816666666666667, 0.5816666666666667, 0.5833333333333334, 0.5833333333333334, 0.5933333333333334, 0.5933333333333334, 0.6, 0.6, 0.6016666666666667, 0.6016666666666667, 0.6083333333333333, 0.6083333333333333, 0.61, 0.61, 0.6133333333333333, 0.6133333333333333, 0.615, 0.615, 0.6183333333333333, 0.6183333333333333, 0.62, 0.62, 0.6233333333333333, 0.6233333333333333, 0.6266666666666667, 0.6266666666666667, 0.6283333333333333, 0.6283333333333333, 0.63, 0.63, 0.6366666666666667, 0.6366666666666667, 0.6383333333333333, 0.6383333333333333, 0.64, 0.64, 0.6533333333333333, 0.6533333333333333, 0.655, 0.655, 0.6633333333333333, 0.6633333333333333, 0.665, 0.665, 0.6716666666666666, 0.6716666666666666, 0.6733333333333333, 0.6733333333333333, 0.6783333333333333, 0.6783333333333333, 0.6866666666666666, 0.6866666666666666, 0.7033333333333334, 0.7033333333333334, 0.7066666666666667, 0.7066666666666667, 0.71, 0.71, 0.75, 0.75, 0.7533333333333333, 0.7533333333333333, 0.77, 0.77, 0.7766666666666666, 0.7766666666666666, 0.78, 0.78, 0.7983333333333333, 0.7983333333333333, 0.8083333333333333, 0.8083333333333333, 0.8366666666666667, 0.8366666666666667, 0.8466666666666667, 0.8466666666666667, 0.8516666666666667, 0.8516666666666667, 0.8683333333333333, 0.8683333333333333, 0.87, 0.87, 0.8916666666666667, 0.8916666666666667, 0.925, 0.925, 0.9316666666666666, 0.9316666666666666, 0.9483333333333334, 0.9866666666666667, 0.9983333333333333, 0.9983333333333333, 1.0], "tpr": [0.0, 0.0016666666666666668, 0.0016666666666666668, 0.008333333333333333, 0.008333333333333333, 0.011666666666666667, 0.011666666666666667, 0.018333333333333333, 0.018333333333333333, 0.035, 0.035, 0.03833333333333333, 0.03833333333333333, 0.04, 0.04, 0.041666666666666664, 0.041666666666666664, 0.056666666666666664, 0.056666666666666664, 0.06666666666666667, 0.06666666666666667, 0.075, 0.075, 0.07666666666666666, 0.07666666666666666, 0.08, 0.08, 0.08166666666666667, 0.08166666666666667, 0.09333333333333334, 0.09333333333333334, 0.09833333333333333, 0.09833333333333333, 0.1, 0.1, 0.105, 0.105, 0.11166666666666666, 0.11166666666666666, 0.12666666666666668, 0.12666666666666668, 0.12833333333333333, 0.12833333333333333, 0.13833333333333334, 0.13833333333333334, 0.14, 0.14, 0.15166666666666667, 0.15166666666666667, 0.155, 0.155, 0.16, 0.16, 0.16333333333333333, 0.16333333333333333, 0.165, 0.165, 0.17166666666666666, 0.17166666666666666, 0.17833333333333334, 0.17833333333333334, 0.18333333333333332, 0.18333333333333332, 0.19, 0.19, 0.19666666666666666, 0.19666666666666666, 0.2, 0.2, 0.20833333333333334, 0.20833333333333334, 0.22, 0.22, 0.225, 0.225, 0.22833333333333333, 0.22833333333333333, 0.23, 0.23, 0.23166666666666666, 0.23166666666666666, 0.24333333333333335, 0.24333333333333335, 0.245, 0.245, 0.24833333333333332, 0.24833333333333332, 0.2683333333333333, 0.2683333333333333, 0.2733333333333333, 0.2733333333333333, 0.2783333333333333, 0.2783333333333333, 0.28, 0.28, 0.2833333333333333, 0.2833333333333333, 0.2866666666666667, 0.2866666666666667, 0.295, 0.295, 0.305, 0.305, 0.30666666666666664, 0.30666666666666664, 0.31166666666666665, 0.31166666666666665, 0.31666666666666665, 0.31666666666666665, 0.31833333333333336, 0.31833333333333336, 0.32, 0.32, 0.33666666666666667, 0.33666666666666667, 0.3383333333333333, 0.3383333333333333, 0.3416666666666667, 0.3416666666666667, 0.3466666666666667, 0.3466666666666667, 0.3516666666666667, 0.3516666666666667, 0.3566666666666667, 0.3566666666666667, 0.365, 0.365, 0.36833333333333335, 0.36833333333333335, 0.37, 0.37, 0.37833333333333335, 0.37833333333333335, 0.38, 0.38, 0.385, 0.385, 0.39166666666666666, 0.39166666666666666, 0.3933333333333333, 0.3933333333333333, 0.39666666666666667, 0.39666666666666667, 0.3983333333333333, 0.3983333333333333, 0.4, 0.4, 0.4033333333333333, 0.4033333333333333, 0.4066666666666667, 0.4066666666666667, 0.4083333333333333, 0.4083333333333333, 0.4116666666666667, 0.4116666666666667, 0.415, 0.415, 0.41833333333333333, 0.41833333333333333, 0.42, 0.42, 0.4216666666666667, 0.4216666666666667, 0.42333333333333334, 0.42333333333333334, 0.425, 0.425, 0.43, 0.43, 0.43333333333333335, 0.43333333333333335, 0.44333333333333336, 0.44333333333333336, 0.445, 0.445, 0.45, 0.45, 0.46, 0.46, 0.4666666666666667, 0.4666666666666667, 0.4683333333333333, 0.4683333333333333, 0.47, 0.47, 0.47333333333333333, 0.47333333333333333, 0.475, 0.475, 0.4766666666666667, 0.4766666666666667, 0.4816666666666667, 0.4816666666666667, 0.48333333333333334, 0.48333333333333334, 0.48833333333333334, 0.48833333333333334, 0.49, 0.49, 0.49333333333333335, 0.49333333333333335, 0.505, 0.505, 0.5066666666666667, 0.5066666666666667, 0.51, 0.51, 0.5133333333333333, 0.5133333333333333, 0.515, 0.515, 0.5166666666666667, 0.5166666666666667, 0.52, 0.52, 0.5216666666666666, 0.5216666666666666, 0.5233333333333333, 0.5233333333333333, 0.525, 0.525, 0.5283333333333333, 0.5283333333333333, 0.5316666666666666, 0.5316666666666666, 0.5383333333333333, 0.5383333333333333, 0.54, 0.54, 0.5416666666666666, 0.5416666666666666, 0.55, 0.55, 0.5516666666666666, 0.5516666666666666, 0.5566666666666666, 0.5566666666666666, 0.56, 0.56, 0.5633333333333334, 0.5633333333333334, 0.5666666666666667, 0.5666666666666667, 0.5716666666666667, 0.5716666666666667, 0.5733333333333334, 0.5733333333333334, 0.5766666666666667, 0.5766666666666667, 0.5816666666666667, 0.5816666666666667, 0.585, 0.585, 0.5916666666666667, 0.5916666666666667, 0.5933333333333334, 0.5933333333333334, 0.595, 0.595, 0.5966666666666667, 0.5966666666666667, 0.5983333333333334, 0.5983333333333334, 0.6, 0.6, 0.6083333333333333, 0.6083333333333333, 0.6183333333333333, 0.6183333333333333, 0.6216666666666667, 0.6216666666666667, 0.6283333333333333, 0.6283333333333333, 0.6366666666666667, 0.6366666666666667, 0.6383333333333333, 0.6383333333333333, 0.645, 0.645, 0.65, 0.65, 0.6516666666666666, 0.6516666666666666, 0.6583333333333333, 0.6583333333333333, 0.6616666666666666, 0.6616666666666666, 0.6683333333333333, 0.6683333333333333, 0.67, 0.67, 0.6733333333333333, 0.6733333333333333, 0.675, 0.675, 0.6766666666666666, 0.6766666666666666, 0.685, 0.685, 0.6866666666666666, 0.6866666666666666, 0.6916666666666667, 0.6916666666666667, 0.6933333333333334, 0.6933333333333334, 0.695, 0.695, 0.6966666666666667, 0.6966666666666667, 0.7, 0.7, 0.7033333333333334, 0.7033333333333334, 0.7083333333333334, 0.7083333333333334, 0.71, 0.71, 0.7116666666666667, 0.7116666666666667, 0.7133333333333334, 0.7133333333333334, 0.715, 0.715, 0.72, 0.72, 0.7316666666666667, 0.7316666666666667, 0.7366666666666667, 0.7366666666666667, 0.7383333333333333, 0.7383333333333333, 0.7416666666666667, 0.7416666666666667, 0.745, 0.745, 0.7466666666666667, 0.7466666666666667, 0.7483333333333333, 0.7483333333333333, 0.755, 0.755, 0.7633333333333333, 0.7633333333333333, 0.765, 0.765, 0.77, 0.77, 0.7716666666666666, 0.7716666666666666, 0.7733333333333333, 0.7733333333333333, 0.7783333333333333, 0.7783333333333333, 0.78, 0.78, 0.7883333333333333, 0.7883333333333333, 0.79, 0.79, 0.7916666666666666, 0.7916666666666666, 0.795, 0.795, 0.8, 0.8, 0.8033333333333333, 0.8033333333333333, 0.805, 0.805, 0.8066666666666666, 0.8066666666666666, 0.81, 0.81, 0.8116666666666666, 0.8116666666666666, 0.8183333333333334, 0.8183333333333334, 0.8216666666666667, 0.8216666666666667, 0.8283333333333334, 0.8283333333333334, 0.83, 0.83, 0.8316666666666667, 0.8316666666666667, 0.8333333333333334, 0.8333333333333334, 0.8366666666666667, 0.8366666666666667, 0.8433333333333334, 0.8433333333333334, 0.8483333333333334, 0.8483333333333334, 0.85, 0.85, 0.8533333333333334, 0.8533333333333334, 0.855, 0.855, 0.8583333333333333, 0.8583333333333333, 0.86, 0.86, 0.8633333333333333, 0.8633333333333333, 0.865, 0.865, 0.8683333333333333, 0.8683333333333333, 0.8733333333333333, 0.8733333333333333, 0.875, 0.875, 0.8783333333333333, 0.8783333333333333, 0.8833333333333333, 0.8833333333333333, 0.885, 0.885, 0.8866666666666667, 0.8866666666666667, 0.8883333333333333, 0.8883333333333333, 0.8933333333333333, 0.8933333333333333, 0.8966666666666666, 0.8966666666666666, 0.9, 0.9, 0.905, 0.905, 0.9083333333333333, 0.9083333333333333, 0.91, 0.91, 0.9116666666666666, 0.9116666666666666, 0.915, 0.915, 0.9166666666666666, 0.9166666666666666, 0.9183333333333333, 0.9183333333333333, 0.9216666666666666, 0.9216666666666666, 0.925, 0.925, 0.93, 0.93, 0.9366666666666666, 0.9366666666666666, 0.9383333333333334, 0.9383333333333334, 0.94, 0.94, 0.9433333333333334, 0.9433333333333334, 0.945, 0.945, 0.9466666666666667, 0.9466666666666667, 0.9516666666666667, 0.9516666666666667, 0.9533333333333334, 0.9533333333333334, 0.9566666666666667, 0.9566666666666667, 0.9583333333333334, 0.9583333333333334, 0.96, 0.96, 0.9616666666666667, 0.9616666666666667, 0.9633333333333334, 0.9633333333333334, 0.965, 0.965, 0.9666666666666667, 0.9666666666666667, 0.9683333333333334, 0.9683333333333334, 0.9733333333333334, 0.9733333333333334, 0.9766666666666667, 0.9766666666666667, 0.9783333333333334, 0.9783333333333334, 0.98, 0.98, 0.9816666666666667, 0.9816666666666667, 0.9833333333333333, 0.9833333333333333, 0.985, 0.985, 0.9866666666666667, 0.9866666666666667, 0.9883333333333333, 0.9883333333333333, 0.99, 0.99, 0.9916666666666667, 0.9916666666666667, 0.9933333333333333, 0.9933333333333333, 0.995, 0.995, 0.9966666666666667, 0.9966666666666667, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 1.0, 1.0]}, "pr_metrics": {"pr_auc": 0.6771259695604105, "precision": [0.5, 0.5004170141784821, 0.5, 0.5004177109440268, 0.5008361204013378, 0.501255230125523, 0.501675041876047, 0.5020955574182733, 0.50251677852349, 0.5029387069689337, 0.5128424657534246, 0.5132819194515853, 0.5137221269296741, 0.5141630901287554, 0.5146048109965635, 0.5150472914875323, 0.5154905335628227, 0.5159345391903531, 0.5163793103448275, 0.5168248490077653, 0.5172711571675302, 0.5168539325842697, 0.5173010380622838, 0.5177489177489177, 0.5181975736568457, 0.5186470078057241, 0.5182291666666666, 0.5186794092093832, 0.5191304347826087, 0.5195822454308094, 0.5200348432055749, 0.5204882301656495, 0.5209424083769634, 0.5213973799126638, 0.5218531468531469, 0.5223097112860893, 0.5227670753064798, 0.523225241016652, 0.5236842105263158, 0.52414398595259, 0.5246045694200352, 0.525065963060686, 0.5255281690140845, 0.5259911894273128, 0.5264550264550265, 0.526919682259488, 0.5273851590106007, 0.5269672855879752, 0.5274336283185841, 0.5279007971656333, 0.5283687943262412, 0.5288376220053239, 0.5293072824156305, 0.5297777777777778, 0.5302491103202847, 0.5307212822796082, 0.5311942959001783, 0.5316681534344335, 0.5321428571428571, 0.5326184092940125, 0.5330948121645797, 0.5326768128916741, 0.5331541218637993, 0.5327354260089686, 0.533213644524237, 0.5336927223719676, 0.5341726618705036, 0.5346534653465347, 0.5351351351351351, 0.5356176735798016, 0.5361010830324909, 0.5365853658536586, 0.5370705244122965, 0.5375565610859728, 0.5371376811594203, 0.5376246600181324, 0.5381125226860254, 0.5386012715712988, 0.5381818181818182, 0.5386715195632393, 0.5391621129326047, 0.5396536007292616, 0.5401459854014599, 0.5406392694063927, 0.5411334552102377, 0.5407136322049405, 0.5412087912087912, 0.541704857928506, 0.5422018348623853, 0.5426997245179064, 0.5431985294117647, 0.5436982520699172, 0.5441988950276243, 0.5447004608294931, 0.5452029520295203, 0.5457063711911357, 0.5462107208872459, 0.5467160037002775, 0.5472222222222223, 0.5477293790546802, 0.5482374768089053, 0.5487465181058496, 0.5492565055762082, 0.5488372093023256, 0.5493482309124768, 0.5498602050326188, 0.5503731343283582, 0.5508870214752568, 0.5514018691588785, 0.5519176800748363, 0.5514981273408239, 0.5520149953139644, 0.5525328330206379, 0.5530516431924882, 0.5535714285714286, 0.5540921919096896, 0.5546139359698682, 0.5551366635249765, 0.5556603773584906, 0.5561850802644004, 0.556710775047259, 0.5572374645222328, 0.5568181818181818, 0.557345971563981, 0.5578747628083491, 0.5574548907882241, 0.5579847908745247, 0.5585156993339676, 0.559047619047619, 0.559580552907531, 0.5591603053435115, 0.559694364851958, 0.5602294455066922, 0.5607655502392345, 0.5613026819923371, 0.5618408437200384, 0.5623800383877159, 0.5629202689721422, 0.5634615384615385, 0.5640038498556305, 0.5645472061657033, 0.5641272902603665, 0.5637065637065637, 0.5642512077294686, 0.5647969052224371, 0.5643756050338818, 0.563953488372093, 0.5635305528612997, 0.5640776699029126, 0.564625850340136, 0.5651750972762646, 0.5657254138266796, 0.5662768031189084, 0.5668292682926829, 0.5673828125, 0.5679374389051809, 0.5684931506849316, 0.5690499510284035, 0.5696078431372549, 0.5701668302257115, 0.5707269155206287, 0.5712881022615536, 0.5718503937007874, 0.5724137931034483, 0.5729783037475346, 0.5735439289239882, 0.5741106719367589, 0.5746785361028685, 0.5752475247524752, 0.5758176412289395, 0.5763888888888888, 0.576961271102284, 0.5765407554671969, 0.5771144278606966, 0.5776892430278885, 0.5772681954137587, 0.5778443113772455, 0.5784215784215784, 0.578, 0.5785785785785785, 0.5791583166332666, 0.5797392176529589, 0.5803212851405622, 0.5809045226130654, 0.5814889336016097, 0.5820745216515609, 0.5826612903225806, 0.5832492431886983, 0.5838383838383838, 0.583417593528817, 0.5840080971659919, 0.5845997973657548, 0.5851926977687627, 0.5857868020304569, 0.5863821138211383, 0.5859613428280773, 0.5865580448065173, 0.5871559633027523, 0.5877551020408164, 0.5873340143003064, 0.5879345603271984, 0.5875127942681678, 0.5881147540983607, 0.5887179487179487, 0.5893223819301848, 0.5899280575539568, 0.5895061728395061, 0.5890834191555098, 0.5896907216494846, 0.5892672858617131, 0.5898760330578512, 0.5904860392967942, 0.5910973084886129, 0.5917098445595855, 0.5923236514522822, 0.5919003115264797, 0.5914760914760915, 0.5910509885535901, 0.5916666666666667, 0.5912408759124088, 0.5918580375782881, 0.5924764890282131, 0.5930962343096234, 0.5937172774869109, 0.5943396226415094, 0.5949632738719832, 0.5955882352941176, 0.5962145110410094, 0.5957894736842105, 0.5964172813487882, 0.5959915611814346, 0.5955649419218585, 0.5961945031712473, 0.5957671957671957, 0.5963983050847458, 0.5970307529162248, 0.5976645435244161, 0.5982996811902231, 0.597872340425532, 0.5985090521831736, 0.5980810234541578, 0.5976520811099253, 0.5972222222222222, 0.5967914438502674, 0.5974304068522484, 0.5969989281886388, 0.5965665236051502, 0.5961331901181526, 0.5967741935483871, 0.5974165769644779, 0.5969827586206896, 0.5965480043149946, 0.5971922246220303, 0.5978378378378378, 0.5974025974025974, 0.5969664138678223, 0.5976138828633406, 0.5971769815418024, 0.5978260869565217, 0.5984766050054406, 0.5980392156862745, 0.5986913849509269, 0.5982532751091703, 0.5978142076502733, 0.5984682713347921, 0.5991237677984665, 0.5986842105263158, 0.5993413830954994, 0.5989010989010989, 0.5995599559955995, 0.6002202643171806, 0.6008820286659317, 0.6015452538631346, 0.6011049723756906, 0.6006637168141593, 0.6013289036544851, 0.6008869179600886, 0.6004439511653719, 0.6, 0.6006674082313682, 0.6013363028953229, 0.6020066889632107, 0.6026785714285714, 0.6022346368715084, 0.6017897091722595, 0.6024636058230683, 0.6031390134529148, 0.6038159371492705, 0.604494382022472, 0.6051743532058492, 0.6058558558558559, 0.6054114994363021, 0.6049661399548533, 0.6056497175141243, 0.6052036199095022, 0.6047565118912798, 0.6043083900226758, 0.604994324631101, 0.6045454545454545, 0.6052332195676906, 0.6059225512528473, 0.6066134549600912, 0.6061643835616438, 0.6068571428571429, 0.6075514874141876, 0.6071019473081328, 0.6077981651376146, 0.6084959816303099, 0.6080459770114942, 0.6075949367088608, 0.6071428571428571, 0.6078431372549019, 0.6085450346420324, 0.6092485549132948, 0.6087962962962963, 0.608342989571263, 0.6090487238979119, 0.6085946573751452, 0.6093023255813953, 0.610011641443539, 0.6095571095571095, 0.6091015169194866, 0.6086448598130841, 0.6093567251461989, 0.6100702576112412, 0.6107854630715123, 0.6115023474178404, 0.6110458284371327, 0.6105882352941177, 0.6113074204946997, 0.6108490566037735, 0.6115702479338843, 0.6111111111111112, 0.6106508875739645, 0.6113744075829384, 0.6120996441281139, 0.6128266033254157, 0.6123662306777645, 0.6130952380952381, 0.6126340882002383, 0.6121718377088305, 0.6129032258064516, 0.6124401913875598, 0.6131736526946108, 0.6127098321342925, 0.6122448979591837, 0.6129807692307693, 0.6137184115523465, 0.6132530120481928, 0.6139927623642943, 0.6135265700483091, 0.6130592503022975, 0.612590799031477, 0.6133333333333333, 0.6128640776699029, 0.6123936816524909, 0.6119221411192214, 0.6114494518879415, 0.6121951219512195, 0.612942612942613, 0.6124694376528117, 0.6119951040391677, 0.6127450980392157, 0.6134969325153374, 0.6142506142506142, 0.6137761377613776, 0.6145320197044335, 0.6140567200986436, 0.6148148148148148, 0.61557478368356, 0.6150990099009901, 0.6158612143742255, 0.6153846153846154, 0.6149068322981367, 0.6144278606965174, 0.613947696139477, 0.614713216957606, 0.6142322097378277, 0.61375, 0.6145181476846058, 0.6152882205513784, 0.616060225846926, 0.6155778894472361, 0.6150943396226415, 0.6146095717884131, 0.6141235813366961, 0.61489898989899, 0.6144121365360303, 0.6151898734177215, 0.6159695817490495, 0.616751269035533, 0.6162642947903431, 0.6157760814249363, 0.6165605095541401, 0.6173469387755102, 0.6168582375478927, 0.6176470588235294, 0.618437900128041, 0.617948717948718, 0.6187419768934531, 0.6182519280205655, 0.6177606177606177, 0.6185567010309279, 0.6193548387096774, 0.6188630490956072, 0.6183699870633894, 0.6178756476683938, 0.6186770428015564, 0.6194805194805195, 0.6202860858257477, 0.6197916666666666, 0.6192959582790091, 0.6201044386422977, 0.6196078431372549, 0.6204188481675392, 0.6199213630406291, 0.6207349081364829, 0.621550591327201, 0.6210526315789474, 0.6205533596837944, 0.6200527704485488, 0.619550858652576, 0.6190476190476191, 0.6198675496688741, 0.6206896551724138, 0.6215139442231076, 0.6210106382978723, 0.6218375499334221, 0.6226666666666667, 0.6221628838451269, 0.6216577540106952, 0.6211512717536813, 0.6219839142091153, 0.6214765100671141, 0.6223118279569892, 0.6231493943472409, 0.623989218328841, 0.6234817813765182, 0.6243243243243243, 0.6238159675236806, 0.6233062330623306, 0.6227951153324288, 0.623641304347826, 0.6244897959183674, 0.6253405994550408, 0.626193724420191, 0.6256830601092896, 0.6265389876880985, 0.6273972602739726, 0.6282578875171467, 0.6277472527472527, 0.6272352132049519, 0.6267217630853994, 0.6262068965517241, 0.6256906077348067, 0.6265560165975104, 0.6260387811634349, 0.6255201109570042, 0.625, 0.6244784422809457, 0.6253481894150418, 0.6248256624825662, 0.6256983240223464, 0.6265734265734266, 0.6274509803921569, 0.6283309957924264, 0.6278089887640449, 0.6286919831223629, 0.6281690140845071, 0.6276445698166432, 0.6285310734463276, 0.6294200848656294, 0.6303116147308782, 0.6312056737588653, 0.6321022727272727, 0.6330014224751067, 0.6339031339031339, 0.6348074179743224, 0.6342857142857142, 0.6337625178826896, 0.6346704871060171, 0.6341463414634146, 0.6350574712643678, 0.6345323741007194, 0.6340057636887608, 0.6334776334776335, 0.634393063583815, 0.6338639652677279, 0.6333333333333333, 0.6328011611030478, 0.6322674418604651, 0.6317321688500728, 0.6311953352769679, 0.6306569343065693, 0.631578947368421, 0.6310395314787701, 0.6304985337243402, 0.6299559471365639, 0.6308823529411764, 0.6318114874815906, 0.6312684365781711, 0.6322008862629247, 0.6331360946745562, 0.6340740740740741, 0.6350148367952523, 0.6359583952451708, 0.6354166666666666, 0.6363636363636364, 0.6373134328358209, 0.6367713004484304, 0.6377245508982036, 0.638680659670165, 0.6396396396396397, 0.6390977443609023, 0.6400602409638554, 0.6395173453996983, 0.6389728096676737, 0.6384266263237519, 0.6393939393939394, 0.6388467374810318, 0.6382978723404256, 0.639269406392694, 0.6387195121951219, 0.6381679389312978, 0.6391437308868502, 0.6401225114854517, 0.6411042944785276, 0.642089093701997, 0.6430769230769231, 0.6440677966101694, 0.6435185185185185, 0.6445131375579598, 0.6439628482972136, 0.6449612403100775, 0.6459627329192547, 0.6469673405909798, 0.6479750778816199, 0.6474258970358814, 0.6484375, 0.6494522691705791, 0.6489028213166145, 0.6483516483516484, 0.6477987421383647, 0.6488188976377953, 0.6498422712933754, 0.6492890995260664, 0.6503164556962026, 0.6513470681458003, 0.6507936507936508, 0.6502384737678856, 0.6496815286624203, 0.6491228070175439, 0.6485623003194888, 0.6496, 0.6506410256410257, 0.6500802568218299, 0.6511254019292605, 0.6505636070853462, 0.6516129032258065, 0.6510500807754442, 0.6504854368932039, 0.6515397082658023, 0.6525974025974026, 0.6520325203252032, 0.6530944625407166, 0.6541598694942904, 0.6535947712418301, 0.6530278232405892, 0.6524590163934426, 0.6518883415435139, 0.6529605263157895, 0.6540362438220758, 0.6551155115511551, 0.6545454545454545, 0.6539735099337748, 0.6550580431177446, 0.654485049833887, 0.653910149750416, 0.6533333333333333, 0.6527545909849749, 0.6538461538461539, 0.6549413735343383, 0.6543624161073825, 0.6554621848739496, 0.6565656565656566, 0.6559865092748736, 0.6554054054054054, 0.6548223350253807, 0.6559322033898305, 0.6570458404074703, 0.6581632653061225, 0.6592844974446337, 0.658703071672355, 0.6581196581196581, 0.6575342465753424, 0.6569468267581475, 0.6580756013745704, 0.657487091222031, 0.6586206896551724, 0.6597582037996546, 0.6608996539792388, 0.6620450606585788, 0.6614583333333334, 0.6608695652173913, 0.6602787456445993, 0.6596858638743456, 0.6590909090909091, 0.660245183887916, 0.6596491228070176, 0.6590509666080844, 0.6584507042253521, 0.6578483245149912, 0.6590106007067138, 0.6584070796460177, 0.6578014184397163, 0.6589698046181173, 0.6583629893238434, 0.6577540106951871, 0.6571428571428571, 0.6565295169946332, 0.6559139784946236, 0.6552962298025135, 0.6564748201438849, 0.6576576576576577, 0.6570397111913358, 0.6564195298372514, 0.6557971014492754, 0.6551724137931034, 0.6545454545454545, 0.6557377049180327, 0.6551094890510949, 0.6563071297989032, 0.6556776556776557, 0.6568807339449542, 0.65625, 0.6574585635359116, 0.6586715867158671, 0.6580406654343808, 0.6592592592592592, 0.660482374768089, 0.6617100371747212, 0.6629422718808193, 0.664179104477612, 0.6654205607476635, 0.6647940074906367, 0.6660412757973734, 0.6654135338345865, 0.664783427495292, 0.6641509433962264, 0.6635160680529301, 0.6647727272727273, 0.6641366223908919, 0.6634980988593155, 0.6647619047619048, 0.6641221374045801, 0.6634799235181644, 0.6628352490421456, 0.6641074856046065, 0.6634615384615384, 0.6628131021194605, 0.6640926640926641, 0.6653771760154739, 0.6647286821705426, 0.6660194174757281, 0.6673151750972762, 0.6666666666666666, 0.666015625, 0.6653620352250489, 0.6666666666666666, 0.6660117878192534, 0.6653543307086615, 0.6666666666666666, 0.66600790513834, 0.6653465346534654, 0.6666666666666666, 0.6679920477137177, 0.6693227091633466, 0.6706586826347305, 0.67, 0.6693386773547094, 0.6706827309236948, 0.670020120724346, 0.6693548387096774, 0.6686868686868687, 0.6700404858299596, 0.6713995943204868, 0.6707317073170732, 0.6720977596741344, 0.6714285714285714, 0.6707566462167689, 0.6700819672131147, 0.6694045174537988, 0.668724279835391, 0.6701030927835051, 0.6694214876033058, 0.6708074534161491, 0.6721991701244814, 0.6735966735966736, 0.675, 0.6743215031315241, 0.6757322175732218, 0.6771488469601677, 0.6785714285714286, 0.6778947368421052, 0.6772151898734177, 0.6765327695560254, 0.6758474576271186, 0.6772823779193206, 0.676595744680851, 0.67590618336887, 0.6773504273504274, 0.6788008565310493, 0.6781115879828327, 0.6774193548387096, 0.6788793103448276, 0.6781857451403888, 0.6796536796536796, 0.6789587852494577, 0.6804347826086956, 0.6797385620915033, 0.6812227074235808, 0.6827133479212254, 0.6820175438596491, 0.6813186813186813, 0.6828193832599119, 0.6821192052980133, 0.6836283185840708, 0.6829268292682927, 0.6844444444444444, 0.6837416481069042, 0.6830357142857143, 0.6845637583892618, 0.6838565022421524, 0.6831460674157304, 0.6846846846846847, 0.6839729119638827, 0.6855203619909502, 0.6848072562358276, 0.6840909090909091, 0.683371298405467, 0.682648401826484, 0.6819221967963387, 0.6811926605504587, 0.6804597701149425, 0.6820276497695853, 0.6812933025404158, 0.6805555555555556, 0.6821345707656613, 0.6813953488372093, 0.682983682983683, 0.6845794392523364, 0.6838407494145199, 0.6830985915492958, 0.6823529411764706, 0.6839622641509434, 0.6832151300236406, 0.6848341232227488, 0.684085510688836, 0.6833333333333333, 0.6825775656324582, 0.6842105263157895, 0.6834532374100719, 0.6850961538461539, 0.6867469879518072, 0.6859903381642513, 0.6876513317191283, 0.6868932038834952, 0.6861313868613139, 0.6878048780487804, 0.687041564792176, 0.6887254901960784, 0.687960687960688, 0.6896551724137931, 0.691358024691358, 0.6905940594059405, 0.6898263027295285, 0.6890547263681592, 0.6882793017456359, 0.69, 0.6917293233082706, 0.6934673366834171, 0.6952141057934509, 0.6944444444444444, 0.6936708860759494, 0.6928934010152284, 0.6921119592875318, 0.6913265306122449, 0.690537084398977, 0.6923076923076923, 0.6940874035989717, 0.6932989690721649, 0.6925064599483204, 0.6917098445595855, 0.6935064935064935, 0.6953125, 0.6971279373368147, 0.6989528795811518, 0.6981627296587927, 0.7, 0.6992084432717678, 0.6984126984126984, 0.6976127320954907, 0.6968085106382979, 0.696, 0.6951871657754011, 0.6970509383378016, 0.6989247311827957, 0.7008086253369272, 0.7, 0.6991869918699187, 0.7010869565217391, 0.7002724795640327, 0.6994535519125683, 0.6986301369863014, 0.7005494505494505, 0.7024793388429752, 0.7044198895027625, 0.703601108033241, 0.7055555555555556, 0.7075208913649025, 0.7067039106145251, 0.7086834733893558, 0.7078651685393258, 0.7098591549295775, 0.711864406779661, 0.7138810198300283, 0.7130681818181818, 0.7150997150997151, 0.7171428571428572, 0.7191977077363897, 0.7183908045977011, 0.7175792507204611, 0.7196531791907514, 0.7188405797101449, 0.7180232558139535, 0.7201166180758017, 0.7192982456140351, 0.718475073313783, 0.7205882352941176, 0.7227138643067846, 0.7218934911242604, 0.7240356083086054, 0.7232142857142857, 0.7223880597014926, 0.7245508982035929, 0.7267267267267268, 0.7259036144578314, 0.7250755287009063, 0.7272727272727273, 0.7264437689969605, 0.7286585365853658, 0.72782874617737, 0.7300613496932515, 0.7292307692307692, 0.7283950617283951, 0.7306501547987616, 0.7298136645962733, 0.7320872274143302, 0.73125, 0.7304075235109718, 0.7295597484276729, 0.7287066246056783, 0.7310126582278481, 0.7301587301587301, 0.7292993630573248, 0.7284345047923323, 0.7307692307692307, 0.729903536977492, 0.7322580645161291, 0.7313915857605178, 0.7305194805194806, 0.7296416938110749, 0.7287581699346405, 0.7278688524590164, 0.7302631578947368, 0.7326732673267327, 0.7317880794701986, 0.7342192691029901, 0.7333333333333333, 0.7324414715719063, 0.7348993288590604, 0.734006734006734, 0.7331081081081081, 0.7322033898305085, 0.7312925170068028, 0.7303754266211604, 0.7328767123287672, 0.7319587628865979, 0.7310344827586207, 0.7301038062283737, 0.7326388888888888, 0.7317073170731707, 0.7307692307692307, 0.7298245614035088, 0.7323943661971831, 0.734982332155477, 0.7340425531914894, 0.7330960854092526, 0.7321428571428571, 0.7347670250896058, 0.737410071942446, 0.7364620938628159, 0.7355072463768116, 0.7381818181818182, 0.7372262773722628, 0.73992673992674, 0.7389705882352942, 0.7380073800738007, 0.737037037037037, 0.7360594795539034, 0.7350746268656716, 0.7340823970037453, 0.7330827067669173, 0.7320754716981132, 0.7310606060606061, 0.7300380228136882, 0.732824427480916, 0.735632183908046, 0.7346153846153847, 0.7374517374517374, 0.7364341085271318, 0.7392996108949417, 0.73828125, 0.7372549019607844, 0.7362204724409449, 0.7391304347826086, 0.7380952380952381, 0.7370517928286853, 0.736, 0.7389558232931727, 0.7379032258064516, 0.7408906882591093, 0.7398373983739838, 0.7387755102040816, 0.7377049180327869, 0.7366255144032922, 0.7355371900826446, 0.7344398340248963, 0.7375, 0.7364016736401674, 0.7352941176470589, 0.7341772151898734, 0.7330508474576272, 0.7319148936170212, 0.7350427350427351, 0.7339055793991416, 0.7327586206896551, 0.7359307359307359, 0.7347826086956522, 0.7336244541484717, 0.7368421052631579, 0.73568281938326, 0.7389380530973452, 0.7377777777777778, 0.7366071428571429, 0.7354260089686099, 0.7387387387387387, 0.7375565610859729, 0.7363636363636363, 0.7351598173515982, 0.7385321100917431, 0.7373271889400922, 0.7361111111111112, 0.7348837209302326, 0.7336448598130841, 0.7323943661971831, 0.7311320754716981, 0.7298578199052133, 0.7285714285714285, 0.7272727272727273, 0.7259615384615384, 0.7246376811594203, 0.7233009708737864, 0.7268292682926829, 0.7303921568627451, 0.729064039408867, 0.7277227722772277, 0.7313432835820896, 0.73, 0.7336683417085427, 0.7323232323232324, 0.7309644670050761, 0.7295918367346939, 0.7282051282051282, 0.7268041237113402, 0.7253886010362695, 0.7239583333333334, 0.7277486910994765, 0.7263157894736842, 0.7301587301587301, 0.7340425531914894, 0.732620320855615, 0.7365591397849462, 0.7405405405405405, 0.7391304347826086, 0.7377049180327869, 0.7417582417582418, 0.7403314917127072, 0.7388888888888889, 0.7374301675977654, 0.7415730337078652, 0.7401129943502824, 0.7386363636363636, 0.7371428571428571, 0.735632183908046, 0.7341040462427746, 0.7325581395348837, 0.7309941520467836, 0.7352941176470589, 0.7396449704142012, 0.7380952380952381, 0.7365269461077845, 0.7349397590361446, 0.7333333333333333, 0.7317073170731707, 0.7361963190184049, 0.7345679012345679, 0.7329192546583851, 0.7375, 0.7358490566037735, 0.7341772151898734, 0.732484076433121, 0.7307692307692307, 0.7354838709677419, 0.7337662337662337, 0.7320261437908496, 0.7302631578947368, 0.7284768211920529, 0.7333333333333333, 0.738255033557047, 0.7364864864864865, 0.7346938775510204, 0.7328767123287672, 0.7379310344827587, 0.7361111111111112, 0.7342657342657343, 0.7323943661971831, 0.7304964539007093, 0.7357142857142858, 0.7410071942446043, 0.7391304347826086, 0.7372262773722628, 0.7352941176470589, 0.7333333333333333, 0.7388059701492538, 0.7368421052631579, 0.7424242424242424, 0.7404580152671756, 0.7384615384615385, 0.7441860465116279, 0.7421875, 0.7401574803149606, 0.7380952380952381, 0.744, 0.7419354838709677, 0.7398373983739838, 0.7459016393442623, 0.743801652892562, 0.7416666666666667, 0.7394957983193278, 0.7372881355932204, 0.7350427350427351, 0.7327586206896551, 0.7304347826086957, 0.7368421052631579, 0.7345132743362832, 0.7410714285714286, 0.7387387387387387, 0.7363636363636363, 0.7339449541284404, 0.7314814814814815, 0.7289719626168224, 0.7264150943396226, 0.7333333333333333, 0.7403846153846154, 0.7378640776699029, 0.7450980392156863, 0.7425742574257426, 0.74, 0.7373737373737373, 0.7346938775510204, 0.7319587628865979, 0.7291666666666666, 0.7263157894736842, 0.723404255319149, 0.7204301075268817, 0.7282608695652174, 0.7252747252747253, 0.7222222222222222, 0.7191011235955056, 0.7159090909090909, 0.7241379310344828, 0.7325581395348837, 0.7294117647058823, 0.7261904761904762, 0.7228915662650602, 0.7317073170731707, 0.7283950617283951, 0.7375, 0.7341772151898734, 0.7307692307692307, 0.7272727272727273, 0.7368421052631579, 0.7333333333333333, 0.7297297297297297, 0.726027397260274, 0.7222222222222222, 0.7183098591549296, 0.7142857142857143, 0.7101449275362319, 0.7205882352941176, 0.7313432835820896, 0.7272727272727273, 0.7384615384615385, 0.734375, 0.7301587301587301, 0.7419354838709677, 0.7377049180327869, 0.75, 0.7627118644067796, 0.7758620689655172, 0.7719298245614035, 0.7678571428571429, 0.7636363636363637, 0.7592592592592593, 0.7547169811320755, 0.7692307692307693, 0.7647058823529411, 0.76, 0.7551020408163265, 0.75, 0.7446808510638298, 0.7391304347826086, 0.7555555555555555, 0.75, 0.7441860465116279, 0.7380952380952381, 0.7317073170731707, 0.725, 0.717948717948718, 0.7105263157894737, 0.7027027027027027, 0.6944444444444444, 0.7142857142857143, 0.7058823529411765, 0.7272727272727273, 0.71875, 0.7419354838709677, 0.7666666666666667, 0.7586206896551724, 0.75, 0.7777777777777778, 0.8076923076923077, 0.8, 0.7916666666666666, 0.782608695652174, 0.7727272727272727, 0.7619047619047619, 0.75, 0.7368421052631579, 0.7222222222222222, 0.7058823529411765, 0.6875, 0.7333333333333333, 0.7142857142857143, 0.6923076923076923, 0.6666666666666666, 0.6363636363636364, 0.7, 0.6666666666666666, 0.625, 0.7142857142857143, 0.6666666666666666, 0.6, 0.5, 0.3333333333333333, 0.5, 1.0, 1.0], "recall": [1.0, 1.0, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9916666666666667, 0.9916666666666667, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.9883333333333333, 0.9883333333333333, 0.9883333333333333, 0.9883333333333333, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.9816666666666667, 0.98, 0.98, 0.98, 0.9783333333333334, 0.9783333333333334, 0.9783333333333334, 0.9783333333333334, 0.9783333333333334, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.975, 0.9733333333333334, 0.9733333333333334, 0.9733333333333334, 0.9716666666666667, 0.97, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9666666666666667, 0.9666666666666667, 0.9666666666666667, 0.965, 0.965, 0.965, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9633333333333334, 0.9616666666666667, 0.9616666666666667, 0.9616666666666667, 0.9616666666666667, 0.9616666666666667, 0.9616666666666667, 0.96, 0.96, 0.96, 0.96, 0.9583333333333334, 0.9583333333333334, 0.9566666666666667, 0.9566666666666667, 0.9566666666666667, 0.9566666666666667, 0.9566666666666667, 0.955, 0.9533333333333334, 0.9533333333333334, 0.9516666666666667, 0.9516666666666667, 0.9516666666666667, 0.9516666666666667, 0.9516666666666667, 0.9516666666666667, 0.95, 0.9483333333333334, 0.9466666666666667, 0.9466666666666667, 0.945, 0.945, 0.945, 0.945, 0.945, 0.945, 0.945, 0.945, 0.945, 0.9433333333333334, 0.9433333333333334, 0.9416666666666667, 0.94, 0.94, 0.9383333333333334, 0.9383333333333334, 0.9383333333333334, 0.9383333333333334, 0.9383333333333334, 0.9366666666666666, 0.9366666666666666, 0.935, 0.9333333333333333, 0.9316666666666666, 0.93, 0.93, 0.9283333333333333, 0.9266666666666666, 0.925, 0.925, 0.925, 0.9233333333333333, 0.9216666666666666, 0.9216666666666666, 0.9216666666666666, 0.92, 0.9183333333333333, 0.9183333333333333, 0.9166666666666666, 0.9166666666666666, 0.9166666666666666, 0.915, 0.915, 0.9133333333333333, 0.9116666666666666, 0.9116666666666666, 0.9116666666666666, 0.91, 0.91, 0.9083333333333333, 0.9083333333333333, 0.9083333333333333, 0.9083333333333333, 0.9083333333333333, 0.9066666666666666, 0.905, 0.905, 0.9033333333333333, 0.9016666666666666, 0.9, 0.9, 0.9, 0.9, 0.9, 0.8983333333333333, 0.8966666666666666, 0.8966666666666666, 0.8966666666666666, 0.8966666666666666, 0.8966666666666666, 0.8966666666666666, 0.8966666666666666, 0.895, 0.8933333333333333, 0.8933333333333333, 0.8916666666666667, 0.89, 0.8883333333333333, 0.8883333333333333, 0.8866666666666667, 0.8866666666666667, 0.8866666666666667, 0.8866666666666667, 0.885, 0.885, 0.885, 0.8833333333333333, 0.8833333333333333, 0.8833333333333333, 0.8816666666666667, 0.88, 0.8783333333333333, 0.8783333333333333, 0.8783333333333333, 0.8783333333333333, 0.8766666666666667, 0.875, 0.875, 0.8733333333333333, 0.8733333333333333, 0.8733333333333333, 0.8716666666666667, 0.87, 0.8683333333333333, 0.8683333333333333, 0.8683333333333333, 0.8683333333333333, 0.8683333333333333, 0.8666666666666667, 0.865, 0.865, 0.8633333333333333, 0.8633333333333333, 0.8616666666666667, 0.86, 0.86, 0.86, 0.86, 0.8583333333333333, 0.8583333333333333, 0.8566666666666667, 0.855, 0.855, 0.8533333333333334, 0.8533333333333334, 0.8516666666666667, 0.85, 0.85, 0.85, 0.8483333333333334, 0.8483333333333334, 0.8466666666666667, 0.845, 0.8433333333333334, 0.8433333333333334, 0.8416666666666667, 0.84, 0.8383333333333334, 0.8366666666666667, 0.8366666666666667, 0.8366666666666667, 0.835, 0.8333333333333334, 0.8333333333333334, 0.8333333333333334, 0.8333333333333334, 0.8316666666666667, 0.8316666666666667, 0.83, 0.83, 0.83, 0.8283333333333334, 0.8283333333333334, 0.8266666666666667, 0.825, 0.8233333333333334, 0.8216666666666667, 0.8216666666666667, 0.82, 0.8183333333333334, 0.8183333333333334, 0.8183333333333334, 0.8183333333333334, 0.8166666666666667, 0.815, 0.8133333333333334, 0.8116666666666666, 0.8116666666666666, 0.81, 0.81, 0.81, 0.81, 0.8083333333333333, 0.8066666666666666, 0.8066666666666666, 0.8066666666666666, 0.805, 0.805, 0.805, 0.8033333333333333, 0.8033333333333333, 0.8016666666666666, 0.8, 0.8, 0.8, 0.7983333333333333, 0.7966666666666666, 0.795, 0.795, 0.795, 0.795, 0.7933333333333333, 0.7916666666666666, 0.7916666666666666, 0.79, 0.79, 0.7883333333333333, 0.7883333333333333, 0.7883333333333333, 0.7866666666666666, 0.785, 0.7833333333333333, 0.7816666666666666, 0.78, 0.78, 0.78, 0.78, 0.7783333333333333, 0.7783333333333333, 0.7783333333333333, 0.7766666666666666, 0.775, 0.7733333333333333, 0.7733333333333333, 0.7716666666666666, 0.7716666666666666, 0.7716666666666666, 0.7716666666666666, 0.77, 0.77, 0.7683333333333333, 0.7666666666666667, 0.765, 0.765, 0.765, 0.765, 0.765, 0.7633333333333333, 0.7633333333333333, 0.7633333333333333, 0.7633333333333333, 0.7616666666666667, 0.76, 0.7583333333333333, 0.7566666666666667, 0.755, 0.755, 0.7533333333333333, 0.7516666666666667, 0.75, 0.7483333333333333, 0.7483333333333333, 0.7466666666666667, 0.7466666666666667, 0.7466666666666667, 0.7466666666666667, 0.7466666666666667, 0.745, 0.745, 0.7433333333333333, 0.7416666666666667, 0.7416666666666667, 0.7416666666666667, 0.7416666666666667, 0.7416666666666667, 0.7416666666666667, 0.7416666666666667, 0.7416666666666667, 0.7416666666666667, 0.74, 0.7383333333333333, 0.7383333333333333, 0.7366666666666667, 0.7366666666666667, 0.735, 0.7333333333333333, 0.7316666666666667, 0.7316666666666667, 0.73, 0.7283333333333334, 0.7266666666666667, 0.725, 0.7233333333333334, 0.7216666666666667, 0.72, 0.72, 0.7183333333333334, 0.7166666666666667, 0.715, 0.715, 0.715, 0.7133333333333334, 0.7133333333333334, 0.7133333333333334, 0.7133333333333334, 0.7133333333333334, 0.7133333333333334, 0.7116666666666667, 0.7116666666666667, 0.7116666666666667, 0.71, 0.71, 0.71, 0.71, 0.7083333333333334, 0.7083333333333334, 0.7066666666666667, 0.705, 0.7033333333333334, 0.7033333333333334, 0.7016666666666667, 0.7, 0.7, 0.6983333333333334, 0.6966666666666667, 0.6966666666666667, 0.6966666666666667, 0.6966666666666667, 0.6966666666666667, 0.6966666666666667, 0.6966666666666667, 0.695, 0.695, 0.6933333333333334, 0.6933333333333334, 0.6933333333333334, 0.6933333333333334, 0.6933333333333334, 0.6916666666666667, 0.6916666666666667, 0.6916666666666667, 0.69, 0.6883333333333334, 0.6866666666666666, 0.6866666666666666, 0.6866666666666666, 0.685, 0.685, 0.685, 0.6833333333333333, 0.6816666666666666, 0.68, 0.6783333333333333, 0.6766666666666666, 0.6766666666666666, 0.6766666666666666, 0.675, 0.675, 0.6733333333333333, 0.6733333333333333, 0.6716666666666666, 0.67, 0.67, 0.67, 0.6683333333333333, 0.6683333333333333, 0.6683333333333333, 0.6666666666666666, 0.665, 0.6633333333333333, 0.6616666666666666, 0.6616666666666666, 0.6616666666666666, 0.6616666666666666, 0.66, 0.6583333333333333, 0.6583333333333333, 0.6566666666666666, 0.655, 0.6533333333333333, 0.6516666666666666, 0.6516666666666666, 0.6516666666666666, 0.65, 0.65, 0.65, 0.6483333333333333, 0.6466666666666666, 0.645, 0.645, 0.645, 0.645, 0.645, 0.6433333333333333, 0.6416666666666667, 0.64, 0.6383333333333333, 0.6383333333333333, 0.6366666666666667, 0.6366666666666667, 0.6366666666666667, 0.6366666666666667, 0.6366666666666667, 0.635, 0.6333333333333333, 0.6316666666666667, 0.63, 0.6283333333333333, 0.6283333333333333, 0.6266666666666667, 0.625, 0.6233333333333333, 0.6216666666666667, 0.6216666666666667, 0.62, 0.6183333333333333, 0.6183333333333333, 0.6166666666666667, 0.615, 0.6133333333333333, 0.6116666666666667, 0.61, 0.6083333333333333, 0.6083333333333333, 0.6083333333333333, 0.6066666666666667, 0.605, 0.6033333333333334, 0.6016666666666667, 0.6, 0.6, 0.5983333333333334, 0.5983333333333334, 0.5966666666666667, 0.5966666666666667, 0.595, 0.595, 0.595, 0.5933333333333334, 0.5933333333333334, 0.5933333333333334, 0.5933333333333334, 0.5933333333333334, 0.5933333333333334, 0.5933333333333334, 0.5916666666666667, 0.5916666666666667, 0.59, 0.5883333333333334, 0.5866666666666667, 0.585, 0.585, 0.5833333333333334, 0.5816666666666667, 0.5816666666666667, 0.58, 0.5783333333333334, 0.5766666666666667, 0.5766666666666667, 0.575, 0.5733333333333334, 0.5733333333333334, 0.5733333333333334, 0.5716666666666667, 0.5716666666666667, 0.5716666666666667, 0.57, 0.5683333333333334, 0.5666666666666667, 0.5666666666666667, 0.565, 0.5633333333333334, 0.5633333333333334, 0.5616666666666666, 0.56, 0.56, 0.56, 0.56, 0.56, 0.5583333333333333, 0.5566666666666666, 0.5566666666666666, 0.555, 0.5533333333333333, 0.5516666666666666, 0.5516666666666666, 0.5516666666666666, 0.55, 0.55, 0.5483333333333333, 0.5466666666666666, 0.545, 0.5433333333333333, 0.5416666666666666, 0.5416666666666666, 0.54, 0.54, 0.54, 0.54, 0.54, 0.5383333333333333, 0.5383333333333333, 0.5383333333333333, 0.5383333333333333, 0.5366666666666666, 0.535, 0.5333333333333333, 0.5316666666666666, 0.5316666666666666, 0.53, 0.5283333333333333, 0.5283333333333333, 0.5283333333333333, 0.5266666666666666, 0.525, 0.525, 0.5233333333333333, 0.5233333333333333, 0.5216666666666666, 0.5216666666666666, 0.52, 0.52, 0.52, 0.5183333333333333, 0.5166666666666667, 0.5166666666666667, 0.515, 0.515, 0.5133333333333333, 0.5133333333333333, 0.5116666666666667, 0.51, 0.51, 0.5083333333333333, 0.5066666666666667, 0.5066666666666667, 0.505, 0.505, 0.5033333333333333, 0.5016666666666667, 0.5, 0.49833333333333335, 0.49666666666666665, 0.495, 0.49333333333333335, 0.49333333333333335, 0.49166666666666664, 0.49, 0.49, 0.48833333333333334, 0.48833333333333334, 0.48833333333333334, 0.4866666666666667, 0.485, 0.48333333333333334, 0.48333333333333334, 0.4816666666666667, 0.4816666666666667, 0.48, 0.47833333333333333, 0.4766666666666667, 0.4766666666666667, 0.475, 0.475, 0.475, 0.47333333333333333, 0.47333333333333333, 0.4716666666666667, 0.47, 0.47, 0.4683333333333333, 0.4683333333333333, 0.4666666666666667, 0.4666666666666667, 0.4666666666666667, 0.465, 0.4633333333333333, 0.46166666666666667, 0.46, 0.46, 0.46, 0.46, 0.46, 0.4583333333333333, 0.45666666666666667, 0.455, 0.4533333333333333, 0.45166666666666666, 0.45, 0.45, 0.45, 0.4483333333333333, 0.44666666666666666, 0.445, 0.445, 0.445, 0.445, 0.445, 0.44333333333333336, 0.44333333333333336, 0.44166666666666665, 0.44, 0.43833333333333335, 0.43666666666666665, 0.435, 0.43333333333333335, 0.43333333333333335, 0.43333333333333335, 0.43333333333333335, 0.43166666666666664, 0.43, 0.43, 0.42833333333333334, 0.4266666666666667, 0.425, 0.425, 0.425, 0.425, 0.42333333333333334, 0.42333333333333334, 0.42333333333333334, 0.4216666666666667, 0.4216666666666667, 0.42, 0.42, 0.42, 0.42, 0.41833333333333333, 0.41833333333333333, 0.41833333333333333, 0.41833333333333333, 0.4166666666666667, 0.415, 0.415, 0.41333333333333333, 0.4116666666666667, 0.4116666666666667, 0.41, 0.4083333333333333, 0.4083333333333333, 0.4083333333333333, 0.4066666666666667, 0.4066666666666667, 0.405, 0.4033333333333333, 0.4033333333333333, 0.4033333333333333, 0.40166666666666667, 0.4, 0.4, 0.3983333333333333, 0.3983333333333333, 0.39666666666666667, 0.39666666666666667, 0.395, 0.3933333333333333, 0.3933333333333333, 0.39166666666666666, 0.39166666666666666, 0.39, 0.3883333333333333, 0.38666666666666666, 0.385, 0.385, 0.38333333333333336, 0.38166666666666665, 0.38, 0.38, 0.37833333333333335, 0.37833333333333335, 0.37666666666666665, 0.375, 0.37333333333333335, 0.37166666666666665, 0.37, 0.37, 0.37, 0.36833333333333335, 0.36833333333333335, 0.36666666666666664, 0.365, 0.365, 0.36333333333333334, 0.3616666666666667, 0.36, 0.35833333333333334, 0.3566666666666667, 0.3566666666666667, 0.355, 0.35333333333333333, 0.3516666666666667, 0.3516666666666667, 0.35, 0.34833333333333333, 0.3466666666666667, 0.3466666666666667, 0.3466666666666667, 0.345, 0.3433333333333333, 0.3416666666666667, 0.3416666666666667, 0.3416666666666667, 0.34, 0.3383333333333333, 0.3383333333333333, 0.33666666666666667, 0.33666666666666667, 0.335, 0.3333333333333333, 0.33166666666666667, 0.33, 0.3283333333333333, 0.32666666666666666, 0.325, 0.3233333333333333, 0.32166666666666666, 0.32, 0.32, 0.32, 0.31833333333333336, 0.31833333333333336, 0.31666666666666665, 0.31666666666666665, 0.315, 0.31333333333333335, 0.31166666666666665, 0.31166666666666665, 0.31, 0.30833333333333335, 0.30666666666666664, 0.30666666666666664, 0.305, 0.305, 0.30333333333333334, 0.3016666666666667, 0.3, 0.29833333333333334, 0.2966666666666667, 0.295, 0.295, 0.29333333333333333, 0.2916666666666667, 0.29, 0.28833333333333333, 0.2866666666666667, 0.2866666666666667, 0.285, 0.2833333333333333, 0.2833333333333333, 0.2816666666666667, 0.28, 0.28, 0.2783333333333333, 0.2783333333333333, 0.27666666666666667, 0.275, 0.2733333333333333, 0.2733333333333333, 0.27166666666666667, 0.27, 0.2683333333333333, 0.2683333333333333, 0.26666666666666666, 0.265, 0.2633333333333333, 0.26166666666666666, 0.26, 0.25833333333333336, 0.25666666666666665, 0.255, 0.25333333333333335, 0.25166666666666665, 0.25, 0.24833333333333332, 0.24833333333333332, 0.24833333333333332, 0.24666666666666667, 0.245, 0.245, 0.24333333333333335, 0.24333333333333335, 0.24166666666666667, 0.24, 0.23833333333333334, 0.23666666666666666, 0.235, 0.23333333333333334, 0.23166666666666666, 0.23166666666666666, 0.23, 0.23, 0.23, 0.22833333333333333, 0.22833333333333333, 0.22833333333333333, 0.22666666666666666, 0.225, 0.225, 0.22333333333333333, 0.22166666666666668, 0.22, 0.22, 0.21833333333333332, 0.21666666666666667, 0.215, 0.21333333333333335, 0.21166666666666667, 0.21, 0.20833333333333334, 0.20833333333333334, 0.20833333333333334, 0.20666666666666667, 0.205, 0.20333333333333334, 0.20166666666666666, 0.2, 0.2, 0.19833333333333333, 0.19666666666666666, 0.19666666666666666, 0.195, 0.19333333333333333, 0.19166666666666668, 0.19, 0.19, 0.18833333333333332, 0.18666666666666668, 0.185, 0.18333333333333332, 0.18333333333333332, 0.18333333333333332, 0.18166666666666667, 0.18, 0.17833333333333334, 0.17833333333333334, 0.17666666666666667, 0.175, 0.17333333333333334, 0.17166666666666666, 0.17166666666666666, 0.17166666666666666, 0.17, 0.16833333333333333, 0.16666666666666666, 0.165, 0.165, 0.16333333333333333, 0.16333333333333333, 0.16166666666666665, 0.16, 0.16, 0.15833333333333333, 0.15666666666666668, 0.155, 0.155, 0.15333333333333332, 0.15166666666666667, 0.15166666666666667, 0.15, 0.14833333333333334, 0.14666666666666667, 0.145, 0.14333333333333334, 0.14166666666666666, 0.14, 0.14, 0.13833333333333334, 0.13833333333333334, 0.13666666666666666, 0.135, 0.13333333333333333, 0.13166666666666665, 0.13, 0.12833333333333333, 0.12833333333333333, 0.12833333333333333, 0.12666666666666668, 0.12666666666666668, 0.125, 0.12333333333333334, 0.12166666666666667, 0.12, 0.11833333333333333, 0.11666666666666667, 0.115, 0.11333333333333333, 0.11166666666666666, 0.11166666666666666, 0.11, 0.10833333333333334, 0.10666666666666667, 0.105, 0.105, 0.105, 0.10333333333333333, 0.10166666666666667, 0.1, 0.1, 0.09833333333333333, 0.09833333333333333, 0.09666666666666666, 0.095, 0.09333333333333334, 0.09333333333333334, 0.09166666666666666, 0.09, 0.08833333333333333, 0.08666666666666667, 0.085, 0.08333333333333333, 0.08166666666666667, 0.08166666666666667, 0.08166666666666667, 0.08, 0.08, 0.07833333333333334, 0.07666666666666666, 0.07666666666666666, 0.075, 0.075, 0.075, 0.075, 0.07333333333333333, 0.07166666666666667, 0.07, 0.06833333333333333, 0.06666666666666667, 0.06666666666666667, 0.065, 0.06333333333333334, 0.06166666666666667, 0.06, 0.058333333333333334, 0.056666666666666664, 0.056666666666666664, 0.055, 0.05333333333333334, 0.051666666666666666, 0.05, 0.04833333333333333, 0.04666666666666667, 0.045, 0.043333333333333335, 0.041666666666666664, 0.041666666666666664, 0.04, 0.04, 0.03833333333333333, 0.03833333333333333, 0.03833333333333333, 0.03666666666666667, 0.035, 0.035, 0.035, 0.03333333333333333, 0.03166666666666667, 0.03, 0.028333333333333332, 0.02666666666666667, 0.025, 0.023333333333333334, 0.021666666666666667, 0.02, 0.018333333333333333, 0.018333333333333333, 0.016666666666666666, 0.015, 0.013333333333333334, 0.011666666666666667, 0.011666666666666667, 0.01, 0.008333333333333333, 0.008333333333333333, 0.006666666666666667, 0.005, 0.0033333333333333335, 0.0016666666666666668, 0.0016666666666666668, 0.0016666666666666668, 0.0]}, "loss": 0.3228740304395895}