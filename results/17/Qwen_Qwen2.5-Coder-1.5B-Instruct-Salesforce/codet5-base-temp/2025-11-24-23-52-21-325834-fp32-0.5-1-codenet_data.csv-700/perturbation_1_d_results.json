{"name": "perturbation_1_d", "predictions": {"real": [1.8293244540691376, 1.9537379741668701, 2.6918476819992065, 1.0492425858974457, 0.37026119232177734, 1.369938313961029, 0.7009096145629883, 0.9422690272331238, 0.4057260751724243, 1.343214213848114, 1.2161758542060852, 0.08703505992889404, 0.0035740137100219727, 1.0384000539779663, -0.6086578369140625, -0.1404118537902832, 1.4996429681777954, 0.5452144145965576, 1.7917563915252686, 1.3423964977264404, 0.9563024044036865, 1.007198542356491, 0.6007383465766907, 0.7183141112327576, 0.6800890564918518, 1.4626127481460571, 1.2488115429878235, 0.9836517572402954, 1.3046595454216003, 3.1297433376312256, 2.0373061895370483, 1.1138567924499512, 1.7879031896591187, 0.9772462844848633, 1.1092587113380432, 1.0546456575393677, 0.7902165651321411, 1.0286431312561035, 1.8156236410140991, 1.7336186170578003, 0.991946280002594, 0.28014278411865234, -0.0634615421295166, 1.5229061841964722, 0.6013789176940918, 0.6004202961921692, 1.1574115753173828, 0.0, 1.1665927171707153, 1.098551630973816, 0.8719771504402161, 1.3841363787651062, 1.3055724203586578, 0.1995633840560913, 0.55912184715271, 1.7400661706924438, 0.7583250999450684, 0.429206907749176, 1.7083657383918762, 1.658440351486206, 0.9029061198234558, 1.291636437177658, 0.8780766725540161, 1.1392067074775696, 0.903518795967102, 1.2914164066314697, 1.061966896057129, 1.171417474746704, 0.7360350489616394, 0.6896906495094299, 0.8849667310714722, 2.423453986644745, 1.3087031841278076, 1.1755459308624268, 0.9272152185440063, 1.5125794410705566, 1.1545037627220154, 1.9481195211410522, 0.7526100873947144, 1.1296428442001343, 1.4992926120758057, 0.8334300518035889, 1.2458903789520264, 0.9505445957183838, 2.70313960313797, 1.2886402010917664, 0.44608092308044434, 1.0315224528312683, 0.18605542182922363, 1.7897425889968872, 0.49757489562034607, 0.7721484005451202, 0.20853161811828613, 0.37676137685775757, 1.0959986448287964, 0.9243238568305969, 0.8970136642456055, 1.0491664409637451, 1.0155632197856903, 0.17319869995117188, 0.8425036668777466, 1.0231947898864746, 0.0, 0.8891417980194092, 1.1608502864837646, 1.0603245496749878, 1.2658370435237885, 2.029054880142212, 1.5366255044937134, 1.4264463186264038, 1.9584789276123047, 1.0759367942810059, 1.8637298345565796, 1.5589264631271362, 0.7677147388458252, 0.9853704571723938, 1.5112382769584656, 0.621799111366272, 1.1772224307060242, 1.0904237627983093, 1.0408375263214111, 1.215607464313507, 2.022564113140106, 0.5563876330852509, 1.3575082421302795, 0.9625837802886963, 2.11715304851532, 1.2885690331459045, 1.503309428691864, 0.9873472452163696, 0.9156044125556946, 0.12277078628540039, 0.720373272895813, 0.8218417167663574, 2.2733633518218994, 0.841370701789856, 1.0377822518348694, 0.8165733814239502, 1.2085089683532715, 1.6452301144599915, 1.3454932570457458, 0.0, 0.6298395395278931, 0.5262233018875122, 0.0, 0.5645496249198914, 0.14279544353485107, 1.0290809273719788, 0.6763173043727875, 0.9113873839378357, 0.9436787962913513, 0.40866976976394653, 0.05805015563964844, 1.146624743938446, 1.3430670499801636, 1.3789308071136475, 1.7122042775154114, 1.5139154195785522, 0.9683406949043274, 1.1292956471443176, 1.0318478345870972, 0.9767179489135742, 0.3605960011482239, 0.6533119678497314, 0.2095167636871338, 1.3512347340583801, 0.6147013902664185, 1.4733578562736511, 0.845422774553299, 1.1307772994041443, 1.0974214673042297, 0.959725022315979, 1.2008607983589172, 1.4444094896316528, 0.3844263553619385, 1.3728265762329102, 1.7224228382110596, 0.8045060932636261, 0.8920130431652069, 1.0313621759414673, 1.3772360682487488, 0.9997944831848145, 1.1580381393432617, 0.5396029353141785, 0.5084309577941895, 1.164909303188324, 0.0, 1.385374128818512, -0.053565025329589844, 0.830124020576477, 1.2962409257888794, 3.317260980606079, 0.4683035612106323, 1.0639768540859222, 2.009427011013031, 0.4947017431259155, 1.255449891090393, 1.4760547876358032, 1.12359619140625, 1.0768927931785583, 0.09476780891418457, 1.178346037864685, 1.1455827951431274, 3.442898392677307, 0.7749289870262146, 0.5562641620635986, 1.2721998691558838, 0.18547344207763672, 1.494325578212738, 0.4418293237686157, 0.885037899017334, 0.49452143907546997, 1.7445231676101685, 0.0, 0.7284761667251587, 2.0230406522750854, 1.9626033306121826, 0.41588225960731506, 2.041224718093872, 0.5462841391563416, 1.0250688791275024, 1.2349743247032166, 0.5618072748184204, 1.4878727793693542, 1.0380691289901733, 0.0, 1.0667675137519836, 1.2556275725364685, 1.0132983922958374, 1.3395556211471558, 0.5564659833908081, 0.0, 0.4080057144165039, 0.5341124534606934, 1.635826587677002, 1.2804052829742432, 0.282751202583313, 0.7191011607646942, 1.332131028175354, 0.31899702548980713, 1.1391758918762207, 1.117809772491455, 0.7510538101196289, 0.436944842338562, 1.260111689567566, 0.8409898281097412, 1.9178301095962524, 1.7287256717681885, 1.414078712463379, 0.6931501030921936, 0.8221932053565979, 2.988597869873047, 0.45470547676086426, 1.2489832043647766, 0.5750198364257812, 1.3601090908050537, 1.0664012432098389, 1.0874481797218323, 0.04328358173370361, 0.8406894207000732, 0.8894253969192505, 0.774875283241272, 1.1174901127815247, -0.07846522331237793, 1.0331648290157318, 1.3658605813980103, 1.3066714406013489, 1.030033826828003, 1.4781490564346313, 1.8957066535949707, 0.26231902837753296, 0.597488522529602, 0.9768121838569641, 1.2393141388893127, 0.7222796678543091, 1.6793924570083618, 0.43402040004730225, 1.4230713844299316, 1.1527972221374512, 0.10825932025909424, 0.8372136354446411, 1.4609661102294922, 0.8412206768989563, 1.959492802619934, 1.9970703125, 1.2015594840049744, 0.9589585363864899, 0.5195157527923584, 1.7920377254486084, 1.9065138101577759, 0.7376067042350769, 1.1604207754135132, 0.987786054611206, 1.3913038969039917, 0.9563546776771545, 1.6164236664772034, 1.1944602131843567, 0.09139704704284668, 1.460611343383789, 0.7033081650733948, 1.3269034624099731, 1.0084578394889832, 1.4888460636138916, 0.6755803227424622, 0.8045229911804199, 0.8795263767242432, 0.8151419162750244, 1.4441858530044556, 1.613250970840454, 0.7313950657844543, 0.9990201592445374, 0.9018778204917908, 0.8020581007003784, 0.8094679415225983, 0.8683226704597473, 0.7402334809303284, 1.1087802648544312, 1.33961820602417, 0.9714324474334717, 1.0958887934684753, 0.1715775728225708, 0.5714857578277588, 1.0298995673656464, 0.8899443447589874, 0.9778990149497986, 1.132146954536438, 1.1198320388793945, 0.15735816955566406, 1.2763959169387817, 0.9318360090255737, 1.3598381280899048, 1.2459530532360077, 1.8540109395980835, 1.3333110213279724, 0.7828387022018433, 0.617355465888977, 0.5940991342067719, 0.8570194244384766, 0.2874366044998169, 0.8215129971504211, 1.0156025290489197, 0.9479228258132935, 0.7136405110359192, 0.855316162109375, 0.9203765392303467, 1.080246925354004, 1.0367664098739624, 1.1391733884811401, 0.6577532887458801, 1.1647922992706299, 0.9808080196380615, 0.8783355951309204, 0.6457153558731079, 1.2423163056373596, 0.8538033366203308, 1.3638466000556946, 1.871225357055664, 0.4625488519668579, 1.220125675201416, 1.335800290107727, 0.3363898992538452, 1.2587990164756775, 1.0991504192352295, -0.06015372276306152, 0.9675174355506897, 1.338596224784851, 0.28269481658935547, 1.529506802558899, 1.302658200263977, 1.2545454502105713, 1.85763680934906, 0.6101264953613281, 0.0, 0.7341830730438232, 0.9111286401748657, 0.6717045307159424, 1.2175102829933167, 1.3245508074760437, 0.9999717473983765, 0.7465314865112305, 0.7196604609489441, 1.1293706893920898, 1.1875231862068176, 1.2203178405761719, 0.2933765649795532, 1.1825509369373322, 1.1825803518295288, 1.2495423555374146, 0.9867143332958221, 0.8961547315120697, 1.4042308926582336, 1.055322676897049, 1.1839114427566528, 2.2822160124778748, 1.4956138134002686, 0.779190182685852, 0.4153224229812622, 0.6651482582092285, 1.690137505531311, 0.6240981817245483, 0.9307377338409424, 0.36178791522979736, 0.982848584651947, 0.5509657859802246, 0.30728888511657715, 0.6943313479423523, 1.2572205066680908, 1.1555441617965698, 1.2967194318771362, 0.8594798445701599, 0.26665937900543213, 0.0, 1.0211361646652222, 0.5078917741775513, 1.6351081132888794, 1.2604737877845764, 0.5544295907020569, 0.9933292865753174, 1.0876561403274536, 1.3218726515769958, 1.0637203454971313, 0.0, 1.2887444496154785, 0.2803255319595337, 1.5187963247299194, 1.2189710140228271, 0.8970340490341187, 1.301929771900177, 1.1339870691299438, 0.4087575674057007, 1.131024956703186, 0.366152286529541, 0.0, 0.6217526793479919, 2.224961042404175, 0.7235508561134338, 1.082373559474945, 0.8490438461303711, 0.3771689534187317, 0.8692996501922607, 0.959760308265686, 0.37141311168670654, 1.0802538990974426, 0.22858238220214844, 0.0, 1.147062361240387, 1.5237412452697754, 0.944167971611023, 1.3936203718185425, 1.3456102013587952, 0.8611382246017456, 0.8779363632202148, 1.1289870738983154, 0.4406806230545044, 1.3232216238975525, 1.3300436735153198, 1.5680984258651733, 1.3120236992835999, 0.8782980442047119, 0.0760420560836792, 1.028429239988327, 1.5477879047393799, 0.4251960515975952, 1.114379346370697, 1.6302491426467896, 0.10321497917175293, 1.5541563034057617, 1.634516954421997, 0.6253388524055481, 0.5959104299545288, 1.189590334892273, 1.251242220401764, 1.3096586465835571, 1.3961042165756226, 0.7334299087524414, 0.9599083662033081, 0.7592250108718872, 0.0, 1.0427074432373047, 1.3076580166816711, 0.0, 1.0354198217391968, 1.5372262001037598, 0.9817221164703369, 1.053773581981659, 1.2550147771835327, 0.0, 0.8534435629844666, 1.0875912308692932, 1.2083697319030762, 1.098483145236969, 1.4714791774749756, 1.328784167766571, 0.8932212591171265, 1.6495203971862793, 0.44298505783081055, 0.602070689201355, 0.964840292930603, 0.4513953924179077, 1.04879230260849, 1.2564977407455444, 0.9651850461959839, 0.825762540102005, 1.262566089630127, 0.347745418548584, 0.861236035823822, 1.598838746547699, 0.9902950525283813, 1.1439728736877441, 1.2272248268127441, 0.8694381713867188, 1.0002781748771667, 1.5501043200492859, 1.2044036388397217, 0.8428698182106018, 0.7216113805770874, 0.8136175274848938, 1.04458349943161, 1.6985334157943726, 0.3459129333496094, 0.9523687362670898, 1.053262710571289, 1.5290740728378296, 1.2387497425079346, 1.3163541555404663, 0.9324183464050293, 0.7591267824172974, 1.1037407517433167, 0.0, 1.1772469878196716, 2.019522547721863, 0.5161714553833008, 1.1679674983024597, 1.2987195253372192, 1.3207526803016663, 1.5093366503715515, 1.1100545525550842, 0.9145004153251648, 0.9188350439071655, 1.6988505721092224, 0.9919716119766235, 1.0197200179100037, 1.1070383191108704, 0.291282594203949, 0.9104980230331421, 0.7116894125938416, 0.0, 0.9768344163894653, 1.278226375579834, 0.8125087022781372, 0.7767064571380615, 1.882032036781311, 0.7487707138061523, 0.9835147261619568, 1.2937885522842407, 0.0, 1.0724305510520935, 0.8765843510627747, 1.1511178016662598, 1.1145181059837341, 1.2801051139831543, 0.9766530990600586, 0.876410961151123, 1.5795671939849854, 1.0624356269836426, 1.2857893109321594, 1.3297923803329468, 0.0, 1.586805820465088, 1.5175793170928955, 0.621524453163147, 0.8592133522033691, 1.3720120191574097, 0.9219294786453247, 1.0015759468078613, 0.684992790222168, 0.794357419013977, 0.5568007230758667, 1.623739242553711, 0.2460615634918213, 1.4004859924316406, 0.9231007099151611, 0.8361159563064575, 1.090027391910553, 0.44631922245025635, 0.0, 1.012239694595337, 0.25208139419555664, 0.0, 1.1225584745407104, 1.8378003239631653, -0.0034637451171875, 1.1331359148025513, 1.5552775859832764, 0.0, 1.0029721856117249, 0.9919040203094482, 0.6824628114700317, 0.6489460468292236, 1.6051543354988098], "samples": [0.704295426607132, 1.2166450917720795, 0.20541781187057495, 1.4980088472366333, 1.2661010921001434, 2.169359028339386, 1.223547786474228, 1.2496763467788696, 1.7079192996025085, 1.5342291295528412, 1.266986459493637, 2.1464139819145203, 0.8138660788536072, 1.2351722121238708, 1.387969970703125, 0.9782916903495789, 0.926670491695404, 1.1771854162216187, 0.5907217264175415, 1.4263545274734497, 1.8178070783615112, 1.24791219830513, 1.3970437347888947, 1.3127423226833344, 1.205078899860382, 1.1368347704410553, 1.350989818572998, 1.0165593028068542, 1.462473839521408, 0.466855525970459, 1.5789450407028198, 1.3888104557991028, 1.2622371912002563, 1.3076452612876892, 1.263496994972229, 2.2642563581466675, 1.00259929895401, 1.379781186580658, 1.5551100969314575, 0.945867270231247, 1.2462545931339264, 0.43758702278137207, 1.5044676065444946, 2.0590363442897797, 0.4889785051345825, 2.0658435821533203, 1.6926892399787903, -0.3953080177307129, 1.1363885402679443, 1.0167097449302673, 0.7160763740539551, 1.207210659980774, 1.7056623995304108, 2.2762083411216736, 1.6416511535644531, 1.6592880487442017, 1.5638761520385742, 1.065119445323944, 1.666932374238968, 1.929220736026764, 0.8741619288921356, 0.9203798770904541, 1.1592112183570862, 1.0573872029781342, 1.0994971096515656, 1.3210230469703674, 1.5910767316818237, 1.1337584257125854, 1.7354336977005005, 0.8782497048377991, 0.9994707703590393, 0.9449124336242676, 1.6495728492736816, 1.307375192642212, 0.9302752614021301, 1.521900713443756, 1.7084857821464539, 1.1774228811264038, 1.4495357871055603, 1.5760060548782349, 1.5061566829681396, 1.327787697315216, 1.271017074584961, 1.8595026135444641, 1.0667124390602112, 1.1222589612007141, 1.2784479856491089, 1.010714203119278, 1.0887228548526764, 1.5120172202587128, 0.9247855544090271, 1.2088401913642883, 1.1314500570297241, 1.375277191400528, 1.1719377040863037, 1.597841203212738, 0.791298121213913, 1.1289930641651154, 0.9880477786064148, 1.3127993047237396, 1.1637761890888214, 1.7497661113739014, 1.1678332090377808, 1.2629185020923615, 1.381336748600006, 1.0879158079624176, 1.267590969800949, 1.5286607444286346, 1.2963333129882812, 1.4522874653339386, 2.1603747606277466, 1.91671222448349, 1.5862475633621216, 0.3893320560455322, 1.432364284992218, 1.5514448881149292, 1.0879510641098022, 0.7915544211864471, 1.0978670716285706, 1.1526966094970703, 1.3996173441410065, 0.5769651234149933, 0.7893469333648682, 0.9785474836826324, 1.1393511295318604, 0.15952444076538086, 1.9532352685928345, 1.4445452690124512, 1.7002882957458496, 1.0407595038414001, 1.2980749607086182, 0.6590269804000854, 1.6374498009681702, 0.871540904045105, 2.9074071645736694, 1.5868800282478333, 1.474707007408142, 1.6607566475868225, 0.7613697648048401, 1.254361629486084, 1.748371183872223, 1.3590425252914429, 2.0800143480300903, 2.979371666908264, 0.6982810497283936, 1.4718704223632812, 2.1050854325294495, 1.5212989151477814, 1.1694764494895935, 0.6273741126060486, 1.560124695301056, 1.2797709703445435, 2.156685531139374, 1.2430779933929443, 1.1801724433898926, 1.5988115072250366, 0.7968408763408661, 1.560244470834732, 3.207860589027405, 0.9683793187141418, 1.640196144580841, 3.0271440744400024, 0.9032166004180908, 0.8994661867618561, 1.396408200263977, 0.9632748961448669, 1.1745266914367676, 1.1203864216804504, 1.3159149289131165, 1.2912914752960205, 1.6294582188129425, 1.1165544986724854, 1.441163718700409, 1.4306155443191528, 1.3398469686508179, 1.8914607763290405, 1.6058472990989685, 1.3228332102298737, 1.2580009400844574, 1.518888533115387, 0.8856720626354218, 1.317026972770691, 1.151277482509613, 1.7282522916793823, 1.2004309296607971, 1.2141987681388855, 1.6755020022392273, 1.5742301940917969, 2.0434396266937256, 1.6238830983638763, 2.3156741857528687, 1.8507513999938965, 2.0087761282920837, 0.8112334311008453, 0.847215324640274, 1.0385345816612244, 1.2857341170310974, 1.0929683446884155, 1.671912044286728, 1.107251763343811, 1.6296263933181763, 1.4160566926002502, 1.2759408056735992, 1.289542317390442, 1.0125262141227722, 1.1105057895183563, 1.1321616768836975, 1.9835070371627808, 0.8704542219638824, 1.4542111158370972, 0.8489703834056854, 1.1676267385482788, 1.2404570579528809, 1.029868096113205, 0.9785718023777008, 1.5378638207912445, 0.7703266441822052, 0.6011930704116821, 0.687191516160965, 1.0588708817958832, 1.258277416229248, 0.9414300918579102, 1.0675268471240997, 1.1352567374706268, 1.2064032554626465, 1.1772719323635101, 1.0178546607494354, 1.3997071087360382, 1.5926268100738525, 1.6200886964797974, 1.2239864468574524, 1.329842209815979, 0.8875483274459839, 0.44267427921295166, 1.8658933639526367, 1.0064817070960999, 1.3509076833724976, 1.29006627202034, 1.8927517533302307, 1.412514328956604, 1.7724051475524902, 1.1471908688545227, 1.3623228967189789, 1.522523581981659, 1.3115063309669495, 1.3815499544143677, 1.253387451171875, 0.942219465970993, 1.6003817915916443, 1.0121427178382874, 1.5764997005462646, 0.5638854503631592, 0.9926786124706268, 0.8346375077962875, 1.6501637697219849, 1.0132026076316833, 1.3989620208740234, 1.447487235069275, 1.412233978509903, 1.626630276441574, 1.4028602242469788, 1.2835692763328552, 0.7412717938423157, 1.353231430053711, 1.288827508687973, 1.3615867495536804, 1.5022254884243011, 1.0769267082214355, 1.4371740520000458, 1.7424140572547913, 0.8178291916847229, 0.6611989438533783, 0.5977421700954437, 1.815824568271637, 1.3702393174171448, 1.49833083152771, 1.2911832928657532, 1.6347913146018982, 2.1949849724769592, 1.1227672398090363, 1.4753431975841522, 1.642696499824524, 1.0218324065208435, 1.0141214281320572, 1.1175513565540314, 1.1392253935337067, 0.994079202413559, 1.144789695739746, 0.9879332184791565, 1.1840055286884308, 1.3764196932315826, 1.6081761717796326, 0.7224728465080261, 1.614112913608551, 1.3441628217697144, 1.1479186117649078, 1.9605582356452942, 1.3182145059108734, 1.3210780918598175, 1.7401331067085266, 1.003393441438675, 1.19895538687706, 1.1644428968429565, 0.6851757764816284, 0.8751519322395325, 1.071251392364502, 1.1893775761127472, 0.9721448421478271, 1.0806642174720764, 1.2456112504005432, 1.1015851646661758, 1.355635017156601, 0.9845351129770279, 1.3259845525026321, 1.5715475976467133, 1.0584417581558228, 1.2868041396141052, 1.4249906539916992, 1.3242219686508179, 1.1256363987922668, 2.2862948775291443, 1.2989411354064941, 1.1962397992610931, 1.480245590209961, 0.9366461336612701, 0.9698144197463989, 1.1185122728347778, 1.1734512746334076, 0.8563818335533142, 1.6140422821044922, 0.9721362590789795, 1.407878577709198, 0.5322563648223877, 1.0679857730865479, 1.5679779648780823, 0.9980035424232483, 0.8462454974651337, 1.1045269072055817, 1.2196027636528015, 1.152195394039154, 1.4592896699905396, 2.565943479537964, 1.0197563767433167, 1.2614279985427856, 1.416884571313858, 1.3100956678390503, 1.1329706311225891, 1.3790199160575867, 1.1059990525245667, 1.2576123476028442, 1.772524654865265, 1.0906349420547485, 0.862412691116333, 1.1522102355957031, 1.230934500694275, 1.231103539466858, 1.4984111785888672, 1.1903263926506042, 1.0853297710418701, 1.4310059547424316, 1.079439789056778, 1.3028206825256348, 1.3260457515716553, 1.1574161648750305, 1.0361422300338745, 1.433118999004364, 1.268428087234497, 0.8091881275177002, 2.136352300643921, 1.3593688607215881, 1.5291456282138824, 1.1134300827980042, 1.1320554912090302, 1.2280984073877335, 1.1510066092014313, 1.1495394110679626, 1.0502680540084839, 1.5024750530719757, 0.9994299113750458, 0.8541699051856995, 1.1892880499362946, 1.034443199634552, 1.5906853675842285, 1.051764726638794, 0.813997209072113, 1.0568223595619202, 1.0849710702896118, 1.108401119709015, 1.2177935242652893, 1.2226298451423645, 1.1221251785755157, 1.6531939506530762, 1.9125275015830994, 1.1517838537693024, 1.8486950397491455, 1.8948920965194702, 0.6865853071212769, 1.0797978639602661, 2.5254518389701843, 1.7090296745300293, 1.1952024698257446, 1.5268107652664185, 1.3861675262451172, 1.0427025854587555, 1.5622895956039429, 1.1469527184963226, 1.389544129371643, 1.5909292101860046, 0.9781778752803802, 1.1061182618141174, 0.9361467957496643, 1.411569356918335, 0.9876033663749695, 0.9427287578582764, 1.0428822934627533, 1.1550447940826416, 0.7323509752750397, 1.4891845285892487, 1.176453411579132, 1.3228664100170135, 0.8660008907318115, 1.1507278084754944, 1.985066294670105, 1.6745426058769226, 1.169682264328003, 1.997563123703003, 1.1083701848983765, 1.1921851634979248, 1.6891633868217468, 1.541782259941101, 1.1580698490142822, 1.6302505731582642, 1.3587679266929626, 1.1303688287734985, 1.1749109029769897, 1.5499538779258728, 1.8191649913787842, 2.2612590193748474, 1.2920477986335754, 0.9258769750595093, 0.8311620950698853, 1.098183125257492, 1.0754201710224152, 1.6744210124015808, 1.3676145374774933, 1.2186851799488068, 2.0380244851112366, 1.236427903175354, 1.1210089027881622, 1.8932119607925415, 1.2870070338249207, 1.1498138904571533, 1.03521528840065, 1.025587558746338, 1.6507126986980438, 1.5145862698554993, 1.0566663444042206, 1.3482292592525482, 1.3756867051124573, 1.1960129737854004, 1.1599377393722534, 0.9096392095088959, 1.2288612127304077, 1.0288515388965607, 1.4193371534347534, 1.7243556082248688, 1.3680586218833923, 1.1206701397895813, 0.9051596820354462, 0.7361465096473694, 0.760146290063858, 0.9143967628479004, 0.7053901553153992, 1.5961440801620483, 0.9938146770000458, 1.117104947566986, 1.2113577723503113, 0.9130110442638397, 1.3960309028625488, 1.8973798155784607, 1.180037260055542, 1.089051604270935, 1.0145448446273804, 0.8680275976657867, 0.7895094752311707, 1.2703297138214111, 1.0712167024612427, 0.9266997277736664, 1.4895581007003784, 1.5815211832523346, 1.0241487324237823, 1.688148021697998, 1.2054651081562042, 1.3481887876987457, 1.6376196146011353, 1.2132959961891174, 1.398260921239853, 1.5907636880874634, 1.057367742061615, 1.034636527299881, 0.9330936074256897, 1.176180124282837, 1.2166400849819183, 1.424383521080017, 0.9038598537445068, 0.940910130739212, 0.8746259212493896, 1.5349844098091125, 0.9379527568817139, 2.0558372139930725, 1.1846935451030731, 1.7115710973739624, 1.216897964477539, 1.377115786075592, 1.0117459297180176, 1.0074844360351562, 1.0172963440418243, 1.3117877840995789, 1.3919785022735596, 1.222883939743042, 1.3115801811218262, 1.046728491783142, 1.4422916173934937, 1.069156289100647, 1.7146397829055786, 1.3768345713615417, 1.3526922762393951, 1.212364912033081, 0.9080702066421509, 1.2691526412963867, 1.353722631931305, 1.2430974245071411, 1.1486774384975433, 1.254817545413971, 1.594266414642334, 1.2328870296478271, 1.3679658770561218, 1.0430608093738556, 1.2508080899715424, 1.5810672640800476, 1.1743112206459045, 1.0618398189544678, 1.3772835731506348, 0.9949979037046432, 0.9195377826690674, 1.3463067412376404, 1.197097271680832, 1.0972604155540466, 1.4276695847511292, 1.6599546670913696, 1.3961252570152283, 1.4806302189826965, 1.6941949129104614, 1.451444923877716, 1.3871862888336182, 1.812986671924591, 1.9716114401817322, 1.6600520610809326, 1.6952641606330872, 1.5577008724212646, 1.4055846333503723, 1.2163532972335815, 1.405575454235077, 1.6191138625144958, 1.2060585021972656, 1.1368648409843445, 1.294727623462677, 1.0927823781967163, 1.415623277425766, 0.9997138381004333, 1.102371335029602, 0.9646437466144562, 1.1977559328079224, 0.8274329006671906, 1.1232814490795135, 1.2917766571044922, 1.5479837954044342, 1.2606454193592072, 1.1773244142532349, 1.6801527738571167, 1.407034993171692, 1.6855623126029968, 1.3264922499656677, 1.804178237915039, 0.9886779189109802, 1.6188422441482544, 1.7551791667938232, 1.798897624015808, 0.9383522272109985, 1.217850148677826, 1.5637755393981934, 1.5643564760684967, 1.394529014825821, 2.284981846809387, 1.1984339356422424, 1.5889931917190552, 1.230506181716919, 0.9727514684200287, 1.0774833261966705, 1.4432979226112366]}, "info": {"pct_words_masked": 0.5, "span_length": 10, "n_perturbations": 1, "n_samples": 700}, "raw_results": [{"original": "#include <stdio.h>\nint main(void)\n{\n\tint a[10];\n\tint i;\n\tint MAX[3];\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(i = 0; i < 3; i++)\n\t{\n\t\tMAX[i] = 0;\n\t}\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tif(MAX[0] < a[i])\n\t\t{\n\t\t\tMAX[0] = a[i];\n\t\t}\n\t}\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tif(MAX[1] < a[i])\n\t\t{\n\t\t\tif(a[i] < MAX[0])\n\t\t\t{\n\t\t\t\tMAX[1] = a[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tif(MAX[2] < a[i])\n\t\t{\n\t\t\tif(a[i] < MAX[1])\n\t\t\t{\n\t\t\t\tMAX[2] = a[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%d\\n\", MAX[i]);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int heights[10];\n    int i, j;\n    \n    for (i = 0; i < 10; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n    \n    for (i = 0; i < 10; i++) {\n        for (j = i + 1; j < 10; j++) {\n            if (heights[i] < heights[j]) {\n                int temp = heights[i];\n                heights[i] = heights[j];\n                heights[j] = temp;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", heights[0]);\n    printf(\"%d\\n\", heights[1]);\n    printf(\"%d\\n\", heights[2]);\n    \n    return 0;\n}\n", "perturbed_sampled": [" for (i = 0; i < 10; i++) { scanf(\"%d\", &heights[i]); } for (i = 0; i < 10; i++) { for (j = i + 1; j < 10; j++) { if (heights[i]  heights[j] =  return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { <extra_id_4>[<extra_id_5>if(i < 4) {<extra_id_6>] = float.MAX_VALUE;<extra_id_7>int A.size(a[i]); if(s is<extra_id_8>}<extra_id_9>* a[i - 30];<extra_id_10>} int a[i]= a[i];<extra_id_11>( s = A.value<extra_id_12>= [<extra_id_13>] ; for<extra_id_14>{<extra_id_15>[ i ] ><extra_id_16>a[i] < 10; i++) { scanf(\"%d\", &a[i]); } for(i = 0;  = 0; i < 10;  } for(i = 0; i < 10; i++) { if(MAX[1] < a[i]) { if(a[i] < MAX[0]) { MAX[1] = a[i]; } } } for(i = 0; i <  0; i < 3; i++) { printf(\"%d\\n\", MAX[i]); } return 0; }"], "original_ll": -0.3286745846271515, "sampled_ll": -0.3793737590312958, "all_perturbed_sampled_ll": [-1.0836691856384277], "all_perturbed_original_ll": [-2.157999038696289], "perturbed_sampled_ll": -1.0836691856384277, "perturbed_original_ll": -2.157999038696289, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class Main{\n\tpublic static void main(String[] a) throws Exception {\n\t\tint[] heights = new int[10];\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tBufferedReader height = new BufferedReader(new InputStreamReader(System.in));\t\n\t\t\theights[i] = Integer.parseInt(height.readLine());\n\t\t\tSystem.out.println(heights[i]);\n\t\t}\n\t\tArrays.sort(heights);\n\t\tSystem.out.println(heights[0]);\n\t\tSystem.out.println(heights[1]);\n\t\tSystem.out.println(heights[2]);\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Integer[] heights = new Integer[10];\n        \n        for (int i = 0; i < 10; i++) {\n            heights[i] = sc.nextInt();\n        }\n        \n        Arrays.sort(heights, Collections.reverseOrder());\n        \n        System.out.println(heights[0]);\n        System.out.println(heights[1]);\n        System.out.println(heights[2]);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public <extra_id_1>,<extra_id_2>} for (int i = 0; i < 10; i++) { heights[i] = sc.nextInt(); } Arrays.sort(heights, Collections.reverseOrder()); System.out.println(heights[0]); System.out.println(heights[1]); System.out.println(heights[2]); sc.close(); } }"], "perturbed_original": ["public class Main{ public static void main(String[] a) throws Exception { int[]  < 10; i++) { BufferedReader height =  System.out.println(heights[1]); System.out.println(heights[2]); } }"], "original_ll": -0.8593831062316895, "sampled_ll": -0.49140146374702454, "all_perturbed_sampled_ll": [-1.708046555519104], "all_perturbed_original_ll": [-2.8131210803985596], "perturbed_sampled_ll": -1.708046555519104, "perturbed_original_ll": -2.8131210803985596, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\ne = sys.stdin.readlines()\ne = [int(i) for i in e]\nfor i in range(3):\n    m = max(e)\n    e.remove(m)\n    print (m)\n", "sampled": "heights = []\nfor _ in range(10):\n    heights.append(int(input()))\n\nheights.sort(reverse=True)\n\nfor i in range(3):\n    print(heights[i])\n", "perturbed_sampled": ["heights = [] for _ in range(10): heights.append(int(input())) heights.sort(reverse=True) for i in range(3): print(heights[i])"], "perturbed_original": ["import sys e = sys.stdin.readlines() e = [int(i) for i  print (m)"], "original_ll": -1.6235491037368774, "sampled_ll": -0.7311930060386658, "all_perturbed_sampled_ll": [-0.9366108179092407], "all_perturbed_original_ll": [-4.315396785736084], "perturbed_sampled_ll": -0.9366108179092407, "perturbed_original_ll": -4.315396785736084, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main()\n{\nint N, i, a, b, c, max;\n\nscanf(\"%d\", &N);\n\nfor(i=0; i<N; i++){\nscanf(\"%d %d %d\", &a, &b, &c);\n\nif(a<=b && b<=c){\nmax = c;\nif(c*c==a*a+b*b){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(a<=c && c<=b){\nmax = b;\nif(b*b==a*a+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(b<=c && c<=a){\nmax = a;\nif(a*a==b*b+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(b<=a && a<=c){\nmax = c;\nif(c*c==a*a+b*b){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(c<=a && a<=b){\nmax = b;\nif(b*b==a*a+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(c<=b && b<=a){\nmax = a;\nif(a*a==b*b+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\n\n}\n\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        \n        int aa = a * a;\n        int bb = b * b;\n        int cc = c * c;\n        \n        if (aa + bb == cc || aa + cc == bb || bb + cc == aa) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n);  &a, &b, &c); int aa = a * a;  *  cc == bb || bb + cc == aa) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main() { int N, i, a, b, c, max; scanf(\"%d\", &N); for(i=0; i<N; i++){ scanf(\"%d %d %d\", &a,  }else{ puts(\"NO\"); } } else if(a<=c && c<=b){ max  && c<=a){ max = a; if(a*a==b*b+c*c){  puts(\"NO\"); } } else if(c<=b && b<=a){ max = a; if(a*a==b*b+c*c){ puts(\"YES\"); }else{ puts(\"NO\"); } } } return 0; }"], "original_ll": -0.44192495942115784, "sampled_ll": -0.37493956089019775, "all_perturbed_sampled_ll": [-1.872948408126831], "all_perturbed_original_ll": [-1.4911675453186035], "perturbed_sampled_ll": -1.872948408126831, "perturbed_original_ll": -1.4911675453186035, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tScanner kb=new Scanner(System.in);\nint size=kb.nextInt();\nint a[][]=new int[size][3];\nint x,y,z;\nfor(int i=0;i<size;i++){\n\ta[i][0]=kb.nextInt();\n\ta[i][1]=kb.nextInt();\n\ta[i][2]=kb.nextInt();\n}\nfor(int i=0;i<size;i++){\nx=a[i][0];\ny=a[i][1];\nz=a[i][2];\nif(x*x+y*y==z*z||y*y+z*z==x*x||z*z+x*x==y*y){\n\tSystem.out.println(\"YES\");\n}else{\n\tSystem.out.println(\"NO\");\n}\n}\n\t}\n\n}", "sampled": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            int[] sides = new int[3];\n            sides[0] = sc.nextInt();\n            sides[1] = sc.nextInt();\n            sides[2] = sc.nextInt();\n            \n            Arrays.sort(sides);\n            \n            if (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; import java.util.Arrays; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n  i++) { int[] sides = new int[3]; sides[0] = sc.nextInt(); sides[1] = sc.nextInt(); sides[2]  sides[1] == sides[2] *  } }"], "perturbed_original": ["import java.util.Scanner; public class Main{ public  i=0;i<size;i++){ a[i][0]=kb.nextInt(); a[i][1]=kb.nextInt(); a[i][2]=kb.nextInt(); } for(int i=0;i<size;i++){ x=a[i][0]; y=a[i][1]; z=a[i][2]; if(x*x+y*y==z*z||y*y+z*z==x*x||z*z+x*x==y*y){ System.out.println(\"YES\"); }else{ System.out.println(\"NO\"); } } } }"], "original_ll": -0.7276204824447632, "sampled_ll": -0.3389137089252472, "all_perturbed_sampled_ll": [-1.6050148010253906], "all_perturbed_original_ll": [-1.0978816747665405], "perturbed_sampled_ll": -1.6050148010253906, "perturbed_original_ll": -1.0978816747665405, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N = int(input())\nfor i in range(N):\n    triangle = sorted([int(n) for n in input().split()])\n    if triangle[0]**2 + triangle[1]**2 == triangle[2]**2:\n        print('YES')\n    else:\n        print('NO')\n\n", "sampled": "n = int(input())\nfor _ in range(n):\n    sides = list(map(int, input().split()))\n    sides.sort()\n    if sides[0]**2 + sides[1]**2 == sides[2]**2:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["n = int(input()) for _ in range(n):  sides[2]**2: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["N =  in input().split()]) if triangle[0]**2 + triangle[1]**2 == triangle[2]**2: print('YES') else: print('NO')"], "original_ll": -0.8837476372718811, "sampled_ll": -0.6795265078544617, "all_perturbed_sampled_ll": [-2.8488855361938477], "all_perturbed_original_ll": [-2.25368595123291], "perturbed_sampled_ll": -2.8488855361938477, "perturbed_original_ll": -2.25368595123291, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main( void )\n{\n    int a,b,c,d,e,f;\n    float x,y;\n    \n    while(scanf(\"%d %d %d %d %d %d\",&a,&b,&c,&d,&e,&f)!=-1){    \n        y = (float)( c*d -a*f ) / (b*d-a*e); \n        x = (float)( c*e -b*f ) / (a*e-b*d);\n        if(-0.0005<x && x<=0 ){\n            x = 0;\n        }\n        if(-0.0005<y && y<=0 ){\n            y = 0;\n        }\n        printf( \"%.3lf %.3f\\n\",x,y); \n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double a, b, c, d, e, f;\n    \n    while (scanf(\"%lf %lf %lf %lf %lf %lf\", &a, &b, &c, &d, &e, &f) != EOF) {\n        double x, y;\n        double det = a * e - b * d;\n        \n        x = (c * e - b * f) / det;\n        y = (a * f - c * d) / det;\n        \n        printf(\"%.3f %.3f\\n\", x, y);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double  %lf %lf %lf\", &a, &b, &c, &d, &e, &f) != EOF) { double x, y; double det  y = (a * f - c * d) / det; printf(\"%.3f %.3f\\n\", x, y); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main( void ) { int a,b,c,d,e,f; float x,y; while(scanf(\"%d %d %d %d %d %d\",&a,&b,&c,&d,&e,&f)!=-1){ y = (float)( c*d  / (a*e-b*d); if(-0.0005<x && x<=0 ){ x = 0; }  %.3f\\n\",x,y); } return 0; }"], "original_ll": -1.1125622987747192, "sampled_ll": -0.4869227707386017, "all_perturbed_sampled_ll": [-1.7104705572128296], "all_perturbed_original_ll": [-1.8134719133377075], "perturbed_sampled_ll": -1.7104705572128296, "perturbed_original_ll": -1.8134719133377075, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString t[], s;\n\t\t\tdouble a[] = new double[6];\n\t\t\twhile((s = reader.readLine())  != null) {\n\t\t\t\tt = s.split(\" \");\n\t\t\t\tfor(int i = 0;i < a.length;i++) {\n\t\t\t\t\ta[i] = Double.parseDouble(t[i]);\n\t\t\t\t}\n\t\t\t\tdouble z = a[0]*a[4]-a[1]*a[3];\n\t\t\t\tdouble x = (a[4]*a[2]-a[1]*a[5])/z;\n\t\t\t\tdouble y = (-a[3]*a[2]+a[0]*a[5])/z;\n\n\t\t\t\tif(x == -0.0)\n\t\t\t\t\tx = 0.0;\n\t\t\t\tif(y == -0.0)\n\t\t\t\t\ty = 0.0;\n\t\t\t\tSystem.out.printf(\"%4.3f %4.3f\\n\", x, y);\n\n\t\t\t}\n\n\t\t}\n\t\tcatch(IOException e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double a = sc.nextDouble();\n            double b = sc.nextDouble();\n            double c = sc.nextDouble();\n            double d = sc.nextDouble();\n            double e = sc.nextDouble();\n            double f = sc.nextDouble();\n            \n            double det = a * e - b * d;\n            double x = (c * e - b * f) / det;\n            double y = (a * f - c * d) / det;\n            \n            System.out.printf(\"%.3f %.3f%n\", x, y);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  {  = sc.nextDouble(); double b = sc.nextDouble(); double c = sc.nextDouble(); double d = sc.nextDouble(); double e = sc.nextDouble(); double f = sc.nextDouble(); double det = a * e - b * d; double x  double  det; System.out.printf(\"%.3f %.3f%n\", x, y); } sc.close(); } }"], "perturbed_original": ["import java.io.*; class Main { public  new BufferedReader(new InputStreamReader(System.in)); String  != null) { t = s.split(\" \"); for(int i = 0;i < a.length;i++) { a[i] = Double.parseDouble(t[i]); } double z = a[0]*a[4]-a[1]*a[3]; double x = (a[4]*a[2]-a[1]*a[5])/z; double  == -0.0) y = 0.0; System.out.printf(\"%4.3f %4.3f\\n\",  }"], "original_ll": -0.756742537021637, "sampled_ll": -0.4077526330947876, "all_perturbed_sampled_ll": [-1.6574289798736572], "all_perturbed_original_ll": [-1.6990115642547607], "perturbed_sampled_ll": -1.6574289798736572, "perturbed_original_ll": -1.6990115642547607, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor line in sys.stdin:\n    a,b,c,d,e,f = map(float, line.split())\n    print((c*e-b*f)/(a*e-b*d), (a*f-c*d)/(a*e-b*d))", "sampled": "import sys\n\nfor line in sys.stdin:\n    a, b, c, d, e, f = map(float, line.split())\n    \n    # Using Cramer's rule\n    # ax + by = c\n    # dx + ey = f\n    \n    det = a * e - b * d\n    \n    if det != 0:\n        x = (c * e - b * f) / det\n        y = (a * f - c * d) / det\n    else:\n        # This shouldn't happen as per problem statement (unique solution)\n        x = 0\n        y = 0\n    \n    print(f\"{x:.3f} {y:.3f}\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: a, b, c, d, e, f = map(float, line.split()) # Using  - b *  - b * f) / det  det else: # This shouldn't happen as per problem statement (unique solution) x = 0 y = 0 print(f\"{x:.3f} {y:.3f}\")"], "perturbed_original": ["import sys for line in sys.stdin: a,b,c,d,e,f = map(float, line.split()) print((c*e-b*f)/(a*e-b*d), (a*f-c*d)/(a*e-b*d))"], "original_ll": -1.4522068500518799, "sampled_ll": -0.8963740468025208, "all_perturbed_sampled_ll": [-2.6042933464050293], "all_perturbed_original_ll": [-1.8579329252243042], "perturbed_sampled_ll": -2.6042933464050293, "perturbed_original_ll": -1.8579329252243042, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n    int a,b,c,tmp,tmp_a,tmp_b;\n    while(scanf(\"%d%d\", &a, &b)!=EOF){\n        c = 1;\n        if(b > a){tmp = a; a = b; b = tmp;}\n        tmp_a = a;\n        tmp_b = b;\n        for(int i=2; i<=tmp_b; i++){\n            while(tmp_b%i==0 && tmp_a%i==0){\n                c = c*i;\n                tmp_b = tmp_b / i;\n                tmp_a = tmp_a / i;\n            }\n        }\n        printf(\"%d %d\\n\", c, tmp_a*tmp_b*c);\n    }\n    return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint main() {\n    long long a, b;\n    while (scanf(\"%lld %lld\", &a, &b) != EOF) {\n        long long g = gcd(a, b);\n        long long lcm = (a / g) * b;\n        printf(\"%lld %lld\\n\", g, lcm);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> long long gcd(long long a, long long b) { while (b  a %  { long  { long long g = gcd(a, b); long long lcm = (a / g) * b; printf(\"%lld %lld\\n\", g, lcm); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int a,b,c,tmp,tmp_a,tmp_b; while(scanf(\"%d%d\", &a, &b)!=EOF){ c = 1; if(b >  = a; tmp_b = b; for(int  = tmp_b / i; tmp_a = tmp_a / i; } } printf(\"%d %d\\n\", c, tmp_a*tmp_b*c); } return 0; }"], "original_ll": -0.9382491707801819, "sampled_ll": -0.33897343277931213, "all_perturbed_sampled_ll": [-1.8732025623321533], "all_perturbed_original_ll": [-2.281463384628296], "perturbed_sampled_ll": -1.8732025623321533, "perturbed_original_ll": -2.281463384628296, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\npublic class Main{\n\t/*\n\tpublic static long findGcd(long f1, long f2){\n\t\tlong gcd = 1;\n\t\tlong max, min;\n\t\tif(f1 > f2){max = f1; min = f2;}\n\t\telse{max = f2; min = f1;}\n\t\tfor(long i=1; i<=(long)(Math.sqrt(min)+1); i++){\n\t\t\tif(min % i == 0){\n\t\t\t\tlong tmp = min / i;\n\t\t\t\tif((max % tmp) == 0){\n\t\t\t\t\tgcd = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn gcd;\n\t}\n\t*/\n\tstatic long findGcd(long x, long y){\n        for(long i=1; i<=x; i++){\n            if(y*i%x==0){\n                return y*i;\n            }\n        }\n        return 0;\n    }\n\t\n\tpublic static long findlcm(long f1, long f2){\n\t\tlong lcm = 0;\n\t\tlong max, min;\n\t\tif(f1 > f2){max = f1; min = f2;}\n\t\telse{max = f2; min = f1;}\n\t\tlong i=1;\n\t\twhile(lcm == 0){\n\t\t\tif((max * i)%min == 0){\n\t\t\t\tlcm = max * i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn lcm;\n\t}\n\t\n\tpublic static void main(String[] argv) throws NumberFormatException, IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\twhile((line = br.readLine()) != null){\n\t\t\tString[] lineArray = line.split(\" \");\n\t\t\tlong[] factor = {Long.parseLong(lineArray[0]), Long.parseLong(lineArray[1])};\n\t\t\tlong gcd = findGcd(factor[0], factor[1]);\n\t\t\tlong lcm = findlcm(factor[0], factor[1]);\n\t\t\tSystem.out.println(gcd + \" \" + lcm);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            long a = sc.nextLong();\n            long b = sc.nextLong();\n            \n            long gcd = gcd(a, b);\n            long lcm = (a / gcd) * b;\n            \n            System.out.println(gcd + \" \" + lcm);\n        }\n        \n        sc.close();\n    }\n    \n    static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void  { long a = sc.nextLong(); long  \" + lcm); } sc.close(); } static long gcd(long a, long b) { while (b != 0) { long temp = b; b = a % b; a = temp; } return a; } }"], "perturbed_original": ["import java.io.*; public class Main{ /* public  long max, min; if(f1 > f2){max = f1; min = f2;} else{max = f2; min = f1;} for(long i=1; i<=(long)(Math.sqrt(min)+1); i++){ if(min % i == 0){ long tmp = min / i;  } } return gcd; } */ static  return y*i; } } return 0; } public static long findlcm(long f1,   min =   IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while((line = br.readLine()) != null){ String[] lineArray =  findGcd(factor[0], factor[1]); long lcm = findlcm(factor[0], factor[1]); System.out.println(gcd + \" \" + lcm); } } }"], "original_ll": -0.6323391795158386, "sampled_ll": -0.3231864273548126, "all_perturbed_sampled_ll": [-1.5901728868484497], "all_perturbed_original_ll": [-1.8485150337219238], "perturbed_sampled_ll": -1.5901728868484497, "perturbed_original_ll": -1.8485150337219238, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\ntry:\n while 1:\n  a,b=map(int,input().split())\n  print(math.gcd(a,b),a*b// math.gcd(a, b))\nexcept:\n   pass\n ", "sampled": "import sys\nimport math\n\nfor line in sys.stdin:\n    a, b = map(int, line.split())\n    gcd = math.gcd(a, b)\n    lcm = (a * b) // gcd\n    print(gcd, lcm)\n", "perturbed_sampled": ["import sys import  gcd = math.gcd(a, b) lcm = (a * b) // gcd print(gcd, lcm)"], "perturbed_original": ["import math try: while 1: a,b=map(int,input().split()) print(math.gcd(a,b),a*b// math.gcd(a, b)) except: pass"], "original_ll": -1.8181451559066772, "sampled_ll": -0.8229323029518127, "all_perturbed_sampled_ll": [-2.969346284866333], "all_perturbed_original_ll": [-1.9051802158355713], "perturbed_sampled_ll": -2.969346284866333, "perturbed_original_ll": -1.9051802158355713, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio,h>\n#include<string.h>\nint main(){\nchar a[20];\nint l,i;\nscanf(\"%s\",a);\nl=strlen(a);\nfor(i=l-1;i>=0;i--)\nprintf(\"%c\",a[i]);\nreturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[21];\n    scanf(\"%s\", str);\n    int len = strlen(str);\n    for (int i = len - 1; i >= 0; i--) {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int  for (int i = len - 1; i >= 0; i--) { printf(\"%c\", str[i]); } printf(\"\\n\"); return 0; }"], "perturbed_original": ["#include<stdio,h> #include<string.h> int main(){ char a[20]; int l,i; scanf(\"%s\",a); l=strlen(a); for(i=l-1;i>=0;i--) printf(\"%c\",a[i]); return 0; }"], "original_ll": -1.330481767654419, "sampled_ll": -0.5266357064247131, "all_perturbed_sampled_ll": [-1.3405017852783203], "all_perturbed_original_ll": [-1.334055781364441], "perturbed_sampled_ll": -1.3405017852783203, "perturbed_original_ll": -1.334055781364441, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n    public static void main (String [] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        char [] str = sc.next().toCharArray();\n        for(int x = str.length-1; x >= 0; x--) {\n            System.out.print(str[x]);\n        }\n\n        System.out.print(\"\\n\");\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        StringBuilder sb = new StringBuilder(str);\n        System.out.println(sb.reverse().toString());\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc =  StringBuilder(str); System.out.println(sb.reverse().toString()); sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main { public static void main (String  str = sc.next().toCharArray(); for(int x = str.length-1; x >= 0; x--) { System.out.print(str[x]); } System.out.print(\"\\n\"); } }"], "original_ll": -1.0031317472457886, "sampled_ll": -0.6778625845909119, "all_perturbed_sampled_ll": [-1.9130347967147827], "all_perturbed_original_ll": [-2.041531801223755], "perturbed_sampled_ll": -1.9130347967147827, "perturbed_original_ll": -2.041531801223755, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "print(input()[::-1])\n", "sampled": "s = input()\nprint(s[::-1])\n", "perturbed_sampled": ["s = input() print(s[::-1])"], "perturbed_original": ["print(input()[::-1])"], "original_ll": -5.913525104522705, "sampled_ll": -3.0255022048950195, "all_perturbed_sampled_ll": [-4.4134721755981445], "all_perturbed_original_ll": [-5.304867267608643], "perturbed_sampled_ll": -4.4134721755981445, "perturbed_original_ll": -5.304867267608643, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(){\n    int n,a=100000; scanf(\"%d\",&n);\n    while(n--){\n        a*=1.05;\n        if(a%1000>0) a=(a/1000+1)*1000;\n        else        a=a/1000*1000;\n    }\n    printf(\"%d\\n\",a);\n    exit(0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int debt = 100000;\n    \n    for (int i = 0; i < n; i++) {\n        debt = debt * 105 / 100;\n        if (debt % 1000 != 0) {\n            debt = (debt / 1000 + 1) * 1000;\n        }\n    }\n    \n    printf(\"%d\\n\", debt);\n    \n    return 0;\n}\n", "perturbed_sampled": [" debt = 100000; for (int i = 0; i < n; i++) { debt = debt *  debt = (debt / 1000 + 1) * 1000; } } printf(\"%d\\n\", debt); return 0; }"], "perturbed_original": ["main(){ int n,a=100000; scanf(\"%d\",&n); while(n--){ a*=1.05; if(a%1000>0) a=(a/1000+1)*1000; else a=a/1000*1000; } printf(\"%d\\n\",a); exit(0); }"], "original_ll": -1.2363612651824951, "sampled_ll": -0.6074500679969788, "all_perturbed_sampled_ll": [-1.5857417583465576], "all_perturbed_original_ll": [-1.095949411392212], "perturbed_sampled_ll": -1.5857417583465576, "perturbed_original_ll": -1.095949411392212, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tdouble sum = 100000;   //????????????10??????\n\t\tint ??? = 0;\t\t\t//?????????????????\u00b1???\n\n\t\t??? = Integer.parseInt(br.readLine());\n\n\t\tfor(int i = 0; i < ???; i++){\n\t\t\tsum = sum * 1.05;\n\t\t\tsum = sum / 1000;\n\t\t\tsum = Math.ceil(sum) * 1000;\n\t\t}\n\n\t\tSystem.out.println(sum);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        long debt = 100000;\n        \n        for (int i = 0; i < n; i++) {\n            debt = (long) Math.ceil(debt * 1.05 / 1000.0) * 1000;\n        }\n        \n        System.out.println(debt);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); long debt =  {  } System.out.println(debt); sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); double sum = 100000; //????????????10?????? int ; } ;<extra_id_13>} public<extra_id_14>) 0; i   } }"], "original_ll": -1.1549588441848755, "sampled_ll": -0.6625598073005676, "all_perturbed_sampled_ll": [-1.5892302989959717], "all_perturbed_original_ll": [-2.654601812362671], "perturbed_sampled_ll": -1.5892302989959717, "perturbed_original_ll": -2.654601812362671, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "x = 100000\nfor i in range(int(input())):\n    x*=1.05\n    x+=999\n    x=x//1000*1000\nprint(x)", "sampled": "import math\n\nn = int(input())\ndebt = 100000\n\nfor _ in range(n):\n    debt = debt * 1.05\n    debt = math.ceil(debt / 1000) * 1000\n\nprint(int(debt))\n", "perturbed_sampled": ["import  range(n): debt = debt * 1.05 debt = math.ceil(debt / 1000) * 1000 print(int(debt))"], "perturbed_original": ["x = 100000 for i in range(int(input())): x*=1.05 x+=999 x=x//1000*1000 print(x)"], "original_ll": -1.5169026851654053, "sampled_ll": -1.1356412172317505, "all_perturbed_sampled_ll": [-2.312826633453369], "all_perturbed_original_ll": [-2.062117099761963], "perturbed_sampled_ll": -2.312826633453369, "perturbed_original_ll": -2.062117099761963, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n \n#define MAX 1000000\n \nchar Prime[MAX];\n \nvoid PrimeSearch_Eratos( void ) //\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\n{\n    int i = 0, j = 0;\n \n    for( i = 0 ; i < MAX ; i ++ ) Prime[i] = 1;\n \n    Prime[0] = 0;\n    Prime[1] = 0;\n \n    for( i = 2 ; i <= sqrt( ( double )MAX ) + 1 ; i ++ ) //double\u306b\u30ad\u30e3\u30b9\u30c8\u3057\u306a\u3044\u3068\n    {                                                   //\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u304c\u306a\u3093\u305f\u3089\n        if( !Prime[i] ) continue;                       //\uff08\u3000\u309c\u0434\u309c\uff09\u30dd\u30ab\u30f3\n \n        for( j = i * 2 ; j <= MAX ; j += i )\n        {\n            Prime[j] = 0;\n        }\n    }\n \n    return ;\n}\n \nint main( void )\n{\n    int n = 0;\n \n    PrimeSearch_Eratos();\n \n    while( scanf( \"%d\", &n ) != EOF )\n    {\n        int i = 0;\n        int Count = 0;\n \n        for( i = 0 ; i <= n ; i ++ )\n        {\n            if( Prime[i] ) Count ++;\n        }\n \n        printf( \"%d\\n\", Count );\n    }\n \n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX 1000000\n\nint is_prime[MAX];\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int prime_count[MAX];\n    prime_count[0] = 0;\n    for (int i = 1; i < MAX; i++) {\n        prime_count[i] = prime_count[i-1] + is_prime[i];\n    }\n    \n    int n;\n    while (scanf(\"%d\", &n) != EOF) {\n        printf(\"%d\\n\", prime_count[n]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <math.h> #define MAX 1000000 int is_prime[MAX]; void sieve() {  is_prime[j] = 0; } } } } int main() { sieve(); int prime_count[MAX]; prime_count[0] = 0; for (int i = 1; i < MAX; i++) { prime_count[i] = prime_count[i-1] + is_prime[i]; } int n; while (scanf(\"%d\", &n) != EOF) { printf(\"%d\\n\", prime_count[n]); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> #define MAX 1000000 char Prime[MAX]; void PrimeSearch_Eratos( void ) //\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9 { int i = 0, j = 0; for( i = 0 ; i < MAX ;  = 0; for( i  + 1 ; i ++ ) //double\u306b\u30ad\u30e3\u30b9\u30c8\u3057\u306a\u3044\u3068 { //\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u304c\u306a\u3093\u305f\u3089 if( !Prime[i] ) continue; //\uff08 \u309c\u0434\u309c\uff09\u30dd\u30ab\u30f3 for( j = i  } int main( void  &n  Count = 0; for( i = 0 ; i <= n ; i ++ ) { if(  return 0; }"], "original_ll": -1.041551113128662, "sampled_ll": -0.3592725992202759, "all_perturbed_sampled_ll": [-0.9499943256378174], "all_perturbed_original_ll": [-2.8333075046539307], "perturbed_sampled_ll": -0.9499943256378174, "perturbed_original_ll": -2.8333075046539307, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = in.readLine();\n\t\twhile (line != null) {\n\t\t\tStringTokenizer tk = new StringTokenizer(line);\n\t\t\tint n = Integer.parseInt(tk.nextToken());\n\t\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\t\tfor(int i = 2; i <= n; i++) {\n\t\t\t\tqueue.add(i);\n\t\t\t}\n\t\t\tint p = queue.remove();\n\t\t\tqueue.add(p);\n\t\t\tdo {\n\t\t\t\twhile (queue.element() != p) {\n\t\t\t\t\tint temp = queue.remove();\n\t\t\t\t\tif (temp % p != 0) {\n\t\t\t\t\t\tqueue.add(temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tqueue.add(queue.remove());\n\t\t\t\tp = queue.remove();\n\t\t\t\tqueue.add(p);\n\t\t\t} while (p != 2);\n\t\t\t\n\t\t\tint length = 0;\n\t\t\twhile (!queue.isEmpty()){\n\t\t\t\tlength ++;\n\t\t\t\tqueue.remove();\n\t\t\t}\n\t\t\tSystem.out.println(length);\n\t\t\tline = in.readLine();\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    private static final int MAX = 1000000;\n    private static boolean[] isPrime;\n    private static int[] primeCount;\n    \n    static {\n        isPrime = new boolean[MAX + 1];\n        primeCount = new int[MAX + 1];\n        \n        // Sieve of Eratosthenes\n        for (int i = 2; i <= MAX; i++) {\n            isPrime[i] = true;\n        }\n        \n        for (int i = 2; i * i <= MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= MAX; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        // Precompute prime counts\n        int count = 0;\n        for (int i = 0; i <= MAX; i++) {\n            if (i >= 2 && isPrime[i]) {\n                count++;\n            }\n            primeCount[i] = count;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            System.out.println(primeCount[n]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { private static final  int[] primeCount; static { isPrime = new boolean[MAX + 1]; primeCount = new  = 2; i <= MAX; i++) {  for (int j = i *   = 0; for (int i = 0; i <= MAX; i++) { if (i >= 2 && isPrime[i]) { count++; } primeCount[i] = count; } } public static void main(String[] args) { Scanner sc  System.out.println(primeCount[n]); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String line =  LinkedList<Integer>(); for(int i = 2; i <= n; i++) { queue.add(i); } int p = queue.remove(); queue.add(p); do { while (queue.element()  p != 0) { queue.add(temp); }  2); int length  = in.readLine(); } } }"], "original_ll": -0.7013206481933594, "sampled_ll": -0.363680362701416, "all_perturbed_sampled_ll": [-1.7900348901748657], "all_perturbed_original_ll": [-2.0437171459198], "perturbed_sampled_ll": -1.7900348901748657, "perturbed_original_ll": -2.0437171459198, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nimport sys\n\nlst=[0 for _ in xrange(999999+1)]\n\ndef is_prime(num):\n  if num%2==0:\n      return 0\n  for x in range(3, int(num**0.5)+1,2):\n    if num % x==0:\n        return 0\n  return 1\n\nlst[1]=0\nlst[2]=1\nfor idx in range(3, len(lst)):\n  lst[idx] = is_prime(idx) + lst[idx-1]\n\nfor line in sys.stdin:\n  print lst[int(line)]", "sampled": "def sieve_of_eratosthenes(limit):\n    if limit < 2:\n        return []\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\nmax_n = 999999\nis_prime = sieve_of_eratosthenes(max_n)\nprime_count = [0] * (max_n + 1)\n\ncount = 0\nfor i in range(max_n + 1):\n    if is_prime[i]:\n        count += 1\n    prime_count[i] = count\n\nimport sys\nfor line in sys.stdin:\n    n = int(line.strip())\n    print(prime_count[n])\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): if limit < 2: return [] is_prime = [True]  i in  limit + 1, i): is_prime[j] = False return is_prime max_n =  1)  is_prime[i]: count += 1 prime_count[i] = count import sys for line in sys.stdin: n = int(line.strip()) print(prime_count[n])"], "perturbed_original": ["import  if num % x==0: return 0 return 1 lst[1]=0 lst[2]=1 for idx in range(3, len(lst)): lst[idx] = is_prime(idx) + lst[idx-1] for line in sys.stdin: print lst[int(line)]"], "original_ll": -1.1764311790466309, "sampled_ll": -0.5249384641647339, "all_perturbed_sampled_ll": [-2.342745542526245], "all_perturbed_original_ll": [-2.1327335834503174], "perturbed_sampled_ll": -2.342745542526245, "perturbed_original_ll": -2.1327335834503174, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nint main(int argc, const char * argv[])\n{\n\n    double x1, y1, x2, y2, x3, y3;\n    double midx1, midx2, midy1, midy2;\n    double circlex, circley;\n    double slant1, slant2;\n    double slice1, slice2;\n    double radius;\n    int i;\n    int input;\n    \n    scanf(\"%d\", &input);\n    for (i = 0; i < input; i++) {\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3);\n        midx1 = (x1 + x2) / 2;\n        midy1 = (y1 + y2) / 2;\n        midx2 = (x1 + x3) / 2;\n        midy2 = (y1 + y3) / 2;\n        slant1 = - (x2 - x1) / (y2 - y1);\n        slant2 = - (x3 - x1) / (y3 - y1);\n        slice1 = midy1 - slant1 * midx1;\n        slice2 = midy2 - slant2 * midx2;\n        circlex = (slice2 - slice1) / (slant1 - slant2);\n        circley = slant1 * circlex + slice1;\n        \n        if (x2 == x1) {\n            circley = midy1;\n            circlex = (circley - slice2) / slant2;\n        }\n        else if (y2 == y1) {\n            circlex = midx1;\n            circley = slant2 * circlex + slice2;\n        }\n        if(x3 == x1) {\n            circley = midy2;\n            circlex = (circley - slice1) / slant1;\n        }\n        else if (y3 == y1) {\n            circlex = midx2;\n            circley = slant1 * circlex + slice1;\n        }\n        if (x2 == x1 && y3 == y1) {\n            circley = midy1;\n            circlex = midx2;\n        }\n        else if (x3 == x1 && y2 == y1){\n            circley = midy2;\n            circlex = midx1;\n        }\n        radius = sqrt((circlex - x1) * (circlex - x1) + (circley - y1) * (circley - y1));\n        printf(\"%0.3f %0.3f %0.3f\\n\", circlex, circley, radius);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        double x1, y1, x2, y2, x3, y3;\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3);\n        \n        double a = 2 * (x2 - x1);\n        double b = 2 * (y2 - y1);\n        double c = x2 * x2 - x1 * x1 + y2 * y2 - y1 * y1;\n        \n        double d = 2 * (x3 - x1);\n        double e = 2 * (y3 - y1);\n        double f = x3 * x3 - x1 * x1 + y3 * y3 - y1 * y1;\n        \n        double px = (c * e - b * f) / (a * e - b * d);\n        double py = (a * f - c * d) / (a * e - b * d);\n        \n        double r = sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));\n        \n        printf(\"%.3f %.3f %.3f\\n\", px, py, r);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int  x1, y1, x2, y2, x3, y3; scanf(\"%lf %lf %lf %lf %lf   - x1 * x1 + y2 * y2 - y1  f = x3 * x3 - x1 * x1 + y3 * y3 - y1 * y1; double px = (c * e - b * f) / (a * e - b * d); double py = (a * f - c * d) / (a * e - b * d);  %.3f %.3f\\n\", px, py, r); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> int main(int argc, const char * argv[]) { double x1, y1, x2,  circley; double slant1, slant2; double  for (i = 0; i < input; i++) { scanf(\"%lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3); midx1 = (x1 + x2) / 2; midy1 = (y1 + y2)  = (y1 +  / (y3 - y1); slice1  slant2 * midx2; circlex = (slice2 - slice1) / (slant1 - slant2); circley = slant1 * circlex + slice1; if (x2 == x1) { circley = midy1;  (y2  circlex + slice2; } if(x3 == x1) { circley = midy2; circlex = (circley - slice1) / slant1;   x1 && y2 == y1){ circley = midy2; circlex = midx1; } radius = sqrt((circlex - x1) * (circlex - x1) + (circley - y1)  } return 0; }"], "original_ll": -0.4801560938358307, "sampled_ll": -0.2777218520641327, "all_perturbed_sampled_ll": [-1.5256340503692627], "all_perturbed_original_ll": [-1.4873546361923218], "perturbed_sampled_ll": -1.5256340503692627, "perturbed_original_ll": -1.4873546361923218, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tint n;\n\t\tdouble x1,x2,x3,y1,y2,y3,xp,yp,r,a1,a2,b1,b2,c1,c2,a,b;\n\t\tn=s.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx1=s.nextDouble();\n\t\t\ty1=s.nextDouble();\n\t\t\tx2=s.nextDouble();\n\t\t\ty2=s.nextDouble();\n\t\t\tx3=s.nextDouble();\n\t\t\ty3=s.nextDouble();\n\t\t\t\n\t\t\ta1=2*(x1-x2);//a\n\t\t\tb1=2*(y1-y2);//b\n\t\t\t//c\n\t\t\tc1=(x1*x1)-(x2*x2)+(y1*y1)-(y2*y2);\n\t\t\ta2=2*(x2-x3);//d\n\t\t\tb2=2*(y2-y3);//e\n\t\t\tc2=(x2*x2)-(x3*x3)+(y2*y2)-(y3*y3);\n\t\t\t\n\t\t\tif(c1*b2-b1*c2==0 ||a1*b2-a2*b1==0)xp=0;\n\t\t\telse\n\t\t\txp=(c1*b2-b1*c2)/(a1*b2-a2*b1);\n\t\t\tif(c1*a2-c2*a1==0 ||a2*b1-a1*b2==0)yp=0;\n\t\t\telse\n\t\t\typ=(c1*a2-c2*a1)/(a2*b1-a1*b2);\n\t\t\t\n\t\t\ta=xp-x1;\n\t\t\ta=a*a;\n\t\t\tb=yp-y1;\n\t\t\tb=b*b;\n\t\t\tr=Math.sqrt(a+b);\n\t\t\tif(r==0)\n\t\t\t\tr=0;\n\t\t\tSystem.out.printf(\"%.3f %.3f %.3f\\n\",xp,yp,r);\n\t\t}//for\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double x1 = sc.nextDouble();\n            double y1 = sc.nextDouble();\n            double x2 = sc.nextDouble();\n            double y2 = sc.nextDouble();\n            double x3 = sc.nextDouble();\n            double y3 = sc.nextDouble();\n            \n            double a = 2 * (x2 - x1);\n            double b = 2 * (y2 - y1);\n            double c = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2;\n            \n            double d = 2 * (x3 - x1);\n            double e = 2 * (y3 - y1);\n            double f = x1 * x1 - x3 * x3 + y1 * y1 - y3 * y3;\n            \n            double px = (b * f - e * c) / (b * d - e * a);\n            double py = (d * c - a * f) / (b * d - e * a);\n            \n            double r = Math.sqrt((x1 - px) * (x1 - px) + (y1 - py) * (y1 - py));\n            \n            System.out.printf(\"%.3f %.3f %.3f\\n\", px, py, r);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i < n; i++) {  =  y3 = sc.nextDouble(); double a = 2 * (x2 - x1); double b = 2 * (y2 - y1); double c = x1 * x1 - x2  double d = 2 * (x3 - x1); double e = 2  - x3 *  px = (b * f - e * c) / (b * d - e * a);  / (b * d - e * a); double r = Math.sqrt((x1 - px)   } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner s=new Scanner(System.in); int n; double x1,x2,x3,y1,y2,y3,xp,yp,r,a1,a2,b1,b2,c1,c2,a,b;  xp=(c1*b2-b1*c2)/(a1*b2-a2*b1); if(c1*a2-c2*a1==0 ||a2*b1-a1*b2==0)yp=0; else yp=(c1*a2-c2*a1)/(a2*b1-a1*b2); a=xp-x1; a=a*a; b=yp-y1; b=b*b; r=Math.sqrt(a+b); if(r==0) r=0; System.out.printf(\"%.3f %.3f %.3f\\n\",xp,yp,r); }//for } }"], "original_ll": -0.6433263421058655, "sampled_ll": -0.2965103089809418, "all_perturbed_sampled_ll": [-1.6935540437698364], "all_perturbed_original_ll": [-1.2440646886825562], "perturbed_sampled_ll": -1.6935540437698364, "perturbed_original_ll": -1.2440646886825562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# coding: utf-8\n\nimport math\n\nn = int(raw_input())\n\nfor i in range(n):\n\tdata = map(float, raw_input().split())\n\tx1 = data[0]\n\ty1 = data[1]\n\tx2 = data[2]\n\ty2 = data[3]\n\tx3 = data[4]\n\ty3 = data[5]\n\n\tk = 0.5 * ( (x3-x2)*(x3-x1) + (y3-y2)*(y3-y1) ) / ( (x2-x1)*(y3-y1) + (y2-y1)*(x3-x1) )\n\n\tx = 0.5 * (x1 + x2) - k * (y2 - y1)\n\ty = 0.5 * (y1 + y2) + k * (x2 - x1)\n\n\tr = math.sqrt( (x-x1)**2 + (y-y1)**2 )\n\n\tprint(\"{:.3f} {:.3f} {:.3f}\".format(x,y,r))", "sampled": "import math\n\ndef circumcircle(x1, y1, x2, y2, x3, y3):\n    # Calculate D (denominator)\n    D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    \n    # Calculate center coordinates\n    ux = ((x1**2 + y1**2) * (y2 - y3) + (x2**2 + y2**2) * (y3 - y1) + (x3**2 + y3**2) * (y1 - y2)) / D\n    uy = ((x1**2 + y1**2) * (x3 - x2) + (x2**2 + y2**2) * (x1 - x3) + (x3**2 + y3**2) * (x2 - x1)) / D\n    \n    # Calculate radius\n    r = math.sqrt((x1 - ux)**2 + (y1 - uy)**2)\n    \n    return ux, uy, r\n\nn = int(input())\nfor _ in range(n):\n    coords = list(map(float, input().split()))\n    x1, y1, x2, y2, x3, y3 = coords\n    px, py, r = circumcircle(x1, y1, x2, y2, x3, y3)\n    print(f\"{px:.3f} {py:.3f} {r:.3f}\")\n", "perturbed_sampled": [" Calculate  y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) #  - y3) + (x2**2 + y2**2) * (y3 - y1) + (x3**2  ((x1**2 + y1**2) * (x3 -  (x3**2 + y3**2) * (x2 - x1)) / D # Calculate radius r = math.sqrt((x1 - ux)**2 + (y1 - uy)**2) return ux, uy, r n = int(input()) for _ in range(n): coords = list(map(float,  print(f\"{px:.3f} {py:.3f} {r:.3f}\")"], "perturbed_original": ["# coding: utf-8 import math n = int(raw_input()) for i in range(n): data = map(float, raw_input().split()) x1 =  x2) - k * (y2 - y1) y = 0.5 * (y1 + y2) + k * (x2 - x1) r = math.sqrt( (x-x1)**2 + (y-y1)**2 ) print(\"{:.3f} {:.3f} {:.3f}\".format(x,y,r))"], "original_ll": -0.6321696639060974, "sampled_ll": -0.3487136662006378, "all_perturbed_sampled_ll": [-1.6614559888839722], "all_perturbed_original_ll": [-1.350483775138855], "perturbed_sampled_ll": -1.6614559888839722, "perturbed_original_ll": -1.350483775138855, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid swap(int *a, int *b){\n  int t=*a;*a=*b;*b=t;\n}\n\nint main(void){\n  int w,n,i,l[31];\n  scanf(\"%d\\n\",&w);\n  scanf(\"%d\\n\",&n);\n  for(i=1;i<=w;i++){\n    l[i]=i;\n  }\n  for(i=0;i<n;i++) {\n    int a,b;\n    scanf(\"%d,%d\\n\",&a,&b);\n    swap(&l[a],&l[b]);\n  }\n  for(i=1;i<=w;i++){\n    printf(\"%d\\n\", l[i]);\n  }\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int w, n;\n    int lines[31];\n    \n    scanf(\"%d\", &w);\n    scanf(\"%d\", &n);\n    \n    // Initialize vertical lines with numbers 1 to w\n    for (int i = 1; i <= w; i++) {\n        lines[i] = i;\n    }\n    \n    // Process each horizontal line\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        scanf(\"%d,%d\", &a, &b);\n        \n        // Swap the values at positions a and b\n        int temp = lines[a];\n        lines[a] = lines[b];\n        lines[b] = temp;\n    }\n    \n    // Print the final state\n    for (int i = 1; i <= w; i++) {\n        printf(\"%d\\n\", lines[i]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int w, n; int lines[31]; scanf(\"%d\", &w);  i++) { lines[i] = i; } // Process each horizontal line for (int i = 0; i < n; i++) { int a, b; scanf(\"%d,%d\", &a, &b); // Swap the values  = lines[b]; lines[b] = temp; } // Print the final state for  lines[i]); } return 0; }"], "perturbed_original": ["#include <stdio.h> void swap(int *a, int *b){ int t=*a;*a=*b;*b=t; } int main(void){ int w,n,i,l[31]; scanf(\"%d\\n\",&w); scanf(\"%d\\n\",&n); for(i=1;i<=w;i++){ l[i]=i; }  } return 0; }"], "original_ll": -0.8598865866661072, "sampled_ll": -0.6135058999061584, "all_perturbed_sampled_ll": [-1.8185847997665405], "all_perturbed_original_ll": [-1.539975643157959], "perturbed_sampled_ll": -1.8185847997665405, "perturbed_original_ll": -1.539975643157959, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class AOJ3_3{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint w = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tint[] values = new int[w];\n\t\tfor(int i=0;i<values.length;i++){\n\t\t\tvalues[i] = i + 1;\n\t\t}\n\t\tfor(int i = 0;i<n;i++){\n\t\t\tString str = sc.next();\n\t\t\tString[] ab = str.split(\",\");\n\t\t\tint a = Integer.parseInt(ab[0]) -1;\n\t\t\tint b = Integer.parseInt(ab[1]) -1;\n\t\t\tint temp = values[a];\n\t\t\tvalues[a] = values[b];\n\t\t\tvalues[b] = temp;\n\t\t}\n\t\tfor(int i = 0;i<w;i++){\n\t\t\tSystem.out.println(values[i]);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System);\n        \n        int w = sc.nextInt();\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        int[] lines = new int[w + 1];\n        for (int i = 1; i <= w; i++) {\n            lines[i] = i;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            \n            int temp = lines[a];\n            lines[a] = lines[b];\n            lines[b] = temp;\n        }\n        \n        for (int i = 1; i <= w; i++) {\n            System.out.println(lines[i]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main {  Scanner(System); int w = sc.nextInt(); int n = sc.nextInt(); sc.nextLine(); int[] lines = new int[w + 1]; for (int i = 1; i <= w; i++)  i < n; i++) { String line = sc.nextLine(); String[] parts = line.split(\",\"); int a = Integer.parseInt(parts[0]); int b = Integer.parseInt(parts[1]); int temp = lines[a];  sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class AOJ3_3{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int w = sc.nextInt(); int n = sc.nextInt(); int[] values = new int[w]; for(int i=0;i<values.length;i++){ values[i] = i + 1; } for(int i = 0;i<n;i++){ String <extra_id_1>values[b] = = values[a]; values[a] = values[b]; values[b] ; }<extra_id_2>-1,1<extra_id_3>; if (w <= 2<extra_id_4>w/2) continue;<extra_id_5>//print(int<extra_id_6>(<extra_id_7>. valueOf ( ) ==<extra_id_8>0 {<extra_id_9>values[a]; } #pragma warning disable<extra_id_10>new System.Security.PermissionRightsException (<extra_id_11>;<extra_id_12>public<extra_id_13>int a {<extra_id_14>;<extra_id_15>String . Format ( Environment<extra_id_16>\"<extra_id_17>,<extra_id_18>; } }"], "original_ll": -0.7398730516433716, "sampled_ll": -0.4858931005001068, "all_perturbed_sampled_ll": [-1.622727870941162], "all_perturbed_original_ll": [-2.2024857997894287], "perturbed_sampled_ll": -1.622727870941162, "perturbed_original_ll": -2.2024857997894287, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\n\ndef solve(w, n):\n    l = [i for i in range(1, w+1)]\n    for _ in range(n):\n        a, b = map(int, input().split(','))\n        l[a], l[b] = l[b], l[a]\n\n    print(*l, sep='\\n')\n\nif __name__ == '__main__':\n    w = int(input())\n    n = int(input())\n    solve(w, n)", "sampled": "w = int(input())\nn = int(input())\n\n# Initialize positions: position[i] = number at position i (0-indexed)\npositions = list(range(1, w + 1))\n\n# Process each horizontal line\nfor _ in range(n):\n    line = input().strip()\n    a, b = map(int, line.split(','))\n    # Swap the numbers at positions a-1 and b-1 (converting to 0-indexed)\n    positions[a-1], positions[b-1] = positions[b-1], positions[a-1]\n\n# Output the final positions\nfor num in positions:\n    print(num)\n", "perturbed_sampled": ["w = int(input()) <extra_id_1>print(pos) # Output the current<extra_id_2>0-indexed for<extra_id_3>(0,<extra_id_4>i<extra_id_5>) print(position_id)<extra_id_6>Print<extra_id_7>w<extra_id_8>positions print(position_id)<extra_id_9>print(position_id) # Process each horizontal line for _ in  Swap the numbers at positions a-1 and b-1 (converting to 0-indexed) positions[a-1], positions[b-1] = positions[b-1], positions[a-1] # Output the final positions for num in positions: print(num)"], "perturbed_original": ["# -*-  b = map(int, input().split(',')) l[a], l[b] = l[b], l[a] print(*l, sep='\\n') if __name__ == '__main__': w = int(input()) n = int(input()) solve(w, n)"], "original_ll": -0.9040843844413757, "sampled_ll": -1.1207647323608398, "all_perturbed_sampled_ll": [-2.471754550933838], "all_perturbed_original_ll": [-2.152895927429199], "perturbed_sampled_ll": -2.471754550933838, "perturbed_original_ll": -2.152895927429199, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main() {\n\tint i = 0, k = 0, n, car[100] = {0}, out[100] = {0};\n\twhile(scanf(\"%d\", &n)!= EOF) {\n\t\tif(n == 0) {\n\t\t\ti--;\n\t\t\tout[k] = car[i];\n\t\t\tk++;\n\t\t} else {\n\t\t\tcar[i] = n;\n\t\t\ti++;\n\t\t}\n\t}\n\tfor(i = 0; i < k; i++) printf(\"%d\\n\", out[i]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int stack[100];\n    int top = -1;\n    int input;\n    \n    while (scanf(\"%d\", &input) != EOF) {\n        if (input == 0) {\n            printf(\"%d\\n\", stack[top]);\n            top--;\n        } else {\n            top++;\n            stack[top] = input;\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main()  (scanf(\"%d\", &input) != EOF) { if (input == 0) { printf(\"%d\\n\", stack[top]); top--; } else { top++; stack[top] = input; } } return 0; }"], "perturbed_original": ["#include <stdio.h> int main() { int i = 0, k = 0, n, car[100] = {0}, out[100] = {0}; while(scanf(\"%d\", &n)!= EOF) { if(n == 0) { i--;  i++; } }  0; }"], "original_ll": -0.9140048027038574, "sampled_ll": -0.6154360175132751, "all_perturbed_sampled_ll": [-1.6319953203201294], "all_perturbed_original_ll": [-1.8976565599441528], "perturbed_sampled_ll": -1.6319953203201294, "perturbed_original_ll": -1.8976565599441528, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n \npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        Stack<Integer> stack = new Stack<Integer>();\n        while(sc.hasNextInt()){\n            int a=sc.nextInt();\n            if(a==0){\n                System.out.println(stack.pop());\n            }else{\n                stack.push(a);\n            }\n        }\n    }\n}", "sampled": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Stack<Integer> stack = new Stack<>();\n        \n        while (sc.hasNext()) {\n            int num = sc.nextInt();\n            if (num == 0) {\n                System.out.println(stack.pop());\n            } else {\n                stack.push(num);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; import java.util.Stack; public class Main { public static void main(String[] args) {   0) { System.out.println(stack.pop()); } else { stack.push(num); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); Stack<Integer>  stack.push(a); } } } }"], "original_ll": -0.7556572556495667, "sampled_ll": -0.43813303112983704, "all_perturbed_sampled_ll": [-1.9006068706512451], "all_perturbed_original_ll": [-2.060316801071167], "perturbed_sampled_ll": -1.9006068706512451, "perturbed_original_ll": -2.060316801071167, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a = []\nwhile True:\n    s = int(input())\n    if s != 0:\n        a.append(s)\n    else:\n        print(a.pop())\n    if len(a) == 0:\n        break", "sampled": "import sys\n\nstack = []\nfor line in sys.stdin:\n    num = int(line.strip())\n    if num == 0:\n        print(stack.pop())\n    else:\n        stack.append(num)\n", "perturbed_sampled": ["import sys stack = [] for line in sys.stdin: num = int(line.strip()) if num == 0: print(stack.pop()) else: stack.append(num)"], "perturbed_original": ["a = [] while True: s ) a len(a) == 0: break"], "original_ll": -1.2067081928253174, "sampled_ll": -1.1285371780395508, "all_perturbed_sampled_ll": [-1.5953927040100098], "all_perturbed_original_ll": [-4.336451530456543], "perturbed_sampled_ll": -1.5953927040100098, "perturbed_original_ll": -4.336451530456543, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main()\n{\n    int n, i;\n    long long int sum;\n    \n    while(scanf(\"%d\", &n) != EOF){\n    \tsum = 0;\n        for (i = n; i <= 600 - n; i += n){\n            sum += i * i;\n        }\n        sum *= n;\n        printf(\"%lld\\n\", sum);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int d;\n    while (scanf(\"%d\", &d) != EOF) {\n        long long area = 0;\n        for (int x = d; x <= 600 - d; x += d) {\n            area += (long long)d * x * x;\n        }\n        printf(\"%lld\\n\", area);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  long long area = 0; for (int  d) { area += (long long)d * x * x; } printf(\"%lld\\n\", area); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main() { int n, i; long long int sum;  n; i <= 600 - n; i += n){ sum +=  return 0; }"], "original_ll": -1.1410733461380005, "sampled_ll": -1.0447417497634888, "all_perturbed_sampled_ll": [-2.6236867904663086], "all_perturbed_original_ll": [-3.178379535675049], "perturbed_sampled_ll": -2.6236867904663086, "perturbed_original_ll": -3.178379535675049, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/**\n * \n * AOJ No. 0014 Integral\n * \n * @author \tyuichirw <y.iky917@gmail.com+>\n * @see\t\thttp://rose.u-aizu.ac.jp/onlinejudge/ProblemSet/description.jsp?id=0014&lang=jp\n */\n\nimport java.util.*;\npublic class Main {\n\t\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int d;\n\t\n\tstatic boolean read() {\n\t\tif(!sc.hasNextInt()) return false;\n\t\td = sc.nextInt();\n\t\treturn true;\n\t}\n\t\n\tstatic int solve() {\n\t\tint ans,n;\n\t\tans = 0; n = 600 / d;\n\t\tfor(int x = d; x < 600; x += d) {\n\t\t\tans += d * ((x * x));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int d = sc.nextInt();\n            long area = 0;\n            \n            for (int x = d; x < 600; x += d) {\n                area += (long) d * x * x;\n            }\n            \n            System.out.println(area);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc =  < 600; x += d) { area += (long) d * x * x; } System.out.println(area); } sc.close(); } }"], "perturbed_original": ["/** * * AOJ No. 0014 Integral * * @author yuichirw <y.iky917@gmail.com+> * @see http://rose.u-aizu.ac.jp/onlinejudge/ProblemSet/description.jsp?id=0014&lang=jp */ import java.util.*; public class Main { static Scanner sc = new Scanner(System.in); static int d; static boolean read() { if(!sc.hasNextInt()) return false; d ans,d ans,n; ans = 0; n <extra_id_5>(D void main(String[] args) { while(read()) { System.out.println(solve()); } } }"], "original_ll": -1.6779203414916992, "sampled_ll": -0.8496086001396179, "all_perturbed_sampled_ll": [-2.2384190559387207], "all_perturbed_original_ll": [-2.7917771339416504], "perturbed_sampled_ll": -2.2384190559387207, "perturbed_original_ll": -2.7917771339416504, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\n\nimport sys\nimport math\n\ndef rectArea(h, w):\n    return h * w\n\n\nfor d in sys.stdin:\n    area = 0\n    d = int(d)\n    for i in range(0, 600, d):\n        area += rectArea(i*i, d)\n\n    print(area)", "sampled": "import sys\n\nfor line in sys.stdin:\n    d = int(line.strip())\n    s = 0\n    x = d\n    while x <= 600 - d:\n        s += d * (x * x)\n        x += d\n    print(s)\n", "perturbed_sampled": ["import sys for line in sys.stdin: d = int(line.strip()) s = 0 x  d * (x * x) x += d print(s)"], "perturbed_original": ["#!/usr/bin/env  w): return h * w for d in sys.stdin: area = 0 d = int(d) for i in range(0, 600, d): area += rectArea(i*i, d) print(area)"], "original_ll": -1.5110434293746948, "sampled_ll": -1.6187463998794556, "all_perturbed_sampled_ll": [-2.880983591079712], "all_perturbed_original_ll": [-3.2989466190338135], "perturbed_sampled_ll": -2.880983591079712, "perturbed_original_ll": -3.2989466190338135, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\t__int64 a, b, sum;\n\tint keta;\n\tint n;\n\tint i;\n\t\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++){\n\t\tscanf(\"%I64u\", &a);\n\t\tscanf(\"%I64u\", &b);\n\t\tsum = a + b;\n\t\t\n\t\tketa = 1;\n\t\twhile (sum / 10 > 0){\n\t\t\tketa++;\n\t\t\tsum /= 10;\n\t\t}\n\t\t\n\t\tif (keta > 80){\n\t\t\tprintf(\"overflow\\n\");\n\t\t}\n\t\telse {\n\t\t\tsum = a + b;\n\t\t\tprintf(\"%I64u\\n\", sum);\n\t\t}\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid reverseString(char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        char temp = str[i];\n        str[i] = str[len - 1 - i];\n        str[len - 1 - i] = temp;\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    while (N--) {\n        char num1[105], num2[105], result[105];\n        scanf(\"%s %s\", num1, num2);\n        \n        int len1 = strlen(num1);\n        int len2 = strlen(num2);\n        \n        // Check if input has more than 80 digits\n        if (len1 > 80 || len2 > 80) {\n            printf(\"overflow\\n\");\n            continue;\n        }\n        \n        // Reverse the strings for easier addition\n        reverseString(num1);\n        reverseString(num2);\n        \n        int maxLen = (len1 > len2) ? len1 : len2;\n        int carry = 0;\n        int resultLen = 0;\n        \n        for (int i = 0; i < maxLen || carry; i++) {\n            int digit1 = (i < len1) ? (num1[i] - '0') : 0;\n            int digit2 = (i < len2) ? (num2[i] - '0') : 0;\n            \n            int sum = digit1 + digit2 + carry;\n            result[resultLen++] = (sum % 10) + '0';\n            carry = sum / 10;\n        }\n        \n        result[resultLen] = '\\0';\n        \n        // Check if result has more than 80 digits\n        if (resultLen > 80) {\n            printf(\"overflow\\n\");\n            continue;\n        }\n        \n        // Reverse result back\n        reverseString(result);\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int len = strlen(str); for (int i = 0; i < len / 2; i++) { char temp = str[i]; str[i] = str[len - 1 - i]; str[len - 1 - i] = temp; } } int main()   int len2 = strlen(num2); // Check if input has   > len2) ? len1 : len2; int carry = 0; int  maxLen || carry; i++) { int digit1 = (i < len1) ?  = digit1 + digit2 + carry; result[resultLen++] = (sum % 10) + '0'; carry = sum / 10; } result[resultLen] = '\\0'; // Check if result has  continue; } // Reverse result back reverseString(result); printf(\"%s\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { __int64 a, b, sum; int keta; int n; int i; scanf(\"%d\", &n); for (i = 0; i < n; i++){ scanf(\"%I64u\", &a); scanf(\"%I64u\", &b); sum  10 > 0){  sum); } } return (0); }"], "original_ll": -0.926114559173584, "sampled_ll": -0.35227280855178833, "all_perturbed_sampled_ll": [-1.6599180698394775], "all_perturbed_original_ll": [-1.9033608436584473], "perturbed_sampled_ll": -1.6599180698394775, "perturbed_original_ll": -1.9033608436584473, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (sc.hasNext()) {\n\t\t\tString s1 = sc.next();\n\t\t\tString s2 = sc.next();\n\t\t\tif (s1.length() > 80 || s2.length() > 80)\n\t\t\t\tSystem.out.println(\"overflow\");\n\t\t\tBigInteger b = new BigInteger(s1).add(new BigInteger(s2));\n\t\t\tSystem.out.println(b.toString().length() > 80 ? \"overflow\" : b);\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\nimport java.math.BigInteger;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String a = sc.nextLine().trim();\n            String b = sc.nextLine().trim();\n            \n            if (a.length() > 80 || b.length() > 80) {\n                System.out.println(\"overflow\");\n                continue;\n            }\n            \n            BigInteger num1 = new BigInteger(a);\n            BigInteger num2 = new BigInteger(b);\n            BigInteger sum = num1.add(num2);\n            \n            String result = sum.toString();\n            if (result.length() > 80) {\n                System.out.println(\"overflow\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.math.BigInteger; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); for (int i = 0;  new BigInteger(a); BigInteger num2 = new BigInteger(b); BigInteger sum  { System.out.println(\"overflow\"); } else { System.out.println(result); } } sc.close(); } }"], "perturbed_original": ["import java.math.BigInteger;  args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s1 = sc.next(); String s2 = sc.next(); if (s1.length() > 80 || s2.length() > 80) System.out.println(\"overflow\");  \"overflow\" : b); } } }"], "original_ll": -0.7646723389625549, "sampled_ll": -0.449149489402771, "all_perturbed_sampled_ll": [-1.712646484375], "all_perturbed_original_ll": [-1.8739310503005981], "perturbed_sampled_ll": -1.712646484375, "perturbed_original_ll": -1.8739310503005981, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = input()\n\nfor i in range(n):\n    a = input(),\n    b = input()\n    c = a + b\n    if len(a) > 80 or len(b) > 80 or len(c) > 80 :\n        print 'overflow'\n    else:\n        print a + b", "sampled": "N = int(input())\nfor _ in range(N):\n    a = input().strip()\n    b = input().strip()\n    \n    # Check if input integers have more than 80 digits\n    if len(a) > 80 or len(b) > 80:\n        print(\"overflow\")\n        continue\n    \n    # Convert to integers and calculate sum\n    num_a = int(a)\n    num_b = int(b)\n    result = num_a + num_b\n    \n    # Check if sum has more than 80 digits\n    if len(str(result)) > 80:\n        print(\"overflow\")\n    else:\n        print(result)\n", "perturbed_sampled": ["N = int(input())  # Check if input integers have more than 80  continue # Convert to integers and calculate sum num_a = int(a)  if sum has more than 80 digits if len(str(result)) > 80: print(\"overflow\") else: print(result)"], "perturbed_original": ["n = input() for i in range(n): a = input(), b = input() c = a + b if len(a) > 80 or len(b)  print a + b"], "original_ll": -1.420418381690979, "sampled_ll": -0.7767795324325562, "all_perturbed_sampled_ll": [-3.0410358905792236], "all_perturbed_original_ll": [-2.4750640392303467], "perturbed_sampled_ll": -3.0410358905792236, "perturbed_original_ll": -2.4750640392303467, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0016\nTresure hunt\n*/\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\ndouble x,y;\nint len,arg;\ndouble PAI=3.14159265;\n\nmain()\n{\n  x=0.0; y=0.0;\n  int argsum = 90; \n\n  while(EOF != scanf(\"%d,%d\",&len,&arg) && (len || arg))\n    {\n      x += cos(((double)argsum)*(PAI/180))*(double)len;\n      y += sin(((double)argsum)*(PAI/180))*(double)len;\n\n      //printf(\"%d:%d %d %d %d\\n\",(int)x,(int)y,argsum,len,arg);\n      argsum -= arg;\n    }\n  printf(\"%d\\n%d\\n\",(int)x,(int)y);\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int d, t;\n    double x = 0.0, y = 0.0;\n    double angle = 90.0; // Start facing north (90 degrees from east)\n    \n    while(1) {\n        scanf(\"%d,%d\", &d, &t);\n        if(d == 0 && t == 0) break;\n        \n        // Move d steps in current direction\n        double rad = angle * M_PI / 180.0;\n        x += d * cos(rad);\n        y += d * sin(rad);\n        \n        // Turn clockwise by t degrees (subtract from angle)\n        angle -= t;\n    }\n    \n    printf(\"%d\\n%d\\n\", (int)x, (int)y);\n    \n    return 0;\n}\n", "perturbed_sampled": [" double x = 0.0, y = 0.0; double angle  t == 0) break; // Move d steps in current direction double rad = angle * M_PI / 180.0; x += d * cos(rad); y += d * sin(rad); // Turn clockwise  printf(\"%d\\n%d\\n\", (int)x, (int)y); return 0; }"], "perturbed_original": ["/* AizuOnline A0016 Tresure hunt */ #include <stdio.h> #include <math.h> #include <float.h> double x,y; int len,arg; double PAI=3.14159265; main() { x=0.0; y=0.0; int argsum = 90; while(EOF != scanf(\"%d,%d\",&len,&arg) && (len  }"], "original_ll": -1.6941131353378296, "sampled_ll": -0.8667120337486267, "all_perturbed_sampled_ll": [-1.8693113327026367], "all_perturbed_original_ll": [-2.4843297004699707], "perturbed_sampled_ll": -1.8693113327026367, "perturbed_original_ll": -2.4843297004699707, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tpublic static void main(String[] aegs){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint a = 0,c=0;\n\t\tString t = \"\";\n\t\tdouble counta =0,countb = 0;\n\t\tdouble rad = 90.0;\n\t\tdouble PI = Math.PI;\n\t\t\n\t\twhile(true){\n\t\t\n\t\t\ttry {\n\t\t\t\tt = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tString[] tt = t.split(\",\",0);\n\t\t\ta = Integer.parseInt(tt[0]);\n\t\t\tc = Integer.parseInt(tt[1]);\n\t\t\tif(a == 0 && c == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tcounta +=  (a * Math.sin(rad*PI/180d));\n\t\t\tcountb +=  (a * Math.cos(rad*PI/180d));\n\t\t\trad = rad - c;\n\t\t\t\n\t\t}\n\t\tSystem.out.println((int)countb);\n\t\tSystem.out.println((int)counta);\n\t\t\n\t}\n\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        double x = 0;\n        double y = 0;\n        double angle = 90; // Starting facing north (90 degrees from east)\n        \n        while (true) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int d = Integer.parseInt(parts[0].trim());\n            int t = Integer.parseInt(parts[1].trim());\n            \n            if (d == 0 && t == 0) {\n                break;\n            }\n            \n            // Move d steps in current direction\n            double radians = Math.toRadians(angle);\n            x += d * Math.cos(radians);\n            y += d * Math.sin(radians);\n            \n            // Turn clockwise by t degrees (subtract because clockwise is negative rotation)\n            angle -= t;\n        }\n        \n        System.out.println((int)x);\n        System.out.println((int)y);\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  Scanner sc = new Scanner(System.in); double x = 0; double y  (90 degrees from east) while (true) { String line = sc.nextLine(); String[] parts = line.split(\",\"); int d = Integer.parseInt(parts[0].trim()); int t = Integer.parseInt(parts[1].trim()); if (d  Move d steps in current direction double radians =  Math.sin(radians); // Turn clockwise by t  } System.out.println((int)x); System.out.println((int)y); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] aegs){ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int  = 0; double  t = br.readLine(); } catch (IOException e) { // TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af e.printStackTrace(); } String[] tt  0 && c == 0){ break; } counta += (a  - c; } System.out.println((int)countb); System.out.println((int)counta); } }"], "original_ll": -0.9656194448471069, "sampled_ll": -0.8754969239234924, "all_perturbed_sampled_ll": [-2.2552781105041504], "all_perturbed_original_ll": [-1.9942625761032104], "perturbed_sampled_ll": -2.2552781105041504, "perturbed_original_ll": -1.9942625761032104, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import turtle\nk = turtle.Turtle()\nk.speed(0)\nk.left(90)\nwhile True:\n    x = map(int,raw_input().split(\",\"))\n    if x[0] == 0 and x[1] == 0:\n        break\n    else:\n        k.fd(x[0])\n        k.right(x[1])\n        continue\nprint int(k.xcor())\nprint int(k.ycor())", "sampled": "import math\n\nx = 0.0\ny = 0.0\nangle = 90.0  # Starting direction: north (90 degrees from east)\n\nwhile True:\n    line = input().strip()\n    d, t = map(int, line.split(','))\n    \n    if d == 0 and t == 0:\n        break\n    \n    # Move d steps in current direction\n    x += d * math.cos(math.radians(angle))\n    y += d * math.sin(math.radians(angle))\n    \n    # Turn clockwise by t degrees (subtract because clockwise is negative)\n    angle -= t\n\nprint(int(x))\nprint(int(y))\n", "perturbed_sampled": ["import math x = 0.0 y = 0.0 angle = 90.0 # Starting direction: north (90 degrees from east) while True: line = input().strip() d, t = map(int, line.split(',')) if  by t degrees (subtract because clockwise is negative) angle -= t print(int(x)) print(int(y))"], "perturbed_original": ["import turtle k =  == 0 and x[1] == 0: break else: k.fd(x[0]) k.right(x[1]) continue print int(k.xcor()) print int(k.ycor())"], "original_ll": -1.1942418813705444, "sampled_ll": -1.1993738412857056, "all_perturbed_sampled_ll": [-2.754483938217163], "all_perturbed_original_ll": [-3.0098655223846436], "perturbed_sampled_ll": -2.754483938217163, "perturbed_original_ll": -3.0098655223846436, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n    int a[5],i,j,k;\n    int x=0;\n\n    for(i=0;i<5;i++){\n        scanf(\"%d\",&a[i]);\n        for(j=0;j<5;j++){\n            if(a[i]>a[j]){\n                x=a[i];\n                a[i]=a[j];\n                a[j]=x;\n            }\n        }\n    }\n    for(k=0;k<5;k++){\n        printf(\"%d \",a[k]);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int arr[5];\n    int i, j, temp;\n    \n    for(i = 0; i < 5; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    for(i = 0; i < 4; i++) {\n        for(j = i + 1; j < 5; j++) {\n            if(arr[i] < arr[j]) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    \n    for(i = 0; i < 5; i++) {\n        if(i > 0) printf(\" \");\n        printf(\"%d\", arr[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int arr[5]; int i, j, temp; for(i = 0; i < 5; i++) { scanf(\"%d\",  for(j = i + 1;  =  for(i = 0; i < 5; i++) { if(i > 0) printf(\" \"); printf(\"%d\", arr[i]); } printf(\"\\n\"); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int  } } } for(k=0;k<5;k++){ printf(\"%d \",a[k]); } return 0; }"], "original_ll": -0.7300270795822144, "sampled_ll": -0.3638063967227936, "all_perturbed_sampled_ll": [-1.3096736669540405], "all_perturbed_original_ll": [-2.4636456966400146], "perturbed_sampled_ll": -1.3096736669540405, "perturbed_original_ll": -2.4636456966400146, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Int implements Comparable<Int>{\n\tpublic int i;\n\tInt(int i){this.i = i;}\n\tpublic int compareTo (Int I){return I.i - this.i;}\n}\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\n\t\t//input\n\t\tScanner sc = new Scanner(System.in).useDelimiter(System.getProperty(\"line.separator\"));\n\t\tString[] s = sc.next().split(\"\\\\s\");\n\t\tInt[] ar = new Int[5];\n\t\tfor(int i=0;i<5;i++){ar[i] = new Int(Integer.parseInt(s[i]));}\n\t\t\n\t\t//calculation\n\t\tArrays.sort(ar);\n\t\t\n\t\t//output\n\t\tfor(int i=0;i<5;i++){\n\t\t\tSystem.out.print(ar[i].i);\n\t\t\tif(i < 4){System.out.print(\" \");}\n\t\t}\n\t\tSystem.out.println();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int[] arr = new int[5];\n        for (int i = 0; i < 5; i++) {\n            arr[i] = sc.nextInt();\n        }\n        Arrays.sort(arr);\n        for (int i = 4; i >= 0; i--) {\n            if (i == 4) {\n                System.out.print(arr[i]);\n            } else {\n                System.out.print(\" \" + arr[i]);\n            }\n        }\n        System.out.println();\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc  = sc.nextInt(); }  { if (i == 4) { System.out.print(arr[i]); } else { System.out.print(\" \" + arr[i]); } } System.out.println(); sc.close(); } }"], "perturbed_original": ["import java.util.*; class Int implements Comparable<Int>{  { public static void main(String[] args) { //input Scanner sc = new Scanner(System.in).useDelimiter(System.getProperty(\"line.separator\")); String[] s = sc.next().split(\"\\\\s\"); Int[]  Arrays.sort(ar); //output for(int i=0;i<5;i++){ System.out.print(ar[i].i); if(i < 4){System.out.print(\" \");} } System.out.println(); } }"], "original_ll": -0.9299836754798889, "sampled_ll": -0.3898261487483978, "all_perturbed_sampled_ll": [-1.6360807418823242], "all_perturbed_original_ll": [-1.921929955482483], "perturbed_sampled_ll": -1.6360807418823242, "perturbed_original_ll": -1.921929955482483, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a = map(int, raw_input().split())\na.sort()\na.reverse()\nprint \" \".join(map(str, a))", "sampled": "numbers = list(map(int, input().split()))\nnumbers.sort(reverse=True)\nprint(' '.join(map(str, numbers)))\n", "perturbed_sampled": ["numbers = list(map(int, input().split())) numbers.sort(reverse=True) print(' '.join(map(str, numbers)))"], "perturbed_original": ["a = map(int, raw_input().split()) a.sort() a.reverse() print \" \".join(map(str, a))"], "original_ll": -1.5471067428588867, "sampled_ll": -1.2694475650787354, "all_perturbed_sampled_ll": [-1.7070345878601074], "all_perturbed_original_ll": [-1.827249526977539], "perturbed_sampled_ll": -1.7070345878601074, "perturbed_original_ll": -1.827249526977539, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void)\n{\nint i,j;\n\nscanf(\"%d\",&i);\nj=1;\nfor(;i>0;i--){\nj*=i;\n}\nprintf(\"%d\\n\",j);\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    long long factorial = 1;\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i <= n; i++) {\n        factorial *= i;\n    }\n    \n    printf(\"%lld\\n\", factorial);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; long long  i <= n; i++) { factorial *= i; } printf(\"%lld\\n\", factorial); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int i,j; scanf(\"%d\",&i); j=1; for(;i>0;i--){ j*=i; } printf(\"%d\\n\",j); return 0; }"], "original_ll": -1.554857850074768, "sampled_ll": -0.49363410472869873, "all_perturbed_sampled_ll": [-1.9981017112731934], "all_perturbed_original_ll": [-1.4913963079452515], "perturbed_sampled_ll": -1.9981017112731934, "perturbed_original_ll": -1.4913963079452515, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.math.*;\n\npublic class Main{\n    public static void main(String[] args){\n\tScanner in = new Scanner(System.in);\n\tint a = in.nextInt();\n\tlong b = 1;\n\n\tfor(int i = 1 ; i <= a ; i++){\n\t    b = b*i;\n\t}\n\tSystem.out.println(b);\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long factorial = 1;\n        for (int i = 2; i <= n; i++) {\n            factorial *= i;\n        }\n        System.out.println(factorial);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  { Scanner  = 1; for (int i = 2; i <= n; i++) { factorial *= i; } System.out.println(factorial); sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.math.*; public  new Scanner(System.in); int a = in.nextInt(); long b = 1; for(int i = 1  System.out.println(b); } }"], "original_ll": -0.9627333879470825, "sampled_ll": -0.4569930136203766, "all_perturbed_sampled_ll": [-2.5160293579101562], "all_perturbed_original_ll": [-2.4856395721435547], "perturbed_sampled_ll": -2.5160293579101562, "perturbed_original_ll": -2.4856395721435547, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "s=int(input())\nans=1\nfor i in range(1,s+1):\n    ans *= i\n\nprint(ans)", "sampled": "n = int(input())\nresult = 1\nfor i in range(1, n + 1):\n    result *= i\nprint(result)\n", "perturbed_sampled": ["n = int(input()) result = 1 for i in range(1, n + 1): result *= i print(result)"], "perturbed_original": ["s=int(input()) ans=1 for i in range(1,s+1): ans *= i print(ans)"], "original_ll": -1.5674026012420654, "sampled_ll": -0.9496647119522095, "all_perturbed_sampled_ll": [-1.438643217086792], "all_perturbed_original_ll": [-2.1687815189361572], "perturbed_sampled_ll": -1.438643217086792, "perturbed_original_ll": -2.1687815189361572, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n  char ch[81];\n  int i;\n\n  gets(ch);\n  for(i = 0; ch[i] != '\\0'; ++i)\n    {\n      if('a' <= ch[i] && ch[i] <= 'z')\n\t{\n\t  ch[i] -= 32;\n\t}\n    }\n  puts(ch);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char c;\n    while ((c = getchar()) != EOF) {\n        putchar(toupper(c));\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <ctype.h> int main() { char c; while  }"], "perturbed_original": ["#include  = 0; ch[i] != '\\0'; ++i) { if('a' <= ch[i] && ch[i] <= 'z') { ch[i] -= 32; } } puts(ch); return 0; }"], "original_ll": -0.8418545126914978, "sampled_ll": -0.750054121017456, "all_perturbed_sampled_ll": [-2.8158977031707764], "all_perturbed_original_ll": [-1.442274808883667], "perturbed_sampled_ll": -2.8158977031707764, "perturbed_original_ll": -1.442274808883667, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n\n        String input = s.nextLine();\n        System.out.println(input.toUpperCase());\n    }\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String text = sc.nextLine();\n        System.out.println(text.toUpperCase());\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main {  Scanner(System.in); String text = sc.nextLine(); System.out.println(text.toUpperCase()); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) {  } }"], "original_ll": -0.935631513595581, "sampled_ll": -0.7259752154350281, "all_perturbed_sampled_ll": [-2.4186644554138184], "all_perturbed_original_ll": [-2.093043088912964], "perturbed_sampled_ll": -2.4186644554138184, "perturbed_original_ll": -2.093043088912964, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "print(input().upper())", "sampled": "print(input().upper())\n", "perturbed_sampled": ["print(input().upper())"], "perturbed_original": ["print(input().upper())"], "original_ll": -6.2531657218933105, "sampled_ll": -6.648473739624023, "all_perturbed_sampled_ll": [-6.2531657218933105], "all_perturbed_original_ll": [-6.2531657218933105], "perturbed_sampled_ll": -6.2531657218933105, "perturbed_original_ll": -6.2531657218933105, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nconst double eps = 1e-10;\n\nint n;\ndouble x1, x2, x3, x4;\ndouble y1, y2, y3, y4;\n\n//\u5897\u52a0\u7387\u3092\u898b\u308b\u65b9\u6cd5\nint solve1() {\n    double r1 = (y2-y1)/(x2-x1);\n    double r2 = (y4-y3)/(x4-x3);\n    return (fabs(r1-r2) < eps);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; ++i) {\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n\n        if(solve1()) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    double x1, y1, x2, y2, x3, y3, x4, y4;\n    double dx1, dy1, dx2, dy2;\n    double cross;\n    \n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n              &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n        \n        dx1 = x2 - x1;\n        dy1 = y2 - y1;\n        dx2 = x4 - x3;\n        dy2 = y4 - y3;\n        \n        cross = dx1 * dy2 - dy1 * dx2;\n        \n        if (fabs(cross) < 1e-9) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  dx2, dy2; double cross; scanf(\"%d\", &n); while (n--) { scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3,  y2 - y1; dx2 = x4 - x3; dy2 = y4 - y3; cross = dx1 * dy2 - dy1 * dx2; if (fabs(cross) <  0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> const double eps = 1e-10; int n; double x1, x2, x3, x4; double y1, y2, y3, y4; //\u5897\u52a0\u7387\u3092\u898b\u308b\u65b9\u6cd5  (y4-y3)/(x4-x3); return (fabs(r1-r2)  i<n; ++i)  &y1, &x2, &y2, &x3, &y3, &x4, &y4); if(solve1()) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } }"], "original_ll": -0.7197741270065308, "sampled_ll": -0.37489426136016846, "all_perturbed_sampled_ll": [-1.5112828016281128], "all_perturbed_original_ll": [-1.886366844177246], "perturbed_sampled_ll": -1.5112828016281128, "perturbed_original_ll": -1.886366844177246, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\n// AOJ 0021\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic final double EPS = 1e-8;\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tdouble[] x = new double[4], y = new double[4];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tx[j] = sc.nextDouble();\n\t\t\t\ty[j] = sc.nextDouble();\n\t\t\t}\n\t\t\t\n\t\t\tComplex \n\t\t\t\tp1 = new Complex(x[0], y[0]),\n\t\t\t\tp2 = new Complex(x[1], y[1]),\n\t\t\t\tp3 = new Complex(x[2], y[2]),\n\t\t\t\tp4 = new Complex(x[3], y[3]);\n\t\t\t\n\t\t\tif (!isCross(p1, p2, p3, p4)) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic boolean isCross(Complex p1, Complex p2, Complex p3, Complex p4) {\n\t\tdouble det = p1.sub(p2).crossProduct(p3.sub(p4));\n\t\tif (Math.abs(det) < Complex.EPS) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nclass Complex {\n\tstatic final double EPS = 1e-10;\n\t\n\tdouble re, im;\n\t\n\tComplex (double r, double i) {\n\t\tre = r; im = i;\n\t}\n\n\tdouble arg() {\n\t\treturn Math.atan2(im, re);\n\t}\n\t\n\tdouble abs2() {\n\t\treturn re * re + im * im;\n\t}\n\t\n\tdouble abs() {\n\t\treturn Math.sqrt(abs2());\n\t}\n\t\n\tdouble innerProdut(Complex o) {\n\t\treturn re * o.re + im * o.im;\n\t}\n\t\n\tdouble crossProduct(Complex o) {\n\t\treturn re * o.im - im * o.re;\n\t}\n\t\n\tstatic Complex polar(double theta, double r) {\n\t\treturn new Complex(r * Math.cos(theta), r * Math.sin(theta));\n\t}\n\t\n\tComplex conj() {\n\t\treturn new Complex(re, -im);\n\t}\n\t\n\tComplex add(Complex o) {\n\t\treturn new Complex(re + o.re, im + o.im);\n\t}\n\n\tComplex sub(Complex o) {\n\t\treturn new Complex(re - o.re, im - o.im);\n\t}\n\t\n\tComplex mul(Complex o) {\n\t\treturn new Complex(re * o.re - im * o.im, re * o.im + im * o.re);\n\t}\n\t\n\tComplex div(Complex o) {\n\t\treturn new Complex((re * o.re + im * o.im) / o.abs2(), (im * o.re - re * o.im) / o.abs2());\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double x1 = sc.nextDouble();\n            double y1 = sc.nextDouble();\n            double x2 = sc.nextDouble();\n            double y2 = sc.nextDouble();\n            double x3 = sc.nextDouble();\n            double y3 = sc.nextDouble();\n            double x4 = sc.nextDouble();\n            double y4 = sc.nextDouble();\n            \n            double dx1 = x2 - x1;\n            double dy1 = y2 - y1;\n            double dx2 = x4 - x3;\n            double dy2 = y4 - y3;\n            \n            double cross = dx1 * dy2 - dy1 * dx2;\n            \n            if (Math.abs(cross) < 1e-9) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i < n; i++) { double  sc.nextDouble(); double y2 = sc.nextDouble(); double x3 = sc.nextDouble(); double y3 = sc.nextDouble(); double  double dx2 = x4 -  dx1 * dy2 - dy1 * dx2; if (Math.abs(cross) < 1e-9) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; import static java.util.Arrays.*; import static java.lang.Math.*; // AOJ 0021 public class Main { static Scanner sc = new Scanner(System.in);  static void main(String[] args) { N = sc.nextInt(); double[] x = new double[4], y = new double[4]; for (int i = 0; i < N; i++) { for (int j =  p3, p4)) { System.out.println(\"YES\"); } else { System.out.println(\"No\"); } } } static boolean isCross(Complex p1, Complex p2, Complex p3, Complex p4) { double det = p1.sub(p2).crossProduct(p3.sub(p4)); if (Math.abs(det) < Complex.EPS) { return false; }  static final double EPS = 1e-10; double re, im; Complex (double  } double arg() { return Math.atan2(im, re); } double abs2() {  abs() { return Math.sqrt(abs2()); } double innerProdut(Complex o)  double crossProduct(Complex o) { return  Math.cos(theta), r * Math.sin(theta)); } Complex conj() { return new Complex(re, -im); } Complex add(Complex o)  im - o.im); } Complex  * o.im, re * o.im + im * o.re); } Complex div(Complex o) {  o.abs2(), (im * o.re - re * o.im) / o.abs2()); } }"], "original_ll": -0.5198462009429932, "sampled_ll": -0.28433889150619507, "all_perturbed_sampled_ll": [-1.3010486364364624], "all_perturbed_original_ll": [-1.618397831916809], "perturbed_sampled_ll": -1.3010486364364624, "perturbed_original_ll": -1.618397831916809, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "ans = []\nn = input()\nfor i in range(n):\n    x1,y1,x2,y2,x3,y3,x4,y4 = map(float,raw_input().split())\n    if ((y2-y1)/(x2-x1) == (y4-y3)/(x4-x3)):\n        ans.append('YES')\n    else:\n        ans.append('NO')\nfor i in ans:\n    print i", "sampled": "n = int(input())\nfor _ in range(n):\n    coords = list(map(float, input().split()))\n    x1, y1, x2, y2, x3, y3, x4, y4 = coords\n    \n    # Direction vectors\n    dx1 = x2 - x1\n    dy1 = y2 - y1\n    dx2 = x4 - x3\n    dy2 = y4 - y3\n    \n    # Two lines are parallel if their direction vectors are parallel\n    # This means the cross product should be zero\n    cross = dx1 * dy2 - dy1 * dx2\n    \n    if abs(cross) < 1e-9:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["n = int(input()) for _ in range(n): coords = list(map(float, input().split())) x1, y1, x2, y2, x3, y3, x4, y4  dy1 = y2 - y1 dx2 = x4 - x3 dy2 = y4 - y3 # Two lines are parallel  print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["ans =  map(float,raw_input().split()) if ((y2-y1)/(x2-x1) == (y4-y3)/(x4-x3)): ans.append('YES') else: ans.append('NO') for i in ans: print i"], "original_ll": -0.8097441792488098, "sampled_ll": -0.7387608289718628, "all_perturbed_sampled_ll": [-1.4548372030258179], "all_perturbed_original_ll": [-1.6817213296890259], "perturbed_sampled_ll": -1.4548372030258179, "perturbed_original_ll": -1.6817213296890259, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct\n{\n    double x;\n    double y;\n    double r;\n}circle;\n\nint main(void)\n{\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    while (datasets--) {\n        circle a, b;\n        scanf(\" %lf %lf %lf\", &(a.x), &(a.y), &(a.r));\n        scanf(\" %lf %lf %lf\", &(b.x), &(b.y), &(b.r));\n\n        double bigr, smallr;\n        if (a.r >=  b.r) {\n            bigr = a.r;\n            smallr = b.r;\n        } else {\n            bigr = b.r;\n            smallr = a.r;\n        }\n\n        double dist = pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n        dist = sqrt(dist);\n\n        int judge;\n        if (dist > bigr + smallr) {\n            judge = 0;\n        } else if (dist > bigr - smallr) {\n            judge = 1;\n        } else {\n            if (bigr == a.r) {\n                judge = 2;\n            } else {\n                judge = -2;\n            }\n        }\n\n        printf(\"%d\\n\", judge);\n    }\n\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        double xa, ya, ra, xb, yb, rb;\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &xa, &ya, &ra, &xb, &yb, &rb);\n        \n        double dist = sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n        \n        if (dist + rb < ra + 1e-9) {\n            printf(\"2\\n\");\n        } else if (dist + ra < rb + 1e-9) {\n            printf(\"-2\\n\");\n        } else if (dist < ra + rb + 1e-9 && dist + 1e-9 > fabs(ra - rb)) {\n            printf(\"1\\n\");\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>   %lf %lf  + (ya - yb) * (ya - yb)); if (dist + rb < ra + 1e-9) { printf(\"2\\n\"); } else if (dist + ra < rb + 1e-9) { printf(\"-2\\n\"); } else if (dist  > fabs(ra - rb)) { printf(\"1\\n\"); } else { printf(\"0\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h>  int main(void)  b; scanf(\"   { bigr = a.r; smallr = b.r; } else { bigr = b.r; smallr = a.r; } double dist = pow(a.x - b.x, 2) + pow(a.y  > bigr + smallr) { judge = 0; } else if (dist > bigr - smallr) { judge  judge = 2; } else { judge = -2; } } printf(\"%d\\n\", judge); } return 0; }"], "original_ll": -0.6373117566108704, "sampled_ll": -0.5692116022109985, "all_perturbed_sampled_ll": [-1.7764222621917725], "all_perturbed_original_ll": [-2.0214481353759766], "perturbed_sampled_ll": -1.7764222621917725, "perturbed_original_ll": -2.0214481353759766, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        while (n-- > 0) {\n            Circle a = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n            Circle b = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n            double dx = b.x - a.x;\n            double dy = b.y - a.y;\n            double r = a.r + b.r;\n            double d = Math.sqrt(dx * dx + dy * dy);\n            if (d > r) {\n                System.out.println(0);\n            } else {\n                if (a.r < b.r && d + a.r < b.r) {\n                    System.out.println(-2);\n                } else if (a.r > b.r && d + b.r < a.r) {\n                    System.out.println(2);\n                } else {\n                    System.out.println(1);\n                }\n            }\n        }\n    }\n\n    static class Circle {\n        double x;\n        double y;\n        double r;\n\n        Circle(double x, double y, double r) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n        }\n    }\n}\n\n\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double xa = sc.nextDouble();\n            double ya = sc.nextDouble();\n            double ra = sc.nextDouble();\n            double xb = sc.nextDouble();\n            double yb = sc.nextDouble();\n            double rb = sc.nextDouble();\n            \n            double dist = Math.sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n            \n            if (dist + rb < ra || Math.abs(dist + rb - ra) < 1e-9) {\n                System.out.println(2);\n            } else if (dist + ra < rb || Math.abs(dist + ra - rb) < 1e-9) {\n                System.out.println(-2);\n            } else if (dist < ra + rb && dist > Math.abs(ra - rb)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner <extra_id_7>for<extra_id_8>= 0; i <<extra_id_9>Math.abs(xb -<extra_id_10>{ double ya<extra_id_11>-<extra_id_12>Math.abs(yp<extra_id_13>{ System.out.println(4); }<extra_id_14>, double ea = 0 i = 0; i <  sc.nextDouble(); double ra = sc.nextDouble(); double xb = sc.nextDouble(); double yb  - xb) * (xa - xb) + (ya - yb) * (ya - yb)); if (dist + rb < ra || Math.abs(dist + rb - ra) < 1e-9) { System.out.println(2); }  Math.abs(ra - rb)) { System.out.println(1); } else { System.out.println(0); } } sc.close(); } }"], "perturbed_original": [" { Scanner sc  0) { Circle a = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble()); Circle b = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble()); double dx = b.x -  a.r +  dy); if (d  b.r && d + a.r < b.r) { System.out.println(-2); } else if (a.r > b.r && d + b.r < a.r) { System.out.println(2); } else { System.out.println(1); } } } } static class Circle { double  r) { this.x = x; this.y = y; this.r = r; } } }"], "original_ll": -0.4733905494213104, "sampled_ll": -0.44923147559165955, "all_perturbed_sampled_ll": [-2.1548938751220703], "all_perturbed_original_ll": [-1.7789629697799683], "perturbed_sampled_ll": -2.1548938751220703, "perturbed_original_ll": -1.7789629697799683, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for a,b,r,c,d,s in[map(float,raw_input().split())for i in range(input())]:\n\td=(a-c)**2+(b-d)**2\n\tif d>(r+s)**2:print 0\n\telif d+min(r,s)>max(r,s):print 1\n\telif r>s:print 2\n\telse:print -2", "sampled": "import math\n\nn = int(input())\nfor _ in range(n):\n    xa, ya, ra, xb, yb, rb = map(float, input().split())\n    \n    # Calculate distance between centers\n    d = math.sqrt((xa - xb)**2 + (ya - yb)**2)\n    \n    # Check if B is in A\n    if d + rb <= ra:\n        print(2)\n    # Check if A is in B\n    elif d + ra <= rb:\n        print(-2)\n    # Check if circles intersect\n    elif d < ra + rb:\n        print(1)\n    # Circles do not overlap\n    else:\n        print(0)\n", "perturbed_sampled": ["import math   centers d = math.sqrt((xa  is in A if d + rb <= ra: print(2) # Check if A is in B elif d + ra <= rb: print(-2) # Check if circles intersect elif d < ra + rb: print(1) # Circles do not overlap else: print(0)"], "perturbed_original": ["for a,b,r,c,d,s in[map(float,raw_input().split())for i in range(input())]: d=(a-c)**2+(b-d)**2 if d>(r+s)**2:print 0 elif d+min(r,s)>max(r,s):print 1 elif r>s:print 2 else:print -2"], "original_ll": -1.645774006843567, "sampled_ll": -0.7747495770454407, "all_perturbed_sampled_ll": [-3.0509579181671143], "all_perturbed_original_ll": [-1.8453373908996582], "perturbed_sampled_ll": -3.0509579181671143, "perturbed_original_ll": -1.8453373908996582, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nint main(){\n\tfloat v,t,y;\n\twhile(scanf(\"%f\",&v) != EOF){\n\t\tt = v / 9.8;\n\t\ty = t * t * 4.9;\n\t\tprintf(\"%d\\n\",(int)ceilf(y / 5.0) + 1);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double v;\n    while (scanf(\"%lf\", &v) != EOF) {\n        double t = v / 9.8;\n        double y = 4.9 * t * t;\n        int floor = (int)ceil((y + 5) / 5);\n        printf(\"%d\\n\", floor);\n    }\n    return 0;\n}\n", "perturbed_sampled": [" (scanf(\"%lf\", &v) != EOF)  4.9 * t * t; int floor = (int)ceil((y + 5) / 5); printf(\"%d\\n\", floor); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> int main(){ float v,t,y; while(scanf(\"%f\",&v) != EOF){ t = v / 9.8; y  1); } return 0; }"], "original_ll": -1.4823215007781982, "sampled_ll": -1.0034258365631104, "all_perturbed_sampled_ll": [-2.6450769901275635], "all_perturbed_original_ll": [-2.041443347930908], "perturbed_sampled_ll": -2.6450769901275635, "perturbed_original_ll": -2.041443347930908, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid doIt() {\n\t\twhile(true){\n\t\t\ttry{\n\t\t\t\tdouble v = sc.nextDouble();\n\t\t\t\tdouble t = v / 9.8;\n\t\t\t\tdouble y = 4.9 * t * t;\n\t\t\t\tint ans = (int) y / 5;\n\t\t\t\tdouble cnt = y % 5;\n\t\t\t\tif(cnt > 0){\n\t\t\t\t\tans++;\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t}\n\t\t\t}catch(Exception g){\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\t}\n    public static void main(String[] args) {\n    \tnew Main().doIt();\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double v = sc.nextDouble();\n            \n            // From v = 9.8t, we get t = v / 9.8\n            double t = v / 9.8;\n            \n            // Drop distance y = 4.9 * t^2\n            double y = 4.9 * t * t;\n            \n            // Height of floor N is 5*N - 5\n            // We need to find smallest N such that 5*N - 5 >= y\n            // 5*N >= y + 5\n            // N >= (y + 5) / 5\n            \n            int floor = (int) Math.ceil((y + 5) / 5.0);\n            \n            System.out.println(floor);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  = new Scanner(System.in); while (sc.hasNext()) {  get t = v  distance y = 4.9 * t^2 double y = 4.9 * t * t; // Height of floor N is 5*N - 5 // We need to find smallest N  / 5 int floor = (int) Math.ceil((y + 5) / 5.0); System.out.println(floor); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class  while(true){ try{ double v = sc.nextDouble(); double t = v / 9.8; double y = 4.9 *  double cnt = y % 5; if(cnt > 0){ ans++;  public static void main(String[] args) { new Main().doIt(); } }"], "original_ll": -1.0901435613632202, "sampled_ll": -0.9343289136886597, "all_perturbed_sampled_ll": [-2.5936169624328613], "all_perturbed_original_ll": [-2.830209732055664], "perturbed_sampled_ll": -2.5936169624328613, "perturbed_original_ll": -2.830209732055664, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nimport math\nv=[]\nfor line in sys.stdin:\n    v.append(float(line))\nfor i in range(len(v)):\n    print math.ceil(v[i]**2/98+1),", "sampled": "import sys\nimport math\n\nfor line in sys.stdin:\n    v = float(line.strip())\n    \n    # From v = 9.8 * t, we get t = v / 9.8\n    t = v / 9.8\n    \n    # From y = 4.9 * t^2\n    y = 4.9 * t * t\n    \n    # Height of floor N is 5*N - 5\n    # We need 5*N - 5 >= y\n    # 5*N >= y + 5\n    # N >= (y + 5) / 5\n    \n    N = math.ceil((y + 5) / 5)\n    \n    print(N)\n", "perturbed_sampled": ["import sys import math for line in sys.stdin: v = float(line.strip()) # From v = 9.8 * t, we get t  is 5*N -  5*N >= y + 5 # N >= (y + 5) / 5 N = math.ceil((y + 5) / 5) print(N)"], "perturbed_original": ["import sys import math v=[] for line in sys.stdin: v.append(float(line)) for i in range(len(v)): print math.ceil(v[i]**2/98+1),"], "original_ll": -2.1340839862823486, "sampled_ll": -1.066253423690796, "all_perturbed_sampled_ll": [-2.63012957572937], "all_perturbed_original_ll": [-2.892409086227417], "perturbed_sampled_ll": -2.63012957572937, "perturbed_original_ll": -2.892409086227417, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n\tint A[4], B[4];\n\tint a, b;\n\tint hit, blow;\n\n\twhile( scanf(\"%d%d%d%d\",&A[0],&A[1],&A[2],&A[3]) != EOF ){\n\t\tscanf(\"%d%d%d%d\",&B[0],&B[1],&B[2],&B[3]);\n\n\t\thit=blow=0;\n\n\t\tfor( a=0; a<4; a++ ){\n\t\t\tfor( b=0; b<4; b++ ){\n\t\t\t\tif( A[a] == B[b] ){\n\t\t\t\t\t(a==b)? hit++ : blow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %d\\n\", hit, blow);\n\t}\n\n\treturn 0;\n}\n\t", "sampled": "#include <stdio.h>\n\nint main() {\n    int a[4], b[4];\n    \n    while(scanf(\"%d %d %d %d\", &a[0], &a[1], &a[2], &a[3]) != EOF) {\n        scanf(\"%d %d %d %d\", &b[0], &b[1], &b[2], &b[3]);\n        \n        int hit = 0, blow = 0;\n        \n        // Count hits\n        for(int i = 0; i < 4; i++) {\n            if(a[i] == b[i]) {\n                hit++;\n            }\n        }\n        \n        // Count blows\n        for(int i = 0; i < 4; i++) {\n            for(int j = 0; j < 4; j++) {\n                if(i != j && a[i] == b[j]) {\n                    blow++;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", hit, blow);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int a[4], b[4]; while(scanf(\"%d %d %d %d\", &a[0], &a[1], &a[2], &a[3]) != EOF) {  = 0, blow = 0; // Count hits for(int i = 0; i < 4; i++) { if(a[i] == b[i]) { hit++; } } // Count blows for(int i = 0;    } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ int A[4], B[4]; int a, b; int hit, blow; while( scanf(\"%d%d%d%d\",&A[0],&A[1],&A[2],&A[3]) != EOF ){ scanf(\"%d%d%d%d\",&B[0],&B[1],&B[2],&B[3]); hit=blow=0; for( a=0; a<4; a++ ){ for( b=0; b<4; b++  0; }"], "original_ll": -0.747734010219574, "sampled_ll": -0.3695306181907654, "all_perturbed_sampled_ll": [-1.4346500635147095], "all_perturbed_original_ll": [-1.17694091796875], "perturbed_sampled_ll": -1.4346500635147095, "perturbed_original_ll": -1.17694091796875, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint [] a = new int[4];\n\t\t\tint [] b = new int[4];\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i =0; i < 4; i++){\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint hit=0;\n\t\t\tint blow = 0;\n\t\t\tfor(int i =0; i < 4; i++){\n\t\t\t\tfor(int j =i; j < 4; j++){\n\t\t\t\t\tif(a[i] == b[j]){\n\t\t\t\t\t\tif(i == j)\n\t\t\t\t\t\t\thit++;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tblow++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(hit + \" \" + blow);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int[] a = new int[4];\n            int[] b = new int[4];\n            \n            for (int i = 0; i < 4; i++) {\n                a[i] = sc.nextInt();\n            }\n            for (int i = 0; i < 4; i++) {\n                b[i] = sc.nextInt();\n            }\n            \n            int hit = 0;\n            int blow = 0;\n            \n            for (int i = 0; i < 4; i++) {\n                if (a[i] == b[i]) {\n                    hit++;\n                } else {\n                    for (int j = 0; j < 4; j++) {\n                        if (i != j && a[i] == b[j]) {\n                            blow++;\n                            break;\n                        }\n                    }\n                }\n            }\n            \n            System.out.println(hit + \" \" + blow);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  new int[4]; int[] b = new int[4]; for  hit = 0; int blow = 0; for (int i = 0; i < 4; i++) { if (a[i] == b[i]) { hit++; } else { for (int j  j && a[i]  + \" \" + blow); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public  new Scanner(System.in); while(sc.hasNext()){ int [] a = new int[4]; int [] b = new int[4]; for(int i = 0;  =0; i < 4; i++){ b[i] = sc.nextInt(); } int hit=0;  == b[j]){ if(i == j) hit++; else{ blow++; } } } } System.out.println(hit + \"  { Main obj = new Main(); obj.doit(); } }"], "original_ll": -0.6021494269371033, "sampled_ll": -0.30800947546958923, "all_perturbed_sampled_ll": [-1.9749418497085571], "all_perturbed_original_ll": [-2.3105151653289795], "perturbed_sampled_ll": -1.9749418497085571, "perturbed_original_ll": -2.3105151653289795, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor i in sys.stdin:\n    arrA,arrB = [],[]\n    s = i.split()\n    for i in s:\n        arrA.append(int(i))\n    s = input().split()\n    for i in s:\n        arrB.append(int(i))\n    h,b = 0,0\n    for i in range(len(arrA)):\n        if arrA[i] == arrB[i]:\n            h += 1\n        else:\n            if arrB.count(arrA[i]) > 0:\n                b += 1\n    print(h,b)", "sampled": "import sys\n\nfor line in sys.stdin:\n    numbers = list(map(int, line.split()))\n    if len(numbers) < 8:\n        continue\n    \n    a = numbers[:4]\n    b = numbers[4:8]\n    \n    hit = 0\n    blow = 0\n    \n    for i in range(4):\n        if a[i] == b[i]:\n            hit += 1\n        elif b[i] in a:\n            blow += 1\n    \n    print(hit, blow)\n", "perturbed_sampled": ["import sys for line in sys.stdin: numbers = list(map(int, line.split())) if len(numbers) < 8: continue  b[i]: hit += 1 elif b[i] in a: blow += 1 print(hit, blow)"], "perturbed_original": ["import sys  for i in s: arrA.append(int(i)) s =  i in range(len(arrA)): if arrA[i] == arrB[i]: h += 1 else: if arrB.count(arrA[i]) > 0: b += 1 print(h,b)"], "original_ll": -0.9464068412780762, "sampled_ll": -0.8604347109794617, "all_perturbed_sampled_ll": [-2.7896554470062256], "all_perturbed_original_ll": [-2.6048471927642822], "perturbed_sampled_ll": -2.7896554470062256, "perturbed_original_ll": -2.6048471927642822, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid fact(int ,int, int);\nvoid count(void);\n\nint a[10][10],i,j;\n\nint main(){\n  int x,y,size;\n\n  for(i = 0 ; i < 10 ; i++){\n    for(j = 0 ; j < 10 ; j++){\n      a[i][j] = 0;\n    }\n  }\n  while(scanf(\"%d,%d,%d\",&x,&y,&size) != 3){\n    fact(x,y,size);\n  }\n  count();\n  return 0;\n}\nvoid fact(int x, int y, int size){\n  int size1[2] = {1,-1};\n  int size2[2] = {2,-2};\n\n  a[y][x] += 1;\n  if(size == 1){\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size1[i] >= 0 || x+size1[i] <= 10)\n\ta[y][x+size1[i]] += 1;\n      if(y+size1[i] >= 0 || y+size1[i] <= 10)\n\ta[y+size1[i]][x] += 1;\n    }\n  }\n  if(size == 2){\n    for(i = 0 ; i < 2 ; i++){\n      for(j = 0 ; j < 2 ; j++){\n\tif(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10)\n\t  a[y+size1[i]][x+size1[j]] += 1;\n      }\n    }\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size1[i] >= 0 || x+size1[i] <= 10)\n\ta[y][x+size1[i]] += 1;\n      if(y+size1[i] >= 0 || y+size1[i] <= 10)\n\ta[y+size1[i]][x] += 1;\n    }\n  }\n  if(size == 3){\n    for(i = 0 ; i < 2 ; i++){\n      for(j = 0 ; j < 2 ; j++){\n\tif(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10)\n\t  a[y+size1[i]][x+size1[j]] += 1;\n      }\n    }\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size1[i] >= 0 || x+size1[i] <= 10)\n\ta[y][x+size1[i]] += 1;\n      if(y+size1[i] >= 0 || y+size1[i] <= 10)\n\ta[y+size1[i]][x] += 1;\n    }\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size2[i] >= 0 || x+size2[i] <= 10)\n\ta[y][x+size2[i]] += 1;\n      if(y+size2[i] >= 0 || y+size2[i] <= 10)\n\ta[y+size2[i]][x] += 1;\n    }\n  }\n}\nvoid count(void){\n  int sum = 0,x = 0;\n\n  for(i = 0 ; i < 10 ; i++){\n    for(j = 0 ; j < 10 ; j++){\n      if(a[i][j] == 0)\n\tsum++;\n      else if(x < a[i][j])\n\tx++;\n    }\n  }\n  printf(\"%d\\n%d\\n\",sum,x);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int grid[10][10];\n    memset(grid, 0, sizeof(grid));\n    \n    int x, y, s;\n    while (scanf(\"%d,%d,%d\", &x, &y, &s) == 3) {\n        // Small (s=1): only center point\n        if (s == 1) {\n            grid[y][x]++;\n        }\n        // Medium (s=2): center + adjacent (up, down, left, right)\n        else if (s == 2) {\n            grid[y][x]++;\n            if (y > 0) grid[y-1][x]++;\n            if (y < 9) grid[y+1][x]++;\n            if (x > 0) grid[y][x-1]++;\n            if (x < 9) grid[y][x+1]++;\n        }\n        // Large (s=3): center + all 8 surrounding cells + distance 2 in 4 directions\n        else if (s == 3) {\n            grid[y][x]++;\n            // 8 surrounding cells\n            if (y > 0) grid[y-1][x]++;\n            if (y < 9) grid[y+1][x]++;\n            if (x > 0) grid[y][x-1]++;\n            if (x < 9) grid[y][x+1]++;\n            if (y > 0 && x > 0) grid[y-1][x-1]++;\n            if (y > 0 && x < 9) grid[y-1][x+1]++;\n            if (y < 9 && x > 0) grid[y+1][x-1]++;\n            if (y < 9 && x < 9) grid[y+1][x+1]++;\n            // distance 2 in 4 directions\n            if (y > 1) grid[y-2][x]++;\n            if (y < 8) grid[y+2][x]++;\n            if (x > 1) grid[y][x-2]++;\n            if (x < 8) grid[y][x+2]++;\n        }\n    }\n    \n    int zero_count = 0;\n    int max_density = 0;\n    \n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (grid[i][j] == 0) {\n                zero_count++;\n            }\n            if (grid[i][j] > max_density) {\n                max_density = grid[i][j];\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", zero_count);\n    printf(\"%d\\n\", max_density);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int grid[10][10]; memset(grid, 0,  if (s == 1) { grid[y][x]++; } // Medium (s=2): center  2) { grid[y][x]++; if (y > 0)  grid[y][x-1]++; if (x < 9) grid[y][x+1]++; } // Large (s=3): center +  else if (s == 3) { grid[y][x]++; // 8 surrounding cells if (y > 0) grid[y-1][x]++; if (y < 9) grid[y+1][x]++; if (x > 0) grid[y][x-1]++; if (x < 9) grid[y][x+1]++; if (y > 0 && x > 0)  if (y < 9 && x > 0)  // distance 2 in 4 directions if (y > 1) grid[y-2][x]++; if (y < 8)  grid[y][x+2]++;  for (int i = 0; i < 10; i++)  (grid[i][j] > max_density) { max_density = grid[i][j]; } } } printf(\"%d\\n\", zero_count); printf(\"%d\\n\", max_density); return 0; }"], "perturbed_original": ["#include <stdio.h> void  j++){ a[i][j] = 0; } } while(scanf(\"%d,%d,%d\",&x,&y,&size) != 3){ fact(x,y,size); } count(); return 0; } void fact(int x, int y, int size){ int size1[2] = {1,-1}; int size2[2] = {2,-2};   y+size1[i] <= 10) a[y+size1[i]][x] += 1; } } if(size == 2){ for(i = 0 ; i < 2 ; i++){ for(j = 0 ;  <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10) a[y+size1[i]][x+size1[j]] += 1; } } for(i = 0 ; i <  a[y][x+size1[i]]  0 ; i < 2 ; i++){ for(j = 0 ; j < 2 ; j++){ if(x+size1[i] >= 0 || x+size1[i] <=  += 1; } } for(i = 0 ; i < 2 ; i++){ if(x+size1[i] >=  0 || y+size1[i] <= 10) a[y+size1[i]][x] +=  += 1; if(y+size2[i] >= 0 || y+size2[i] <= 10) a[y+size2[i]][x] += 1; } } } void count(void){ int sum  10 ; i++){ for(j = 0 ; j < 10 ; j++){ if(a[i][j] == 0) sum++; else if(x < a[i][j]) x++; } } printf(\"%d\\n%d\\n\",sum,x); }"], "original_ll": -0.390471875667572, "sampled_ll": -0.37035873532295227, "all_perturbed_sampled_ll": [-1.244520664215088], "all_perturbed_original_ll": [-1.2933779954910278], "perturbed_sampled_ll": -1.244520664215088, "perturbed_original_ll": -1.2933779954910278, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint[] area = new int[10 * 10];\n\n\t\tString str;\n\n\t\ttry {\n\t\t\twhile ((str = br.readLine()) != null) {\n\t\t\t\tString strArray[] = str.split(\",\");\n\t\t\t\tint x = Integer.parseInt(strArray[0]);\n\t\t\t\tint y = Integer.parseInt(strArray[1]);\n\t\t\t\tint size = Integer.parseInt(strArray[2]);\n\n\t\t\t\tint point = y * 10 + x;\n\n\t\t\t\tswitch (size) {\n\t\t\t\tcase 3:\n\t\t\t\t\tif (x < 8)\n\t\t\t\t\t\tarea[point + 2]++;\n\t\t\t\t\tif (x > 1)\n\t\t\t\t\t\tarea[point - 2]++;\n\t\t\t\t\tif (y < 8)\n\t\t\t\t\t\tarea[point + 20]++;\n\t\t\t\t\tif (y > 1)\n\t\t\t\t\t\tarea[point - 20]++;\n\t\t\t\tcase 2:\n\t\t\t\t\t// \u5de6\u4e0a\n\t\t\t\t\tif (x > 0 && y > 0)\n\t\t\t\t\t\tarea[point - 11]++;\n\t\t\t\t\t// \u53f3\u4e0a\n\t\t\t\t\tif (x < 9 && y > 0)\n\t\t\t\t\t\tarea[point - 9]++;\n\t\t\t\t\t// \u5de6\u4e0b\n\t\t\t\t\tif (y < 9 && x > 0)\n\t\t\t\t\t\tarea[point + 9]++;\n\t\t\t\t\t// \u53f3\u4e0b\n\t\t\t\t\tif (y < 9 && x < 9)\n\t\t\t\t\t\tarea[point + 11]++;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (x < 9)\n\t\t\t\t\t\tarea[point + 1]++;\n\t\t\t\t\tif (x > 0)\n\t\t\t\t\t\tarea[point - 1]++;\n\t\t\t\t\tif (y < 9)\n\t\t\t\t\t\tarea[point + 10]++;\n\t\t\t\t\tif (y > 1)\n\t\t\t\t\t\tarea[point - 10]++;\n\t\t\t\t\tarea[point]++;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (NumberFormatException e) {\n\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tArrays.sort(area);\n\t\tint blank = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tif (area[i] != 0) {\n\t\t\t\tblank = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// System.out.println(Arrays.binarySearch(area, 1));\n\t\tSystem.out.println(blank);\n\t\tSystem.out.println(area[99]);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int[][] paper = new int[10][10];\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int x = Integer.parseInt(parts[0]);\n            int y = Integer.parseInt(parts[1]);\n            int size = Integer.parseInt(parts[2]);\n            \n            dropInk(paper, x, y, size);\n        }\n        \n        int zeroCells = 0;\n        int maxDensity = 0;\n        \n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                if (paper[i][j] == 0) {\n                    zeroCells++;\n                }\n                maxDensity = Math.max(maxDensity, paper[i][j]);\n            }\n        }\n        \n        System.out.println(zeroCells);\n        System.out.println(maxDensity);\n        \n        sc.close();\n    }\n    \n    static void dropInk(int[][] paper, int x, int y, int size) {\n        if (size == 1) {\n            // Small: only center\n            if (isValid(x, y)) {\n                paper[y][x]++;\n            }\n        } else if (size == 2) {\n            // Medium: cross pattern with radius 1\n            int[][] offsets = {\n                {0, 0},\n                {-1, 0}, {1, 0}, {0, -1}, {0, 1}\n            };\n            for (int[] offset : offsets) {\n                int nx = x + offset[0];\n                int ny = y + offset[1];\n                if (isValid(nx, ny)) {\n                    paper[ny][nx]++;\n                }\n            }\n        } else if (size == 3) {\n            // Large: diamond pattern with radius 2\n            int[][] offsets = {\n                {0, 0},\n                {-1, 0}, {1, 0}, {0, -1}, {0, 1},\n                {-2, 0}, {2, 0}, {0, -2}, {0, 2},\n                {-1, -1}, {-1, 1}, {1, -1}, {1, 1}\n            };\n            for (int[] offset : offsets) {\n                int nx = x + offset[0];\n                int ny = y + offset[1];\n                if (isValid(nx, ny)) {\n                    paper[ny][nx]++;\n                }\n            }\n        }\n    }\n    \n    static boolean isValid(int x, int y) {\n        return x >= 0 && x < 10 && y >= 0 && y < 10;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  sc = new Scanner(System.in); int[][] paper =  = Integer.parseInt(parts[1]); int size = Integer.parseInt(parts[2]); dropInk(paper, x, y, size); }  (int  } } System.out.println(zeroCells); System.out.println(maxDensity); sc.close(); } static void dropInk(int[][] paper, int x, int y, int size) { if (size == 1) { // Small: only center if (isValid(x, y)) { paper[y][x]++; } } else if (size  int[][] offsets = { {0, 0}, {-1, 0}, {1, 0}, {0, -1}, {0, 1} }; for (int[] offset : offsets) { int nx = x + offset[0]; int ny = y + offset[1]; if (isValid(nx, ny)) { paper[ny][nx]++; } } }  with radius 2 int[][] offsets = { {0, 0}, {-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-2, 0}, {2, 0}, {0, -2}, {0, 2}, {-1, -1}, {-1, 1}, {1,  int nx = x + offset[0]; int ny = y + offset[1]; if (isValid(nx, ny)) { paper[ny][nx]++;  }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; public class Main { public static void main(String[] args) { BufferedReader br =  null) { String strArray[] = str.split(\",\"); int x =  { case 3: if (x < 8) area[point +  < 8) area[point + 20]++; if (y > 1) area[point - 20]++;  > 0) area[point - 11]++; // \u53f3\u4e0a if (x < 9 && y > 0) area[point - 9]++; // \u5de6\u4e0b if  // \u53f3\u4e0b if (y < 9 && x <  area[point + 1]++; if (x  area[point]++; } } } catch (NumberFormatException e) { // TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af e.printStackTrace(); } catch (IOException e) { // TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af e.printStackTrace();  0; i < 100; i++)  } } // System.out.println(Arrays.binarySearch(area, 1)); System.out.println(blank); System.out.println(area[99]); } }"], "original_ll": -0.49560943245887756, "sampled_ll": -0.46376192569732666, "all_perturbed_sampled_ll": [-1.3841418027877808], "all_perturbed_original_ll": [-1.7872458696365356], "perturbed_sampled_ll": -1.3841418027877808, "perturbed_original_ll": -1.7872458696365356, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Cloth(object):\n    cell = None\n    x = 0\n    y = 0\n    def __init__(self, x, y):\n        self.cell = list([list([0 for i in range(y)]) for i in range(x)])\n        self.x = x\n        self.y = y\n    def check(self, x, y):\n        try:\n            self.cell[x][y] += 0\n            return True\n        except IndexError:\n            return False\n    def point(self, x, y):\n        try:\n            self.cell[x][y] += 1\n        except IndexError:\n            pass\n    def small(self, x, y):\n        if not self.check(x, y):\n            return\n        self.point(x, y + 1)\n        self.point(x - 1, y)\n        self.point(x, y)\n        self.point(x + 1, y)\n        self.point(x, y - 1)\n    def medium(self, x, y):\n        if not self.check(x, y):\n            return\n        self.small(x, y)\n        self.point(x + 1, y + 1)\n        self.point(x - 1, y + 1)\n        self.point(x + 1, y - 1)\n        self.point(x - 1, y - 1)\n    def large(self, x, y):\n        if not self.check(x, y):\n            return\n        self.medium(x, y)\n        self.point(x, y + 2)\n        self.point(x - 2, y)\n        self.point(x + 2, y)\n        self.point(x, y - 2)\ncloth = Cloth(10, 10)\nwhile True:\n    try:\n        (x, y, s) = map(lambda x:int(x)-1, raw_input().split(','))\n        if s == 0:\n            cloth.small(x, y)\n        elif s == 1:\n            cloth.medium(x, y)\n        elif s == 2:\n            cloth.large(x, y)\n    except EOFError:\n        break\nprint reduce(lambda x,y:x+y,map(lambda x:x.count(0),cloth.cell))\nprint max(map(max,cloth.cell))", "sampled": "import sys\n\n# Initialize 10x10 grid\ngrid = [[0 for _ in range(10)] for _ in range(10)]\n\n# Define ink patterns for each size relative to drop point\n# Size 1 (Small): just the center and 4 adjacent cells (cross pattern)\npatterns = {\n    1: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)],\n    2: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, 2), (0, -2), (2, 0), (-2, 0)],\n    3: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), \n        (0, 2), (0, -2), (2, 0), (-2, 0), (1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (0, 3), (0, -3), (3, 0), (-3, 0)]\n}\n\n# Read input and process drops\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    parts = line.split(',')\n    x = int(parts[0])\n    y = int(parts[1])\n    size = int(parts[2])\n    \n    # Apply ink pattern\n    for dx, dy in patterns[size]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < 10 and 0 <= ny < 10:\n            grid[ny][nx] += 1\n\n# Count cells with density 0 and find maximum density\nzero_count = 0\nmax_density = 0\n\nfor row in grid:\n    for cell in row:\n        if cell == 0:\n            zero_count += 1\n        max_density = max(max_density, cell)\n\nprint(zero_count)\nprint(max_density)\n", "perturbed_sampled": ["import sys  range(10)] for _ in range(10)] # Define ink patterns for each size relative to drop point # Size 1 (Small): just the center and  0), (0, 1), (0, -1), (1, 0), (-1, 0)], 2: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1,  -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, 2), (0, -2), (2, 0), (-2, 0), (1, 2),  (-2, 1), (-2, -1),  Read input and  not line: continue parts = line.split(',') x = int(parts[0]) y = int(parts[1]) size = int(parts[2]) # Apply ink pattern for dx, dy in patterns[size]: nx, ny  and find maximum density zero_count = 0 max_density = 0  == 0: zero_count += 1 max_density = max(max_density, cell) print(zero_count) print(max_density)"], "perturbed_original": ["class  += 0 return True except IndexError: return  IndexError: pass def small(self, x, y): if not self.check(x, y): return self.point(x, y + 1) self.point(x - 1, y) self.point(x, y) self.point(x + 1, y) self.point(x, y - 1) def medium(self, x, y): if not self.check(x, y): return self.small(x, y) self.point(x +  self.point(x + 1, y - 1) self.point(x - 1, y - 1) def large(self, x, y): if not self.check(x, y): return self.medium(x, y) self.point(x,  while True: try: (x, y, s) = map(lambda x:int(x)-1, raw_input().split(',')) if s  elif s == 2: cloth.large(x, y) except EOFError: break print reduce(lambda x,y:x+y,map(lambda x:x.count(0),cloth.cell)) print max(map(max,cloth.cell))"], "original_ll": -0.6114765405654907, "sampled_ll": -0.5842834115028381, "all_perturbed_sampled_ll": [-1.7434946298599243], "all_perturbed_original_ll": [-1.4895532131195068], "perturbed_sampled_ll": -1.7434946298599243, "perturbed_original_ll": -1.4895532131195068, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n \nint dayOfWeek(int year, int month, int day)\n{\n    if (month == 1 || month == 2) {\n        year--;\n        month += 12;\n    }\n    return (year + year / 4 - year / 100 + year / 400\n        + (13 * month + 8) / 5 + day) % 7;\n}\n \nint main()\n{\n    int m, d;\n    char *day[7] = {\n        \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\n    };\n     \n    while (1) {\n        scanf(\"%d%d\", &m, &d);\n        if (m == 0 || d == 0) break;\n        puts(day[dayOfWeek(2004, m, d)]);\n    }\n    return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nint main() {\n    int days_in_month[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    char *day_names[] = {\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"};\n    \n    int m, d;\n    while(1) {\n        scanf(\"%d %d\", &m, &d);\n        if(m == 0 && d == 0) break;\n        \n        int total_days = 0;\n        for(int i = 1; i < m; i++) {\n            total_days += days_in_month[i];\n        }\n        total_days += d - 1;\n        \n        int day_index = total_days % 7;\n        printf(\"%s\\n\", day_names[day_index]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int days_in_month[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30,  \"Wednesday\"}; int m, d; while(1) { scanf(\"%d %d\",  < m; i++) { total_days += days_in_month[i]; } total_days += d - 1; int  }"], "perturbed_original": ["#include <stdio.h> int dayOfWeek(int year, int month, int day) { if (month == 1 || month == 2) { year--;  - year / 100  { int m, d; char *day[7] = { \"Sunday\", \"Monday\",  &m, &d); if (m == 0 || d == 0) break; puts(day[dayOfWeek(2004, m, d)]); } return 0; }"], "original_ll": -0.7081373333930969, "sampled_ll": -0.44907310605049133, "all_perturbed_sampled_ll": [-1.5064603090286255], "all_perturbed_original_ll": [-1.8473440408706665], "perturbed_sampled_ll": -1.5064603090286255, "perturbed_original_ll": -1.8473440408706665, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid run(){\n\t\tint[] map={31,29,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] dp = new int [12];\n\t\tString[] str ={\n\t\t\t\t\"Monday\",\n\t\t\t\t\"Tuesday\",\n\t\t\t\t\"Wednesday\",\n\t\t\t\t\"Thursday\",\n\t\t\t\t\"Friday\",\n\t\t\t\t\"Monday\",\n\t\t\t\t\"Sunday\",\n\t\t};\n\t\tdp[0] = 2;\n\t\tfor(int i=1; i <12;i++){\n\t\t\tdp[i] = (dp[i-1] + map[i-1] +2)%7;\n\t\t}\n\t\tfor(;;){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(str[(dp[m-1]+n)%7]);\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int[] daysInMonth = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        String[] days = {\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"};\n        \n        while (true) {\n            int m = sc.nextInt();\n            int d = sc.nextInt();\n            \n            if (m == 0 && d == 0) {\n                break;\n            }\n            \n            int totalDays = 0;\n            for (int i = 1; i < m; i++) {\n                totalDays += daysInMonth[i];\n            }\n            totalDays += d - 1;\n            \n            System.out.println(days[totalDays % 7]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void  = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; String[] days  { int m  && d == 0) { break; } int totalDays  i++) { totalDays += daysInMonth[i]; } totalDays += d - 1; System.out.println(days[totalDays % 7]); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.lang.*; import  void run(){ int[] map={31,29,31,30,31,30,31,31,30,31,30,31}; int[] dp = new int [12];  }; dp[0] = 2; for(int i=1; i <12;i++){ dp[i]  sc.nextInt(); int n = sc.nextInt(); if((m|n)==0){ break; } System.out.println(str[(dp[m-1]+n)%7]); } } public static void main(String[] args){ Main m = new Main(); m.run(); } }"], "original_ll": -0.8894072771072388, "sampled_ll": -0.4160982072353363, "all_perturbed_sampled_ll": [-1.5155953168869019], "all_perturbed_original_ll": [-1.7929260730743408], "perturbed_sampled_ll": -1.5155953168869019, "perturbed_original_ll": -1.7929260730743408, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "month, day = map(int, raw_input().split())\ndays = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\nyoubi = [\"Sunday\", \"Monday\", \"Tuesday\",\n         \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\nwhile month != 0:\n    Days = 0\n    for i in range(month - 1):\n        Days += days[i]\n    Days += day\n    print youbi[Days % 7]\n    month, day = map(int, raw_input().split())", "sampled": "days_of_week = [\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"]\ndays_in_month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nwhile True:\n    line = input().split()\n    m, d = int(line[0]), int(line[1])\n    \n    if m == 0 and d == 0:\n        break\n    \n    total_days = 0\n    for i in range(1, m):\n        total_days += days_in_month[i]\n    total_days += d - 1\n    \n    day_index = total_days % 7\n    print(days_of_week[day_index])\n", "perturbed_sampled": ["days_of_week = [\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"]  31, 30, 31, 30, 31] while True: line = input().split() m, d =  break total_days = 0 for i in range(1,  = total_days % 7 print(days_of_week[day_index])"], "perturbed_original": [" 30, 31, 30, 31, 31,  \"Thursday\", \"Friday\", \"Saturday\"] while month != 0: Days = 0 for i in range(month - 1): Days += days[i] Days += day print youbi[Days % 7] month, day = map(int, raw_input().split())"], "original_ll": -0.5738586187362671, "sampled_ll": -0.6477815508842468, "all_perturbed_sampled_ll": [-1.9688045978546143], "all_perturbed_original_ll": [-1.8652750253677368], "perturbed_sampled_ll": -1.9688045978546143, "perturbed_original_ll": -1.8652750253677368, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n  int countArray[101], number, mx_number = 0;\n  memset(countArray, 0, sizeof countArray);\n\n  while(scanf(\"%d\", &number)!=EOF){\n    ++countArray[number];\n  }\n\n  for(number = 100; number > 0; --number)\n    if(countArray[number] > countArray[mx_number])\n      mx_number = number;\n\n  for(number = 1; number <= mx_number; ++number)\n    if(countArray[number] == countArray[mx_number])\n      printf(\"%d\\n\", number);\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int count[101] = {0};\n    int num;\n    int maxCount = 0;\n    \n    while (scanf(\"%d\", &num) != EOF) {\n        count[num]++;\n        if (count[num] > maxCount) {\n            maxCount = count[num];\n        }\n    }\n    \n    for (int i = 1; i <= 100; i++) {\n        if (count[i] == maxCount) {\n            printf(\"%d\\n\", i);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int <extra_id_1>{<extra_id_2>floor(count[num]++);<extra_id_3>; } if<extra_id_4>} if (%d > maxCount)<extra_id_5>><extra_id_6>-<extra_id_7>-1,<extra_id_8>\\n<extra_id_9>}<extra_id_10>{<extra_id_11>} } }<extra_id_12>} = 0; while (scanf(\"%d\", &num) != EOF) { count[num]++; if (count[num] > maxCount) { maxCount = count[num]; } } for (int i  maxCount) { printf(\"%d\\n\", i); } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main()   0; --number) if(countArray[number] > countArray[mx_number]) mx_number = number; for(number = 1; number <= mx_number; ++number) if(countArray[number] == countArray[mx_number]) printf(\"%d\\n\", number); return 0; }"], "original_ll": -0.906397819519043, "sampled_ll": -0.40704166889190674, "all_perturbed_sampled_ll": [-1.9981184005737305], "all_perturbed_original_ll": [-1.9683647155761719], "perturbed_sampled_ll": -1.9981184005737305, "perturbed_original_ll": -1.9683647155761719, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u30fb\u30b9\u30bf\u30d6\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString tmp = null;\n\t\tint cup = 0;\n\t\tint mun = 0;\n\t\tint ter = 0;\n\t\tString[] rrr;\n\t\tint st = 0,sr = 0;\n\t\tint mon = 0;\n\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\ttry {\n\t\t\t\ttmp = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp == null){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp.equals(\"\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tal.add(Integer.parseInt(tmp));\n\t\t}\n\t\t\n\t\t//System.out.println(al.toString());\n\t\tCollections.sort(al);\n\t\t//System.out.println(al.toString());\n\t\tArrayList<Integer> al2 = new ArrayList<Integer>();\n\t\tArrayList<Integer> al3 = new ArrayList<Integer>();\n\t\tint tmpr = 0;\n\t\t\n\t\tfor(int i=0;i<al.size();i++){\n\t\t\tif(tmpr ==0){\n\t\t\t\tal2.add(al.get(i));\n\t\t\t}\n\t\t\tif(al2.get(tmpr) < al.get(i)){\n\t\t\t\ttmpr++;\n\t\t\t\tal2.add(al.get(i));\n\t\t\t}\n\t\t}\n\t\tint aaa = 0;\n\t\tfor(int i=0;i<al2.size();i++){\n\t\t\ttmpr = 0;\n\t\t\tfor(int j=0;j<al.size();j++){\n\t\t\t\tif(al.get(j) == al2.get(i)){\n\t\t\t\t\ttmpr++;\n\t\t\t\t}\n\t\t\t\tal3.add(tmpr);\n\t\t\t\tif(aaa < tmpr){\n\t\t\t\t\taaa = tmpr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<al3.size();i++){\n\t\t\tif(aaa == al3.get(i)){\n\t\t\t\tSystem.out.println(al2.get(i));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Map<Integer, Integer> count = new HashMap<>();\n        \n        while (sc.hasNextInt()) {\n            int num = sc.nextInt();\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n        \n        int maxCount = 0;\n        for (int c : count.values()) {\n            maxCount = Math.max(maxCount, c);\n        }\n        \n        List<Integer> modes = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                modes.add(entry.getKey());\n            }\n        }\n        \n        Collections.sort(modes);\n        \n        for (int mode : modes) {\n            System.out.println(mode);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  sc = new Scanner(System.in); Map<Integer, Integer> count = new HashMap<>(); while (sc.hasNextInt()) { int num = sc.nextInt(); count.put(num, count.getOrDefault(num, 0) + 1); } int maxCount = 0;  modes.add(entry.getKey()); } } Collections.sort(modes); for (int mode : modes) { System.out.println(mode); } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Collections; public  tmp = null; int cup  String[] rrr; int st = 0,sr = 0; int mon = 0; ArrayList<Integer> al = new ArrayList<Integer>(); while(true){ try  TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af e.printStackTrace(); } if(tmp == null){ break; } if(tmp.equals(\"\")){ break; } al.add(Integer.parseInt(tmp)); } //System.out.println(al.toString()); Collections.sort(al); //System.out.println(al.toString());  int tmpr = 0; for(int i=0;i<al.size();i++){ if(tmpr ==0){ al2.add(al.get(i)); } if(al2.get(tmpr) < al.get(i)){ tmpr++; al2.add(al.get(i));  0; for(int  aaa = tmpr; } } } for(int i=0;i<al3.size();i++){ if(aaa == al3.get(i)){ System.out.println(al2.get(i)); } } } }"], "original_ll": -0.6564191579818726, "sampled_ll": -0.304797887802124, "all_perturbed_sampled_ll": [-1.4385563135147095], "all_perturbed_original_ll": [-1.8278366327285767], "perturbed_sampled_ll": -1.4385563135147095, "perturbed_original_ll": -1.8278366327285767, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "num = [[0,i+1] for i in range(100)]\nwhile True:\n    try:\n        num[int(input())-1][0] += 1\n    except:\n        num.sort(reverse = True)\n        ans = []\n        for i in range(100):\n            if num[i][0] == num[0][0]:\n                ans.append(num[i][1])\n            else:\n                ans.sort()\n                for z in ans:\n                    print(z)\n                break\n        break\n", "sampled": "import sys\nfrom collections import Counter\n\nnumbers = []\nfor line in sys.stdin:\n    numbers.append(int(line.strip()))\n\ncounter = Counter(numbers)\nmax_count = max(counter.values())\nmode_values = sorted([num for num, count in counter.items() if count == max_count])\n\nfor val in mode_values:\n    print(val)\n", "perturbed_sampled": ["import sys from collections import Counter numbers = []  max(counter.values()) mode_values = sorted([num for num, count in counter.items() if count == max_count]) for val in mode_values: print(val)"], "perturbed_original": ["num = [[0,i+1] for i in range(100)] while True: try: num[int(input())-1][0] +=  in range(100): if num[i][0] == num[0][0]: ans.append(num[i][1]) else: ans.sort() for z in ans: print(z) break break"], "original_ll": -0.9892707467079163, "sampled_ll": -1.0008443593978882, "all_perturbed_sampled_ll": [-2.7362780570983887], "all_perturbed_original_ll": [-1.7253057956695557], "perturbed_sampled_ll": -2.7362780570983887, "perturbed_original_ll": -1.7253057956695557, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void){\n\tint i=0,j,c,max=0,ans1=100,ans2=100,count=0;\n\tchar s[1000][33]={0};\n\tchar ch;\n\t\n\twhile(1){\n\t\tscanf(\"%c\",&ch);\n\t\tif(ch=='\\n')break;\n\t\tif(ch==' '){\n\t\t\tcount++;\n\t\t\ti=0;\n\t\t}\n\t\ts[count][i]=ch;\n\t\tif(max<1+i){\n\t\t\tmax=i+1;\n\t\t\tans2=count;\n\t\t}\n\t\tif(ch!=' ')i++;\n\t}\n\tmax=0;\n\tfor(i=0;i<count;i++){\n\t\tfor(j=i+1,c=0;j<count;j++){\n\t\t\tif(strcmp(s[i],s[j])==0){\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tif(max<c){\n\t\t\t\tmax=c;\n\t\t\t\tans1=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%s %s\\n\",s[ans1],s[ans2]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    char text[1001];\n    char words[100][33];\n    int count[100] = {0};\n    int wordCount = 0;\n    \n    fgets(text, sizeof(text), stdin);\n    \n    // Remove newline if present\n    int len = strlen(text);\n    if (len > 0 && text[len-1] == '\\n') {\n        text[len-1] = '\\0';\n    }\n    \n    // Parse words\n    char *token = strtok(text, \" \");\n    while (token != NULL) {\n        int found = -1;\n        for (int i = 0; i < wordCount; i++) {\n            if (strcmp(words[i], token) == 0) {\n                found = i;\n                break;\n            }\n        }\n        \n        if (found != -1) {\n            count[found]++;\n        } else {\n            strcpy(words[wordCount], token);\n            count[wordCount] = 1;\n            wordCount++;\n        }\n        \n        token = strtok(NULL, \" \");\n    }\n    \n    // Find most frequent word\n    int maxCount = 0;\n    int maxCountIndex = 0;\n    for (int i = 0; i < wordCount; i++) {\n        if (count[i] > maxCount) {\n            maxCount = count[i];\n            maxCountIndex = i;\n        }\n    }\n    \n    // Find longest word\n    int maxLen = 0;\n    int maxLenIndex = 0;\n    for (int i = 0; i < wordCount; i++) {\n        int len = strlen(words[i]);\n        if (len > maxLen) {\n            maxLen = len;\n            maxLenIndex = i;\n        }\n    }\n    \n    printf(\"%s %s\\n\", words[maxCountIndex], words[maxLenIndex]);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <ctype.h> int main() { char text[1001]; char words[100][33]; int count[100] = {0}; int wordCount = 0; fgets(text, sizeof(text), stdin); // Remove newline  && text[len-1] == '\\n') { text[len-1]  found = i; break; } } if (found != -1) { count[found]++; } else { strcpy(words[wordCount], token); count[wordCount] = 1; wordCount++; } token  int maxCount = 0; int maxCountIndex = 0; for (int i  maxCount) { maxCount =  int maxLen = 0; int maxLenIndex = 0; for (int i =  if (len > maxLen) { maxLen = len; maxLenIndex = i; } } printf(\"%s %s\\n\", words[maxCountIndex], words[maxLenIndex]); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h>  if(ch=='\\n')break; if(ch==' '){  } max=0; for(i=0;i<count;i++){ for(j=i+1,c=0;j<count;j++){ if(strcmp(s[i],s[j])==0){ c++; } if(max<c){ max=c; ans1=i; } } } printf(\"%s %s\\n\",s[ans1],s[ans2]); return 0; }"], "original_ll": -0.9577261805534363, "sampled_ll": -0.36942654848098755, "all_perturbed_sampled_ll": [-1.2476762533187866], "all_perturbed_original_ll": [-1.6474168300628662], "perturbed_sampled_ll": -1.2476762533187866, "perturbed_original_ll": -1.6474168300628662, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.HashMap;\nimport java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\n\t\tString[] st = sc.nextLine().split(\" \");\n\t\t\n\t\tfor(int i = 0; i < st.length; i++)\n\t\t\tif(map.containsKey(st[i]))\n\t\t\t\tmap.put(st[i], map.get(st[i])+1);\n\t\t\telse\n\t\t\t\tmap.put(st[i], 1);\n\t\t\n\t\tString max = st[0];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < st.length-1; i++){\n\t\t\tif(map.get(st[i]) < map.get(st[i+1]))max = st[i+1];\n\t\t    if(st[i].length() < st[i+1].length())count = i+1;\n\t\t}\n\t\t\tSystem.out.println(max + \" \" + st[count]);\n\t\t\t\n\t\t\tsc.close();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] words = line.split(\" \");\n        \n        Map<String, Integer> frequency = new HashMap<>();\n        for (String word : words) {\n            frequency.put(word, frequency.getOrDefault(word, 0) + 1);\n        }\n        \n        String mostFrequent = \"\";\n        int maxFreq = 0;\n        for (Map.Entry<String, Integer> entry : frequency.entrySet()) {\n            if (entry.getValue() > maxFreq) {\n                maxFreq = entry.getValue();\n                mostFrequent = entry.getKey();\n            }\n        }\n        \n        String longest = \"\";\n        int maxLen = 0;\n        for (String word : words) {\n            if (word.length() > maxLen) {\n                maxLen = word.length();\n                longest = word;\n            }\n        }\n        \n        System.out.println(mostFrequent + \" \" + longest);\n    }\n}\n", "perturbed_sampled": [" = sc.nextLine(); String[] words = line.split(\" \"); Map<String, Integer> frequency  int maxFreq = 0; for (Map.Entry<String,  maxFreq = entry.getValue(); mostFrequent = entry.getKey(); } } String longest = \"\"; int maxLen = 0; for (String word : words) { if (word.length() > maxLen) { maxLen = word.length(); longest = word; } } System.out.println(mostFrequent + \" \" + longest); } }"], "perturbed_original": ["import java.util.HashMap; import  = new Scanner(System.in); HashMap<String, Integer> map = new  0;  String max = st[0]; int count = 0; for(int i = 0; i < st.length-1; i++){ if(map.get(st[i]) < map.get(st[i+1]))max = st[i+1]; if(st[i].length() < st[i+1].length())count = i+1; } System.out.println(max + \" \" + st[count]); sc.close(); } }"], "original_ll": -0.7484049797058105, "sampled_ll": -0.33789604902267456, "all_perturbed_sampled_ll": [-1.3373668193817139], "all_perturbed_original_ll": [-1.6333717107772827], "perturbed_sampled_ll": -1.3373668193817139, "perturbed_original_ll": -1.6333717107772827, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def solve():\n    text = input()\n    longest, length = '', 0\n    dic = {}\n    for word in text.split():\n        if word in dic.keys():\n            dic[word] += 1\n        else:\n            dic[word] = 1\n        \n        if length < len(word):\n            longest = word\n            length = len(word)\n    \n    target, cnt = '', 0\n    for k, v in dic.items():\n        if v > cnt:\n            target = k\n            cnt = v\n    print(target, longest)\n\nif __name__ == \"__main__\":\n    solve()\n\n", "sampled": "text = input().split()\nword_count = {}\nfor word in text:\n    word_count[word] = word_count.get(word, 0) + 1\n\nmost_frequent = max(word_count, key=word_count.get)\nlongest = max(text, key=len)\n\nprint(most_frequent, longest)\n", "perturbed_sampled": ["text =  word_count.get(word, 0) + 1 most_frequent = max(word_count, key=word_count.get) longest = max(text, key=len) print(most_frequent, longest)"], "perturbed_original": ["def solve(): text = input() longest, length <extra_id_16>cnt: \" + len(longest)<extra_id_17>1, max: -1, max:<extra_id_18>d+1, k - if word in dic.keys(): dic[word] += 1 else: dic[word] = 1 if length < len(word): longest = word length =  dic.items(): if v > cnt: target  \"__main__\": solve()"], "original_ll": -0.9420645833015442, "sampled_ll": -0.9495123624801636, "all_perturbed_sampled_ll": [-1.8944247961044312], "all_perturbed_original_ll": [-3.365518569946289], "perturbed_sampled_ll": -1.8944247961044312, "perturbed_original_ll": -3.365518569946289, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\n\nint val[10];\nint s;\n\nint getWay(int x, int n, int sum)\n{\n\tint ret = 0;\n\tint i;\n\t\n\tif (n == 0){\n\t\tif (sum == s){\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\t\n\tfor (i = x; i < 10; i++){\n\t\tif (val[i] == 0 && sum + i <= s){\n\t\t\tval[i] = 1;\n\t\t\tret += getWay(i, n - 1, i + sum);\n\t\t\tval[i] = 0;\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint main(void)\n{\n\twhile (1){\n\t\tint n;\n\t\t\n\t\tscanf(\"%d%d\", &n, &s);\n\t\tmemset(val, 0, sizeof(val));\n\t\t\n\t\tif (n == 0 && s == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", getWay(0, n, 0));\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n\nint count_combinations(int pos, int n, int s, int used) {\n    if (n == 0) {\n        return (s == 0) ? 1 : 0;\n    }\n    if (pos > 9 || s < 0) {\n        return 0;\n    }\n    \n    int result = 0;\n    // Don't use current digit\n    result += count_combinations(pos + 1, n, s, used);\n    // Use current digit\n    result += count_combinations(pos + 1, n - 1, s - pos, used);\n    \n    return result;\n}\n\nint main() {\n    int n, s;\n    \n    while (1) {\n        scanf(\"%d %d\", &n, &s);\n        if (n == 0 && s == 0) {\n            break;\n        }\n        \n        int result = count_combinations(0, n, s, 0);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int count_combinations(int pos, int n, int  (s == 0) ? 1 : 0; } if (pos > 9 || s < 0) { return 0; } int result = 0; // Don't use current digit result += count_combinations(pos + 1, n,  1, n - 1, s -  s;  0 && s == 0) { break; }  return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int  { int ret = 0; int i; if (n == 0){   = 1; ret += getWay(i, n  return (ret); } int main(void) { while (1){ int n; scanf(\"%d%d\", &n, &s); memset(val, 0, sizeof(val)); if (n == 0 && s == 0){ break; } printf(\"%d\\n\", getWay(0, n, 0)); } return (0); }"], "original_ll": -0.7298691272735596, "sampled_ll": -0.5468301773071289, "all_perturbed_sampled_ll": [-2.1964030265808105], "all_perturbed_original_ll": [-2.038572311401367], "perturbed_sampled_ll": -2.1964030265808105, "perturbed_original_ll": -2.038572311401367, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main {\n    public static void main(String args[]){\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try{\n            String line;\n            \n            while((line=br.readLine())!=null){\n                if(line.equals(\"\"))break;\n                String[] splited = line.split(\" \");\n                int n = Integer.parseInt(splited[0]);\n                s = Integer.parseInt(splited[1]);\n                if(n==0&&s==0)break;if(n>=10)System.out.println(\"0\");\n                    combis(1,n);\n                    System.out.println(count);\n                count=0;\n            }         \n        }catch(Exception e){e.printStackTrace();}\n        \n    }\n    static int[] com = new int[10];\n    static int count = 0,s=0;\n    static void combis(int st,int r){\n        if(st<=r){\n            for(int i=(st==1)? 0:com[st-1]+1;i<=9-r+st;i++){\n                com[st]=i;\n                combis(st+1,r);\n            }\n        }else{\n            //System.out.println(Arrays.toString(com));\n            int sum=0; for(int i=1;i<=r;i++) sum+=com[i];\n            if(sum==s)count++;\n        }\n        \n        }\n    static int _10Cn(int n){\n            int _n=1,d=1;\n            for(int i=1; i<=n;i++){\n                _n*=11-i; d*=i;\n            }\n            return _n/d;\n        }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int s = sc.nextInt();\n            \n            if (n == 0 && s == 0) {\n                break;\n            }\n            \n            int count = countCombinations(n, s, 0, 0);\n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n    \n    private static int countCombinations(int n, int s, int start, int depth) {\n        if (depth == n) {\n            return s == 0 ? 1 : 0;\n        }\n        \n        if (start > 9) {\n            return 0;\n        }\n        \n        int count = 0;\n        for (int i = start; i <= 9; i++) {\n            count += countCombinations(n, s - i, i + 1, depth + 1);\n        }\n        \n        return count;\n    }\n}\n", "perturbed_sampled": ["import  { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); int s = sc.nextInt(); if (n == 0 && s == 0) { break; } int count = countCombinations(n, s,  n, int s, int  (start > 9) { return 0; } int count = 0; for (int i = start; i <= 9; i++) { count  1); } return count; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; <extra_id_1>=<extra_id_2>{ i ++){ if(sum==s)count++;<extra_id_3>i++; if(i--%2==0)count++;<extra_id_4>(i++%3==1){i++; _n=com[i];<extra_id_5>i<=t;i++){<extra_id_6>- i ; }<extra_id_7>r++; i++ ;_n*=n; d*=i,<extra_id_8>]<extra_id_9> br = new BufferedReader(new InputStreamReader(System.in)); try{ String line; while((line=br.readLine())!=null){ if(line.equals(\"\"))break; String[] splited =  combis(1,n); System.out.println(count); count=0; } }catch(Exception e){e.printStackTrace();} } static int[] com = new int[10]; static int count = 0,s=0; static void combis(int st,int r){ if(st<=r){  for(int i=1;i<=r;i++) sum+=com[i]; if(sum==s)count++;  i<=n;i++){ _n*=11-i; d*=i; } return _n/d; } }"], "original_ll": -1.1402502059936523, "sampled_ll": -0.4361085891723633, "all_perturbed_sampled_ll": [-1.7434837818145752], "all_perturbed_original_ll": [-2.315796136856079], "perturbed_sampled_ll": -1.7434837818145752, "perturbed_original_ll": -2.315796136856079, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nsys.setrecursionlimit(10000)\n\ndef solve(i,wa,use):\n    global ct,s,n\n    if wa==s and use==n:\n        ct+=1\n        return\n    if use>=n or i==10 or wa>s:\n        return\n    solve(i+1,wa,use)\n    solve(i+1,wa+i,use+1)\n\nwhile 1:\n    n,s=map(int,raw_input().split())\n    if n==0 and s==0:\n        break\n    ct=0\n    wa=0\n    solve(0,0,0)\n    print ct", "sampled": "from itertools import combinations\n\nwhile True:\n    n, s = map(int, input().split())\n    if n == 0 and s == 0:\n        break\n    \n    count = 0\n    for combo in combinations(range(10), n):\n        if sum(combo) == s:\n            count += 1\n    \n    print(count)\n", "perturbed_sampled": ["from itertools import combinations while True: n, s = map(int, input().split()) if n == 0 and s == 0: break  == s: count += 1 print(count)"], "perturbed_original": ["import sys sys.setrecursionlimit(10000) def solve(i,wa,use): global ct,s,n if wa==s  return solve(i+1,wa,use) solve(i+1,wa+i,use+1) while 1: n,s=map(int,raw_input().split()) if n==0 and s==0: break ct=0 wa=0 solve(0,0,0) print ct"], "original_ll": -1.0525683164596558, "sampled_ll": -0.8878548741340637, "all_perturbed_sampled_ll": [-1.8181301355361938], "all_perturbed_original_ll": [-1.979783535003662], "perturbed_sampled_ll": -1.8181301355361938, "perturbed_original_ll": -1.979783535003662, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0031\nWeight\n*/\n#include <stdio.h>\n\n\nmain()\n{\n  int weight;\n  int fundou;\n  int flag;\n  \n  while(EOF !=scanf(\"%d\",&weight))\n    {\n      flag = 0;\n      for(fundou=1;fundou <= 512;fundou <<= 1)\n      { if(weight & fundou)\n        {\n          if(flag)\n            printf(\" \");\n          printf(\"%d\",fundou);\n          flag = 1;\n        }\n      }\n        printf(\"\\n\");\n    }\n\nreturn(0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int weight;\n    int weights[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};\n    \n    while(scanf(\"%d\", &weight) != EOF) {\n        int first = 1;\n        for(int i = 0; i < 10; i++) {\n            if(weight & (1 << i)) {\n                if(!first) {\n                    printf(\" \");\n                }\n                printf(\"%d\", weights[i]);\n                first = 0;\n            }\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  8, 16, 32, 64, 128, 256, 512}; while(scanf(\"%d\", &weight) != EOF) {  10;  printf(\" \"); } printf(\"%d\", weights[i]); first = 0; } } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["/* AizuOnline A0031 Weight  flag; while(EOF !=scanf(\"%d\",&weight)) { flag = 0; for(fundou=1;fundou <= 512;fundou <<= 1)  = 1; } } printf(\"\\n\"); } return(0); }"], "original_ll": -1.8325436115264893, "sampled_ll": -0.5561484694480896, "all_perturbed_sampled_ll": [-2.0780491828918457], "all_perturbed_original_ll": [-3.345123052597046], "perturbed_sampled_ll": -2.0780491828918457, "perturbed_original_ll": -3.345123052597046, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n        public static void main(String[] args){\n                Scanner sc = new Scanner(System.in);\n                while(sc.hasNext()){\n                        String b = Integer.toString(sc.nextInt(), 2); \n                        String s = \"\"; \n                        for(int i = 0; i < b.length(); i++){\n                                if(b.charAt(b.length()-1-i) == '1'){\n                                        if(!s.equals(\"\")){\n                                                s += \" \";\n                                        }   \n                                        s += (int)Math.pow(2,i);\n                                }   \n                        }   \n                        System.out.println(s);\n                }   \n                sc.close();\n        }   \n}", "sampled": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int weight = sc.nextInt();\n            ArrayList<Integer> weights = new ArrayList<>();\n            \n            int[] powers = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};\n            \n            for (int i = 0; i < powers.length; i++) {\n                if ((weight & (1 << i)) != 0) {\n                    weights.add(powers[i]);\n                }\n            }\n            \n            for (int i = 0; i < weights.size(); i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(weights.get(i));\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; import java.util.ArrayList; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int weight = sc.nextInt(); ArrayList<Integer> weights = (1; int<extra_id_5>1); if(powers.length == 0)<extra_id_6>int[][] weights = (1 << i)) != 0) { weights.add(powers[i]); } } for (int i = 0; i < weights.size(); i++) { (1); while(weights.contains(1);<extra_id_7>0) {<extra_id_8>void<extra_id_9>)<extra_id_10>\" : {<extra_id_11>Main ( ) {<extra_id_12>{<extra_id_13>; } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); while(sc.hasNext()){ String b = Integer.toString(sc.nextInt(), 2); String s = \"\"; for(int ++){ if(s.equals(\"\")){<extra_id_7>s<extra_id_8>=<extra_id_9>{ s+= \"<extra_id_10>;<extra_id_11>i++ } s<extra_id_12>; }<extra_id_13>}<extra_id_14>.<extra_id_15>; } if(!s.equals(\"\")){ s += \" \";  }"], "original_ll": -0.9417181611061096, "sampled_ll": -0.47757869958877563, "all_perturbed_sampled_ll": [-2.1860644817352295], "all_perturbed_original_ll": [-2.096221923828125], "perturbed_sampled_ll": -2.1860644817352295, "perturbed_original_ll": -2.096221923828125, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#encoding=utf-8\nimport itertools as iter\nimport sys\nfor i in sys.stdin:\n    omori = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n    x = int(i)\n    for i in xrange(1,11):\n        for element in iter.combinations(omori,i):\n             if sum(element) == x:\n                 for k in xrange(len(element)):\n                     print element[k],\n                 print \"\"", "sampled": "import sys\n\nfor line in sys.stdin:\n    weight = int(line.strip())\n    weights = []\n    power = 0\n    \n    while weight > 0:\n        if weight & 1:\n            weights.append(2 ** power)\n        weight >>= 1\n        power += 1\n    \n    print(' '.join(map(str, weights)))\n", "perturbed_sampled": ["import  [] power = 0 while weight > 0: if weight & 1: weights.append(2 ** power) weight >>= 1 power += 1 print(' '.join(map(str, weights)))"], "perturbed_original": ["#encoding=utf-8  128, 256, 512] x = int(i) for i in xrange(1,11): for element in iter.combinations(omori,i): if sum(element) == x: for k in xrange(len(element)): print element[k], print \"\""], "original_ll": -1.4095820188522339, "sampled_ll": -1.1125847101211548, "all_perturbed_sampled_ll": [-2.2900075912475586], "all_perturbed_original_ll": [-3.357701539993286], "perturbed_sampled_ll": -2.2900075912475586, "perturbed_original_ll": -3.357701539993286, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint tyou=0, hisi=0;\n\tint a, b, c;\n\t\n\twhile(scanf(\"%d,%d,%d\", &a, &b, &c)!=EOF) {\n\t\tif(c*c==a*a+b*b) tyou++;\n\t\tif(a==b) hisi++;\n\t}\n\t\n\tprintf(\"%d\\n%d\\n\", tyou, hisi);\n\t\n\treturn 0;\n}\n", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[256];\n    int rectangles = 0;\n    int rhombuses = 0;\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int a, b, c;\n        if (sscanf(line, \"%d,%d,%d\", &a, &b, &c) == 3) {\n            // Check if it's a rectangle: a^2 + b^2 = c^2\n            if (a * a + b * b == c * c) {\n                rectangles++;\n            }\n            // Check if it's a rhombus: a = b\n            else if (a == b) {\n                rhombuses++;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", rectangles);\n    printf(\"%d\\n\", rhombuses);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char line[256]; int rectangles = 0; int rhombuses = 0;  Check if  c) { rectangles++; } // Check if it's a rhombus: a = b else if (a == b) { rhombuses++; } } } printf(\"%d\\n\", rectangles); printf(\"%d\\n\", rhombuses); return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int tyou=0, hisi=0; int a, b, c; while(scanf(\"%d,%d,%d\", &a, &b, &c)!=EOF) {  }"], "original_ll": -1.3021458387374878, "sampled_ll": -0.5449933409690857, "all_perturbed_sampled_ll": [-1.994529128074646], "all_perturbed_original_ll": [-2.054755926132202], "perturbed_sampled_ll": -1.994529128074646, "perturbed_original_ll": -2.054755926132202, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = null;\n\t\ttry {\n\t\t\tsc = new Scanner(System.in);\n\t\t\tint countRectangle = 0;\n\t\t\tint countRhombus = 0;\n\t\t\twhile (sc.hasNextLine()) {\n\t\t\t\tString[] input = sc.nextLine().split(\",\");\n\t\t\t\tint[] x = new int[3];\n\t\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\t\tx[i] = Integer.parseInt(input[i]);\n\t\t\t\tif (x[0] * x[0] + x[1] * x[1] == x[2] * x[2])\n\t\t\t\t\tcountRectangle++;\n\t\t\t\telse if (x[0] == x[1])\n\t\t\t\t\tcountRhombus++;\n\t\t\t}\n\t\t\tSystem.out.println(countRectangle);\n\t\t\tSystem.out.println(countRhombus);\n\t\t} finally {\n\t\t\tsc.close();\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int rectangles = 0;\n        int rhombuses = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            int c = Integer.parseInt(parts[2]);\n            \n            // Check if rectangle: a^2 + b^2 = c^2 (diagonal satisfies Pythagorean theorem)\n            if (a * a + b * b == c * c) {\n                rectangles++;\n            }\n            // Check if rhombus: all sides equal (a == b)\n            else if (a == b) {\n                rhombuses++;\n            }\n        }\n        \n        System.out.println(rectangles);\n        System.out.println(rhombuses);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  Scanner sc = new Scanner(System.in); int rectangles = 0;  sc.nextLine().trim(); if (line.isEmpty()) break; String[] parts = line.split(\",\"); int a = Integer.parseInt(parts[0]); int b = Integer.parseInt(parts[1]); int c = Integer.parseInt(parts[2]); // Check if rectangle: a^2 + b^2 = c^2 (diagonal satisfies  == c * c) { rectangles++;  b)  System.out.println(rhombuses); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void  = 0; while (sc.hasNextLine()) { String[] input = sc.nextLine().split(\",\"); int[] x = new int[3]; for (int i = 0; i  + x[1] * x[1] == x[2] * x[2])  } finally { sc.close(); } } }"], "original_ll": -0.6085971593856812, "sampled_ll": -0.625332236289978, "all_perturbed_sampled_ll": [-2.201338291168213], "all_perturbed_original_ll": [-1.7382400035858154], "perturbed_sampled_ll": -2.201338291168213, "perturbed_original_ll": -1.7382400035858154, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nnum1=0                                          #\u9577\u65b9\u5f62\u306e\u6570                                                 \nnum2=0                                          #\u3072\u3057\u5f62\u306e\u6570\nwhile True:\n    try:\n        a,b,c=list(map(int, input().split(\",\")))\n    except:\n        break\n    \n    if pow(a,2)+pow(b,2)==pow(c,2):\n        num1+=1\n    elif a==b and a+b>c:\n        num2+=1\n\nprint(num1)\nprint(num2)\n\n", "sampled": "import sys\nimport math\n\nrectangle_count = 0\nrhombus_count = 0\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    \n    parts = line.split(',')\n    a, b, c = int(parts[0]), int(parts[1]), int(parts[2])\n    \n    # Check if it's a rectangle\n    # In a rectangle, the diagonal satisfies: c^2 = a^2 + b^2\n    if a * a + b * b == c * c:\n        rectangle_count += 1\n    \n    # Check if it's a rhombus\n    # In a rhombus, all sides are equal: a == b\n    if a == b:\n        rhombus_count += 1\n\nprint(rectangle_count)\nprint(rhombus_count)\n", "perturbed_sampled": ["import sys import math rectangle_count = 0 rhombus_count = 0 for  parts = line.split(',') a, b, c = int(parts[0]), int(parts[1]), int(parts[2]) # Check if it's a rectangle # In  c * c: rectangle_count += 1 # Check  are equal: a == b if a == b: rhombus_count += 1 print(rectangle_count) print(rhombus_count)"], "perturbed_original": ["import math num1=0 #\u9577\u65b9\u5f62\u306e\u6570 num2=0 #\u3072\u3057\u5f62\u306e\u6570 while True: try: a,b,c=list(map(int,  num2+=1 print(num1) print(num2)"], "original_ll": -1.7513809204101562, "sampled_ll": -0.7385423183441162, "all_perturbed_sampled_ll": [-2.244699001312256], "all_perturbed_original_ll": [-3.250673532485962], "perturbed_sampled_ll": -2.244699001312256, "perturbed_original_ll": -3.250673532485962, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n\n\tint i,j,n,a[10],b,c,nflag;\n\n\tscanf(\"%d\",&n);\n\n\tfor(i=0;i<n;i++){\n\t\tnflag=0;\n\t\tfor(j=0;j<9;j++) scanf(\"%d \",&a[j]);\n\t\tscanf(\"%d\",&a[9]);\n\n\t\tb=a[0];\n\t\tc=0;\n\t\tfor(j=1;j<10;j++){\n\t\t\tif(b<a[j]) b=a[j];\n\t\t\telse if(c<a[j]) c=a[j];\n\t\t\telse{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\tnflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(nflag) continue;\n\t\tprintf(\"YES\\n\");\n\n\t}\n\n\n\n\treturn 0;\n\n}", "sampled": "#include <stdio.h>\n#include <stdbool.h>\n\nbool canArrange(int balls[10]) {\n    // Try all possible combinations of putting balls in B or C\n    // Use bitmask: 0 = put in B, 1 = put in C\n    for (int mask = 0; mask < (1 << 10); mask++) {\n        int b[10], c[10];\n        int bCount = 0, cCount = 0;\n        bool valid = true;\n        \n        // Distribute balls according to mask\n        for (int i = 0; i < 10; i++) {\n            if ((mask & (1 << i)) == 0) {\n                // Put in B\n                if (bCount > 0 && b[bCount - 1] > balls[i]) {\n                    valid = false;\n                    break;\n                }\n                b[bCount++] = balls[i];\n            } else {\n                // Put in C\n                if (cCount > 0 && c[cCount - 1] > balls[i]) {\n                    valid = false;\n                    break;\n                }\n                c[cCount++] = balls[i];\n            }\n        }\n        \n        if (valid) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        int balls[10];\n        for (int j = 0; j < 10; j++) {\n            scanf(\"%d\", &balls[j]);\n        }\n        \n        if (canArrange(balls)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdbool.h> bool canArrange(int balls[10]) { // Try all possible combinations of putting balls in B  1 = put in C for (int mask = 0; mask < (1 << 10); mask++) { int b[10], c[10]; int bCount  (1 << i)) == 0) { // Put in B if (bCount > 0 && b[bCount - 1] > balls[i]) { valid =  - 1] > balls[i]) { valid = false; break; } c[cCount++] = balls[i]; } } if (valid) { return true; } } return false; }  for (int j  if (canArrange(balls)) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int  b=a[0]; c=0; for(j=1;j<10;j++){ if(b<a[j]) b=a[j]; else if(c<a[j]) c=a[j]; else{ printf(\"NO\\n\"); nflag=1; break; } } if(nflag) continue; printf(\"YES\\n\"); } return 0; }"], "original_ll": -1.0201002359390259, "sampled_ll": -0.5068585276603699, "all_perturbed_sampled_ll": [-1.834646224975586], "all_perturbed_original_ll": [-1.8535302877426147], "perturbed_sampled_ll": -1.834646224975586, "perturbed_original_ll": -1.8535302877426147, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static final int N = 12;\n\tint[] a = new int[N];\n\tint small = 0;\n\tint big = 0;\n\t\n\tprivate int s=0;     //\u6570?\u7684\u4e2a\u6570\n\t\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.Sort();\n\t}\n\t\n\t\n\tprivate void Sort(){\t\n\n\t\tScanner sc = new Scanner(System.in);\n\t\ts = sc.nextInt();\n\t\t\n\t\twhile(s!= 0){\t\n\t\t\t\n\t\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t/*for (int m = 1; m <= 10; m++) {\n\t\t\t\tSystem.out.print(a[m]+ \" \");\n\t\t\t}*/\n\t\t\t\n\t\t\tif (a[1] > a[2]) {\n\t\t\t\tbig = a[1];\n\t\t\t\tsmall = a[2];\n\t\t\t}else {\n\t\t\t\tbig = a[2];\n\t\t\t\tsmall = a[1];\n\t\t\t}\n\t\t\t//System.out.println(big);\n\t\t\t\n\t\t\tfor (int j = 3; j <= 10; j++) {\n\t\t\t\tif (a[j] > big) {\n\t\t\t\t\tbig = a[j];\n\t\t\t\t}\n\t\t\t\tif (a[j] < big && a[j] > small) {\n\t\t\t\t\tsmall = a[j];\n\t\t\t\t}\n\t\t\t\tif (a[j] < small) {\n\t\t\t\t\tSystem.out.printf(\"%s\\n\",\"NO\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 10) {\n\t\t\t\t\tSystem.out.printf(\"%s\\n\",\"YES\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(s);\n\t\t\ts--;\n\t\t\t\t\n\t\t}\n\t\tsc.close();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[] balls;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            balls = new int[10];\n            for (int j = 0; j < 10; j++) {\n                balls[j] = sc.nextInt();\n            }\n            \n            if (canArrange(0, new ArrayList<>(), new ArrayList<>())) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        sc.close();\n    }\n    \n    static boolean canArrange(int index, List<Integer> b, List<Integer> c) {\n        if (index == 10) {\n            return true;\n        }\n        \n        int current = balls[index];\n        \n        // Try to put in B\n        boolean canPutInB = true;\n        if (!b.isEmpty() && b.get(b.size() - 1) > current) {\n            canPutInB = false;\n        }\n        \n        if (canPutInB) {\n            b.add(current);\n            if (canArrange(index + 1, b, c)) {\n                return true;\n            }\n            b.remove(b.size() - 1);\n        }\n        \n        // Try to put in C\n        boolean canPutInC = true;\n        if (!c.isEmpty() && c.get(c.size() - 1) > current) {\n            canPutInC = false;\n        }\n        \n        if (canPutInC) {\n            c.add(current);\n            if (canArrange(index + 1, b, c)) {\n                return true;\n            }\n            c.remove(c.size() - 1);\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int[] balls; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i =  for (int j = 0; j < 10; j++) { balls[j] = sc.nextInt(); } if (canArrange(0, new ArrayList<>(), new ArrayList<>())) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close();  current = balls[index];  canPutInB = false; } if (canPutInB) { b.add(current); if  - 1); } // Try to put in C boolean canPutInC = true; if (!c.isEmpty() &&  if (canPutInC) { c.add(current); if  - 1); } return false; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { private static final int ; #if<extra_id_1>System.out.println(m); m<extra_id_2>a[9]; b<extra_id_3>}<extra_id_4>.<extra_id_5>; public<extra_id_6>( int small )<extra_id_7>;<extra_id_8>; //<extra_id_9>} }<extra_id_10>new IntArrayList(a);<extra_id_11>(<extra_id_12>int<extra_id_13>; }<extra_id_14>if (a[z],<extra_id_15>(char<extra_id_16>int<extra_id_17>int j<extra_id_18>{ int<extra_id_19>, int small = small<extra_id_20>0 ] ; for (<extra_id_21>( int i =<extra_id_22>;<extra_id_23>&& = 0; int big =  { Main  sc = new Scanner(System.in); s = sc.nextInt(); while(s!= 0){ for (int i = 1; i <= 10; i++) { a[i] = sc.nextInt(); } /*for (int  a[1]; small = a[2]; }else { big = a[2]; small = a[1]; } //System.out.println(big); for (int j = 3; j <= 10;  } if (a[j] < big && a[j]  small) {  } } //System.out.println(s); s--; } sc.close(); } }"], "original_ll": -0.9099321365356445, "sampled_ll": -0.35531163215637207, "all_perturbed_sampled_ll": [-1.626328706741333], "all_perturbed_original_ll": [-2.155822515487671], "perturbed_sampled_ll": -1.626328706741333, "perturbed_original_ll": -2.155822515487671, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for data in range(input()):\n    dataset=map(int,raw_input().split(\" \"))\n    B,C=0,0\n    B=dataset.pop(0)\n    while len(dataset)!=0:\n        ball = dataset.pop(0)\n        if ball-B<0 or ball-C<0:\n            if ball-B<0 and ball-C<0:\n                print \"NO\"\n                break\n            elif ball-B<0:\n                C=ball\n            else:\n                B=ball\n        else:\n            if ball-B<ball-C:\n                B=ball\n            else:\n                C=ball\n    if(len(dataset)==0):\n        print \"YES\"", "sampled": "def can_sort(sequence):\n    def is_valid(b_stack, c_stack, index):\n        if index == 10:\n            return True\n        \n        ball = sequence[index]\n        \n        # Try putting in B\n        can_put_b = len(b_stack) == 0 or b_stack[-1] < ball\n        if can_put_b:\n            b_stack.append(ball)\n            if is_valid(b_stack, c_stack, index + 1):\n                return True\n            b_stack.pop()\n        \n        # Try putting in C\n        can_put_c = len(c_stack) == 0 or c_stack[-1] < ball\n        if can_put_c:\n            c_stack.append(ball)\n            if is_valid(b_stack, c_stack, index + 1):\n                return True\n            c_stack.pop()\n        \n        return False\n    \n    return is_valid([], [], 0)\n\nn = int(input())\nfor _ in range(n):\n    sequence = list(map(int, input().split()))\n    if can_sort(sequence):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": [" return True ball = sequence[index] # Try putting in B can_put_b = len(b_stack) == 0  index + 1): return True b_stack.pop() # Try putting in C can_put_c = len(c_stack) == 0 or c_stack[-1] < ball if can_put_c: c_stack.append(ball) if is_valid(b_stack,  is_valid([], [],  list(map(int, input().split())) if can_sort(sequence): print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["for data in range(input()): dataset=map(int,raw_input().split(\" \")) B,C=0,0 B=dataset.pop(0) while len(dataset)!=0: ball = dataset.pop(0) if ball-B<0 or ball-C<0: if ball-B<0 and  if ball-B<ball-C: B=ball else: C=ball if(len(dataset)==0): print \"YES\""], "original_ll": -1.021568775177002, "sampled_ll": -0.7077993750572205, "all_perturbed_sampled_ll": [-2.5673019886016846], "all_perturbed_original_ll": [-1.9721133708953857], "perturbed_sampled_ll": -2.5673019886016846, "perturbed_original_ll": -1.9721133708953857, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nmain(){\n  int i,ans;\n  double l[10],km,k,v[2];\n  while(scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\",&l[0],&l[1],&l[2],&l[3],&l[4],&l[5],&l[6],&l[7],&l[8],&l[9],&v[0],&v[1])!=EOF){\n    km=l[0]+l[1]+l[2]+l[3]+l[4]+l[5]+l[6]+l[7]+l[8]+l[9];\n    k=km*v[0]/(v[0]+v[1]);\n    for(i=0;i>=0;i++){\n      k-=l[i];\n      if(k<=0){\n\tans=i+1;\n\ti=-2;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[256];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int l[10];\n        int v1, v2;\n        \n        sscanf(line, \"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\",\n               &l[0], &l[1], &l[2], &l[3], &l[4],\n               &l[5], &l[6], &l[7], &l[8], &l[9],\n               &v1, &v2);\n        \n        // Calculate total distance\n        int total = 0;\n        for (int i = 0; i < 10; i++) {\n            total += l[i];\n        }\n        \n        // Calculate cumulative distances from left\n        int cum[11];\n        cum[0] = 0;\n        for (int i = 0; i < 10; i++) {\n            cum[i + 1] = cum[i] + l[i];\n        }\n        \n        // Find meeting point\n        // Train 1 travels distance d1 = v1 * t\n        // Train 2 travels distance d2 = v2 * t\n        // d1 + d2 = total\n        // v1 * t + v2 * t = total\n        // t = total / (v1 + v2)\n        // d1 = v1 * total / (v1 + v2)\n        \n        double d1 = (double)v1 * total / (v1 + v2);\n        \n        // Find which section this is in\n        for (int i = 0; i < 10; i++) {\n            if (d1 <= cum[i + 1]) {\n                printf(\"%d\\n\", i + 1);\n                break;\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char line[256]; while (fgets(line, sizeof(line), stdin)) { int l[10]; int v1, v2; sscanf(line, \"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\", &l[0], &l[1], &l[2],  Calculate total distance int total = 0; for (int i = 0; i < 10; i++) { total += l[i]; } // Calculate cumulative distances from  0; i < 10; i++) { cum[i + 1] = cum[i] + l[i]; } // Find meeting point // Train 1 travels distance d1  = v2 * t // d1 + d2 = total  v2); // Find which section this is in for (int i = 0;  } return 0; }"], "perturbed_original": ["#include<stdio.h> main(){ int i,ans; double  } printf(\"%d\\n\",ans); } return 0; }"], "original_ll": -0.8298017382621765, "sampled_ll": -0.5888370871543884, "all_perturbed_sampled_ll": [-1.6555495262145996], "all_perturbed_original_ll": [-3.5329413414001465], "perturbed_sampled_ll": -1.6555495262145996, "perturbed_original_ll": -3.5329413414001465, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = null;\n\t\tint[] l = new int[10];\n\t\tint[] v = new int[2];\n\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tString[] data = line.trim().split(\",\");\n\t\t\tint distance = 0;\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tl[i] = Integer.parseInt(data[i]);\n\t\t\t\tdistance += l[i];\n\t\t\t}\n\t\t\tfor (int i = 0; i < 2; i++)\n\t\t\t\tv[i] = Integer.parseInt(data[i + 10]);\n\t\t\tdouble see = distance * ((double) v[0] / (v[1] + v[0]));\n\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif (see - l[i] > 0) {\n\t\t\t\t\tsee -= l[i];\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(i + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            line = line.trim();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            int[] lengths = new int[10];\n            for (int i = 0; i < 10; i++) {\n                lengths[i] = Integer.parseInt(parts[i].trim());\n            }\n            int v1 = Integer.parseInt(parts[10].trim());\n            int v2 = Integer.parseInt(parts[11].trim());\n            \n            // Calculate cumulative distances from station 0\n            int[] cumDist = new int[11];\n            cumDist[0] = 0;\n            for (int i = 0; i < 10; i++) {\n                cumDist[i + 1] = cumDist[i] + lengths[i];\n            }\n            int totalDistance = cumDist[10];\n            \n            // They meet when: distance1 + distance2 = totalDistance\n            // time is same for both: t = distance1 / v1 = distance2 / v2\n            // distance1 = v1 * t, distance2 = v2 * t\n            // v1 * t + v2 * t = totalDistance\n            // t = totalDistance / (v1 + v2)\n            // distance1 = v1 * totalDistance / (v1 + v2)\n            \n            double meetDistance = (double) v1 * totalDistance / (v1 + v2);\n            \n            // Find which section this distance falls into\n            int section = 1;\n            for (int i = 1; i <= 10; i++) {\n                if (meetDistance <= cumDist[i]) {\n                    section = i;\n                    break;\n                }\n            }\n            \n            System.out.println(section);\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { public static void main(String[] args)  line; while ((line = br.readLine()) != null) { line = line.trim(); if (line.isEmpty()) break; String[] parts = line.split(\",\"); int[] lengths = new int[10]; for (int i = 0; i < 10; i++) { lengths[i] = Integer.parseInt(parts[i].trim()); } int v1 = Integer.parseInt(parts[10].trim());  { cumDist[i + 1]  They meet when: distance1 + distance2 = totalDistance // time is  / v2 // distance1 = v1 * t, distance2 = v2 * t // v1 * t + v2 *  v2) // distance1  = (double) v1 * totalDistance / (v1 + v2);  10; i++) { if (meetDistance <= cumDist[i]) { section = i; break; } } System.out.println(section); } } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = null; int[] l = new int[10]; int[] v  String[] data = line.trim().split(\",\"); int distance = 0; for  =  i < 2; i++)  ((double) v[0] / (v[1] + v[0])); for  (see  { System.out.println(i + 1); break; } } } } }"], "original_ll": -0.6467524170875549, "sampled_ll": -0.6440221667289734, "all_perturbed_sampled_ll": [-1.7662811279296875], "all_perturbed_original_ll": [-1.9353926181793213], "perturbed_sampled_ll": -1.7662811279296875, "perturbed_original_ll": -1.9353926181793213, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,v1,v2=map(int,input().split(\",\"))\n        kyo=0\n        for i in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10:\n            kyo +=i\n        v=v1+v2\n        x=kyo/v\n        ans=v1*x\n        flag=0\n        for j in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10:\n            if ans>0:\n                ans -=j\n                flag +=1\n            elif ans==0:\n                print(flag)\n                break\n            elif ans<0:\n                print(flag)\n                break\n    except:break\n\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    parts = line.strip().split(',')\n    lengths = list(map(int, parts[:10]))\n    v1, v2 = int(parts[10]), int(parts[11])\n    \n    total_length = sum(lengths)\n    \n    # Time when trains meet\n    t_meet = total_length / (v1 + v2)\n    \n    # Distance traveled by train from section 1 side\n    d1 = v1 * t_meet\n    \n    # Find which section this distance falls into\n    cumulative = 0\n    for i in range(10):\n        cumulative += lengths[i]\n        if d1 <= cumulative:\n            print(i + 1)\n            break\n", "perturbed_sampled": [" = list(map(int, parts[:10])) v1, v2 = int(parts[10]), int(parts[11]) total_length =  (v1 + v2) # Distance traveled by train from section 1 side d1 = v1 *  = 0 for i in range(10): cumulative += lengths[i] if d1 <= cumulative: print(i + 1) break"], "perturbed_original": ["while True: try: l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,v1,v2=map(int,input().split(\",\"))  flag=0 for j in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10: if ans>0: ans -=j flag +=1 elif ans==0: print(flag) break elif ans<0: print(flag) break except:break"], "original_ll": -1.040817379951477, "sampled_ll": -1.2569373846054077, "all_perturbed_sampled_ll": [-2.5353853702545166], "all_perturbed_original_ll": [-1.4868983030319214], "perturbed_sampled_ll": -2.5353853702545166, "perturbed_original_ll": -1.4868983030319214, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\ndouble gaiseki(double x0,double y0,double x1,double y1,double x2,double y2){\nreturn(x0-x1)*(y0-y1)-(x0-x2)*(y0-y2);\n}\nint main(){\ndouble x0,y0,x1,y1,x2,y2,x3,y3;\nwhile (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3)!=EOF){\nif (gaiseki(x0,y0,x1,y1,x3,y3)>=0&&gaiseki(x1,y1,x2,y2,x3,y3)>=0&&gaiseki(x2,y2,x0,y0,x3,y3)>=0){\nprintf(\"YES\\n\");\n}else{\nprintf(\"NO\\n\");\n}\n}\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\ndouble cross(double ax, double ay, double bx, double by, double cx, double cy) {\n    return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);\n}\n\nint main() {\n    double xa, ya, xb, yb, xc, yc, xd, yd;\n    \n    while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\", \n                 &xa, &ya, &xb, &yb, &xc, &yc, &xd, &yd) == 8) {\n        \n        double c1 = cross(xa, ya, xb, yb, xc, yc);\n        double c2 = cross(xb, yb, xc, yc, xd, yd);\n        double c3 = cross(xc, yc, xd, yd, xa, ya);\n        double c4 = cross(xd, yd, xa, ya, xb, yb);\n        \n        if ((c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0) ||\n            (c1 < 0 && c2 < 0 && c3 < 0 && c4 < 0)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> double cross(double ax, double ay, double bx, double by, double cx, double  -  {  (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\", &xa, &ya, &xb,  = cross(xa, ya, xb,  xa, ya); double c4 = cross(xd, yd, xa, ya, xb, yb); if ((c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0) || (c1 < 0 && c2 < 0 && c3 < 0 && c4 < 0)) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> double gaiseki(double x0,double y0,double x1,double y1,double x2,double y2){ return(x0-x1)*(y0-y1)-(x0-x2)*(y0-y2); } int main(){ double x0,y0,x1,y1,x2,y2,x3,y3; while  }"], "original_ll": -0.6555150151252747, "sampled_ll": -0.35708603262901306, "all_perturbed_sampled_ll": [-1.367800235748291], "all_perturbed_original_ll": [-1.687037467956543], "perturbed_sampled_ll": -1.367800235748291, "perturbed_original_ll": -1.687037467956543, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;class Main{public static void main(String[]z){double[]b=new double[8];for(Scanner s=new Scanner(System.in);s.hasNext();System.out.println((f(b[0],b[1],b[4],b[5],b[6],b[7])>0&&f(b[4],b[5],b[0],b[1],b[2],b[3])>0&&f(b[2],b[3],b[6],b[7],b[0],b[1])>0&&f(b[6],b[7],b[2],b[3],b[4],b[5])>0)||(f(b[0],b[1],b[4],b[5],b[6],b[7])<0&&f(b[4],b[5],b[0],b[1],b[2],b[3])<0&&f(b[2],b[3],b[6],b[7],b[0],b[1])<0&&f(b[6],b[7],b[2],b[3],b[4],b[5])<0)?\"YES\":\"NO\")){z=s.next().split(\",\");for(int i=0;i<8;++i)b[i]=new Double(z[i]);}}static double f(double a,double b,double c,double d,double e,double f){return ((d-b)*e+(a-c)*f+c*b-a*d);}}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            \n            double xa = Double.parseDouble(parts[0]);\n            double ya = Double.parseDouble(parts[1]);\n            double xb = Double.parseDouble(parts[2]);\n            double yb = Double.parseDouble(parts[3]);\n            double xc = Double.parseDouble(parts[4]);\n            double yc = Double.parseDouble(parts[5]);\n            double xd = Double.parseDouble(parts[6]);\n            double yd = Double.parseDouble(parts[7]);\n            \n            double cross1 = crossProduct(xa, ya, xb, yb, xc, yc);\n            double cross2 = crossProduct(xb, yb, xc, yc, xd, yd);\n            double cross3 = crossProduct(xc, yc, xd, yd, xa, ya);\n            double cross4 = crossProduct(xd, yd, xa, ya, xb, yb);\n            \n            boolean allPositive = cross1 > 0 && cross2 > 0 && cross3 > 0 && cross4 > 0;\n            boolean allNegative = cross1 < 0 && cross2 < 0 && cross3 < 0 && cross4 < 0;\n            \n            if (allPositive || allNegative) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static double crossProduct(double x1, double y1, double x2, double y2, double x3, double y3) {\n        double v1x = x2 - x1;\n        double v1y = y2 - y1;\n        double v2x = x3 - x2;\n        double v2y = y3 - y2;\n        return v1x * v2y - v1y * v2x;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main  = Double.parseDouble(parts[3]); double xc = Double.parseDouble(parts[4]); double yc = Double.parseDouble(parts[5]); double xd = Double.parseDouble(parts[6]); double yd = Double.parseDouble(parts[7]); double cross1 = crossProduct(xa, ya, xb, yb, xc, yc); double cross2 = crossProduct(xb, yb, xc, yc, xd,  double  = cross1 > 0 && cross2 > 0 && cross3 > 0  && cross2 < 0 && cross3 < 0 && cross4 < 0; if (allPositive || allNegative) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); } private static double  double y3) { double v1x = x2 - x1; double v1y = y2 - y1; double v2x = x3 - x2;  - v1y * v2x; } }"], "perturbed_original": ["import java.util.*;class Main{public static void main(String[]z){double[]b=new double[8];for(Scanner s=new Scanner(System.in);s.hasNext();System.out.println((f(b[0],b[1],b[4],b[5],b[6],b[7])>0&&f(b[4],b[5],b[0],b[1],b[2],b[3])>0&&f(b[2],b[3],b[6],b[7],b[0],b[1])>0&&f(b[6],b[7],b[2],b[3],b[4],b[5])>0)||(f(b[0],b[1],b[4],b[5],b[6],b[7])<0&&f(b[4],b[5],b[0],b[1],b[2],b[3])<0&&f(b[2],b[3],b[6],b[7],b[0],b[1])<0&&f(b[6],b[7],b[2],b[3],b[4],b[5])<0)?\"YES\":\"NO\")){z=s.next().split(\",\");for(int  ((d-b)*e+(a-c)*f+c*b-a*d);}}"], "original_ll": -0.7121915221214294, "sampled_ll": -0.2333115041255951, "all_perturbed_sampled_ll": [-1.3220343589782715], "all_perturbed_original_ll": [-0.8982469439506531], "perturbed_sampled_ll": -1.3220343589782715, "perturbed_original_ll": -0.8982469439506531, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from __future__ import (division, absolute_import, print_function,\n                        unicode_literals)\nfrom sys import stdin\nfrom collections import namedtuple\nPoint = namedtuple('Point', 'x y')\n\ndef make_test(p1, p2):\n    if p1.x == p2.x:\n        gradient = p1.x\n        return lambda p: gradient > p.x\n    gradient = (p1.y - p2.y) / (p1.x - p2.x)\n    y_intercept = p1.y - gradient * p1.x\n    return lambda p: gradient * p.x + y_intercept > p.y\n\nfor line in stdin:\n    it = (float(s) for s in line.split(','))\n    A, B, C, D = (Point(next(it), next(it)) for _ in xrange(4))\n\n    f = make_test(A, C)\n    g = make_test(B, D)\n    if f(B) == f(D) or g(A) == g(C):\n        print('NO')\n    else:\n        print('YES')", "sampled": "import sys\n\ndef cross_product(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef is_convex(points):\n    n = len(points)\n    sign = None\n    \n    for i in range(n):\n        o = points[i]\n        a = points[(i + 1) % n]\n        b = points[(i + 2) % n]\n        \n        cp = cross_product(o, a, b)\n        \n        if cp != 0:\n            if sign is None:\n                sign = cp > 0\n            elif (cp > 0) != sign:\n                return False\n    \n    return True\n\nfor line in sys.stdin:\n    coords = list(map(float, line.strip().split(',')))\n    points = [(coords[i], coords[i+1]) for i in range(0, 8, 2)]\n    \n    if is_convex(points):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": [" * (b[1] -  1) % n] b = points[(i + 2) % n] cp = cross_product(o, a, b) if cp != 0: if sign is None: sign = cp > 0 elif (cp  in sys.stdin: coords = list(map(float, line.strip().split(','))) points = [(coords[i], coords[i+1]) for i in range(0, 8, 2)] if is_convex(points): print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["from __future__ import (division, absolute_import, print_function, unicode_literals) from sys import stdin from collections import namedtuple Point = namedtuple('Point',  =  - gradient * p1.x return lambda p: gradient * p.x + y_intercept > p.y for  A, B, C, D = (Point(next(it), next(it)) for _ in xrange(4)) f = make_test(A,  g(A) == g(C): print('NO') else: print('YES')"], "original_ll": -0.9555858373641968, "sampled_ll": -0.49204567074775696, "all_perturbed_sampled_ll": [-2.0040628910064697], "all_perturbed_original_ll": [-2.745328426361084], "perturbed_sampled_ll": -2.0040628910064697, "perturbed_original_ll": -2.745328426361084, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\n#define X 8\n#define Y 8\n#define L 3\n#define M 2\n#define S 1\n\n\nint main(void)\n{\n        char ppr[X][Y];/*\u7d19*/\n        int x = 0, y = 0;\n        int i = 0, j = 0;\n        int size = 0;\n        int count = 0;\n        int max = 0;\n        int farst = 0;\n        int k = 0;\n        int h = 0;\n        char ans[4][2];\n\n        for(i = 0; i < X; i++)\n        {\n                for(j = 0;j < Y; j++)\n                {\n                        ppr[i][j] = '0';\n                }\n        }\n\n        for(i = 0; i < 4; i++)\n        {\n                for(j = 0;j < 2; j++)\n                {\n                        ans[i][j] = '0';\n                }\n        }\n\n        while(scanf(\"%s\", ppr[0]) != EOF)\n        {\n                for(i = 1; i < X; i++)\n                {\n                        scanf(\"%s\", ppr[i]);\n                }\n                for(i = 0; i < X; i++)\n                {\n                        for(j = 0; j < Y; j++)\n                        {\n                                if( ppr[i][j] == '1')\n                                {\n                                        ans[k][0] = j;\n                                        ans[k][1] = i;\n                                        k++;\n                                }\n                        }\n                }\n/*\n                for(i = 0;i < 4; i++)\n                {\n                        printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n                }\n*/\n                x = ans[0][0];\n                y = ans[0][1];\n                ans[0][0] -= x; ans[0][1] -= y;\n                ans[1][0] -= x; ans[1][1] -= y;\n                ans[2][0] -= x; ans[2][1] -= y;\n                ans[3][0] -= x; ans[3][1] -= y;\n                /*\n                for(i = 0;i < 4; i++)\n                {\n                        printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n                }*/\n\n                if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                   ans[1][0] ==  0 && ans[1][1] == 1 &&\n                   ans[2][0] ==  1 && ans[2][1] == 0 &&\n                   ans[3][0] ==  1 && ans[3][1] == 1 )\n                {\n                        printf(\"A\\n\");\n                }\n                else if(ans[0][0] == 0 &&ans[0][1] == 0 &&\n                   ans[1][0] ==  1 && ans[1][1] == 0 &&\n                   ans[2][0] ==  2 && ans[2][1] == 0 &&\n                   ans[3][0] ==  3 && ans[3][1] == 0 )\n                {\n                        printf(\"B\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                        ans[1][0] ==  0 && ans[1][1] == 1 &&\n                        ans[2][0] ==  0 && ans[2][1] == 2 &&\n                        ans[3][0] ==  0 && ans[3][1] == 3 )\n                {\n                        printf(\"C\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 1 &&\n                        ans[1][0] ==  1 && ans[1][1] == 0 &&\n                        ans[2][0] ==  1 && ans[2][1] == 1 &&\n                        ans[3][0] ==  2 && ans[3][1] == 0 )\n                {\n                        printf(\"D\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                        ans[1][0] ==  0 && ans[1][1] == 1 &&\n                        ans[2][0] ==  1 && ans[2][1] == 1 &&\n                        ans[3][0] ==  1 && ans[3][1] == 2 )\n                {\n                        printf(\"E\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                        ans[1][0] ==  1 && ans[1][1] == 0 &&\n                        ans[2][0] ==  1 && ans[2][1] == 1 &&\n                        ans[3][0] ==  2 && ans[3][1] == 1 )\n                {\n                        printf(\"F\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 1 &&\n                        ans[1][0] ==  0 && ans[1][1] == 2 &&\n                        ans[2][0] ==  1 && ans[2][1] == 0 &&\n                        ans[3][0] ==  1 && ans[3][1] == 1 )\n                {\n                        printf(\"G\\n\");\n                }\n\n\n        }\n\n        return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char grid[8][9];\n    \n    while(scanf(\"%s\", grid[0]) != EOF) {\n        for(int i = 1; i < 8; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        // Extract the shape pattern\n        int minR = 8, maxR = -1, minC = 8, maxC = -1;\n        for(int i = 0; i < 8; i++) {\n            for(int j = 0; j < 8; j++) {\n                if(grid[i][j] == '1') {\n                    if(i < minR) minR = i;\n                    if(i > maxR) maxR = i;\n                    if(j < minC) minC = j;\n                    if(j > maxC) maxC = j;\n                }\n            }\n        }\n        \n        int height = maxR - minR + 1;\n        int width = maxC - minC + 1;\n        \n        // Extract normalized pattern\n        int pattern[4][4] = {0};\n        for(int i = minR; i <= maxR; i++) {\n            for(int j = minC; j <= maxC; j++) {\n                if(grid[i][j] == '1') {\n                    pattern[i-minR][j-minC] = 1;\n                }\n            }\n        }\n        \n        // Check each shape\n        char result = '?';\n        \n        // Shape A: 2x2 square\n        if(height == 2 && width == 2 && \n           pattern[0][0] && pattern[0][1] && \n           pattern[1][0] && pattern[1][1]) {\n            result = 'A';\n        }\n        // Shape B: 1x4 horizontal\n        else if(height == 1 && width == 4 && \n                pattern[0][0] && pattern[0][1] && \n                pattern[0][2] && pattern[0][3]) {\n            result = 'B';\n        }\n        // Shape C: 4x1 vertical\n        else if(height == 4 && width == 1 && \n                pattern[0][0] && pattern[1][0] && \n                pattern[2][0] && pattern[3][0]) {\n            result = 'C';\n        }\n        // Shape D: 3x1 vertical\n        else if(height == 3 && width == 1 && \n                pattern[0][0] && pattern[1][0] && \n                pattern[2][0]) {\n            result = 'D';\n        }\n        // Shape E: zigzag\n        else if(height == 2 && width == 3 && \n                pattern[0][0] && pattern[0][1] && !pattern[0][2] &&\n                !pattern[1][0] && pattern[1][1] && pattern[1][2]) {\n            result = 'E';\n        }\n        // Shape F: reverse zigzag\n        else if(height == 2 && width == 3 && \n                !pattern[0][0] && pattern[0][1] && pattern[0][2] &&\n                pattern[1][0] && pattern[1][1] && !pattern[1][2]) {\n            result = 'F';\n        }\n        // Shape G: L-shape\n        else if(height == 2 && width == 2 && \n                pattern[0][0] && !pattern[0][1] && \n                pattern[1][0] && pattern[1][1]) {\n            result = 'G';\n        }\n        \n        printf(\"%c\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char grid[8][9]; while(scanf(\"%s\", grid[0]) != EOF) { for(int i = 1; i < 8; i++) { scanf(\"%s\", grid[i]); } // Extract the shape pattern int minR = 8, maxR = -1, minC = 8, maxC = -1; for(int i = 0;  > maxC) maxC = j; } } } int  int pattern[4][4] = {0}; for(int i = minR; i <= maxR; i++)  } // Check each shape char result = '?'; // Shape A: 2x2 square if(height == 2 && width == 2 && pattern[0][0] && pattern[0][1] && pattern[1][0] && pattern[1][1]) { result =  1 && width == 4 && pattern[0][0] && pattern[0][1] &&  C: 4x1 vertical else if(height == 4 && width == 1 && pattern[0][0] && pattern[1][0] && pattern[2][0] && pattern[3][0]) {   Shape E: zigzag else if(height == 2 && width == 3 && pattern[0][0] && pattern[0][1] &&  'E';  && width == 3 && !pattern[0][0] && pattern[0][1] && pattern[0][2] && pattern[1][0] && pattern[1][1] && !pattern[1][2]) { result  2 && width == 2 &&  'G'; } printf(\"%c\\n\", result); } return 0; }"], "perturbed_original": ["#include<stdio.h> #define X 8 #define Y 8 #define L 3 #define M 2  = 0, y = 0; int i = 0, j = 0; int size = 0;  = 0; int k = 0; int h = 0; char ans[4][2]; for(i = 0; i < X; i++) { for(j = 0;j < Y; j++) { ppr[i][j] = '0'; } } for(i = 0; i < 4; i++) { for(j =  while(scanf(\"%s\", ppr[0]) != EOF) { for(i = 1; i  ans[0][1]; ans[0][0] -= x; ans[0][1] -= y; ans[1][0] -= x; ans[1][1] -= y; ans[2][0] -= x; ans[2][1] -= y; ans[3][0] -= x; ans[3][1] -= y; /* for(i = 0;i < 4; i++) { printf(\"%d %d\\n\",ans[i][0],ans[i][1]); }*/ if(ans[0][0] == 0 && ans[0][1] ==  ans[2][0] == 1 && ans[2][1] == 0 && ans[3][0] == 1 && ans[3][1] == 1 ) { printf(\"A\\n\"); } else if(ans[0][0] == 0 &&ans[0][1] == 0 && ans[1][0] == 1   ) { printf(\"B\\n\"); } else if(ans[0][0] == 0 && ans[0][1] == 0 && ans[1][0] == 0 && ans[1][1] == 1 && ans[2][0] == 0 && ans[2][1] == 2  printf(\"C\\n\"); } else if(ans[0][0] == 0 && ans[0][1] == 1 && ans[1][0] == 1 && ans[1][1] == 0 && ans[2][0] == 1 &&  0 ) { printf(\"D\\n\");  == 1 && ans[2][1] == 1 &&  && ans[1][0] == 1 && ans[1][1]  { printf(\"F\\n\"); } else if(ans[0][0] == 0 && ans[0][1]  ans[3][0] == 1 && ans[3][1] == 1 ) { printf(\"G\\n\"); } } return 0; }"], "original_ll": -0.3708331882953644, "sampled_ll": -0.36075741052627563, "all_perturbed_sampled_ll": [-1.2855429649353027], "all_perturbed_original_ll": [-0.8684080839157104], "perturbed_sampled_ll": -1.2855429649353027, "perturbed_original_ll": -0.8684080839157104, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new java.util.Scanner(System.in);\n\n\n\tpublic static void main(String[] args) {\n\n\t\tint[][] num = new int[15][15];\n\t\tString str = \"\";\n\n\t\twhile (sc.hasNextLine()) {\n\t\t\t// ?????????\n\t\t\t//syokika(num);\n\t\t\tfor (int i = 0; i < 15; i++) {\n\t\t\t\tfor (int j = 0; j < 15; j++) {\n\t\t\t\t\tnum[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????\u00a8????????????????\u00b4?\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tstr = sc.next();\n\t\t\t\tString[] st = str.split(\"\");\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tnum[i][j] = Integer.parseInt(st[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????????\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (num[i][j] == 1 && num[i][j + 1] == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"A\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i + 1][j] == 1 && num[i + 2][j] == 1 && num[i + 3][j] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"B\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i][j + 3] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"C\");\n\t\t\t\t\t} else if (num[i][j + 1] == 1 && num[i + 1][j] == 1 && num[i][j + 1] == 1 && num[i + 2][j] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"D\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i + 1][j + 1] == 1\n\t\t\t\t\t\t\t&& num[i + 1][j + 2] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"E\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1\n\t\t\t\t\t\t\t&& num[i + 2][j + 1] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"F\");\n\t\t\t\t\t} else if (num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i + 1][j] == 1\n\t\t\t\t\t\t\t&& num[i + 1][j + 1] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"G\");\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String[][] grid = new String[8][8];\n            List<int[]> points = new ArrayList<>();\n            \n            for (int i = 0; i < 8; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < 8; j++) {\n                    grid[i][j] = String.valueOf(line.charAt(j));\n                    if (line.charAt(j) == '1') {\n                        points.add(new int[]{i, j});\n                    }\n                }\n            }\n            \n            if (points.size() == 0) break;\n            \n            // Normalize the shape\n            int minRow = Integer.MAX_VALUE;\n            int minCol = Integer.MAX_VALUE;\n            for (int[] p : points) {\n                minRow = Math.min(minRow, p[0]);\n                minCol = Math.min(minCol, p[1]);\n            }\n            \n            Set<String> normalized = new HashSet<>();\n            for (int[] p : points) {\n                normalized.add((p[0] - minRow) + \",\" + (p[1] - minCol));\n            }\n            \n            String result = identifyShape(normalized);\n            System.out.println(result);\n            \n            if (sc.hasNextLine()) {\n                String blank = sc.nextLine();\n            }\n        }\n        sc.close();\n    }\n    \n    static String identifyShape(Set<String> shape) {\n        // Define all shapes\n        Map<String, Set<String>> shapes = new HashMap<>();\n        \n        // A: 2x2 square\n        Set<String> a = new HashSet<>();\n        a.add(\"0,0\"); a.add(\"0,1\"); a.add(\"1,0\"); a.add(\"1,1\");\n        shapes.put(\"A\", a);\n        \n        // B: vertical line\n        Set<String> b = new HashSet<>();\n        b.add(\"0,0\"); b.add(\"1,0\"); b.add(\"2,0\"); b.add(\"3,0\");\n        shapes.put(\"B\", b);\n        \n        // C: horizontal line\n        Set<String> c = new HashSet<>();\n        c.add(\"0,0\"); c.add(\"0,1\"); c.add(\"0,2\"); c.add(\"0,3\");\n        shapes.put(\"C\", c);\n        \n        // D: L shape\n        Set<String> d = new HashSet<>();\n        d.add(\"0,0\"); d.add(\"1,0\"); d.add(\"2,0\"); d.add(\"2,1\");\n        shapes.put(\"D\", d);\n        \n        // E: Z shape\n        Set<String> e = new HashSet<>();\n        e.add(\"0,0\"); e.add(\"0,1\"); e.add(\"1,1\"); e.add(\"1,2\");\n        shapes.put(\"E\", e);\n        \n        // F: T shape\n        Set<String> f = new HashSet<>();\n        f.add(\"0,0\"); f.add(\"0,1\"); f.add(\"0,2\"); f.add(\"1,1\");\n        shapes.put(\"F\", f);\n        \n        // G: small L\n        Set<String> g = new HashSet<>();\n        g.add(\"0,0\"); g.add(\"1,0\"); g.add(\"1,1\");\n        shapes.put(\"G\", g);\n        \n        // Try all rotations and reflections\n        for (String key : shapes.keySet()) {\n            Set<String> pattern = shapes.get(key);\n            if (matchesWithTransformations(shape, pattern)) {\n                return key;\n            }\n        }\n        \n        return \"?\";\n    }\n    \n    static boolean matchesWithTransformations(Set<String> shape, Set<String> pattern) {\n        Set<String> current = pattern;\n        \n        for (int rotation = 0; rotation < 4; rotation++) {\n            if (matches(shape, current)) return true;\n            Set<String> reflected = reflect(current);\n            if (matches(shape, reflected)) return true;\n            current = rotate90(current);\n        }\n        \n        return false;\n    }\n    \n    static boolean matches(Set<String> shape, Set<String> pattern) {\n        Set<String> normalized = normalize(pattern);\n        return shape.equals(normalized);\n    }\n    \n    static Set<String> normalize(Set<String> pattern) {\n        int minRow = Integer.MAX_VALUE;\n        int minCol = Integer.MAX_VALUE;\n        \n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            minRow = Math.min(minRow, r);\n            minCol = Math.min(minCol, c);\n        }\n        \n        Set<String> result = new HashSet<>();\n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            result.add((r - minRow) + \",\" + (c - minCol));\n        }\n        \n        return result;\n    }\n    \n    static Set<String> rotate90(Set<String> pattern) {\n        Set<String> result = new HashSet<>();\n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            result.add(c + \",\" + (-r));\n        }\n        return normalize(result);\n    }\n    \n    static Set<String> reflect(Set<String> pattern) {\n        Set<String> result = new HashSet<>();\n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            result.add(r + \",\" + (-c));\n        }\n        return normalize(result);\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  new String[8][8]; List<int[]> points = new ArrayList<>(); for  < 8; j++) { grid[i][j] = String.valueOf(line.charAt(j)); if (line.charAt(j) == '1') { points.add(new int[]{i, j}); } } } if (points.size() == 0) break; // Normalize the shape int minRow = Integer.MAX_VALUE; int minCol  = new HashSet<>(); for  + (p[1] - minCol)); } String result = identifyShape(normalized); System.out.println(result); if (sc.hasNextLine()) { String blank = sc.nextLine(); } } sc.close(); } static String identifyShape(Set<String> shape) { // Define all shapes Map<String, Set<String>> shapes = new HashMap<>(); // A:  a.add(\"1,1\"); shapes.put(\"A\", a); // B: vertical line Set<String> b = new HashSet<>(); b.add(\"0,0\"); b.add(\"1,0\"); b.add(\"2,0\"); b.add(\"3,0\"); shapes.put(\"B\", b); // C: horizontal  shapes.put(\"C\", c); // D: L shape Set<String> d = new HashSet<>(); d.add(\"0,0\"); d.add(\"1,0\"); d.add(\"2,0\"); d.add(\"2,1\");  HashSet<>(); e.add(\"0,0\"); e.add(\"0,1\"); e.add(\"1,1\"); e.add(\"1,2\"); shapes.put(\"E\", e); // F: T shape Set<String>  // G: small L Set<String> g = new HashSet<>(); g.add(\"0,0\"); g.add(\"1,0\"); g.add(\"1,1\"); shapes.put(\"G\", g); // Try all rotations and reflections  if (matchesWithTransformations(shape, pattern)) { return key; } } return  < 4; rotation++) { if (matches(shape, current)) return   shape, Set<String> pattern) { Set<String> normalized = normalize(pattern); return shape.equals(normalized); } static Set<String> normalize(Set<String> pattern) { int minRow = Integer.MAX_VALUE; int minCol = Integer.MAX_VALUE; for (String  r); minCol = Math.min(minCol, c); }  {  = Integer.parseInt(parts[1]); result.add((r - minRow) + \",\" + (c - minCol)); } return  new HashSet<>(); for (String p : pattern) { String[] parts  result.add(c + \",\" + (-r)); } return normalize(result); }  for (String p : pattern) { String[] parts = p.split(\",\"); int r = Integer.parseInt(parts[0]); int c  } }"], "perturbed_original": ["import java.util.Scanner; public class Main { static Scanner sc = new java.util.Scanner(System.in); public   for  (int j =  } // ???????????\u00a8????????????????\u00b4? for (int i =  st  j++) { num[i][j] = Integer.parseInt(st[j]); } } // ???????????? for (int i = 0; i  < 8; j++)  1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1) { System.out.println(\"A\"); } else if (num[i][j] == 1 && num[i +  num[i + 3][j] == 1) { System.out.println(\"B\"); } else if (num[i][j]  + 2] == 1 && num[i][j + 3] == 1) { System.out.println(\"C\"); } else if (num[i][j +  num[i][j + 1] == 1 && num[i +  1 && num[i][j + 1] == 1 && num[i + 1][j + 1] == 1 && num[i + 1][j + 2] == 1) { System.out.println(\"E\"); } else if (num[i][j] == 1 && num[i + 1][j] == 1 && num[i +  1] == 1) { System.out.println(\"F\"); }   num[i + 1][j + 1] == 1) { System.out.println(\"G\"); } } } } } }"], "original_ll": -0.4332980811595917, "sampled_ll": -0.3636217713356018, "all_perturbed_sampled_ll": [-1.5724619626998901], "all_perturbed_original_ll": [-1.205446481704712], "perturbed_sampled_ll": -1.5724619626998901, "perturbed_original_ll": -1.205446481704712, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys;import re\nfor s in sys.stdin.read().split('\\n\\n'):print 'BCD F GAE'[len(re.findall('1.*1',s.replace('\\n',''))[0])%12-3]", "sampled": "import sys\n\ndef normalize_shape(points):\n    if not points:\n        return []\n    min_r = min(p[0] for p in points)\n    min_c = min(p[1] for p in points)\n    normalized = sorted([(r - min_r, c - min_c) for r, c in points])\n    return normalized\n\ndef get_shape_signature(grid):\n    points = []\n    for r in range(8):\n        for c in range(8):\n            if grid[r][c] == '1':\n                points.append((r, c))\n    return normalize_shape(points)\n\n# Define the shapes A-G\nshapes = {\n    'A': [(0, 0), (0, 1), (1, 0), (1, 1)],\n    'B': [(0, 0), (0, 1), (0, 2), (0, 3)],\n    'C': [(0, 0), (0, 1), (0, 2), (0, 3)],\n    'D': [(0, 0), (1, 0), (1, 1), (2, 1)],\n    'E': [(0, 0), (0, 1), (1, 0), (1, 1)],\n    'F': [(0, 1), (1, 0), (1, 1), (2, 0)],\n    'G': [(0, 0), (0, 1), (0, 2), (1, 1)]\n}\n\n# Generate all rotations and reflections for each shape\ndef get_all_orientations(points):\n    orientations = set()\n    pts = points[:]\n    \n    for _ in range(4):  # 4 rotations\n        orientations.add(tuple(normalize_shape(pts)))\n        # Rotate 90 degrees clockwise: (r, c) -> (c, -r)\n        pts = [(c, -r) for r, c in pts]\n    \n    # Mirror horizontally\n    pts = [(r, -c) for r, c in points]\n    for _ in range(4):  # 4 rotations of mirrored\n        orientations.add(tuple(normalize_shape(pts)))\n        pts = [(c, -r) for r, c in pts]\n    \n    return orientations\n\nshape_orientations = {}\nfor name, shape in shapes.items():\n    shape_orientations[name] = get_all_orientations(shape)\n\ndef identify_shape(grid):\n    sig = tuple(get_shape_signature(grid))\n    \n    for name, orientations in shape_orientations.items():\n        if sig in orientations:\n            return name\n    \n    return None\n\n# Read input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.rstrip('\\n'))\n\n# Process datasets\ni = 0\nwhile i < len(lines):\n    grid = []\n    while i < len(lines) and lines[i] != '':\n        grid.append(lines[i])\n        i += 1\n    \n    if len(grid) == 8:\n        result = identify_shape(grid)\n        print(result)\n    \n    i += 1  # Skip empty line\n", "perturbed_sampled": ["import sys def normalize_shape(points): if not points: return [] min_r = min(p[0] for p in points) min_c = min(p[1] for   points = [] for r in range(8):  return normalize_shape(points) # Define the shapes  0), (1, 1)], 'B': [(0, 0), (0, 1), (0, 2), (0, 3)], 'C': [(0, 0), (0,  (1,  (1, 1)], 'F': [(0, 1), (1, 0), (1, 1), (2, 0)], 'G': [(0, 0), (0, 1), (0, 2), (1, 1)] } # Generate  = set() pts  # Rotate 90 degrees clockwise: (r, c) -> (c, -r) pts = [(c, -r) for r, c in pts] # Mirror horizontally  pts = [(c, -r) for r, c in pts] return orientations shape_orientations = {} for name, shape  for name, orientations  # Read input lines = [] for line in sys.stdin: lines.append(line.rstrip('\\n'))  grid =  i += 1 if len(grid) == 8: result = identify_shape(grid) print(result) i += 1 # Skip empty line"], "perturbed_original": ["import sys;import re for s in sys.stdin.read().split('\\n\\n'):print 'BCD F GAE'[len(re.findall('1.*1',s.replace('\\n',''))[0])%12-3]"], "original_ll": -2.989722967147827, "sampled_ll": -0.6562668085098267, "all_perturbed_sampled_ll": [-1.7877168655395508], "all_perturbed_original_ll": [-3.1982545852661133], "perturbed_sampled_ll": -1.7877168655395508, "perturbed_original_ll": -3.1982545852661133, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n  int tate[8][4],yoko[8][3];\n  int h,i,j,k,x=0,y=0;\n  for(i=0;i<9;i++){\n    if(i%2==0){\n      scanf(\"%1d%1d%1d%1d\",&yoko[i][0],&yoko[i][1],&yoko[i][2],&yoko[i][3]);\n      yoko[i][4]=0;   \n    }else{  \n      scanf(\"%1d%1d%1d%1d%1d\",&tate[i][0],&tate[i][1],&tate[i][2],&tate[i][3],&tate[i][4]);\n      tate[i][5]=0;\n    }\n  }\n\n  //printf(\"----------------------------------------\\n\");\n       for(k=0;k<=9;k++){\n       if(k%2==0){\n\t //printf(\"%d%d%d%d%d\\n\",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]);\n       }else{\n\t //printf(\"%d%d%d%d%d%d\\n\",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]);\n       }\n       }\n  \n\n \n  int sl=1;\n  printf(\"R\");\n  do{\n   \n    switch(sl){\n    case 1:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n\n      if(tate[y-1][x+1]==1&&y>0){\n\tx++;\n\ty--;\n\tsl=4;\n      }else if(yoko[y][x+1]==1&&x<3){\n\t//printf(\"ok\\n\");\n\tx++;\n\tsl=1;\n\t//printf(\"s=%d\",s);\n      }else if(tate[y+1][x+1]==1&&y<8){\n\tx++;\n\ty++;\n\t\n\tsl=2;\n      }\n      // printf(\"tate74=%d\\n\",tate[7][4]);\n\n      break;\n\n    case 2:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"%d %d\\n\",x+1,y+2);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n      if(yoko[y+1][x]==1&&x<3){\n\ty++;sl=1;\n      }else if(tate[y+2][x]==1&&y<8){\n\ty=y+2;sl=2;\n      }else if(yoko[y+1][x-1]==1&&x>0){\n\ty++;\n\tx--;\n\tsl=3;\n      }\n      break;\n\n\n    case 3:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n       if(tate[y+1][x]==1&&y<8){\n\tsl=2;y++;\n      }else if(yoko[y][x-1]==1&&x>0){\n\tx--;sl=3;\n      }else if(tate[y-1][x]==1&&y>0){\n\ty--;sl=4;\n      }\n      break;\n\n\n    case 4:\n      // printf(\"x=%d:y=%d\\n\",x,y);\n      if(yoko[y-1][x-1]==1&&x>0){\n\tx--;y--;sl=3;\n      }else if(tate[y-2][x]==1&&y>0){\n\ty=y-2;sl=4;\n      }else if(yoko[y-1][x]==1&&x<3){\n\ty--;sl=1;\n      }\n      break;\n\n\n    }\n    //printf(\"sl=%d\\n\",sl);\n    if(sl==1)printf(\"R\");\n    if(sl==2)printf(\"D\");\n    if(sl==3)printf(\"L\");\n    if(sl==4)printf(\"U\");\n    //printf(\"tate74=%d\\n\",tate[7][4]);\n    //printf(\"\\n\");\n   \n   \n  }while(x!=0||y!=0);\n  printf(\"\\n\");\n  return 0;\n  \n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char h[5][5]; // horizontal walls\n    char v[4][5]; // vertical walls\n    char input[10];\n    \n    // Read input\n    for (int i = 0; i < 9; i++) {\n        scanf(\"%s\", input);\n        if (i % 2 == 0) {\n            // horizontal walls\n            int row = i / 2;\n            strcpy(h[row], input);\n        } else {\n            // vertical walls\n            int row = i / 2;\n            strcpy(v[row], input);\n        }\n    }\n    \n    // Start at point A (0,0), facing right (east)\n    int x = 0, y = 0;\n    int dir = 0; // 0=East, 1=South, 2=West, 3=North\n    char dirChars[] = {'R', 'D', 'L', 'U'};\n    \n    // Direction vectors: dx[dir], dy[dir]\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, 1, 0, -1};\n    \n    char path[10000];\n    int pathLen = 0;\n    \n    // Right-hand rule: keep wall on right\n    do {\n        // Try to turn right first\n        int rightDir = (dir + 3) % 4; // turn right\n        int rightX = x + dx[rightDir];\n        int rightY = y + dy[rightDir];\n        \n        // Check if we can move right\n        int canMoveRight = 0;\n        if (rightX >= 0 && rightX <= 4 && rightY >= 0 && rightY <= 4) {\n            if (rightDir == 0 && rightX <= 4 && v[y][x] == '0') canMoveRight = 1;\n            else if (rightDir == 1 && rightY <= 4 && h[y][x] == '0') canMoveRight = 1;\n            else if (rightDir == 2 && rightX >= 0 && v[y][rightX] == '0') canMoveRight = 1;\n            else if (rightDir == 3 && rightY >= 0 && h[rightY][x] == '0') canMoveRight = 1;\n        }\n        \n        if (canMoveRight) {\n            dir = rightDir;\n            x = rightX;\n            y = rightY;\n            path[pathLen++] = dirChars[dir];\n        } else {\n            // Try to move forward\n            int fwdX = x + dx[dir];\n            int fwdY = y + dy[dir];\n            \n            int canMoveFwd = 0;\n            if (fwdX >= 0 && fwdX <= 4 && fwdY >= 0 && fwdY <= 4) {\n                if (dir == 0 && fwdX <= 4 && v[y][x] == '0') canMoveFwd = 1;\n                else if (dir == 1 && fwdY <= 4 && h[y][x] == '0') canMoveFwd = 1;\n                else if (dir == 2 && fwdX >= 0 && v[y][fwdX] == '0') canMoveFwd = 1;\n                else if (dir == 3 && fwdY >= 0 && h[fwdY][x] == '0') canMoveFwd = 1;\n            }\n            \n            if (canMoveFwd) {\n                x = fwdX;\n                y = fwdY;\n                path[pathLen++] = dirChars[dir];\n            } else {\n                // Turn left\n                dir = (dir + 1) % 4;\n            }\n        }\n    } while (!(x == 0 && y == 0 && dir == 0));\n    \n    path[pathLen] = '\\0';\n    printf(\"%s\\n\", path);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() {  char input[10]; // Read input for (int i = 0; i <  0) { // horizontal walls int row = i / 2; strcpy(h[row], input); } else { // vertical walls int row =  point A (0,0),  int dir = 0; // 0=East, 1=South, 2=West, 3=North char dirChars[] = {'R', 'D', 'L',  0, -1, 0}; int dy[]  { // Try to turn right first int rightDir = (dir + 3) % 4; // turn right int rightX  //  if  0 && rightX <= 4 && v[y][x] == '0') canMoveRight = 1; else if (rightDir == 1 && rightY <= 4 && h[y][x] ==   else if (rightDir == 3 && rightY >= 0 && h[rightY][x] == '0') canMoveRight = 1;  y = rightY; path[pathLen++] = dirChars[dir]; } else { //  int  (fwdX >= 0 && fwdX <= 4 && fwdY >= 0 && fwdY <= 4) { if (dir == 0 && fwdX <= 4 && v[y][x] ==  fwdY <= 4 && h[y][x] == '0') canMoveFwd = 1; else if (dir == 2 && fwdX >= 0  == 3  1; } if (canMoveFwd) { x = fwdX; y = fwdY; path[pathLen++] = dirChars[dir]; }  && y == 0 && dir == 0)); path[pathLen] = '\\0'; printf(\"%s\\n\", path); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int tate[8][4],yoko[8][3]; int h,i,j,k,x=0,y=0;  for(k=0;k<=9;k++){ if(k%2==0){ //printf(\"%d%d%d%d%d\\n\",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]); }else{ //printf(\"%d%d%d%d%d%d\\n\",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]); } } int sl=1; printf(\"R\"); do{ switch(sl){ case 1:  y++;sl=1; }else if(tate[y+2][x]==1&&y<8){ y=y+2;sl=2; }else if(yoko[y+1][x-1]==1&&x>0){ y++; x--;  x--;sl=3; }else if(tate[y-1][x]==1&&y>0){ y--;sl=4; } break; case 4: // printf(\"x=%d:y=%d\\n\",x,y); if(yoko[y-1][x-1]==1&&x>0){ x--;y--;sl=3; }else if(tate[y-2][x]==1&&y>0){ y=y-2;sl=4; }else if(yoko[y-1][x]==1&&x<3){ y--;sl=1; } break; } //printf(\"sl=%d\\n\",sl); if(sl==1)printf(\"R\"); if(sl==2)printf(\"D\"); if(sl==3)printf(\"L\"); if(sl==4)printf(\"U\"); //printf(\"tate74=%d\\n\",tate[7][4]); //printf(\"\\n\"); }while(x!=0||y!=0); printf(\"\\n\"); return 0; }"], "original_ll": -0.7322588562965393, "sampled_ll": -0.4883149564266205, "all_perturbed_sampled_ll": [-1.8635921478271484], "all_perturbed_original_ll": [-1.1090202331542969], "perturbed_sampled_ll": -1.8635921478271484, "perturbed_original_ll": -1.1090202331542969, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\n// AOJ 0037\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final double EPS = 1e-10;\n\tpublic static void main(String[] args) {\n\t\tchar[][] cs = new char[20][1000];\n\t\tfor (int i = 0; i < 20; i++) fill(cs[i], '0');\n\t\t\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tString buf = sc.next();\n\t\t\tfor (int j = 0; j < buf.length(); j++) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tcs[i + 1][j * 2 + 2] = buf.charAt(j);\n\t\t\t\t} else {\n\t\t\t\t\tcs[i + 1][j * 2 + 1] = buf.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tint[] dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n\t\tString[] str = {\"R\", \"D\", \"L\", \"U\"}; \n\t\tint x = 1, y = 1, d = 0;\n\t\twhile (!(x == 1 && y == 1 && d == 2)) {\n\t\t\tif (cs[y + dy[d]][x + dx[d]] == '1') {\n\t\t\t\tx += dx[d] * 2; \n\t\t\t\ty += dy[d] * 2;\n\t\t\t\tSystem.out.print(str[d]);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (cs[y + dy[(d - 1 + 4) % 4]][x + dx[(d - 1 + 4) % 4]] == '1') {\n\t\t\t\t\td = (d - 1 + 4) % 4;\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\td = (d + 1) % 4;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class State {\n        int row, col;\n        int dir; // 0=right, 1=down, 2=left, 3=up\n        \n        State(int row, int col, int dir) {\n            this.row = row;\n            this.col = col;\n            this.dir = dir;\n        }\n    }\n    \n    static int[][] horizontal = new int[5][4]; // 5 horizontal lines, 4 segments each\n    static int[][] vertical = new int[4][5]; // 4 vertical lines, 5 segments each\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Read horizontal walls\n        for (int i = 0; i < 5; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 4; j++) {\n                horizontal[i][j] = line.charAt(j) - '0';\n            }\n        }\n        \n        // Read vertical walls\n        for (int i = 0; i < 4; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 5; j++) {\n                vertical[i][j] = line.charAt(j) - '0';\n            }\n        }\n        \n        // Start at position (0,0), facing right (dir=0)\n        // Right hand is on the wall above (horizontal[0][0] = 1)\n        State state = new State(0, 0, 0);\n        StringBuilder result = new StringBuilder();\n        \n        do {\n            // Try to turn right first (right-hand rule)\n            int rightDir = (state.dir + 3) % 4; // Turn right\n            \n            if (canMove(state.row, state.col, rightDir)) {\n                // Turn right and move\n                state.dir = rightDir;\n                move(state, result);\n            } else if (canMove(state.row, state.col, state.dir)) {\n                // Move straight\n                move(state, result);\n            } else {\n                // Turn left\n                state.dir = (state.dir + 1) % 4;\n            }\n        } while (!(state.row == 0 && state.col == 0 && state.dir == 0));\n        \n        System.out.println(result.toString());\n    }\n    \n    static boolean canMove(int row, int col, int dir) {\n        if (dir == 0) { // Right\n            if (col >= 4) return false;\n            return vertical[col][row] == 0;\n        } else if (dir == 1) { // Down\n            if (row >= 4) return false;\n            return horizontal[row + 1][col] == 0;\n        } else if (dir == 2) { // Left\n            if (col <= 0) return false;\n            return vertical[col - 1][row] == 0;\n        } else { // Up\n            if (row <= 0) return false;\n            return horizontal[row][col] == 0;\n        }\n    }\n    \n    static void move(State state, StringBuilder result) {\n        if (state.dir == 0) { // Right\n            result.append('R');\n            state.col++;\n        } else if (state.dir == 1) { // Down\n            result.append('D');\n            state.row++;\n        } else if (state.dir == 2) { // Left\n            result.append('L');\n            state.col--;\n        } else { // Up\n            result.append('U');\n            state.row--;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  int dir; // 0=right, 1=down, 2=left, 3=up State(int row, int col,  = dir; } } static int[][] horizontal = new int[5][4]; // 5 horizontal lines, 4 segments each static int[][] vertical = new int[4][5]; // 4 vertical lines, 5 segments each public static void main(String[] args) { Scanner sc = new Scanner(System.in); // Read horizontal walls for (int i = 0; i < 5; i++) { String line  j++) { horizontal[i][j] = line.charAt(j) - '0'; } } // Read vertical walls for (int i = 0; i  j = 0; j < 5; j++) { vertical[i][j] = line.charAt(j) - '0'; } } //  state = new State(0, 0, 0); StringBuilder result = new  // Turn right if (canMove(state.row, state.col, rightDir)) { // Turn right and move state.dir = rightDir; move(state, result); } else if (canMove(state.row, state.col, state.dir)) { // Move straight move(state, result); } else { // Turn left state.dir  == 0  if (dir ==  return  horizontal[row + 1][col] == 0; }  <= 0) return false; return vertical[col - 1][row] == 0; } else  horizontal[row][col] == 0; } } static void move(State state, StringBuilder  state.col++; } else if (state.dir ==  { // Up result.append('U'); state.row--; } } }"], "perturbed_original": ["import java.util.*; import static java.util.Arrays.*; import static java.lang.Math.*; // AOJ 0037 public class Main { static Scanner sc = new Scanner(System.in); static final double  cs = new char[20][1000]; for (int i = 0; i < 20; i++) fill(cs[i], '0'); for (int i = 0; i < 9; i++) { String buf = sc.next(); for (int j = 0;  0) { cs[i + 1][j * 2 + 2] = buf.charAt(j);  = buf.charAt(j); } } } int[] dx = {1, 0, -1, 0},  \"D\", \"L\",  0; while (!(x ==  if (cs[y + dy[d]][x + dx[d]] == '1')  2; System.out.print(str[d]); } else { if (cs[y  d = (d - 1 + 4) % 4; } else { d  } }"], "original_ll": -0.708753228187561, "sampled_ll": -0.4425762891769409, "all_perturbed_sampled_ll": [-1.6145139932632446], "all_perturbed_original_ll": [-1.8047518730163574], "perturbed_sampled_ll": -1.6145139932632446, "perturbed_original_ll": -1.8047518730163574, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "path = [[[] for i in range(5)] for i in range(5)]\nfor i in range(9):\n    if i%2 == 0:\n        a = [int(i) for i in list(input())]\n        for j in range(4):\n            if a[j] == 1:\n                path[int(i/2)][j].append(\"R\")\n                path[int(i/2)][j+1].append(\"L\")\n    else:\n        a = [int(i) for i in list(input())]\n        for j in range(5):\n            if a[j] == 1:\n                path[int(i/2)][j].append(\"D\")\n                path[int(i/2)+1][j].append(\"U\")\n\nprev = \"R\"\np = \"R\"\nx = 0\ny = 0\nwhile(1):\n    if prev == \"R\":\n        if \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n    elif prev == \"L\":\n        if \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n    elif prev == \"U\":\n        if \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n    elif prev == \"D\":\n        if \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n    if x == 0 and y == 0:\n        break\nprint(p[1:])\n\n\n    \n\n", "sampled": "def solve():\n    # Read input\n    lines = []\n    for _ in range(9):\n        lines.append(input().strip())\n    \n    # Parse walls\n    # h_walls[i][j] = horizontal wall between row i and i+1, at column j\n    # v_walls[i][j] = vertical wall between column j and j+1, at row i\n    h_walls = []\n    v_walls = []\n    \n    for i in range(9):\n        if i % 2 == 0:  # horizontal walls\n            h_walls.append([int(c) for c in lines[i]])\n        else:  # vertical walls\n            v_walls.append([int(c) for c in lines[i]])\n    \n    # Start at point A (top-left corner, position (0, 0))\n    # Initial direction: facing right (since we start by going right with wall on right)\n    # Directions: 0=Right, 1=Down, 2=Left, 3=Up\n    pos = (0, 0)\n    direction = 0  # facing right\n    path = []\n    \n    # Direction vectors\n    dx = [1, 0, -1, 0]  # Right, Down, Left, Up\n    dy = [0, 1, 0, -1]\n    dir_chars = ['R', 'D', 'L', 'U']\n    \n    def has_wall(r, c, d):\n        \"\"\"Check if there's a wall when moving from (r,c) in direction d\"\"\"\n        if d == 0:  # Right\n            if c >= len(v_walls[0]):\n                return True\n            return v_walls[r][c] == 1\n        elif d == 1:  # Down\n            if r >= len(h_walls) - 1:\n                return True\n            return h_walls[r + 1][c] == 1\n        elif d == 2:  # Left\n            if c == 0:\n                return True\n            return v_walls[r][c - 1] == 1\n        else:  # Up (d == 3)\n            if r == 0:\n                return True\n            return h_walls[r][c] == 1\n    \n    while True:\n        # Try to turn right first (right-hand rule)\n        right_dir = (direction - 1) % 4\n        \n        # Check if we can go right\n        if not has_wall(pos[1], pos[0], right_dir):\n            # Turn right and move\n            direction = right_dir\n            pos = (pos[0] + dx[direction], pos[1] + dy[direction])\n            path.append(dir_chars[direction])\n        # Check if we can go straight\n        elif not has_wall(pos[1], pos[0], direction):\n            # Move straight\n            pos = (pos[0] + dx[direction], pos[1] + dy[direction])\n            path.append(dir_chars[direction])\n        else:\n            # Turn left\n            direction = (direction + 1) % 4\n            continue\n        \n        # Check if we're back at start\n        if pos == (0, 0) and len(path) > 0:\n            break\n    \n    print(''.join(path))\n\nsolve()\n", "perturbed_sampled": ["def solve(): # Read input lines = [] for _ in range(9): lines.append(input().strip()) # Parse walls # h_walls[i][j] = horizontal wall between row i and i+1, (0, 0)<extra_id_4>direction 1 if<extra_id_5>#<extra_id_6>Direction = [<extra_id_7>+ dx [ direction<extra_id_8>dir<extra_id_9># See if we can<extra_id_10>direction -<extra_id_11>in direction +<extra_id_12># See if we<extra_id_13>check if<extra_id_14>:<extra_id_15>(0, 0)<extra_id_16>[direction] =<extra_id_17>(direction-1) ==<extra_id_18>if (step1, step2)] = path.split(dir_chars[direction])<extra_id_19>direction j and j+1, at row i h_walls = [] v_walls = [] for i in range(9): if i % 2 == 0: # horizontal walls h_walls.append([int(c) for c in lines[i]]) else: # vertical walls v_walls.append([int(c) for c in lines[i]]) #  right with wall on right) # Directions:  vectors dx = [1, 0, -1, 0] # Right, Down, Left, Up dy   when moving from (r,c) in direction d\"\"\" if  True return  r >= len(h_walls) - 1:  == 2: # Left if c ==  return True return h_walls[r][c] == 1 while True:  (direction - 1) % 4 # Check if we can go right if not has_wall(pos[1], pos[0], right_dir): # Turn right and move direction  path.append(dir_chars[direction]) # Check if we can go straight  (pos[0] + dx[direction], pos[1] + dy[direction]) path.append(dir_chars[direction]) else: #  # Check if we're back at start if pos == (0, 0) and len(path) > 0: break print(''.join(path)) solve()"], "perturbed_original": ["path = [[[] for i in range(5)] for i in  = [int(i) for i in list(input())] for j in range(4): if a[j] == 1: path[int(i/2)][j].append(\"R\")  j in range(5): if a[j] == 1: path[int(i/2)][j].append(\"D\") path[int(i/2)+1][j].append(\"U\") prev = \"R\"  if prev == \"R\": if \"U\"  \"U\" elif \"R\" in path[x][y]: y += 1 prev = \"R\" p += \"R\" elif \"D\" in path[x][y]: x += 1 prev = \"D\" p += \"D\" elif \"L\" in path[x][y]: y -= 1 prev = \"L\" p += \"L\" elif prev == \"L\": if \"D\" in path[x][y]: x += 1 prev = \"D\" p += \"D\" elif \"L\" in path[x][y]: y -= 1 prev =  1  \"U\" in  += 1 prev = \"D\" p += \"D\" elif prev == \"D\": if \"R\" in path[x][y]: y += 1 prev = \"R\" p += \"R\" elif \"D\" in path[x][y]: x +=  path[x][y]: y -= 1 prev  x == 0 and y == 0: break print(p[1:])"], "original_ll": -0.3090987801551819, "sampled_ll": -0.690674364566803, "all_perturbed_sampled_ll": [-2.288515567779541], "all_perturbed_original_ll": [-1.2334226369857788], "perturbed_sampled_ll": -2.288515567779541, "perturbed_original_ll": -1.2334226369857788, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint isstraight(int[5]);\n\nint main(void) {\n\tint cards[5];\n\tint i,j,temp;\n\tint yaku;\n\tchar yakuname[7][11]={\"null\",\"one pair\",\"two pair\",\"three card\",\n\t\t\t\t\t\t\"straight\",\"full house\",\"four card\"};\n\twhile(1) {\n\t\tif(scanf(\"%d,%d,%d,%d,%d\",\n\t\t\t&cards[0],&cards[1],&cards[2],&cards[3],&cards[4])==-1)break;\n\t\tfor(i=4;i>0;i--) {\n\t\t\tfor(j=0;j<i;j++) {\n\t\t\t\tif(cards[j]>cards[j+1]) {\n\t\t\t\t\ttemp=cards[j];\n\t\t\t\t\tcards[j]=cards[j+1];\n\t\t\t\t\tcards[j+1]=temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tyaku=0;\n\t\tif(cards[1]==cards[2] && cards[2]==cards[3]) {\n\t\t\tif(cards[0]==cards[1] || cards[3]==cards[4])yaku=6;\n\t\t\telse yaku=3;\n\t\t} else if(cards[0]==cards[1] && cards[1]==cards[2]) {\n\t\t\tif(cards[3]==cards[4])yaku=5; else yaku=3;\n\t\t} else if(cards[2]==cards[3] && cards[3]==cards[4]) {\n\t\t\tif(cards[0]==cards[1])yaku=5; else yaku=3;\n\t\t} else if(isstraight(cards))yaku=4;\n\t\telse {\n\t\t\tfor(i=0;i<4;i++) {\n\t\t\t\tif(cards[i]==cards[i+1])yaku++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",yakuname[yaku]);\n\t}\n\treturn 0;\n}\n\nint isstraight(int cards[5]) {\n\tint i;\n\tfor(i=0;i<4;i++) {\n\t\tif(cards[i]+1!=cards[i+1])break;\n\t}\n\tif(i<4) {\n\t\tif(cards[0]==1 && cards[1]==10 && cards[2]==11 &&\n\t\t\tcards[3]==12 && cards[4]==13)return 1; else return 0;\n\t} else return 1;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    char line[100];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int cards[5];\n        sscanf(line, \"%d,%d,%d,%d,%d\", &cards[0], &cards[1], &cards[2], &cards[3], &cards[4]);\n        \n        // Count frequency of each card value\n        int count[14] = {0};\n        for (int i = 0; i < 5; i++) {\n            count[cards[i]]++;\n        }\n        \n        // Check for pairs, three of a kind, four of a kind\n        int pairs = 0, threes = 0, fours = 0;\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 2) pairs++;\n            else if (count[i] == 3) threes++;\n            else if (count[i] == 4) fours++;\n        }\n        \n        // Check for straight\n        qsort(cards, 5, sizeof(int), compare);\n        int is_straight = 0;\n        \n        // Normal straight\n        if (cards[1] == cards[0] + 1 && \n            cards[2] == cards[1] + 1 && \n            cards[3] == cards[2] + 1 && \n            cards[4] == cards[3] + 1) {\n            is_straight = 1;\n        }\n        \n        // A-2-3-4-5 straight\n        if (cards[0] == 1 && cards[1] == 2 && cards[2] == 3 && \n            cards[3] == 4 && cards[4] == 5) {\n            is_straight = 1;\n        }\n        \n        // 10-J-Q-K-A straight\n        if (cards[0] == 1 && cards[1] == 10 && cards[2] == 11 && \n            cards[3] == 12 && cards[4] == 13) {\n            is_straight = 1;\n        }\n        \n        // Determine the hand\n        if (fours > 0) {\n            printf(\"four card\\n\");\n        } else if (threes > 0 && pairs > 0) {\n            printf(\"full house\\n\");\n        } else if (is_straight) {\n            printf(\"straight\\n\");\n        } else if (threes > 0) {\n            printf(\"three card\\n\");\n        } else if (pairs == 2) {\n            printf(\"two pair\\n\");\n        } else if (pairs == 1) {\n            printf(\"one pair\\n\");\n        } else {\n            printf(\"null\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" { int cards[5]; sscanf(line, \"%d,%d,%d,%d,%d\", &cards[0], &cards[1], &cards[2], &cards[3], &cards[4]); // Count frequency of each card value int count[14] = {0}; for (int i = 0; i < 5; i++) { count[cards[i]]++; } // Check for  pairs = 0, threes = 0, fours = 0;  if (count[i] == 2) pairs++; else if (count[i] == 3) threes++; else if (count[i] == 4)  int is_straight = 0; // Normal straight if (cards[1] == cards[0] + 1 && cards[2]  && cards[4] == cards[3] + 1) {  1 && cards[1] == 2 && cards[2] == 3 && cards[3] == 4 && cards[4] == 5) { is_straight = 1; } // 10-J-Q-K-A straight if (cards[0] == 1  == 12 &&  } else if (threes > 0 && pairs > 0)  else if (threes > 0) { printf(\"three card\\n\"); } else if (pairs == 2) { printf(\"two pair\\n\"); } else if (pairs ==  return 0; }"], "perturbed_original": ["#include <stdio.h> int isstraight(int[5]); int main(void) { int cards[5]; int i,j,temp; int yaku; char yakuname[7][11]={\"null\",\"one pair\",\"two pair\",\"three card\", \"straight\",\"full house\",\"four card\"}; while(1) { if(scanf(\"%d,%d,%d,%d,%d\", &cards[0],&cards[1],&cards[2],&cards[3],&cards[4])==-1)break; for(i=4;i>0;i--) { for(j=0;j<i;j++) {  && cards[2]==cards[3]) { if(cards[0]==cards[1] || cards[3]==cards[4])yaku=6; else yaku=3; } else  else { for(i=0;i<4;i++) {  cards[5]) { int i; for(i=0;i<4;i++) { if(cards[i]+1!=cards[i+1])break; } if(i<4) { if(cards[0]==1 && cards[1]==10 && cards[2]==11 && cards[3]==12  }"], "original_ll": -0.6049731969833374, "sampled_ll": -0.3463745415210724, "all_perturbed_sampled_ll": [-1.1376726627349854], "all_perturbed_original_ll": [-1.5019868612289429], "perturbed_sampled_ll": -1.1376726627349854, "perturbed_original_ll": -1.5019868612289429, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tprivate static boolean checkFourCard(int[] group){\n\t\tboolean flag = false;\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(group[i] == 4){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\t\n\tprivate static boolean checkFullHouse(int[] group){\n\t\tboolean two=false, three=false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(group[i] == 2){\n\t\t\t\ttwo = true;\n\t\t\t}else if(group[i] == 3){\n\t\t\t\tthree = true;\n\t\t\t}\n\t\t}\n\t\tif(two && three){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate static boolean checkStraight(int[] group){\n\t\tboolean flag = false;\n\t\tint count = 0;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(group[i] == 1){\n\t\t\t\t//\u307e\u305f\u3044\u3060\u56de\u6570\n\t\t\t\tint over = 0;\n\t\t\t\tfor(int j=i; j<i+5; ++j){\n\t\t\t\t\tover += j/group.length;\n\t\t\t\t\tif(over > 1){\t//2\u307e\u3067\u884c\u3063\u305f\u3089\u3001\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint num = j%13;\n\t\t\t\t\tif(num == 0){ num = 13; }\n\t\t\t\t\tif(group[num] == 1){\n\t\t\t\t\t\t++count;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count == 5){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\tprivate static boolean checkThreeCard(int[] group){\n\t\tboolean flag = false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\t//main \u3067 else if \u3084\u3063\u3066\u3044\u308b\u304b\u3089\u5927\u4e08\u592b\u3060\u3051\u3069\u3001full house \u8aa4\u8a8d\u9632\u6b62\n\t\t\tif(group[i] == 2){\n\t\t\t\treturn false;\n\t\t\t}else if(group[i] == 3){\t\t//four card\u3082false\u3067\u5e30\u308b\u3002\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\t\n\tprivate static boolean checkTwoPair(int[] group){\n\t\tboolean flag = false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(flag){\t\t//one pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001\n\t\t\t\tif(group[i] == 2){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(group[i] == 2){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate static boolean checkOnePair(int[] group){\n\t\tboolean flag = false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(flag){\t\t//one pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001\n\t\t\t\tif(group[i] == 2 || group[i] == 3){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(group[i] == 2){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\t\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scan = new Scanner(System.in);\n\t\tint hand[] = new int [5];\n\t\t\n\t\twhile(scan.hasNext()){\n\t\t\tString[] str = scan.next().split(\",\");\n\t\t\tfor(int i=0; i<str.length; ++i){\n\t\t\t\thand[i] = Integer.parseInt(str[i]);\n\t\t\t}\n\t\t\t\n\t\t\tint group[] = new int [14];\t//\u6dfb\u5b57\u304c\u30ab\u30fc\u30c9\u30ca\u30f3\u30d0\u3068\u5bfe\u5fdc\u3002\uff10\u306f\u6b20\u756a\n\t\t\tArrays.fill(group, 0);\n\t\t\tfor(int i=0; i<hand.length; ++i){\n\t\t\t\t++group[hand[i]];\n\t\t\t}\n\t\t\t\n\t\t\tif(checkFourCard(group)){\n\t\t\t\tSystem.out.println(\"four card\");\n\t\t\t}else if(checkFullHouse(group)){\n\t\t\t\tSystem.out.println(\"full house\");\n\t\t\t}else if(checkStraight(group)){\n\t\t\t\tSystem.out.println(\"straight\");\n\t\t\t}else if(checkThreeCard(group)){\n\t\t\t\tSystem.out.println(\"three card\");\n\t\t\t}else if(checkTwoPair(group)){\n\t\t\t\tSystem.out.println(\"two pair\");\n\t\t\t}else if(checkOnePair(group)){\n\t\t\t\tSystem.out.println(\"one pair\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"null\");\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] cards = line.split(\",\");\n            int[] hand = new int[5];\n            for (int i = 0; i < 5; i++) {\n                hand[i] = Integer.parseInt(cards[i]);\n            }\n            \n            System.out.println(evaluateHand(hand));\n        }\n        \n        sc.close();\n    }\n    \n    static String evaluateHand(int[] hand) {\n        int[] count = new int[14];\n        for (int card : hand) {\n            count[card]++;\n        }\n        \n        // Check for four card\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 4) {\n                return \"four card\";\n            }\n        }\n        \n        // Check for full house\n        boolean hasThree = false;\n        boolean hasTwo = false;\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 3) hasThree = true;\n            if (count[i] == 2) hasTwo = true;\n        }\n        if (hasThree && hasTwo) {\n            return \"full house\";\n        }\n        \n        // Check for straight\n        if (isStraight(hand)) {\n            return \"straight\";\n        }\n        \n        // Check for three card\n        if (hasThree) {\n            return \"three card\";\n        }\n        \n        // Check for two pair\n        int pairCount = 0;\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 2) pairCount++;\n        }\n        if (pairCount == 2) {\n            return \"two pair\";\n        }\n        \n        // Check for one pair\n        if (pairCount == 1) {\n            return \"one pair\";\n        }\n        \n        return \"null\";\n    }\n    \n    static boolean isStraight(int[] hand) {\n        int[] sorted = hand.clone();\n        Arrays.sort(sorted);\n        \n        // Check normal straight\n        boolean isConsecutive = true;\n        for (int i = 1; i < 5; i++) {\n            if (sorted[i] != sorted[i-1] + 1) {\n                isConsecutive = false;\n                break;\n            }\n        }\n        if (isConsecutive) return true;\n        \n        // Check A-2-3-4-5\n        if (sorted[0] == 1 && sorted[1] == 2 && sorted[2] == 3 && sorted[3] == 4 && sorted[4] == 5) {\n            return true;\n        }\n        \n        // Check 10-J-Q-K-A\n        if (sorted[0] == 1 && sorted[1] == 10 && sorted[2] == 11 && sorted[3] == 12 && sorted[4] == 13) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String line = sc.nextLine().trim(); if (line.isEmpty())  for (int  Integer.parseInt(cards[i]); }  count = new int[14]; for (int card : hand) { count[card]++; } // Check for four card for (int i = 1; i  \"four card\";   house\"; } // Check for straight if (isStraight(hand))  (hasThree) { return \"three card\"; } // Check for two pair int pairCount = 0; for (int i  \"two pair\"; } // Check for one pair  \"null\"; } static boolean isStraight(int[] hand) { int[] sorted = hand.clone(); Arrays.sort(sorted); // Check normal straight boolean isConsecutive = true; for (int i = 1; i < 5; i++) { if (sorted[i] != sorted[i-1] + 1) { isConsecutive = false; break; } } if (isConsecutive) return true;  2 && sorted[2] == 3 && sorted[3] == 4 && sorted[4] == 5) { return true; }  && sorted[4] == 13) { return true; } return false; } }"], "perturbed_original": ["import java.util.Arrays; import  boolean flag = false; for(int i=1; i<group.length; ++i){ if(group[i] == 4){ flag = true; } } return flag; } private static boolean checkFullHouse(int[]  2){ two = true; }else if(group[i] == 3){ three = true; } }  private static boolean checkStraight(int[] group){ boolean flag = false; int count = 0; for(int i=1; i<group.length; ++i){  j<i+5; ++j){ over += j/group.length; if(over > 1){ //2\u307e\u3067\u884c\u3063\u305f\u3089\u3001 return false; } int num  == 1){ ++count; }else{ count  true; break; }  boolean flag = false; for(int i=1; i<group.length;   boolean checkTwoPair(int[] group){ boolean flag = false; for(int i=1;  true; } } if(group[i] == 2){ flag  checkOnePair(int[] group){ boolean flag = false; for(int i=1; i<group.length; ++i){ if(flag){ //one pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001 if(group[i] == 2 || group[i] == 3){ flag = false;  static void main(String[] args)  Scanner(System.in); int hand[] = new int  hand[i] = Integer.parseInt(str[i]); } int group[] = new int [14]; //\u6dfb\u5b57\u304c\u30ab\u30fc\u30c9\u30ca\u30f3\u30d0\u3068\u5bfe\u5fdc\u3002\uff10\u306f\u6b20\u756a Arrays.fill(group, 0); for(int i=0; i<hand.length; ++i){ ++group[hand[i]]; } if(checkFourCard(group)){ System.out.println(\"four card\"); }else  }else if(checkTwoPair(group)){ System.out.println(\"two pair\"); }else if(checkOnePair(group)){ System.out.println(\"one pair\"); }else{ System.out.println(\"null\"); } } } }"], "original_ll": -0.7192032337188721, "sampled_ll": -0.3249523341655731, "all_perturbed_sampled_ll": [-1.4539453983306885], "all_perturbed_original_ll": [-1.7683696746826172], "perturbed_sampled_ll": -1.4539453983306885, "perturbed_original_ll": -1.7683696746826172, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nfor s in sys.stdin:\n    A = list(map(int, s.split(',')))\n    A.sort()\n    #print(A)\n\n    if (A[0] == A[1] == A[2] == A[3]) or (A[1] == A[2] == A[3] == A[4]):\n        print('four card')\n\n    # full house\n    elif (A[0] == A[1] == A[2]) and (A[3] == A[4]):\n        print('full house')\n    elif (A[0] == A[1]) and (A[2] == A[3] == A[4]):\n        print('full house')\n\n    # straight\n    elif A[0] == A[1] - 1 == A[2] - 2 == A[3] - 3 == A[4] - 4:\n        print('straight')\n    elif A[1] == 10 and A[2] == 11 and A[3] == 12 and A[4] == 13 and A[0] == 1:\n        print('straight')\n\n    # three card\n    elif (A[0] == A[1] == A[2]) or (A[1] == A[2] == A[3]) or (A[2] == A[3] == A[4]):\n        print('three card')\n\n    # two pair\n    elif ((A[0] == A[1]) and (A[2] == A[3])) or ((A[0] == A[1]) and (A[3] == A[4])) or ((A[1] == A[2]) and (A[3] == A[4])):\n        print('two pair')\n\n    # one pair\n    elif (A[0] == A[1]) or (A[1] == A[2]) or (A[2] == A[3]) or (A[3] == A[4]):\n        print('one pair')\n\n    else:\n        print('null')", "sampled": "import sys\nfrom collections import Counter\n\ndef get_hand_rank(cards):\n    counts = Counter(cards)\n    count_values = sorted(counts.values(), reverse=True)\n    \n    # Check for four card\n    if count_values[0] == 4:\n        return \"four card\"\n    \n    # Check for full house\n    if count_values[0] == 3 and count_values[1] == 2:\n        return \"full house\"\n    \n    # Check for straight\n    sorted_cards = sorted(cards)\n    is_straight = True\n    for i in range(4):\n        if sorted_cards[i+1] - sorted_cards[i] != 1:\n            is_straight = False\n            break\n    \n    if is_straight:\n        return \"straight\"\n    \n    # Check for A-2-3-4-5 straight\n    if sorted_cards == [1, 2, 3, 4, 5]:\n        return \"straight\"\n    \n    # Check for 10-J-Q-K-A straight\n    if sorted_cards == [1, 10, 11, 12, 13]:\n        return \"straight\"\n    \n    # Check for three card\n    if count_values[0] == 3:\n        return \"three card\"\n    \n    # Check for two pair\n    if count_values[0] == 2 and count_values[1] == 2:\n        return \"two pair\"\n    \n    # Check for one pair\n    if count_values[0] == 2:\n        return \"one pair\"\n    \n    return \"null\"\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        break\n    cards = list(map(int, line.split(',')))\n    print(get_hand_rank(cards))\n", "perturbed_sampled": ["import sys from collections import Counter def get_hand_rank(cards): counts = Counter(cards) count_values = sorted(counts.values(), reverse=True) # Check  # Check for full house if count_values[0] == 3 and count_values[1] == 2: return \"full house\" #  i in range(4):  if is_straight: return \"straight\" # Check for A-2-3-4-5 straight if sorted_cards == [1, 2, 3, 4, 5]: return \"straight\" # Check for 10-J-Q-K-A straight if sorted_cards  2 and count_values[1] == 2: return \"two pair\" # Check for one pair if count_values[0] == 2: return \"one pair\"  not line: break cards = list(map(int, line.split(','))) print(get_hand_rank(cards))"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys import  #print(A) if (A[0] == A[1] == A[2] == A[3]) or (A[1] == A[2] == A[3] == A[4]): print('four card') # full house elif (A[0] == A[1] == A[2]) and (A[3] == A[4]): print('full house') elif (A[0] == A[1]) and (A[2] ==  A[1] - 1  - 4: print('straight') elif A[1] == 10 and A[2] == 11 and A[3] == 12 and A[4] == 13 and A[0] ==  A[2]) or   == A[4])): print('two pair') # one pair elif  A[3]) or (A[3] == A[4]): print('one pair') else: print('null')"], "original_ll": -0.39829304814338684, "sampled_ll": -0.5601951479911804, "all_perturbed_sampled_ll": [-1.5482429265975952], "all_perturbed_original_ll": [-1.4138562679290771], "perturbed_sampled_ll": -1.5482429265975952, "perturbed_original_ll": -1.4138562679290771, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\n\n\nint main(){\n  int i,j,k,l,al[]={0,1,5,7,11,17,19,23,25},n,clen;\n  char ci[257],ans[257];\n  fgets(ci,256,stdin);\n  n=atoi(ci);\n  for(i=0;i<n;i++){\n    fgets(ci,256,stdin);\n    clen=strlen(ci);\n    ans[clen]='\\0';\n    for(j=0;j<9;j++){\n      for(k=0;k<26;k++){\n\tfor(l=0;l<clen;l++){\n\t  if(isalpha(ci[l]))\n\t    ans[l]=(al[j]*((int)ci[l]-(int)'a')+k)%26+'a';\n\t  else\n\t    ans[l]=ci[l];\n\t}\n\tif(strstr(ans,\"that\")||strstr(ans,\"this\")){\n\t  printf(\"%s\",ans);\n\t  goto find;\n\t}\n      }\n    }\n  find:;\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint mod_inverse(int a, int m) {\n    for (int i = 1; i < m; i++) {\n        if ((a * i) % m == 1) return i;\n    }\n    return -1;\n}\n\nvoid decrypt(char *text, int alpha, int beta, char *result) {\n    int alpha_inv = mod_inverse(alpha, 26);\n    if (alpha_inv == -1) {\n        result[0] = '\\0';\n        return;\n    }\n    \n    int len = strlen(text);\n    for (int i = 0; i < len; i++) {\n        if (isalpha(text[i])) {\n            int c = text[i] - 'a';\n            int decoded = (alpha_inv * (c - beta + 26)) % 26;\n            if (decoded < 0) decoded += 26;\n            result[i] = decoded + 'a';\n        } else {\n            result[i] = text[i];\n        }\n    }\n    result[len] = '\\0';\n}\n\nint contains_word(char *text, char *word) {\n    int text_len = strlen(text);\n    int word_len = strlen(word);\n    \n    for (int i = 0; i <= text_len - word_len; i++) {\n        if (i > 0 && isalpha(text[i-1])) continue;\n        if (i + word_len < text_len && isalpha(text[i + word_len])) continue;\n        \n        int match = 1;\n        for (int j = 0; j < word_len; j++) {\n            if (text[i + j] != word[j]) {\n                match = 0;\n                break;\n            }\n        }\n        if (match) return 1;\n    }\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\\n\", &n);\n    \n    for (int t = 0; t < n; t++) {\n        char text[257];\n        fgets(text, 257, stdin);\n        int len = strlen(text);\n        if (text[len-1] == '\\n') text[len-1] = '\\0';\n        \n        char result[257];\n        int found = 0;\n        \n        for (int alpha = 1; alpha < 26 && !found; alpha++) {\n            if (gcd(alpha, 26) != 1) continue;\n            \n            for (int beta = 0; beta < 26 && !found; beta++) {\n                decrypt(text, alpha, beta, result);\n                \n                if (contains_word(result, \"that\") || contains_word(result, \"this\")) {\n                    printf(\"%s\\n\", result);\n                    found = 1;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h>  == 0) return a; return gcd(b, a % b); } int mod_inverse(int a, int m) { for  } return -1; } void decrypt(char *text, int alpha, int beta, char *result) { int alpha_inv = mod_inverse(alpha, 26); if (alpha_inv == -1) { result[0] = '\\0'; return; } int len =  { if (isalpha(text[i])) {  * (c - beta + 26)) % 26; if (decoded < 0)  { result[i] = text[i]; } } result[len] = '\\0'; } int contains_word(char *text, char *word) { int text_len = strlen(text); int word_len = strlen(word); for (int i = 0; i <= text_len - word_len; i++)  != word[j]) { match = 0; break; }  main() { int n; scanf(\"%d\\n\", &n); for (int  fgets(text, 257, stdin); int len  result[257]; int found = 0; for (int alpha = 1; alpha < 26 && !found; alpha++) { if (gcd(alpha, 26) != 1)  !found; beta++) { decrypt(text, alpha, beta, result); if (contains_word(result, \"that\") || contains_word(result, \"this\")) { printf(\"%s\\n\",  }"], "perturbed_original": ["#include<stdio.h> #include<string.h> int main(){ int i,j,k,l,al[]={0,1,5,7,11,17,19,23,25},n,clen; char ci[257],ans[257]; fgets(ci,256,stdin); n=atoi(ci); for(i=0;i<n;i++){ fgets(ci,256,stdin); clen=strlen(ci); ans[clen]='\\0'; for(j=0;j<9;j++){ for(k=0;k<26;k++){ for(l=0;l<clen;l++){ if(isalpha(ci[l])) ans[l]=(al[j]*((int)ci[l]-(int)'a')+k)%26+'a'; else ans[l]=ci[l];  return 0; }"], "original_ll": -1.1490429639816284, "sampled_ll": -0.4386623203754425, "all_perturbed_sampled_ll": [-1.7514616250991821], "all_perturbed_original_ll": [-1.3222416639328003], "perturbed_sampled_ll": -1.7514616250991821, "perturbed_original_ll": -1.3222416639328003, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\n\n\n class Main{\n     \n    static  ArrayList<String> al=new ArrayList<String>();\n    static int A=1,B=0;\n    static char chars[]= new char[]{\n         'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',\n         'q','r','s','t','u','v','w','x','y','z'\n     };\n    static char getChar(int n){return chars[n];}\n    static int getCode(char c){return (int)c-(int)'a';}\n    static int F(int m){return (A*m+B)%26;}\n    static String replace(String str){\n        StringBuilder sb=new StringBuilder();\n        for(int i=0; i<str.length(); i++){\n           // System.out.println(str.charAt(i)+\" \"+F(getCode(str.charAt(i))));\n            char replaced = getChar(F(getCode(str.charAt(i))));\n            //System.out.println(replaced);\n            sb.append(replaced);\n        }        return new String(sb);\n    }\n    static void detectAB(){\n        A=1;B=0;\n        for(int a=1; a<30000;a+=2){\n            for(int b=0; b<26;b++){\n                A=a;B=b;\n                for(String str:al){\n                    String rep = replace(str);\n                    //System.out.println(rep);\n                    if(rep.equals(\"this\")||rep.equals(\"that\"))return;\n                }\n            }\n        }\n    }\n    \n     public static void main(String args[]){\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // System.out.println(getCode('a')+\"\"+getCode('b')+\"\"+getCode('z'));\n         //System.out.println(replace(\"abz\"));\n         //String line;\n         try{\n         int n=Integer.parseInt(br.readLine());\n         //int n=1;\n         //for(int i=0; i<n;i++){\n         String line;\n         while((line=br.readLine())!=null){\n             //System.out.println(\"aa\"+n);\n             al.clear();\n             \n             //System.out.println(line);\n             String split[]=line.split(\" \");\n             for(String str:split)if(str.length()==4)al.add(str);\n            detectAB();\n             System.out.print(replace(split[0]));\n            for(int j=1; j<split.length;j++){\n                System.out.print(\" \"+replace(split[j]));\n            }\n             System.out.println();\n         }\n         }catch(Exception e){}\n         \n     }\n     \n }", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String encrypted = sc.nextLine();\n            String decrypted = decrypt(encrypted);\n            System.out.println(decrypted);\n        }\n    }\n    \n    static String decrypt(String encrypted) {\n        // Try all possible alpha and beta values\n        for (int alpha = 1; alpha < 26; alpha++) {\n            if (gcd(alpha, 26) != 1) continue; // alpha must be coprime with 26\n            \n            for (int beta = 0; beta < 26; beta++) {\n                String decrypted = tryDecrypt(encrypted, alpha, beta);\n                if (decrypted != null && (decrypted.contains(\"that\") || decrypted.contains(\"this\"))) {\n                    return decrypted;\n                }\n            }\n        }\n        return encrypted;\n    }\n    \n    static String tryDecrypt(String encrypted, int alpha, int beta) {\n        // Find modular inverse of alpha\n        int alphaInv = modInverse(alpha, 26);\n        if (alphaInv == -1) return null;\n        \n        StringBuilder sb = new StringBuilder();\n        for (char c : encrypted.toCharArray()) {\n            if (c >= 'a' && c <= 'z') {\n                int y = c - 'a';\n                int x = (alphaInv * (y - beta + 26)) % 26;\n                if (x < 0) x += 26;\n                sb.append((char)('a' + x));\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n    \n    static int gcd(int a, int b) {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n    \n    static int modInverse(int a, int m) {\n        for (int x = 1; x < m; x++) {\n            if ((a * x) % m == 1) {\n                return x;\n            }\n        }\n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); for (int i = 0; i < n; i++) { String encrypted = sc.nextLine(); String decrypted = decrypt(encrypted); System.out.println(decrypted); } } static String decrypt(String   be coprime with 26  String  return encrypted; } static String tryDecrypt(String encrypted, int alpha, int beta) { // Find modular inverse  -1) return null; StringBuilder sb = new StringBuilder(); for (char c : encrypted.toCharArray()) { if (c >= 'a' && c <= 'z') {  * (y - beta + 26)) % 26; if (x < 0) x += 26; sb.append((char)('a' + x)); } else { sb.append(c); }  { if (b  static int  x <  1) { return x; } } return -1; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; class Main{ static ArrayList<String> al=new  'q','r','s','t','u','v','w','x','y','z' }; static char getChar(int n){return  (A*m+B)%26;} static String replace(String str){  char replaced = getChar(F(getCode(str.charAt(i))));  A=1;B=0; for(int a=1; a<30000;a+=2){ for(int b=0; b<26;b++){ A=a;B=b; for(String str:al){ String rep = replace(str); //System.out.println(rep); if(rep.equals(\"this\")||rep.equals(\"that\"))return; } }  new BufferedReader(new InputStreamReader(System.in)); // System.out.println(getCode('a')+\"\"+getCode('b')+\"\"+getCode('z')); //System.out.println(replace(\"abz\")); //String line; try{ int n=Integer.parseInt(br.readLine());  //System.out.println(line); String split[]=line.split(\" \"); for(String str:split)if(str.length()==4)al.add(str); detectAB(); System.out.print(replace(split[0])); for(int j=1; j<split.length;j++){ System.out.print(\" \"+replace(split[j])); } System.out.println(); } }catch(Exception e){} } }"], "original_ll": -1.0700280666351318, "sampled_ll": -0.493753045797348, "all_perturbed_sampled_ll": [-1.6575292348861694], "all_perturbed_original_ll": [-1.9125317335128784], "perturbed_sampled_ll": -1.6575292348861694, "perturbed_original_ll": -1.9125317335128784, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for _ in[0]*int(input()):\n e=input()\n for i in range(1,26,2):\n  for j in range(26):\n   a=''.join([c,chr(((ord(c)-97)*i+j)%26+97)][c.islower()]for c in e)\n   if'that'in a or'this'in a:print(a);break\n", "sampled": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    if gcd(a, m) != 1:\n        return None\n    for i in range(1, m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef decrypt_char(c, alpha, beta):\n    if not c.isalpha():\n        return c\n    alpha_inv = mod_inverse(alpha, 26)\n    if alpha_inv is None:\n        return c\n    val = ord(c) - ord('a')\n    decrypted_val = (alpha_inv * (val - beta)) % 26\n    return chr(decrypted_val + ord('a'))\n\ndef decrypt_text(text, alpha, beta):\n    return ''.join(decrypt_char(c, alpha, beta) for c in text)\n\ndef try_decrypt(encrypted):\n    keywords = [\"that\", \"this\"]\n    \n    for alpha in range(1, 26):\n        if gcd(alpha, 26) != 1:\n            continue\n        \n        for beta in range(26):\n            decrypted = decrypt_text(encrypted, alpha, beta)\n            \n            for keyword in keywords:\n                if keyword in decrypted:\n                    return decrypted\n    \n    return encrypted\n\nn = int(input())\nfor _ in range(n):\n    encrypted = input()\n    print(try_decrypt(encrypted))\n", "perturbed_sampled": ["def gcd(a, b): while b: a,  m): if gcd(a, m) != 1: return None  m == 1: return i  c alpha_inv = mod_inverse(alpha, 26)  ord('a') decrypted_val = (alpha_inv * (val - beta)) % 26 return chr(decrypted_val +  c in text) def try_decrypt(encrypted): keywords =  != 1: continue for beta in range(26): decrypted = decrypt_text(encrypted, alpha, beta) for keyword in keywords: if keyword in decrypted: return decrypted return encrypted n = int(input()) for _ in range(n): encrypted = input() print(try_decrypt(encrypted))"], "perturbed_original": [" in range(26): a=''.join([c,chr(((ord(c)-97)*i+j)%26+97)][c.islower()]for c in e) if'that'in a or'this'in a:print(a);break"], "original_ll": -1.9936106204986572, "sampled_ll": -0.6307528018951416, "all_perturbed_sampled_ll": [-2.380518913269043], "all_perturbed_original_ll": [-3.016805410385132], "perturbed_sampled_ll": -2.380518913269043, "perturbed_original_ll": -3.016805410385132, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "d[4],e[9],f,k;char x[];z(){int b,c,a=e[f++];a>9?x[k++]=40,b=z(),x[k++]=a,c=z(),x[k++]=41,a=a-43?a-45?b*c:b-c:b+c:(x[k++]=a+48);return a;}y(o,n,i,j){if(i==7){f=k=0;if(z()==10){x[k]=0;puts(x);return 1;}return 0;}if(o)for(;j--;){e[i]=\"+-*\"[j];if(y(o-1,n+1,i+1,3))return 1;}if(n|i==6)for(j=4;j--;)if(e[i]=d[j]){d[j]=0;if(y(o,n-1,i+1,3))return 1;d[j]=e[i];}return 0;}main(){for(;scanf(\"%d%d%d%d\",d,d+1,d+2,d+3),f=*d;)y(3,0,0,3)||puts(\"0\");}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint nums[4];\nchar result[1025];\nint found;\n\nvoid generate(int depth, int count, int used, int values[], char* exprs[], int value, char* expr) {\n    if (found) return;\n    \n    if (count == 1) {\n        if (value == 10) {\n            strcpy(result, expr);\n            found = 1;\n        }\n        return;\n    }\n    \n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            int newValues[4];\n            char* newExprs[4];\n            int newCount = 0;\n            \n            for (int k = 0; k < count; k++) {\n                if (k != i && k != j) {\n                    newValues[newCount] = values[k];\n                    newExprs[newCount] = exprs[k];\n                    newCount++;\n                }\n            }\n            \n            char expr1[1025], expr2[1025], expr3[1025];\n            \n            // Addition\n            sprintf(expr1, \"(%s + %s)\", exprs[i], exprs[j]);\n            newValues[newCount] = values[i] + values[j];\n            newExprs[newCount] = expr1;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr1);\n            if (found) return;\n            \n            // Subtraction (i - j)\n            sprintf(expr2, \"(%s - %s)\", exprs[i], exprs[j]);\n            newValues[newCount] = values[i] - values[j];\n            newExprs[newCount] = expr2;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr2);\n            if (found) return;\n            \n            // Subtraction (j - i)\n            sprintf(expr3, \"(%s - %s)\", exprs[j], exprs[i]);\n            newValues[newCount] = values[j] - values[i];\n            newExprs[newCount] = expr3;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr3);\n            if (found) return;\n            \n            // Multiplication\n            sprintf(expr1, \"(%s * %s)\", exprs[i], exprs[j]);\n            newValues[newCount] = values[i] * values[j];\n            newExprs[newCount] = expr1;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr1);\n            if (found) return;\n        }\n    }\n}\n\nvoid permute(int pos, int used, int perm[]) {\n    if (found) return;\n    \n    if (pos == 4) {\n        int values[4];\n        char* exprs[4];\n        char exprBuf[4][10];\n        \n        for (int i = 0; i < 4; i++) {\n            values[i] = perm[i];\n            sprintf(exprBuf[i], \"%d\", perm[i]);\n            exprs[i] = exprBuf[i];\n        }\n        \n        generate(0, 4, 0, values, exprs, 0, \"\");\n        return;\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (!(used & (1 << i))) {\n            perm[pos] = nums[i];\n            permute(pos + 1, used | (1 << i), perm);\n            if (found) return;\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d %d\", &nums[0], &nums[1], &nums[2], &nums[3]);\n        \n        if (nums[0] == 0 && nums[1] == 0 && nums[2] == 0 && nums[3] == 0) {\n            break;\n        }\n        \n        found = 0;\n        result[0] = '\\0';\n        \n        int perm[4];\n        permute(0, 0, perm);\n        \n        if (found) {\n            printf(\"%s\\n\", result);\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int nums[4]; char result[1025]; int found; void generate(int  value, char* expr) { if (found) return; if (count == 1) { if (value == 10) { strcpy(result, expr); found = 1; } return; } for (int i = 0; i < count; i++) { for (int j = i + 1; j < count; j++) { int newValues[4]; char* newExprs[4]; int newCount = 0; for (int k = 0;  k != j) { newValues[newCount] = values[k]; newExprs[newCount] = exprs[k];  values[j]; newExprs[newCount]  newExprs, newValues[newCount], expr1); if (found) return; // Subtraction (i - j) sprintf(expr2, \"(%s - %s)\", exprs[i], exprs[j]);  1, newCount + 1, used, newValues,  i) sprintf(expr3, \"(%s - %s)\", exprs[j], exprs[i]); newValues[newCount] = values[j] -  used, newValues, newExprs, newValues[newCount], expr3); if (found) return; // Multiplication sprintf(expr1, \"(%s * %s)\", exprs[i], exprs[j]); newValues[newCount] = values[i] * values[j]; newExprs[newCount]   return; if (pos  (int i =   exprs, 0, \"\"); return; } for (int i =  << i))) { perm[pos] = nums[i];  (1) { scanf(\"%d %d %d %d\", &nums[0], &nums[1], &nums[2], &nums[3]); if (nums[0] == 0 && nums[1] == 0 && nums[2] == 0 && nums[3] == 0) { break; }  perm); if  return 0; }"], "perturbed_original": ["d[4],e[9],f,k;char x[];z(){int b,c,a=e[f++];a>9?x[k++]=40,b=z(),x[k++]=a,c=z(),x[k++]=41,a=a-43?a-45?b*c:b-c:b+c:(x[k++]=a+48);return a;}y(o,n,i,j){if(i==7){f=k=0;if(z()==10){x[k]=0;puts(x);return 1;}return 0;}if(o)for(;j--;){e[i]=\"+-*\"[j];if(y(o-1,n+1,i+1,3))return 1;}if(n|i==6)for(j=4;j--;)if(e[i]=d[j]){d[j]=0;if(y(o,n-1,i+1,3))return 1;d[j]=e[i];}return 0;}main(){for(;scanf(\"%d%d%d%d\",d,d+1,d+2,d+3),f=*d;)y(3,0,0,3)||puts(\"0\");}"], "original_ll": -2.1893181800842285, "sampled_ll": -0.36061084270477295, "all_perturbed_sampled_ll": [-1.5284440517425537], "all_perturbed_original_ll": [-2.1893181800842285], "perturbed_sampled_ll": -1.5284440517425537, "perturbed_original_ll": -2.1893181800842285, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n  public static ArrayList<int[]> perm(int n){\n    int[] num = new int[n];\n    boolean[] flag = new boolean[n];\n    ArrayList<int[]> arrList = new ArrayList<int[]>();\n    permCalc(0,num,flag,arrList);\n    return arrList;\n  }\n\n  public static void permCalc(int rank, int[] num, boolean[] flag, ArrayList<int[]> arrList){\n    if (rank == num.length) {\n      arrList.add(num.clone());\n    }\n    else {\n      for (int i = 0; i < num.length; i++) {\n        if (!flag[i]) {\n          num[rank] = i;\n          flag[i] = true;\n          permCalc(rank+1,num,flag,arrList);\n          flag[i] = false;\n        }\n      }\n    }\n  }\n\n  public static int ope(int a, int b, int operand){\n    switch (operand) {\n      case 0:\n        return a+b;\n      case 1:\n        return a-b;\n      default:\n        return a*b;\n    }\n  }\n\n  public static String opeToStr(int operand){\n    switch (operand) {\n      case 0:\n        return \"+\";\n      case 1:\n        return \"-\";\n      default:\n        return \"*\";\n    }\n  }\n\n  public static String check(int[] num, int[] op){\n    int a = num[0];\n    int b = num[1];\n    int c = num[2];\n    int d = num[3];\n    if(ope(ope(ope(a,b,op[0]),c,op[1]),d,op[2]) == 10) {\n      return \"((\"+a+\" \"+opeToStr(op[0])+\" \"+b+\") \"+opeToStr(op[1])+\" \"+c+\") \"+opeToStr(op[2])+\" \"+d;\n    }\n    else if(ope(ope(a,b,op[0]),ope(c,d,op[2]),op[1]) == 10) {\n      return \"(\"+a+\" \"+opeToStr(op[0])+\" \"+b+\") \"+opeToStr(op[1])+\" (\"+c+\" \"+opeToStr(op[2])+\" \"+d+\")\";\n    }\n    else if(ope(ope(a,ope(b,c,op[1]),op[0]),d,op[2]) == 10) {\n      return \"(\"+a+\" \"+opeToStr(op[0])+\" (\"+b+\" \"+opeToStr(op[1])+\" \"+c+\")) \"+opeToStr(op[2])+\" \"+d;\n    }\n    else if(ope(a,ope(ope(b,c,op[1]),d,op[2]),op[0]) == 10) {\n      return a+\" \"+opeToStr(op[0])+\" ((\"+b+\" \"+opeToStr(op[1])+\" \"+c+\") \"+opeToStr(op[2])+\" \"+d+\")\";\n    }\n    else if(ope(a,ope(b,ope(c,d,op[2]),op[1]),op[0]) == 10) {\n      return a+\" \"+opeToStr(op[0])+\" (\"+b+\" \"+opeToStr(op[1])+\" (\"+c+\" \"+opeToStr(op[2])+\" \"+d+\"))\";\n    }\n    else {\n      return null;\n    }\n  }\n\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    ArrayList<int[]> arrList = perm(4);\n    int[][] operand = new int[27][];\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 3; j++) {\n        for (int k = 0; k < 3; k++) {\n          int[] temp = {i,j,k};\n          operand[9*i+3*j+k] = temp;\n        }\n      }\n    }\n    while(true) {\n      int[] num0 = new int[4];\n      for (int i = 0; i < 4; i++) {\n        num0[i] = sc.nextInt();\n      }\n      if (num0[0] == 0 && num0[1] == 0 && num0[2] == 0 && num0[3] == 0) {\n        break;\n      }\n      String chk = null;\n      search:\n      for (int i = 0; i < arrList.size(); i++) {\n        int[] num = {num0[arrList.get(i)[0]],num0[arrList.get(i)[1]],\n                     num0[arrList.get(i)[2]],num0[arrList.get(i)[3]]};\n        for (int j = 0; j < operand.length; j++) {\n          chk = check(num, operand[j]);\n          if (chk != null) {\n            break search;\n          }\n        }\n      }\n      if (chk == null) {\n        System.out.println(0);\n      }\n      else {\n        System.out.println(chk);\n      }\n    }\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Expr {\n        String str;\n        int val;\n        Expr(String s, int v) {\n            str = s;\n            val = v;\n        }\n    }\n    \n    static String result;\n    static boolean found;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int d = sc.nextInt();\n            \n            if (a == 0 && b == 0 && c == 0 && d == 0) break;\n            \n            int[] nums = {a, b, c, d};\n            result = null;\n            found = false;\n            \n            permute(nums, 0);\n            \n            if (result != null) {\n                System.out.println(result);\n            } else {\n                System.out.println(\"0\");\n            }\n        }\n    }\n    \n    static void permute(int[] nums, int start) {\n        if (found) return;\n        \n        if (start == nums.length) {\n            solve(nums);\n            return;\n        }\n        \n        for (int i = start; i < nums.length; i++) {\n            swap(nums, start, i);\n            permute(nums, start + 1);\n            swap(nums, start, i);\n            if (found) return;\n        }\n    }\n    \n    static void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    \n    static void solve(int[] nums) {\n        List<Expr> exprs = new ArrayList<>();\n        for (int num : nums) {\n            exprs.add(new Expr(String.valueOf(num), num));\n        }\n        \n        generate(exprs);\n    }\n    \n    static void generate(List<Expr> exprs) {\n        if (found) return;\n        \n        if (exprs.size() == 1) {\n            if (exprs.get(0).val == 10) {\n                result = exprs.get(0).str;\n                found = true;\n            }\n            return;\n        }\n        \n        for (int i = 0; i < exprs.size(); i++) {\n            for (int j = 0; j < exprs.size(); j++) {\n                if (i == j) continue;\n                \n                Expr e1 = exprs.get(i);\n                Expr e2 = exprs.get(j);\n                \n                char[] ops = {'+', '-', '*'};\n                \n                for (char op : ops) {\n                    int newVal = calc(e1.val, e2.val, op);\n                    String newStr = \"(\" + e1.str + \" \" + op + \" \" + e2.str + \")\";\n                    \n                    List<Expr> newExprs = new ArrayList<>();\n                    for (int k = 0; k < exprs.size(); k++) {\n                        if (k != i && k != j) {\n                            newExprs.add(exprs.get(k));\n                        }\n                    }\n                    newExprs.add(new Expr(newStr, newVal));\n                    \n                    generate(newExprs);\n                    if (found) return;\n                }\n            }\n        }\n    }\n    \n    static int calc(int a, int b, char op) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n        }\n        return 0;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  val; Expr(String s, int v) { str = s; val = v; } } static String result; static boolean found; public  while (true) { int a = sc.nextInt(); int b = sc.nextInt(); int c = sc.nextInt(); int d = sc.nextInt(); if (a ==  d == 0) break; int[] nums = {a, b, c, d}; result = null; found = false; permute(nums, 0); if (result  } static void permute(int[] nums, int start) { if (found) return; if (start ==  i < nums.length;  start, i); if  nums[j]; nums[j] = temp; } static void solve(int[] nums) { List<Expr> exprs = new ArrayList<>(); for (int num : nums) { exprs.add(new Expr(String.valueOf(num), num)); }  if (exprs.size() == 1) { if (exprs.get(0).val == 10) { result = exprs.get(0).str; found = true; } return; } for (int i =  0; j < exprs.size();  '-', '*'}; for (char op : ops) { int newVal = calc(e1.val, e2.val, op); String   exprs.size(); k++) { if (k  op) { switch (op) { case '+': return a + b; case '-': return a - b; case '*': return a * b; } return 0; } }"], "perturbed_original": ["import  = new int[n]; boolean[] flag = new boolean[n]; ArrayList<int[]> arrList = new ArrayList<int[]>(); permCalc(0,num,flag,arrList); return arrList; } public static void permCalc(int rank, int[] num, boolean[] flag, ArrayList<int[]> arrList){ if (rank == num.length)  i < num.length;  public static int ope(int a, int b, int operand){ switch (operand) {  a*b; } } public static String opeToStr(int operand){ switch (operand) { case  } }  num[0]; int b = num[1]; int c  return \"((\"+a+\" \"+opeToStr(op[0])+\" \"+b+\") \"+opeToStr(op[1])+\" \"+c+\") \"+opeToStr(op[2])+\" \"+d; } else if(ope(ope(a,b,op[0]),ope(c,d,op[2]),op[1]) == 10) { return \"(\"+a+\" \"+opeToStr(op[0])+\" \"+b+\") \"+opeToStr(op[1])+\" (\"+c+\" \"+opeToStr(op[2])+\" \"+d+\")\";   return a+\" \"+opeToStr(op[0])+\" ((\"+b+\" \"+opeToStr(op[1])+\" \"+c+\") \"+opeToStr(op[2])+\" \"+d+\")\"; } else if(ope(a,ope(b,ope(c,d,op[2]),op[1]),op[0]) == 10) { return a+\" \"+opeToStr(op[0])+\" (\"+b+\" \"+opeToStr(op[1])+\"  public static void main(String[] args){ Scanner sc = new Scanner(System.in); ArrayList<int[]> arrList = perm(4); int[][] operand = new int[27][]; for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { for (int k = 0; k <  } } }  0  = 0; i < arrList.size(); i++) { int[] num = {num0[arrList.get(i)[0]],num0[arrList.get(i)[1]], num0[arrList.get(i)[2]],num0[arrList.get(i)[3]]}; for (int j = 0; j < operand.length; j++) { chk = check(num, operand[j]); if (chk != null) { break search; } } } if (chk  } }"], "original_ll": -0.4100996255874634, "sampled_ll": -0.2919251620769501, "all_perturbed_sampled_ll": [-1.5548436641693115], "all_perturbed_original_ll": [-1.2992414236068726], "perturbed_sampled_ll": -1.5548436641693115, "perturbed_original_ll": -1.2992414236068726, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import *\ndef f(s):\n if sum(s)==10:return\"((({} + {}) + {}) + {})\".format(*s)\n for a,b,c,d in permutations(s):\n  for x,y,z in permutations('+-**',3):\n   for t in[f\"({a} {x} {b}) {y} ({c} {z} {d})\",f\"(({a} {x} {b}) {y} {c}) {z} {d}\",f\"({a} {x} ({b} {y} {c})) {z} {d}\"]:\n    if eval(t)==10:return'('+t+')'\n else:return 0\nfor e in iter(input,'0 0 0 0'):print(f(list(map(int,e.split()))))\n", "sampled": "from itertools import permutations, product\n\ndef evaluate(expr):\n    try:\n        return eval(expr)\n    except:\n        return None\n\ndef generate_expressions(nums):\n    operators = ['+', '-', '*']\n    \n    # Template patterns for 4 numbers with different parenthesizations\n    patterns = [\n        # No parentheses\n        \"{} {} {} {} {} {} {}\",\n        # One pair of parentheses\n        \"({} {} {}) {} {} {} {}\",\n        \"{} {} ({} {} {}) {} {}\",\n        \"{} {} {} {} ({} {} {})\",\n        # Two pairs of parentheses\n        \"({} {} {}) {} ({} {} {})\",\n        \"(({} {} {}) {} {}) {} {}\",\n        \"{} {} (({} {} {}) {} {})\",\n        \"({} {} ({} {} {})) {} {}\",\n        \"{} {} ({} {} ({} {} {}))\",\n        # Three pairs of parentheses\n        \"(({} {} {}) {} ({} {} {}))\",\n        \"((({} {} {}) {} {}) {} {})\",\n        \"({} {} (({} {} {}) {} {}))\",\n        \"({} {} ({} {} ({} {} {})))\",\n        \"{} {} ((({} {} {}) {} {}))\",\n        \"{} {} (({} {} ({} {} {})))\",\n        \"{} {} ({} {} (({} {} {})))\",\n        # More complex patterns\n        \"((({} {} {}) {} ({} {} {})))\",\n        \"(({} {} ({} {} {})) {} {})\",\n        \"({} {} (({} {} ({} {} {}))))\",\n        \"(({} {} {}) {} (({} {} {})))\",\n        \"((({} {} ({} {} {}))) {} {})\",\n        \"{} {} (((({} {} {})) {} {}))\",\n    ]\n    \n    for perm in permutations(nums):\n        for ops in product(operators, repeat=3):\n            for pattern in patterns:\n                try:\n                    # Interleave numbers and operators\n                    elements = []\n                    num_idx = 0\n                    op_idx = 0\n                    for char in pattern:\n                        if char == '{}':\n                            if num_idx < 4:\n                                elements.append(str(perm[num_idx]))\n                                num_idx += 1\n                            elif op_idx < 3:\n                                elements.append(ops[op_idx])\n                                op_idx += 1\n                    \n                    if num_idx == 4 and op_idx == 3:\n                        expr = pattern.format(perm[0], ops[0], perm[1], ops[1], perm[2], ops[2], perm[3])\n                        result = evaluate(expr)\n                        if result == 10:\n                            return expr\n                except:\n                    continue\n    \n    return None\n\ndef solve():\n    results = []\n    while True:\n        line = input().split()\n        nums = [int(x) for x in line]\n        \n        if nums == [0, 0, 0, 0]:\n            break\n        \n        expr = generate_expressions(nums)\n        if expr:\n            results.append(expr)\n        else:\n            results.append(\"0\")\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "perturbed_sampled": ["from itertools import permutations, product def evaluate(expr): try: return eval(expr) except: return None def generate_expressions(nums): operators = ['+', '-', '*'] # Template patterns for 4 numbers with different parenthesizations patterns = [ # No parentheses \"{} {} {} {} {} {} {}\", # One pair of parentheses \"({} {} {}) {} {} {} {}\", \"{} {} ({} {} {}) {} {}\", \"{} {} {} {} ({} {} {})\", # Two  \"(({} {}  {} {})\", \"({}  {} {}) {}   \"(({} {} ({} {} {})) {} {})\", \"({} {} (({} {} ({} {} {}))))\", \"(({} {} {}) {} (({} {} {})))\", \"((({} {} ({} {} {}))) {} {})\", \"{} {} (((({} {} {})) {} {}))\", ] for perm  patterns: try: # Interleave numbers and operators elements = [] num_idx = 0 op_idx = 0 for char  elements.append(str(perm[num_idx])) num_idx  if num_idx == 4 and op_idx  expr except: continue return None def solve(): results = [] while True: line = input().split() nums = [int(x) for x in line] if nums ==  results.append(expr) else: results.append(\"0\") for result in results: print(result) solve()"], "perturbed_original": ["from itertools import *  for a,b,c,d in permutations(s): for x,y,z in permutations('+-**',3): for t in[f\"({a} {x} {b})  {x} ({b} {y} {c})) {z} {d}\"]: if eval(t)==10:return'('+t+')' else:return 0 for e in iter(input,'0 0 0 0'):print(f(list(map(int,e.split()))))"], "original_ll": -1.437110424041748, "sampled_ll": -0.7116956114768982, "all_perturbed_sampled_ll": [-2.0930323600769043], "all_perturbed_original_ll": [-2.5979607105255127], "perturbed_sampled_ll": -2.0930323600769043, "perturbed_original_ll": -2.5979607105255127, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void)\n{\n  int i,j;\n  int prime[70000];\n  int n;\n  for(i=0;i<60000;i++){\n    prime[i] = 1;\n  }\n  prime[0]=0;\n  scanf(\"%d\",&n);\n\n  for(i=1;i*i<=60000;i++){\n    if(prime[i]==1){\n      for(j=i+1;(i+1)*j<=60000;j++){\n\tprime[(i+1)*j-1]=0;\n      }\n    }\n  }\n\n  for(i=n-2;0<=i;i--){\n    if(prime[i]==1){\n      printf(\"%d \",i+1); break;\n    }\n  }\n\n  for(i=n;i<60000;i++){\n    if(prime[i]==1){\n      printf(\"%d\",i+1); break;\n    }\n  }\n  putchar('\\n');\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    \n    int sqrt_num = (int)sqrt(num);\n    for (int i = 3; i <= sqrt_num; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) != EOF) {\n        int smaller = n - 1;\n        int larger = n + 1;\n        \n        while (smaller >= 2 && !is_prime(smaller)) {\n            smaller--;\n        }\n        \n        while (!is_prime(larger)) {\n            larger++;\n        }\n        \n        printf(\"%d %d\\n\", smaller, larger);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdbool.h> #include <math.h> bool is_prime(int  == 2) return true; if (num % 2 == 0) return false;  int main() { int n; while (scanf(\"%d\", &n) != EOF) { int smaller = n - 1; int larger = n + 1;  (!is_prime(larger)) { larger++; } printf(\"%d %d\\n\", smaller, larger); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int i,j; int prime[70000]; int n; for(i=0;i<60000;i++){ prime[i] = 1; } prime[0]=0; scanf(\"%d\",&n); for(i=1;i*i<=60000;i++){ if(prime[i]==1){ ++;<extra_id_1>if(prime[0]==1){ return 0; }"], "original_ll": -0.9172674417495728, "sampled_ll": -0.40369555354118347, "all_perturbed_sampled_ll": [-1.491611361503601], "all_perturbed_original_ll": [-1.9775919914245605], "perturbed_sampled_ll": -1.491611361503601, "perturbed_original_ll": -1.9775919914245605, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tfor(int i=n-1;i>=2;i--){\n\t\t\t\tboolean flag=true;\n\t\t\t\tfor(int j=2;j<Math.sqrt(i)+1;j++){\n\t\t\t\t\tif(i%j==0){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tSystem.out.print(i+\" \");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=n+1;i<50000;i++){\n\t\t\t\tboolean flag=true;\n\t\t\t\tfor(int j=2;j<Math.sqrt(i)+1;j++){\n\t\t\t\t\tif(i%j==0){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static boolean[] isPrime;\n    static final int MAX = 100001;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Sieve of Eratosthenes\n        isPrime = new boolean[MAX];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i < MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < MAX; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            \n            int smaller = 0;\n            for (int i = n - 1; i >= 2; i--) {\n                if (isPrime[i]) {\n                    smaller = i;\n                    break;\n                }\n            }\n            \n            int larger = 0;\n            for (int i = n + 1; i < MAX; i++) {\n                if (isPrime[i]) {\n                    larger = i;\n                    break;\n                }\n            }\n            \n            System.out.println(smaller + \" \" + larger);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  int MAX =  new Scanner(System.in); // Sieve of Eratosthenes  < MAX; i++) { if (isPrime[i]) { for (int j = i * i; j < MAX; j += i) { isPrime[j] = false; } } } while (sc.hasNext()) { int n = sc.nextInt(); int smaller = 0; for (int i = n - 1; i >= 2;  } int larger = 0; for (int i = n + 1;  larger); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args){ Scanner sc=new Scanner(System.in); while(sc.hasNext()){ int n=sc.nextInt(); for(int i=n-1;i>=2;i--){ boolean flag=true;  break; }  } } if(flag){ System.out.println(i); break; } } } } }"], "original_ll": -0.4319078028202057, "sampled_ll": -0.3011228144168854, "all_perturbed_sampled_ll": [-1.5687137842178345], "all_perturbed_original_ll": [-1.6977448463439941], "perturbed_sampled_ll": -1.5687137842178345, "perturbed_original_ll": -1.6977448463439941, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\nr = 50000\nsqrt = int(math.sqrt(r))\np = [1]*r\np[0] = 0\nfor i in range(1,sqrt):\n    if p[i]:\n        for j in range(2*i+1,r,i+1):\n            p[j] = 0\n            \nwhile True:\n    try:\n        n = int(raw_input())\n        for i in range(n,50000):\n            if p[i] == 1:\n                lp = i+1\n                break\n        for i in range(n-2,0,-1):\n            if p[i] == 1:\n                sp = i+1\n                break\n        print sp, lp\n    except:\n        break", "sampled": "import sys\n\ndef sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\n# Precompute primes up to a reasonable limit\nMAX_LIMIT = 100000\nis_prime = sieve_of_eratosthenes(MAX_LIMIT)\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    \n    # Find largest prime less than n\n    smaller = n - 1\n    while smaller > 1 and not is_prime[smaller]:\n        smaller -= 1\n    \n    # Find smallest prime greater than n\n    larger = n + 1\n    while larger <= MAX_LIMIT and not is_prime[larger]:\n        larger += 1\n    \n    print(smaller, larger)\n", "perturbed_sampled": ["import sys def sieve_of_eratosthenes(limit): is_prime  False for i in range(2, int(limit**0.5) + 1): if is_prime[i]: for j in range(i*i, limit + 1, i): is_prime[j] = False return is_prime # Precompute primes up to a reasonable  than n smaller = n - 1  # Find smallest prime greater than  and not is_prime[larger]: larger += 1 print(smaller, larger)"], "perturbed_original": ["import math r =  for i  0 while True: try: n = int(raw_input()) for  break for i in range(n-2,0,-1): if p[i] == 1: sp = i+1 break print sp, lp except: break"], "original_ll": -1.0689048767089844, "sampled_ll": -0.4871263802051544, "all_perturbed_sampled_ll": [-2.015787124633789], "all_perturbed_original_ll": [-3.0979597568511963], "perturbed_sampled_ll": -2.015787124633789, "perturbed_original_ll": -3.0979597568511963, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(int argc, char *argv[]){\n  int prise,num;\n  long long int sum = 0;\n  int num_sum = 0;\n  int times = 0;\n  \n  while(scanf(\"%d,%d\",&prise,&num) != EOF){\n    sum += (long long int)(prise)*(long long int)(num);\n    num_sum += num;\n    ++times;\n  }\n\n  printf(\"%lld\\n%.0lf\\n\",sum,(double)(num_sum)/times);\n  \n  return 0;    \n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int price, quantity;\n    int total_sales = 0;\n    int total_quantity = 0;\n    int count = 0;\n    \n    while (scanf(\"%d,%d\", &price, &quantity) == 2) {\n        total_sales += price * quantity;\n        total_quantity += quantity;\n        count++;\n    }\n    \n    int average = (total_quantity + count / 2) / count;\n    \n    printf(\"%d\\n\", total_sales);\n    printf(\"%d\\n\", average);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  total_quantity = 0; int count = 0; while (scanf(\"%d,%d\", &price, &quantity) == 2) { total_sales += price * quantity; total_quantity += quantity; count++; } int average = (total_quantity +  0; }"], "perturbed_original": ["#include <stdio.h> int main(int  0; int num_sum = 0; int times = 0; while(scanf(\"%d,%d\",&prise,&num)  += num; ++times; } printf(\"%lld\\n%.0lf\\n\",sum,(double)(num_sum)/times); return 0; }"], "original_ll": -1.3890281915664673, "sampled_ll": -0.8700714111328125, "all_perturbed_sampled_ll": [-2.1664047241210938], "all_perturbed_original_ll": [-2.9256536960601807], "perturbed_sampled_ll": -2.1664047241210938, "perturbed_original_ll": -2.9256536960601807, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tint count = 0;\n\t\tint sum = 0;\n\t\tint sum2 = 0;\n\t\twhile(stdIn.hasNext()) {\n\t\t\tcount++;\n\t\t\tString[] in = stdIn.next().split(\",\");\n\t\t\tint a = Integer.parseInt(in[0]);\n\t\t\tint b = Integer.parseInt(in[1]);\n\t\t\tsum += a*b;\n\t\t\tsum2 += b;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\tdouble ave = sum2/(double)count*10;\n\t\tif(ave%10 >= 5) {\n\t\t\tave += 10-ave%10;\n\t\t}\n\t\telse {\n\t\t\tave -= (ave*10)%10;\n\t\t}\n\t\tave /=10;\n\t\t\n\t\tSystem.out.println((int)ave);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int totalAmount = 0;\n        int totalQuantity = 0;\n        int count = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            int price = Integer.parseInt(parts[0]);\n            int quantity = Integer.parseInt(parts[1]);\n            \n            totalAmount += price * quantity;\n            totalQuantity += quantity;\n            count++;\n        }\n        \n        int averageQuantity = (int) Math.round((double) totalQuantity / count);\n        \n        System.out.println(totalAmount);\n        System.out.println(averageQuantity);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[]  0; int totalQuantity = 0; int count = 0; while (sc.hasNextLine()) { String line = sc.nextLine();  Integer.parseInt(parts[0]); int quantity = Integer.parseInt(parts[1]); totalAmount += price * quantity; totalQuantity += quantity;  System.out.println(totalAmount); System.out.println(averageQuantity); sc.close(); } }"], "perturbed_original": ["import java.io.*;  public static void main(String[] args) { Scanner stdIn = new Scanner(System.in); int count = 0; int sum = 0;  stdIn.next().split(\",\"); int a = Integer.parseInt(in[0]); int b = Integer.parseInt(in[1]); sum  sum2/(double)count*10; if(ave%10 >= 5)  } ave /=10; System.out.println((int)ave); } }"], "original_ll": -0.8736165761947632, "sampled_ll": -0.4954199492931366, "all_perturbed_sampled_ll": [-1.9477074146270752], "all_perturbed_original_ll": [-2.300062894821167], "perturbed_sampled_ll": -1.9477074146270752, "perturbed_original_ll": -2.300062894821167, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# _*_ coding: utf-8 _*_\n\nsum = 0\ntotal = 0\ncnt = 0\n\nwhile True:\n\ts = input()\n\t\n\tif s == '':\n\t\tbreak\n\t\n\tlist = s.split(',')\n\tsum += int(list[0])*int(list[1])\n\ttotal += int(list[1])\n\tcnt += 1\n\nave = total / cnt + 0.5\n\nprint(sum)\nprint(int(ave))", "sampled": "import sys\n\ntotal_amount = 0\ntotal_quantity = 0\ncount = 0\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        price, quantity = map(int, line.split(','))\n        total_amount += price * quantity\n        total_quantity += quantity\n        count += 1\n\naverage_quantity = round(total_quantity / count)\n\nprint(total_amount)\nprint(average_quantity)\n", "perturbed_sampled": ["import sys total_amount  in sys.stdin: line = line.strip() if line: price, quantity = map(int, line.split(','))  1 average_quantity = round(total_quantity / count) print(total_amount) print(average_quantity)"], "perturbed_original": ["# _*_ coding: utf-8 _*_ sum = 0 total = 0 cnt  '': break list  1 ave = total / cnt + 0.5 print(sum) print(int(ave))"], "original_ll": -1.4167370796203613, "sampled_ll": -0.9002493619918823, "all_perturbed_sampled_ll": [-3.060624122619629], "all_perturbed_original_ll": [-3.375216007232666], "perturbed_sampled_ll": -3.060624122619629, "perturbed_original_ll": -3.375216007232666, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void) {\n    double i,max,min;\n    scanf(\"%lf\",&max);\n    min=max;\n    while(1) {\n        if(scanf(\"%lf\",&i) == -0){\n            break;\n        }\n        if(i < min){\n            min = i;\n        }\n        if(i > max){\n            max = i;\n        }\n    }\n    printf(\"%f\\n\",max-min);\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double height;\n    double max = -1;\n    double min = 1000001;\n    \n    while (scanf(\"%lf\", &height) == 1) {\n        if (height > max) {\n            max = height;\n        }\n        if (height < min) {\n            min = height;\n        }\n    }\n    \n    printf(\"%.1f\\n\", max - min);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double height; double max = -1; double min =  max) { max  height; } } printf(\"%.1f\\n\", max - min); return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { double i,max,min; scanf(\"%lf\",&max); min=max; while(1) { if(scanf(\"%lf\",&i) == -0){ break; } if(i < min){ min  } printf(\"%f\\n\",max-min); return 0; }"], "original_ll": -1.0607976913452148, "sampled_ll": -0.7518323063850403, "all_perturbed_sampled_ll": [-2.6685445308685303], "all_perturbed_original_ll": [-2.1367344856262207], "perturbed_sampled_ll": -2.6685445308685303, "perturbed_original_ll": -2.1367344856262207, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tdouble height = Double.MIN_VALUE,min = Double.MAX_VALUE;\n\t\twhile(scan.hasNext()) {\n\t\t\tdouble mount = scan.nextDouble();\n\t\t\tif(height < mount) {\n\t\t\t\theight = mount;\n\t\t\t}\n\t\t\tif(min > mount) {\n\t\t\t\tmin = mount;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(height - min);\n\t\tscan.close();\n\t}\n}\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        double max = Double.MIN_VALUE;\n        double min = Double.MAX_VALUE;\n        \n        while (sc.hasNextDouble()) {\n            double height = sc.nextDouble();\n            if (height > max) {\n                max = height;\n            }\n            if (height < min) {\n                min = height;\n            }\n        }\n        \n        double diff = max - min;\n        System.out.println(diff);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  = Double.MAX_VALUE; while (sc.hasNextDouble()) { double height = sc.nextDouble(); if (height >  { min = height; } } double diff = max - min; System.out.println(diff); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main  new Scanner(System.in); double height = Double.MIN_VALUE,min = Double.MAX_VALUE; while(scan.hasNext()) { double mount = scan.nextDouble(); if(height < mount) { height = mount; } if(min >  scan.close(); } }"], "original_ll": -0.8427823781967163, "sampled_ll": -0.5806533098220825, "all_perturbed_sampled_ll": [-2.166900873184204], "all_perturbed_original_ll": [-2.706512212753296], "perturbed_sampled_ll": -2.166900873184204, "perturbed_original_ll": -2.706512212753296, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "fir=0\nsec=0\n\nwhile True:\n        try:\n                a=raw_input()\n                if a >= fir:\n                        sec = fir\n                        fir = a\n                elif a >= sec:\n                        sec = a\n        except EOFError:\n                break\n\nprint fir-sec", "sampled": "import sys\n\nheights = []\nfor line in sys.stdin:\n    heights.append(float(line.strip()))\n\nprint(max(heights) - min(heights))\n", "perturbed_sampled": ["import sys heights = [] for line in sys.stdin: heights.append(float(line.strip())) print(max(heights) - min(heights))"], "perturbed_original": ["fir=0 sec=0 while True: try: a=raw_input() if a >=  sec: sec = a except EOFError: break print fir-sec"], "original_ll": -1.22775399684906, "sampled_ll": -1.7717134952545166, "all_perturbed_sampled_ll": [-2.161045551300049], "all_perturbed_original_ll": [-2.7866804599761963], "perturbed_sampled_ll": -2.161045551300049, "perturbed_original_ll": -2.7866804599761963, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\tint ball[3];\n\tint x,y,temp;\n\tchar a,b;\n\tball[0]=1;ball[1]=0;ball[2]=0;\n\twhile(scanf(\"%c,%c\",&a,&b)!=EOF){\n\t\tswitch(a){\n\t\tcase 'A':x=0;break;\n\t\tcase 'B':x=1;break;\n\t\tcase 'C':x=2;break;\n\t\t}\n\t\tswitch(b){\n\t\tcase 'A':y=0;break;\n\t\tcase 'B':y=1;break;\n\t\tcase 'C':y=2;break;\n\t\t}\n\t\ttemp=ball[x];ball[x]=ball[y];ball[y]=temp;\n\t}\n\tif(ball[0]==1){\n\t\tprintf(\"A\\n\");\n\t}else if(ball[1]==1){\n\t\tprintf(\"B\\n\");\n\t}else{printf(\"C\\n\");}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    char ball = 'A';\n    char line[10];\n    \n    while (fgets(line, sizeof(line), stdin) != NULL) {\n        char pos1 = line[0];\n        char pos2 = line[2];\n        \n        if (ball == pos1) {\n            ball = pos2;\n        } else if (ball == pos2) {\n            ball = pos1;\n        }\n    }\n    \n    printf(\"%c\\n\", ball);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() {  != NULL) { char pos1 = line[0]; char pos2 = line[2]; if (ball == pos1) { ball = pos2; } else if (ball == pos2)  }"], "perturbed_original": ["#include<stdio.h> int main(void){ int ball[3]; int x,y,temp; char a,b; ball[0]=1;ball[1]=0;ball[2]=0; while(scanf(\"%c,%c\",&a,&b)!=EOF){ switch(a){ case 'A':x=0;break; case 'B':x=1;break; case  temp=ball[x];ball[x]=ball[y];ball[y]=temp; } if(ball[0]==1){ printf(\"A\\n\"); }else if(ball[1]==1){ printf(\"B\\n\"); }else{printf(\"C\\n\");} return 0; }"], "original_ll": -0.7205878496170044, "sampled_ll": -0.9060739874839783, "all_perturbed_sampled_ll": [-2.3384382724761963], "all_perturbed_original_ll": [-1.4883025884628296], "perturbed_sampled_ll": -2.3384382724761963, "perturbed_original_ll": -1.4883025884628296, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s;\n\t\tString[] t;\n\t\tint[] location=new int[3];\n\t\tlocation[0]=1;\n\t\tlocation[1]=0;\n\t\tlocation[2]=0;\n\t\tint alt;\n\t\tint[] number=new int[2];\n\t\twhile((s=reader.readLine())!=null){\n\t\t\tif(s.isEmpty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(s==\"\"){break;}\n\t\t\tt=s.split(\",\");\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tif(t[i]==\"A\"){number[i]=0;}\n\t\t\t\t\telse if(t[i]==\"B\"){number[i]=1;}\n\t\t\t\t\telse if(t[i]==\"C\"){number[i]=2;}\t\n\t\t\t}\n\t\t\talt=location[number[0]];\n\t\t\tlocation[number[0]]=location[number[1]];\n\t\t\tlocation[number[1]]=alt;\n\t\t}\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tif(location[j]==1){\n\t\t\t\t\tswitch(j){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tSystem.out.println(\"A\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tSystem.out.println(\"B\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tSystem.out.println(\"C\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        char ball = 'A';\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] positions = line.split(\",\");\n            char pos1 = positions[0].charAt(0);\n            char pos2 = positions[1].charAt(0);\n            \n            if (ball == pos1) {\n                ball = pos2;\n            } else if (ball == pos2) {\n                ball = pos1;\n            }\n        }\n        \n        System.out.println(ball);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public <extra_id_1>( char<extra_id_2>char char0= =<extra_id_3>void<extra_id_4>} ;<extra_id_5>{ char<extra_id_6>+<extra_id_7>{<extra_id_8>; } sc = new Scanner(System.in); char ball = 'A'; while (sc.hasNextLine()) {  if (ball == pos1) { ball = pos2; } else if (ball == pos2) { ball = pos1; } } System.out.println(ball); sc.close(); } }"], "perturbed_original": ["import java.io.*; public class Main{ public static void main(String[] args)throws IOException{ BufferedReader reader=new BufferedReader(new InputStreamReader(System.in)); String s;  int[] number=new int[2]; while((s=reader.readLine())!=null){ if(s.isEmpty()){ break; } if(s==\"\"){break;} t=s.split(\",\"); for(int i=0;i<2;i++){  for(int j=0;j<3;j++){ if(location[j]==1){  2: System.out.println(\"C\"); break; } } } } }"], "original_ll": -0.7438599467277527, "sampled_ll": -0.6557935476303101, "all_perturbed_sampled_ll": [-2.2072384357452393], "all_perturbed_original_ll": [-1.7292304039001465], "perturbed_sampled_ll": -2.2072384357452393, "perturbed_original_ll": -1.7292304039001465, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nimport itertools\n\nA = [1, 0, 0]\n\nfor s in sys.stdin:\n    s = s.strip()\n    a, b = s.split(',')\n\n    if a == 'A':\n        i = 0\n    elif a == 'B':\n        i = 1\n    elif a == 'C':\n        i = 2\n\n    if b == 'A':\n        j = 0\n    elif b == 'B':\n        j = 1\n    elif b == 'C':\n        j = 2\n\n    A[i], A[j] = A[j], A[i]\n\nif A[0] == 1:\n    print('A')\nelif A[1] == 1:\n    print('B')\nelse:\n    print('C')", "sampled": "import sys\n\nball_position = 'A'\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    pos1, pos2 = line.split(',')\n    \n    if ball_position == pos1:\n        ball_position = pos2\n    elif ball_position == pos2:\n        ball_position = pos1\n\nprint(ball_position)\n", "perturbed_sampled": ["import sys ball_position = 'A'  continue pos1, pos2 = line.split(',') if ball_position == pos1: ball_position = pos2 elif ball_position == pos2: ball_position = pos1 print(ball_position)"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys import os import math import itertools A = [1, 0, 0] for s in sys.stdin: s = s.strip() a, b = s.split(',') if a == 'A': i  a == 'C': i = 2 if b  A[i], A[j] = A[j],  print('B') else: print('C')"], "original_ll": -0.6421764492988586, "sampled_ll": -1.114303469657898, "all_perturbed_sampled_ll": [-2.2022545337677], "all_perturbed_original_ll": [-2.153414726257324], "perturbed_sampled_ll": -2.2022545337677, "perturbed_original_ll": -2.153414726257324, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tfloat g;\n\t\n\tscanf(\"%f\", &g);\n\t\n\tif (g <= 48.00){\n\t\tprintf(\"light fly\\n\");\n\t}\n\telse if ((48.00 < g)&&(g <= 51.00)){\n\t\tprintf(\"fly\\n\");\n\t}\n\telse if ((51.00 < g)&&(g <= 54.00)){\n\t\tprintf(\"bantam\\n\");\n\t}\n\telse if ((54.00 < g)&&(g <= 57.00)){\n\t\tprintf(\"feather\\n\");\n\t}\n\telse if ((57.00 < g)&&(g <= 60.00)){\n\t\tprintf(\"light\\n\");\n\t}\n\telse if ((60.00 < g)&&(g <= 64.00)){\n\t\tprintf(\"light welter\\n\");\n\t}\n\telse if ((64.00 < g)&&(g <= 69.00)){\n\t\tprintf(\"welter\\n\");\n\t}\n\telse if ((69.00 < g)&&(g <= 75.00)){\n\t\tprintf(\"light middle\\n\");\n\t}\n\telse if ((75.00 < g)&&(g <= 81.00)){\n\t\tprintf(\"middle\\n\");\n\t}\n\telse if ((81.00 < g)&&(g <= 91.00)){\n\t\tprintf(\"light heavy\\n\");\n\t}\n\telse if (91.00 < g){\n\t\tprintf(\"heavy\\n\");\n\t}\n\t\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double w;\n    \n    while (scanf(\"%lf\", &w) != EOF) {\n        if (w <= 48.00) {\n            printf(\"light fly\\n\");\n        } else if (w <= 51.00) {\n            printf(\"fly\\n\");\n        } else if (w <= 54.00) {\n            printf(\"bantam\\n\");\n        } else if (w <= 57.00) {\n            printf(\"feather\\n\");\n        } else if (w <= 60.00) {\n            printf(\"light\\n\");\n        } else if (w <= 64.00) {\n            printf(\"light welter\\n\");\n        } else if (w <= 69.00) {\n            printf(\"welter\\n\");\n        } else if (w <= 75.00) {\n            printf(\"light middle\\n\");\n        } else if (w <= 81.00) {\n            printf(\"middle\\n\");\n        } else if (w <= 91.00) {\n            printf(\"light heavy\\n\");\n        } else {\n            printf(\"heavy\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double w; while (scanf(\"%lf\", &w) != EOF) { if (w <= 48.00) { printf(\"light fly\\n\"); } else if (w <= 51.00) { printf(\"fly\\n\"); } else if (w <= 54.00) { printf(\"bantam\\n\");  (w <= 64.00) { printf(\"light welter\\n\"); } else if (w <= 69.00)  } else if (w <=  return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { float g; scanf(\"%f\", &g); if (g <= 48.00){ printf(\"light fly\\n\"); } else if ((48.00 < g)&&(g <=  printf(\"light welter\\n\");  else if ((69.00 < g)&&(g <= 75.00)){ printf(\"light middle\\n\"); } else if ((75.00 < g)&&(g <= 81.00)){ printf(\"middle\\n\"); } else if ((81.00 < g)&&(g <= 91.00)){ printf(\"light heavy\\n\"); } else if (91.00 < g){ printf(\"heavy\\n\"); } return (0); }"], "original_ll": -0.4703882932662964, "sampled_ll": -0.47650888562202454, "all_perturbed_sampled_ll": [-1.2680633068084717], "all_perturbed_original_ll": [-1.0921874046325684], "perturbed_sampled_ll": -1.2680633068084717, "perturbed_original_ll": -1.0921874046325684, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str;\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\twhile((str=br.readLine())!=null){\n\t\t\tlist.add(check(Double.parseDouble(str)));\n\t\t}\n\t\tfor(String d : list){\n\t\t\tSystem.out.println(d);\n\t\t}\n\t\t\n\t}\n\tpublic static String check(double weight){\n\t\tif(weight > 91.0){\n            return \"heavy\";\n        }\n        else if(weight > 81.0){\n            return \"light heavy\";\n        }\n        else if(weight > 75.0){\n            return \"middle\";\n        }\n        else if(weight > 69.0){\n            return \"light middle\";\n        }\n        else if(weight > 64.0){\n            return \"welter\";\n        }\n        else if(weight > 60.0){\n            return \"light welter\";\n        }\n        else if(weight > 57.0){\n            return \"light\";\n        }\n        else if(weight > 54.0){\n            return \"feather\";\n        }\n        else if(weight > 51.0){\n            return \"bantam\";\n        }\n        else if(weight > 48.0){\n            return \"fly\";\n        }\n        else{\n            return \"light fly\";\n        }\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double w = sc.nextDouble();\n            \n            if (w <= 48.00) {\n                System.out.println(\"light fly\");\n            } else if (w <= 51.00) {\n                System.out.println(\"fly\");\n            } else if (w <= 54.00) {\n                System.out.println(\"bantam\");\n            } else if (w <= 57.00) {\n                System.out.println(\"feather\");\n            } else if (w <= 60.00) {\n                System.out.println(\"light\");\n            } else if (w <= 64.00) {\n                System.out.println(\"light welter\");\n            } else if (w <= 69.00) {\n                System.out.println(\"welter\");\n            } else if (w <= 75.00) {\n                System.out.println(\"light middle\");\n            } else if (w <= 81.00) {\n                System.out.println(\"middle\");\n            } else if (w <= 91.00) {\n                System.out.println(\"light heavy\");\n            } else {\n                System.out.println(\"heavy\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public  while  { System.out.println(\"fly\"); } else if  57.00) { System.out.println(\"feather\"); } else if (w <= 60.00) { System.out.println(\"light\"); } else if (w <= 64.00) { System.out.println(\"light welter\"); } else if (w <= 69.00) { System.out.println(\"welter\"); } else if (w <= 75.00) { System.out.println(\"light middle\");  if (w <= 91.00) { System.out.println(\"light heavy\"); } else { System.out.println(\"heavy\"); } } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import   list = new ArrayList<String>(); while((str=br.readLine())!=null){ list.add(check(Double.parseDouble(str))); } for(String d : list){ System.out.println(d); } } public  else if(weight > 81.0){ return \"light heavy\"; } else if(weight > 75.0){ return \"middle\"; } else if(weight > 69.0){ return \"light middle\"; } else if(weight > 64.0){ return \"welter\"; } else if(weight > 60.0){ return \"light welter\"; } else  }  fly\"; } } }"], "original_ll": -0.6428366303443909, "sampled_ll": -0.4415828585624695, "all_perturbed_sampled_ll": [-1.53944993019104], "all_perturbed_original_ll": [-1.820059061050415], "perturbed_sampled_ll": -1.53944993019104, "perturbed_original_ll": -1.820059061050415, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from decimal import Decimal\nimport sys\n\ndef classify(w):\n    if w <= Decimal(\"48.00\"):\n        return \"light fly\"\n    elif Decimal(\"48.00\") < w <= Decimal(\"51.00\"):\n        return \"fly\"\n    elif Decimal(\"51.00\") < w <= Decimal(\"54.00\"):\n        return \"bantam\"\n    elif Decimal(\"54.00\") < w <= Decimal(\"57.00\"):\n        return \"feather\"\n    elif Decimal(\"57.00\") < w <= Decimal(\"60.00\"):\n        return \"light\"\n    elif Decimal(\"60.00\") < w <= Decimal(\"64.00\"):\n        return \"light welter\"\n    elif Decimal(\"64.00\") < w <= Decimal(\"69.00\"):\n        return \"welter\"\n    elif Decimal(\"69.00\") < w <= Decimal(\"75.00\"):\n        return \"light middle\"\n    elif Decimal(\"75.00\") < w <= Decimal(\"81.00\"):\n        return \"middle\"\n    elif Decimal(\"81.00\") < w <= Decimal(\"91.00\"):\n        return \"light heavy\"\n    else:\n        return \"heavy\"\n    \n[print(classify(Decimal(j))) for j in [i for i in sys.stdin]]\n\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    w = float(line.strip())\n    \n    if w <= 48.00:\n        print(\"light fly\")\n    elif w <= 51.00:\n        print(\"fly\")\n    elif w <= 54.00:\n        print(\"bantam\")\n    elif w <= 57.00:\n        print(\"feather\")\n    elif w <= 60.00:\n        print(\"light\")\n    elif w <= 64.00:\n        print(\"light welter\")\n    elif w <= 69.00:\n        print(\"welter\")\n    elif w <= 75.00:\n        print(\"light middle\")\n    elif w <= 81.00:\n        print(\"middle\")\n    elif w <= 91.00:\n        print(\"light heavy\")\n    else:\n        print(\"heavy\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: w = float(line.strip()) if w <= 48.00: print(\"light fly\") elif w  <= 57.00: print(\"feather\") elif w <=   w <= 81.00: print(\"middle\") elif w <= 91.00: print(\"light heavy\") else: print(\"heavy\")"], "perturbed_original": ["from decimal   \"fly\" elif Decimal(\"51.00\") < w <= Decimal(\"54.00\"): return \"bantam\" elif Decimal(\"54.00\") < w <= Decimal(\"57.00\"): return \"feather\" elif Decimal(\"57.00\") < w <= Decimal(\"60.00\"): return \"light\"  < w <= Decimal(\"75.00\"): return \"light middle\" elif Decimal(\"75.00\") < w <= Decimal(\"81.00\"): return  else: return \"heavy\" [print(classify(Decimal(j))) for j in [i for i in sys.stdin]]"], "original_ll": -0.584625780582428, "sampled_ll": -0.668548583984375, "all_perturbed_sampled_ll": [-1.8212451934814453], "all_perturbed_original_ll": [-1.6750495433807373], "perturbed_sampled_ll": -1.8212451934814453, "perturbed_original_ll": -1.6750495433807373, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol0 0049: Blood Groups\n// 2017.7.29\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar *gets(char *);\n\n#define MAX 50\n\nint blood[MAX + 5];\nint cnt[5];\n\nint main()\n{\n\tchar buf[100], *p;\n\tint k, t;\n\n\tfor (k = 0; k <= MAX; k++) blood[k] = 0;\n\tfor (k = 1; k < 5; k++) cnt[k] = 0;\n\twhile (gets(buf) != NULL) {\n\t\tp = buf;\n\n\t\twhile (isspace(*p)) p++;\n\t\tk = *p++ - '0';\n\t\tif (isdigit(*p)) k = k * 10 + (*p++ - '0');\n\n\t\twhile (isspace(*p)) p++;  // ','\n\t\tp++;\n\n\t\twhile (isspace(*p)) p++;\n\t\tif (*p == 'A' && *(p + 1) == 'B') t = 3;\n\t\telse if (*p == 'B') t = 2;\n\t\telse if (*p == 'O') t = 4;\n\t\telse t = 1;\n\n\t\tif (blood[k] == 0) {\n\t\t\tblood[k] = t;\n\t\t\tcnt[t]++;\n\t\t} else if (blood[k] != t) while (1);\n\t}\n\tfor (k = 1; k < 5; k++) printf(\"%d\\n\", cnt[k]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int num;\n    char blood[10];\n    int countA = 0, countB = 0, countAB = 0, countO = 0;\n    \n    while (scanf(\"%d,%s\", &num, blood) == 2) {\n        if (strcmp(blood, \"A\") == 0) {\n            countA++;\n        } else if (strcmp(blood, \"B\") == 0) {\n            countB++;\n        } else if (strcmp(blood, \"AB\") == 0) {\n            countAB++;\n        } else if (strcmp(blood, \"O\") == 0) {\n            countO++;\n        }\n    }\n    \n    printf(\"%d\\n\", countA);\n    printf(\"%d\\n\", countB);\n    printf(\"%d\\n\", countAB);\n    printf(\"%d\\n\", countO);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int num; char blood[10]; int <extra_id_12>++; } = 0; while (scanf(\"%d,%s\", &num, blood) ==  else if (strcmp(blood, \"B\") == 0) { countB++; } else if (strcmp(blood, \"AB\") == 0) { countAB++; } else if (strcmp(blood, \"O\") == 0) {  countO); return 0; }"], "perturbed_original": ["// Aizu Vol0 0049: Blood Groups // 2017.7.29 #include <stdio.h> #include <stdlib.h>  + 5]; int cnt[5]; int  = 0; k <= MAX; k++) blood[k] = 0; for  (isspace(*p)) p++; k = *p++ - '0';  '0'); while (isspace(*p)) p++; // ',' p++; while (isspace(*p)) p++; if (*p == 'A' && *(p + 1) == 'B')  2; else if (*p == 'O') t = 4; else t = 1; if (blood[k] == 0) { blood[k] = t; cnt[t]++; } else if (blood[k]  < 5; k++) printf(\"%d\\n\", cnt[k]); return 0; }"], "original_ll": -1.0128161907196045, "sampled_ll": -0.3804785907268524, "all_perturbed_sampled_ll": [-1.7800959348678589], "all_perturbed_original_ll": [-2.0536537170410156], "perturbed_sampled_ll": -1.7800959348678589, "perturbed_original_ll": -2.0536537170410156, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint[] abo = {0,0,0,0};\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString tmp = null;\n\t\tint cup = 0;\n\t\tint mun = 0;\n\t\tint ter = 0;\n\t\tString[] rrr;\n\t\tint st = 0,sr = 0;\n\t\tint mon = 0;\n\t\tint syo=0,hisi=0;\n\t\t\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\ttry {\n\t\t\t\ttmp = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp == null){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp.equals(\"\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trrr = tmp.split(\",\");\n\t\t\t\n\t\t\tif(rrr[1].equals(\"A\")){\n\t\t\t\tabo[0]++;\n\t\t\t}else if(rrr[1].equals(\"B\")){\n\t\t\t\tabo[1]++;\n\t\t\t}else if(rrr[1].equals(\"AB\")){\n\t\t\t\tabo[2]++;\n\t\t\t}else if(rrr[1].equals(\"O\")){\n\t\t\t\tabo[3]++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(abo[0]);\n\t\tSystem.out.println(abo[1]);\n\t\tSystem.out.println(abo[2]);\n\t\tSystem.out.println(abo[3]);\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int countA = 0;\n        int countB = 0;\n        int countAB = 0;\n        int countO = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            String bloodType = parts[1];\n            \n            switch (bloodType) {\n                case \"A\":\n                    countA++;\n                    break;\n                case \"B\":\n                    countB++;\n                    break;\n                case \"AB\":\n                    countAB++;\n                    break;\n                case \"O\":\n                    countO++;\n                    break;\n            }\n        }\n        \n        System.out.println(countA);\n        System.out.println(countB);\n        System.out.println(countAB);\n        System.out.println(countO);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int countA = 0; int countB  break;  { case \"A\": countA++; break; case \"B\": countB++; break; case \"AB\": countAB++; break; case \"O\": countO++; break; } } System.out.println(countA); System.out.println(countB); System.out.println(countAB); System.out.println(countO); sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void <extra_id_1>{<extra_id_2>int cdown<extra_id_3>= 0 ; mun<extra_id_4>; mun<extra_id_5>int<extra_id_6>= 1<extra_id_7>; mun += 1 ;<extra_id_8>; mun += 1<extra_id_9>;<extra_id_10>mun += 1<extra_id_11>;<extra_id_12>} catch (<extra_id_13>\" \" ;<extra_id_14>= 1<extra_id_15>mun == 1 ; if<extra_id_16>\" \"<extra_id_17>if ( temp !=<extra_id_18>) {<extra_id_19>(<extra_id_20>.<extra_id_21>+= 3 ; mun ++<extra_id_22>(<extra_id_23>} } public static<extra_id_24>{ BufferedReader(new InputStreamReader(System.in)); String tmp = null; int cup = 0; int mun = 0; int  0; int mon = 0; int syo=0,hisi=0; while(true){ try {  \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af e.printStackTrace(); } if(tmp ==  abo[3]++; } } System.out.println(abo[0]); System.out.println(abo[1]); System.out.println(abo[2]); System.out.println(abo[3]); } }"], "original_ll": -0.8218650221824646, "sampled_ll": -0.4313839375972748, "all_perturbed_sampled_ll": [-1.008349061012268], "all_perturbed_original_ll": [-2.0374724864959717], "perturbed_sampled_ll": -1.008349061012268, "perturbed_original_ll": -2.0374724864959717, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\na = 0\nb = 0\nab = 0\no = 0\nfor i in sys.stdin.readlines():\n    if i.find(\",AB\") > -1:\n        ab += 1\n    elif i.find(\",B\") > -1:\n        b += 1\n    elif i.find(\",A\") >-1:\n        a += 1\n    else:\n        o += 1\nprint(a)\nprint(b)\nprint(ab)\nprint(o)", "sampled": "import sys\n\ncount = {'A': 0, 'B': 0, 'AB': 0, 'O': 0}\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        parts = line.split(',')\n        blood_type = parts[1]\n        count[blood_type] += 1\n\nprint(count['A'])\nprint(count['B'])\nprint(count['AB'])\nprint(count['O'])\n", "perturbed_sampled": ["import sys count = {'A': 0, 'B': 0, 'AB': 0, 'O': 0} for line  blood_type = parts[1] count[blood_type] += 1 print(count['A']) print(count['B']) print(count['AB']) print(count['O'])"], "perturbed_original": ["import sys a = 0 b = 0  > -1: b += 1 elif i.find(\",A\") >-1: a += 1 else: o += 1 print(a) print(b) print(ab) print(o)"], "original_ll": -0.9827123284339905, "sampled_ll": -0.773705244064331, "all_perturbed_sampled_ll": [-1.5630521774291992], "all_perturbed_original_ll": [-3.0052764415740967], "perturbed_sampled_ll": -1.5630521774291992, "perturbed_original_ll": -3.0052764415740967, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void){\n\tchar text[1002],i,n;\n\tfgets(text,1002,stdin);\n\tn=strlen(text);\n\tfor(i=0;i<n-5;i++){\n\t\tif(text[i]=='a' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){\n\t\t\ttext[i]='p';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h';\n\t\t}\n\t\telse if(text[i]=='p' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){\n\t\t\ttext[i]='a';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e';\n\t\t}\n\t\tif(text[i]=='A' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){\n\t\t\ttext[i]='P';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h';\n\t\t}\n\t\telse if(text[i]=='P' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){\n\t\t\ttext[i]='A';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e';\n\t\t}\n\t}\n\tprintf(\"%s\",text);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[1001];\n    char result[10001];\n    int i, j;\n    \n    fgets(line, sizeof(line), stdin);\n    \n    i = 0;\n    j = 0;\n    while (line[i] != '\\0' && line[i] != '\\n') {\n        if (strncmp(&line[i], \"apple\", 5) == 0) {\n            strcpy(&result[j], \"peach\");\n            j += 5;\n            i += 5;\n        } else if (strncmp(&line[i], \"peach\", 5) == 0) {\n            strcpy(&result[j], \"apple\");\n            j += 5;\n            i += 5;\n        } else {\n            result[j] = line[i];\n            j++;\n            i++;\n        }\n    }\n    result[j] = '\\0';\n    \n    printf(\"%s\\n\", result);\n    \n    return 0;\n}\n", "perturbed_sampled": [" result[10001]; int i, j; fgets(line, sizeof(line), stdin); i = 0; j = 0; while (line[i] != '\\0' && line[i] != '\\n') { if (strncmp(&line[i], \"apple\", 5) == 0) { strcpy(&result[j], \"peach\");  \"peach\",  += 5;  result[j] = '\\0'; printf(\"%s\\n\", result); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(void){ char text[1002],i,n; fgets(text,1002,stdin); n=strlen(text); for(i=0;i<n-5;i++){ if(text[i]=='a' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){ text[i]='p';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h'; } else if(text[i]=='p' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' &&  return 0; }"], "original_ll": -0.3317855894565582, "sampled_ll": -0.4642769992351532, "all_perturbed_sampled_ll": [-1.4428244829177856], "all_perturbed_original_ll": [-0.8881732225418091], "perturbed_sampled_ll": -1.4428244829177856, "perturbed_original_ll": -0.8881732225418091, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tStringBuilder ans = new StringBuilder();\n\t\twhile(in.hasNext()) {\n\t\t\tString x = in.next();\n\t\t\tif(x.contains(\"apple\"))\n\t\t\t\tans.append(x.replace(\"apple\",\"peach\")).append(\" \");\n\t\t\telse if(x.contains(\"peach\"))\n\t\t\t\tans.append(x.replace(\"peach\",\"apple\")).append(\" \");\n\t\t\telse\n\t\t\t\tans.append(x).append(\" \");\n\t\t}\n\t\tSystem.out.println(ans.toString().trim());\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        \n        String result = line.replace(\"apple\", \"TEMP\")\n                           .replace(\"peach\", \"apple\")\n                           .replace(\"TEMP\", \"peach\");\n        \n        System.out.println(result);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) {  result = line.replace(\"apple\", \"TEMP\") .replace(\"peach\", \"apple\") .replace(\"TEMP\", \"peach\"); System.out.println(result); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); StringBuilder ans  } System.out.println(ans.toString().trim()); } }"], "original_ll": -0.6974615454673767, "sampled_ll": -1.0439963340759277, "all_perturbed_sampled_ll": [-2.183347463607788], "all_perturbed_original_ll": [-2.0549697875976562], "perturbed_sampled_ll": -2.183347463607788, "perturbed_original_ll": -2.0549697875976562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nsent = map(str, raw_input().split(' '))\n\nfor i in range(len(sent)):\n    if sent[i] == 'apple' :\n        sent[i] = 'peach'\n    elif sent[i] == 'peach':\n        sent[i] = 'apple'\n\n    elif sent[i] == 'apple,' :\n        sent[i] = 'peach,'\n    elif sent[i] == 'peach,':\n        sent[i] = 'apple,'\n\n    elif sent[i] == 'apple.' :\n        sent[i] = 'peach.'\n    elif sent[i] == 'peach.':\n        sent[i] = 'apple.'\n\n    elif sent[i] == 'apple!' :\n        sent[i] = 'peach!'\n    elif sent[i] == 'peach!':\n        sent[i] = 'apple!'\n\n    elif sent[i] == 'apple?' :\n        sent[i] = 'peach?'\n    elif sent[i] == 'peach?':\n        sent[i] = 'apple?'\n\n \n\n\n\nfor sen in sent:\n    print sen,\n    ", "sampled": "s = input()\ns = s.replace('apple', '@TEMP@').replace('peach', 'apple').replace('@TEMP@', 'peach')\nprint(s)\n", "perturbed_sampled": ["s = input() s = s.replace('apple', '@TEMP@').replace('peach', 'apple').replace('@TEMP@', 'peach') print(s)"], "perturbed_original": ["sent = map(str, raw_input().split(' ')) for i in range(len(sent)): if sent[i] == 'apple' : sent[i] = 'peach' elif sent[i] == 'peach': sent[i] = 'apple' elif sent[i]  sent[i] = 'apple,' elif sent[i] == 'apple.' : sent[i] = 'peach.' elif sent[i] == 'peach.': sent[i] = 'apple.' elif sent[i] ==  'peach?' elif  print sen,"], "original_ll": -0.6185399293899536, "sampled_ll": -2.121476888656616, "all_perturbed_sampled_ll": [-2.281001329421997], "all_perturbed_original_ll": [-1.58112370967865], "perturbed_sampled_ll": -2.281001329421997, "perturbed_original_ll": -1.58112370967865, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  long a,b,i,n;\n\n  while(scanf(\"%ld\",&n),n!=0){\n    a=0;\n    for(i=5;i<=n;i++){\n      b=i;\n      while(b>0){\n        if(b%5!=0) break;\n        a++;\n        b=b/5;\n      }\n    }\n    printf(\"%ld\\n\",a);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int count = 0;\n        int temp = n;\n        \n        while(temp >= 5) {\n            temp /= 5;\n            count += temp;\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) {  int temp =  temp; } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ long  } } printf(\"%ld\\n\",a); } return 0; }"], "original_ll": -1.029948115348816, "sampled_ll": -0.6297503709793091, "all_perturbed_sampled_ll": [-2.5829856395721436], "all_perturbed_original_ll": [-3.1471011638641357], "perturbed_sampled_ll": -2.5829856395721436, "perturbed_original_ll": -3.1471011638641357, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Scanner;\npublic class Main {\n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakePrimeList();\n\t\twhile(true) {\n\t\t\tint a = stdIn.nextInt();\n\t\t\tif(a == 0) break;\n\t\t\tint c2 = 0;\n\t\t\tint c5 = 0;\n\t\t\tfor(int i = a; i >= 1; i--) {\n\t\t\t\tint[] ret = f(i);\n\t\t\t\tc2 += ret[0];\n\t\t\t\tc5 += ret[2];\n\t\t\t}\n\t\t\tint count = Math.min(c2, c5);\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tpublic static void makePrimeList() {\n\t\tboolean[] isntPrime = new boolean[20001];\n\t\tisntPrime[0] = isntPrime[1] = true;\n\t\tlist.add(2);\n\t\tfor(int i = 3; i < 20001; i+= 2) {\n\t\t\tif(!isntPrime[i]) {\n\t\t\t\tlist.add(i);\n\t\t\t\tfor(int j = i + i; j < 20001; j+= i) {\n\t\t\t\t\tisntPrime[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int[] f(int a) {\n\t\tint[] ret = new int[list.size()];\n\t\twhile(a > 1) {\n\t\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\t\tif(a % list.get(i) == 0) {\n\t\t\t\t\ta /= list.get(i);\n\t\t\t\t\tret[i]++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\t\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            int temp = n;\n            while (temp > 0) {\n                temp /= 5;\n                count += temp;\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  = new Scanner(System.in); while  break; int count = 0; int temp = n; while (temp > 0) { temp /= 5; count += temp; } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.io.*; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.Scanner; public class Main { static ArrayList<Integer> list = new ArrayList<Integer>(); public static void main(String[] args) { Scanner stdIn = new Scanner(System.in);  break; int c2 = 0; int c5 = 0; for(int i = a; i >= 1; i--) {  } int  makePrimeList() { boolean[] isntPrime =  { list.add(i); for(int j = i +  } } } } public static int[] f(int a) { int[] ret = new int[list.size()]; while(a   list.get(i); ret[i]++; } } } return ret; } }"], "original_ll": -0.6294464468955994, "sampled_ll": -0.47968900203704834, "all_perturbed_sampled_ll": [-1.9242342710494995], "all_perturbed_original_ll": [-1.918015480041504], "perturbed_sampled_ll": -1.9242342710494995, "perturbed_original_ll": -1.918015480041504, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f(n):\n    for i in range(1,n):\n        n*=i\n    return n\n        \n        \nwhile True:\n    n=int(input())\n    if n==0:\n        break\n    else:\n        a=str(f(n))\n        s=0\n        l=len(a)\n        for i in range(l-1,-1,-1):\n            if a[i]==\"0\":\n                s+=1\n            else:\n                break\n        print(s)\n", "sampled": "import sys\n\ndef count_trailing_zeros(n):\n    count = 0\n    power_of_5 = 5\n    while power_of_5 <= n:\n        count += n // power_of_5\n        power_of_5 *= 5\n    return count\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    if n == 0:\n        break\n    print(count_trailing_zeros(n))\n", "perturbed_sampled": ["import sys def count_trailing_zeros(n): count = 0  // power_of_5 power_of_5 *= 5 return count for line in sys.stdin: n = int(line.strip()) if n == 0: break print(count_trailing_zeros(n))"], "perturbed_original": ["def f(n): for i in range(1,n): n*=i return n while True: n=int(input()) if n==0:  a[i]==\"0\": s+=1 else: break print(s)"], "original_ll": -0.9292617440223694, "sampled_ll": -0.5974042415618896, "all_perturbed_sampled_ll": [-2.2976925373077393], "all_perturbed_original_ll": [-2.4325711727142334], "perturbed_sampled_ll": -2.2976925373077393, "perturbed_original_ll": -2.4325711727142334, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\n\nint main()\n{\n\tint n=0,d,sw;\n\tlong int i,j,k,s[1000],sum;\n\n\twhile(1)\n\t{\n\t\tn=1;\n\t\tsum=0;\n\t\tscanf(\"%d\",&d);\n\t\tif(!d)\n\t\t\tbreak;\n\t\ts[0]=2;\n\t\ts[1]=3;\n\t\tif(d<=2)\n\t\t{\n\t\t\tfor(i=0;i<d;i++)\n\t\t\t\tsum+=s[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum=5;\n\t\t\tfor(i=5;;i+=2)\n\t\t\t{\n\t\t\t\tsw=0;\n\t\t\t\tk=(long int)sqrt((double)i);\n\t\t\t\tfor(j=0;s[j]<=k;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i%s[j]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsw=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!sw)\n\t\t\t\t{\n\t\t\t\t\tn++;\n\t\t\t\t\tif(n<1000)\n\t\t\t\t\t\ts[n]=i;\n\t\t\t\t\tsum+=i;\n\t\t\t\t\tif(n==d-1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 10000\n#define MAX_PRIME 104730\n\nint is_prime[MAX_PRIME + 1];\nint primes[MAX_N];\nint prime_count = 0;\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i <= MAX_PRIME; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= MAX_PRIME; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n    \n    for (int i = 2; i <= MAX_PRIME && prime_count < MAX_N; i++) {\n        if (is_prime[i]) {\n            primes[prime_count++] = i;\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += primes[i];\n        }\n        printf(\"%lld\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  is_prime[MAX_PRIME + 1]; int primes[MAX_N]; int prime_count = 0; void sieve() { memset(is_prime, 1, sizeof(is_prime)); is_prime[0] = is_prime[1] = 0; for (int i = 2; i * i <= MAX_PRIME; i++) { if  <=  } for (int i = 2; i <=  primes[prime_count++] =  { long long sum = 0; for (int i = 0; i < n; i++) { sum += primes[i]; } printf(\"%lld\\n\", sum); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h> int main()  scanf(\"%d\",&d); if(!d) break; s[0]=2; s[1]=3; if(d<=2) { for(i=0;i<d;i++) sum+=s[i]; } else { sum=5; for(i=5;;i+=2) { sw=0; k=(long int)sqrt((double)i);  n++; if(n<1000) s[n]=i; sum+=i; if(n==d-1) break; } } } printf(\"%d\\n\",sum); } return 0; }"], "original_ll": -0.8601018190383911, "sampled_ll": -0.3442285656929016, "all_perturbed_sampled_ll": [-1.3849880695343018], "all_perturbed_original_ll": [-1.8474490642547607], "perturbed_sampled_ll": -1.3849880695343018, "perturbed_original_ll": -1.8474490642547607, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main{\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\tint[] p = new int[1000000];\n\tsetP(p);\n\twhile(kbd.hasNext()){\n\t    int n = kbd.nextInt();\n\t    if(n!=0) solve(p, n);\n\t}\n    }\n\n    static void solve(int[] p, int n){\n\tint sum=0, i;\n\tfor(i=0; p[i]<=n; i++){\n\t    if(p[i]!=-1) {\n\t\tsum+=i;\n\t\t//System.out.println(i);\n\t    }\n\t}\n\n\tSystem.out.println(sum);\n    }\n\n    static void setP(int[] p){\n\tint a=1, i, j;\n\tArrays.fill(p, 1);\n\tp[0] = -1;\n\tp[1] = -1;\n\tfor(i=2; i<p.length; i++){\n\t    if(p[i] == 1){\n\t\t//System.out.println(i+\" \"+a);\n\t\tp[i] = a;\n\t\ta++;\t\n\t    }\n\t    for(j=i+i; j<p.length; j+=i){\n\t\tp[j] = -1;\n\t    }\n\t}\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Pre-calculate primes up to a reasonable limit\n        // For n=10000, we need the 10000th prime\n        // The 10000th prime is approximately 104729\n        int limit = 110000;\n        boolean[] isPrime = new boolean[limit];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        // Sieve of Eratosthenes\n        for (int i = 2; i * i < limit; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < limit; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        // Collect primes in order\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < limit; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        // Pre-calculate cumulative sums\n        long[] cumulativeSum = new long[primes.size() + 1];\n        for (int i = 0; i < primes.size(); i++) {\n            cumulativeSum[i + 1] = cumulativeSum[i] + primes.get(i);\n        }\n        \n        // Process queries\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            System.out.println(cumulativeSum[n]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  sc = new Scanner(System.in); // Pre-calculate primes up to a reasonable limit // For n=10000, we  104729 int limit = 110000; boolean[] isPrime = new boolean[limit];  Eratosthenes for (int i = 2; i * i < limit; i++) { if (isPrime[i]) { for (int j = i  = false; } } } // Collect primes in order List<Integer>  long[primes.size() + 1]; for (int i = 0; i  primes.get(i); } // Process queries while (true) { int n = sc.nextInt(); if (n == 0) break; System.out.println(cumulativeSum[n]); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ static Scanner kbd = new Scanner(System.in); public static void main(String[] args){ int[] p = new int[1000000]; setP(p); while(kbd.hasNext()){ int n = kbd.nextInt(); if(n!=0) solve(p,  sum=0, i; for(i=0; p[i]<=n; i++){ if(p[i]!=-1) { sum+=i; //System.out.println(i); } } System.out.println(sum); } static void setP(int[] p){ int a=1, i, j;   } }"], "original_ll": -0.8661919236183167, "sampled_ll": -0.4598054885864258, "all_perturbed_sampled_ll": [-1.757880449295044], "all_perturbed_original_ll": [-1.7817963361740112], "perturbed_sampled_ll": -1.757880449295044, "perturbed_original_ll": -1.7817963361740112, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import *\nn=range(104730);a=list(n)\nfor i in range(2,321):a[i*2::i]=[0]*len(a[i*2::i])\np=list(compress(n,a))\nfor e in iter(input,'0'):print(sum(p[:int(e)+1])-1)\n", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    primes = [i for i in range(2, limit + 1) if is_prime[i]]\n    return primes\n\n# Pre-compute primes up to a sufficient limit\n# For n=10000, we need the 10000th prime\n# The 10000th prime is 104729\nprimes = sieve_of_eratosthenes(105000)\n\n# Pre-compute cumulative sums\ncumsum = [0]\nfor prime in primes:\n    cumsum.append(cumsum[-1] + prime)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(cumsum[n])\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(limit**0.5) +  i): is_prime[j] = False primes  prime # The 10000th prime is 104729 primes = sieve_of_eratosthenes(105000) # Pre-compute cumulative sums cumsum = [0] for prime in primes: cumsum.append(cumsum[-1] + prime) while True: n = int(input()) if n == 0: break print(cumsum[n])"], "perturbed_original": ["from itertools import * n=range(104730);a=list(n) for i in range(2,321):a[i*2::i]=[0]*len(a[i*2::i]) p=list(compress(n,a)) for e in iter(input,'0'):print(sum(p[:int(e)+1])-1)"], "original_ll": -2.4989681243896484, "sampled_ll": -0.6432137489318848, "all_perturbed_sampled_ll": [-1.3022407293319702], "all_perturbed_original_ll": [-2.621738910675049], "perturbed_sampled_ll": -1.3022407293319702, "perturbed_original_ll": -2.621738910675049, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void) {\n\tint a,b,n;\n\tint sum;\n\tint i,j;\n\twhile(1) {\n\t\tif(scanf(\"%d %d %d\",&a,&b,&n)==-1)break;\n\t\ta-=a/b*b;\n\t\tsum=0;\n\t\tfor(i=1;i<=n;i++) {\n\t\t\ta*=10;\n\t\t\tfor(j=9;j>=0;j--) {\n\t\t\t\tif(b*j<=a)break;\n\t\t\t}\n\t\t\ta-=b*j;\n\t\t\tsum+=j;\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a, b, n;\n    \n    while (scanf(\"%d %d %d\", &a, &b, &n) == 3) {\n        int sum = 0;\n        int remainder = a % b;\n        \n        for (int i = 0; i < n; i++) {\n            remainder *= 10;\n            int digit = remainder / b;\n            sum += digit;\n            remainder = remainder % b;\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  %d\", &a, &b, &n) == 3)  i++) { remainder *= 10; int digit = remainder / b; sum += digit; remainder = remainder % b; } printf(\"%d\\n\", sum); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int a,b,n; int sum; int i,j; while(1) { if(scanf(\"%d %d %d\",&a,&b,&n)==-1)break; a-=a/b*b; sum=0;  printf(\"%d\\n\",sum); } return 0; }"], "original_ll": -1.0060502290725708, "sampled_ll": -0.5422503352165222, "all_perturbed_sampled_ll": [-2.1797001361846924], "all_perturbed_original_ll": [-1.7264235019683838], "perturbed_sampled_ll": -2.1797001361846924, "perturbed_original_ll": -1.7264235019683838, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main{\n\tMain(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tint n = sc.nextInt();\n\t\t\tint s = 0;\n\t\t\tString str = Double.toString((a/b)) + \"0000000000\";\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\ts += Integer.parseInt(str.substring(i+2, i+3));\n\t\t\t}\n\t\t\tSystem.out.println(Integer.toString(s));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int n = sc.nextInt();\n            \n            int sum = 0;\n            int remainder = a % b;\n            \n            for (int i = 0; i < n; i++) {\n                remainder *= 10;\n                int digit = remainder / b;\n                sum += digit;\n                remainder = remainder % b;\n            }\n            \n            System.out.println(sum);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int a = sc.nextInt(); int b = sc.nextInt(); int n = sc.nextInt(); int sum = 0; int remainder = a % b; for (int i = 0; i < n; i++) { remainder  sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main{ Main(){ Scanner sc = new Scanner(System.in); while(sc.hasNext()){ double a = sc.nextDouble(); double b = sc.nextDouble(); int n = sc.nextInt(); int s = 0; String str = Double.toString((a/b)) + \"0000000000\"; for(int i =  System.out.println(Integer.toString(s));  }"], "original_ll": -0.9605746269226074, "sampled_ll": -0.5062127113342285, "all_perturbed_sampled_ll": [-1.3777536153793335], "all_perturbed_original_ll": [-1.7824163436889648], "perturbed_sampled_ll": -1.3777536153793335, "perturbed_original_ll": -1.7824163436889648, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "t=10**9\nwhile 1:\n    try:\n        a,b,n=map(int,raw_input().split())\n        if b==0:\n            print 0\n            continue\n        f=a*t/b\n        f=str(f%t)\n        ans=0\n        for i in range(n):\n            ans+=int(f[i])\n        print ans\n    except:\n        break", "sampled": "import sys\n\nfor line in sys.stdin:\n    a, b, n = map(int, line.split())\n    s = 0\n    remainder = a % b\n    \n    for i in range(n):\n        remainder *= 10\n        digit = remainder // b\n        s += digit\n        remainder = remainder % b\n    \n    print(s)\n", "perturbed_sampled": ["import sys for line in sys.stdin: a, b, n  b for i in range(n): remainder *= 10 digit = remainder  print(s)"], "perturbed_original": ["t=10**9 while  ans=0 for i in range(n): ans+=int(f[i]) print ans except: break"], "original_ll": -1.2677586078643799, "sampled_ll": -1.1094900369644165, "all_perturbed_sampled_ll": [-4.016897201538086], "all_perturbed_original_ll": [-3.5411219596862793], "perturbed_sampled_ll": -4.016897201538086, "perturbed_original_ll": -3.5411219596862793, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n  int k;\n  double a[11];\n  double sum;\n  while(scanf(\"%lf\",&a[1])!=EOF){\n    sum = a[1];\n    printf(\"test\");\n    for(k=2;k=10;k++){\n      if(k%2==0){\n        a[k] = a[k-1] * 2;\n      }else{\n        a[k] = a[k-1] / 3;\n      }\n      sum += a[k];\n    }\n    printf(\"%lf\\n\",sum);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double a;\n    while (scanf(\"%lf\", &a) != EOF) {\n        double sum = 0.0;\n        double current = a;\n        \n        for (int i = 1; i <= 10; i++) {\n            sum += current;\n            if (i % 2 == 0) {\n                current = current / 3.0;\n            } else {\n                current = current * 2.0;\n            }\n        }\n        \n        printf(\"%.8lf\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main()  sum = 0.0; double current = a; for (int i = 1;   } else { current = current * 2.0; } } printf(\"%.8lf\\n\", sum); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int k; double a[11]; double sum; while(scanf(\"%lf\",&a[1])!=EOF){ sum = a[1]; printf(\"test\"); for(k=2;k=10;k++){ if(k%2==0){ a[k] = a[k-1]  += a[k]; } printf(\"%lf\\n\",sum); } return 0; }"], "original_ll": -1.1180412769317627, "sampled_ll": -0.6366769671440125, "all_perturbed_sampled_ll": [-2.2235569953918457], "all_perturbed_original_ll": [-1.9594119787216187], "perturbed_sampled_ll": -2.2235569953918457, "perturbed_original_ll": -1.9594119787216187, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n    private static double calculation(double value){\n\tdouble sum = value;\n\tdouble[] values = new double[10];\n\tvalues[0] = value;\n\t\n\tfor(int i = 1; i < 10; ++i){\n\t    if(i%2 == 1){\n\t\tvalues[i] = values[i-1]*2.0;\n\t    } else {\n\t\tvalues[i] = values[i-1]/3.0;\n\t    }\n\t    sum += values[i];\n\t}\n\t\n\n\treturn sum;\n    }\n    \n    public static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\t\n\twhile(sc.hasNext()){\n\t    double value = sc.nextDouble();\n\t    System.out.printf(\"%f\\n\", calculation(value));\n\t}\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double a = sc.nextDouble();\n            double sum = 0;\n            double current = a;\n            \n            for (int i = 1; i <= 10; i++) {\n                sum += current;\n                if (i % 2 == 0) {\n                    current = current / 3.0;\n                } else {\n                    current = current * 2.0;\n                }\n            }\n            \n            System.out.printf(\"%.8f%n\", sum);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[]  double  a; for (int i = 1; i <= 10; i++)  { current = current / 3.0; } else { current = current * 2.0; } } System.out.printf(\"%.8f%n\", sum); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ private static double calculation(double value){ double sum = value; double[] values = new double[10]; values[0] = value; for(int i =  +=  Scanner sc = new Scanner(System.in); while(sc.hasNext()){ double value = sc.nextDouble(); System.out.printf(\"%f\\n\", calculation(value)); } } }"], "original_ll": -0.8571709990501404, "sampled_ll": -0.5965708494186401, "all_perturbed_sampled_ll": [-2.0712778568267822], "all_perturbed_original_ll": [-1.8949532508850098], "perturbed_sampled_ll": -2.0712778568267822, "perturbed_original_ll": -1.8949532508850098, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    try:n=float(input())\n    except:break\n    s=n\n    for i in range(9):\n        n=n/3 if i%2 else n*2\n        s+=n\n    print(s)", "sampled": "import sys\n\nfor line in sys.stdin:\n    a = float(line.strip())\n    \n    terms = [a]\n    for i in range(1, 10):\n        if i % 2 == 1:  # odd index (2nd, 4th, 6th... terms)\n            terms.append(terms[-1] * 2)\n        else:  # even index (3rd, 5th, 7th... terms)\n            terms.append(terms[-1] / 3)\n    \n    s = sum(terms)\n    print(f\"{s:.8f}\")\n", "perturbed_sampled": ["import sys for line in  range(1, 10): if i % 2 == 1: # odd index (2nd, 4th, 6th... terms) terms.append(terms[-1] * 2)  3) s = sum(terms) print(f\"{s:.8f}\")"], "perturbed_original": ["while 1: try:n=float(input()) except:break s=n for i in range(9): n=n/3 if i%2 else n*2 s+=n print(s)"], "original_ll": -1.2127773761749268, "sampled_ll": -0.9472917914390564, "all_perturbed_sampled_ll": [-2.608048439025879], "all_perturbed_original_ll": [-2.029350757598877], "perturbed_sampled_ll": -2.608048439025879, "perturbed_original_ll": -2.029350757598877, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint prime[50001];\nvoid set(void){\n    int i,o;\n    for(i=4;i<=5000;i+=2)\n        prime[i]=1;\n    for(i=3;i*i<=5000;i+=2){\n        if(prime[i]==0)\n            for(o=i*2;o<=5000;o+=i)\n                prime[o]=1;\n    }\n}\nint main(void){\n    int num,count,sum,i,o;\n    set();\n    for(;count=0,scanf(\"%d\",&num),num;){\n        for(i=2;i<=num;i++)\n            if(!prime[i]){\n                if(i>num)\n                     break;\n                for(o=2;o<=num;o++)\n                    if(!prime[o]){\n                        sum=i+o;\n                        if(sum == num){\n                            count++;\n                            break;\n                        }\n                        if(sum > num)\n                            break;\n                    }\n            }\n        printf(\"%d\\n\",count%2?(count/2+1):(count/2));\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 50001\n\nint is_prime[MAX];\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int count = 0;\n        for (int i = 2; i <= n / 2; i++) {\n            if (is_prime[i] && is_prime[n - i]) {\n                count++;\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #define MAX 50001 int is_prime[MAX]; void sieve() { memset(is_prime, 1, sizeof(is_prime)); is_prime[0] = is_prime[1] = 0; for (int i = 2; i  (scanf(\"%d\", &n) == 1 && n != 0)  i <= n / 2; i++) { if (is_prime[i] && is_prime[n - i]) { count++; } } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include <stdio.h> int prime[50001]; void set(void){ int i,o; for(i=4;i<=5000;i+=2) prime[i]=1;  set(); for(;count=0,scanf(\"%d\",&num),num;){  count++; break; } if(sum > num) break; } } printf(\"%d\\n\",count%2?(count/2+1):(count/2)); } return 0; }"], "original_ll": -0.988865852355957, "sampled_ll": -0.31437116861343384, "all_perturbed_sampled_ll": [-1.075740933418274], "all_perturbed_original_ll": [-2.1973748207092285], "perturbed_sampled_ll": -1.075740933418274, "perturbed_original_ll": -2.1973748207092285, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static boolean[] p=new boolean[50000];\n\tpublic static int counter(int n){\n\t\tint c=0,i,j;\n\t\tfor(i=2;i<=n/2;i++){\n\t\t\tif(p[i])\n\t\t\tfor(j=2;i+j<=n;j++){\n\t\t\t\tif(p[j]){\n\t\t\t\t\tif(i+j==n){\n\t\t\t\t\t\tc++;\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}//\n\t\treturn c;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,i,j;\n\t\tArrays.fill(p, true);\n\t\tfor(i=2;i<50000;i++){\n\t\t\tif(p[i])\n\t\t\tfor(j=2;i*j<50000;j++){\n\t\t\t\tp[i*j]=false;\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tSystem.out.println(counter(n));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static boolean[] isPrime;\n    static int MAX = 50001;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Sieve of Eratosthenes\n        isPrime = new boolean[MAX];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i < MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < MAX; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            for (int i = 2; i <= n / 2; i++) {\n                if (isPrime[i] && isPrime[n - i]) {\n                    count++;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static boolean[] isPrime; static int MAX = 50001; public static void main(String[] args) {  = new boolean[MAX]; Arrays.fill(isPrime, true); isPrime[0] =  i < MAX;  * i; j < MAX; j += i) { isPrime[j] = false; } } } while (true) { int n = sc.nextInt(); if (n == 0) break; int count  / 2; i++) { if (isPrime[i] &&  } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class true<extra_id_1>{ foreach<extra_id_2>) if(!s[i] { //<extra_id_3>s[i]);if(s[j]){ if(s[j]==true){ return false;<extra_id_4>c>2){<extra_id_5>//}<extra_id_6>if(s[j+1]==true){ if(s[j+2]==true){ System.err.println(p[j+1].toString());<extra_id_7>} } } } }<extra_id_8>public int counter counter(int n){ int c=0,i,j; for(i=2;i<=n/2;i++){ if(p[i]) for(j=2;i+j<=n;j++){ if(p[j]){ if(i+j==n){ c++; // System.out.println(i+\" \"+j); } } } }// return c; } public static  true);  System.out.println(counter(n)); } } }"], "original_ll": -0.8087391257286072, "sampled_ll": -0.3037806749343872, "all_perturbed_sampled_ll": [-1.5581423044204712], "all_perturbed_original_ll": [-2.4539692401885986], "perturbed_sampled_ll": -1.5581423044204712, "perturbed_original_ll": -2.4539692401885986, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N=50000+1\np=[True]*N\np[0],p[1]=False,False\nfor i in xrange(2,int(N**0.5)+1):\n    if p[i]==True:\n        for j in xrange(i**2,N,i):\n            p[j]=False\nwhile True:\n    n=input()\n    if n==0:break\n    c=0\n    for i in xrange(n/2+1):\n        if p[i] and p[n-i]:c+=1\n    print c", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\nlimit = 50000\nis_prime = sieve_of_eratosthenes(limit)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = 0\n    for i in range(2, n // 2 + 1):\n        if is_prime[i] and is_prime[n - i]:\n            count += 1\n    \n    print(count)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + +=<extra_id_8>1 if not<extra_id_9>.<extra_id_10>else : i = 0<extra_id_11>i : n = n<extra_id_12>return n return n int(limit**0.5) + 1): if is_prime[i]: for j in range(i*i,  = 50000 is_prime = sieve_of_eratosthenes(limit) while  = 0 for i in range(2, n // 2 + 1): if is_prime[i] and is_prime[n - i]: count += 1 print(count)"], "perturbed_original": [" j in xrange(i**2,N,i): p[j]=False while True: n=input() if n==0:break c=0 for i in xrange(n/2+1): if p[i] and p[n-i]:c+=1 print c"], "original_ll": -0.7088199257850647, "sampled_ll": -0.35662907361984253, "all_perturbed_sampled_ll": [-2.1050002574920654], "all_perturbed_original_ll": [-2.0543131828308105], "perturbed_sampled_ll": -2.1050002574920654, "perturbed_original_ll": -2.0543131828308105, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N,main(){while(~scanf(\"%d\",&N))printf(\"%d\\n\",N*(N+1)/2+1);}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) != EOF) {\n        long long result = 1 + (long long)n * (n + 1) / 2;\n        printf(\"%lld\\n\", result);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n;  1 + (long long)n * (n + 1) / 2; printf(\"%lld\\n\", result); } return 0; }"], "perturbed_original": ["N,main(){while(~scanf(\"%d\",&N))printf(\"%d\\n\",N*(N+1)/2+1);}"], "original_ll": -2.0631284713745117, "sampled_ll": -0.7436593770980835, "all_perturbed_sampled_ll": [-2.1027019023895264], "all_perturbed_original_ll": [-2.0631284713745117], "perturbed_sampled_ll": -2.1027019023895264, "perturbed_original_ll": -2.0631284713745117, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n\tScanner s = new Scanner(System.in);\n\tint[] d = new int[10001];\n\td[0]=1;\n\td[1]=2;\n\tfor(int i=2 ; i<10001 ; i++)\n\t    d[i] = d[i-1]+i;\n\twhile(s.hasNext())\n\t    System.out.println(d[s.nextInt()]);\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            long result = (long) n * (n + 1) / 2 + 1;\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[]  int n = sc.nextInt(); long result =  System.out.println(result); } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main { public static  d = new int[10001]; d[0]=1; d[1]=2; for(int i=2 ; i<10001 ; i++) d[i] = d[i-1]+i; while(s.hasNext()) System.out.println(d[s.nextInt()]); } }"], "original_ll": -0.9500241279602051, "sampled_ll": -0.6218088865280151, "all_perturbed_sampled_ll": [-2.7018232345581055], "all_perturbed_original_ll": [-1.5798636674880981], "perturbed_sampled_ll": -2.7018232345581055, "perturbed_original_ll": -1.5798636674880981, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        a = int(input())\n        print(((a * a) + a + 2) / 2)\n    except EOFError:\n        break", "sampled": "import sys\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    result = 1 + n * (n + 1) // 2\n    print(result)\n", "perturbed_sampled": ["import sys for  n * (n + 1) // 2 print(result)"], "perturbed_original": ["while True: try: a = int(input()) print(((a * a) + a + 2) / 2) except EOFError: break"], "original_ll": -1.2230191230773926, "sampled_ll": -1.3409327268600464, "all_perturbed_sampled_ll": [-4.3203043937683105], "all_perturbed_original_ll": [-1.7492424249649048], "perturbed_sampled_ll": -4.3203043937683105, "perturbed_original_ll": -1.7492424249649048, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "i;main(){float A,a,B,b,C,c,D,d;for(;~scanf(\"%f\",&d+i*2);)if(++i==8)puts((A-B)*(C-D)+(a-b)*(c-d)?\"NO\":\"YES\",i=0);}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double xA, yA, xB, yB, xC, yC, xD, yD;\n    \n    while (scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n                 &xA, &yA, &xB, &yB, &xC, &yC, &xD, &yD) == 8) {\n        double dx1 = xB - xA;\n        double dy1 = yB - yA;\n        double dx2 = xD - xC;\n        double dy2 = yD - yC;\n        \n        double dot = dx1 * dx2 + dy1 * dy2;\n        \n        if (fabs(dot) < 1e-9) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" xB, yB, xC, yC, xD, yD; while (scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &xA, &yA, &xB, &yB, &xC, &yC, &xD, &yD) == 8) { double dx1 = xB - xA; double dy1   * dx2 + dy1 * dy2; if (fabs(dot)  return 0; }"], "perturbed_original": ["i;main(){float A,a,B,b,C,c,D,d;for(;~scanf(\"%f\",&d+i*2);)if(++i==8)puts((A-B)*(C-D)+(a-b)*(c-d)?\"NO\":\"YES\",i=0);}"], "original_ll": -2.8278112411499023, "sampled_ll": -0.4259226322174072, "all_perturbed_sampled_ll": [-1.1242036819458008], "all_perturbed_original_ll": [-2.8278112411499023], "perturbed_sampled_ll": -1.1242036819458008, "perturbed_original_ll": -2.8278112411499023, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main{\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        while(sc.hasNext()){\n            double[][]point=new double[4][2];\n            for(int i=0;i<4;i++){\n                point[i][0]=sc.nextDouble();\n                point[i][1]=sc.nextDouble();\n            }\n            double x1=point[1][0]-point[0][0],y1=point[1][1]-point[0][1],x2=point[3][0]-point[2][0],y2=point[3][1]-point[2][1];\n            System.out.println((x1*x2+y1*y2)==0?\"YES\":\"NO\");\n            \n        }\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double xA = sc.nextDouble();\n            double yA = sc.nextDouble();\n            double xB = sc.nextDouble();\n            double yB = sc.nextDouble();\n            double xC = sc.nextDouble();\n            double yC = sc.nextDouble();\n            double xD = sc.nextDouble();\n            double yD = sc.nextDouble();\n            \n            double dx1 = xB - xA;\n            double dy1 = yB - yA;\n            double dx2 = xD - xC;\n            double dy2 = yD - yC;\n            \n            double dotProduct = dx1 * dx2 + dy1 * dy2;\n            \n            if (Math.abs(dotProduct) < 1e-9) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main {  yA = sc.nextDouble(); double xB = sc.nextDouble(); double yB = sc.nextDouble(); double xC = sc.nextDouble(); double yC = sc.nextDouble(); double  xB - xA; double dy1 = yB  = yD - yC;  if (Math.abs(dotProduct) < 1e-9) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main{ public  double[4][2]; for(int i=0;i<4;i++){ point[i][0]=sc.nextDouble(); point[i][1]=sc.nextDouble(); } double x1=point[1][0]-point[0][0],y1=point[1][1]-point[0][1],x2=point[3][0]-point[2][0],y2=point[3][1]-point[2][1]; System.out.println((x1*x2+y1*y2)==0?\"YES\":\"NO\"); } } }"], "original_ll": -0.6098334193229675, "sampled_ll": -0.33978402614593506, "all_perturbed_sampled_ll": [-1.8116544485092163], "all_perturbed_original_ll": [-1.1743830442428589], "perturbed_sampled_ll": -1.8116544485092163, "perturbed_original_ll": -1.1743830442428589, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        xA,yA,xB,yB,xC,yC,xD,yD = map(float,raw_input().split())\n        if (100000*(yB-yA))*(100000*(yD-yC)) + (100000*(xB-xA))*(100000*(xD-xC)) < 1.e-10:\n            print \"YES\"\n        else:\n            print \"NO\"\n    except:\n        break", "sampled": "import sys\n\nfor line in sys.stdin:\n    coords = list(map(float, line.split()))\n    xa, ya, xb, yb, xc, yc, xd, yd = coords\n    \n    # Vector AB\n    vab_x = xb - xa\n    vab_y = yb - ya\n    \n    # Vector CD\n    vcd_x = xd - xc\n    vcd_y = yd - yc\n    \n    # Dot product\n    dot = vab_x * vcd_x + vab_y * vcd_y\n    \n    # Check if perpendicular (dot product is 0)\n    if abs(dot) < 1e-9:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys for line in sys.stdin:  xd, yd = coords # Vector AB vab_x = xb - xa  xd - xc vcd_y = yd - yc # Dot product dot = vab_x * vcd_x + vab_y *  abs(dot) < 1e-9: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["while True: try: xA,yA,xB,yB,xC,yC,xD,yD = map(float,raw_input().split()) if (100000*(yB-yA))*(100000*(yD-yC)) + (100000*(xB-xA))*(100000*(xD-xC)) < 1.e-10: print \"YES\" else: print \"NO\" except: break"], "original_ll": -1.005983591079712, "sampled_ll": -0.742567241191864, "all_perturbed_sampled_ll": [-2.8476526737213135], "all_perturbed_original_ll": [-1.148779034614563], "perturbed_sampled_ll": -2.8476526737213135, "perturbed_original_ll": -1.148779034614563, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\n#include <stdlib.h>\n#include<string.h>\n#include<limits.h>\n\nint main(){\n\tdouble x[4],y[4];\n\tint i;\n\t\n\twhile(scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2],&x[3],&y[3])!=EOF){\n\t\n\t\tif(x[0]<=x[2] && x[1]>=x[2]){\n\t\t\tif((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t\telse if(x[0]<=x[3] && x[1]>=x[3]){\n\t\t\tif((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t\telse printf(\"NO\\n\");\n\t}\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2;\n    \n    while (scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n                  &xa1, &ya1, &xa2, &ya2, &xb1, &yb1, &xb2, &yb2) == 8) {\n        \n        if (xa2 >= xb1 && xb2 >= xa1 && ya2 >= yb1 && yb2 >= ya1) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2; while (scanf(\"%lf %lf %lf %lf %lf  &yb2) == 8) {  >= yb1 &&  } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h> #include <stdlib.h> #include<string.h> #include<limits.h> int main(){ double  && x[1]>=x[3]){ if((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(\"YES\\n\"); else printf(\"NO\\n\"); } else printf(\"NO\\n\"); } return 0; }"], "original_ll": -0.5573317408561707, "sampled_ll": -0.4627642333507538, "all_perturbed_sampled_ll": [-1.9840631484985352], "all_perturbed_original_ll": [-1.5864126682281494], "perturbed_sampled_ll": -1.9840631484985352, "perturbed_original_ll": -1.5864126682281494, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main {\n\tstatic double x1[]=new double[2];\n\tstatic double y1[]=new double[2];\n\tstatic double x2[]=new double[2];\n\tstatic double y2[]=new double[2];\n\tpublic static boolean check(double x,double y) {\n\t\tif(x1[0]<=x && x<=x1[1] && y1[0]<=y && y<=y1[1]){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static boolean check2(double x,double y) {\n\t\tif(x2[0]<=x && x<=x2[1] && y2[0]<=y && y<=y2[1]){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble tmp;\n\t\tint i,j;\n\t\twhile(sc.hasNext()){\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tx1[i]=sc.nextDouble();\n\t\t\t\ty1[i]=sc.nextDouble();\n\t\t\t}\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tx2[i]=sc.nextDouble();\n\t\t\t\ty2[i]=sc.nextDouble();\n\t\t\t}\n\t\t\tif(x1[1]<x1[0]){\n\t\t\t\ttmp=x1[1];\n\t\t\t\tx1[0]=x1[1];\n\t\t\t\tx1[1]=tmp;\n\t\t\t}\n\t\t\tif(y1[1]<y1[0]){\n\t\t\t\ttmp=y1[1];\n\t\t\t\ty1[0]=y1[1];\n\t\t\t\ty1[1]=tmp;\n\t\t\t}\n\t\t\tif(x2[1]<x2[0]){\n\t\t\t\ttmp=x2[1];\n\t\t\t\tx2[0]=x2[1];\n\t\t\t\tx2[1]=tmp;\n\t\t\t}\n\t\t\tif(y2[1]<y2[0]){\n\t\t\t\ttmp=y2[1];\n\t\t\t\ty2[0]=y2[1];\n\t\t\t\ty2[1]=tmp;\n\t\t\t}\n\t\t\tboolean f=false;\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t//System.out.println(f+\" \"+x2[i]+\" \"+y2[j]);\n\t\t\t\t\tif(f) break;\n\t\t\t\t\tf=check(x2[i],y2[j]);\n\t\t\t\t}\n\t\t\t}//\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t//System.out.println(f);\n\t\t\t\t\tif(f) break;\n\t\t\t\t\tf=check2(x1[i],y1[j]);\n\t\t\t\t}\n\t\t\t}//\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double xa1 = sc.nextDouble();\n            double ya1 = sc.nextDouble();\n            double xa2 = sc.nextDouble();\n            double ya2 = sc.nextDouble();\n            double xb1 = sc.nextDouble();\n            double yb1 = sc.nextDouble();\n            double xb2 = sc.nextDouble();\n            double yb2 = sc.nextDouble();\n            \n            boolean xOverlap = !(xa2 < xb1 || xb2 < xa1);\n            boolean yOverlap = !(ya2 < yb1 || yb2 < ya1);\n            \n            if (xOverlap && yOverlap) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { double xa1 = sc.nextDouble(); double ya1 = sc.nextDouble(); double xa2 = sc.nextDouble(); double ya2 = sc.nextDouble(); double xb1 = sc.nextDouble(); double yb1 =  xOverlap  = !(ya2 < yb1 || yb2 < ya1);  } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public  double[2]; static double x2[]=new double[2]; static double y2[]=new double[2]; public static boolean check(double x,double y) { if(x1[0]<=x && x<=x1[1] && y1[0]<=y  boolean check2(double x,double y) { if(x2[0]<=x && x<=x2[1] && y2[0]<=y && y<=y2[1]){ return true; } return false; } public static  } if(x1[1]<x1[0]){ tmp=x1[1]; x1[0]=x1[1]; x1[1]=tmp; } if(y1[1]<y1[0]){ tmp=y1[1]; y1[0]=y1[1]; y1[1]=tmp; } if(x2[1]<x2[0]){ tmp=x2[1]; x2[0]=x2[1];  for(j=0;j<2;j++){ //System.out.println(f+\" \"+x2[i]+\" \"+y2[j]); if(f) break; f=check(x2[i],y2[j]); } }// for(i=0;i<2;i++){ for(j=0;j<2;j++){ //System.out.println(f); if(f) break;  } }"], "original_ll": -0.35558703541755676, "sampled_ll": -0.37563687562942505, "all_perturbed_sampled_ll": [-1.5451133251190186], "all_perturbed_original_ll": [-1.0319043397903442], "perturbed_sampled_ll": -1.5451133251190186, "perturbed_original_ll": -1.0319043397903442, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\n\nfor line in sys.stdin.readline():\n    xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2 = map(float, line.rstrip('\\n').split(' '))\n    if ((xb1<=xa1 and xa1<=xb2) or (xa1<=xb1 and xb1<=xa2)) and ((yb1<=ya2 and ya2<=yb2) or (ya1<=yb2 and yb2<=ya2)):\n        print 'YES'\n    else:\n        print 'NO'", "sampled": "import sys\n\nfor line in sys.stdin:\n    coords = []\n    coords.append(list(map(float, line.split())))\n    for _ in range(7):\n        coords.append(list(map(float, input().split())))\n    \n    xa1, ya1 = coords[0][0], coords[1][0]\n    xa2, ya2 = coords[2][0], coords[3][0]\n    xb1, yb1 = coords[4][0], coords[5][0]\n    xb2, yb2 = coords[6][0], coords[7][0]\n    \n    if xa2 >= xb1 and xb2 >= xa1 and ya2 >= yb1 and yb2 >= ya1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys  _ in range(7): coords.append(list(map(float, input().split()))) xa1, ya1 = coords[0][0], coords[1][0] xa2, ya2 = coords[2][0], coords[3][0] xb1, yb1 = coords[4][0], coords[5][0] xb2, yb2 = coords[6][0], coords[7][0] if xa2 >= xb1  >= ya1: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["import sys for  yb2 = map(float, line.rstrip('\\n').split(' ')) if ((xb1<=xa1 and xa1<=xb2) or (xa1<=xb1 and xb1<=xa2)) and ((yb1<=ya2 and ya2<=yb2) or (ya1<=yb2 and yb2<=ya2)): print 'YES' else: print 'NO'"], "original_ll": -0.8934713006019592, "sampled_ll": -0.702441394329071, "all_perturbed_sampled_ll": [-1.3298155069351196], "all_perturbed_original_ll": [-1.804858684539795], "perturbed_sampled_ll": -1.3298155069351196, "perturbed_original_ll": -1.804858684539795, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main()\n{\n        int c1, c2, c3, i, cnt = 0;\n        int card[11];\n\n        for ( int i = 1 ; i < 11 ; i++ ) {\n                card[i] = 1;\n        }\n\n        while ( scanf( \"%d %d %d\", &c1, &c2, &c3 ) == 3 ) {\n                cnt = 0;\n                for ( i = 1 ; i < 11 ; i++ ) {\n                        if ( c1 != i && c2 != i && c3 != i ) {\n                                if ( c1 + c2 + i <= 20 ) {\n                                        cnt++;\n                                }\n                        }\n                }\n                if ( cnt >= 4 ) {\n                        printf( \"YES\\n\" );\n                } else {\n                        printf( \"NO\\n\" );\n                }\n        }\n        return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nint main() {\n    int c1, c2, c3;\n    \n    while (scanf(\"%d %d %d\", &c1, &c2, &c3) == 3) {\n        int current_sum = c1 + c2;\n        int max_allowed = 20 - current_sum;\n        \n        int count_valid = 0;\n        int count_total = 0;\n        \n        for (int i = 1; i <= 10; i++) {\n            if (i != c1 && i != c2 && i != c3) {\n                count_total++;\n                if (i <= max_allowed) {\n                    count_valid++;\n                }\n            }\n        }\n        \n        if (count_valid * 2 >= count_total) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int c1, c2, c3; while (scanf(\"%d %d  c1 +  0; int count_total = 0; for (int i = 1; i <= 10; i++) { if (i  { count_total++; if (i <= max_allowed) { count_valid++; } } }  { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include  = 0; int card[11]; for (  ) { card[i] = 1; } while ( scanf( \"%d %d %d\", &c1, &c2, &c3 ) == 3 ) { cnt =  ; i++ ) { if ( c1 != i && c2 != i && c3 != i ) { if ( c1 + c2 + i <= 20 ) { cnt++; }  } return 0; }"], "original_ll": -0.781013548374176, "sampled_ll": -0.6711427569389343, "all_perturbed_sampled_ll": [-2.2312674522399902], "all_perturbed_original_ll": [-1.7246923446655273], "perturbed_sampled_ll": -2.2312674522399902, "perturbed_original_ll": -1.7246923446655273, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint count = 0;\n\t\t\tfor(int i=1;i<=10;i++){\n\t\t\t\tif(i!=a && i!=b && i!=c && a+b+i>20) count++;\n\t\t\t}\n\t\t\tif(count<=3) System.out.println(\"YES\");\n\t\t\telse System.out.println(\"NO\");\t\n\t\t}\n\t}\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int c1 = sc.nextInt();\n            int c2 = sc.nextInt();\n            int c3 = sc.nextInt();\n            \n            int currentSum = c1 + c2;\n            \n            // Count how many cards from remaining 7 cards would make sum <= 20\n            int count = 0;\n            for (int i = 1; i <= 10; i++) {\n                if (i != c1 && i != c2 && i != c3) {\n                    if (currentSum + i <= 20) {\n                        count++;\n                    }\n                }\n            }\n            \n            // Total remaining cards is 7 (10 - 3 known cards)\n            // Probability is count/7\n            // 50% or more means count/7 >= 0.5, which is count >= 3.5, so count >= 4\n            if (count * 2 >= 7) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  { Scanner sc =  int count = 0; for (int i = 1; i <= 10; i++) { if (i != c1 && i != c2 && i != c3) { if (currentSum + i  cards is 7 (10 - 3 known cards) // Probability is count/7 // 50% or more means count/7 >= 0.5, which is count >= 3.5, so count >= 4 if (count * 2 >= 7) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(sc.hasNext()){ int a = sc.nextInt(); int b = sc.nextInt(); int c = sc.nextInt(); int  } }"], "original_ll": -0.84539395570755, "sampled_ll": -0.9197403192520142, "all_perturbed_sampled_ll": [-2.1995112895965576], "all_perturbed_original_ll": [-1.2540637254714966], "perturbed_sampled_ll": -2.1995112895965576, "perturbed_original_ll": -1.2540637254714966, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor x in sys.stdin:\n e=list(map(int,x.split()))\n print(['YES','NO'][len(set(range(1,21-sum(e[:2])))-set(e))/7<.5])\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    c1, c2, c3 = map(int, line.strip().split())\n    \n    current_sum = c1 + c2\n    used_cards = {c1, c2, c3}\n    \n    available_cards = []\n    for i in range(1, 11):\n        if i not in used_cards:\n            available_cards.append(i)\n    \n    valid_count = 0\n    for card in available_cards:\n        if current_sum + card <= 20:\n            valid_count += 1\n    \n    total_count = len(available_cards)\n    \n    if valid_count / total_count >= 0.5:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys <extra_id_1>else: input_name +=<extra_id_2>for a in<extra_id_3>str ( c3<extra_id_4>.<extra_id_5>( available_cards .<extra_id_6>!=<extra_id_7>( c3 . current_card_type<extra_id_8>c3 .<extra_id_9>; print(current_sum+2 * p-1<extra_id_10>= sys.sighandler.c3))) c3._c3_info.card_names_to_display_values c3} available_cards = [] for i in range(1, 11):  card in available_cards: if current_sum + card <= 20: valid_count += 1 total_count = len(available_cards) if valid_count / total_count >= 0.5: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["import sys for x in sys.stdin: e=list(map(int,x.split())) print(['YES','NO'][len(set(range(1,21-sum(e[:2])))-set(e))/7<.5])"], "original_ll": -3.1768813133239746, "sampled_ll": -0.9136961102485657, "all_perturbed_sampled_ll": [-3.0703816413879395], "all_perturbed_original_ll": [-3.234931468963623], "perturbed_sampled_ll": -3.0703816413879395, "perturbed_original_ll": -3.234931468963623, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint i,j,k;\n\tint team[100],score[100];\n\tint rank[100];\n\tint count,number,tmp1,tmp2,info;\n\t\n\tcount=0;\n\t//\u5165\u529b\n\tfor(i=0;i<100;i++)\n\t{\n\t\tscanf(\"%d,%d\",&team[i],&score[i]);\n\t\tif(team[i]+score[i]==0)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\t\n\t//\u4e26\u3073\u66ff\u3048\n\tfor(i=0;i<count;i++)\n\t{\n\t\tfor(j=count-1;j>i;j--)\n\t\t{\n\t\t\tif(score[i]<=score[j])\n\t\t\t{\n\t\t\t\ttmp1=score[i];\n\t\t\t\tscore[i]=score[j];\n\t\t\t\tscore[j]=tmp1;\n\t\t\t\t\n\t\t\t\ttmp1=team[i];\n\t\t\t\tteam[i]=team[j];\n\t\t\t\tteam[j]=tmp1;\n\t\t\t}\n\t\t}\n\t}\n\t//\u9806\u4f4d\u4ed8\u3051\n\tnumber=1;\n\trank[0]=number;\n\ttmp2=score[0];\n\tfor(i=1;i<count;i++)\n\t{\n\t\t//printf(\"%d %d\\n\",score[i],tmp2);\n\t\tif(score[i]!=tmp2)\n\t\t{\n\t\t\tnumber++;\n\t\t\ttmp2=score[i];\n\t\t}\n\t\trank[i]=number;\n\t}\n\t\n\t\n\t//\u554f\u3044\u5408\u308f\u305b\n\twhile(scanf(\"%d\",&info)!=EOF)\n\t{\n\t\tfor(i=0;i<count;i++)\n\t\t{\n\t\t\tif(info==team[i])\n\t\t\t\tprintf(\"%d\\n\",rank[i]);\n\t\t\t//printf(\"%d,%d\\n\",team[i],score[i]);\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int score;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    return tb->score - ta->score;\n}\n\nint main() {\n    Team teams[100];\n    int count = 0;\n    int id, score;\n    \n    while (1) {\n        scanf(\"%d,%d\", &id, &score);\n        if (id == 0 && score == 0) break;\n        teams[count].id = id;\n        teams[count].score = score;\n        count++;\n    }\n    \n    qsort(teams, count, sizeof(Team), compare);\n    \n    int query;\n    while (scanf(\"%d\", &query) != EOF) {\n        int target_score = -1;\n        for (int i = 0; i < count; i++) {\n            if (teams[i].id == query) {\n                target_score = teams[i].score;\n                break;\n            }\n        }\n        \n        int rank = 1;\n        int prev_score = -1;\n        int current_rank = 0;\n        \n        for (int i = 0; i < count; i++) {\n            if (teams[i].score != prev_score) {\n                current_rank++;\n                prev_score = teams[i].score;\n            }\n            if (teams[i].score == target_score) {\n                rank = current_rank;\n                break;\n            }\n        }\n        \n        printf(\"%d\\n\", rank);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef  (Team *)a; Team *tb = (Team *)b; return tb->score - ta->score; } int main() { Team teams[100]; int count = 0; int id, score; while (1) { scanf(\"%d,%d\", &id, &score); if (id == 0 && score == 0) break; teams[count].id = id; teams[count].score = score; count++; }   query) { target_score = teams[i].score; break; } } int rank  for (int i = 0; i < count; i++) { if (teams[i].score !=  target_score) { rank = current_rank; break; } } printf(\"%d\\n\", rank); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int i,j,k; int team[100],score[100]; int rank[100]; int count,number,tmp1,tmp2,info;  for(i=0;i<count;i++) { for(j=count-1;j>i;j--) { if(score[i]<=score[j]) {  number=1; rank[0]=number; tmp2=score[0]; for(i=1;i<count;i++) { //printf(\"%d %d\\n\",score[i],tmp2); if(score[i]!=tmp2) { number++; tmp2=score[i]; } rank[i]=number; } //\u554f\u3044\u5408\u308f\u305b  0; }"], "original_ll": -0.6795074343681335, "sampled_ll": -0.42233705520629883, "all_perturbed_sampled_ll": [-1.6654150485992432], "all_perturbed_original_ll": [-1.8261321783065796], "perturbed_sampled_ll": -1.6654150485992432, "perturbed_original_ll": -1.8261321783065796, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString point[]= new String[100];\n\t\tint rank[]= new int[30];\n\t\tint n = 0;\n\t\tint count=0;\n\t\twhile(sc.hasNext()){\n\t\t\tString get = sc.next();\n\t\t\tif(get.equals(\"0,0\"))break;\n\t\t\tString str[] = get.split(\",\");\n\t\t\tpoint[n = Integer.parseInt(str[0])]=str[1];\n\t\t\trank[n= Integer.parseInt(str[1])-1]++;\n\t\t}\n\t\twhile(sc.hasNext()){\n\t\t\tcount=1;\n\t\t\tn = sc.nextInt();\n\t\t\tfor(int i = 29 ;i > Integer.parseInt(point[n]);i--){\n\t\t\t\tif(rank[i]>0)count++;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Map<Integer, Integer> teamScores = new HashMap<>();\n        \n        while (true) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int teamId = Integer.parseInt(parts[0]);\n            int score = Integer.parseInt(parts[1]);\n            \n            if (teamId == 0 && score == 0) {\n                break;\n            }\n            \n            teamScores.put(teamId, score);\n        }\n        \n        List<Integer> sortedScores = new ArrayList<>(teamScores.values());\n        Collections.sort(sortedScores, Collections.reverseOrder());\n        \n        Map<Integer, Integer> scoreToRank = new HashMap<>();\n        int rank = 1;\n        for (int score : sortedScores) {\n            if (!scoreToRank.containsKey(score)) {\n                scoreToRank.put(score, rank);\n                rank++;\n            }\n        }\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            int queryTeam = Integer.parseInt(line.trim());\n            int score = teamScores.get(queryTeam);\n            int teamRank = scoreToRank.get(score);\n            System.out.println(teamRank);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); Map<Integer, Integer> teamScores = new HashMap<>(); while (true) { String line = sc.nextLine(); String[] parts = line.split(\",\"); int teamId = Integer.parseInt(parts[0]); int score = Integer.parseInt(parts[1]); if  teamScores.put(teamId, score); }  = new HashMap<>(); int rank  { scoreToRank.put(score, rank); rank++; } } while  queryTeam = Integer.parseInt(line.trim()); int score  }"], "perturbed_original": ["import java.util.Scanner; class Main{ public static void main(String args[]){ Scanner sc = new Scanner(System.in);  =  str[] =  = sc.nextInt(); for(int i = 29 ;i > Integer.parseInt(point[n]);i--){ if(rank[i]>0)count++; } System.out.println(count); } } }"], "original_ll": -1.2854968309402466, "sampled_ll": -0.5440812110900879, "all_perturbed_sampled_ll": [-1.7242536544799805], "all_perturbed_original_ll": [-2.62856388092041], "perturbed_sampled_ll": -1.7242536544799805, "perturbed_original_ll": -2.62856388092041, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "nums={}\nwhile True:\n    p,s=map(int,input().split(','))\n    if(p==0 and s==0):break\n    if not s in nums:\n        nums[s]=[]\n    nums[s].append(p)\n\nwhile True:\n    try:\n        q=int(input())\n        ans=len(nums)\n        for ns in nums.items():\n            if q in ns[1]:\n                print(ans)\n                break\n            ans-=1\n    except:\n        break", "sampled": "# Read team data\nteams = {}\nwhile True:\n    line = input().strip()\n    parts = line.split(',')\n    team_id = int(parts[0])\n    score = int(parts[1])\n    if team_id == 0 and score == 0:\n        break\n    teams[team_id] = score\n\n# Get unique scores and sort them in descending order\nunique_scores = sorted(set(teams.values()), reverse=True)\n\n# Create a mapping from score to rank\nscore_to_rank = {}\nfor i, score in enumerate(unique_scores):\n    score_to_rank[score] = i + 1\n\n# Process queries\nimport sys\nfor line in sys.stdin:\n    query = int(line.strip())\n    score = teams[query]\n    rank = score_to_rank[score]\n    print(rank)\n", "perturbed_sampled": ["# Read team data teams = {} while True: line = input().strip() parts = line.split(',') team_id = int(parts[0])  and sort them in descending order unique_scores = sorted(set(teams.values()), reverse=True) # Create a mapping from score to rank score_to_rank = {} for i, score in enumerate(unique_scores): score_to_rank[score] =  in  print(rank)"], "perturbed_original": ["nums={} while True:  nums[s].append(p) while True: try: q=int(input()) ans=len(nums) for ns in nums.items(): if q in ns[1]: print(ans) break ans-=1 except: break"], "original_ll": -1.3787477016448975, "sampled_ll": -0.9182032346725464, "all_perturbed_sampled_ll": [-2.517014741897583], "all_perturbed_original_ll": [-2.757678508758545], "perturbed_sampled_ll": -2.517014741897583, "perturbed_original_ll": -2.757678508758545, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#define N 100\n\nvoid hanten(char str[],int n){\n  char t;\n  int i,j;\n    for (j=0;j<n/2;j++){\n      t=str[j];\n      str[j]=str[n-j-1];\n      str[n-j-1]=t;\n    }\n}\n\nint main()\n{\n  int i,j,cnt=0;\n  char str1[N],str2[N];\n  while (scanf(\"%s\",str1)!=EOF){\n    strcpy(str2,str1);\n    hanten(str1,strlen(str1));\n    if (strcmp(str1,str2)==0)\n      cnt++;\n  }\n  printf(\"%d\\n\",cnt);\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint isPalindrome(char *str) {\n    int len = strlen(str);\n    if (str[len-1] == '\\n') {\n        str[len-1] = '\\0';\n        len--;\n    }\n    \n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - 1 - i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char line[101];\n    int count = 0;\n    \n    while (fgets(line, sizeof(line), stdin) != NULL) {\n        if (isPalindrome(line)) {\n            count++;\n        }\n    }\n    \n    printf(\"%d\\n\", count);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int isPalindrome(char *str) { int len = strlen(str); if  (int i = 0; i < len / 2; i++) { if (str[i] !=  count = 0; while (fgets(line, sizeof(line), stdin) != NULL) { if (isPalindrome(line)) { count++; } } printf(\"%d\\n\", count); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #define N 100 void hanten(char str[],int n){ char t;  main()  (strcmp(str1,str2)==0) cnt++; } printf(\"%d\\n\",cnt); return 0; }"], "original_ll": -0.8853587508201599, "sampled_ll": -0.4585752785205841, "all_perturbed_sampled_ll": [-1.2554161548614502], "all_perturbed_original_ll": [-2.5975630283355713], "perturbed_sampled_ll": -1.2554161548614502, "perturbed_original_ll": -2.5975630283355713, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n    private static final Scanner scn = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int cnt = 0;\n        while(scn.hasNext()) {\n            String str = scn.next();\n            String rev = new String(new StringBuilder(str).reverse());\n            if(str.equals(rev)) {\n                cnt++;\n            }\n        }\n        System.out.println(cnt);\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (isPalindrome(line)) {\n                count++;\n            }\n        }\n        \n        System.out.println(count);\n        sc.close();\n    }\n    \n    static boolean isPalindrome(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int count = 0;  count++; } } System.out.println(count); sc.close(); } static boolean isPalindrome(String s)  s.charAt(right)) { return false; } left++; right--; } return true; } }"], "perturbed_original": ["import java.util.*; public class Main {  void main(String[] args) { int cnt = 0; while(scn.hasNext()) { String  { cnt++; } } System.out.println(cnt); } }"], "original_ll": -0.8151882886886597, "sampled_ll": -0.3092479407787323, "all_perturbed_sampled_ll": [-1.8694924116134644], "all_perturbed_original_ll": [-2.329103708267212], "perturbed_sampled_ll": -1.8694924116134644, "perturbed_original_ll": -2.329103708267212, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef is_pal(s):\n    l = len(s)-1\n    for i in range(l/2):\n        if s[i] != s[l-1-i]:\n            return False\n    return True\n\ncount = 0\nfor line in sys.stdin:\n    if is_pal(line):\n        count += 1\nprint count", "sampled": "import sys\n\ncount = 0\nfor line in sys.stdin:\n    s = line.strip()\n    if s == s[::-1]:\n        count += 1\n\nprint(count)\n", "perturbed_sampled": ["import sys count = 0 for  count += 1 print(count)"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys def is_pal(s): l = len(s)-1 for i in range(l/2): if s[i] != s[l-1-i]: return False return True  += 1 print count"], "original_ll": -0.9505003094673157, "sampled_ll": -1.2730969190597534, "all_perturbed_sampled_ll": [-4.480957508087158], "all_perturbed_original_ll": [-1.918841004371643], "perturbed_sampled_ll": -4.480957508087158, "perturbed_original_ll": -1.918841004371643, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <ctype.h>\n\nint main()\n{\n        char str[81], tmp[6];\n        int num = 0, i, sum = 0;\n\n        while ( scanf( \"%s\", str ) == 1 ) {\n                i = 0;\n                while ( str[i] ) {\n                        if ( isdigit( str[i] ) ) {\n                                num = 0;\n                                while ( isdigit( str[i] ) ) {\n                                        num = 10 * num + ( str[i] - '0' );\n                                        i++;\n                                }\n                                sum = sum + num;\n                        } else {\n                                i++;\n                        }\n                }\n        }\n\n        printf( \"%d\\n\", sum );\n\n        return 0;\n}\n\n", "sampled": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    int sum = 0;\n    int num = 0;\n    int in_number = 0;\n    char c;\n    \n    while ((c = getchar()) != EOF) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n            in_number = 1;\n        } else {\n            if (in_number) {\n                sum += num;\n                num = 0;\n                in_number = 0;\n            }\n        }\n    }\n    \n    if (in_number) {\n        sum += num;\n    }\n    \n    printf(\"%d\\n\", sum);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <ctype.h> int main() { int sum = 0; int num = 0; int in_number = 0; char c; while ((c = getchar()) != EOF) { if (isdigit(c)) { num = num * 10  if (in_number) {  printf(\"%d\\n\", sum); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <ctype.h> int main() { char  while ( scanf( \"%s\", str   num =  10 * num + ( str[i] - '0' ); i++; } sum = sum + num; } else { i++; } } } printf( \"%d\\n\", sum ); return 0; }"], "original_ll": -0.7837428450584412, "sampled_ll": -0.4640091061592102, "all_perturbed_sampled_ll": [-1.432388424873352], "all_perturbed_original_ll": [-1.9130384922027588], "perturbed_sampled_ll": -1.432388424873352, "perturbed_original_ll": -1.9130384922027588, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = 0,sum = 0;\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] ch = sc.next().toCharArray();\n\t\tfor(int i = 0; i < ch.length; i++){\n\t\t\tif('0' <= ch[i] && ch[i] <= '9'){\n\t\t\t\tn = n * 10;\n\t\t\t\tn += ch[i] - '0';\n\t\t\t}else{\n\t\t\t\tsum += n;\n\t\t\t\tn = 0;\n\t\t\t}\n\t\t}\n\t\tsum += n;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t\tsc.close();\n\t}\n}", "sampled": "import java.util.*;\nimport java.util.regex.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int sum = 0;\n        Pattern pattern = Pattern.compile(\"\\\\d+\");\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            Matcher matcher = pattern.matcher(line);\n            \n            while (matcher.find()) {\n                sum += Integer.parseInt(matcher.group());\n            }\n        }\n        \n        System.out.println(sum);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.util.regex.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int sum = 0; Pattern pattern =  = pattern.matcher(line); while  }"], "perturbed_original": ["import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int n = 0,sum = 0; while(sc.hasNext()){ char[] ch  if('0' <= ch[i] && ch[i]  } } sum += n; } System.out.println(sum); sc.close(); } }"], "original_ll": -0.6309410333633423, "sampled_ll": -0.5350126624107361, "all_perturbed_sampled_ll": [-2.175208806991577], "all_perturbed_original_ll": [-1.6627888679504395], "perturbed_sampled_ll": -2.175208806991577, "perturbed_original_ll": -1.6627888679504395, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import re\nans = 0\nwhile True:\n    try:\n        line = input()\n    except:\n        print(ans)\n        break\n    ans += sum(map(int, re.findall(\"[0-9]+\", line)))", "sampled": "import sys\nimport re\n\ntotal = 0\nfor line in sys.stdin:\n    numbers = re.findall(r'\\d+', line)\n    for num in numbers:\n        total += int(num)\n\nprint(total)\n", "perturbed_sampled": ["import sys import re total  for num in numbers: total += int(num) print(total)"], "perturbed_original": ["import re ans = 0 while True: try: line = input() except: print(ans) break ans += sum(map(int, re.findall(\"[0-9]+\", line)))"], "original_ll": -1.1135430335998535, "sampled_ll": -1.081687331199646, "all_perturbed_sampled_ll": [-4.108831405639648], "all_perturbed_original_ll": [-2.0902609825134277], "perturbed_sampled_ll": -4.108831405639648, "perturbed_original_ll": -2.0902609825134277, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\n#include <stdlib.h>\n#include<string.h>\n#include<limits.h>\n#include<time.h>\n\nvoid sosu(int n){\n\tint i,j,num[n];\n\t\n\tfor(i=2;i<=n;i++)num[i]=i;\n\tfor(i=2;i<=sqrt(n);i++){\n\t\tfor(j=2;j*i<=n;j++)num[j*i]=0;\n\t}\n}\n\nint main(){\n\tint number[10000]={0};\n\tint ac[10000]={0};\n\tint i,j,k,count;\n\t\n\tfor(i=0;scanf(\"%d,%d\",&number[i],&ac[i])!=EOF;i++);\n\tfor(j=i;scanf(\"%d,%d\",&number[j],&ac[j])!=EOF;j++);\n\tcount=j;\n\t\n\tfor(i=0;i<count;i++){\n\t\tfor(j=0;j<count;j++){\n\t\t\tif(number[i]<number[j]){\n\t\t\t\tk=number[i];\n\t\t\t\tnumber[i]=number[j];\n\t\t\t\tnumber[j]=k;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0,k=0;i<count;i++){\n\t\tfor(j=i;j<count;j++){\n\t\t\tif(number[i]==number[j] && i!=j)k++;\n\t\t}\n\t\ti+=k;\n\t\tif(k>=1)printf(\"%d %d\\n\",number[i],k+1);\n\t\tk=0;\n\t}\n\t\nreturn 0;\n\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int this_month[1001] = {0};\n    int last_month[1001] = {0};\n    int customer, day;\n    char line[100];\n    int reading_this_month = 1;\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        if (line[0] == '\\n' || strlen(line) <= 1) {\n            reading_this_month = 0;\n            continue;\n        }\n        \n        if (sscanf(line, \"%d,%d\", &customer, &day) == 2) {\n            if (reading_this_month) {\n                this_month[customer]++;\n            } else {\n                last_month[customer]++;\n            }\n        }\n    }\n    \n    for (int i = 1; i <= 1000; i++) {\n        if (this_month[i] > 0 && last_month[i] > 0) {\n            printf(\"%d %d\\n\", i, this_month[i] + last_month[i]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int this_month[1001] = {0}; int last_month[1001] = {0};  (fgets(line, sizeof(line), stdin)) { if (line[0] == '\\n' || strlen(line) <= 1) { reading_this_month = 0; continue; } if (sscanf(line, \"%d,%d\",  = 1; i <= 1000; i++) {  %d\\n\", i, this_month[i] + last_month[i]); } } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h> #include <stdlib.h> #include<string.h> #include<limits.h> #include<time.h> void sosu(int  for(i=0;i<count;i++){ for(j=0;j<count;j++){ if(number[i]<number[j]){ k=number[i]; number[i]=number[j]; number[j]=k; } } } for(i=0,k=0;i<count;i++){ for(j=i;j<count;j++){ if(number[i]==number[j] && i!=j)k++; } i+=k; if(k>=1)printf(\"%d %d\\n\",number[i],k+1); k=0; } return 0; }"], "original_ll": -0.9693806767463684, "sampled_ll": -0.7133219242095947, "all_perturbed_sampled_ll": [-1.6165385246276855], "all_perturbed_original_ll": [-1.3299766778945923], "perturbed_sampled_ll": -1.6165385246276855, "perturbed_original_ll": -1.3299766778945923, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.util.Map.Entry;\n\n//\u6587\u5b57\u64cd\u4f5c\nclass Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic void run() {\n\t\tHashtable<Integer,Integer> data1=new Hashtable<Integer, Integer>();\n\t\tHashtable<Integer,Integer> data2=new Hashtable<Integer, Integer>();\n\n\t\twhile(sc.hasNext()){\n\t\t\tString[] str=sc.nextLine().split(\",\");\n\t\t\tif(\"\".equals(str[0]))break;\n\t\t\tint[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])};\n\t\t\tif(data1.containsKey(vals[0])){\n\t\t\t\tdata1.put(vals[0],data1.get(vals[0])+1);\n\t\t\t}else{\n\t\t\t\tdata1.put(vals[0],1);\n\t\t\t}\n\t\t}\n\t\twhile(sc.hasNext()){\n\t\t\tString[] str=sc.nextLine().split(\",\");\n\t\t\tif(\"\".equals(str[0]))break;\n\t\t\tint[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])};\n\t\t\tif(data2.containsKey(vals[0])){\n\t\t\t\tdata2.put(vals[0],data2.get(vals[0])+1);\n\t\t\t}else{\n\t\t\t\tdata2.put(vals[0],1);\n\t\t\t}\n\t\t}\n\t\tArrayList<Entry<Integer,Integer>> data1list=new ArrayList<Entry<Integer,Integer>>(data1.entrySet());\n\t\tCollections.sort(data1list,new Comparator<Entry<Integer,Integer>>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Entry<Integer, Integer> o1,\n\t\t\t\t\tEntry<Integer, Integer> o2) {\n\t\t\t\treturn o1.getKey()-o2.getKey();\n\t\t\t}\n\t\t});\n\t\tfor(Entry<Integer,Integer> entry:data1list){\n\t\t\tif(data2.containsKey(entry.getKey())){\n\t\t\t\tln(entry.getKey()+\" \"+ (entry.getValue()+data2.get(entry.getKey())));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Map<Integer, Integer> thisMonth = new HashMap<>();\n        Map<Integer, Integer> lastMonth = new HashMap<>();\n        \n        // Read this month's data\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.trim().isEmpty()) {\n                break;\n            }\n            String[] parts = line.split(\",\");\n            int customer = Integer.parseInt(parts[0]);\n            thisMonth.put(customer, thisMonth.getOrDefault(customer, 0) + 1);\n        }\n        \n        // Read last month's data\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.trim().isEmpty()) {\n                break;\n            }\n            String[] parts = line.split(\",\");\n            int customer = Integer.parseInt(parts[0]);\n            lastMonth.put(customer, lastMonth.getOrDefault(customer, 0) + 1);\n        }\n        \n        // Find customers in both months\n        Set<Integer> commonCustomers = new HashSet<>(thisMonth.keySet());\n        commonCustomers.retainAll(lastMonth.keySet());\n        \n        // Sort and output\n        List<Integer> sortedCustomers = new ArrayList<>(commonCustomers);\n        Collections.sort(sortedCustomers);\n        \n        for (int customer : sortedCustomers) {\n            int total = thisMonth.get(customer) + lastMonth.get(customer);\n            System.out.println(customer + \" \" + total);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); Map<Integer, Integer> thisMonth = new HashMap<>(); Map<Integer, Integer> lastMonth = new HashMap<>(); // Read this  (line.trim().isEmpty()) { break; } String[] parts = line.split(\",\"); int customer = Integer.parseInt(parts[0]); thisMonth.put(customer, thisMonth.getOrDefault(customer, 0) + 1);  line = sc.nextLine(); if (line.trim().isEmpty()) { break; } String[] parts = line.split(\",\"); int customer = Integer.parseInt(parts[0]); lastMonth.put(customer, lastMonth.getOrDefault(customer, 0) +  = new HashSet<>(thisMonth.keySet()); commonCustomers.retainAll(lastMonth.keySet()); //   } }"], "perturbed_original": ["import java.util.*; import java.util.Map.Entry; //\u6587\u5b57\u64cd\u4f5c class Main { Scanner sc = new Scanner(System.in); public void  while(sc.hasNext()){ String[] str=sc.nextLine().split(\",\"); if(\"\".equals(str[0]))break; int[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])}; if(data1.containsKey(vals[0])){ data1.put(vals[0],data1.get(vals[0])+1); }else{ data1.put(vals[0],1); } } while(sc.hasNext()){ String[] str=sc.nextLine().split(\",\"); if(\"\".equals(str[0]))break; int[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])}; if(data2.containsKey(vals[0])){ data2.put(vals[0],data2.get(vals[0])+1); }else{  (entry.getValue()+data2.get(entry.getKey()))); } } } public static void main(String[] args) { new Main().run(); } public static void pr(Object o) { System.out.print(o); }  void ln() { System.out.println(); } }"], "original_ll": -0.6314448118209839, "sampled_ll": -0.4193880259990692, "all_perturbed_sampled_ll": [-1.3188542127609253], "all_perturbed_original_ll": [-1.2847567796707153], "perturbed_sampled_ll": -1.3188542127609253, "perturbed_original_ll": -1.2847567796707153, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nb=0\na=[{},{}]\nfor e in sys.stdin:\n if'\\n'==e:b=1\n else:c=int(e.split(',')[0]);a[b].setdefault(c,0);a[b][c]+=1\nfor k in sorted({*a[0]}&{*a[1]}):print(k,a[0][k]+a[1][k])\n", "sampled": "import sys\n\n# Read all input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.strip())\n\n# Find the empty line that separates this month and last month\nseparator_idx = -1\nfor i, line in enumerate(lines):\n    if line == '':\n        separator_idx = i\n        break\n\n# Parse this month's data\nthis_month = lines[:separator_idx]\nlast_month = lines[separator_idx + 1:]\n\n# Count transactions for each customer\nthis_month_customers = {}\nlast_month_customers = {}\n\nfor line in this_month:\n    if line:\n        parts = line.split(',')\n        customer_id = int(parts[0])\n        this_month_customers[customer_id] = this_month_customers.get(customer_id, 0) + 1\n\nfor line in last_month:\n    if line:\n        parts = line.split(',')\n        customer_id = int(parts[0])\n        last_month_customers[customer_id] = last_month_customers.get(customer_id, 0) + 1\n\n# Find customers who appear in both months\ncommon_customers = set(this_month_customers.keys()) & set(last_month_customers.keys())\n\n# Calculate total transactions and sort by customer ID\nresults = []\nfor customer_id in common_customers:\n    total_transactions = this_month_customers[customer_id] + last_month_customers[customer_id]\n    results.append((customer_id, total_transactions))\n\nresults.sort()\n\n# Output\nfor customer_id, total in results:\n    print(customer_id, total)\n", "perturbed_sampled": ["import sys # Read all input lines = [] for line in sys.stdin: lines.append(line.strip()) # Find the empty line  this_month = lines[:separator_idx] last_month = lines[separator_idx + 1:] # Count transactions for each customer this_month_customers  line:  + 1 for line in last_month: if line: parts = line.split(',') customer_id = int(parts[0]) last_month_customers[customer_id] = last_month_customers.get(customer_id, 0) +  = set(this_month_customers.keys()) & set(last_month_customers.keys()) # Calculate total transactions and sort by customer ID results  last_month_customers[customer_id] results.append((customer_id, total_transactions)) results.sort() # Output for customer_id, total in results: print(customer_id, total)"], "perturbed_original": ["import sys b=0 a=[{},{}] for e in sys.stdin: if'\\n'==e:b=1 else:c=int(e.split(',')[0]);a[b].setdefault(c,0);a[b][c]+=1 for k in sorted({*a[0]}&{*a[1]}):print(k,a[0][k]+a[1][k])"], "original_ll": -1.8674256801605225, "sampled_ll": -0.6689382791519165, "all_perturbed_sampled_ll": [-2.0653464794158936], "all_perturbed_original_ll": [-2.0769424438476562], "perturbed_sampled_ll": -2.0653464794158936, "perturbed_original_ll": -2.0769424438476562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nchar map[16][16] = {0};\n\nvoid delete_island(int x, int y)\n{\n\tif (map[x][y] == 0) return;\n\tmap[x][y] = 0;\n\tdelete_island(x - 1, y);\n\tdelete_island(x + 1, y);\n\tdelete_island(x, y - 1);\n\tdelete_island(x, y + 1);\n}\n\nint main(void)\n{\n\twhile (scanf(\"%s\", &map[0][1]) != EOF){\n\t\tint i, j;\n\t\tint count = 0;\n\t\t\n\t\tfor (i = 1; i < 12; i++) scanf(\"%s\", &map[i][1]);\n\t\tfor (i = 0; i < 12; i++){\n\t\t\tfor (j = 0; j < 12; j++) map[i][j + 1] -= '0';\n\t\t}\n\t\t\n\t\tfor (i = 0; i < 12; i++){\n\t\t\tfor (j = 0; j < 12; j++){\n\t\t\t\tif (map[i][j + 1] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tdelete_island(i, j + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", count);\n\t\tscanf(\"%*c\");\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint grid[12][12];\nint visited[12][12];\n\nvoid dfs(int i, int j) {\n    if (i < 0 || i >= 12 || j < 0 || j >= 12) return;\n    if (grid[i][j] == 0 || visited[i][j]) return;\n    \n    visited[i][j] = 1;\n    \n    dfs(i-1, j);\n    dfs(i+1, j);\n    dfs(i, j-1);\n    dfs(i, j+1);\n}\n\nint main() {\n    char line[100];\n    \n    while (1) {\n        int hasInput = 0;\n        \n        for (int i = 0; i < 12; i++) {\n            if (fgets(line, sizeof(line), stdin) == NULL) {\n                return 0;\n            }\n            \n            if (strlen(line) > 1 && line[0] != '\\n') {\n                hasInput = 1;\n                for (int j = 0; j < 12; j++) {\n                    grid[i][j] = line[j] - '0';\n                }\n            } else if (strlen(line) <= 1 || line[0] == '\\n') {\n                if (!hasInput) {\n                    i--;\n                    continue;\n                } else {\n                    return 0;\n                }\n            }\n        }\n        \n        if (!hasInput) break;\n        \n        memset(visited, 0, sizeof(visited));\n        \n        int islands = 0;\n        for (int i = 0; i < 12; i++) {\n            for (int j = 0; j < 12; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    dfs(i, j);\n                    islands++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", islands);\n        \n        while (fgets(line, sizeof(line), stdin) != NULL) {\n            if (line[0] != '\\n' && strlen(line) > 1) {\n                fseek(stdin, -(long)strlen(line), SEEK_CUR);\n                break;\n            }\n            if (feof(stdin)) return 0;\n        }\n        \n        if (feof(stdin)) break;\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int  (i < 0 || i >= 12 || j < 0 || j >= 12) return; if (grid[i][j] == 0 ||  j-1);  { int hasInput = 0; for (int i = 0; i < 12; i++) { if (fgets(line, sizeof(line), stdin) == NULL) { return 0; } if (strlen(line) > 1 && line[0] != '\\n') { hasInput  j++) { grid[i][j] = line[j]  for (int i = 0; i < 12; i++) {  if (grid[i][j] == 1 && !visited[i][j]) { dfs(i, j); islands++; } } } printf(\"%d\\n\", islands); while (fgets(line, sizeof(line), stdin) != NULL) { if (line[0] != '\\n' && strlen(line) > 1) { fseek(stdin, -(long)strlen(line), SEEK_CUR);  } return 0; }"], "perturbed_original": ["#include <stdio.h> char map[16][16] = {0}; void <extra_id_8>} }<extra_id_9>i =<extra_id_10>+ i) while<extra_id_11>(i> 1); }<extra_id_12>(0; i<12; i++){ if<extra_id_13>(j=0; 1); } int main(void) { while (scanf(\"%s\", &map[0][1]) != EOF){ int i, j; int count = 0; for (i = 1; i < 12; i++) scanf(\"%s\",  1] -= '0'; } for (i = 0; i < 12; i++){ for (j = 0; j < 12; j++){ if  } } } printf(\"%d\\n\", count); scanf(\"%*c\"); } return 0; }"], "original_ll": -0.6007340550422668, "sampled_ll": -0.44625216722488403, "all_perturbed_sampled_ll": [-1.409527063369751], "all_perturbed_original_ll": [-1.951968789100647], "perturbed_sampled_ll": -1.409527063369751, "perturbed_original_ll": -1.951968789100647, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u30fb\u30b9\u30bf\u30d6\n\t\tnew Main().run();\n\t}\n\t\n\tint filed[][]=new int[12][12];\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint count=0;\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tchar ch[]=sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\t\tfiled[i][j]=ch[j]-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\t\tif(filed[i][j]==1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tdfs(j,i,12,12);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n    int mx[]={-1,0,1,0};\n    int my[]={0,-1,0,1};\n\tvoid dfs(int x,int y,int w,int h){\n        int i,nx,ny;\n        for(i=0;i<4;i++){\n            nx=x+mx[i];\n            ny=y+my[i];\n            if(0<=nx && nx<w && 0<=ny && ny<h && filed[ny][nx]!=0){\n                filed[ny][nx]=0;\n                dfs(nx,ny,w,h);\n            }\n        }\n    }\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[][] grid;\n    static boolean[][] visited;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            grid = new int[12][12];\n            visited = new boolean[12][12];\n            \n            // Read 12 lines for the grid\n            boolean validInput = true;\n            for (int i = 0; i < 12; i++) {\n                if (!sc.hasNextLine()) {\n                    validInput = false;\n                    break;\n                }\n                String line = sc.nextLine().trim();\n                if (line.isEmpty()) {\n                    validInput = false;\n                    break;\n                }\n                for (int j = 0; j < 12 && j < line.length(); j++) {\n                    grid[i][j] = line.charAt(j) - '0';\n                }\n            }\n            \n            if (!validInput) {\n                break;\n            }\n            \n            // Count islands\n            int islands = 0;\n            for (int i = 0; i < 12; i++) {\n                for (int j = 0; j < 12; j++) {\n                    if (grid[i][j] == 1 && !visited[i][j]) {\n                        dfs(i, j);\n                        islands++;\n                    }\n                }\n            }\n            \n            System.out.println(islands);\n            \n            // Skip empty line between datasets\n            if (sc.hasNextLine()) {\n                String line = sc.nextLine();\n                // If the line is not empty, we need to check if it's the start of next dataset\n                if (!line.trim().isEmpty()) {\n                    // This is the first line of next dataset\n                    grid = new int[12][12];\n                    visited = new boolean[12][12];\n                    \n                    // Process this first line\n                    for (int j = 0; j < 12 && j < line.length(); j++) {\n                        grid[0][j] = line.charAt(j) - '0';\n                    }\n                    \n                    // Read remaining 11 lines\n                    for (int i = 1; i < 12; i++) {\n                        if (!sc.hasNextLine()) break;\n                        line = sc.nextLine().trim();\n                        if (line.isEmpty()) break;\n                        for (int j = 0; j < 12 && j < line.length(); j++) {\n                            grid[i][j] = line.charAt(j) - '0';\n                        }\n                    }\n                    \n                    // Count islands\n                    islands = 0;\n                    for (int i = 0; i < 12; i++) {\n                        for (int j = 0; j < 12; j++) {\n                            if (grid[i][j] == 1 && !visited[i][j]) {\n                                dfs(i, j);\n                                islands++;\n                            }\n                        }\n                    }\n                    \n                    System.out.println(islands);\n                    \n                    // Skip empty line\n                    if (sc.hasNextLine()) {\n                        sc.nextLine();\n                    }\n                }\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static void dfs(int x, int y) {\n        visited[x][y] = true;\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if (nx >= 0 && nx < 12 && ny >= 0 && ny < 12 && \n                grid[nx][ny] == 1 && !visited[nx][ny]) {\n                dfs(nx, ny);\n            }\n        }\n    }\n}\n", "perturbed_sampled": [" boolean[][] visited; static int[] dx = {-1, 1,  public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { grid = new int[12][12]; visited = new boolean[12][12]; // Read 12 lines for the grid  < 12; i++)  line = sc.nextLine().trim(); if (line.isEmpty()) { validInput = false; break; } for (int j = 0; j < 12 && j <  if (!validInput) { break; } // Count islands int islands = 0;  for (int j = 0; j  { dfs(i,  between datasets if (sc.hasNextLine()) { String line = sc.nextLine();  check if it's the start of next dataset if (!line.trim().isEmpty()) { // This is the first line of next dataset grid = new int[12][12]; visited = new  remaining 11 lines for (int i = 1; i < 12; i++) { if (!sc.hasNextLine()) break; line = sc.nextLine().trim(); if (line.isEmpty()) break; for (int j = 0; j < 12 && j < line.length(); j++) { grid[i][j] = line.charAt(j) - '0'; } }  0; i < 12; i++) { for (int j  1 &&  Skip empty line if (sc.hasNextLine()) { sc.nextLine(); } } } } sc.close(); } static void dfs(int x, int y) { visited[x][y]  && nx  && grid[nx][ny] == 1 && !visited[nx][ny]) { dfs(nx, ny); } } } }"], "perturbed_original": [" filed[][]=new  i=0;i<12;i++){ char ch[]=sc.next().toCharArray(); for(int j=0;j<12;j++){ filed[i][j]=ch[j]-'0'; } } for(int i=0;i<12;i++){ for(int j=0;j<12;j++){ if(filed[i][j]==1){ count++; dfs(j,i,12,12); } } } System.out.println(count);  w,int h){ int i,nx,ny; for(i=0;i<4;i++){ nx=x+mx[i]; ny=y+my[i]; if(0<=nx && nx<w && 0<=ny && ny<h && filed[ny][nx]!=0){ filed[ny][nx]=0; dfs(nx,ny,w,h); } } } }"], "original_ll": -0.6422930955886841, "sampled_ll": -0.3691549301147461, "all_perturbed_sampled_ll": [-1.5436816215515137], "all_perturbed_original_ll": [-1.2569944858551025], "perturbed_sampled_ll": -1.5436816215515137, "perturbed_original_ll": -1.2569944858551025, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Depth_First_Search_stack:\n    def __init__(self, map):\n        self.map = map\n        self.num_island = 0\n        self.stack = []\n        self.start_point = None\n\n    def get_start_point(self):\n        get_start = False\n        for i in range(12):\n            for j in range(12):\n                if self.map[i][j] == '1':\n                    self.start_point = [i, j]\n                    get_start = True\n        return get_start\n\n    def check(self, new_r, new_c):\n        return 0<=new_r<12 and 0<=new_c<12 and self.map[new_r][new_c] == '1'\n\n    def search(self, r, c):\n        while self.stack:\n            r, c = self.stack.pop()\n            self.map[r][c] = '0'\n            for (i, j) in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n                if self.check(r+i, c+j):\n                    self.stack.append([r+i, c+j])\n\n    def run(self):\n        while self.get_start_point():\n            r, c = self.start_point\n            self.stack.append([r, c])\n            self.search(r, c)\n            self.num_island += 1\n\nif __name__ == '__main__':\n    while 1:\n        map = []\n        for i in range(12):\n            row = [x for x in input()]\n            map.append(row)\n\n        if len(map[0]) != 12:\n            break\n\n        DFS = Depth_First_Search_stack(map)\n        DFS.run()\n        print(DFS.num_island)\n\n        empty = input()", "sampled": "import sys\nfrom collections import deque\n\ndef count_islands(grid):\n    rows = 12\n    cols = 12\n    visited = [[False] * cols for _ in range(rows)]\n    count = 0\n    \n    def bfs(start_r, start_c):\n        queue = deque([(start_r, start_c)])\n        visited[start_r][start_c] = True\n        \n        while queue:\n            r, c = queue.popleft()\n            # Check 4 directions: up, down, left, right\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == 1:\n                    visited[nr][nc] = True\n                    queue.append((nr, nc))\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1 and not visited[i][j]:\n                bfs(i, j)\n                count += 1\n    \n    return count\n\ndef main():\n    lines = []\n    for line in sys.stdin:\n        lines.append(line.rstrip('\\n'))\n    \n    datasets = []\n    current_dataset = []\n    \n    for line in lines:\n        if line == '':\n            if current_dataset:\n                datasets.append(current_dataset)\n                current_dataset = []\n        else:\n            current_dataset.append(line)\n    \n    if current_dataset:\n        datasets.append(current_dataset)\n    \n    for dataset in datasets:\n        grid = []\n        for line in dataset:\n            row = [int(c) for c in line]\n            grid.append(row)\n        \n        result = count_islands(grid)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from collections import deque def  * cols for _ in range(rows)]  visited[start_r][start_c] = True while queue: r, c  for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  < cols and not visited[nr][nc] and grid[nr][nc] == 1: visited[nr][nc] = True queue.append((nr, nc)) for i in range(rows): for j in range(cols): if grid[i][j] == 1 and not visited[i][j]: bfs(i, j) count += 1 return count def  = [] current_dataset =  current_dataset: datasets.append(current_dataset) current_dataset = [] else: current_dataset.append(line) if current_dataset: datasets.append(current_dataset) for  = count_islands(grid) print(result) if __name__ == \"__main__\": main()"], "perturbed_original": ["class Depth_First_Search_stack: +<extra_id_5># print(self.stack[n][i]+self.stack[n][i]),<extra_id_6>for j in [1, 0],<extra_id_7>(i, j) =<extra_id_8>0, 1] map.push(0) map<extra_id_9>1] = 2 self = [] self.start_point = None def get_start_point(self):  range(12): if self.map[i][j] == '1': self.start_point = [i, j] get_start = True  self.stack: r, c = self.stack.pop() self.map[r][c] = '0' for (i, j) in [[1, 0], [0, 1], [-1, 0], [0, -1]]: if self.check(r+i, c+j): self.stack.append([r+i, c+j]) def run(self): while self.get_start_point(): r, c = self.start_point self.stack.append([r, c]) self.search(r, c) self.num_island += 1 if __name__ == '__main__': while 1: map = [] for i in range(12):  = input()"], "original_ll": -0.6992121338844299, "sampled_ll": -0.3730326294898987, "all_perturbed_sampled_ll": [-1.4934190511703491], "all_perturbed_original_ll": [-2.172569990158081], "perturbed_sampled_ll": -1.4934190511703491, "perturbed_original_ll": -2.172569990158081, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x,y;\n} xy_t;\n\nint qsort_comp(const void* x,const void* y) {\n\tconst xy_t* a=(const xy_t*)x;\n\tconst xy_t* b=(const xy_t*)y;\n\tif((a->x)>(b->x))return 1;\n\tif((a->x)<(b->x))return -1;\n\tif((a->y)>(b->y))return 1;\n\tif((a->y)<(b->y))return -1;\n\treturn 0;\n}\n\nint zahyou_num;\nxy_t zahyou[100];\n\nint th_up_n;\nint th_down_n;\nxy_t th_up[100];\nxy_t th_down[100];\n\nint main(void) {\n\tint i;\n\twhile(1) {\n\t\tscanf(\"%d\",&zahyou_num);\n\t\tif(zahyou_num==0)break;\n\t\tfor(i=0;i<zahyou_num;i++) {\n\t\t\tscanf(\"%lf,%lf\",&zahyou[i].x,&zahyou[i].y);\n\t\t}\n\t\tqsort(zahyou,zahyou_num,sizeof(xy_t),qsort_comp);\n\t\t//sita no totu-ho\n\t\tth_down_n=1;\n\t\tth_down[0].x=zahyou[0].x;\n\t\tth_down[0].y=zahyou[0].y;\n\t\tfor(i=1;i<zahyou_num;i++) {\n\t\t\t//if(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\twhile(th_down_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_down[th_down_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_down[th_down_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_down[th_down_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_down[th_down_n-1].x==th_down[th_down_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_down[th_down_n-1].y<th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else if(th_down[th_down_n-1].y>th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_down[th_down_n-1].y-th_down[th_down_n-2].y)/\n\t\t\t\t\t\t   (th_down[th_down_n-1].x-th_down[th_down_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_down_n--;\n\t\t\t\t}\n\t\t\t//}\n\t\t\tth_down[th_down_n].x=zahyou[i].x;\n\t\t\tth_down[th_down_n].y=zahyou[i].y;\n\t\t\tth_down_n++;\n\t\t}\n\t\t//ue no totu-ho\n\t\tth_up_n=1;\n\t\tth_up[0].x=zahyou[zahyou_num-1].x;\n\t\tth_up[0].y=zahyou[zahyou_num-1].y;\n\t\tfor(i=zahyou_num-2;i>=0;i--) {\n\t\t\t//if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\twhile(th_up_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_up[th_up_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_up[th_up_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_up[th_up_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_up[th_up_n-1].x==th_up[th_up_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_up[th_up_n-1].y<th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else if(th_up[th_up_n-1].y>th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_up[th_up_n-1].y-th_up[th_up_n-2].y)/\n\t\t\t\t\t\t   (th_up[th_up_n-1].x-th_up[th_up_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_up_n--;\n\t\t\t\t}\n\t\t\t//}\n\t\t\tth_up[th_up_n].x=zahyou[i].x;\n\t\t\tth_up[th_up_n].y=zahyou[i].y;\n\t\t\tth_up_n++;\n\t\t}\n\t\tprintf(\"%d\\n\",zahyou_num-(th_down_n+th_up_n-2));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross(Point O, Point A, Point B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nint convexHull(Point points[], int n, int hull[]) {\n    int k = 0;\n    \n    // Find bottommost point (or leftmost in case of tie)\n    int minIdx = 0;\n    for (int i = 1; i < n; i++) {\n        if (points[i].y < points[minIdx].y || \n            (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {\n            minIdx = i;\n        }\n    }\n    \n    // Start from bottommost point\n    int current = minIdx;\n    do {\n        hull[k++] = current;\n        int next = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == current) continue;\n            \n            if (next == current) {\n                next = i;\n            } else {\n                double cp = cross(points[current], points[next], points[i]);\n                if (cp < 0 || (cp == 0 && \n                    (pow(points[i].x - points[current].x, 2) + pow(points[i].y - points[current].y, 2)) >\n                    (pow(points[next].x - points[current].x, 2) + pow(points[next].y - points[current].y, 2)))) {\n                    next = i;\n                }\n            }\n        }\n        current = next;\n    } while (current != minIdx);\n    \n    return k;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Point points[100];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf,%lf\", &points[i].x, &points[i].y);\n        }\n        \n        if (n == 3) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        int hull[100];\n        int hullSize = convexHull(points, n, hull);\n        \n        printf(\"%d\\n\", n - hullSize);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> typedef struct { double x, y; }  (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x); } int convexHull(Point  tie) int minIdx  i++) { if (points[i].y < points[minIdx].y || (points[i].y ==  } // Start from bottommost point int current   current) { next = i; } else { double cp = cross(points[current], points[next], points[i]);  - points[current].x,  2) + pow(points[next].y -  = next; } while (current  while (scanf(\"%d\", &n) == 1 && n != 0) { Point points[100]; for (int i = 0; i < n; i++) { scanf(\"%lf,%lf\", &points[i].x, &points[i].y); } if (n == 3) { printf(\"0\\n\"); continue; } int hull[100]; int hullSize = convexHull(points, n, hull); printf(\"%d\\n\", n - hullSize); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> typedef struct { double x,y; } xy_t; int qsort_comp(const void* x,const void* y) { const xy_t* a=(const  1; if((a->y)<(b->y))return -1; return 0;  th_up[100]; xy_t th_down[100]; int main(void) { int i;  no totu-ho  k1,k2; if(zahyou[i].x==th_down[th_down_n-1].x) { //INF if(zahyou[i].y<th_down[th_down_n-1].y) { k1=-1e+200; } else if(zahyou[i].y>th_down[th_down_n-1].y) { k1=1e+200; } else k1=0; } else {  else  (th_down[th_down_n-1].x-th_down[th_down_n-2].x); } if(k1>=k2)break; th_down_n--; } //} th_down[th_down_n].x=zahyou[i].x; th_down[th_down_n].y=zahyou[i].y; th_down_n++; } //ue no totu-ho  if(zahyou[i].y>th_up[th_up_n-1].y) { k1=-1e+200; } else k1=0; } else { k1=(zahyou[i].y-th_up[th_up_n-1].y)/ (zahyou[i].x-th_up[th_up_n-1].x); } if(th_up[th_up_n-1].x==th_up[th_up_n-2].x) { //INF  k2=0; } else { k2=(th_up[th_up_n-1].y-th_up[th_up_n-2].y)/ (th_up[th_up_n-1].x-th_up[th_up_n-2].x); } if(k1>=k2)break; th_up_n--; } //} th_up[th_up_n].x=zahyou[i].x; th_up[th_up_n].y=zahyou[i].y; th_up_n++; } printf(\"%d\\n\",zahyou_num-(th_down_n+th_up_n-2)); } return 0; }"], "original_ll": -0.3329019248485565, "sampled_ll": -0.4406387209892273, "all_perturbed_sampled_ll": [-1.7565536499023438], "all_perturbed_original_ll": [-1.1783246994018555], "perturbed_sampled_ll": -1.7565536499023438, "perturbed_original_ll": -1.1783246994018555, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\t\n\tclass Point{\n\t\tpublic double x,y;\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t\t\n\t\tpublic Point(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\t\n\tdouble getTheta(Point p,Point p0){\n\t\tdouble theta=Math.acos((p.x-p0.x)/Math.hypot(p.x-p0.x,p.y-p0.y));\n\t\tif(p.y<p0.y)theta=Math.PI*2-theta;\n\t\treturn theta;\n\t}\n\t\n\tint solve(Point[] points){\n\t\tPoint start=points[0];\n\t\tfor(Point v:points){\n\t\t\tif(v.y<start.y)start=v;\n\t\t}\n\t\tPoint p0=start;\n\t\tint n=0;\n\t\tdouble prev=0;\n\t\tdo{\n\t\t\tdouble min=Math.PI*3;\n\t\t\tPoint next=p0;\n\t\t\tfor(Point p: points){\n\t\t\t\tdouble theta=getTheta(p,p0);\n\t\t\t\tif(theta>=prev&&theta<min){\n\t\t\t\t\tmin=theta;\n\t\t\t\t\tnext=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp0=next;\n\t\t\tprev=min;\n\t\t\t++n;\n\t\t}while(p0!=start);\n\t\treturn points.length-n;\n\t}\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in).useDelimiter(\",|\\r\\n|\\n\");\n\t\t\n\t\tint n;\n\t\tPoint[] points;\n\t\twhile((n=ni())!=0){\n\t\t\tpoints=new Point[n];\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tpoints[i]=new Point(nd(),nd());\n\t\t\t}\n\t\t\tSystem.out.println(solve(points));\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            Point[] points = new Point[n];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\",\");\n                double x = Double.parseDouble(parts[0]);\n                double y = Double.parseDouble(parts[1]);\n                points[i] = new Point(x, y);\n            }\n            \n            List<Integer> hull = convexHull(points);\n            System.out.println(n - hull.size());\n        }\n    }\n    \n    static List<Integer> convexHull(Point[] points) {\n        int n = points.length;\n        if (n < 3) {\n            List<Integer> result = new ArrayList<>();\n            for (int i = 0; i < n; i++) result.add(i);\n            return result;\n        }\n        \n        // Find the bottommost point (or leftmost in case of tie)\n        int start = 0;\n        for (int i = 1; i < n; i++) {\n            if (points[i].y < points[start].y || \n                (points[i].y == points[start].y && points[i].x < points[start].x)) {\n                start = i;\n            }\n        }\n        \n        List<Integer> hull = new ArrayList<>();\n        int current = start;\n        \n        do {\n            hull.add(current);\n            int next = (current + 1) % n;\n            \n            for (int i = 0; i < n; i++) {\n                if (i == current) continue;\n                double cross = crossProduct(points[current], points[next], points[i]);\n                if (cross > 0) {\n                    next = i;\n                } else if (cross == 0) {\n                    // Collinear points - choose the farthest one\n                    if (distance(points[current], points[i]) > distance(points[current], points[next])) {\n                        next = i;\n                    }\n                }\n            }\n            \n            current = next;\n        } while (current != start);\n        \n        return hull;\n    }\n    \n    static double crossProduct(Point o, Point a, Point b) {\n        return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n    }\n    \n    static double distance(Point a, Point b) {\n        double dx = a.x - b.x;\n        double dy = a.y - b.y;\n        return dx * dx + dy * dy;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main {  }  = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { int n = Integer.parseInt(line.trim()); if (n == 0) break; Point[] points = new Point[n]; for (int i  points[i] = new Point(x, y); } List<Integer> hull = convexHull(points); System.out.println(n - hull.size()); } } static List<Integer> convexHull(Point[] points) { int n = points.length; if (n < 3) { List<Integer> result = new ArrayList<>();  return result; } // Find the  = 0; for (int i = 1; i < n; i++) {  { hull.add(current); int  = 0; i < n; i++) { if (i == current) continue; double cross  = i; } else if (cross == 0) { // Collinear points -  { next = i; } } } current = next; } while (current != start); return hull; } static double crossProduct(Point o, Point a, Point b) {  - o.y) *  { double  b.y; return dx * dx + dy * dy; } }"], "perturbed_original": ["import java.util.Scanner; public  y){ this.x=x; this.y=y; } } double getTheta(Point p,Point p0){ double theta=Math.acos((p.x-p0.x)/Math.hypot(p.x-p0.x,p.y-p0.y)); if(p.y<p0.y)theta=Math.PI*2-theta; return theta; } int solve(Point[] points){ Point start=points[0]; for(Point v:points){ if(v.y<start.y)start=v; } Point p0=start; int n=0; double prev=0; do{ double min=Math.PI*3; Point next=p0; for(Point p: points){ double  return points.length-n;  } void io(){ sc=new Scanner(System.in).useDelimiter(\",|\\r\\n|\\n\");  Point(nd(),nd()); } System.out.println(solve(points)); } sc.close(); } public static void main(String[] args) { // TODO Auto-generated method stub new Main().io(); } }"], "original_ll": -0.7825383543968201, "sampled_ll": -0.3424190282821655, "all_perturbed_sampled_ll": [-1.633710503578186], "all_perturbed_original_ll": [-1.9133156538009644], "perturbed_sampled_ll": -1.633710503578186, "perturbed_original_ll": -1.9133156538009644, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f(x,y,x1,y1,x2,y2):\n    if x1 <= x2:\n        return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1\n    else:\n        return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1)\n\ndef DC(a):\n    if len(a) > 3:\n        # Divide\n        la = a[:len(a)/2]\n        ra = a[len(a)/2:]\n        # Conquer\n        la,ra = DC(la),DC(ra)\n        while f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0 and len(ra) > 1:\n            ra.pop(0)\n        while f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0 and len(la) > 1:\n            la.pop(-1)\n        return la+ra\n    else:\n        return a\n\nwhile True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(map(float, raw_input().split(\",\")))\n    p = sorted(p, key = lambda x: x[0])\n    print n - len(DC(p))", "sampled": "def cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef convex_hull(points):\n    points = sorted(points)\n    if len(points) <= 1:\n        return points\n    \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    points = []\n    for _ in range(n):\n        line = input().strip()\n        x, y = map(float, line.split(','))\n        points.append((x, y))\n    \n    hull = convex_hull(points)\n    hull_set = set(hull)\n    \n    count = 0\n    for p in points:\n        if p not in hull_set:\n            count += 1\n    \n    print(count)\n", "perturbed_sampled": ["def cross(o, a, b): return  o[1]) * (b[0] - o[0]) def convex_hull(points): points = sorted(points) if len(points) <=  0:  upper.pop() upper.append(p) return lower[:-1] + upper[:-1] while True: n = int(input()) if n == 0: break points = [] for _ in  y)) hull = convex_hull(points) hull_set = set(hull) count = 0 for p in points: if p not in hull_set: count += 1 print(count)"], "perturbed_original": ["def f(x,y,x1,y1,x2,y2): if x1 <= x2: return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1 else: return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1) def DC(a): if  0 and len(ra) > 1: ra.pop(0) while  else:  0: break p = [] for i in range(n): p.append(map(float, raw_input().split(\",\"))) p = sorted(p, key = lambda x: x[0]) print n - len(DC(p))"], "original_ll": -0.7144041657447815, "sampled_ll": -0.3761083781719208, "all_perturbed_sampled_ll": [-2.0055665969848633], "all_perturbed_original_ll": [-1.8118256330490112], "perturbed_sampled_ll": -2.0055665969848633, "perturbed_original_ll": -1.8118256330490112, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint i, j;\nint flag;\nint n;\nint m;\nint atari;\nint d;\nchar amida[11][31];\nint temp[10], keep[10];\n\nint check_amida(void){\n\tint k, l;\n\tfor (k = 0; k < d; k++){\n\t\tfor (l = 0; l < n - 1; l++){\n\t\t\tif (amida[k][l] == '1'){\n\t\t\t\ttemp[l] += temp[l + 1];\n\t\t\t\ttemp[l + 1] = temp[l] - temp[l + 1];\n\t\t\t\ttemp[l] -= temp[l + 1];\n\t\t\t}\n\t\t}\n\t}\n\tif (temp[atari - 1] == m){\n\t\treturn (1);\n\t}\n\telse {\n\t\treturn (0);\n\t}\n}\n\nint ins_amida(int a, int b){\n\tint res;\n\tamida[a][b] = '1';\n\tres = check_amida();\n\tamida[a][b] = '0';\n\t\n\treturn (res);\n}\n\nint main(void)\n{\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tif (!n){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\ttemp[i] = i + 1;\n\t\t\tkeep[i] = i + 1;\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &atari);\n\t\tscanf(\"%d\", &d);\n\t\t\n\t\tfor (i = 0; i < d; i++){\n\t\t\tscanf(\"%s\", amida[i]);\n\t\t\tgetchar();\n\t\t}\n\t\t\n\t\tflag = 0;\n\t\t\n\t\tif (check_amida() == 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tflag = 1;\n\t\t}\n\t\tif (flag == 0){\n\t\t\tfor (i = 0; i < d; i++){\n\t\t\t\tfor (j = 0; j < n - 1; j++){\n\t\t\t\t\tmemcpy(temp, keep, sizeof(keep));\n\t\t\t\t\tif (amida[i][j] == '1'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (j > 0){\n\t\t\t\t\t\tif (amida[i][j - 1] == '1'){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j != n - 2){\n\t\t\t\t\t\tif (amida[i][j + 1] == '1'){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ins_amida(i, j) == 1){\n\t\t\t\t\t\tprintf(\"%d %d\\n\", i + 1, j + 1);\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag == 1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag == 0){\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint n, m, target, d;\nint amida[31][10];\n\nint trace(int start, int skipRow, int skipCol) {\n    int pos = start;\n    for (int row = 1; row <= d; row++) {\n        if (row == skipRow && skipCol == pos && amida[row][pos] == 0) {\n            pos++;\n        } else if (row == skipRow && skipCol == pos - 1 && amida[row][pos - 1] == 0) {\n            pos--;\n        } else if (pos > 1 && amida[row][pos - 1] == 1) {\n            pos--;\n        } else if (pos < n && amida[row][pos] == 1) {\n            pos++;\n        }\n    }\n    return pos;\n}\n\nint canAdd(int row, int col) {\n    if (amida[row][col] == 1) return 0;\n    if (col > 1 && amida[row][col - 1] == 1) return 0;\n    if (col < n - 1 && amida[row][col + 1] == 1) return 0;\n    return 1;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        scanf(\"%d\", &m);\n        scanf(\"%d\", &target);\n        scanf(\"%d\", &d);\n        \n        for (int i = 1; i <= d; i++) {\n            char line[11];\n            scanf(\"%s\", line);\n            for (int j = 0; j < n - 1; j++) {\n                amida[i][j + 1] = line[j] - '0';\n            }\n        }\n        \n        int result = trace(m, -1, -1);\n        if (result == target) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        int found = 0;\n        for (int row = 1; row <= d && !found; row++) {\n            for (int col = 1; col < n && !found; col++) {\n                if (canAdd(row, col)) {\n                    int res = trace(m, row, col);\n                    if (res == target) {\n                        printf(\"%d %d\\n\", row, col);\n                        found = 1;\n                    }\n                }\n            }\n        }\n        \n        if (!found) {\n            printf(\"1\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int n, m, target, d; int amida[31][10]; int trace(int start, int skipRow, int skipCol) { int pos = start; for (int row = 1; row  ==  &&  (pos > 1 &&  (pos < n && amida[row][pos] == 1) { pos++; } }  (amida[row][col]  - 1] == 1)  + 1] == 1) return 0; return 1; } int main()  i = 1; i <= d; i++) { char line[11]; scanf(\"%s\", line); for (int j = 0; j < n - 1; j++) { amida[i][j + 1] = line[j] - '0'; } } int result = trace(m, -1, -1); if (result == target) { printf(\"0\\n\"); continue; } int found = 0; for (int row = 1; row <= d && !found; row++) {  trace(m, row, col); if (res == target) { printf(\"%d %d\\n\", row, col); found = 1; } }  }"], "perturbed_original": ["#include  temp[10], keep[10]; int check_amida(void){ int k,  if (amida[k][l] == '1'){ temp[l] += temp[l + 1]; temp[l + 1] = temp[l] - temp[l + 1]; temp[l] -= temp[l +  (!n){ break; } for (i = 0; i < n; i++){ temp[i] = i + 1; keep[i] = i + 1; } scanf(\"%d\", &m); scanf(\"%d\", &atari); scanf(\"%d\", &d); for (i = 0; i < d; i++){ scanf(\"%s\", amida[i]); getchar(); } flag =  if (flag == 0){ for (i  j < n - 1; j++){ memcpy(temp, keep, sizeof(keep)); if (amida[i][j] == '1'){ continue; } if (j > 0){ if (amida[i][j - 1] == '1'){ continue; } } if  '1'){ continue; } } if (ins_amida(i, j) == 1){ printf(\"%d %d\\n\", i + 1, j + 1); flag  } } } if (flag == 0){ printf(\"1\\n\"); } } return (0); }"], "original_ll": -0.6479200124740601, "sampled_ll": -0.5696433782577515, "all_perturbed_sampled_ll": [-1.6861978769302368], "all_perturbed_original_ll": [-1.607645034790039], "perturbed_sampled_ll": -1.6861978769302368, "perturbed_original_ll": -1.607645034790039, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tString string;\n\t\t\n\t\twhile(!(string = reader.readLine()).equals(\"0\")){\n\t\t\tint n = Integer.valueOf(string);\n\t\t\tint m = Integer.valueOf(reader.readLine()) - 1;\n\t\t\tint a = Integer.valueOf(reader.readLine()) - 1;\n\t\t\tint d = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint node[][] = new int[n - 1][d];\n\t\t\tfor(int i = 0; i < d; i++){\n\t\t\t\tstring = reader.readLine();\n\t\t\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\t\t\tnode[j][i] = string.charAt(j) - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(doing(node, n, m, d) == a){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tboolean judge = false;\n\t\t\t\tx : for(int i = 0; i < d; i++){\n\t\t\t\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\t\t\t\tif(j + 1 < n && j - 1 >= 0)\n\t\t\t\t\t\tif(node[j][i] == 0){\n\t\t\t\t\t\t\tnode[j][i] = 1;\n\t\t\t\t\t\t\tif(doing(node, n, m, d) == a){\n\t\t\t\t\t\t\t\tSystem.out.println((i + 1) + \" \" + (j + 1));\n\t\t\t\t\t\t\t\tjudge = true;\n\t\t\t\t\t\t\t\tbreak x;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnode[j][i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!judge) System.out.println(1);\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t}\n\t\n\tpublic static int doing(int node[][], int n, int s, int d){\n\t\tfor(int i = 0; i < d; i++){\n\t\t\tif(s > 0 && node[s - 1][i] == 1) s--;\n\t\t\telse if(s < n - 1 && node[s][i] == 1) s++;\n\t\t}\n\t\treturn s;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int m = sc.nextInt();\n            int target = sc.nextInt();\n            int d = sc.nextInt();\n            \n            int[][] ladder = new int[d][n - 1];\n            for (int i = 0; i < d; i++) {\n                String line = sc.next();\n                for (int j = 0; j < n - 1; j++) {\n                    ladder[i][j] = line.charAt(j) - '0';\n                }\n            }\n            \n            // Check if we can reach without adding\n            int result = traverse(ladder, m - 1, d, n);\n            if (result == target - 1) {\n                System.out.println(0);\n                continue;\n            }\n            \n            // Try adding one horizontal line\n            boolean found = false;\n            for (int row = 0; row < d; row++) {\n                for (int col = 0; col < n - 1; col++) {\n                    if (canAddLine(ladder, row, col, n)) {\n                        ladder[row][col] = 1;\n                        int newResult = traverse(ladder, m - 1, d, n);\n                        if (newResult == target - 1) {\n                            System.out.println((row + 1) + \" \" + (col + 1));\n                            found = true;\n                            ladder[row][col] = 0;\n                            break;\n                        }\n                        ladder[row][col] = 0;\n                    }\n                }\n                if (found) break;\n            }\n            \n            if (!found) {\n                System.out.println(1);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static int traverse(int[][] ladder, int start, int d, int n) {\n        int pos = start;\n        for (int row = 0; row < d; row++) {\n            // Check left\n            if (pos > 0 && ladder[row][pos - 1] == 1) {\n                pos--;\n            }\n            // Check right\n            else if (pos < n - 1 && ladder[row][pos] == 1) {\n                pos++;\n            }\n        }\n        return pos;\n    }\n    \n    static boolean canAddLine(int[][] ladder, int row, int col, int n) {\n        if (ladder[row][col] == 1) {\n            return false;\n        }\n        \n        // Check if adjacent positions have lines\n        if (col > 0 && ladder[row][col - 1] == 1) {\n            return false;\n        }\n        if (col < n - 2 && ladder[row][col + 1] == 1) {\n            return false;\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n =  int target = sc.nextInt(); int d = sc.nextInt(); int[][] ladder = new int[d][n  i++) { String line = sc.next(); for (int j  = line.charAt(j) - '0'; } } // Check if we can reach without adding int result = traverse(ladder, m  { System.out.println(0); continue; } // Try adding one horizontal line  < d; row++) { for (int col = 0; col  n)) { ladder[row][col] = 1; int newResult = traverse(ladder, m -   traverse(int[][] ladder, int start, int d, int n) { int pos = start; for (int row = 0; row < d; row++) {  1] == 1) { pos--; } // Check  == 1) {  int row, int col, int   0 && ladder[row][col - 1] == 1) { return false; } if (col < n - 2 && ladder[row][col + 1] == 1) { return false; } return true; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main{ public static void main(String[] args)throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader reader = new  int m = Integer.valueOf(reader.readLine()) - 1; int  node[][] = new int[n - 1][d]; for(int i = 0; i < d; i++){ string = reader.readLine(); for(int j = 0; j  } } if(doing(node, n, m, d) ==  for(int i = 0; i  = 1; if(doing(node, n, m, d) == a){ System.out.println((i + 1) + \" \" + (j +  } } } if(!judge) System.out.println(1); } } reader.close(); } public static int doing(int node[][], int  < d; i++){ if(s  if(s < n - 1 && node[s][i] == 1) s++; } return s; } }"], "original_ll": -0.7000569701194763, "sampled_ll": -0.510989248752594, "all_perturbed_sampled_ll": [-1.952152967453003], "all_perturbed_original_ll": [-1.9009177684783936], "perturbed_sampled_ll": -1.952152967453003, "perturbed_original_ll": -1.9009177684783936, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nimport itertools\n\n\ndef one_step(lo,lis):\n    nu = [ e for e in lis ]\n    for j in xrange(len(nu)):\n        if lo[0][j] == 1:\n            nu[j],nu[j+1] = nu[j+1],nu[j]\n    return lo[1:],nu\n\n\ndef solve(lo,lis):\n    if len(lo) == 0:\n        return lis\n    nu = [ e for e in lis]\n    lo2,nu2 = one_step(lo,nu)\n    return solve(lo2,nu2)\n\nn = input()\nm = input()\nstar = input()\nd = input()\nlis = range(n+1)\nlots = []\nfor i in xrange(d):\n    lots.append([0]+[ 1 if e == '1' else 0 for e in list(raw_input()) ] +[0])\n\nif solve(lots,lis)[star] == m: print 0;exit()\nfor i in xrange(d):\n    for j in xrange(1,n):\n        if lots[0][j-1] == 0 and lots[0][j] == 0 and lots[0][j+1] == 0:\n            lots[0][j] = 1\n            if solve(lots,lis)[star] == m: print i+1,j;exit()\n            lots[0][j] = 0\n    lots,lis = one_step(lots,lis)\nprint 1", "sampled": "def follow_amida(n, start, lines):\n    pos = start\n    for line in lines:\n        if pos > 1 and line[pos-2] == 1:\n            pos -= 1\n        elif pos < n and line[pos-1] == 1:\n            pos += 1\n    return pos\n\ndef can_add_line(lines, level, bridge_pos):\n    # Check if we can add a horizontal line at level between bridge_pos and bridge_pos+1\n    line = lines[level]\n    \n    # Check if there's already a line there\n    if line[bridge_pos] == 1:\n        return False\n    \n    # Check left neighbor\n    if bridge_pos > 0 and line[bridge_pos-1] == 1:\n        return False\n    \n    # Check right neighbor\n    if bridge_pos < len(line) - 1 and line[bridge_pos+1] == 1:\n        return False\n    \n    return True\n\ndef solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        m = int(input())\n        target = int(input())\n        d = int(input())\n        \n        lines = []\n        for _ in range(d):\n            line_str = input().strip()\n            line = [int(c) for c in line_str]\n            lines.append(line)\n        \n        # Check if already reaches target without adding any line\n        result = follow_amida(n, m, lines)\n        if result == target:\n            print(0)\n            continue\n        \n        # Try adding one line at each possible position\n        found = False\n        for level in range(d):\n            for bridge_pos in range(n-1):\n                if can_add_line(lines, level, bridge_pos):\n                    # Make a copy and add the line\n                    new_lines = [line[:] for line in lines]\n                    new_lines[level][bridge_pos] = 1\n                    \n                    # Check if this reaches target\n                    result = follow_amida(n, m, new_lines)\n                    if result == target:\n                        print(level + 1, bridge_pos + 1)\n                        found = True\n                        break\n            if found:\n                break\n        \n        if not found:\n            print(1)\n\nsolve()\n", "perturbed_sampled": ["def follow_amida(n, start, lines): pos = start for line in lines: if pos > 1 and line[pos-2] == 1: pos -= 1  1 return pos def can_add_line(lines, level, bridge_pos): # Check  bridge_pos  a line there if line[bridge_pos] == 1: return False # Check left neighbor if bridge_pos > 0 and line[bridge_pos-1] == 1: return False # Check right neighbor if bridge_pos < len(line) - 1 and line[bridge_pos+1] == 1: return False  n == 0: break m = int(input()) target = int(input()) d = int(input()) lines = [] for _ in  adding any line result = follow_amida(n,  adding one line at each possible position  and add the line new_lines = [line[:] for line in lines] new_lines[level][bridge_pos] = 1 # Check if this reaches target result = follow_amida(n, m, new_lines)  found: print(1) solve()"], "perturbed_original": ["import sys import itertools def one_step(lo,lis): nu = [ e for e in lis ] for j in xrange(len(nu)): if  if len(lo) == 0: return lis nu = [ e for e in lis] lo2,nu2 = one_step(lo,nu) return solve(lo2,nu2)  = input() lis = range(n+1) lots = [] for i in xrange(d): lots.append([0]+[ 1 if  lots[0][j] = 1 if solve(lots,lis)[star] == m: print i+1,j;exit() lots[0][j] = 0 lots,lis = one_step(lots,lis) print 1"], "original_ll": -1.2507563829421997, "sampled_ll": -0.7855983972549438, "all_perturbed_sampled_ll": [-2.2162139415740967], "all_perturbed_original_ll": [-2.6951658725738525], "perturbed_sampled_ll": -2.2162139415740967, "perturbed_original_ll": -2.6951658725738525, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint num[10]={1,2,3,4,5,6,7,8,9,0}, dp[11][331];\n#define exch(A,B) {int t; t=A, A=B, B=t;}\n\n/* k\u0095\u00b6\u008e\u009a\u0096\u00da\u0082\u00f0\u008c\u0088\u0082\u00df\u0082\u00e9, s\u0082\u00c9\u0082\u00cd\u0082\u00bb\u0082\u00cc\u008e\u009e\u0093_\u0082\u00c5\u0082\u00cc\u0098a\u0082\u00f0\u0083\u0081\u0083\u0082 */\nvoid solve(int k, int s){\n     int i, j, ts;\n\n     for(i=k; i<10; i++){\n\t  exch(num[i],num[k]);\n\n\t  /* n=k\u0082\u00c5\u0082\u00ccs\u0082\u00f0\u008bL\u0098^ */\n\t  ts=s;\n\t  ts+=num[k]*(k+1);\n\t  dp[k+1][ts]++;\n\n\t  if(k<9) solve(k+1,ts);\n\n\t  exch(num[i],num[k]);\n     }\n}\n\nint main(int argc, char *argv[]){\n     int n, s;\n\n     solve(0,0);\n     \n     while(~scanf(\"%d %d\",&n,&s))\n\t  printf(\"%d\\n\",(n<=10 && s<=330)?dp[n][s]:0);\n\n     return 0;\n}", "sampled": "#include <stdio.h>\n\nint n, s;\nint count;\nint used[10];\nint seq[11];\n\nvoid solve(int pos, int sum) {\n    if (pos > n) {\n        if (sum == s) {\n            count++;\n        }\n        return;\n    }\n    \n    for (int i = 0; i <= 9; i++) {\n        if (!used[i]) {\n            used[i] = 1;\n            seq[pos] = i;\n            solve(pos + 1, sum + pos * i);\n            used[i] = 0;\n        }\n    }\n}\n\nint main() {\n    while (scanf(\"%d %d\", &n, &s) == 2) {\n        count = 0;\n        for (int i = 0; i <= 9; i++) {\n            used[i] = 0;\n        }\n        solve(1, 0);\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int n, s; int count;  0; i <= 9; i++) { if (!used[i]) { used[i] = 1; seq[pos] = i; solve(pos  }  == 2) { count = 0; for (int i = 0; i <= 9; i++) { used[i] = 0; } solve(1, 0); printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include <stdio.h> int num[10]={1,2,3,4,5,6,7,8,9,0}, dp[11][331]; #define exch(A,B) {int t; t=A, A=B, B=t;} /* k\u0095\u00b6\u008e\u009a\u0096\u00da\u0082\u00f0\u008c\u0088\u0082\u00df\u0082\u00e9, s\u0082\u00c9\u0082\u00cd\u0082\u00bb\u0082\u00cc\u008e\u009e\u0093_\u0082\u00c5\u0082\u00cc\u0098a\u0082\u00f0\u0083\u0081\u0083\u0082 */ void solve(int k, int s){  */ ts=s; ts+=num[k]*(k+1); dp[k+1][ts]++; if(k<9) solve(k+1,ts); exch(num[i],num[k]);  solve(0,0); while(~scanf(\"%d %d\",&n,&s)) printf(\"%d\\n\",(n<=10 && s<=330)?dp[n][s]:0); return 0; }"], "original_ll": -1.7130074501037598, "sampled_ll": -0.5045537948608398, "all_perturbed_sampled_ll": [-1.8444007635116577], "all_perturbed_original_ll": [-2.0974338054656982], "perturbed_sampled_ll": -1.8444007635116577, "perturbed_original_ll": -2.0974338054656982, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * Combination of Number Sequences\n */\npublic class Main {\n\n\tstatic int count;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint s = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tcount = 0;\n\t\t\tsolve(0, n, 1, s);\n\t\t\tSystem.out.println(count);\n\n\t\t}\n\n\t}\n\n\tstatic void solve(int p, int n, int a, int s) {\n\n\t\tif (p > 9 || n <= 0 || p * a > s) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (n == 1 && p * a == s) {\n\t\t\t++count;\n\t\t} else {\n\t\t\tsolve(p + 1, n - 1, a + 1, s - p * a);\n\t\t\tsolve(p + 1, n, a, s);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int n, s;\n    static int count;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            n = sc.nextInt();\n            s = sc.nextInt();\n            \n            count = 0;\n            boolean[] used = new boolean[10];\n            solve(1, 0, used);\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n    \n    static void solve(int pos, int sum, boolean[] used) {\n        if (pos > n) {\n            if (sum == s) {\n                count++;\n            }\n            return;\n        }\n        \n        for (int i = 0; i <= 9; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                solve(pos + 1, sum + pos * i, used);\n                used[i] = false;\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  count; public static void main(String[] args) { Scanner sc  = sc.nextInt(); count = 0; boolean[] used = new boolean[10]; solve(1, 0, used); System.out.println(count); } sc.close(); }  (pos > n) { if  i = 0; i <= 9; i++)  sum + pos * i, used); used[i] = false; } } } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; /** * Combination of Number Sequences */ public class Main { static int count; public static void main(String[] args) throws IOException { BufferedReader br = new  != null && !line.isEmpty()) { int n = Integer.parseInt(line.substring(0,  = 0; solve(0, n, 1, s); System.out.println(count); } }  || p * a > s) { return; } if (n == 1 && p * a == s) { ++count; } else  a, s); } } }"], "original_ll": -0.7200961112976074, "sampled_ll": -0.5139693021774292, "all_perturbed_sampled_ll": [-2.4054300785064697], "all_perturbed_original_ll": [-2.0929226875305176], "perturbed_sampled_ll": -2.4054300785064697, "perturbed_original_ll": -2.0929226875305176, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport sys\nimport itertools\n\n\ntable = [[], [], [], [], [], [], [], [], [], [], []]\n\ndef solv(n, s):\n    if s > 330:\n        return 0\n    dp = table[n]\n    if dp:\n        return dp[s]\n    else:\n        for i in xrange(331):\n            dp.append(0)\n        for p in itertools.permutations(xrange(10), n):\n            s0 = foo(p, n)\n            dp[s0] += 1\n        return dp[s]\n\n\ndef foo(perm, n):\n    return sum(map(lambda x, y: x * y, xrange(1, n+1), perm))\n\n\nfor line in sys.stdin:\n    n, s = map(int, line.split(' '))\n    print solv(n, s)", "sampled": "import sys\nfrom itertools import permutations\n\ndef count_combinations(n, s):\n    count = 0\n    # Generate all permutations of n numbers from 0-9\n    for perm in permutations(range(10), n):\n        # Calculate the weighted sum\n        weighted_sum = sum((i + 1) * perm[i] for i in range(n))\n        if weighted_sum == s:\n            count += 1\n    return count\n\nfor line in sys.stdin:\n    n, s = map(int, line.strip().split())\n    print(count_combinations(n, s))\n", "perturbed_sampled": ["import sys from itertools import  sum((i + 1) * perm[i] for i in range(n)) if weighted_sum == s: count += 1 return count for line in sys.stdin: n, s = map(int, line.strip().split()) print(count_combinations(n, s))"], "perturbed_original": ["import sys import itertools table = [[], [], [], [], [], [], [], [], [], [], []] def solv(n, s):  dp: return dp[s] else: for i in xrange(331): dp.append(0) for p in  dp[s] def  n+1), perm)) for line in sys.stdin: n, s = map(int, line.split(' ')) print solv(n, s)"], "original_ll": -1.309814214706421, "sampled_ll": -0.8504071831703186, "all_perturbed_sampled_ll": [-2.456254482269287], "all_perturbed_original_ll": [-3.0322370529174805], "perturbed_sampled_ll": -2.456254482269287, "perturbed_original_ll": -3.0322370529174805, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid bomb(int field[8][8],int x,int y);\n\nint main(){\n\tint i,j,k,n;\n\tint field[8][8];\n\tchar line[9];\n\tint x,y;\n\t\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\t\t\n\t\tfor(j=0;j<8;j++){\n\t\t\tscanf(\"%s\",line);\n\t\t\tfor(k=0;k<8;k++){\n\t\t\t\tfield[j][k] = line[k] - '0';\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&x);\n\t\tscanf(\"%d\",&y);\n\t\tx--; y--;\n\t\t\n\t\tbomb(field,y,x);\n\t\t\n\t\tprintf(\"Data %d:\\n\",i);\n\t\tfor(j=0;j<8;j++){\n\t\t\tfor(k=0;k<8;k++){\n\t\t\t\tprintf(\"%d\",field[j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nvoid bomb(int field[8][8],int x,int y){\n\tint i;\n\tfield[x][y] = 0;\n\tfor(i=1;i<=3&&x-i>=0;i++){\n\t\tif(field[x-i][y] == 1){\n\t\t\tfield[x-i][y] = 0;\n\t\t\tbomb(field,x-i,y);\n\t\t}\n\t}\n\tfor(i=1;i<=3&&x+i<8;i++){\n\t\tif(field[x+i][y] == 1){\n\t\t\tfield[x+i][y] = 0;\n\t\t\tbomb(field,x+i,y);\n\t\t}\n\t}\n\tfor(i=1;i<=3&&y-i>=0;i++){\n\t\tif(field[x][y-i] == 1){\n\t\t\tfield[x][y-i] = 0;\n\t\t\tbomb(field,x,y-i);\n\t\t}\n\t}\n\tfor(i=1;i<=3&&y+i<8;i++){\n\t\tif(field[x][y+i] == 1){\n\t\t\tfield[x][y+i] = 0;\n\t\t\tbomb(field,x,y+i);\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint grid[8][8];\nint exploded[8][8];\n\nvoid explode(int x, int y) {\n    if (x < 0 || x >= 8 || y < 0 || y >= 8) return;\n    if (exploded[y][x]) return;\n    if (grid[y][x] == 0) return;\n    \n    exploded[y][x] = 1;\n    \n    // Explode bombs in range (3 squares in each direction)\n    for (int i = 1; i <= 3; i++) {\n        if (x - i >= 0) explode(x - i, y);\n        if (x + i < 8) explode(x + i, y);\n        if (y - i >= 0) explode(x, y - i);\n        if (y + i < 8) explode(x, y + i);\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int dataset = 1; dataset <= n; dataset++) {\n        // Read the grid\n        for (int i = 0; i < 8; i++) {\n            char line[10];\n            scanf(\"%s\", line);\n            for (int j = 0; j < 8; j++) {\n                grid[i][j] = line[j] - '0';\n            }\n        }\n        \n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--; y--; // Convert to 0-indexed\n        \n        // Initialize exploded array\n        memset(exploded, 0, sizeof(exploded));\n        \n        // Start the chain reaction\n        explode(x, y);\n        \n        // Output\n        printf(\"Data %d:\\n\", dataset);\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                if (exploded[i][j]) {\n                    printf(\"0\");\n                } else {\n                    printf(\"%d\", grid[i][j]);\n                }\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int  (x < 0 || x >= 8 || y < 0 || y >= 8) return; if (exploded[y][x]) return; if (grid[y][x] == 0)  squares in each direction) for (int i =  >= 0)  explode(x + i, y); if (y -  i < 8) explode(x, y + i); } } int main() { int n;  dataset++) { // Read the grid for (int i = 0; i < 8;  - '0'; } } int x, y; scanf(\"%d %d\", &x, &y); x--; y--; // Convert to 0-indexed  for (int i = 0; i < 8; i++) { for (int j = 0; j < 8; j++) { if  printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> void bomb(int field[8][8],int x,int y); int main(){  for(j=0;j<8;j++){ scanf(\"%s\",line); for(k=0;k<8;k++){ field[j][k] = line[k] - '0'; } } scanf(\"%d\",&x); scanf(\"%d\",&y); x--;  } return 0; } void bomb(int field[8][8],int x,int y){ int i; field[x][y]  } } for(i=1;i<=3&&x+i<8;i++){ if(field[x+i][y] == 1){ field[x+i][y] = 0; bomb(field,x+i,y); } } for(i=1;i<=3&&y-i>=0;i++){  if(field[x][y+i] == 1){ field[x][y+i] = 0; bomb(field,x,y+i); } } }"], "original_ll": -0.45498475432395935, "sampled_ll": -0.4754079282283783, "all_perturbed_sampled_ll": [-1.798241138458252], "all_perturbed_original_ll": [-1.2594908475875854], "perturbed_sampled_ll": -1.798241138458252, "perturbed_original_ll": -1.2594908475875854, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tint[][] map;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint sets = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor (int index = 0; index < sets; index++) {\n\t\t\tsc.nextLine();\n\t\t\t\n\t\t\tmap = new int[8][8];\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\tmap[j][i] = line.charAt(j) - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer[]> boms = new LinkedList<Integer[]>();\n\t\t\tInteger[] xy = new Integer[2];\n\t\t\txy[0] = Integer.parseInt(sc.nextLine()) - 1;\n\t\t\txy[1] = Integer.parseInt(sc.nextLine()) - 1;\n\t\t\tmap[xy[0]][xy[1]] = 0;\n\t\t\tboms.add(xy);\n\t\t\t\n\t\t\twhile (boms.isEmpty() == false) {\n\t\t\t\txy = boms.pop();\n\t\t\t\t\n\t\t\t\tint tx = xy[0];\n\t\t\t\tint ty = xy[1];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = -3; i < 4; i++) {\n\t\t\t\t\tif ((tx + i) < 0) continue;\n\t\t\t\t\tif ((tx + i) > 7) break;\n\t\t\t\t\t\n\t\t\t\t\tif (map[tx + i][ty] == 1) {\n\t\t\t\t\t\tmap[tx + i][ty] = 0;\n\t\t\t\t\t\txy[0] = tx + i;\n\t\t\t\t\t\txy[1] = ty;\n\t\t\t\t\t\tboms.add(xy);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = -3; i < 4; i++) {\n\t\t\t\t\tif ((ty + i) < 0) continue;\n\t\t\t\t\tif ((ty + i) > 7) break;\t\n\t\t\t\t\t\n\t\t\t\t\tif (map[tx][ty + i] == 1) {\n\t\t\t\t\t\tmap[tx][ty + i] = 0;\n\t\t\t\t\t\txy[0] = tx;\n\t\t\t\t\t\txy[1] = ty + i;\n\t\t\t\t\t\tboms.add(xy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"Data \" + (index + 1) + \":\");\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\tSystem.out.print(map[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int dataSet = 1; dataSet <= n; dataSet++) {\n            sc.nextLine(); // empty line\n            \n            int[][] grid = new int[8][8];\n            for (int y = 0; y < 8; y++) {\n                String line = sc.nextLine();\n                for (int x = 0; x < 8; x++) {\n                    grid[y][x] = line.charAt(x) - '0';\n                }\n            }\n            \n            int startX = sc.nextInt() - 1;\n            int startY = sc.nextInt() - 1;\n            sc.nextLine();\n            \n            // BFS to explode bombs\n            Queue<int[]> queue = new LinkedList<>();\n            boolean[][] exploded = new boolean[8][8];\n            \n            queue.offer(new int[]{startX, startY});\n            exploded[startY][startX] = true;\n            \n            while (!queue.isEmpty()) {\n                int[] pos = queue.poll();\n                int x = pos[0];\n                int y = pos[1];\n                \n                // Check up to 3 cells in each direction\n                for (int dy = -3; dy <= 3; dy++) {\n                    int ny = y + dy;\n                    if (ny >= 0 && ny < 8 && grid[ny][x] == 1 && !exploded[ny][x]) {\n                        exploded[ny][x] = true;\n                        queue.offer(new int[]{x, ny});\n                    }\n                }\n                \n                for (int dx = -3; dx <= 3; dx++) {\n                    int nx = x + dx;\n                    if (nx >= 0 && nx < 8 && grid[y][nx] == 1 && !exploded[y][nx]) {\n                        exploded[y][nx] = true;\n                        queue.offer(new int[]{nx, y});\n                    }\n                }\n            }\n            \n            // Update grid\n            for (int y = 0; y < 8; y++) {\n                for (int x = 0; x < 8; x++) {\n                    if (exploded[y][x]) {\n                        grid[y][x] = 0;\n                    }\n                }\n            }\n            \n            // Output\n            System.out.println(\"Data \" + dataSet + \":\");\n            for (int y = 0; y < 8; y++) {\n                for (int x = 0; x < 8; x++) {\n                    System.out.print(grid[y][x]);\n                }\n                System.out.println();\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args)  sc.nextLine(); for (int  empty line int[][] grid = new int[8][8]; for (int y = 0; y < 8; y++) { String line = sc.nextLine(); for (int x = 0; x < 8; x++) { grid[y][x] = line.charAt(x) - '0'; } } int startX = sc.nextInt() - 1; int startY = sc.nextInt() - 1; sc.nextLine(); //  x = pos[0]; int y = pos[1]; // Check up to 3  dy; if (ny >= 0 && ny < 8 && grid[ny][x] ==  } } for (int dx = -3; dx <=   1 && !exploded[y][nx]) { exploded[y][nx] = true; queue.offer(new int[]{nx, y}); }  y < 8; y++) { for (int x = 0; x < 8; x++)  // Output System.out.println(\"Data \" + dataSet + \":\"); for (int y = 0; y < 8; y++) { for (int x  } } sc.close(); } }"], "perturbed_original": ["import java.util.LinkedList; import java.util.Scanner; public class Main { private Scanner sc; int[][] map;  Main() { sc = new  index < sets; index++) { sc.nextLine(); map = new int[8][8]; for (int i = 0; i < map.length; i++) { String line = sc.nextLine();  = new LinkedList<Integer[]>(); Integer[] xy = new Integer[2]; xy[0] = Integer.parseInt(sc.nextLine()) - 1; xy[1] = Integer.parseInt(sc.nextLine()) - 1; map[xy[0]][xy[1]] = 0; boms.add(xy); while (boms.isEmpty() == false)  = xy[1]; for (int i = -3; i < 4; i++) { if ((tx  7) break; if (map[tx + i][ty] == 1) { map[tx + i][ty] = 0; xy[0] = tx + i; xy[1] = ty;  = 0; xy[0] = tx; xy[1] = ty + i; boms.add(xy);   { for (int j = 0; j < map.length; j++) { System.out.print(map[j][i]); } System.out.println(); } } } }"], "original_ll": -0.4823695719242096, "sampled_ll": -0.35795655846595764, "all_perturbed_sampled_ll": [-1.615957498550415], "all_perturbed_original_ll": [-1.3743826150894165], "perturbed_sampled_ll": -1.615957498550415, "perturbed_original_ll": -1.3743826150894165, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def bomb(x,y):\n    s=M[y]\n    if s[x]==\"0\":return\n    M[y]=s[:x]+\"0\"+s[x+1:]\n    R=[-3,-2,-1,1,2,3]\n    for e in R:\n        bomb(x+e,y)\n        bomb(x,y+e)\n    return\n\nA=range(3,11)\nM=[\"00000000000000\" for i in range(14)]\nz=\"000\"\nn=input()\nfor i in range(n):\n    s=raw_input()\n    for j in A:\n        M[j]=z+raw_input()+z\n    x=input()+2\n    y=input()+2\n    bomb(x,y)\n    print \"Data %d:\" %(i+1)\n    for j in A:\n        print M[j][3:-3]", "sampled": "from collections import deque\n\ndef solve():\n    n = int(input())\n    \n    for dataset_num in range(1, n + 1):\n        # Read empty line\n        input()\n        \n        # Read 8x8 grid\n        grid = []\n        for i in range(8):\n            line = input().strip()\n            grid.append([int(c) for c in line])\n        \n        # Read starting position\n        x = int(input())\n        y = int(input())\n        \n        # Convert to 0-indexed\n        x -= 1\n        y -= 1\n        \n        # BFS to simulate chain explosions\n        exploded = [[False] * 8 for _ in range(8)]\n        queue = deque()\n        \n        # Start explosion at (x, y)\n        if grid[y][x] == 1:\n            queue.append((x, y))\n            exploded[y][x] = True\n        \n        while queue:\n            cx, cy = queue.popleft()\n            \n            # Explosion affects 3 squares in each direction (up, down, left, right)\n            directions = []\n            # Up\n            for dy in range(1, 4):\n                if cy - dy >= 0:\n                    directions.append((cx, cy - dy))\n            # Down\n            for dy in range(1, 4):\n                if cy + dy < 8:\n                    directions.append((cx, cy + dy))\n            # Left\n            for dx in range(1, 4):\n                if cx - dx >= 0:\n                    directions.append((cx - dx, cy))\n            # Right\n            for dx in range(1, 4):\n                if cx + dx < 8:\n                    directions.append((cx + dx, cy))\n            \n            for nx, ny in directions:\n                if grid[ny][nx] == 1 and not exploded[ny][nx]:\n                    exploded[ny][nx] = True\n                    queue.append((nx, ny))\n        \n        # Remove exploded bombs from grid\n        for i in range(8):\n            for j in range(8):\n                if exploded[i][j]:\n                    grid[i][j] = 0\n        \n        # Output result\n        print(f\"Data {dataset_num}:\")\n        for row in grid:\n            print(''.join(map(str, row)))\n\nsolve()\n", "perturbed_sampled": ["from collections import deque def solve(): n = int(input()) for dataset_num in range(1, n + 1): # Read empty line input()  range(8): line = input().strip() grid.append([int(c) for c in line]) # Read starting position x = int(input()) y = int(input()) # Convert to 0-indexed x -= 1 y -= 1 # BFS to simulate chain explosions exploded = [[False] * 8 for _ in range(8)] queue = deque() # Start explosion at (x, y) if grid[y][x] == 1: queue.append((x, y)) exploded[y][x] = True while queue: cx, cy =  down, left, right) directions = [] # Up for dy  4): if cy  for dx in range(1, 4): if   in directions: if grid[ny][nx] ==  for j in range(8): if exploded[i][j]:  in grid: print(''.join(map(str, row))) solve()"], "perturbed_original": ["def bomb(x,y): s=M[y] if s[x]==\"0\":return M[y]=s[:x]+\"0\"+s[x+1:] R=[-3,-2,-1,1,2,3] for e in R: bomb(x+e,y) bomb(x,y+e)  i in range(n): s=raw_input() for j in A: M[j]=z+raw_input()+z  A: print M[j][3:-3]"], "original_ll": -1.4506884813308716, "sampled_ll": -0.6286031603813171, "all_perturbed_sampled_ll": [-2.147491693496704], "all_perturbed_original_ll": [-2.482050657272339], "perturbed_sampled_ll": -2.147491693496704, "perturbed_original_ll": -2.482050657272339, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#define INF 1000000\n\nint cost[100][100];\nint mincost[100];\nchar used[100];\nint V;\n\nint min(int a, int b){\n\tif (a > b){\n\t\treturn (b);\n\t}\n\treturn (a);\n}\n\nint prim(void)\n{\n\tint i;\n\tint res;\n\tint u, v;\n\t\n\tfor (i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = 0;\n\t}\n\t\n\tmincost[0] = 0;\n\tres = 0;\n\t\n\twhile (1){\n\t\tv = -1;\n\t\tfor (u = 0; u < V; u++){\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\t\n\t\tfor (u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn (res);\n}\n\nint main(void)\n{\n\tint num, from, to, dist;\n\tint i,j;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &V);\n\t\tif (V == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tfor (j = 0; j < num; j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &dist);\n\t\t\tcost[from][to] = cost[to][from] = (dist / 100) - 1;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", prim());\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100\n#define MAX_M 5000\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint parent[MAX_N];\nEdge edges[MAX_M];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    if (px != py) {\n        parent[px] = py;\n    }\n}\n\nint compare(const void *a, const void *b) {\n    Edge *ea = (Edge *)a;\n    Edge *eb = (Edge *)b;\n    return ea->w - eb->w;\n}\n\nint main() {\n    int n, m;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        scanf(\"%d\", &m);\n        \n        for (int i = 0; i < m; i++) {\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            edges[i].u = a;\n            edges[i].v = b;\n            edges[i].w = d;\n        }\n        \n        qsort(edges, m, sizeof(Edge), compare);\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        int total_lanterns = 0;\n        int edges_used = 0;\n        \n        for (int i = 0; i < m && edges_used < n - 1; i++) {\n            int u = edges[i].u;\n            int v = edges[i].v;\n            int w = edges[i].w;\n            \n            if (find(u) != find(v)) {\n                unite(u, v);\n                edges_used++;\n                total_lanterns += (w / 100 - 1);\n            }\n        }\n        \n        printf(\"%d\\n\", total_lanterns);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h>  parent[x] = find(parent[x]); } return parent[x]; } void unite(int  = find(y); if (px != py) { parent[px] = py; } } int compare(const void *a, const void *b)  *)b; return ea->w - eb->w; } int main() { int n, m; while (scanf(\"%d\", &n) == 1 && n != 0) { scanf(\"%d\", &m);  int a, b, d; scanf(\"%d,%d,%d\", &a, &b, &d); edges[i].u = a; edges[i].v = b;   0; for (int i = 0;  { int u = edges[i].u; int v = edges[i].v; int w = edges[i].w; if (find(u) != find(v)) { unite(u, v); edges_used++; total_lanterns += (w / 100 - 1); } } printf(\"%d\\n\", total_lanterns); } return 0; }"], "perturbed_original": ["#include <stdio.h> #define INF 1000000 int cost[100][100]; int mincost[100]; = cost[n][u]<extra_id_16>;<extra_id_17>{ if (u == -1)continue;<extra_id_18>for<extra_id_19>i >= v - 1;<extra_id_20>/ 100)<extra_id_21>]<extra_id_22> int prim(void) { int i; int res; int u, v; for (i = 0; i < V; i++){ mincost[i] = INF; used[i] = 0; } mincost[0] = 0; res = 0; while (1){ v = -1; for (u = 0; u < V; u++){ if (!used[u] && (v == -1 ||   for (u  } } return (res); } int main(void)  &num); for (i = 0; i <  cost[i][j] = INF; } } for (i =  = cost[to][from] = (dist / 100) - 1; } printf(\"%d\\n\", prim()); } return (0); }"], "original_ll": -0.5208573937416077, "sampled_ll": -0.36521008610725403, "all_perturbed_sampled_ll": [-1.2508821487426758], "all_perturbed_original_ll": [-1.8980934619903564], "perturbed_sampled_ll": -1.2508821487426758, "perturbed_original_ll": -1.8980934619903564, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = 0, m = 0, a = 0, b = 0, c = 0;\n\t\t\n\t\twhile(!(sb.append(reader.readLine())).equals(\"0\")){\n\t\t\tn = Integer.valueOf(sb.toString());\n\t\t\tm = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint map[][] = new int[n][n];\n\t\t\tboolean visit[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tsb.setLength(0);\n\t\t\t\tsb.append(reader.readLine());\n\t\t\t\ta = Integer.valueOf(sb.toString().split(\",\")[0]);\n\t\t\t\tb = Integer.valueOf(sb.toString().split(\",\")[1]);\n\t\t\t\tc = (Integer.valueOf(sb.toString().split(\",\")[2]) - 100) / 100;\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tvisit[0] = true;\n\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\tm = 1 << 29;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(map[0][i] < m && !visit[i]){\n\t\t\t\t\t\tm = map[0][i];\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisit[b] = true;\n\t\t\t\tc += map[0][b];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tmap[0][i] = Math.min(map[0][i], map[b][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t\tsb.setLength(0);\n\t\t}\n\t\treader.close();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, dist;\n        Edge(int to, int dist) {\n            this.to = to;\n            this.dist = dist;\n        }\n    }\n    \n    static class UnionFind {\n        int[] parent, rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        void union(int x, int y) {\n            int px = find(x);\n            int py = find(y);\n            if (px == py) return;\n            \n            if (rank[px] < rank[py]) {\n                parent[px] = py;\n            } else if (rank[px] > rank[py]) {\n                parent[py] = px;\n            } else {\n                parent[py] = px;\n                rank[px]++;\n            }\n        }\n        \n        boolean connected(int x, int y) {\n            return find(x) == find(y);\n        }\n    }\n    \n    static class MSTEdge implements Comparable<MSTEdge> {\n        int u, v, dist;\n        MSTEdge(int u, int v, int dist) {\n            this.u = u;\n            this.v = v;\n            this.dist = dist;\n        }\n        \n        public int compareTo(MSTEdge other) {\n            return this.dist - other.dist;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int m = sc.nextInt();\n            sc.nextLine();\n            \n            List<MSTEdge> edges = new ArrayList<>();\n            \n            for (int i = 0; i < m; i++) {\n                String line = sc.nextLine();\n                String[] parts = line.split(\",\");\n                int a = Integer.parseInt(parts[0]);\n                int b = Integer.parseInt(parts[1]);\n                int d = Integer.parseInt(parts[2]);\n                edges.add(new MSTEdge(a, b, d));\n            }\n            \n            // Kruskal's algorithm to find MST\n            Collections.sort(edges);\n            UnionFind uf = new UnionFind(n);\n            \n            int totalLanterns = 0;\n            \n            for (MSTEdge edge : edges) {\n                if (!uf.connected(edge.u, edge.v)) {\n                    uf.union(edge.u, edge.v);\n                    // Calculate lanterns needed for this edge\n                    // Distance is in meters, lanterns are every 100m\n                    // First lantern at 100m from one end, last at 100m from other end\n                    // For distance d, we need (d/100 - 1) lanterns\n                    int lanterns = edge.dist / 100 - 1;\n                    totalLanterns += lanterns;\n                }\n            }\n            \n            System.out.println(totalLanterns);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  dist; Edge(int to, int  static class UnionFind { int[] parent, rank;  i++) { parent[i] = i; } } int  find(parent[x]); } return parent[x]; } void union(int x, int y) { int px = find(x); int py = find(y);  parent[px] = py; } else if (rank[px] > rank[py]) { parent[py] = px; } else { parent[py] = px; rank[px]++; } } boolean connected(int x, int y) { return find(x) == find(y); }  dist; MSTEdge(int u, int v, int dist) { this.u = u; this.v = v; this.dist =  other.dist; } } public static void main(String[]  i++) { String line = sc.nextLine(); String[] parts = line.split(\",\"); int a = Integer.parseInt(parts[0]); int b = Integer.parseInt(parts[1]); int d = Integer.parseInt(parts[2]); edges.add(new MSTEdge(a, b, d)); } // Kruskal's algorithm to find MST Collections.sort(edges); UnionFind uf = new UnionFind(n); int totalLanterns =  { uf.union(edge.u, edge.v); // Calculate lanterns needed  every 100m // First lantern at 100m from  distance d, we need (d/100  1; totalLanterns += lanterns; } } System.out.println(totalLanterns); } sc.close(); } }"], "perturbed_original": ["import  public static void main(String[] args)throws IOException{ InputStreamReader isr = new InputStreamReader(System.in); BufferedReader reader = new BufferedReader(isr); StringBuilder sb = new StringBuilder(); int n  0, c = 0;  new int[n][n]; boolean visit[] = new boolean[n]; for(int i  i = 0; i < m; i++){ sb.setLength(0); sb.append(reader.readLine()); a = Integer.valueOf(sb.toString().split(\",\")[0]); b = Integer.valueOf(sb.toString().split(\",\")[1]); c  x = 0; x <  i = 0; i < n; i++){ if(map[0][i] < m && !visit[i]){  true; c += map[0][b]; for(int i = 0; i < n; i++){ map[0][i] = Math.min(map[0][i], map[b][i]); } } System.out.println(c); sb.setLength(0); } reader.close(); } }"], "original_ll": -0.6081327199935913, "sampled_ll": -0.41740942001342773, "all_perturbed_sampled_ll": [-1.7344363927841187], "all_perturbed_original_ll": [-1.6079272031784058], "perturbed_sampled_ll": -1.7344363927841187, "perturbed_original_ll": -1.6079272031784058, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n  n=int(input())\n  if not n:break\n  X={0}\n  Y=set(range(n))-X\n  s=0\n  l=[tuple(map(int,input().split(\",\"))) for _ in range(int(input()))]\n\n  while Y:\n    cd=[i for i in l if (i[0] in X and i[1] in Y) or (i[0] in Y and i[1] in X)]\n    cd=sorted(cd,key=lambda x:x[2])[0]\n    if cd[0] in X and cd[1] in Y:\n      X.add(cd[1])\n      Y=Y-X\n    elif cd[0] in Y and cd[1] in X:\n      X.add(cd[0])\n      Y=Y-X\n    s+=int(cd[2]/100-1)\n  print(s)\n", "sampled": "import sys\nfrom collections import defaultdict\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    px, py = find(parent, x), find(parent, y)\n    if px == py:\n        return False\n    if rank[px] < rank[py]:\n        px, py = py, px\n    parent[py] = px\n    if rank[px] == rank[py]:\n        rank[px] += 1\n    return True\n\ndef kruskal_mst(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n    edges.sort(key=lambda x: x[2])\n    mst_edges = []\n    \n    for a, b, d in edges:\n        if union(parent, rank, a, b):\n            mst_edges.append((a, b, d))\n            if len(mst_edges) == n - 1:\n                break\n    \n    return mst_edges\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    m = int(input())\n    edges = []\n    \n    for _ in range(m):\n        line = input().strip()\n        a, b, d = map(int, line.split(','))\n        edges.append((a, b, d))\n    \n    # Find MST\n    mst_edges = kruskal_mst(n, edges)\n    \n    # Calculate total lanterns needed\n    total_lanterns = 0\n    for a, b, d in mst_edges:\n        # Distance between two sites is d meters\n        # Lanterns are placed every 100m\n        # First lantern is 100m from site a, last is 100m from site b\n        # So number of lanterns = d/100 - 1\n        lanterns = d // 100 - 1\n        total_lanterns += lanterns\n    \n    print(total_lanterns)\n", "perturbed_sampled": ["import sys from collections import defaultdict def  return parent[x] def union(parent, rank, x, y): px, py = find(parent, x), find(parent, y) if px == py: return False if rank[px] < rank[py]: px, py = py, px parent[py] = px if rank[px] == rank[py]: rank[px] += 1 return True def kruskal_mst(n, edges): parent = list(range(n))  [] for a, b, d in edges: if union(parent, rank, a, b): mst_edges.append((a, b, d)) if len(mst_edges) == n - 1: break return mst_edges while True: n = int(input()) if n ==  = kruskal_mst(n, edges) # Calculate total  mst_edges: # Distance between two sites is d  is 100m from site a, last is  1 total_lanterns += lanterns print(total_lanterns)"], "perturbed_original": ["while 1: n=int(input()) if not n:break X={0} Y=set(range(n))-X s=0 l=[tuple(map(int,input().split(\",\"))) for _ in range(int(input()))] while Y: cd=[i for i in l if (i[0]   Y and cd[1] in X: X.add(cd[0]) Y=Y-X s+=int(cd[2]/100-1) print(s)"], "original_ll": -1.1023685932159424, "sampled_ll": -0.6044744849205017, "all_perturbed_sampled_ll": [-1.7557519674301147], "all_perturbed_original_ll": [-2.260406732559204], "perturbed_sampled_ll": -1.7557519674301147, "perturbed_original_ll": -2.260406732559204, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid timePrint(int time);\n\nint main(void){\n  int t, h, s;\n  int time;\n\n  scanf(\"%d%d%d\", &t, &h, &s);\n  while(!(t == -1 && h == -1 && s == -1)){\n    time = t*3600 + h*60 + s;\n    timePrint(7200-time);\n    timePrint(7200-time/3);\n    scanf(\"%d%d%d\", &t, &h, &s);\n  }\n  return 0;\n}\n\nvoid timePrint(int time){\n  printf(\"%02d:\", time/3600);\n  time %= 3600;\n  printf(\"%02d:\", time/60);\n  time %= 60;\n  printf(\"%02d\\n\", time);\n  return;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int T, H, S;\n    \n    while(1) {\n        scanf(\"%d %d %d\", &T, &H, &S);\n        \n        if(T == -1 && H == -1 && S == -1) {\n            break;\n        }\n        \n        // Convert current time to seconds\n        int current_seconds = T * 3600 + H * 60 + S;\n        \n        // Total tape is 120 minutes = 7200 seconds\n        int total_seconds = 120 * 60;\n        \n        // Remaining seconds\n        int remaining_seconds = total_seconds - current_seconds;\n        \n        // Standard mode: remaining time as is\n        int std_hours = remaining_seconds / 3600;\n        int std_minutes = (remaining_seconds % 3600) / 60;\n        int std_seconds = remaining_seconds % 60;\n        \n        // 3x mode: 3 times the remaining time\n        int triple_total_seconds = remaining_seconds * 3;\n        int triple_hours = triple_total_seconds / 3600;\n        int triple_minutes = (triple_total_seconds % 3600) / 60;\n        int triple_seconds = triple_total_seconds % 60;\n        \n        printf(\"%02d:%02d:%02d\\n\", std_hours, std_minutes, std_seconds);\n        printf(\"%02d:%02d:%02d\\n\", triple_hours, triple_minutes, triple_seconds);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int T, H, S; while(1) {  H == -1 && S == -1) { break; } // Convert current time to seconds int current_seconds = T * 3600 + H * 60 + S; // Total tape is 120 minutes = 7200  int  as is int std_hours = remaining_seconds / 3600; int std_minutes = (remaining_seconds % 3600) / 60; int  the remaining time int triple_total_seconds = remaining_seconds * 3;   return 0; }"], "perturbed_original": [" -1  t*3600 + h*60 + s; timePrint(7200-time); timePrint(7200-time/3); scanf(\"%d%d%d\", &t, &h, &s); } return 0; } void timePrint(int time){ printf(\"%02d:\", time/3600); time %= 3600; printf(\"%02d:\", time/60); time %= 60; printf(\"%02d\\n\", time); return; }"], "original_ll": -0.7608142495155334, "sampled_ll": -0.6194192171096802, "all_perturbed_sampled_ll": [-2.3476715087890625], "all_perturbed_original_ll": [-1.300417184829712], "perturbed_sampled_ll": -2.3476715087890625, "perturbed_original_ll": -1.300417184829712, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tint s = scanner.nextInt();\n\t\t\tif (h == -1 && m == -1 && s == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint sc = 7200 - (h * 3600 + m * 60 + s);\n\t\t\tint sc3 = sc * 3;\n\t\t\tSystem.out.println(String.format(\"%02d:%02d:%02d\", sc / 3600,\n\t\t\t\t\tsc / 60 % 60, sc % 60));\n\t\t\tSystem.out.println(String.format(\"%02d:%02d:%02d\", sc3 / 3600,\n\t\t\t\t\tsc3 / 60 % 60, sc3 % 60));\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int h = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            \n            if (h == -1 && m == -1 && s == -1) {\n                break;\n            }\n            \n            // Convert current counter to seconds\n            int usedSeconds = h * 3600 + m * 60 + s;\n            \n            // Total tape capacity in seconds (120 minutes)\n            int totalSeconds = 120 * 60;\n            \n            // Remaining seconds\n            int remainingSeconds = totalSeconds - usedSeconds;\n            \n            // Standard recording mode (remaining time as is)\n            int stdHours = remainingSeconds / 3600;\n            int stdMinutes = (remainingSeconds % 3600) / 60;\n            int stdSeconds = remainingSeconds % 60;\n            \n            // 3x recording mode (remaining time * 3)\n            int tripleSeconds = remainingSeconds * 3;\n            int tripleHours = tripleSeconds / 3600;\n            int tripleMinutes = (tripleSeconds % 3600) / 60;\n            int tripleSecs = tripleSeconds % 60;\n            \n            System.out.printf(\"%02d:%02d:%02d%n\", stdHours, stdMinutes, stdSeconds);\n            System.out.printf(\"%02d:%02d:%02d%n\", tripleHours, tripleMinutes, tripleSecs);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  sc = new Scanner(System.in); while (true) {  Convert current counter to  60 + s; // Total tape capacity in seconds (120 minutes) int totalSeconds = 120 * 60; // Remaining seconds  (remaining time as is) int stdHours = remainingSeconds / 3600; int stdMinutes =  60; // 3x  * 3; int tripleHours = tripleSeconds / 3600; int tripleMinutes = (tripleSeconds % 3600) / 60; int tripleSecs = tripleSeconds % 60; System.out.printf(\"%02d:%02d:%02d%n\", stdHours, stdMinutes, stdSeconds); System.out.printf(\"%02d:%02d:%02d%n\", tripleHours, tripleMinutes, tripleSecs); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (true) { int h  7200 - (h * 3600  * 3; System.out.println(String.format(\"%02d:%02d:%02d\", sc / 3600, sc / 60 % 60, sc % 60)); System.out.println(String.format(\"%02d:%02d:%02d\", sc3 / 3600, sc3 / 60 % 60, sc3 % 60)); } } }"], "original_ll": -0.5527768135070801, "sampled_ll": -0.6878414750099182, "all_perturbed_sampled_ll": [-1.8882724046707153], "all_perturbed_original_ll": [-1.0612077713012695], "perturbed_sampled_ll": -1.8882724046707153, "perturbed_original_ll": -1.0612077713012695, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#!/usr/bin/python\n# coding: utf-8\n\nwhile True:\n    h, m, s = map(int, raw_input().split())\n    if h == m == s == -1:\n        break\n\n    full = 2 * 3600\n    rest = full - (h * 3600 + m * 60 + s)\n\n    h = int(rest / 3600)\n    m = int((rest - h * 3600) / 60)\n    s = rest - h * 3600 - m * 60 \n\n    th = int(rest / 1200)\n    tm = int((rest - th * 1200) / 20)\n    ts = (rest - th * 1200 - tm * 20) * 3\n\n    print \"{:02d}:{:02d}:{:02d}\".format(h, m, s)\n    print \"{:02d}:{:02d}:{:02d}\".format(th, tm, ts)", "sampled": "while True:\n    T, H, S = map(int, input().split())\n    if T == -1 and H == -1 and S == -1:\n        break\n    \n    # Convert current counter to seconds\n    current_seconds = T * 3600 + H * 60 + S\n    \n    # Total tape capacity in seconds (120 minutes)\n    total_seconds = 120 * 60\n    \n    # Remaining tape in seconds\n    remaining_seconds = total_seconds - current_seconds\n    \n    # Standard recording: remaining time is as is\n    std_hours = remaining_seconds // 3600\n    std_minutes = (remaining_seconds % 3600) // 60\n    std_seconds = remaining_seconds % 60\n    \n    # 3x recording: can record 3 times the remaining tape time\n    triple_total_seconds = remaining_seconds * 3\n    triple_hours = triple_total_seconds // 3600\n    triple_minutes = (triple_total_seconds % 3600) // 60\n    triple_seconds = triple_total_seconds % 60\n    \n    print(f\"{std_hours:02d}:{std_minutes:02d}:{std_seconds:02d}\")\n    print(f\"{triple_hours:02d}:{triple_minutes:02d}:{triple_seconds:02d}\")\n", "perturbed_sampled": ["while  -1 and H == -1 and S == -1: break # Convert current counter to seconds  S # Total tape capacity in seconds (120 minutes) total_seconds = 120 * 60 # Remaining tape in seconds remaining_seconds = total_seconds  3x recording: can record 3 times the remaining tape time triple_total_seconds  = (triple_total_seconds % 3600) // 60 triple_seconds = triple_total_seconds % 60 print(f\"{std_hours:02d}:{std_minutes:02d}:{std_seconds:02d}\") print(f\"{triple_hours:02d}:{triple_minutes:02d}:{triple_seconds:02d}\")"], "perturbed_original": ["#!/usr/bin/python # coding: utf-8 while True: h, m, s = map(int, raw_input().split()) if h == m == s == -1: break full  3600 + m * 60 + s) h = int(rest  60) s = rest -  / 20) ts = (rest - th * 1200 - tm * 20) * 3 print \"{:02d}:{:02d}:{:02d}\".format(h, m, s) print \"{:02d}:{:02d}:{:02d}\".format(th, tm, ts)"], "original_ll": -0.6480379700660706, "sampled_ll": -0.8599873185157776, "all_perturbed_sampled_ll": [-2.074186086654663], "all_perturbed_original_ll": [-1.8129472732543945], "perturbed_sampled_ll": -2.074186086654663, "perturbed_original_ll": -1.8129472732543945, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(n){while(~scanf(\"%d\",&n)){float x=1,y=0,r,t;for(;--n>0;x=t)r=hypot(x,y),t=x-y/r,y+=x/r;n+2&&printf(\"%f\\n%f\\n\",x,y);}}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != -1) {\n        double x = 1.0, y = 0.0;\n        double wx = 0.0, wy = 0.0;\n        \n        for (int i = 2; i <= n; i++) {\n            double dx = wx - x;\n            double dy = wy - y;\n            double dist = sqrt(dx * dx + dy * dy);\n            \n            double ux = dx / dist;\n            double uy = dy / dist;\n            \n            double rx = -uy;\n            double ry = ux;\n            \n            x = x + rx;\n            y = y + ry;\n        }\n        \n        printf(\"%.2f\\n%.2f\\n\", x, y);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int  { double x = 1.0, y = 0.0; double  wx - x; double dy = wy - y; double dist = sqrt(dx * dx + dy * dy); double ux = dx / dist; double uy  = ux; x = x + rx; y  0; }"], "perturbed_original": ["main(n){while(~scanf(\"%d\",&n)){float x=1,y=0,r,t;for(;--n>0;x=t)r=hypot(x,y),t=x-y/r,y+=x/r;n+2&&printf(\"%f\\n%f\\n\",x,y);}}"], "original_ll": -2.558379650115967, "sampled_ll": -0.6859150528907776, "all_perturbed_sampled_ll": [-2.361417055130005], "all_perturbed_original_ll": [-2.558379650115967], "perturbed_sampled_ll": -2.361417055130005, "perturbed_original_ll": -2.558379650115967, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble x, y;\n\t\tint n;\n\n\t\tn = sc.nextInt();\n\t\twhile (n != -1) {\n\t\t\tx = 1.0;\n\t\t\ty = 0.0;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (x == 0.0) {\n\t\t\t\t\tif (0 < y) {\n\t\t\t\t\t\tx -= 1.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx += 1.0;\n\t\t\t\t\t}\n\t\t\t\t} else if (y == 0.0) {\n\t\t\t\t\tif (0 < x) {\n\t\t\t\t\t\ty += 1.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty -= 1.0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdouble theta = Math.atan2(y, x) + Math.PI / 2;\n\t\t\t\t\tx += Math.cos(theta);\n\t\t\t\t\ty += Math.sin(theta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(x);\n\t\t\tSystem.out.println(y);\n\t\t\tn = sc.nextInt();\n\t\t}\t\t\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == -1) break;\n            \n            // Start at position (1, 0) - 1m east of the well at (0, 0)\n            double x = 1.0;\n            double y = 0.0;\n            \n            // Initial direction: facing the well (west)\n            double dx = -1.0;\n            double dy = 0.0;\n            \n            // Process steps 2 to n\n            for (int i = 2; i <= n; i++) {\n                // Turn right 90 degrees\n                double newDx = dy;\n                double newDy = -dx;\n                dx = newDx;\n                dy = newDy;\n                \n                // Move 1m forward\n                x += dx;\n                y += dy;\n                \n                // Face the well again\n                double dist = Math.sqrt(x * x + y * y);\n                dx = -x / dist;\n                dy = -y / dist;\n            }\n            \n            System.out.printf(\"%.2f\\n%.2f\\n\", x, y);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  sc =  (n == -1) break; // Start at position (1, 0) - 1m east of the well at (0, 0) double x  (int i = 2; i <= n; i++) { // Turn right 90 degrees double newDx  = newDy; // Move 1m forward x += dx; y += dy; // Face the well again  dx = -x / dist; dy = -y / dist; } System.out.printf(\"%.2f\\n%.2f\\n\", x, y); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public }<extra_id_1>x <=<extra_id_2>y * (x +<extra_id_3>double<extra_id_4>double x<extra_id_5>* y<extra_id_6>/<extra_id_7>int<extra_id_8>Math.sin(theta);<extra_id_9>++ )<extra_id_10>+= 0.0f);<extra_id_11>int n )<extra_id_12>< n<extra_id_13>x<extra_id_14>++<extra_id_15>=<extra_id_16><=<extra_id_17>if ( this .<extra_id_18>x )<extra_id_19>} } public<extra_id_20>Main ( float<extra_id_21>/ ( float )<extra_id_22>} } } } } double x, y;  x = 1.0; y = 0.0; for (int i = 0; i < n; i++) { if (x == 0.0) { if  x += 1.0; } } else if (y == 0.0) { if (0 < x) { y += 1.0; } else { y -= 1.0; } } else { double  Math.cos(theta); y +=  }"], "original_ll": -0.6165692210197449, "sampled_ll": -0.8555433750152588, "all_perturbed_sampled_ll": [-2.4297735691070557], "all_perturbed_original_ll": [-2.001943349838257], "perturbed_sampled_ll": -2.4297735691070557, "perturbed_original_ll": -2.001943349838257, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for e in iter(input,'-1'):\n z=1\n for _ in[0]*~-int(e):d=z*1j;z+=d/abs(d)\n print(z.real)\n print(z.imag)\n", "sampled": "import math\n\ndef solve(n):\n    # Start at position (1, 0) - 1m east of the well\n    x, y = 1.0, 0.0\n    \n    # Initial direction: facing the well (west)\n    # We'll track the angle we're facing\n    \n    for step in range(2, n + 1):\n        # Calculate direction to well from current position\n        dx_to_well = -x\n        dy_to_well = -y\n        angle_to_well = math.atan2(dy_to_well, dx_to_well)\n        \n        # Turn right 90 degrees from facing the well\n        new_angle = angle_to_well - math.pi / 2\n        \n        # Move 1m in that direction\n        x += math.cos(new_angle)\n        y += math.sin(new_angle)\n    \n    return x, y\n\nwhile True:\n    n = int(input())\n    if n == -1:\n        break\n    \n    x, y = solve(n)\n    print(f\"{x:.2f}\")\n    print(f\"{y:.2f}\")\n", "perturbed_sampled": ["import math def solve(n): # Start at position (1, 0) - 1m  Initial direction: facing the well (west) # We'll track the angle we're facing for step in range(2, n + 1): # Calculate direction to well from current position dx_to_well = -x dy_to_well = -y angle_to_well =  well new_angle = angle_to_well - math.pi  math.cos(new_angle) y +=  print(f\"{y:.2f}\")"], "perturbed_original": ["for e in iter(input,'-1'): z=1 for _ in[0]*~-int(e):d=z*1j;z+=d/abs(d) print(z.real) print(z.imag)"], "original_ll": -2.970486879348755, "sampled_ll": -1.1308629512786865, "all_perturbed_sampled_ll": [-3.174302577972412], "all_perturbed_original_ll": [-2.916921854019165], "perturbed_sampled_ll": -3.174302577972412, "perturbed_original_ll": -2.916921854019165, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#define LENGTH 1001\n\nint main(void)\n{\n  char st[LENGTH];\n  int i, j, k, l, m, check, fix, count, kosuu, decimal=1;\n  int a, b, t=0;\n  char ch;\n\n  i = 0;\n  while(scanf(\"%1c\",&ch)!=EOF)\n    {\n      st[i] = ch;\n      i++;\n    }\n  st[i+1] = 0;\n  st[i+2] = 0;\n  st[i+3] = 0;\n\n  k = strlen(st);\n\n\n  /*\n  printf(\"k = %d\\n\",strlen(st));\n\n  for(i=0;i<=strlen(st);i++)\n    {\n      printf(\"st[%d] %d\\n\",i,st[i]); \n      }\n  */\n\n  j = 1;\n  count = 1;\n  kosuu = 0;\n\n  i = 0;\n  t = 0;\n  while(1)\n    {\n      if(st[i]=='@')\n\t{\n\t  kosuu = st[i+1]-48;\n\t  for(j=0;j<=kosuu-1;j++)\n\t    {\n\t      printf(\"%c\",st[i+2]);\n\t    }\n\t  i = i + 3;\n\t}\n      else if(st[i]==10)\n\t{\n\t  printf(\"\\n\");\n\t  i++;\n\t}\n      else if(st[i]==0)\n\t{\n\t  break;\n\t}\n      else\n\t{\n\t  printf(\"%c\",st[i]);\n\t  i++;\n\t}\n    }\n  printf(\"\\n\");\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    char line[256];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int len = strlen(line);\n        if (len > 0 && line[len-1] == '\\n') {\n            line[len-1] = '\\0';\n            len--;\n        }\n        \n        int i = 0;\n        while (i < len) {\n            if (line[i] == '@') {\n                i++;\n                int count = line[i] - '0';\n                i++;\n                char ch = line[i];\n                for (int j = 0; j < count; j++) {\n                    putchar(ch);\n                }\n                i++;\n            } else {\n                putchar(line[i]);\n                i++;\n            }\n        }\n        putchar('\\n');\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <ctype.h> int main() { char line[256];  = '\\0'; len--; }  (line[i] == '@') { i++; int count = line[i] - '0'; i++; char  count; j++) { putchar(ch); } i++; } else { putchar(line[i]); i++; } } putchar('\\n'); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #define LENGTH 1001 int main(void) { char st[LENGTH];  decimal=1; int a, b, t=0; char ch; i  = 0; st[i+2] = 0;  for(i=0;i<=strlen(st);i++) { printf(\"st[%d] %d\\n\",i,st[i]); } */ j = 1; count = 1; kosuu = 0; i = 0; t = 0; while(1) { if(st[i]=='@') { kosuu = st[i+1]-48;  else if(st[i]==10) {  printf(\"%c\",st[i]); i++; } } printf(\"\\n\"); return 0; }"], "original_ll": -1.0701336860656738, "sampled_ll": -0.4814278185367584, "all_perturbed_sampled_ll": [-2.1053109169006348], "all_perturbed_original_ll": [-1.9002577066421509], "perturbed_sampled_ll": -2.1053109169006348, "perturbed_original_ll": -1.9002577066421509, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.FileInputStream;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) throws Exception{\n        while(hasNext()){\n            StringBuilder s = new StringBuilder(NLine());\n            StringBuilder ans=new StringBuilder();\n            if(s.length()==0)return;\n            for (int i = 0; i < s.length(); i++) {\n                if(s.charAt(i)=='@'){\n                    i++;\n                    int len = s.charAt(i)-'0';\n                    i++;\n                    for (int j = 0; j < len; j++) {\n                        ans.append(s.charAt(i));\n                    }\n                } else {\n                    ans.append(s.charAt(i));\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n\n    \n    static int c=0;\n    static int NI(){\n        return (int)NL();\n    }\n    \n    static long NL(){\n        try {\n            long r = 0;\n            skip();\n            if(c=='-') return -NL();\n            for(;'0'<=c&&c<='9';c=System.in.read())\n                r = r * 10 + c - '0';\n            return r;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    \n    static char NC(){\n        try {\n            skip();\n            return (char)c;\n        } catch (Exception e) {\n            return 0;\n        }\n    }\n    \n    static String NS(){\n        StringBuilder sb=new StringBuilder();\n        try {\n            skip();\n            for(;!isSkip();){\n                sb.append((char)c);\n                c=System.in.read();\n            }\n            return sb.toString();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n    \n    static String NLine(){\n        StringBuilder sb=new StringBuilder();\n        try {\n            for(;c!='\\n'&&c!='\\r';){\n                sb.append((char)c);\n                c=System.in.read();\n//                System.out.println(c);\n            }\n            c=System.in.read();\n            return sb.toString();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n    \n    static void skip(){\n        try{\n            while(isSkip()){\n                c=System.in.read();\n            }\n        } catch (Exception e){}\n        \n    }\n    \n    static boolean hasNext(){\n        skip();\n        return c!=-1;\n    }\n    \n    static boolean isSkip(){\n        return 0 <= c && c <= ' ';\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            StringBuilder result = new StringBuilder();\n            \n            int i = 0;\n            while (i < line.length()) {\n                if (line.charAt(i) == '@') {\n                    // Found @ symbol, next character is count, character after that is the character to repeat\n                    i++; // move past @\n                    int count = line.charAt(i) - '0'; // get the count digit\n                    i++; // move to the character to repeat\n                    char charToRepeat = line.charAt(i);\n                    \n                    // Append the character 'count' times\n                    for (int j = 0; j < count; j++) {\n                        result.append(charToRepeat);\n                    }\n                    i++; // move past the repeated character\n                } else {\n                    // Regular character, just append it\n                    result.append(line.charAt(i));\n                    i++;\n                }\n            }\n            \n            System.out.println(result.toString());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  String line = sc.nextLine(); StringBuilder  Found @ symbol, next character is count, character after that is the character to repeat i++; // move past @ int count = line.charAt(i) - '0'; // get the count digit i++; // move to the character to repeat char charToRepeat = line.charAt(i); // Append the  count; j++) { result.append(charToRepeat); } i++; // move past the repeated character } else { // Regular character,  } }"], "perturbed_original": ["import java.io.FileInputStream; import java.util.Scanner; public class Main { /** * @param args */ public static void  StringBuilder ans=new StringBuilder(); if(s.length()==0)return; for (int  int len = s.charAt(i)-'0'; i++; for (int j = 0;  ans.append(s.charAt(i)); } }  = 0; skip(); if(c=='-')  - '0'; return r; } catch (Exception e) { return -1; } } static char NC(){ try { skip(); return (char)c; } catch (Exception e) { return 0; } } static String NS(){ StringBuilder sb=new StringBuilder(); try { skip(); for(;!isSkip();){  c=System.in.read();  } static void skip(){ try{ while(isSkip()){ c=System.in.read(); } } catch (Exception e){} } static boolean hasNext(){ skip(); return c!=-1; } static boolean isSkip(){ return 0 <= c && c <= ' '; } }"], "original_ll": -0.8130732774734497, "sampled_ll": -0.6543360948562622, "all_perturbed_sampled_ll": [-2.970010280609131], "all_perturbed_original_ll": [-2.109314203262329], "perturbed_sampled_ll": -2.970010280609131, "perturbed_original_ll": -2.109314203262329, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\n\ndef method(l):\n    return l if l.find('@') < 0 else method(l.replace(l[l.find('@'):l.find('@')+3], l[l.find('@')+2]*int(l[l.find('@')+1])))\n\nif __name__ == '__main__':\n    for line in sys.stdin:\n        print(method(line))", "sampled": "import sys\nimport re\n\nfor line in sys.stdin:\n    line = line.rstrip('\\n')\n    result = []\n    i = 0\n    while i < len(line):\n        if line[i] == '@':\n            # Find the digit(s) after @\n            j = i + 1\n            while j < len(line) and line[j].isdigit():\n                j += 1\n            count = int(line[i+1:j])\n            # The character to repeat is at position j\n            if j < len(line):\n                char = line[j]\n                result.append(char * count)\n                i = j + 1\n            else:\n                i = j\n        else:\n            result.append(line[i])\n            i += 1\n    print(''.join(result))\n", "perturbed_sampled": ["import sys import re for line in sys.stdin: line = line.rstrip('\\n') result = [] i =  Find the digit(s) after @ j = i + 1 while j < len(line) and line[j].isdigit():  char = line[j] result.append(char * count) i = j +  print(''.join(result))"], "perturbed_original": ["import sys def method(l): return l if l.find('@') < 0  sys.stdin: print(method(line))"], "original_ll": -1.6962916851043701, "sampled_ll": -0.8367400169372559, "all_perturbed_sampled_ll": [-2.6874914169311523], "all_perturbed_original_ll": [-5.013552665710449], "perturbed_sampled_ll": -2.6874914169311523, "perturbed_original_ll": -5.013552665710449, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\nint main(){\n\tint i=0,j;\n\tdouble x[20],y[20],s=0;\n    //\u5024\u306e\u8aad\u307f\u8fbc\u307f\n    \n    while(scanf(\"%lf,%lf\\n\",&x[i],&y[i]) !=EOF) {\n    \t\t//scanf(\"%lf%lf\",&x[i],&y[i]);\n    \t\ti++;\n    \t}\n    \tj=i\n    \tfor(i=1;i<j;i++){\n    \t\ts+=(x[i]*y[i+1]-x[i+1]*y[i]);\n    \t}\n        s+=(x[i]*y[0]-x[0]*y[i]);\n    \tprintf(\"%0.6lf\\n\",fabs(s)/2.0);\n    \n    return 0;\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x[20], y[20];\n    int n = 0;\n    char c;\n    \n    while (scanf(\"%lf,%lf\", &x[n], &y[n]) == 2) {\n        n++;\n        while ((c = getchar()) != '\\n' && c != EOF);\n        if (c == EOF) break;\n    }\n    \n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        area += x[i] * y[j] - x[j] * y[i];\n    }\n    area = fabs(area) / 2.0;\n    \n    printf(\"%.6f\\n\", area);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { double  &x[n], &y[n]) == 2)  != EOF); if (c == EOF) break; }  < n; i++) { int j = (i + 1) % n; area += x[i] * y[j] - x[j]  return 0; }"], "perturbed_original": [" //\u5024\u306e\u8aad\u307f\u8fbc\u307f while(scanf(\"%lf,%lf\\n\",&x[i],&y[i]) !=EOF) { //scanf(\"%lf%lf\",&x[i],&y[i]); i++; } j=i for(i=1;i<j;i++){ s+=(x[i]*y[i+1]-x[i+1]*y[i]); } s+=(x[i]*y[0]-x[0]*y[i]); printf(\"%0.6lf\\n\",fabs(s)/2.0); return 0; }"], "original_ll": -1.2834644317626953, "sampled_ll": -0.5375872254371643, "all_perturbed_sampled_ll": [-2.546363353729248], "all_perturbed_original_ll": [-1.7517679929733276], "perturbed_sampled_ll": -2.546363353729248, "perturbed_original_ll": -1.7517679929733276, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tdouble[] x = new double[20];\n\t\tdouble[] y = new double[20];\n\t\tint i = 0;\n\t\tString string;\n\t\t\n\t\twhile((string = reader.readLine()) != null){\n\t\t\tx[i] = Double.valueOf(string.split(\",\")[0]);\n\t\t\ty[i] = Double.valueOf(string.split(\",\")[1]);\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tdouble a = Math.hypot(x[1] - x[0], y[1] - y[0]);\n\t\tdouble b = Math.hypot(x[2] - x[0], y[2] - y[0]);\n\t\tdouble c = Math.hypot(x[2] - x[1], y[2] - y[1]);\n\t\tdouble z = (a + b + c) / 2;\n\t\tdouble S = Math.sqrt(z * (z - a) * (z - b) * (z - c));\n\t\tfor(int j = 2; j < i - 1; j++){\n\t\t\ta = Math.hypot(x[j] - x[0], y[j] - y[0]);\n\t\t\tb = Math.hypot(x[j + 1] - x[0], y[j + 1] - y[0]);\n\t\t\tc = Math.hypot(x[j + 1] - x[j], y[j + 1] - y[j]);\n\t\t\tz = (a + b + c) / 2;\n\t\t\tS += Math.sqrt(z * (z - a) * (z - b) * (z - c));\n\t\t}\n\t\tSystem.out.println(S);\n\t}\n}", "sampled": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ArrayList<Double> x = new ArrayList<>();\n        ArrayList<Double> y = new ArrayList<>();\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) continue;\n            \n            String[] parts = line.split(\",\");\n            x.add(Double.parseDouble(parts[0]));\n            y.add(Double.parseDouble(parts[1]));\n        }\n        \n        int n = x.size();\n        double area = 0.0;\n        \n        for (int i = 0; i < n; i++) {\n            int j = (i + 1) % n;\n            area += x.get(i) * y.get(j);\n            area -= x.get(j) * y.get(i);\n        }\n        \n        area = Math.abs(area) / 2.0;\n        \n        System.out.printf(\"%.6f\\n\", area);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; import java.util.ArrayList; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); ArrayList<Double> x =  i < n; i++) { int j = (i + 1) % n; area += x.get(i) * y.get(j); area -= x.get(j) * y.get(i); } area = Math.abs(area) / 2.0; System.out.printf(\"%.6f\\n\", area); sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader;  isr = new InputStreamReader(System.in);  double[] y = new double[20];  null){ x[i] = Double.valueOf(string.split(\",\")[0]); y[i] = Double.valueOf(string.split(\",\")[1]); i++;  double b = Math.hypot(x[2] - x[0], y[2] - y[0]); double c = Math.hypot(x[2] -  + c) / 2; double S = Math.sqrt(z * (z - a) * (z - b) * (z - c)); for(int j = 2; j < i - 1; j++){ a = Math.hypot(x[j] - x[0], y[j] - y[0]); b = Math.hypot(x[j  = Math.hypot(x[j + 1] - x[j], y[j +  / 2; S += Math.sqrt(z  - c)); } System.out.println(S); } }"], "original_ll": -0.369960218667984, "sampled_ll": -0.4304264485836029, "all_perturbed_sampled_ll": [-1.2416598796844482], "all_perturbed_original_ll": [-1.4339370727539062], "perturbed_sampled_ll": -1.2416598796844482, "perturbed_original_ll": -1.4339370727539062, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "i = 0\nx = []\ny = []\nwhile 1:\n    try:\n        a,b = map(float,input().split(\",\"))\n        x.append(a)\n        y.append(b)\n    except EOFError:\n        break\n\nS = 0\nfor i in range(len(x)-2):\n    a = ((x[0]-x[i+1]) ** 2 + (y[0]-y[i+1]) ** 2) ** 0.5\n    b = ((x[0]-x[i+2]) ** 2 + (y[0]-y[i+2]) ** 2) ** 0.5\n    c = ((x[i+1]-x[i+2]) ** 2 + (y[i+1]-y[i+2]) ** 2) ** 0.5\n    z = (a + b + c)/2\n    S += (z * (z - a) * (z - b) * (z - c)) ** 0.5\nprint(S)\n", "sampled": "import sys\nimport math\n\ndef polygon_area(points):\n    n = len(points)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    area = abs(area) / 2.0\n    return area\n\npoints = []\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        x, y = map(float, line.split(','))\n        points.append((x, y))\n\narea = polygon_area(points)\nprint(f\"{area:.6f}\")\n", "perturbed_sampled": [" = 0.0 for i in range(n): j = (i + 1) % n area += points[i][0] * points[j][1] area -= points[j][0] * points[i][1] area = abs(area) / 2.0 return area  area = polygon_area(points) print(f\"{area:.6f}\")"], "perturbed_original": ["i = 0 x = [] y = [] while 1: try: a,b  for i in  ** 2) ** 0.5 c =  = (a + b + c)/2 S += (z * (z - a) * (z - b) * (z - c)) ** 0.5 print(S)"], "original_ll": -0.5600886940956116, "sampled_ll": -0.4200994670391083, "all_perturbed_sampled_ll": [-1.2673147916793823], "all_perturbed_original_ll": [-2.5695157051086426], "perturbed_sampled_ll": -1.2673147916793823, "perturbed_original_ll": -2.5695157051086426, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nint main(int argc,char* argv[]){\n  \n  for(;;){\n    int q;\n    double x;\n\n    scanf(\"%d\",&q);\n    if(q == -1){break;}\n    \n    x = q/2;\n    while(!(fabs(x*x*x - q) < 0.00001*q)){\n      x = x - (x*x*x-q)/(3*x*x);\n    }\n\n    printf(\"%lf\\n\",x);\n  }\n\n  return 0;\n  \n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double q;\n    \n    while(1) {\n        scanf(\"%lf\", &q);\n        if(q == -1) break;\n        \n        double x = q / 2.0;\n        \n        while(fabs(x * x * x - q) >= 0.00001 * q) {\n            x = x - (x * x * x - q) / (3 * x * x);\n        }\n        \n        printf(\"%.6f\\n\", x);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { double q; while(1) { scanf(\"%lf\", &q); if(q ==  x * x  - (x * x * x - q) / (3 * x * x); } printf(\"%.6f\\n\", x); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> int main(int argc,char* argv[]){ for(;;){ int q; double x; scanf(\"%d\",&q); if(q  x = x - (x*x*x-q)/(3*x*x); } printf(\"%lf\\n\",x); } return 0; }"], "original_ll": -1.3982172012329102, "sampled_ll": -0.8093869090080261, "all_perturbed_sampled_ll": [-1.8479214906692505], "all_perturbed_original_ll": [-1.8929189443588257], "perturbed_sampled_ll": -1.8479214906692505, "perturbed_original_ll": -1.8929189443588257, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-5;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tdouble q = sc.nextDouble();\n\t\t\tif( q == 0 ) { System.out.println(0.00000); continue; }\n\t\t\tif( q == -1 ) break;\n\t\t\tdouble x = q / 2;\n\t\t\twhile( abs( x*x*x - q) >= EPS * q ) {\n\t\t\t\tx = f(x, q);\n\t\t\t}\n\t\t\tdebug(EPS*q);\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n\t\n\tdouble f(double x, double q) {\n\t\treturn x - (x*x*x - q) / ( 3 * x*x);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int q = sc.nextInt();\n            if (q == -1) break;\n            \n            double x = q / 2.0;\n            \n            while (Math.abs(x * x * x - q) >= 0.00001 * q) {\n                x = x - (x * x * x - q) / (3 * x * x);\n            }\n            \n            System.out.printf(\"%.6f\\n\", x);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) {  = q / 2.0; while (Math.abs(x * x * x - q) >= 0.00001 * q) { x = x - (x * x * x - q) /  } }"], "perturbed_original": ["import java.util.*; import static java.lang.Math.*; import static java.util.Arrays.*; public class Main { int INF = 1 << 28; double EPS = 1e-5;  double q = sc.nextDouble(); if( q == 0 ) {  q) >= EPS *  } } double f(double x, double q) { return x - (x*x*x - q) / ( 3 * x*x); } public static void  // System.err.println(Arrays.deepToString(os)); } }"], "original_ll": -1.1372607946395874, "sampled_ll": -0.6905351281166077, "all_perturbed_sampled_ll": [-1.976269245147705], "all_perturbed_original_ll": [-2.3927106857299805], "perturbed_sampled_ll": -1.976269245147705, "perturbed_original_ll": -2.3927106857299805, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True :\n    q = int(input())\n    if q == -1 :\n        break\n    \n    n = 1\n    x = q / 2\n    while True :\n        if abs(x**3 - q) < (0.00001 * q) :\n            break\n        x = x - (x**3 - q) / (3 * x**2)\n    \n    print('{:.6f}'.format(x))\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    q = int(line.strip())\n    if q == -1:\n        break\n    \n    x = q / 2.0\n    \n    while abs(x**3 - q) >= 0.00001 * q:\n        x = x - (x**3 - q) / (3 * x**2)\n    \n    print(f\"{x:.6f}\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: q = int(line.strip()) if q == -1:  >= 0.00001 * q: x = x - (x**3 - q) / (3 * x**2) print(f\"{x:.6f}\")"], "perturbed_original": ["while True :  = 1 x =  < (0.00001 * q) : break x = x - (x**3 - q) / (3 * x**2) print('{:.6f}'.format(x))"], "original_ll": -1.173939824104309, "sampled_ll": -1.235925316810608, "all_perturbed_sampled_ll": [-2.3288936614990234], "all_perturbed_original_ll": [-2.6499946117401123], "perturbed_sampled_ll": -2.3288936614990234, "perturbed_original_ll": -2.6499946117401123, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\n  double x1,y1,x2,y2,xq,yq,x,y;\n  double a,b,A,B,cx,cy;\n\n  while(~scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\",&x1,&y1,&x2,&y2,&xq,&yq)){\n    \n    if(y1==0 && y2==0){\n      printf(\"%lf %lf\\n\",xq,-yq);\n      continue;\n    }\n    if(xx1==0 && x2==0){\n      printf(\"%lf %lf\\n\",-xq,yq);\n      continue;\n    }\n    a=(y2-y1)?(x2-x1)/(y2-y1):0;\n    b=y2-a*x2;\n\n    A=a?-1/a:0;\n    B=yq-A*xq;\n\n    cx=(a-A)?(B-b)/(a-A):0;\n    cy=A*cx+B;\n\n    x=2*cx-xq;\n    y=2*cy-yq;\n\n    printf(\"%lf %lf\\n\",x,y);\n  }\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double x1, y1, x2, y2, xq, yq;\n    \n    while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\", &x1, &y1, &x2, &y2, &xq, &yq) == 6) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        \n        double a = dx * dx + dy * dy;\n        double t = ((xq - x1) * dx + (yq - y1) * dy) / a;\n        \n        double px = x1 + t * dx;\n        double py = y1 + t * dy;\n        \n        double rx = 2 * px - xq;\n        double ry = 2 * py - yq;\n        \n        printf(\"%.6f %.6f\\n\", rx, ry);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { double x1, y1, x2, y2,  == 6) { double dx = x2 - x1; double  dx + dy * dy; double t =  dy) / a; double px = x1 + t * dx; double py = y1 + t * dy; double rx   0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ double x1,y1,x2,y2,xq,yq,x,y; double a,b,A,B,cx,cy; while(~scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\",&x1,&y1,&x2,&y2,&xq,&yq)){ if(y1==0 && y2==0){ printf(\"%lf %lf\\n\",xq,-yq); continue; } if(xx1==0 && x2==0){ printf(\"%lf -xq; printf(\"%lf<extra_id_3>for(a==0;a<2&yq;a++){<extra_id_4>]; }<extra_id_5>*/ } printf (<extra_id_6>%r\\n\",xq,-xq); printf(\"%lf<extra_id_7>) ) {<extra_id_8>}<extra_id_9>2];\\n y=2*cy-yq; printf(\"%lf %lf\\n\",x,y); } return 0; }"], "original_ll": -1.0862812995910645, "sampled_ll": -0.4900423586368561, "all_perturbed_sampled_ll": [-2.161954402923584], "all_perturbed_original_ll": [-2.2098774909973145], "perturbed_sampled_ll": -2.161954402923584, "perturbed_original_ll": -2.2098774909973145, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(in.hasNext())new AOJ0081().doIt();\n\t}\n\n\tclass AOJ0081{\n\t\t//p0-p1\u306e\u76f4\u7dda\u304c\u3042\u308b\u3068\u304d\u306b\u76f4\u7ddap2\u304b\u3089\u76f4\u7dda\u3089\u3057\u305f\u3068\u304dp0-p1\u4e0a\u306e\u5782\u76f4\u306a\u70b9\u3092\u6c42\u3081\u308b\u3002\n\t\tprivate Point2D projection(Line2D l,Point2D p2){\n\t\t\tdouble kyori = l.getP1().distance(l.getP2());\n\t\t\tdouble angle = angle(l.getP1(),l.getP2(), p2);\n\t\t\tdouble t = l.getP1().distance(p2) * Math.cos(angle);\n\t\t\tPoint2D result = new Point2D.Double(l.getP1().getX()+(l.getP2().getX()-l.getP1().getX())*t/kyori,\n\t\t\t\t\tl.getP1().getY()+(l.getP2().getY()-l.getP1().getY())*t/kyori);\n\t\t\treturn result;\n\t\t}\n\t\tprivate double angle(Point2D p0, Point2D p1, Point2D p2){\n\t\t\treturn Math.atan2(p2.getY()-p0.getY(),p2.getX()-p0.getX())-\n\t\t\t\t\tMath.atan2(p1.getY()-p0.getY(),p1.getX()-p0.getX());\n\t\t}\n\t\t\n\t\t\n\t\tvoid doIt(){\n\t\t\tString input[] = in.next().split(\",\");\n\t\t\tdouble a[] = new double[input.length];\n\t\t\tfor(int i=0;i<a.length;i++)a[i] = Double.parseDouble(input[i]);\n\t\t\tLine2D l = new Line2D.Double(a[0], a[1], a[2], a[3]);\n\t\t\tPoint2D p = new Point2D.Double(a[4],a[5]);\n\t\t\tPoint2D result = projection(l, p);\n\t\t\t double dx = result.getX()-p.getX();\n             double dy = result.getY()-p.getY();\n             double tx = dx+result.getX();\n             double ty = dy+result.getY();\n             System.out.printf(\"%.9f %.9f\\n\",tx,ty);\n\t\t}\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            \n            double x1 = Double.parseDouble(parts[0]);\n            double y1 = Double.parseDouble(parts[1]);\n            double x2 = Double.parseDouble(parts[2]);\n            double y2 = Double.parseDouble(parts[3]);\n            double xq = Double.parseDouble(parts[4]);\n            double yq = Double.parseDouble(parts[5]);\n            \n            // Direction vector of the line P1P2\n            double dx = x2 - x1;\n            double dy = y2 - y1;\n            \n            // Vector from P1 to Q\n            double qx = xq - x1;\n            double qy = yq - y1;\n            \n            // Project Q onto the line P1P2\n            // Parameter t for the projection point\n            double t = (qx * dx + qy * dy) / (dx * dx + dy * dy);\n            \n            // Projection point H on the line\n            double hx = x1 + t * dx;\n            double hy = y1 + t * dy;\n            \n            // R is the reflection of Q across H\n            double rx = 2 * hx - xq;\n            double ry = 2 * hy - yq;\n            \n            System.out.printf(\"%.6f %.6f%n\", rx, ry);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String line = sc.nextLine(); String[] parts = line.split(\",\"); double x1 = Double.parseDouble(parts[0]); double y1 = Double.parseDouble(parts[1]); double x2 = Double.parseDouble(parts[2]); double y2 = Double.parseDouble(parts[3]); double xq = Double.parseDouble(parts[4]); double yq  dx = x2 -  P1 to Q double qx =  Project Q onto the line P1P2 // Parameter t for the projection point double t = (qx * dx  hy = y1 + t *  ry = 2 * hy - yq; System.out.printf(\"%.6f %.6f%n\", rx, ry); } sc.close(); } }"], "perturbed_original": ["import java.awt.geom.Line2D; import java.awt.geom.Point2D; import java.util.*; public class Main { Scanner in = new Scanner(System.in); public static void main(String[] args) { new Main(); } public Main() { while(in.hasNext())new AOJ0081().doIt();   l.getP1().getY()+(l.getP2().getY()-l.getP1().getY())*t/kyori); return result; } private double angle(Point2D p0, Point2D p1, Point2D p2){ return  a[] = new double[input.length]; for(int  a[3]); Point2D p = new Point2D.Double(a[4],a[5]); Point2D result = projection(l, p); double dx = result.getX()-p.getX();  = dy+result.getY(); System.out.printf(\"%.9f %.9f\\n\",tx,ty); } } }"], "original_ll": -0.9384642243385315, "sampled_ll": -0.517986536026001, "all_perturbed_sampled_ll": [-1.625238299369812], "all_perturbed_original_ll": [-2.01535701751709], "perturbed_sampled_ll": -1.625238299369812, "perturbed_original_ll": -2.01535701751709, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfrom math import complex as C\nfor e in sys.stdin:\n a,b,c,d,e,f=map(float,e.split(','))\n z,w,q=C(a,b),C(c,d),C(e,f)\n w-=z\n z+=(w/abs(w))**2*(q-z).conjugate()\n print(z.real,z.imag)\n", "sampled": "import sys\n\ndef reflect_point(x1, y1, x2, y2, xq, yq):\n    # Vector along the line P1P2\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    # Vector from P1 to Q\n    qx = xq - x1\n    qy = yq - y1\n    \n    # Project Q onto the line P1P2\n    # t = dot(PQ, P1P2) / dot(P1P2, P1P2)\n    t = (qx * dx + qy * dy) / (dx * dx + dy * dy)\n    \n    # Point on the line closest to Q\n    px = x1 + t * dx\n    py = y1 + t * dy\n    \n    # Reflect Q across the line\n    rx = 2 * px - xq\n    ry = 2 * py - yq\n    \n    return rx, ry\n\nfor line in sys.stdin:\n    coords = list(map(float, line.strip().split(',')))\n    x1, y1, x2, y2, xq, yq = coords\n    rx, ry = reflect_point(x1, y1, x2, y2, xq, yq)\n    print(f\"{rx:.6f} {ry:.6f}\")\n", "perturbed_sampled": ["import sys def reflect_point(x1, y1, x2, y2, xq, yq): # Vector along the line P1P2  - x1 qy = yq - y1 # Project Q onto  dy) / (dx * dx + dy * dy) # Point on the line closest to Q px = x1 + t * dx py = y1 + t  py - yq return rx, ry for line in sys.stdin: coords = list(map(float, line.strip().split(','))) x1, y1, x2, y2, xq, yq =  print(f\"{rx:.6f} {ry:.6f}\")"], "perturbed_original": ["import sys from math import complex as C for e in sys.stdin: a,b,c,d,e,f=map(float,e.split(',')) z,w,q=C(a,b),C(c,d),C(e,f) w-=z z+=(w/abs(w))**2*(q-z).conjugate() print(z.real,z.imag)"], "original_ll": -2.2443127632141113, "sampled_ll": -0.5288609266281128, "all_perturbed_sampled_ll": [-2.158487319946289], "all_perturbed_original_ll": [-2.339080572128296], "perturbed_sampled_ll": -2.158487319946289, "perturbed_original_ll": -2.339080572128296, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <limits.h>\n\nstatic int units[8];\nstatic int waitings[8];\n\nvoid setup() {\n\tunits[0] = 4;\n\tunits[1] = 1;\n\tunits[2] = 4;\n\tunits[3] = 1;\n\tunits[4] = 2;\n\tunits[5] = 1;\n\tunits[6] = 2;\n\tunits[7] = 1;\n}\n\nint scan_waitings() {\n\treturn scanf(\"%d %d %d %d %d %d %d %d\",\n\t\t\t&waitings[0], &waitings[1], &waitings[2], &waitings[3],\n\t\t\t&waitings[4], &waitings[5], &waitings[6], &waitings[7]);\n}\n\nint count_passengers(int offset) {\n\tint sum = 0;\n\tint i;\n\tfor (i = 0; i < 8; i++) {\n\t\tsum += (units[(i + offset) % 8] > waitings[i]) ? waitings[i] : units[(i + offset) % 8];\n\t}\n\treturn sum;\n}\n\nvoid print_result(int offset) {\n\tint i;\n\tfor (i = 0; i < 8; i++) {\n\t\tprintf(\"%d\", units[(i + offset) % 8]);\n\t\tif (i < 7) {\n\t\t\tprintf(\" \");\n\t\t} else {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}\n\nint main() {\n\tint offset = 0;\n\tint max = 0;\n\tint count = 0;\n\tint max_offset = 0;\n\tchar str[9];\n\tint num = INT_MAX;\n\tsetup();\n\n\twhile (scan_waitings() > 0) {\n\t\tmax = 0;\n\t\tcount = 0;\n\t\tmax_offset = 0;\n\t\tnum = INT_MAX;\n\t\tfor (offset = 0; offset < 8; offset++) {\n\t\t\tcount = count_passengers(offset);\n\t\t\tsprintf(str, \"%d%d%d%d%d%d%d%d\",\n\t\t\t\t\t\tunits[(0 + offset) % 8],\n\t\t\t\t\t\tunits[(1 + offset) % 8],\n\t\t\t\t\t\tunits[(2 + offset) % 8],\n\t\t\t\t\t\tunits[(3 + offset) % 8],\n\t\t\t\t\t\tunits[(4 + offset) % 8],\n\t\t\t\t\t\tunits[(5 + offset) % 8],\n\t\t\t\t\t\tunits[(6 + offset) % 8],\n\t\t\t\t\t\tunits[(7 + offset) % 8]\n\t\t\t\t\t\t);\n\t\t\tif (count > max) {\n//\t\t\t\tprintf(\"\u65b0\u8a18\u9332   offset = %d, \u914d\u7f6e = %d\\n\", offset, atoi(str));\n\t\t\t\tnum = atoi(str);\n\t\t\t\tmax_offset = offset;\n\t\t\t\tmax = count;\n\t\t\t} else if (count == max) {\n\t\t\t\tprintf(\"\u30bf\u30a4\u8a18\u9332 offset = %d, \u914d\u7f6e = %d\\n\", offset, atoi(str));\n\t\t\t\tif (num > atoi(str)) {\n\t\t\t\t\tmax = count;\n\t\t\t\t\tnum = atoi(str);\n\t\t\t\t\tmax_offset = offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprint_result(max_offset);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int p[8];\n    int rides[8] = {4, 1, 4, 1, 2, 1, 2, 1}; // Initial configuration\n    \n    while (scanf(\"%d %d %d %d %d %d %d %d\", &p[0], &p[1], &p[2], &p[3], &p[4], &p[5], &p[6], &p[7]) == 8) {\n        int best_rotation = 0;\n        int min_left = 1000000;\n        long long min_value = 99999999;\n        \n        // Try all 8 rotations\n        for (int rot = 0; rot < 8; rot++) {\n            int left = 0;\n            long long value = 0;\n            \n            // Calculate how many customers can't ride and the resulting value\n            for (int i = 0; i < 8; i++) {\n                int ride_pos = (i - rot + 8) % 8;\n                int capacity = rides[ride_pos];\n                int customers = p[i];\n                \n                if (customers > capacity) {\n                    left += customers - capacity;\n                }\n                \n                value = value * 10 + capacity;\n            }\n            \n            // Update best if this is better\n            if (left < min_left || (left == min_left && value < min_value)) {\n                min_left = left;\n                min_value = value;\n                best_rotation = rot;\n            }\n        }\n        \n        // Output the best configuration\n        for (int i = 0; i < 8; i++) {\n            int ride_pos = (i - best_rotation + 8) % 8;\n            if (i > 0) printf(\" \");\n            printf(\"%d\", rides[ride_pos]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int p[8]; int rides[8] = {4,  while  int best_rotation = 0; int min_left = 1000000; long long min_value = 99999999; // Try  8; rot++) {  value for (int i = 0;  rot  = p[i]; if (customers > capacity) { left += customers - capacity; } value = value * 10 + capacity; } // Update best if this is better  < min_value)) { min_left = left; min_value = value;  for (int i = 0; i < 8; i++) { int ride_pos = (i - best_rotation + 8) % 8; if (i > 0) printf(\" \"); printf(\"%d\", rides[ride_pos]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": [" void setup() { units[0] = 4; units[1]   } int scan_waitings() { return scanf(\"%d %d %d %d %d %d %d %d\", &waitings[0], &waitings[1],  { int sum = 0; int i; for (i = 0; i < 8; i++) { sum += (units[(i + offset) % 8]  } return sum; } void print_result(int offset) { int i; for (i = 0; i < 8; i++) { printf(\"%d\", units[(i + offset) % 8]); if (i  } }  0; int count = 0; int max_offset = 0; char str[9]; int num = INT_MAX; setup(); while (scan_waitings() >  0; num = INT_MAX; for  count_passengers(offset); sprintf(str, \"%d%d%d%d%d%d%d%d\", units[(0 + offset)  offset) % 8], units[(5 +  offset) % 8] ); if (count > max) { // printf(\"\u65b0\u8a18\u9332 offset = %d, \u914d\u7f6e = %d\\n\", offset, atoi(str)); num = atoi(str); max_offset = offset; max = count; } else if (count  offset, atoi(str)); if (num > atoi(str)) {  } } print_result(max_offset); } return 0; }"], "original_ll": -0.6256103515625, "sampled_ll": -0.6897754073143005, "all_perturbed_sampled_ll": [-2.105832099914551], "all_perturbed_original_ll": [-1.803956389427185], "perturbed_sampled_ll": -2.105832099914551, "perturbed_original_ll": -1.803956389427185, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Main {\n    \n    public static void main( final String[] args ) {\n\t\n\tfinal Scanner stdin = new Scanner( System.in );\n\tfinal int[] ls = { 4, 1, 4, 1, 2, 1, 2, 1 };\n\t\n\twhile ( stdin.hasNextInt() ) {\n\t    final int[] ps = new int[8];\n\t    for ( int i = 0; i < 8; i++ ) {\n\t\tps[i] = stdin.nextInt();\n\t    }\n\t    \n\t    final int[] ans = new int[8];\t    \n\t    int maxPeople = 0;\n\t    for ( int i = 0; i < 8; i++ ) {\n\t\tfinal int p = ip( ps, ls );\n\t\tif ( p > maxPeople ) {\n\t\t    maxPeople = p;\n\t\t    System.arraycopy( ls, 0, ans, 0, 8 );\n\t\t}\n\t\tnext( ls );\n\t    }\n\t    System.out.print( ans[0] );\n\t    for ( int i = 1; i < 8; i++ ) {\n\t\tSystem.out.print( \" \" + ans[i] );\n\t    }\n\t    System.out.println();\n\t}\n    }\n    \n    static void next( int[] a ) {\n\tfinal int front = a[0];\n\tfor ( int i = 0; i < 7; i++ ) {\n\t    a[i] = a[i + 1];\n\t}\n\ta[7] = front;\n    }\n\n    static int ip( int[] ps, int[] ls ) {\n\tint sum = 0;\n\tfor ( int i = 0; i < ps.length; i++ ){\n\t    sum += min( ls[i], ps[i] );\n\t}\n\treturn sum;\n    }    \n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int[] people = new int[8];\n            for (int i = 0; i < 8; i++) {\n                people[i] = sc.nextInt();\n            }\n            \n            int[] rides = {4, 1, 4, 1, 2, 1, 2, 1};\n            \n            int minUnserved = Integer.MAX_VALUE;\n            int[] bestArrangement = new int[8];\n            \n            for (int rotation = 0; rotation < 8; rotation++) {\n                int[] currentArrangement = new int[8];\n                for (int i = 0; i < 8; i++) {\n                    currentArrangement[i] = rides[(i - rotation + 8) % 8];\n                }\n                \n                int unserved = 0;\n                for (int i = 0; i < 8; i++) {\n                    unserved += Math.max(0, people[i] - currentArrangement[i]);\n                }\n                \n                if (unserved < minUnserved) {\n                    minUnserved = unserved;\n                    bestArrangement = currentArrangement.clone();\n                } else if (unserved == minUnserved) {\n                    if (isSmaller(currentArrangement, bestArrangement)) {\n                        bestArrangement = currentArrangement.clone();\n                    }\n                }\n            }\n            \n            for (int i = 0; i < 8; i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(bestArrangement[i]);\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean isSmaller(int[] a, int[] b) {\n        for (int i = 0; i < 8; i++) {\n            if (a[i] < b[i]) return true;\n            if (a[i] > b[i]) return false;\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int[] people = new int[8]; for (int i  } int[] rides = {4, 1, 4, 1, 2, 1, 2, 1}; int minUnserved = Integer.MAX_VALUE; int[] bestArrangement = new  < 8; i++) { unserved += Math.max(0, people[i] -  bestArrangement = currentArrangement.clone(); } else if (unserved == minUnserved) { if (isSmaller(currentArrangement, bestArrangement)) {  0; i < 8; i++) { if (i > 0) System.out.print(\" \"); System.out.print(bestArrangement[i]); } System.out.println(); } sc.close(); } private static boolean  return true; if (a[i] > b[i]) return false; } return false; } }"], "perturbed_original": ["import java.util.*; import java.io.*;  final String[] args ) { final Scanner stdin = new Scanner(  ( int i = 0; i < 8; i++  new int[8]; int maxPeople = 0; for ( int i = 0; i < 8; i++ ) { final int   0, 8 ); } next( ls ); }  < 8; i++ ) { System.out.print( \" \" + ans[i] ); } System.out.println(); } } static void next( int[] a ) { final int front = a[0]; for ( int i = 0; i < 7; i++ ) { a[i] = a[i + 1]; } a[7] = front;  int sum = 0; for ( int i = 0; i < ps.length;  sum; } }"], "original_ll": -0.6981613636016846, "sampled_ll": -0.4170468747615814, "all_perturbed_sampled_ll": [-1.6929876804351807], "all_perturbed_original_ll": [-1.843744158744812], "perturbed_sampled_ll": -1.6929876804351807, "perturbed_original_ll": -1.843744158744812, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\np=['41412121','41212141','21414121','21214141','14141212','14121214','12141412','12121414']\ng=lambda x:list(map(int,x))\nfor e in sys.stdin:\n d={}\n for f in p:d[sum(s-t for s,t in zip(g(e.split()),g(f))if s>t)]=f\n print(*list(d[min(d)]))\n", "sampled": "import sys\nfrom itertools import permutations\n\ndef solve(passengers):\n    # Define the vehicles: 4, 4, 2, 2, 1, 1, 1, 1\n    vehicles = [4, 4, 2, 2, 1, 1, 1, 1]\n    \n    min_unable = float('inf')\n    best_arrangement = None\n    \n    # Generate all unique permutations of vehicles\n    seen = set()\n    for perm in permutations(vehicles):\n        if perm in seen:\n            continue\n        seen.add(perm)\n        \n        # Calculate unable to ride\n        unable = 0\n        for i in range(8):\n            if passengers[i] > perm[i]:\n                unable += passengers[i] - perm[i]\n        \n        # Check if this is better\n        if unable < min_unable:\n            min_unable = unable\n            best_arrangement = perm\n        elif unable == min_unable:\n            # Compare lexicographically\n            if perm < best_arrangement:\n                best_arrangement = perm\n    \n    return best_arrangement\n\n# Read all input\nlines = []\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        lines.append(line)\n\n# Process each dataset\nfor line in lines:\n    passengers = list(map(int, line.split()))\n    result = solve(passengers)\n    print(' '.join(map(str, result)))\n", "perturbed_sampled": ["import sys from itertools import permutations def solve(passengers): # Define the vehicles: 4, 4, 2, 2, 1, 1, 1, 1 vehicles = [4, 4, 2, 2, 1, 1, 1, 1] min_unable = float('inf') best_arrangement = None # Generate all unique permutations  perm in seen: continue seen.add(perm)  - perm[i] # Check if this is better if  input lines = [] for line in sys.stdin: line = line.strip() if line: lines.append(line)  list(map(int, line.split())) result = solve(passengers) print(' '.join(map(str, result)))"], "perturbed_original": ["import sys  in p:d[sum(s-t for s,t in zip(g(e.split()),g(f))if s>t)]=f print(*list(d[min(d)]))"], "original_ll": -1.6581324338912964, "sampled_ll": -0.7800477743148804, "all_perturbed_sampled_ll": [-2.0695900917053223], "all_perturbed_original_ll": [-5.1010308265686035], "perturbed_sampled_ll": -2.0695900917053223, "perturbed_original_ll": -5.1010308265686035, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int a,b,c,d,t=0;\n  char s;\n  while(scanf(\"%d %d %d\",&a,&b,&c)!=EOF){\n    if(a<=1868 && b<=9 && c<8){\n      printf(\"pre-meiji\\n\");\n      d=1;\n      t=1;\n    }\n    else if(a<=1912){\n      if(a!=1912){\n\tprintf(\"meiji \");\n\ta=a-1868+1;\n\td=0;\n\tt=1;\n      }\n      else if(a==1912){\n\tif(b<7){\n\t  printf(\"meiji \");\n\t  a=a-1868+1;\n\t  d=0;\n\t  t=1;\n\t}\n\telse if(b>=7){\n\t  if(c<30){\n\t    printf(\"meiji \");\n\t    a=a-1868+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t}\n      }\n    }\n    if(a<=1926 && t==0){\n      if(a!=1926){\n\tprintf(\"taisyo \");\n\ta=a-1912+1;\n\td=0;\n\tt=1;\n      }\n      else if(a==1926){\n\tif(b<12){\n\t  printf(\"taisyo \");\n\t  a=a-1912+1;\n\t  d=0;\n\t  t=1;\n\t}\n\telse if(b==12){\n\t  if(c<25){\n\t    printf(\"taisyo \");\n\t    a=a-1912+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t  if(c>=25){\n\t    printf(\"showa \");\n\t    a=a-1926+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t}\n      }\n    }\n    if(a<=1989 && t==0){\n      if(a!=1989){\n\tprintf(\"showa \");\n\ta=a-1926+1;\n\td=0;\n\tt=1;\n      }\n      else if(a==1989){\n\tif(b==1){\n\t  if(c<8){\n\t    printf(\"showa \");\n\t    a=a-1926+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t}\n      }\n    }\n    if(a>=1989 && t==0){\n      if(a!=1989){\n      printf(\"heisei \");\n      a=a-1989+1;\n      d=0;\n    }\n      else if(a==1989){\n\tif(b!=1){\n\t  printf(\"heisei \");\n\t  a=a-1989+1;\n\t  d=0;\n\t}\n\telse if(b==1){\n\t  if(c>=8){\n\t  printf(\"heisei \");\n\t  a=a-1989+1;\n\t  d=0;\n\t  }\n\t}\n      }\n    }\n    if(d==0){\n      printf(\"%d %d %d\\n\",a,b,c);\n    }\n  }\n  return (0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int year, month, day;\n    \n    while (scanf(\"%d %d %d\", &year, &month, &day) != EOF) {\n        if (year < 1868 || (year == 1868 && month < 9) || (year == 1868 && month == 9 && day < 8)) {\n            printf(\"pre-meiji\\n\");\n        }\n        else if (year < 1912 || (year == 1912 && month < 7) || (year == 1912 && month == 7 && day <= 29)) {\n            printf(\"meiji %d %d %d\\n\", year - 1868 + 1, month, day);\n        }\n        else if (year < 1926 || (year == 1926 && month < 12) || (year == 1926 && month == 12 && day <= 24)) {\n            printf(\"taisho %d %d %d\\n\", year - 1912 + 1, month, day);\n        }\n        else if (year < 1989 || (year == 1989 && month == 1 && day <= 7)) {\n            printf(\"showa %d %d %d\\n\", year - 1926 + 1, month, day);\n        }\n        else {\n            printf(\"heisei %d %d %d\\n\", year - 1989 + 1, month, day);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int year, month, day; while (scanf(\"%d %d %d\", &year, &month, &day) !=  && month  && day < 8)) { printf(\"pre-meiji\\n\"); } else if (year < 1912 ||  1912 && month  && month < 12) || (year == 1926  day); } else if (year < 1989 || (year == 1989 && month == 1 && day <= 7)) { printf(\"showa %d %d %d\\n\", year - 1926 + 1, month, day); } else { printf(\"heisei %d %d %d\\n\", year - 1989 + 1, month, day); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int a,b,c,d,t=0; char s; while(scanf(\"%d  } else if(a<=1912){  printf(\"meiji \"); a=a-1868+1; d=0; t=1; } } } }  else if(a==1926){ if(b<12){ printf(\"taisyo \"); a=a-1912+1; d=0; t=1; } else if(b==12){ if(c<25){ printf(\"taisyo \"); a=a-1912+1; d=0; t=1; } if(c>=25){  && t==0){ if(a!=1989){ printf(\"showa \"); a=a-1926+1; d=0; t=1;  } } } } if(a>=1989 && t==0){ if(a!=1989){ printf(\"heisei  d=0; } else if(b==1){ if(c>=8){ printf(\"heisei \"); a=a-1989+1; d=0; } } } } if(d==0){ printf(\"%d %d %d\\n\",a,b,c); } } return (0); }"], "original_ll": -0.6027581095695496, "sampled_ll": -0.44209176301956177, "all_perturbed_sampled_ll": [-1.454617977142334], "all_perturbed_original_ll": [-1.3776870965957642], "perturbed_sampled_ll": -1.454617977142334, "perturbed_original_ll": -1.3776870965957642, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nclass Main\n{\n    public static void main(String args[])throws IOException\n    {\n\tBufferedReader input=new BufferedReader(new InputStreamReader(System.in));\n\tString str;\n\twhile((str=input.readLine())!=null)\n\t    {\n\t\tString str_ary[]=str.split(\" \");\n\t\tint x[]=new int[3];\n\t\tfor(int i=0;i<3;i++)\n\t\t    {\n\t\t\tx[i]=Integer.parseInt(str_ary[i]);\n\t\t\t\n\t\t    }\n\t\tif((x[0]<1868) \n\t\t   || ((x[0]==1868) && (x[1]<9))\n\t\t   || ((x[0]==1868) && (x[1]==9) && (x[2]<8)))System.out.println(\"pre-meiji\");\n\t\tif(((1869<=x[0]) && (x[0]<=1911))\n\t\t   || (x[0]==1868) && (9<=x[1]) && (8<=x[2])\n\t\t   \n\t\t   || (x[0]==1912 && x[1]==7 && x[2]<=29)\n\t\t   || (x[0]==1912) && x[1]<=7)System.out.println(\"meiji\");\n\t\tif(((1913<=x[0]) && (x[0]<=1925))\n\t\t   || ((x[0]==1912) && (7<=x[1]) && (30<=x[2]))\n\t\t   || (x[0]==1926 && x[1]==12 && x[2]<=24)\n\t\t   || ((x[0]==1912) && (7<=x[1]))\n\t\t   )System.out.println(\"taisho\");\n\t\tif(((1927<=x[0]) && (x[0]<=1988))\n\t\t   || ((x[0]==1926) && (12==x[1]) && (25<=x[2]))\n\t\t   || ((x[0]==1989) && (x[1]==1) && (x[2]<=7))\n\t\t   \n\t\t   \n)System.out.println(\"showa\");\n\t\tif((1989==x[0]) && (1<=x[1]) && (8<=x[2])\n\t\t   || 1990<=x[0]\n\t\t   || (1989==x[0]) && (1<x[1]))System.out.println(\"heisei\");\n\t    }\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int year = sc.nextInt();\n            int month = sc.nextInt();\n            int day = sc.nextInt();\n            \n            // Convert to comparable format (YYYYMMDD)\n            int date = year * 10000 + month * 100 + day;\n            \n            // Define era boundaries\n            int meijiStart = 18680908;\n            int meijiEnd = 19120729;\n            int taishoStart = 19120730;\n            int taishoEnd = 19261224;\n            int showaStart = 19261225;\n            int showaEnd = 19890107;\n            int heiseiStart = 19890108;\n            \n            if (date < meijiStart) {\n                System.out.println(\"pre-meiji\");\n            } else if (date >= meijiStart && date <= meijiEnd) {\n                int eraYear = year - 1868 + 1;\n                System.out.println(\"meiji \" + eraYear + \" \" + month + \" \" + day);\n            } else if (date >= taishoStart && date <= taishoEnd) {\n                int eraYear = year - 1912 + 1;\n                System.out.println(\"taisho \" + eraYear + \" \" + month + \" \" + day);\n            } else if (date >= showaStart && date <= showaEnd) {\n                int eraYear = year - 1926 + 1;\n                System.out.println(\"showa \" + eraYear + \" \" + month + \" \" + day);\n            } else if (date >= heiseiStart) {\n                int eraYear = year - 1989 + 1;\n                System.out.println(\"heisei \" + eraYear + \" \" + month + \" \" + day);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int year = sc.nextInt(); int month =  * 100 + day;  19261224; int showaStart = 19261225; int showaEnd = 19890107; int heiseiStart = 19890108; if (date < meijiStart) { System.out.println(\"pre-meiji\"); } else if (date >= meijiStart && date <= meijiEnd) { int eraYear = year - 1868 + 1; System.out.println(\"meiji \" + eraYear + \" \" + month +  - 1912 + 1; System.out.println(\"taisho \" + eraYear +  { int  eraYear + \" \" + month + \" \" + day);  year - 1989 + 1; System.out.println(\"heisei \" + eraYear  } } sc.close(); } }"], "perturbed_original": [" IOException { BufferedReader input=new BufferedReader(new InputStreamReader(System.in)); String str; while((str=input.readLine())!=null) { String str_ary[]=str.split(\" \"); int x[]=new int[3]; for(int i=0;i<3;i++) { x[i]=Integer.parseInt(str_ary[i]); } if((x[0]<1868) ||  && (x[0]<=1911)) || (x[0]==1868) && (9<=x[1]) && (8<=x[2]) || (x[0]==1912 && x[1]==7 && x[2]<=29) || (x[0]==1912) && x[1]<=7)System.out.println(\"meiji\");  (x[0]==1926  && (x[0]<=1988)) || ((x[0]==1926) &&  if((1989==x[0]) && (1<=x[1]) && (8<=x[2]) || 1990<=x[0] || (1989==x[0]) && (1<x[1]))System.out.println(\"heisei\"); } } }"], "original_ll": -0.8536616563796997, "sampled_ll": -0.4157615005970001, "all_perturbed_sampled_ll": [-1.5262672901153564], "all_perturbed_original_ll": [-1.4099258184432983], "perturbed_sampled_ll": -1.5262672901153564, "perturbed_original_ll": -1.4099258184432983, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from datetime import datetime\ndef era(f):\n    meiji_st  = datetime(1868, 9, 8)\n    taisho_st = datetime(1912, 7,30)\n    showa_st  = datetime(1926,12,25)\n    heisei_st = datetime(1989, 1, 8)\n\n    y,m,d = f\n    dt = datetime(y,m,d)\n    if dt > heisei_st:\n        ret = \"heisei %d %d %d\" % (dt.year - heisei_st.year+1,dt.month,dt.day) \n    elif dt > showa_st:\n        ret = \"showa %d %d %d\" % (dt.year - showa_st.year+1,dt.month,dt.day) \n    elif dt > taisho_st:\n        ret = \"taisho %d %d %d\" % (dt.year - taisho_st.year+1,dt.month,dt.day) \n    elif dt > meiji_st:\n        ret = \"meiji %d %d %d\" % (dt.year - meiji_st.year+1,dt.month,dt.day) \n    else:\n       ret = \"pre-meiji\"\n\n    return(ret)\n\nwhile True:\n    try:\n        f = map(int, input().strip().split())\n        print(era(f))\n    except EOFError:\n        break", "sampled": "import sys\n\ndef to_wareki(year, month, day):\n    # Convert date to comparable format (YYYYMMDD)\n    date = year * 10000 + month * 100 + day\n    \n    # Era boundaries in YYYYMMDD format\n    meiji_start = 18680908\n    meiji_end = 19120729\n    taisho_start = 19120730\n    taisho_end = 19261224\n    showa_start = 19261225\n    showa_end = 19890107\n    heisei_start = 19890108\n    \n    if date < meiji_start:\n        return \"pre-meiji\"\n    elif date <= meiji_end:\n        wareki_year = year - 1868 + 1\n        return f\"meiji {wareki_year} {month} {day}\"\n    elif date <= taisho_end:\n        wareki_year = year - 1912 + 1\n        return f\"taisho {wareki_year} {month} {day}\"\n    elif date <= showa_end:\n        wareki_year = year - 1926 + 1\n        return f\"showa {wareki_year} {month} {day}\"\n    else:\n        wareki_year = year - 1989 + 1\n        return f\"heisei {wareki_year} {month} {day}\"\n\nfor line in sys.stdin:\n    parts = line.strip().split()\n    year = int(parts[0])\n    month = int(parts[1])\n    day = int(parts[2])\n    print(to_wareki(year, month, day))\n", "perturbed_sampled": ["import sys def  + day # Era  taisho_start = 19120730 taisho_end = 19261224 showa_start = 19261225 showa_end = 19890107  date <= meiji_end: wareki_year = year - 1868 + 1 return f\"meiji {wareki_year} {month} {day}\" elif date <= taisho_end: wareki_year = year - 1912 + 1 return f\"taisho  - 1926 + 1 return f\"showa {wareki_year} {month} {day}\" else: wareki_year = year - 1989 + 1 return f\"heisei {wareki_year} {month} {day}\" for line in sys.stdin: parts  int(parts[2]) print(to_wareki(year, month, day))"], "perturbed_original": ["from datetime import datetime def era(f):  = datetime(1926,12,25) heisei_st = datetime(1989, 1, 8)  ret  dt >  %d %d\" % (dt.year - taisho_st.year+1,dt.month,dt.day) elif dt > meiji_st: ret = \"meiji %d %d %d\" % (dt.year - meiji_st.year+1,dt.month,dt.day) else: ret = \"pre-meiji\" return(ret) while True: try: f = map(int, input().strip().split()) print(era(f)) except EOFError: break"], "original_ll": -0.6804536581039429, "sampled_ll": -0.5960653424263, "all_perturbed_sampled_ll": [-1.7282270193099976], "all_perturbed_original_ll": [-1.9526535272598267], "perturbed_sampled_ll": -1.7282270193099976, "perturbed_original_ll": -1.9526535272598267, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<stdlib.h>\nint main(void){\n\tint n,m,i,j;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=j=0;i++<n;j%=i){j+=m;}\n\t\tprintf(\"%d\\n\",j+1);\n\t}\n\treturn 0; \n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n, m;\n    \n    while(1) {\n        scanf(\"%d %d\", &n, &m);\n        if(n == 0 && m == 0) break;\n        \n        int people[1000];\n        for(int i = 0; i < n; i++) {\n            people[i] = i + 1;\n        }\n        \n        int count = n;\n        int pos = n - 1;\n        \n        while(count > 1) {\n            int steps = m % count;\n            if(steps == 0) steps = count;\n            \n            pos = (pos + steps) % count;\n            \n            for(int i = pos; i < count - 1; i++) {\n                people[i] = people[i + 1];\n            }\n            count--;\n            \n            if(count > 0) {\n                pos = pos % count;\n            }\n        }\n        \n        printf(\"%d\\n\", people[0]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n, m; while(1) { scanf(\"%d  break; int people[1000]; for(int i = 0; i \"); } n =<extra_id_4>people[i];<extra_id_5>1) * n<extra_id_6>; } n=<extra_id_7>(m = 1-<extra_id_8>\"i  while(count > 1) { int steps = m % count; if(steps == 0) steps = count; pos = (pos + steps) % count; for(int i = pos; i < count - 1; i++) { people[i] = people[i + \" , m -<extra_id_9>{ if<extra_id_10>><extra_id_11>{<extra_id_12>m ||<extra_id_13>\\nuo \\n\\ t\\ n\"\";<extra_id_14>) >> 1 ]<extra_id_15>- 1<extra_id_16>* = 8; w<extra_id_17>} else<extra_id_18>w; int e }"], "perturbed_original": ["#include<stdio.h> #include<stdlib.h> int main(void){ int n,m,i,j; while(scanf(\"%d\",&n)!=EOF){ scanf(\"%d\",&m); for(i=j=0;i++<n;j%=i){j+=m;} printf(\"%d\\n\",j+1); } return 0; }"], "original_ll": -1.5473483800888062, "sampled_ll": -0.5520979166030884, "all_perturbed_sampled_ll": [-2.535604953765869], "all_perturbed_original_ll": [-1.7328218221664429], "perturbed_sampled_ll": -2.535604953765869, "perturbed_original_ll": -1.7328218221664429, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main ( String[] args ) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tArrayList<Integer> List;\n\t\twhile ( true ) {\n\t\t\tint remove = 0;\n\t\t\tList = new ArrayList<Integer>();\n\t\t\tint size = sc.nextInt();\n\t\t\tint space = sc.nextInt();\n\t\t\tif ( size == 0 && space == 0 ) break;\n\t\t\tspace--;\n\t\t\tfor ( int i = 1; i <= size; i++ )\n\t\t\t\tList.add(i);\n\t\t\twhile ( List.size() != 1 ) {\n\t\t\t\tremove += space;\n\t\t\t\twhile ( remove >= List.size() )\n\t\t\t\t\tremove -= List.size();\n\t\t\t\tList.remove(remove);\n\t\t\t}\n\t\t\tSystem.out.println(List.get(0));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) {\n                break;\n            }\n            \n            ArrayList<Integer> people = new ArrayList<>();\n            for (int i = 1; i <= n; i++) {\n                people.add(i);\n            }\n            \n            int currentIndex = 0;\n            \n            while (people.size() > 1) {\n                currentIndex = (currentIndex + m - 1) % people.size();\n                people.remove(currentIndex);\n                if (currentIndex == people.size() && people.size() > 0) {\n                    currentIndex = 0;\n                }\n            }\n            \n            System.out.println(people.get(0));\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public  while (true) { int n = sc.nextInt(); int m = sc.nextInt(); if (n == 0 && m == 0) { break; } ArrayList<Integer> people = new ArrayList<>(); for (int i = 1; i <= n; i++) { people.add(i); } int currentIndex = 0;  } System.out.println(people.get(0)); } sc.close(); } }"], "perturbed_original": ["import java.io.*; import  String[] args ) { Scanner sc = new Scanner(System.in); ArrayList<Integer> List; while ( true ) {  = sc.nextInt(); int space = sc.nextInt(); if ( size == 0 && space ==  i <= size; i++ ) List.add(i);  while ( remove >= List.size() ) remove -= List.size(); List.remove(remove); } System.out.println(List.get(0)); } } }"], "original_ll": -0.816221296787262, "sampled_ll": -0.42495784163475037, "all_perturbed_sampled_ll": [-1.2954120635986328], "all_perturbed_original_ll": [-2.310546875], "perturbed_sampled_ll": -1.2954120635986328, "perturbed_original_ll": -2.310546875, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n  n,m=map(int,raw_input().split())\n  if n==0==m:break\n  p=0\n  for i in range(2,n+1):p=(p+m)%i\n  print p+1", "sampled": "def find_winner(n, m):\n    people = list(range(1, n + 1))\n    current = 0\n    \n    while len(people) > 1:\n        current = (current + m - 1) % len(people)\n        people.pop(current)\n        if current == len(people) and len(people) > 0:\n            current = 0\n    \n    return people[0]\n\nwhile True:\n    n, m = map(int, input().split())\n    if n == 0 and m == 0:\n        break\n    print(find_winner(n, m))\n", "perturbed_sampled": ["def find_winner(n, m): people = list(range(1, n + 1))  + m - 1) % len(people) people.pop(current) if current == len(people) and len(people)  m = map(int, input().split()) if n == 0 and m == 0: break print(find_winner(n, m))"], "perturbed_original": ["while 1: n,m=map(int,raw_input().split()) if n==0==m:break p=0 for i in range(2,n+1):p=(p+m)%i print p+1"], "original_ll": -1.157636284828186, "sampled_ll": -0.5510858297348022, "all_perturbed_sampled_ll": [-2.0052969455718994], "all_perturbed_original_ll": [-1.5994656085968018], "perturbed_sampled_ll": -2.0052969455718994, "perturbed_original_ll": -1.5994656085968018, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(int argc,char* argv[]){\n  int i;\n  int graph[101];\n\n  for(;;){\n    int from = -1,to = -1,odd_num = 0;\n\n    for(i = 1; i <= 100; i++){\n      graph[i] = -1;\n    }\n\n    while(scanf(\"%d %d\",&from,&to) != EOF){\n      if(from == 0 && to == 0){\n\tbreak;\n      }else{\n\tgraph[to] = (graph[to] == -1) ? 1 : graph[to]+1;\n\tgraph[from] = (graph[from] == -1) ? 1 : graph[from]+1;\n      }\n    }\n\n    if(from != 0 || to != 0){\n      break;\n    }\n\n    for(i = 1; i <= 100; i++){\n      if(graph[i] == -1){break;}\n      if(graph[i]%2 == 1){odd_num++;}\n    }\n\n    if(odd_num == 0 || odd_num == 2){\n      printf(\"OK\\n\");\n    }else{\n      printf(\"NG\\n\");\n    }\n  }\n\n  return 0;\n  \n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAXN 105\n\nint adj[MAXN][MAXN];\nint n;\nint visited[MAXN];\nint path[MAXN];\nint pathlen;\nint found;\n\nvoid dfs(int u, int goal) {\n    if (found) return;\n    if (u == goal) {\n        found = 1;\n        return;\n    }\n    \n    for (int v = 1; v <= n; v++) {\n        if (adj[u][v] > 0 && !visited[v]) {\n            visited[v] = 1;\n            path[pathlen++] = v;\n            \n            for (int i = 0; i < adj[u][v]; i++) {\n                dfs(v, goal);\n                if (found) return;\n            }\n            \n            pathlen--;\n            visited[v] = 0;\n        }\n    }\n}\n\nint canReach(int start, int goal, int avoid) {\n    memset(visited, 0, sizeof(visited));\n    visited[start] = 1;\n    visited[avoid] = 1;\n    \n    pathlen = 0;\n    path[pathlen++] = start;\n    found = 0;\n    \n    dfs(start, goal);\n    return found;\n}\n\nint main() {\n    int a, b;\n    \n    while (1) {\n        memset(adj, 0, sizeof(adj));\n        n = 0;\n        \n        int first = 1;\n        while (1) {\n            if (scanf(\"%d %d\", &a, &b) != 2) return 0;\n            if (a == 0 && b == 0) break;\n            \n            adj[a][b]++;\n            adj[b][a]++;\n            \n            if (a > n) n = a;\n            if (b > n) n = b;\n            first = 0;\n        }\n        \n        if (first) break;\n        \n        memset(visited, 0, sizeof(visited));\n        visited[1] = 1;\n        pathlen = 0;\n        path[pathlen++] = 1;\n        found = 0;\n        \n        dfs(1, 2);\n        \n        if (!found) {\n            printf(\"NG\\n\");\n            continue;\n        }\n        \n        int ok = 1;\n        for (int i = 1; i < pathlen - 1; i++) {\n            int v = path[i];\n            if (!canReach(1, v, 2) || !canReach(v, 2, 1)) {\n                ok = 0;\n                break;\n            }\n        }\n        \n        if (ok) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAXN 105 int  return; } for (int v = 1; v <= n; v++) { if (adj[u][v] > 0 && !visited[v]) { visited[v] = 1; path[pathlen++] = v; for (int i = 0; i < adj[u][v]; i++) { dfs(v, goal); if (found) return; } pathlen--; visited[v] = 0; } } } int canReach(int start, int goal, int avoid) { memset(visited, 0, sizeof(visited)); visited[start] = 1;  { int a, b; while (1) { memset(adj, 0, sizeof(adj)); n = 0; int first = 1; while (1) { if (scanf(\"%d %d\", &a, &b) !=  0) break; adj[a][b]++; adj[b][a]++; if (a > n) n = a; if (b > n)  path[pathlen++]  i = 1;  path[i]; if (!canReach(1, v,  } } if (ok) { printf(\"OK\\n\"); } else { printf(\"NG\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(int argc,char* argv[]){ int i; int graph[101]; for(;;){ int from = -1,to = -1,odd_num = 0; for(i = 1; i <= 100; i++){ graph[i] = -1; } while(scanf(\"%d %d\",&from,&to)  0){ break; } for(i =  1){odd_num++;} } if(odd_num == 0 || odd_num == 2){ printf(\"OK\\n\"); }else{ printf(\"NG\\n\"); } } return 0; }"], "original_ll": -0.8550257682800293, "sampled_ll": -0.49819353222846985, "all_perturbed_sampled_ll": [-1.3471639156341553], "all_perturbed_original_ll": [-1.7400636672973633], "perturbed_sampled_ll": -1.3471639156341553, "perturbed_original_ll": -1.7400636672973633, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n/*answer*/\n    int a, b;\n    int[] count;\n    int i, n;\n\n    count = new int[100];\n    for(;sc.hasNext();){\n      for(i = 0;i < 100;i++)count[i] = 0;\n      n = 0;\n      for(;;){\n        a = sc.nextInt();\n        b = sc.nextInt();\n        if(a == 0 && b == 0)break;\n        count[a - 1]++; count[b - 1]++;\n      }\n\n      for(i = 0;i < 2;i++)if(count[i] % 2 == 0)n = 1;\n      for(i = 2;i < 100;i++)if(count[i] % 2 != 0)n = 1;\n\n      if(n == 1)out.println(\"NG\");\n      else out.println(\"OK\");\n    }\n\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to;\n        int id;\n        Edge(int to, int id) {\n            this.to = to;\n            this.id = id;\n        }\n    }\n    \n    static List<List<Edge>> graph;\n    static int[] edgeCount;\n    static boolean[] visited;\n    static boolean[] edgeUsed;\n    static int start = 1, goal = 2;\n    static boolean found;\n    static List<Integer> path;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            Map<String, Integer> edges = new HashMap<>();\n            List<int[]> edgeList = new ArrayList<>();\n            Set<Integer> nodes = new HashSet<>();\n            \n            while (true) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                if (a == 0 && b == 0) break;\n                \n                nodes.add(a);\n                nodes.add(b);\n                edgeList.add(new int[]{a, b});\n                \n                String key = Math.min(a, b) + \"-\" + Math.max(a, b);\n                edges.put(key, edges.getOrDefault(key, 0) + 1);\n            }\n            \n            int maxNode = 0;\n            for (int node : nodes) {\n                maxNode = Math.max(maxNode, node);\n            }\n            \n            graph = new ArrayList<>();\n            for (int i = 0; i <= maxNode; i++) {\n                graph.add(new ArrayList<>());\n            }\n            \n            edgeCount = new int[edgeList.size()];\n            int edgeId = 0;\n            for (int[] edge : edgeList) {\n                int a = edge[0];\n                int b = edge[1];\n                graph.get(a).add(new Edge(b, edgeId));\n                graph.get(b).add(new Edge(a, edgeId));\n                edgeId++;\n            }\n            \n            visited = new boolean[maxNode + 1];\n            edgeUsed = new boolean[edgeList.size()];\n            found = false;\n            path = new ArrayList<>();\n            \n            dfs(start, new ArrayList<>());\n            \n            if (found) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NG\");\n            }\n        }\n        sc.close();\n    }\n    \n    static void dfs(int current, List<Integer> currentPath) {\n        if (found) return;\n        \n        if (current == goal) {\n            // Check if all edges are used exactly once\n            boolean allUsed = true;\n            for (boolean used : edgeUsed) {\n                if (!used) {\n                    allUsed = false;\n                    break;\n                }\n            }\n            if (allUsed) {\n                found = true;\n                path = new ArrayList<>(currentPath);\n            }\n            return;\n        }\n        \n        visited[current] = true;\n        currentPath.add(current);\n        \n        for (Edge edge : graph.get(current)) {\n            if (!edgeUsed[edge.id]) {\n                edgeUsed[edge.id] = true;\n                dfs(edge.to, currentPath);\n                edgeUsed[edge.id] = false;\n                if (found) return;\n            }\n        }\n        \n        currentPath.remove(currentPath.size() - 1);\n        visited[current] = false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Edge { int to; int id; Edge(int to, int id) { this.to = to; this.id = id; } }   main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { Map<String, Integer> edges = new HashMap<>(); List<int[]> edgeList = new ArrayList<>();  = sc.nextInt();   = Math.min(a, b) + \"-\" + Math.max(a, b); edges.put(key, edges.getOrDefault(key, 0) + 1); } int maxNode = 0; for (int node :  i++)  =  Edge(a, edgeId)); edgeId++; } visited = new boolean[maxNode +  } else { System.out.println(\"NG\"); } } sc.close(); } static void dfs(int current, List<Integer> currentPath) { if (found) return; if (current == goal) { // Check  true; for (boolean used : edgeUsed) { if (!used) { allUsed = false; break; } } if (allUsed) { found = true; path = new ArrayList<>(currentPath); } return; } visited[current] = true; currentPath.add(current); for (Edge edge : graph.get(current)) { if  if (found) return; } } currentPath.remove(currentPath.size() - 1); visited[current] = false; } }"], "perturbed_original": ["public class Main{ public void run(java.io.InputStream in, java.io.PrintStream out){ java.util.Scanner sc = new java.util.Scanner(in);  = new int[100]; for(;sc.hasNext();){  for(;;){ a = sc.nextInt(); b = sc.nextInt(); if(a == 0 && b == 0)break; count[a - 1]++; count[b - 1]++; } for(i = 0;i < 2;i++)if(count[i] % 2 == 0)n = 1; for(i = 2;i < 100;i++)if(count[i] % 2 != 0)n  }"], "original_ll": -0.9335508942604065, "sampled_ll": -0.43664228916168213, "all_perturbed_sampled_ll": [-1.604269027709961], "all_perturbed_original_ll": [-1.4280723333358765], "perturbed_sampled_ll": -1.604269027709961, "perturbed_original_ll": -1.4280723333358765, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfrom collections import defaultdict\ndata_list = []\n\nfor line in sys.stdin:\n    data_list.append(list(map(int, line.split())))\n\ndef is_half_euler_graph(node_list):\n\n    for node in node_list:\n        odd_num_counter = 0\n        for dic_value in node.values():\n            if dic_value % 2 != 0:\n                odd_num_counter = odd_num_counter + 1\n\n        if odd_num_counter == 2:\n            print(\"OK\")\n        else :\n            print(\"NG\")\n\n\nif __name__ == '__main__' :\n    node_data_lists = []\n    tmp_list = []\n    count_lists = []\n    tmp_dic = {}\n    tmp_dic = defaultdict(int)\n\n    for i in range(0, len(data_list)):\n        if data_list[i][0] == 0 and data_list[i][1] == 0:\n            node_data_lists.append(tmp_list[:])\n            tmp_list.clear()\n        else :\n            tmp_list.append(data_list[i])\n\n    for node_data_list in node_data_lists :\n        tmp_dic.clear()\n        for i in range(0, len(node_data_list)):\n            tmp_dic[node_data_list[i][0]] += 1\n            tmp_dic[node_data_list[i][1]] += 1\n\n        count_lists.append(tmp_dic.copy())\n    is_half_euler_graph(count_lists)\n\n", "sampled": "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    datasets = []\n    current_edges = []\n    \n    for line in sys.stdin:\n        line = line.strip()\n        if not line:\n            continue\n        a, b = map(int, line.split())\n        if a == 0 and b == 0:\n            if current_edges:\n                datasets.append(current_edges)\n                current_edges = []\n        else:\n            current_edges.append((a, b))\n    \n    return datasets\n\ndef can_reach(graph, start, end, excluded_edge=None):\n    \"\"\"BFS to check if we can reach end from start, optionally excluding an edge\"\"\"\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                # Check if this edge should be excluded\n                if excluded_edge:\n                    edge = tuple(sorted([node, neighbor]))\n                    if edge == excluded_edge:\n                        continue\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\ndef check_conditions(edges):\n    # Build adjacency list (undirected graph)\n    graph = defaultdict(list)\n    edge_set = set()\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        edge_set.add(tuple(sorted([a, b])))\n    \n    # Condition 1: There must be a path from 1 to 2\n    if not can_reach(graph, 1, 2):\n        return False\n    \n    # Condition 2: Every road must be on some path from 1 to 2\n    for edge in edge_set:\n        a, b = edge\n        # Remove this edge temporarily and check if we can still reach 2 from 1\n        if not can_reach(graph, 1, 2, excluded_edge=edge):\n            # This edge is essential, so condition 2 is satisfied for this edge\n            continue\n        else:\n            # This edge is not essential, condition 2 fails\n            return False\n    \n    # Condition 3: Every intersection (except 1 and 2) must be on some path from 1 to 2\n    all_nodes = set()\n    for a, b in edges:\n        all_nodes.add(a)\n        all_nodes.add(b)\n    \n    for node in all_nodes:\n        if node == 1 or node == 2:\n            continue\n        \n        # Check if node is on some path from 1 to 2\n        # Node is on a path from 1 to 2 if:\n        # - we can reach node from 1, AND\n        # - we can reach 2 from node\n        if can_reach(graph, 1, node) and can_reach(graph, node, 2):\n            # Additionally, we need to check if removing this node disconnects 1 and 2\n            # But a simpler check: node is critical if there's no path from 1 to 2 avoiding it\n            \n            # For now, just check basic reachability\n            # Actually, we need to verify the node is on SOME path, not ALL paths\n            # If we can reach it from 1 and reach 2 from it, it's on some path\n            continue\n        else:\n            return False\n    \n    return True\n\ndef solve():\n    datasets = read_input()\n    \n    for edges in datasets:\n        if check_conditions(edges):\n            print(\"OK\")\n        else:\n            print(\"NG\")\n\nsolve()\n", "perturbed_sampled": [" = map(int, line.split()) if a == 0 and b == 0: if current_edges: datasets.append(current_edges) current_edges = [] else: current_edges.append((a, b)) return datasets def can_reach(graph, start, end, excluded_edge=None): \"\"\"BFS to check   node = queue.popleft() if node == end: return  # Check if this edge should be excluded  continue visited.add(neighbor) queue.append(neighbor) return False def  edge_set = set() for a, b in edges:  a path from 1 to 2 if not can_reach(graph, 1, 2): return False # Condition 2: Every road must be on some path from 1 to 2 for edge in edge_set: a,  not can_reach(graph, 1, 2, excluded_edge=edge): # This edge is essential, so condition 2 is satisfied for this edge continue else: # This edge  3: Every intersection (except 1 and 2) must be on some path from 1 to 2 all_nodes = set() for a, b in edges: all_nodes.add(a) all_nodes.add(b) for node in all_nodes: if node == 1 or node == 2: continue # Check if node is on some path from 1 to 2 # Node is on a path from 1 to 2  # - we can reach 2 from node if  need to check if removing this   is on SOME path, not ALL paths #  from it, it's on some path continue else: return False return True  check_conditions(edges): print(\"OK\") else: print(\"NG\") solve()"], "perturbed_original": ["import sys from collections import defaultdict data_list = [] for line in sys.stdin:  0 for dic_value in  + 1 if odd_num_counter == 2: print(\"OK\") else : print(\"NG\") if __name__ == '__main__' :  = {} tmp_dic = defaultdict(int)  data_list[i][1] == 0: node_data_lists.append(tmp_list[:]) tmp_list.clear() else : tmp_list.append(data_list[i]) for node_data_list in  1 tmp_dic[node_data_list[i][1]] += 1 count_lists.append(tmp_dic.copy()) is_half_euler_graph(count_lists)"], "original_ll": -0.9857255220413208, "sampled_ll": -0.8424849510192871, "all_perturbed_sampled_ll": [-2.082942008972168], "all_perturbed_original_ll": [-2.7302486896514893], "perturbed_sampled_ll": -2.082942008972168, "perturbed_original_ll": -2.7302486896514893, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "double*q,a[99],b;char s[9];main(){for(q=a;~scanf(\"%s\",s);getchar()<14&&printf(\"%f\\n\",*q)){!sscanf(s,\"%lf\",q+1)?b=*q--,*q=*s-47?*s-42?*s-45?*q+b:*q-b:*q*b:*q/b:*++q;}}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_STACK 1000\n\ndouble stack[MAX_STACK];\nint top = -1;\n\nvoid push(double val) {\n    stack[++top] = val;\n}\n\ndouble pop() {\n    return stack[top--];\n}\n\nint is_operator(char *token) {\n    return (strlen(token) == 1 && (token[0] == '+' || token[0] == '-' || \n            token[0] == '*' || token[0] == '/'));\n}\n\ndouble calculate(double a, double b, char op) {\n    switch(op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return a / b;\n    }\n    return 0;\n}\n\nint main() {\n    char line[1000];\n    \n    while(fgets(line, sizeof(line), stdin)) {\n        if(line[0] == '\\n') break;\n        \n        top = -1;\n        char *token = strtok(line, \" \\n\");\n        \n        while(token != NULL) {\n            if(is_operator(token)) {\n                double b = pop();\n                double a = pop();\n                double result = calculate(a, b, token[0]);\n                push(result);\n            } else {\n                double num = atof(token);\n                push(num);\n            }\n            token = strtok(NULL, \" \\n\");\n        }\n        \n        printf(\"%f\\n\", stack[0]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> #include <ctype.h> #define MAX_STACK 1000 double stack[MAX_STACK]; int top = -1; void push(double val) { stack[++top] = val; } double pop() { return stack[top--]; } int is_operator(char *token) { return (strlen(token) == 1 && (token[0] == '+' || token[0] == '-' || token[0] ==  b,  b; case '-': return a - b; case '*': return a * b; case '/':  '\\n') break; top =  { if(is_operator(token))  double num = atof(token); push(num); } token = strtok(NULL, \" \\n\"); } printf(\"%f\\n\", stack[0]); } return 0; }"], "perturbed_original": ["double*q,a[99],b;char s[9];main(){for(q=a;~scanf(\"%s\",s);getchar()<14&&printf(\"%f\\n\",*q)){!sscanf(s,\"%lf\",q+1)?b=*q--,*q=*s-47?*s-42?*s-45?*q+b:*q-b:*q*b:*q/b:*++q;}}"], "original_ll": -2.8481545448303223, "sampled_ll": -0.433257132768631, "all_perturbed_sampled_ll": [-1.463125228881836], "all_perturbed_original_ll": [-2.8481545448303223], "perturbed_sampled_ll": -1.463125228881836, "perturbed_original_ll": -2.8481545448303223, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc;\n\n\tstatic final int INF=1<<28;\n\tstatic final double EPS=1e-9;\n\n\tvoid run(){\n\t\tsc=new Scanner(System.in);\n\t\tfor(; sc.hasNext();){\n\t\t\tScanner c=new Scanner(sc.nextLine());\n\t\t\tLinkedList<Double> stack=new LinkedList<Double>();\n\t\t\tfor(; c.hasNext();){\n\t\t\t\tString s=c.next();\n\t\t\t\tif(Character.isDigit(s.charAt(0))){\n\t\t\t\t\tstack.addFirst(Double.parseDouble(s));\n\t\t\t\t}else{\n\t\t\t\t\tdouble d2=stack.removeFirst();\n\t\t\t\t\tdouble d1=stack.removeFirst();\n\t\t\t\t\tdouble d=0;\n//\t\t\t\t\tdouble d1=0,d2=0,d=0;\n\t\t\t\t\tswitch(s.charAt(0)){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\td=d1+d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\td=d1-d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\td=d1*d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\td=d1/d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstack.addFirst(d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble ans=stack.removeFirst();\n\t\t\tprintln(ans+\"\");\n\t\t}\n\t\tsc.close();\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line == null || line.trim().isEmpty()) {\n                break;\n            }\n            \n            String[] tokens = line.trim().split(\"\\\\s+\");\n            Stack<Double> stack = new Stack<>();\n            \n            for (String token : tokens) {\n                if (token.equals(\"+\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a + b);\n                } else if (token.equals(\"-\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a - b);\n                } else if (token.equals(\"*\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a * b);\n                } else if (token.equals(\"/\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a / b);\n                } else {\n                    stack.push(Double.parseDouble(token));\n                }\n            }\n            \n            System.out.printf(\"%.6f%n\", stack.pop());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*;  Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String line = sc.nextLine(); if (line == null || line.trim().isEmpty()) { break; } String[] tokens = line.trim().split(\"\\\\s+\"); Stack<Double> stack = new Stack<>();  else if (token.equals(\"*\")) { double b = stack.pop(); double a = stack.pop(); stack.push(a * b); } else if (token.equals(\"/\")) { double b = stack.pop(); double a = stack.pop(); stack.push(a  } sc.close(); } }"], "perturbed_original": ["import java.util.*; import  java.util.Arrays.*; public class Main{ Scanner sc; static final  for(; sc.hasNext();){ Scanner c=new Scanner(sc.nextLine()); LinkedList<Double> stack=new LinkedList<Double>(); for(; c.hasNext();){ String s=c.next(); if(Character.isDigit(s.charAt(0))){ stack.addFirst(Double.parseDouble(s)); }else{ double d2=stack.removeFirst(); double d1=stack.removeFirst(); double d=0; // double d1=0,d2=0,d=0; switch(s.charAt(0)){ case '+': d=d1+d2; break; case '-': d=d1-d2; break; case '*': d=d1*d2;  main(String[] args){ new Main().run(); } }"], "original_ll": -0.7493289709091187, "sampled_ll": -0.29866430163383484, "all_perturbed_sampled_ll": [-1.2772361040115356], "all_perturbed_original_ll": [-1.4778051376342773], "perturbed_sampled_ll": -1.2772361040115356, "perturbed_original_ll": -1.4778051376342773, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor l in sys.stdin:\n  t=l.split()\n  l=[]\n  for i in t:\n    try:\n      j=int(i)\n      l.append(j)\n    except:\n      b=l.pop()\n      a=l.pop()\n      l.append(eval(\"a\"+i+\"b\"))\n  print(\"{:.6f}\".format(l[0]))\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    tokens = line.strip().split()\n    stack = []\n    \n    for token in tokens:\n        if token in ['+', '-', '*', '/']:\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+':\n                result = a + b\n            elif token == '-':\n                result = a - b\n            elif token == '*':\n                result = a * b\n            elif token == '/':\n                result = a / b\n            stack.append(result)\n        else:\n            stack.append(float(token))\n    \n    print(f\"{stack[0]:.6f}\")\n", "perturbed_sampled": [" = [] for token in tokens: if token  stack.pop() if token == '+': result = a + b elif token == '-': result = a - b elif  == '/': result = a / b stack.append(result) else: stack.append(float(token)) print(f\"{stack[0]:.6f}\")"], "perturbed_original": ["import sys .i=l[-1].int ) sys try: j=int(i) l.append(j) except: b=l.pop() a=l.pop() l.append(eval(\"a\"+i+\"b\")) print(\"{:.6f}\".format(l[0]))"], "original_ll": -1.53563392162323, "sampled_ll": -0.47061148285865784, "all_perturbed_sampled_ll": [-2.0084753036499023], "all_perturbed_original_ll": [-3.5586745738983154], "perturbed_sampled_ll": -2.0084753036499023, "perturbed_original_ll": -3.5586745738983154, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main()\n{\n  unsigned char *a = \"\\n ',-.?ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  unsigned char *b[] = {\n    \"101\",\"101\",\"000000\",\"000011\",\"10010001\",\"010001\",\"000001\",\"100101\",\n    \"10011010\",\"0101\",\"0001\",\"110\",\"01001\",\"10011011\",\"010000\",\"0111\",\n    \"10011000\",\"0110\",\"00100\",\"10011001\",\"10011110\",\"00101\",\"111\",\n    \"10011111\",\"1000\",\"00110\",\"00111\",\"10011100\",\"10011101\",\"000010\",\n    \"10010010\",\"10010011\",\"10010000\"\n  };\n  unsigned char *c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?\";\n  unsigned char d[4096];\n  unsigned char *p;\n  int i,j,k;\n  i = 0;\n  while((k = getc(stdin)) != '\\n'){\n    j = 0;\n    while(*(a + j) != k) j++;\n    p = b[j];\n    while(*p) d[i++] = *p++;\n  }\n  while(i % 5) d[i++] = '0';\n  d[i] = '\\0';\n  i = 0;\n  while(d[i]) {\n    k = 0;\n    j = 4;\n    do {\n      k |= (d[i++] == '1') << j;\n    } while(j--);\n    putc(*(c + k),stdout);\n  }\n  putc('\\n',stdout);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char *encode1[] = {\n        \"101\", \"000000\", \"000011\", \"10010001\", \"010001\", \"000001\",\n        \"100101\", \"10011010\", \"0101\", \"0001\", \"110\", \"01001\",\n        \"10011011\", \"010000\", \"0111\", \"10011000\", \"0110\", \"00100\",\n        \"10011001\", \"10011110\", \"00101\", \"111\", \"10011111\", \"1000\",\n        \"00110\", \"00111\", \"10011100\", \"10011101\", \"000010\", \"10010010\",\n        \"10010011\", \"10010000\"\n    };\n    \n    char *decode2[] = {\n        \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\",\n        \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\",\n        \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\",\n        \"Y\", \"Z\", \" \", \".\", \",\", \"-\", \"'\", \"?\"\n    };\n    \n    char input[1024];\n    \n    while (fgets(input, sizeof(input), stdin)) {\n        int len = strlen(input);\n        if (len > 0 && input[len-1] == '\\n') {\n            input[len-1] = '\\0';\n            len--;\n        }\n        \n        char binary[10000] = \"\";\n        \n        for (int i = 0; i < len; i++) {\n            char c = input[i];\n            int idx = -1;\n            \n            if (c == ' ') idx = 0;\n            else if (c == '\\'') idx = 1;\n            else if (c == ',') idx = 2;\n            else if (c == '-') idx = 3;\n            else if (c == '.') idx = 4;\n            else if (c == '?') idx = 5;\n            else if (c >= 'A' && c <= 'Z') idx = c - 'A' + 6;\n            \n            if (idx >= 0) {\n                strcat(binary, encode1[idx]);\n            }\n        }\n        \n        int blen = strlen(binary);\n        if (blen % 5 != 0) {\n            int pad = 5 - (blen % 5);\n            for (int i = 0; i < pad; i++) {\n                strcat(binary, \"0\");\n            }\n            blen = strlen(binary);\n        }\n        \n        char result[10000] = \"\";\n        for (int i = 0; i < blen; i += 5) {\n            char chunk[6];\n            strncpy(chunk, binary + i, 5);\n            chunk[5] = '\\0';\n            \n            int val = 0;\n            for (int j = 0; j < 5; j++) {\n                val = val * 2 + (chunk[j] - '0');\n            }\n            \n            strcat(result, decode2[val]);\n        }\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char *encode1[] = { \"101\",  \"01001\", \"10011011\", \"010000\", \"0111\", \"10011000\", \"0110\", \"00100\", \"10011001\", \"10011110\", \"00101\", \"111\", \"10011111\", \"1000\", \"00110\", \"00111\", \"10011100\", \"10011101\",  \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \" \", \".\", \",\", \"-\", \"'\", \"?\" }; char input[1024]; while (fgets(input, sizeof(input), stdin)) { int len = strlen(input); if (len > 0 && input[len-1] == '\\n') { input[len-1] = '\\0'; len--; } char binary[10000] = \"\"; for (int i = 0; i  = -1;  (c == '\\'')  2; else if (c == '-') idx = 3; else if (c == '.') idx = 4; else if (c == '?') idx = 5;  0) { strcat(binary, encode1[idx]);  != 0) { int pad = 5 - (blen % 5); for (int i =  i = 0; i < blen; i += 5) { char  val = 0; for (int j = 0; j < 5; j++) { val = val * 2  } return 0; }"], "perturbed_original": ["#include <stdio.h> int main() { unsigned char *a = \"\\n ',-.?ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; unsigned  unsigned char *c =  = 0; while(*(a + j) != k) j++; p = b[j]; while(*p) d[i++] = *p++; } while(i % 5) d[i++] = '0'; d[i] = '\\0'; i =  {  + k),stdout); } putc('\\n',stdout); return 0; }"], "original_ll": -0.9931159019470215, "sampled_ll": -0.4950203597545624, "all_perturbed_sampled_ll": [-1.2653470039367676], "all_perturbed_original_ll": [-2.955719232559204], "perturbed_sampled_ll": -1.2653470039367676, "perturbed_original_ll": -2.955719232559204, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) throws java.io.IOException{\n        Scanner scan = new Scanner(System.in);\n        HashMap<Character,String> ep =new HashMap<Character,String>();\n        HashMap<String,Character> dp =new HashMap<String,Character>();\n\n\t\tep.put(' ', \"101\");\n\t\tep.put('\\'', \"000000\");\n\t\tep.put(',', \"000011\");\n\t\tep.put('-', \"10010001\");\n\t\tep.put('.', \"010001\");\n\t\tep.put('?', \"000001\");\n\t\tep.put('A', \"100101\");\n\t\tep.put('B', \"10011010\");\n\t\tep.put('C', \"0101\");\n\t\tep.put('D', \"0001\");\n\t\tep.put('E', \"110\");\n\t\tep.put('F', \"01001\");\n\t\tep.put('G', \"10011011\");\n\t\tep.put('H', \"010000\");\n\t\tep.put('I', \"0111\");\n\t\tep.put('J', \"10011000\");\n\t\tep.put('K', \"0110\");\n\t\tep.put('L', \"00100\");\n\t\tep.put('M', \"10011001\");\n\t\tep.put('N', \"10011110\");\n\t\tep.put('O', \"00101\");\n\t\tep.put('P', \"111\");\n\t\tep.put('Q', \"10011111\");\n\t\tep.put('R', \"1000\");\n\t\tep.put('S', \"00110\");\n\t\tep.put('T', \"00111\");\n\t\tep.put('U', \"10011100\");\n\t\tep.put('V', \"10011101\");\n\t\tep.put('W', \"000010\");\n\t\tep.put('X', \"10010010\");\n\t\tep.put('Y', \"10010011\");\n\t\tep.put('Z', \"10010000\");\n        \n\t\tdp.put(\"00000\", 'A');\n\t\tdp.put(\"00001\", 'B');\n\t\tdp.put(\"00010\", 'C');\n\t\tdp.put(\"00011\", 'D');\n\t\tdp.put(\"00100\", 'E');\n\t\tdp.put(\"00101\", 'F');\n\t\tdp.put(\"00110\", 'G');\n\t\tdp.put(\"00111\", 'H');\n\t\tdp.put(\"01000\", 'I');\n\t\tdp.put(\"01001\", 'J');\n\t\tdp.put(\"01010\", 'K');\n\t\tdp.put(\"01011\", 'L');\n\t\tdp.put(\"01100\", 'M');\n\t\tdp.put(\"01101\", 'N');\n\t\tdp.put(\"01110\", 'O');\n\t\tdp.put(\"01111\", 'P');\n\t\tdp.put(\"10000\", 'Q');\n\t\tdp.put(\"10001\", 'R');\n\t\tdp.put(\"10010\", 'S');\n\t\tdp.put(\"10011\", 'T');\n\t\tdp.put(\"10100\", 'U');\n\t\tdp.put(\"10101\", 'V');\n\t\tdp.put(\"10110\", 'W');\n\t\tdp.put(\"10111\", 'X');\n\t\tdp.put(\"11000\", 'Y');\n\t\tdp.put(\"11001\", 'Z');\n\t\tdp.put(\"11010\", ' ');\n\t\tdp.put(\"11011\", '.');\n\t\tdp.put(\"11100\", ',');\n\t\tdp.put(\"11101\", '-');\n\t\tdp.put(\"11110\", '\\'');\n\t\tdp.put(\"11111\", '?');\n        \n        while(scan.hasNext()){\n        \tchar [] line= scan.nextLine().toCharArray();\n        \tString tmp=\"\";\n        \tfor(int i=0;i<line.length;i++)\n        \t\ttmp+=ep.get(line[i]);\n        \tString [] splitedCode =new String[tmp.length()/5+1];\n        \tfor(int i=0;i<splitedCode.length;i++){\t\n        \t\tif(i==(splitedCode.length-1))\n        \t\t\tsplitedCode[i]=tmp.substring(5*i,tmp.length());\n        \t\telse splitedCode[i]=tmp.substring(5*i,5*i+5);\n        \t}\n        \t\tif(tmp.length()%5!=0)\n        \tfor(int i=0;i<(5-tmp.length()%5);i++)\n        \t\tsplitedCode[splitedCode.length-1]+=\"0\";\n        \t\n        \tStringBuilder sb = new StringBuilder();\n        \tfor(int i=0;i<splitedCode.length;i++)\n        \t\tsb.append(dp.get(splitedCode[i]));\n        \tSystem.out.println(sb);\n        }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Map<Character, String> encode1 = new HashMap<>();\n        encode1.put(' ', \"101\");\n        encode1.put('\\'', \"000000\");\n        encode1.put(',', \"000011\");\n        encode1.put('-', \"10010001\");\n        encode1.put('.', \"010001\");\n        encode1.put('?', \"000001\");\n        encode1.put('A', \"100101\");\n        encode1.put('B', \"10011010\");\n        encode1.put('C', \"0101\");\n        encode1.put('D', \"0001\");\n        encode1.put('E', \"110\");\n        encode1.put('F', \"01001\");\n        encode1.put('G', \"10011011\");\n        encode1.put('H', \"010000\");\n        encode1.put('I', \"0111\");\n        encode1.put('J', \"10011000\");\n        encode1.put('K', \"0110\");\n        encode1.put('L', \"00100\");\n        encode1.put('M', \"10011001\");\n        encode1.put('N', \"10011110\");\n        encode1.put('O', \"00101\");\n        encode1.put('P', \"111\");\n        encode1.put('Q', \"10011111\");\n        encode1.put('R', \"1000\");\n        encode1.put('S', \"00110\");\n        encode1.put('T', \"00111\");\n        encode1.put('U', \"10011100\");\n        encode1.put('V', \"10011101\");\n        encode1.put('W', \"000010\");\n        encode1.put('X', \"10010010\");\n        encode1.put('Y', \"10010011\");\n        encode1.put('Z', \"10010000\");\n        \n        Map<String, Character> encode2 = new HashMap<>();\n        encode2.put(\"00000\", 'A');\n        encode2.put(\"00001\", 'B');\n        encode2.put(\"00010\", 'C');\n        encode2.put(\"00011\", 'D');\n        encode2.put(\"00100\", 'E');\n        encode2.put(\"00101\", 'F');\n        encode2.put(\"00110\", 'G');\n        encode2.put(\"00111\", 'H');\n        encode2.put(\"01000\", 'I');\n        encode2.put(\"01001\", 'J');\n        encode2.put(\"01010\", 'K');\n        encode2.put(\"01011\", 'L');\n        encode2.put(\"01100\", 'M');\n        encode2.put(\"01101\", 'N');\n        encode2.put(\"01110\", 'O');\n        encode2.put(\"01111\", 'P');\n        encode2.put(\"10000\", 'Q');\n        encode2.put(\"10001\", 'R');\n        encode2.put(\"10010\", 'S');\n        encode2.put(\"10011\", 'T');\n        encode2.put(\"10100\", 'U');\n        encode2.put(\"10101\", 'V');\n        encode2.put(\"10110\", 'W');\n        encode2.put(\"10111\", 'X');\n        encode2.put(\"11000\", 'Y');\n        encode2.put(\"11001\", 'Z');\n        encode2.put(\"11010\", ' ');\n        encode2.put(\"11011\", '.');\n        encode2.put(\"11100\", ',');\n        encode2.put(\"11101\", '-');\n        encode2.put(\"11110\", '\\'');\n        encode2.put(\"11111\", '?');\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            \n            StringBuilder binary = new StringBuilder();\n            for (char c : line.toCharArray()) {\n                binary.append(encode1.get(c));\n            }\n            \n            while (binary.length() % 5 != 0) {\n                binary.append('0');\n            }\n            \n            StringBuilder result = new StringBuilder();\n            for (int i = 0; i < binary.length(); i += 5) {\n                String chunk = binary.substring(i, i + 5);\n                result.append(encode2.get(chunk));\n            }\n            \n            System.out.println(result.toString());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc  ', \"101\"); encode1.put('\\'', \"000000\"); encode1.put(',', \"000011\"); encode1.put('-', \"10010001\"); encode1.put('.', \"010001\"); encode1.put('?',  \"110\"); encode1.put('F',  encode1.put('P', \"111\"); encode1.put('Q',  \"10011101\"); encode1.put('W', \"000010\"); encode1.put('X', \"10010010\"); encode1.put('Y', \"10010011\"); encode1.put('Z',  'B'); encode2.put(\"00010\", 'C'); encode2.put(\"00011\", 'D'); encode2.put(\"00100\",  'J'); encode2.put(\"01010\", 'K'); encode2.put(\"01011\",  'Q'); encode2.put(\"10001\", 'R'); encode2.put(\"10010\", 'S'); encode2.put(\"10011\", 'T'); encode2.put(\"10100\", 'U'); encode2.put(\"10101\", 'V'); encode2.put(\"10110\", 'W'); encode2.put(\"10111\", 'X'); encode2.put(\"11000\", 'Y'); encode2.put(\"11001\", 'Z'); encode2.put(\"11010\", ' '); encode2.put(\"11011\", '.'); encode2.put(\"11100\", ','); encode2.put(\"11101\", '-'); encode2.put(\"11110\", '\\''); encode2.put(\"11111\", '?'); while (sc.hasNextLine()) { String line = sc.nextLine(); StringBuilder binary = new StringBuilder(); for  5 != 0) { binary.append('0'); } StringBuilder result = new StringBuilder(); for (int i = 0; i < binary.length(); i +=  } System.out.println(result.toString()); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[] args)  HashMap<Character,String>(); HashMap<String,Character> dp  ep.put('C', \"0101\"); ep.put('D', \"0001\"); ep.put('E', \"110\"); ep.put('F', \"01001\"); ep.put('G', \"10011011\"); ep.put('H', \"010000\"); ep.put('I', \"0111\"); ep.put('J', \"10011000\");   \"10010011\"); ep.put('Z', \"10010000\"); dp.put(\"00000\", 'A'); dp.put(\"00001\", 'B'); dp.put(\"00010\", 'C'); dp.put(\"00011\", 'D'); dp.put(\"00100\", 'E'); dp.put(\"00101\", 'F'); dp.put(\"00110\", 'G'); dp.put(\"00111\",  'M'); dp.put(\"01101\", 'N'); dp.put(\"01110\", 'O'); dp.put(\"01111\",  dp.put(\"11001\", 'Z'); dp.put(\"11010\", ' '); dp.put(\"11011\", '.'); dp.put(\"11100\", ','); dp.put(\"11101\", '-'); dp.put(\"11110\", '\\''); dp.put(\"11111\", '?'); while(scan.hasNext()){ char [] line= scan.nextLine().toCharArray(); String tmp=\"\"; for(int i=0;i<line.length;i++) tmp+=ep.get(line[i]); String [] splitedCode =new String[tmp.length()/5+1]; for(int i=0;i<splitedCode.length;i++){ if(i==(splitedCode.length-1)) splitedCode[i]=tmp.substring(5*i,tmp.length()); else splitedCode[i]=tmp.substring(5*i,5*i+5); } if(tmp.length()%5!=0) for(int i=0;i<(5-tmp.length()%5);i++) splitedCode[splitedCode.length-1]+=\"0\"; StringBuilder sb = new StringBuilder(); for(int i=0;i<splitedCode.length;i++) sb.append(dp.get(splitedCode[i])); System.out.println(sb); } } }"], "original_ll": -0.4184757173061371, "sampled_ll": -0.2833854556083679, "all_perturbed_sampled_ll": [-0.88457852602005], "all_perturbed_original_ll": [-0.8343579769134521], "perturbed_sampled_ll": -0.88457852602005, "perturbed_original_ll": -0.8343579769134521, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nd={' ':'101',\"'\":'000000',',':'000011','-':'10010001','.':'010001','?':'000001','A':'100101','B':'10011010','C':'0101','D':'0001','E':'110',\n'F':'01001','G':'10011011','H':'010000','I':'0111','J':'10011000','K':'0110','L':'00100','M':'10011001','N':'10011110','O':'00101','P':'111',\n'Q':'10011111','R':'1000','S':'00110','T':'00111','U':'10011100','V':'10011101','W':'000010','X':'10010010','Y':'10010011','Z':'10010000'}\nfor e in sys.stdin:\n a=''.join(d[c]for c in e[:-1])\n a+='0'*(-len(a)%5)\n print(''.join(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?\"[int(a[i*5:i*5+5],2)]for i in range(len(a)//5)))\n", "sampled": "import sys\n\n# First encoding table (character to binary code)\nencode1 = {\n    ' ': '101',\n    \"'\": '000000',\n    ',': '000011',\n    '-': '10010001',\n    '.': '010001',\n    '?': '000001',\n    'A': '100101',\n    'B': '10011010',\n    'C': '0101',\n    'D': '0001',\n    'E': '110',\n    'F': '01001',\n    'G': '10011011',\n    'H': '010000',\n    'I': '0111',\n    'J': '10011000',\n    'K': '0110',\n    'L': '00100',\n    'M': '10011001',\n    'N': '10011110',\n    'O': '00101',\n    'P': '111',\n    'Q': '10011111',\n    'R': '1000',\n    'S': '00110',\n    'T': '00111',\n    'U': '10011100',\n    'V': '10011101',\n    'W': '000010',\n    'X': '10010010',\n    'Y': '10010011',\n    'Z': '10010000'\n}\n\n# Second encoding table (5-bit binary to character)\nencode2 = {\n    '00000': 'A',\n    '00001': 'B',\n    '00010': 'C',\n    '00011': 'D',\n    '00100': 'E',\n    '00101': 'F',\n    '00110': 'G',\n    '00111': 'H',\n    '01000': 'I',\n    '01001': 'J',\n    '01010': 'K',\n    '01011': 'L',\n    '01100': 'M',\n    '01101': 'N',\n    '01110': 'O',\n    '01111': 'P',\n    '10000': 'Q',\n    '10001': 'R',\n    '10010': 'S',\n    '10011': 'T',\n    '10100': 'U',\n    '10101': 'V',\n    '10110': 'W',\n    '10111': 'X',\n    '11000': 'Y',\n    '11001': 'Z',\n    '11010': ' ',\n    '11011': '.',\n    '11100': ',',\n    '11101': '-',\n    '11110': \"'\",\n    '11111': '?'\n}\n\nfor line in sys.stdin:\n    line = line.rstrip('\\n')\n    \n    # Step 1: Convert each character to its binary code\n    binary_string = ''.join(encode1[c] for c in line)\n    \n    # Step 2: Pad with zeros to make length multiple of 5\n    remainder = len(binary_string) % 5\n    if remainder != 0:\n        binary_string += '0' * (5 - remainder)\n    \n    # Step 3: Split into chunks of 5 and convert using second table\n    result = ''\n    for i in range(0, len(binary_string), 5):\n        chunk = binary_string[i:i+5]\n        result += encode2[chunk]\n    \n    print(result)\n", "perturbed_sampled": ["import sys # First encoding table (character to binary code) encode1 = { ' ': '101', \"'\": '000000', ',': '000011', '-':  '0101', 'D':  'N': '10011110', 'O': '00101',  'U': '10011100', 'V': '10011101', 'W': '000010', 'X': '10010010', 'Y': '10010011', 'Z': '10010000' } # Second encoding table (5-bit binary  '00111': 'H', '01000': 'I', '01001': 'J', '01010': 'K', '01011': 'L', '01100': 'M', '01101': 'N',  '10011': 'T', '10100': 'U', '10101': 'V', '10110': 'W', '10111': 'X', '11000': 'Y', '11001': 'Z', '11010': ' ', '11011': '.', '11100': ',', '11101': '-', '11110': \"'\", '11111': '?' } for line in sys.stdin: line = line.rstrip('\\n') #  = ''.join(encode1[c] for c in  multiple of 5 remainder = len(binary_string)  (5 - remainder) # Step 3: Split  = '' for i in range(0, len(binary_string), 5): chunk = binary_string[i:i+5] result += encode2[chunk] print(result)"], "perturbed_original": ["import  c in e[:-1]) a+='0'*(-len(a)%5) print(''.join(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?\"[int(a[i*5:i*5+5],2)]for i in range(len(a)//5)))"], "original_ll": -1.0132534503936768, "sampled_ll": -0.4180665910243988, "all_perturbed_sampled_ll": [-1.1052581071853638], "all_perturbed_original_ll": [-3.054478168487549], "perturbed_sampled_ll": -1.1052581071853638, "perturbed_original_ll": -3.054478168487549, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????\u00b0???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned long\t\tI4;\ntypedef unsigned long \tU4;\n\n/* ?????\u00b0?????? */\n#define MAXOFNUM_ROW \t99\t\t\t\t\t/* ?????\u00b0????????\u00a7??? */\n#define MAXOFSUM_COLUMN\t(MAXOFNUM_ROW+1)/2\t/* ?????\u00b0????????\u00a7??? */\n\n/* ??\u00b0?????????????????\u00b0 */\nU1 mu1InputNum[MAXOFNUM_ROW][MAXOFSUM_COLUMN];\t/* ??\\??????????????\u00b0??????????\u00b4????????????? */\n\n/* \n??\u00a2??\u00b0??????u1ReadData\n???????????\\???????????????????????????????????\u00b0???????????? \n?????\u00b0???\n?????????\n????????????U1 ??\\?????????????????\u00b0\n*/\nU1 u1ReadData();\n\n/*\n??\u00a2??\u00b0??????u2SearchMax\n???????????\u00a8????????????????????\u00a7?????\u00a7???????????????\n?????\u00b0???\n????\u00ac\u00ac1?????\u00b0????????\u00b0\n????????????U2 ?????\u00a7???\n*/\nU2 u2SearchMax(U1 u1NumOfRow);\n\n/*\n??\u00a2??\u00b0??????\n?????????2????????\u00b0??????????????\u00a7????????\u00b0????????????\n?????\u00b0???\n????\u00ac\u00ac1?????\u00b0?????\u00b0???1\n????\u00ac\u00ac2?????\u00b0?????\u00b0???2\n????????????U2 ??\u00a7??????????????\u00b0???\n*/\nU2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2);\n\nVD main(void)\n{\n\tU1 u1NumOfRow;\t\t\t\t\t\t/* ?????????????????\u00b0 */\n\tU2 u2MaxOfSum;\t\t\t\t\t\t/* ???????????\u00a7??? */\n\t\n\tu1NumOfRow = u1ReadData();\t\t\t\t/* ??????1 ??\\??????????????????????????? */\n\tu2MaxOfSum = u2SearchMax(u1NumOfRow);\t/* ??????2 ?????\u00a7????????\u00a2??? */\n\tprintf(\"%d\\n\",u2MaxOfSum);\t\t\t\t/* ??????3 ?????\u00a7????????\u00a8????????? */\n}\n\nU1 u1ReadData()\n{\n\tU1 u1NumOfRow;\t\t/* ?????????????????\u00b0 */\n\tU1 u1NumOfColumn;\t/* ?????????????????\u00b0 */\n\tU1 u1TmpChar;\t\t/* ','????????????'\\n'???????\u00b4????????????\u00b0 */\n\tI1 i1ReturnScanf;\t/* scanf??\u00a2??\u00b0???????????????????\u00b4????????????\u00b0 */\n\t\n\tU1 u1OnlyNumCnt;\n\t\n\tu1NumOfRow = 0;\n\tu1NumOfColumn = 0;\n\tu1OnlyNumCnt = 0;\n\t\n\twhile(u1OnlyNumCnt != 2){\n\t\tscanf(\"%d%c\",&mu1InputNum[u1NumOfRow][u1NumOfColumn],&u1TmpChar);\n\t\tif(u1TmpChar == ','){\n\t\t\tu1NumOfColumn++;\n\t\t\tu1TmpChar = 0;\n\t\t}\n\t\telse{\n\t\t\tif(u1NumOfColumn == 0){\n\t\t\t\tu1OnlyNumCnt++;\n\t\t\t}\n\t\t\tu1NumOfRow++;\n\t\t\tu1NumOfColumn = 0;\n\t\t}\n\t}\n\treturn u1NumOfRow;\n}\n\n\nU2 u2SearchMax(U1 u1NumOfRow)\n{\n\tU2 mu2work[MAXOFNUM_ROW][MAXOFSUM_COLUMN];\t/* ?\u00a8???????????????????????\u00b4????????????? */\n\tU1 u1RowCnt;\t\t/* ?????\u00b0???????????? */\n\tU1 u1ColumnCnt;\t\t/* ?????\u00b0???????????? */\n\tU1 u1HalfNumOfRow;\t/* ?????\u00b0????????? */\n\tU2 u2Num1;\t\t\t/* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */\n\tU2 u2Num2;\t\t\t/* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */\n\t\n\tu1HalfNumOfRow = u1NumOfRow/2+1;\n\t\n\t/* ??\\?????????????????????mu2work?????????????????? */\n\tfor(u1RowCnt = 0; u1RowCnt < u1NumOfRow; u1RowCnt++){\n\t\tfor(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){\n\t\t\tif(u1RowCnt >= u1HalfNumOfRow){\n\t\t\t\tif(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt];\n\t\t}\n\t}\n\t\n\tfor(u1RowCnt = 1; u1RowCnt < u1NumOfRow; u1RowCnt++){\n\t\tfor(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){\n\t\t\t/* ????????\u00a2?????\u00a8???????\u00b4???\u00b0????\u00a8????????????\u00b4??? */\n\t\t\tif(u1RowCnt < u1HalfNumOfRow){\t\t\t\t\n\t\t\t\tif(u1ColumnCnt == 0){\n\t\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][0];\n\t\t\t\t}\n\t\t\t\telse if(u1ColumnCnt == u1RowCnt){\n\t\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][u1RowCnt-1];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tu2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt-1];\n\t\t\t\t\tu2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt];\n\t\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* ????????\u00a2?????\u00a8???????\u00b4???\u00b0????\u00a8????????????\u00b4??? */\n\t\t\telse{\n\t\t\t\tif(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tu2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt];\n\t\t\t\tu2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt+1];\n\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2);\n\t\t\t}\n\t\t}\n\t}\n\treturn mu2work[u1NumOfRow-1][0];\n}\n\nU2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2)\n{\n\tU2 u2Rtn;\t/* ????????????????\u00b4????????????\u00b0 */\n\t\n\tif(u2Num1 >= u2Num2){\n\t\tu2Rtn = u2Num1;\n\t}else{\n\t\tu2Rtn = u2Num2;\n\t}\t\n\treturn u2Rtn;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    int diamond[200][100];\n    int dp[200][100];\n    int rows = 0;\n    char line[1000];\n    \n    // Read input\n    while (fgets(line, sizeof(line), stdin)) {\n        int len = strlen(line);\n        if (len > 0 && line[len-1] == '\\n') {\n            line[len-1] = '\\0';\n        }\n        \n        int col = 0;\n        char *token = strtok(line, \",\");\n        while (token != NULL) {\n            diamond[rows][col] = atoi(token);\n            col++;\n            token = strtok(NULL, \",\");\n        }\n        rows++;\n    }\n    \n    // Find the middle row (widest part)\n    int maxRow = 0;\n    for (int i = 0; i < rows; i++) {\n        if (i > maxRow) {\n            maxRow = i;\n        }\n    }\n    \n    // Initialize dp\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < 100; j++) {\n            dp[i][j] = -1;\n        }\n    }\n    \n    // Start with first element\n    dp[0][0] = diamond[0][0];\n    \n    // Determine middle row\n    int mid = rows / 2;\n    \n    // Process upper half (expanding)\n    for (int i = 0; i < mid; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (dp[i][j] != -1) {\n                // Move to left-down diagonal\n                if (dp[i+1][j] < dp[i][j] + diamond[i+1][j]) {\n                    dp[i+1][j] = dp[i][j] + diamond[i+1][j];\n                }\n                // Move to right-down diagonal\n                if (dp[i+1][j+1] < dp[i][j] + diamond[i+1][j+1]) {\n                    dp[i+1][j+1] = dp[i][j] + diamond[i+1][j+1];\n                }\n            }\n        }\n    }\n    \n    // Process lower half (contracting)\n    for (int i = mid; i < rows - 1; i++) {\n        int width = rows - i - 1;\n        for (int j = 0; j <= width; j++) {\n            if (dp[i][j] != -1) {\n                // Move to left-down diagonal\n                if (j > 0) {\n                    if (dp[i+1][j-1] < dp[i][j] + diamond[i+1][j-1]) {\n                        dp[i+1][j-1] = dp[i][j] + diamond[i+1][j-1];\n                    }\n                }\n                // Move to right-down diagonal\n                if (j < width) {\n                    if (dp[i+1][j] < dp[i][j] + diamond[i+1][j]) {\n                        dp[i+1][j] = dp[i][j] + diamond[i+1][j];\n                    }\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", dp[rows-1][0]);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  dp[200][100];  (fgets(line, sizeof(line), stdin)) { int len = strlen(line); if (len > 0 && line[len-1] == '\\n') { line[len-1] = '\\0'; }  (token != NULL)  rows++; } // Find the middle row (widest part) int maxRow = 0; for (int i =  { maxRow = i; } } // Initialize dp for (int i = 0; i < rows; i++) {   dp[0][0] = diamond[0][0]; // Determine middle row int mid = rows / 2; // Process upper half (expanding) for (int i = 0; i < mid; i++) { for (int j = 0; j <= i; j++) { if (dp[i][j] != -1) { // Move  right-down diagonal if (dp[i+1][j+1] < dp[i][j]  } } // Process lower half (contracting) for (int i = mid; i < rows - 1; i++) { int width = rows - i - 1; for (int j = 0; j <= width; j++)  dp[i][j]  = dp[i][j] + diamond[i+1][j]; } } } } } printf(\"%d\\n\", dp[rows-1][0]); return 0; }"], "perturbed_original": ["/* ????????????????????????????????????????????? */   unsigned  ?????\u00b0??? ????????? ????????????U1 ??\\?????????????????\u00b0 */ U1 u1ReadData(); /* ??\u00a2??\u00b0??????u2SearchMax ???????????\u00a8????????????????????\u00a7?????\u00a7??????????????? ?????\u00b0??? ????\u00ac\u00ac1?????\u00b0????????\u00b0 ????????????U2 ?????\u00a7??? */ U2 u2SearchMax(U1 u1NumOfRow); /* ??\u00a2??\u00b0?????? ?????????2????????\u00b0??????????????\u00a7????????\u00b0???????????? ?????\u00b0??? ????\u00ac\u00ac1?????\u00b0?????\u00b0???1 ????\u00ac\u00ac2?????\u00b0?????\u00b0???2 ????????????U2 ??\u00a7??????????????\u00b0??? */ U2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2); VD main(void) {  u1NumOfRow = u1ReadData(); /* ??????1 ??\\??????????????????????????? */ u2MaxOfSum = u2SearchMax(u1NumOfRow);  U1  ?????????????????\u00b0  */ U1 u1OnlyNumCnt; u1NumOfRow = 0; u1NumOfColumn = 0; u1OnlyNumCnt = 0; while(u1OnlyNumCnt != 2){ scanf(\"%d%c\",&mu1InputNum[u1NumOfRow][u1NumOfColumn],&u1TmpChar); if(u1TmpChar == ','){ u1NumOfColumn++; u1TmpChar = 0; }  } } return u1NumOfRow; } U2 u2SearchMax(U1 u1NumOfRow) { U2 mu2work[MAXOFNUM_ROW][MAXOFSUM_COLUMN]; /* ?\u00a8???????????????????????\u00b4????????????? */ U1 u1RowCnt; /* ?????\u00b0???????????? */ U1 u1ColumnCnt; /*  u1NumOfRow/2+1; /*  = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){ if(u1RowCnt >= u1HalfNumOfRow){ if(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){ break; } } mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]; } } for(u1RowCnt = 1; u1RowCnt < u1NumOfRow; u1RowCnt++){ for(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){  = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][0]; } else if(u1ColumnCnt == u1RowCnt){ mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][u1RowCnt-1]; } else{ u2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt-1]; u2Num2  else{ if(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){ break; } u2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt]; u2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt+1]; mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2); } } } return mu2work[u1NumOfRow-1][0]; } U2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2)  = u2Num1; }else{ u2Rtn = u2Num2; } return u2Rtn; }"], "original_ll": -0.8803245425224304, "sampled_ll": -0.44342878460884094, "all_perturbed_sampled_ll": [-1.5022996664047241], "all_perturbed_original_ll": [-1.426608681678772], "perturbed_sampled_ll": -1.5022996664047241, "perturbed_original_ll": -1.426608681678772, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] now, next;\n\tint[] dp1, dp2;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] str = sc.next().split(\",\");\n\t\tnow = new int[str.length+4];\n\t\tnow[2] = Integer.parseInt(str[0]);\n\t\tdp1 = new int[51];\n\t\tdp2 = new int[51];\n\t\tdp1[1] = now[2]; \n\t\tfor(;sc.hasNext();) {\n\t//\t\tdebug(dp1);\n\t\t\tstr = sc.next().split(\",\");\n\t\t\tdp2 = dp1.clone();\n\t//\t\tif(str[0].equals(\"0\")) break;\n\t\t\tnext = new int[str.length+4];\n\t\t\tfor(int i=0;i<str.length;i++) next[i+2] = Integer.parseInt(str[i]);\n\t//\t\tdebug(next);\n\t\t\tfor(int i=2;i<=str.length+1;i++) {\n\t\t\t\tif(now.length < next.length) dp1[i-1] = max( dp2[i-2] + next[i], dp2[i-1] + next[i]);\n\t\t\t\telse dp1[i-1] = max( dp2[i-1] + next[i], dp2[i] + next[i]);\n\t\t\t}\n\t\t\tnow = next.clone();\n\t\t}\n\t\tSystem.out.println(dp1[1]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<List<Integer>> diamond = new ArrayList<>();\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            List<Integer> row = new ArrayList<>();\n            if (line.contains(\",\")) {\n                String[] parts = line.split(\",\");\n                for (String part : parts) {\n                    row.add(Integer.parseInt(part));\n                }\n            } else {\n                row.add(Integer.parseInt(line));\n            }\n            diamond.add(row);\n        }\n        \n        int n = diamond.size();\n        int mid = n / 2;\n        \n        List<List<Integer>> dp = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            List<Integer> row = new ArrayList<>();\n            for (int j = 0; j < diamond.get(i).size(); j++) {\n                row.add(Integer.MIN_VALUE);\n            }\n            dp.add(row);\n        }\n        \n        dp.get(0).set(0, diamond.get(0).get(0));\n        \n        for (int i = 0; i < n - 1; i++) {\n            int currSize = diamond.get(i).size();\n            int nextSize = diamond.get(i + 1).size();\n            \n            if (nextSize > currSize) {\n                for (int j = 0; j < currSize; j++) {\n                    if (dp.get(i).get(j) != Integer.MIN_VALUE) {\n                        dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j), \n                            dp.get(i).get(j) + diamond.get(i + 1).get(j)));\n                        dp.get(i + 1).set(j + 1, Math.max(dp.get(i + 1).get(j + 1), \n                            dp.get(i).get(j) + diamond.get(i + 1).get(j + 1)));\n                    }\n                }\n            } else {\n                for (int j = 0; j < currSize; j++) {\n                    if (dp.get(i).get(j) != Integer.MIN_VALUE) {\n                        if (j > 0) {\n                            dp.get(i + 1).set(j - 1, Math.max(dp.get(i + 1).get(j - 1), \n                                dp.get(i).get(j) + diamond.get(i + 1).get(j - 1)));\n                        }\n                        if (j < nextSize) {\n                            dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j), \n                                dp.get(i).get(j) + diamond.get(i + 1).get(j)));\n                        }\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp.get(n - 1).get(0));\n    }\n}\n", "perturbed_sampled": ["import  { Scanner sc = new Scanner(System.in); List<List<Integer>> diamond  if (line.isEmpty()) break; List<Integer> row = new ArrayList<>(); if (line.contains(\",\")) { String[] parts = line.split(\",\"); for (String  = n / 2; List<List<Integer>> dp = new ArrayList<>(); for (int i = 0; i < n; i++)  0; j < diamond.get(i).size(); j++) { row.add(Integer.MIN_VALUE); }  < n - 1; i++) { int currSize = diamond.get(i).size(); int nextSize =  j = 0;  + 1).get(j))); dp.get(i + 1).set(j +  1).get(j + 1))); } } } else { for (int  != Integer.MIN_VALUE) { if (j > 0) { dp.get(i  + diamond.get(i + 1).get(j - 1))); } if (j < nextSize) { dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j), dp.get(i).get(j) + diamond.get(i + 1).get(j))); } } } } } System.out.println(dp.get(n - 1).get(0)); } }"], "perturbed_original": ["import java.util.*; import static java.lang.Math.*; import static java.util.Arrays.*; public class Main { int  String[] str = sc.next().split(\",\"); now = new int[str.length+4]; now[2] = Integer.parseInt(str[0]);  now[2]; for(;sc.hasNext();) { // debug(dp1); str = sc.next().split(\",\"); dp2 = dp1.clone(); // if(str[0].equals(\"0\")) break; next = new int[str.length+4]; for(int  < next.length) dp1[i-1] = max( dp2[i-2] + next[i], dp2[i-1] + next[i]); else dp1[i-1] = max( dp2[i-1]  Main().run(); } void debug(Object... os) { System.err.println(Arrays.deepToString(os)); } }"], "original_ll": -0.9576488733291626, "sampled_ll": -0.3150087594985962, "all_perturbed_sampled_ll": [-1.5732861757278442], "all_perturbed_original_ll": [-1.982717752456665], "perturbed_sampled_ll": -1.5732861757278442, "perturbed_original_ll": -1.982717752456665, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def path(mx,w,h):\n\tif h < c/2:\n\t\tif w > 0:\n\t\t\tmx[h][w] = max(mx[h-1][w],mx[h-1][w-1]) + inp[h][w]\n\t\telse:\n\t\t\tmx[h][w] = mx[h-1][w] + inp[h][w]\n\telse:\n\t\tif w < len(inp[h])-1:\n\t\t\tmx[h][w] = max(mx[h-1][w],mx[h-1][w+1]) + inp[h][w]\n\t\telse:\n\t\t\tmx[h][w] = mx[h-1][w] + inp[h][w]\n\treturn mx\n\t\nc = 0\ninp = []\nwhile True:\n\ttry:\n\t\tinp.append(map(int, raw_input().split(\",\")))\n\t\tc += 1\n\texcept:\n\t\tmx = [[0 for i in range((c+1)/2)] for i in range(c)]\n\t\tmx[0][0] = inp[0][0]\n\t\tfor h in range(1,c):\n\t\t\tfor w in range(len(inp[h])):\n\t\t\t\tmx = path(mx,w,h)\n\t\tprint mx[c-1][0]\n\t\tbreak", "sampled": "import sys\n\nlines = []\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        lines.append(line)\n\n# Parse the diamond\ndiamond = []\nfor line in lines:\n    if ',' in line:\n        diamond.append(list(map(int, line.split(','))))\n    else:\n        diamond.append([int(line)])\n\nn = len(diamond)\nmid = n // 2\n\n# Dynamic programming\ndp = [[float('-inf')] * len(row) for row in diamond]\ndp[0][0] = diamond[0][0]\n\n# Process upper half (expanding)\nfor i in range(1, mid + 1):\n    for j in range(len(diamond[i])):\n        # Can come from position j-1 or j in previous row\n        if j > 0:\n            dp[i][j] = max(dp[i][j], dp[i-1][j-1] + diamond[i][j])\n        if j < len(diamond[i-1]):\n            dp[i][j] = max(dp[i][j], dp[i-1][j] + diamond[i][j])\n\n# Process lower half (contracting)\nfor i in range(mid + 1, n):\n    for j in range(len(diamond[i])):\n        # Can come from position j or j+1 in previous row\n        if j < len(diamond[i-1]):\n            dp[i][j] = max(dp[i][j], dp[i-1][j] + diamond[i][j])\n        if j + 1 < len(diamond[i-1]):\n            dp[i][j] = max(dp[i][j], dp[i-1][j+1] + diamond[i][j])\n\nprint(dp[n-1][0])\n", "perturbed_sampled": ["import sys lines = [] for line in sys.stdin: line = line.strip() if line: lines.append(line)  lines: if  mid = n // 2 # Dynamic programming dp =  mid + 1): for j in range(len(diamond[i])): # Can come from position  dp[i][j]  = max(dp[i][j], dp[i-1][j] + diamond[i][j]) #  n): for j in range(len(diamond[i])): # Can come from position j or j+1 in previous row if j < len(diamond[i-1]): dp[i][j] = max(dp[i][j], dp[i-1][j] + diamond[i][j]) if j + 1 < len(diamond[i-1]): dp[i][j] = max(dp[i][j], dp[i-1][j+1] + diamond[i][j]) print(dp[n-1][0])"], "perturbed_original": ["def path(mx,w,h): if h < c/2: if w > 0: mx[h][w] = max(mx[h-1][w],mx[h-1][w-1]) + inp[h][w] else: mx[h][w] =   mx c = 0 inp =  in range(c)] mx[0][0] = inp[0][0] for h in range(1,c): for w in range(len(inp[h])): mx = path(mx,w,h) print mx[c-1][0] break"], "original_ll": -0.7648698687553406, "sampled_ll": -0.5933178663253784, "all_perturbed_sampled_ll": [-1.5347479581832886], "all_perturbed_original_ll": [-1.9998441934585571], "perturbed_sampled_ll": -1.5347479581832886, "perturbed_original_ll": -1.9998441934585571, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// AOJ0090 Overlaps of Seals\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_N\t(200)\n\n\nint main(void)\n{\n    int n;\n\tdouble circle[MAX_N][2];\n    double d;\n    int flag[MAX_N][MAX_N];\n    int overlap[MAX_N][MAX_N];\n    int max_overlap;\n\tint i, j, k;\n\tint num[MAX_N], max[MAX_N], min[MAX_N];\n    int cont_flag;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// \u0093\u00fc\u0097\u00cd\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%lf,%lf\", &circle[i][0], &circle[i][1]);\n\t\t}\n\t\t\n\t\t// \u008fd\u0082\u00c8\u0082\u00e8\u0083e\u0081[\u0083u\u0083\u008b\u008d\u00ec\u0090\u00ac\n\t\tmemset(flag, 0, sizeof(flag));\n\t\tfor (i = 0; i < n; i++){\n\t\t\tfor (j = i; j < n; j++){\n\t\t\t\tif (i == j){\n\t\t\t\t\tflag[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td = (circle[i][0] - circle[j][0]) * (circle[i][0] - circle[j][0]) +\n\t\t\t\t\t    (circle[i][1] - circle[j][1]) * (circle[i][1] - circle[j][1]);\n\t\t\t\t\tif (d <= 4.0){\n\t\t\t\t\t\tflag[i][j] = flag[j][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n                    // \u0092[\u0082\u00c1\u0082\u00b1\u0082\u00cc\u008d\u00ed\u008f\u009c\n        max_overlap = 1;\n        do {\n\t\t\tfor (i = 0; i < n; i++){\n                num[i] = 0;\n\t\t\t\tfor (j = 0; j < n; j++){\n\t\t\t\t\tnum[i] += flag[i][j];\n\t\t\t\t}\n   \t\t\t}\n\n            cont_flag = 0;\n\t\t\tfor (i = 0; i < n; i++){\n                if (num[i] == 2){\n                    max_overlap = 2;\n                }\n\t\t\t\tif (num[i] == 1 || num[i] == 2){\n\t\t\t\t\tfor (j = 0; j < n; j++){\n\t\t\t\t\t\tflag[i][j] = flag[j][i] = 0; \n\t\t\t\t\t}\n                    cont_flag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (cont_flag == 1);\n\n        \n\t\tmemset(overlap, 0, sizeof(overlap));\n        for (i = 0; i < n; i++){\n            if (num[i] > 0){\n                for (j = 0; j < n; j++){\n                    if (flag[i][j] == 1){\n                        for (k = j + 1; k < n; k++){\n                            if (flag[i][k] == 1){\n                                if (flag[j][k] == 1){\n                                    overlap[i][j]++;\n                                    overlap[i][k]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (i = 0; i < n; i++){\n            max[i] = 0;\n            min[i] = 1000;\n        }\n        for (i = 0; i < n; i++){\n            for (j = 0; j < n; j++){\n                if (max[i] < overlap[i][j]){\n                    max[i] = overlap[i][j];\n                }\n                if (overlap[i][j] > 0 && min[i] > overlap[i][j]){\n                    min[i] = overlap[i][j];\n                }\n            }\n//            printf(\"<%d %d-%d>\", i, min[i], max[i]);\n        }\n\n        for (i = 0; i < n; i++){\n            for (j = 0; j < n; j++){\n//                printf(\"[%d]\",overlap[i][j]);\n                if (overlap[i][j] < overlap[i][i] || max[i] == min[i]){\n                    if (max_overlap < overlap[i][j]){\n                        max_overlap = overlap[i][j];\n                    }\n                }\n            }\n//            printf(\"\\n\");\n        }\n        \n        printf(\"%d\\n\", max_overlap + 1);\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\n#define MAX_N 100\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint main() {\n    int n;\n    Point stickers[MAX_N];\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf,%lf\", &stickers[i].x, &stickers[i].y);\n        }\n        \n        int maxOverlap = 1;\n        \n        // Check all pairs of stickers\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double dx = stickers[i].x - stickers[j].x;\n                double dy = stickers[i].y - stickers[j].y;\n                double dist = sqrt(dx * dx + dy * dy);\n                \n                // If circles overlap or touch\n                if (dist <= 2.0 + EPS) {\n                    // Find intersection points\n                    if (dist < EPS) continue; // Same center (shouldn't happen)\n                    \n                    // Calculate intersection points\n                    double a = dist / 2.0;\n                    double h = sqrt(1.0 - a * a);\n                    \n                    double mx = (stickers[i].x + stickers[j].x) / 2.0;\n                    double my = (stickers[i].y + stickers[j].y) / 2.0;\n                    \n                    double px1 = mx + h * (stickers[j].y - stickers[i].y) / dist;\n                    double py1 = my - h * (stickers[j].x - stickers[i].x) / dist;\n                    \n                    double px2 = mx - h * (stickers[j].y - stickers[i].y) / dist;\n                    double py2 = my + h * (stickers[j].x - stickers[i].x) / dist;\n                    \n                    // Check point 1\n                    int count1 = 0;\n                    for (int k = 0; k < n; k++) {\n                        double d = sqrt((px1 - stickers[k].x) * (px1 - stickers[k].x) + \n                                      (py1 - stickers[k].y) * (py1 - stickers[k].y));\n                        if (d <= 1.0 + EPS) count1++;\n                    }\n                    if (count1 > maxOverlap) maxOverlap = count1;\n                    \n                    // Check point 2\n                    int count2 = 0;\n                    for (int k = 0; k < n; k++) {\n                        double d = sqrt((px2 - stickers[k].x) * (px2 - stickers[k].x) + \n                                      (py2 - stickers[k].y) * (py2 - stickers[k].y));\n                        if (d <= 1.0 + EPS) count2++;\n                    }\n                    if (count2 > maxOverlap) maxOverlap = count2;\n                }\n            }\n            \n            // Check center of each sticker\n            int count = 0;\n            for (int k = 0; k < n; k++) {\n                double d = sqrt((stickers[i].x - stickers[k].x) * (stickers[i].x - stickers[k].x) + \n                              (stickers[i].y - stickers[k].y) * (stickers[i].y - stickers[k].y));\n                if (d <= 1.0 + EPS) count++;\n            }\n            if (count > maxOverlap) maxOverlap = count;\n        }\n        \n        printf(\"%d\\n\", maxOverlap);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #define MAX_N 100 #define EPS 1e-9 typedef struct { double x, y; } Point; int main() { int n;  0) {  scanf(\"%lf,%lf\", &stickers[i].x, &stickers[i].y); } int maxOverlap = 1; // Check  = stickers[i].x  = sqrt(dx * dx  if (dist <= 2.0 + EPS) { // Find intersection points if (dist < EPS) continue; // Same center (shouldn't happen)  double h = sqrt(1.0 - a * a); double mx = (stickers[i].x + stickers[j].x) / 2.0; double my  py1 = my - h * (stickers[j].x - stickers[i].x) /  stickers[i].y) / dist; double py2 = my + h * (stickers[j].x - stickers[i].x)   double d = sqrt((px1 - stickers[k].x) * (px1 -  (d <= 1.0 + EPS) count1++; } if (count1 > maxOverlap) maxOverlap = count1; // Check point 2 int count2 = 0; for (int k = 0; k < n; k++) { double d = sqrt((px2 - stickers[k].x) * (px2 - stickers[k].x) +  each sticker int count = 0; for (int k = 0; k < n; k++) { double d = sqrt((stickers[i].x - stickers[k].x) * (stickers[i].x - stickers[k].x) + (stickers[i].y  + EPS) count++; } if (count > maxOverlap) maxOverlap = count; } printf(\"%d\\n\", maxOverlap); } return 0; }"], "perturbed_original": [" MAX_N (200) int main(void) {  int max_overlap;  while (1){ scanf(\"%d\", &n); if (n == 0){  n; i++){   i; j <  else { d = (circle[i][0] - circle[j][0]) * (circle[i][0] - circle[j][0]) + (circle[i][1] - circle[j][1]) * (circle[i][1] - circle[j][1]); if (d <= 4.0){ flag[i][j] = flag[j][i] = 1;  { for (i = 0; i < n; i++){ num[i] = 0; for  } } cont_flag = 0; for (i = 0; i < n; i++){ if (num[i] == 2){ max_overlap = 2; } if (num[i] == 1 || num[i] == 2){ for (j = 0; j < n; j++){ flag[i][j] = flag[j][i] = 0; } cont_flag = 1;  for (i  for (j  for (k  } } } } } } for (i = 0; i < n; i++){ max[i] = 0; min[i] = 1000; } for (i = 0; i < n; i++){ for (j = 0; j < n; j++){ if (max[i] < overlap[i][j]){ max[i] = overlap[i][j]; } if (overlap[i][j] > 0 && min[i] > overlap[i][j]){ min[i]  }  = 0; j < n; j++){ // printf(\"[%d]\",overlap[i][j]); if (overlap[i][j] < overlap[i][i]   1); } return (0); }"], "original_ll": -0.8038548231124878, "sampled_ll": -0.36275777220726013, "all_perturbed_sampled_ll": [-1.4302846193313599], "all_perturbed_original_ll": [-1.3656620979309082], "perturbed_sampled_ll": -1.4302846193313599, "perturbed_original_ll": -1.3656620979309082, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scanner = new Scanner(System.in);\n\t\t\n\t\tfor(; ;)\n\t\t{\n\t\t\tint n = scanner.nextInt();\n\t\t\tif(n == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint max_len = 0;\n\t\t\tfloat[] x = new float[n];\n\t\t\tfloat[] y = new float[n];\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tString[] input = scanner.next().split(\",\");\n\t\t\t\t\n\t\t\t\tx[i] = Float.parseFloat(input[0]);\n\t\t\t\ty[i] = Float.parseFloat(input[1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(float px=0; px<=10; px+=0.001)\n\t\t\t{\n\t\t\t\tfor(float py=0; py<=10; py+=0.001)\n\t\t\t\t{\n\t\t\t\t\tint len = 0;\n\t\t\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif((px-x[i])*(px-x[i])+(py-y[i])*(py-y[i]) <= 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(max_len < len)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax_len = len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max_len);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n        double dist(Point p) {\n            return Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            Point[] stickers = new Point[n];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\",\");\n                double x = Double.parseDouble(parts[0]);\n                double y = Double.parseDouble(parts[1]);\n                stickers[i] = new Point(x, y);\n            }\n            \n            int maxOverlap = 1;\n            \n            // Check all pairs of stickers and find intersection points\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    double d = stickers[i].dist(stickers[j]);\n                    if (d <= 2.0) {\n                        // Find intersection points\n                        List<Point> testPoints = getIntersectionPoints(stickers[i], stickers[j]);\n                        for (Point p : testPoints) {\n                            int count = 0;\n                            for (int k = 0; k < n; k++) {\n                                if (stickers[k].dist(p) <= 1.0 + 1e-9) {\n                                    count++;\n                                }\n                            }\n                            maxOverlap = Math.max(maxOverlap, count);\n                        }\n                    }\n                }\n                // Also check the center of each sticker\n                int count = 0;\n                for (int k = 0; k < n; k++) {\n                    if (stickers[k].dist(stickers[i]) <= 1.0 + 1e-9) {\n                        count++;\n                    }\n                }\n                maxOverlap = Math.max(maxOverlap, count);\n            }\n            \n            System.out.println(maxOverlap);\n        }\n    }\n    \n    static List<Point> getIntersectionPoints(Point c1, Point c2) {\n        List<Point> points = new ArrayList<>();\n        double d = c1.dist(c2);\n        \n        if (d > 2.0 + 1e-9) return points;\n        \n        double r = 1.0;\n        double a = (r * r - r * r + d * d) / (2 * d);\n        double h = Math.sqrt(Math.max(0, r * r - a * a));\n        \n        double cx = c1.x + a * (c2.x - c1.x) / d;\n        double cy = c1.y + a * (c2.y - c1.y) / d;\n        \n        double px1 = cx + h * (c2.y - c1.y) / d;\n        double py1 = cy - h * (c2.x - c1.x) / d;\n        \n        double px2 = cx - h * (c2.y - c1.y) / d;\n        double py2 = cy + h * (c2.x - c1.x) / d;\n        \n        points.add(new Point(px1, py1));\n        if (h > 1e-9) {\n            points.add(new Point(px2, py2));\n        }\n        \n        return points;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class Point { double x, y; Point(double  (y - p.y)); } } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine())  0) break; Point[] stickers = new Point[n]; for (int i = 0; i < n; i++) { String[]  Double.parseDouble(parts[1]); stickers[i] = new Point(x, y); } int maxOverlap = 1; // Check all pairs of stickers and find intersection points for (int i =  i + 1; j < n; j++)  // Find intersection points List<Point> testPoints = getIntersectionPoints(stickers[i], stickers[j]); for (Point  maxOverlap = Math.max(maxOverlap, count); } } } // Also check the center of each sticker int count = 0; for (int k = 0; k  { count++; } } maxOverlap = Math.max(maxOverlap, count); } System.out.println(maxOverlap); } } static List<Point> getIntersectionPoints(Point c1, Point c2) { List<Point> points = new ArrayList<>(); double d = c1.dist(c2); if (d > 2.0 + 1e-9) return points; double r = 1.0; double a  Math.sqrt(Math.max(0, r *  = c1.y  = cx + h * (c2.y - c1.y) / d; double py1 = cy - h * (c2.x - c1.x) / d; double px2  1e-9) { points.add(new Point(px2, py2)); } return points; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); for(; ;) { int n =  0; float[]  i=0; i<n; i++) { String[] input = scanner.next().split(\",\"); x[i] = Float.parseFloat(input[0]); y[i] = Float.parseFloat(input[1]); } for(float px=0; px<=10; px+=0.001)   len; } } } System.out.println(max_len); } } }"], "original_ll": -0.529978334903717, "sampled_ll": -0.41768375039100647, "all_perturbed_sampled_ll": [-1.5529404878616333], "all_perturbed_original_ll": [-2.0178511142730713], "perturbed_sampled_ll": -1.5529404878616333, "perturbed_original_ll": -2.0178511142730713, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\ndef overlap(p1, p2, d):\n    return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 <= d\n\ndef intersection(o1,o2):\n    a  = 2*(o2[0] - o1[0])\n    b  = 2*(o2[1] - o1[1])\n    c  = (o1[0] - o2[0])*(o1[0] + o2[0]) + (o1[1] - o2[1])*(o1[1] + o2[1])\n    a2 = a**2 + b**2\n    b2 = a*c + a*b*o1[1] - b**2*o1[0]\n    c2 = b**2*(o1[0]**2 + o1[1]**2 - 1) + c**2 + 2*b*c*o1[1]\n    x1 = (-b2 + math.sqrt(b2**2 - a2*c2))/a2\n    x2 = (-b2 - math.sqrt(b2**2 - a2*c2))/a2\n    if abs(b) < 10e-6:\n        y1 = (o1[1] + o2[1])/2\n        y2 = (o1[1] + o2[1])/2\n    else:\n        y1 = -(a*x1 + c)/b\n        y2 = -(a*x2 + c)/b\n    if abs(b2**2 - a2*c2) < 10e-6:\n        return [x1, y1], [None, None]\n    else:\n        return [x1, y1], [x2, y2]\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(list(map(float, input().split(\",\"))))\n    ans = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if not overlap(p[i], p[j], 4):\n                continue\n            elif overlap(p[i], p[j], 10e-6):\n                continue\n            p1, p2 = intersection(p[i], p[j])\n            cnt1 = 0\n            cnt2 = 0\n            for k in range(n):\n                if overlap(p1, p[k], 1):\n                    cnt1 += 1\n                if p2[0] != None and overlap(p2, p[k], 1):\n                    cnt2 += 1\n            ans = max([ans, cnt1, cnt2])\n    print(ans)\n\n", "sampled": "import sys\nfrom math import sqrt\n\ndef distance(p1, p2):\n    return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef circles_overlap(c1, c2):\n    return distance(c1, c2) <= 2.0\n\ndef max_overlap(circles):\n    if not circles:\n        return 0\n    \n    n = len(circles)\n    if n == 1:\n        return 1\n    \n    max_count = 1\n    \n    # Check overlaps at each circle center\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if circles_overlap(circles[i], circles[j]):\n                count += 1\n        max_count = max(max_count, count)\n    \n    # Check intersection points of pairs of circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            if circles_overlap(circles[i], circles[j]):\n                # Find intersection points\n                x1, y1 = circles[i]\n                x2, y2 = circles[j]\n                \n                d = distance(circles[i], circles[j])\n                \n                if d == 0:\n                    continue\n                \n                if d <= 2.0:\n                    # Calculate intersection points\n                    a = d / 2.0\n                    h = sqrt(1.0 - a * a) if a <= 1.0 else 0\n                    \n                    mx = (x1 + x2) / 2.0\n                    my = (y1 + y2) / 2.0\n                    \n                    dx = (x2 - x1) / d\n                    dy = (y2 - y1) / d\n                    \n                    # Two intersection points\n                    points = []\n                    if h > 0:\n                        points.append((mx + h * dy, my - h * dx))\n                        points.append((mx - h * dy, my + h * dx))\n                    else:\n                        points.append((mx, my))\n                    \n                    for point in points:\n                        count = 0\n                        for k in range(n):\n                            if distance(point, circles[k]) <= 1.0 + 1e-9:\n                                count += 1\n                        max_count = max(max_count, count)\n    \n    return max_count\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    circles = []\n    for _ in range(n):\n        line = input().strip()\n        x, y = map(float, line.split(','))\n        circles.append((x, y))\n    \n    print(max_overlap(circles))\n", "perturbed_sampled": ["import sys from math import sqrt def distance(p1, p2): return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def circles_overlap(c1, c2): return distance(c1, c2)  = len(circles) if n == 1: return 1 max_count = 1 # Check  = 0 for j in range(n): if   range(n): for j in range(i + 1, n): if circles_overlap(circles[i],   0: continue if d <= 2.0:  = sqrt(1.0 - a * a) if a <= 1.0 else 0 mx = (x1 + x2) / 2.0 my = (y1 +  dy =  = [] if h >  dx)) points.append((mx - h * dy, my + h * dx)) else: points.append((mx, my)) for point in points: count = 0 for k in range(n): if distance(point, circles[k])  count) return max_count while True: n  for _ in range(n): line = input().strip() x, y = map(float, line.split(',')) circles.append((x, y)) print(max_overlap(circles))"], "perturbed_original": ["import math def overlap(p1, p2, d): return (p1[0] - p2[0])**2 +  - o1[0]) b =   b**2 b2 = a*c + a*b*o1[1] - b**2*o1[0] c2 = b**2*(o1[0]**2 + o1[1]**2 - 1) + c**2 + 2*b*c*o1[1] x1 = (-b2 + math.sqrt(b2**2 - a2*c2))/a2 x2 =  else: y1 = -(a*x1 + c)/b y2  return [x1, y1], [None, None] else: return [x1, y1], [x2, y2] while True: n = int(input()) if n == 0: break p = [] for i in range(n): p.append(list(map(float, input().split(\",\")))) ans = 0 for i in range(n -  overlap(p[i], p[j],  k in range(n): if overlap(p1, p[k], 1):  1): cnt2 += 1 ans = max([ans, cnt1, cnt2]) print(ans)"], "original_ll": -0.680182933807373, "sampled_ll": -0.597815990447998, "all_perturbed_sampled_ll": [-1.8042192459106445], "all_perturbed_original_ll": [-1.7182520627975464], "perturbed_sampled_ll": -1.8042192459106445, "perturbed_original_ll": -1.7182520627975464, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "z[4000],*a=z,*b=z+2000,m,i,j,t,u;main(n){for(;scanf(\"%d\",&n)*n++;m=!printf(\"%d\\n\",m))for(i=n;i--;j=a,a=b,b=j)for(j=n;j--;t>m?m=t:0)t=b[j]=n+~i&&getchar()>45?1+fmin(u=a[j],fmin(t,u)):0;}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    char grid[1001][1001];\n    int dp[1001][1001];\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        // Read the grid\n        for(int i = 0; i < n; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        // Initialize dp array\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                dp[i][j] = 0;\n            }\n        }\n        \n        // Build dp array\n        int maxSize = 0;\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == '.') {\n                    if(i == 0 || j == 0) {\n                        dp[i][j] = 1;\n                    } else {\n                        int min = dp[i-1][j];\n                        if(dp[i][j-1] < min) min = dp[i][j-1];\n                        if(dp[i-1][j-1] < min) min = dp[i-1][j-1];\n                        dp[i][j] = min + 1;\n                    }\n                    if(dp[i][j] > maxSize) {\n                        maxSize = dp[i][j];\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", maxSize);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int  == 1 && n != 0) { // Read the grid for(int i = 0; i < n; i++) { scanf(\"%s\", grid[i]);  <  j++) { dp[i][j] = 0; } } // Build dp array int maxSize = 0; for(int i = 0;  == 0 || j == 0) { dp[i][j] = 1; } else { int min = dp[i-1][j]; if(dp[i][j-1]  dp[i-1][j-1]; dp[i][j] = min + 1;  } } printf(\"%d\\n\", maxSize); } return 0; }"], "perturbed_original": ["z[4000],*a=z,*b=z+2000,m,i,j,t,u;main(n){for(;scanf(\"%d\",&n)*n++;m=!printf(\"%d\\n\",m))for(i=n;i--;j=a,a=b,b=j)for(j=n;j--;t>m?m=t:0)t=b[j]=n+~i&&getchar()>45?1+fmin(u=a[j],fmin(t,u)):0;}"], "original_ll": -2.9673879146575928, "sampled_ll": -0.34700897336006165, "all_perturbed_sampled_ll": [-1.5242809057235718], "all_perturbed_original_ll": [-2.9673879146575928], "perturbed_sampled_ll": -1.5242809057235718, "perturbed_original_ll": -2.9673879146575928, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\nclass Main {\n\tprivate static String check = \".\";\n\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\n\t\ttry {\n\t\t\twhile (!(buf = br.readLine()).equals(\"0\")) {\n\t\t\t\tint n = Integer.parseInt(buf);\n\t\t\t\tint mat[][] = new int[n][n];\n\t\t\t\tString str[] = new String[n];\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tstr[i] = br.readLine();\n\t\t\t\t\tfor (int j=0;j<n;j++) {\n\t\t\t\t\t\tif (str[i].charAt(j)=='.') mat[i][j] = 0;\n\t\t\t\t\t\telse if (str[i].charAt(j)=='*') mat[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max = 0;\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tif (str[i].indexOf(check)>=0) {\n\t\t\t\t\t\tfor (int j=0;j<n;j++) {\n\t\t\t\t\t\t\tint d = Square(mat,i,j,n);\n\t\t\t\t\t\t\tif (max<d) {\n\t\t\t\t\t\t\t\tmax = d;\n\t\t\t\t\t\t\t\tcheck = \".\";\n\t\t\t\t\t\t\t\tfor (int k=0;k<max;k++) check = check+\".\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static int Square(int[][] m,int x,int y,int n) {\n\t\tint c = 0;\n\t\tboolean end = false;\n\t\twhile (x+c<n&&y+c<n) {\n\t\t\tfor (int i=y;i<=y+c;i++) {\n\t\t\t\tif (m[i][x+c]==1) {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i=x+c;i>=x;i--) {\n\t\t\t\tif (m[y+c][i]==1) {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc++;\n\t\t}\n\t\treturn c;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            sc.nextLine();\n            \n            char[][] grid = new char[n][n];\n            for (int i = 0; i < n; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            \n            int[][] dp = new int[n][n];\n            int maxSize = 0;\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (grid[i][j] == '.') {\n                        if (i == 0 || j == 0) {\n                            dp[i][j] = 1;\n                        } else {\n                            dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;\n                        }\n                        maxSize = Math.max(maxSize, dp[i][j]);\n                    } else {\n                        dp[i][j] = 0;\n                    }\n                }\n            }\n            \n            System.out.println(maxSize);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; sc.nextLine(); char[][] grid =  i++) { String line = sc.nextLine(); for (int j = 0; j < n;  =  0; j <  == 0 ||  dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1; } maxSize = Math.max(maxSize, dp[i][j]); } else { dp[i][j] = 0; } } } System.out.println(maxSize); } sc.close(); } }"], "perturbed_original": [" \".\"; public static void main(String args[]) {  int  (int i=0;i<n;i++) { str[i] = br.readLine(); for  (str[i].charAt(j)=='*') mat[i][j] = 1; } } int max = 0; for (int i=0;i<n;i++) { if (str[i].indexOf(check)>=0) { for (int j=0;j<n;j++) { int d = Square(mat,i,j,n); if (max<d) { max = d; check = \".\"; for  } } catch (Exception e) { e.printStackTrace(); } } public static int Square(int[][] m,int x,int y,int n) { int c = 0; boolean end = false; while (x+c<n&&y+c<n) { for (int i=y;i<=y+c;i++) { if  return c; } }"], "original_ll": -0.6793728470802307, "sampled_ll": -0.26850929856300354, "all_perturbed_sampled_ll": [-1.286363959312439], "all_perturbed_original_ll": [-1.7461403608322144], "perturbed_sampled_ll": -1.286363959312439, "perturbed_original_ll": -1.7461403608322144, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while(1):\n    n = int(input())\n    if n == 0:\n        break\n    a = [0 for i in range(n)]\n    b = [[0 for i in range(n)] for j in range(n)]\n    c_ = [[2000 for i in range(n)] for j in range(n)]\n    c = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        a[i] = [0 if i == \".\" else 1 for i in list(input())]\n        count = 0\n        for j in range(n)[::-1]:\n            if a[i][j] == 0:\n                count += 1\n                b[i][j] = count\n            else:\n                count = 0\n                b[i][j] = count\n                \n    for col in range(n):\n        for i in range(n):\n            for j in range(i,n):\n                if b[j][col] < c_[i][col]:\n                    c_[i][col] = b[j][col]\n                l = j-i+1\n                if c_[i][col] < l:\n                    break\n                c[i][col] = l\n    \n    print(max([max(i) for i in c]))\n\n", "sampled": "import sys\n\ndef max_square(n, grid):\n    if n == 0:\n        return 0\n    \n    # Create DP table\n    dp = [[0] * n for _ in range(n)]\n    max_side = 0\n    \n    # Initialize first row and column\n    for i in range(n):\n        if grid[i][0] == '.':\n            dp[i][0] = 1\n            max_side = 1\n    \n    for j in range(n):\n        if grid[0][j] == '.':\n            dp[0][j] = 1\n            max_side = 1\n    \n    # Fill DP table\n    for i in range(1, n):\n        for j in range(1, n):\n            if grid[i][j] == '.':\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n    \n    return max_side\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    grid = []\n    for _ in range(n):\n        grid.append(input().strip())\n    \n    result = max_square(n, grid)\n    print(result)\n", "perturbed_sampled": ["import  # Create DP table dp = [[0] * n for _ in range(n)] max_side = 0 # Initialize first row and column for i in range(n): if grid[i][0] == '.': dp[i][0] = 1 max_side = 1 for j in range(n): if grid[0][j] == '.': dp[0][j] = 1 max_side = 1 # Fill DP table  + 1 max_side = max(max_side,   grid.append(input().strip()) result = max_square(n, grid) print(result)"], "perturbed_original": ["while(1): n = int(input())  for j in range(n)] c_ = [[2000 for i in range(n)] for j in range(n)] c = [[0 for i in range(n)] for j in range(n)] for i in range(n): a[i] = [0 if  = 0 for j in range(n)[::-1]: if a[i][j] == 0:  b[i][j] = count for col in  b[j][col] <  l: break c[i][col] = l print(max([max(i) for i in c]))"], "original_ll": -0.7963653206825256, "sampled_ll": -0.41151222586631775, "all_perturbed_sampled_ll": [-1.811219334602356], "all_perturbed_original_ll": [-2.051992893218994], "perturbed_sampled_ll": -1.811219334602356, "perturbed_original_ll": -2.051992893218994, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n\tint before,after;\n\tint i;\n\tint flag = 0;\n\twhile(scanf(\"%d %d\",&before,&after)){\n\t\tif(before == 0 && after == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = before;i <= after;i++){\n\t\t\tif(i % 4 == 0){\n\t\t\t\tif(i % 100 != 0){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tprintf(\"%d\\n\",i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i % 4 == 0){\n\t\t\t\tif(i % 400 == 0){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tprintf(\"%d\\n\",i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag == 0){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\tprintf(\"\\n\\n\");\n\t\tflag = 0;\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint isLeapYear(int year) {\n    if (year % 400 == 0) return 1;\n    if (year % 100 == 0) return 0;\n    if (year % 4 == 0) return 1;\n    return 0;\n}\n\nint main() {\n    int a, b;\n    int first = 1;\n    \n    while (1) {\n        scanf(\"%d %d\", &a, &b);\n        if (a == 0 && b == 0) break;\n        \n        if (!first) {\n            printf(\"\\n\");\n        }\n        first = 0;\n        \n        int found = 0;\n        for (int year = a; year <= b; year++) {\n            if (isLeapYear(year)) {\n                printf(\"%d\\n\", year);\n                found = 1;\n            }\n        }\n        \n        if (!found) {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  0) return 1; if (year % 100 == 0) return 0;  } int  (1) { scanf(\"%d %d\", &a, &b); if (a == 0  first = 0; int found = 0; for (int year = a; year <= b; year++)  } if (!found) { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int before,after; int i; int flag = 0; while(scanf(\"%d %d\",&before,&after)){ if(before  } if(i % 4 == 0){ if(i % 400 == 0){ flag = 1; printf(\"%d\\n\",i); } } } if(flag == 0){ printf(\"NA\\n\"); } printf(\"\\n\\n\"); flag = 0; } return 0; }"], "original_ll": -0.748376727104187, "sampled_ll": -0.4099724292755127, "all_perturbed_sampled_ll": [-2.0025992393493652], "all_perturbed_original_ll": [-1.7616751194000244], "perturbed_sampled_ll": -2.0025992393493652, "perturbed_original_ll": -1.7616751194000244, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nclass Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n\n        while (!(line = br.readLine()).equals(\"0 0\")) {\n            String[] input = line.split(\" \");\n            int a = Integer.parseInt(input[0]);\n            int b = Integer.parseInt(input[1]);\n            StringBuilder sb = new StringBuilder();\n\n            boolean isNA = true;\n\n            for (int now = a; now <= b; now++) {\n                if (now % 4 == 0) {\n                    if(now % 100 == 0){\n                        if(now % 400 == 0){\n                            sb.append(now).append(\"\\n\");\n                            if (isNA)   isNA = false;\n                        }\n                    }else{\n                        sb.append(now).append(\"\\n\");\n                        if (isNA)   isNA = false;\n                    }\n                }\n            }\n\n            if (isNA) {\n                sb.append(\"NA\").append(\"\\n\");\n            }\n\n            System.out.println(sb);\n        }\n\n    }\n}\n", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        boolean first = true;\n        \n        while (true) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            \n            if (a == 0 && b == 0) {\n                break;\n            }\n            \n            if (!first) {\n                System.out.println();\n            }\n            first = false;\n            \n            boolean found = false;\n            for (int year = a; year <= b; year++) {\n                if (isLeapYear(year)) {\n                    System.out.println(year);\n                    found = true;\n                }\n            }\n            \n            if (!found) {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean isLeapYear(int year) {\n        if (year % 400 == 0) {\n            return true;\n        }\n        if (year % 100 == 0) {\n            return false;\n        }\n        if (year % 4 == 0) {\n            return true;\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); boolean first  == 0) { break; } if (!first) { System.out.println(); } first =  year  true; } } if (!found) { System.out.println(\"NA\"); } } sc.close();  400 == 0) { return true; } if (year % 100 == 0) { return false; }  return false; } }"], "perturbed_original": ["import java.io.IOException; import  args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while (!(line = br.readLine()).equals(\"0 0\"))  int b = Integer.parseInt(input[1]); StringBuilder sb = new  == 0) { if(now % 100 == 0){ if(now % 400 == 0){ sb.append(now).append(\"\\n\"); if (isNA) isNA = false; }  if (isNA) { sb.append(\"NA\").append(\"\\n\"); } System.out.println(sb); } } }"], "original_ll": -0.639552116394043, "sampled_ll": -0.364399790763855, "all_perturbed_sampled_ll": [-1.9844884872436523], "all_perturbed_original_ll": [-1.9791077375411987], "perturbed_sampled_ll": -1.9844884872436523, "perturbed_original_ll": -1.9791077375411987, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    a,b=map(int,raw_input().split(\" \"))\n    if a==0 and b==0:\n        break\n    uruu=[]\n    for i in [year for year in range(b+1) if year >=a]:\n        if i%4==0 and i%100!=0 or i%400==0:\n            uruu.append(str(i))\n    if len(uruu)!=0:\n        print '\\n'.join(uruu)\n    else:\n        print \"NA\"\n    print ''", "sampled": "def is_leap_year(year):\n    if year % 400 == 0:\n        return True\n    if year % 100 == 0:\n        return False\n    if year % 4 == 0:\n        return True\n    return False\n\nfirst_dataset = True\n\nwhile True:\n    a, b = map(int, input().split())\n    if a == 0 and b == 0:\n        break\n    \n    if not first_dataset:\n        print()\n    first_dataset = False\n    \n    leap_years = []\n    for year in range(a, b + 1):\n        if is_leap_year(year):\n            leap_years.append(year)\n    \n    if leap_years:\n        for year in leap_years:\n            print(year)\n    else:\n        print(\"NA\")\n", "perturbed_sampled": ["def is_leap_year(year): if  100 == 0: return  False first_dataset = True while True: a, b = map(int, input().split()) if a == 0 and  False leap_years = [] for year in range(a, b + 1): if is_leap_year(year): leap_years.append(year) if leap_years: for year in leap_years: print(year) else: print(\"NA\")"], "perturbed_original": ["while True: a,b=map(int,raw_input().split(\" \")) if a==0 and b==0: break uruu=[]  >=a]: if i%4==0 and i%100!=0 or i%400==0: uruu.append(str(i)) if len(uruu)!=0: print '\\n'.join(uruu) else: print \"NA\" print ''"], "original_ll": -1.1694852113723755, "sampled_ll": -0.542375385761261, "all_perturbed_sampled_ll": [-1.7663618326187134], "all_perturbed_original_ll": [-1.7259511947631836], "perturbed_sampled_ll": -1.7663618326187134, "perturbed_original_ll": -1.7259511947631836, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "int main(){double a,b;scanf(\"%lf%lf\",&a,&b);printf(\"%.8f\\n\",a*b*0.3025);return 0;}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    \n    double area_m2 = a * b;\n    double area_tsubo = area_m2 / 3.305785;\n    \n    printf(\"%.6f\\n\", area_tsubo);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int a, b; scanf(\"%d %d\", &a, &b); double area_m2  printf(\"%.6f\\n\", area_tsubo); return 0; }"], "perturbed_original": ["int main(){double a,b;scanf(\"%lf%lf\",&a,&b);printf(\"%.8f\\n\",a*b*0.3025);return 0;}"], "original_ll": -1.7246594429016113, "sampled_ll": -1.174204707145691, "all_perturbed_sampled_ll": [-2.50404691696167], "all_perturbed_original_ll": [-1.7246594429016113], "perturbed_sampled_ll": -2.50404691696167, "perturbed_original_ll": -1.7246594429016113, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tString[] input = new Scanner(System.in).nextLine().split(\" \");\n\t\t\n\t\tfloat a = Float.parseFloat(input[0]);\n\t\tfloat b = Float.parseFloat(input[1]);\n\t\t\n\t\tSystem.out.printf(\"%1$.6f\\n\", a*b/3.305785);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        \n        double area = a * b;\n        double tsubo = area / 3.305785;\n        \n        System.out.println(tsubo);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); double area = a  } }"], "perturbed_original": [" args) { String[] input = new Scanner(System.in).nextLine().split(\" \"); float a = Float.parseFloat(input[0]); float b = Float.parseFloat(input[1]); System.out.printf(\"%1$.6f\\n\", a*b/3.305785); } }"], "original_ll": -1.2508490085601807, "sampled_ll": -1.0565663576126099, "all_perturbed_sampled_ll": [-1.9441146850585938], "all_perturbed_original_ll": [-1.6588547229766846], "perturbed_sampled_ll": -1.9441146850585938, "perturbed_original_ll": -1.6588547229766846, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a, b = map(int, input().split())\nprint(a * b / 3.305785)", "sampled": "a, b = map(int, input().split())\narea_m2 = a * b\ntsubo = area_m2 / 3.305785\nprint(tsubo)\n", "perturbed_sampled": ["a, b = map(int, input().split()) area_m2 = a * b tsubo = area_m2 / 3.305785 print(tsubo)"], "perturbed_original": ["a, b = map(int, input().split()) print(a * b / 3.305785)"], "original_ll": -1.8834068775177002, "sampled_ll": -1.8334237337112427, "all_perturbed_sampled_ll": [-2.2760980129241943], "all_perturbed_original_ll": [-2.4175193309783936], "perturbed_sampled_ll": -2.2760980129241943, "perturbed_original_ll": -2.4175193309783936, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int wo, ws, n;\n  int i;\n\n  scanf ( \"%d%d%d\", &n, &wo, &ws );\n  for ( i = 1; i < n; ++i )\n  {\n    int o, s;\n\n    scanf ( \"%d%d\", &o, &s );\n    if ( s > ws\n      || ( s == ws && o < wo ) )\n    {\n      wo = o;\n      ws = s;\n    }\n  }\n\n  printf ( \"%d %d\\n\", wo, ws );\n\n  return ( EXIT_SUCCESS );\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int max_count = -1;\n    int winner_id = 100000;\n    \n    for (int i = 0; i < n; i++) {\n        int a, v;\n        scanf(\"%d %d\", &a, &v);\n        \n        if (v > max_count || (v == max_count && a < winner_id)) {\n            max_count = v;\n            winner_id = a;\n        }\n    }\n    \n    printf(\"%d %d\\n\", winner_id, max_count);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() {  = 100000; for (int i  scanf(\"%d %d\", &a, &v); if (v > max_count || (v ==  = a; } } printf(\"%d %d\\n\", winner_id, max_count); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> int main ( int argc, char *argv[ ] ) { int wo, ws, n; int i; scanf  1; i < n; ++i ) { int o, s; scanf  ) ) {  \"%d %d\\n\", wo, ws ); return ( EXIT_SUCCESS ); }"], "original_ll": -0.9576864242553711, "sampled_ll": -0.634984016418457, "all_perturbed_sampled_ll": [-2.5008773803710938], "all_perturbed_original_ll": [-2.593513011932373], "perturbed_sampled_ll": -2.5008773803710938, "perturbed_original_ll": -2.593513011932373, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt(),x = 0,y,max = 0;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx = Math.max(x, (y = sc.nextInt()));\n\t\t\tif(y == x)max = i + 1;\n\t\t}\n\t\tSystem.out.println(max + \" \" + x);\n\t\t\n\t\tsc.close();\n\t\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        int winnerNumber = 0;\n        int maxCount = -1;\n        \n        for (int i = 0; i < n; i++) {\n            int participantNumber = sc.nextInt();\n            int count = sc.nextInt();\n            \n            if (count > maxCount || (count == maxCount && participantNumber < winnerNumber)) {\n                maxCount = count;\n                winnerNumber = participantNumber;\n            }\n        }\n        \n        System.out.println(winnerNumber + \" \" + maxCount);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  Scanner sc = new  < n; i++) { int participantNumber = sc.nextInt(); int count = sc.nextInt(); if (count > maxCount || (count == maxCount && participantNumber < winnerNumber)) { maxCount = count; winnerNumber = participantNumber; } } System.out.println(winnerNumber + \" \" + maxCount); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int n = sc.nextInt(),x  n; i++){ x = Math.max(x, (y = sc.nextInt())); if(y == x)max = i +  }"], "original_ll": -1.1142160892486572, "sampled_ll": -0.5537645220756531, "all_perturbed_sampled_ll": [-1.560246229171753], "all_perturbed_original_ll": [-2.3946213722229004], "perturbed_sampled_ll": -1.560246229171753, "perturbed_original_ll": -2.3946213722229004, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n=input()\nx=[0]*(n+1)\nfor i in range(n):\n  a,v=map(int, raw_input().split())\n  x[a]=v\nm=max(x)\nprint x.index(m), m", "sampled": "n = int(input())\nmax_count = -1\nwinner_id = float('inf')\n\nfor _ in range(n):\n    a, v = map(int, input().split())\n    if v > max_count or (v == max_count and a < winner_id):\n        max_count = v\n        winner_id = a\n\nprint(winner_id, max_count)\n", "perturbed_sampled": ["n = int(input()) max_count = -1 winner_id = float('inf') for _ in  or (v == max_count and a < winner_id): max_count = v winner_id = a print(winner_id, max_count)"], "perturbed_original": ["n=input() x=[0]*(n+1) for i in range(n): a,v=map(int, raw_input().split()) x[a]=v m=max(x) print x.index(m), m"], "original_ll": -1.905624508857727, "sampled_ll": -1.0605190992355347, "all_perturbed_sampled_ll": [-2.4114267826080322], "all_perturbed_original_ll": [-2.18837571144104], "perturbed_sampled_ll": -2.4114267826080322, "perturbed_original_ll": -2.18837571144104, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint n;\n\tint i, j, k, l;\n\tint c;\n\t\n\twhile (scanf(\"%d\", &n) != EOF){\n\t\tc = 0;\n\t\tfor (i = 0; i <= 1000; i++){\n\t\t\tfor (j = 0; j <= 1000; j++){\n\t\t\t\tfor (k = 0; k <= 1000; k++){\n\t\t\t\t\tfor (l = 0; l <= 1000; l++){\n\t\t\t\t\t\tif (i + j + k + l == n){\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) != EOF) {\n        long long count = 0;\n        for (int a = 0; a <= 1000 && a <= n; a++) {\n            for (int b = 0; b <= 1000 && a + b <= n; b++) {\n                for (int c = 0; c <= 1000 && a + b + c <= n; c++) {\n                    int d = n - a - b - c;\n                    if (d >= 0 && d <= 1000) {\n                        count++;\n                    }\n                }\n            }\n        }\n        printf(\"%lld\\n\", count);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while (scanf(\"%d\", &n) != EOF) { long long count  && a  <= 1000 && a + b <= n; b++) { for (int c = 0; c <= 1000 && a + b + c <= n; c++) { int d = n - a - b  return 0; }"], "perturbed_original": ["#include <stdio.h>   for (i = 0; i <= 1000; i++){ for (j = 0; j <= 1000; j++){ for (k = 0; k <= 1000; k++){ for (l = 0; l  l == n){ c++; } } } } } printf(\"%d\\n\", c); } return (0); }"], "original_ll": -0.47624602913856506, "sampled_ll": -0.3889685571193695, "all_perturbed_sampled_ll": [-1.6790348291397095], "all_perturbed_original_ll": [-1.1953471899032593], "perturbed_sampled_ll": -1.6790348291397095, "perturbed_original_ll": -1.1953471899032593, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Sum of 4 Integers II\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tint[][] dp = new int[5][4001];\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = 0; j <= 1000; j++) {\n\t\t\t\tdp[i][i * j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tdp[i][0] = 1;\n\t\t}\n\n\t\tfor (int i = 2; i <= 4; i++) {\n\t\t\tfor (int j = 1; j <= 1000; j++) {\n\t\t\t\tdp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n\t\t\t}\n\t\t}\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tSystem.out.println(dp[4][parseInt(line)]);\n\t\t} // end while\n\t} // end main\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Precompute all possible sums for two numbers (a+b and c+d)\n        Map<Integer, Integer> sumCount = new HashMap<>();\n        for (int i = 0; i <= 1000; i++) {\n            for (int j = 0; j <= 1000; j++) {\n                int sum = i + j;\n                sumCount.put(sum, sumCount.getOrDefault(sum, 0) + 1);\n            }\n        }\n        \n        while (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            long count = 0;\n            \n            // For each possible sum of a+b, check if n-(a+b) exists as c+d\n            for (Map.Entry<Integer, Integer> entry : sumCount.entrySet()) {\n                int sum1 = entry.getKey();\n                int count1 = entry.getValue();\n                int sum2 = n - sum1;\n                \n                if (sumCount.containsKey(sum2)) {\n                    count += (long) count1 * sumCount.get(sum2);\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc  numbers (a+b and c+d) Map<Integer, Integer>  <= 1000; i++) { for (int j = 0; j <=  sumCount.getOrDefault(sum, 0) + 1); } } while (sc.hasNextInt()) { int n = sc.nextInt(); long count = 0; // For each possible  (Map.Entry<Integer, Integer> entry :  int sum2 = n - sum1; if (sumCount.containsKey(sum2))  } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import static java.lang.Integer.parseInt; /** * Sum of 4 Integers II */  IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; int[][] dp = new   { dp[i][i * j] = 1; } } for (int i = 1; i <= 4; i++) { dp[i][0] = 1; } for (int i = 2; i  <= 1000; j++) {  } while  // end while } // end main }"], "original_ll": -0.6368560791015625, "sampled_ll": -0.5122713446617126, "all_perturbed_sampled_ll": [-2.4050230979919434], "all_perturbed_original_ll": [-1.9689871072769165], "perturbed_sampled_ll": -2.4050230979919434, "perturbed_original_ll": -1.9689871072769165, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    try:\n        n = input(); p = min(2000, n);\n        print (p+1)*(p+2)*(3*n-2*p+3)/6\n    except EOFError:\n        break", "sampled": "import sys\nfrom collections import defaultdict\n\ndef count_combinations(n):\n    # Count all possible sums of two numbers (a+b)\n    sum_count = defaultdict(int)\n    \n    # Calculate all possible sums a+b where 0 <= a, b <= 1000\n    for a in range(min(n+1, 1001)):\n        for b in range(min(n+1, 1001)):\n            if a + b <= n:\n                sum_count[a + b] += 1\n    \n    # For each sum of c+d, find how many a+b sums match to make n\n    result = 0\n    for c in range(min(n+1, 1001)):\n        for d in range(min(n+1, 1001)):\n            if c + d <= n:\n                needed = n - (c + d)\n                if needed in sum_count:\n                    result += sum_count[needed]\n    \n    return result\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    print(count_combinations(n))\n", "perturbed_sampled": ["import sys  sums of two numbers (a+b) sum_count = defaultdict(int) # Calculate all possible  += 1 # For each sum of c+d, find how many a+b sums  range(min(n+1, 1001)): for d in range(min(n+1, 1001)): if c + d <= n: needed = n - (c + d) if needed in sum_count: result += sum_count[needed] return result for line in sys.stdin: n = int(line.strip()) print(count_combinations(n))"], "perturbed_original": ["while 1: try: n = input(); p = min(2000, n); print (p+1)*(p+2)*(3*n-2*p+3)/6 except EOFError: break"], "original_ll": -1.7867523431777954, "sampled_ll": -0.8459447622299194, "all_perturbed_sampled_ll": [-2.2584590911865234], "all_perturbed_original_ll": [-2.1057493686676025], "perturbed_sampled_ll": -2.2584590911865234, "perturbed_original_ll": -2.1057493686676025, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// AOJ 0098: Maximum Sum Sequence II \n// 2017.8.15 bal4u@uu\n// 2017.11.1 retry\n\n#include <stdio.h>\n\nint a[102][102];\nint s[102][102];\n\nchar buf[1000], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, r, c, k, ans;\n\n\tfgets(p=buf, 10, stdin), n = getint();\n\tfor (r = 0; r < n; r++) {\n\t\tfgets(p=buf, sizeof(buf), stdin);\n\t\tfor (c = 0; c < n; c++, p++) {\n\t\t\tif (*p == '-') p++, a[r][c] = -getint();\n\t\t\telse                a[r][c] =  getint();\n\t\t}\n\t}\n\n\tfor (r = 0; r < n; r++)\n\t\tfor (c = 0; c < n; c++)\n\t\t\ts[r][c+1] += s[r][c] + a[r][c];\n\n\tans = s[0][1];\n\tfor (c = 0; c < n; c++) for (k = c+1; k <= n; k++) {\n\t\tint t = 0;\n\t\tfor (r = 0; r < n; r++) {\n\t\t\tif (t < 0) t  = s[r][k] - s[r][c];\n\t\t\telse       t += s[r][k] - s[r][c];\n\t\t\tif (t > ans) ans = t;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int a[100][100];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n    \n    int max_sum = a[0][0];\n    \n    for (int top = 0; top < n; top++) {\n        int col_sum[100] = {0};\n        \n        for (int bottom = top; bottom < n; bottom++) {\n            for (int j = 0; j < n; j++) {\n                col_sum[j] += a[bottom][j];\n            }\n            \n            int current_sum = 0;\n            for (int j = 0; j < n; j++) {\n                current_sum += col_sum[j];\n                if (current_sum > max_sum) {\n                    max_sum = current_sum;\n                }\n                if (current_sum < 0) {\n                    current_sum = 0;\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", max_sum);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n); int a[100][100]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { scanf(\"%d\", &a[i][j]); } } ++; if (inclusive)<extra_id_1>{ < n; top++) { int col_sum[100] = {0}; for (int bottom = --; } } }<extra_id_2>top; for (int<extra_id_3>; } max_sum<extra_id_4>top = top;<extra_id_5>current_sum = col_sum[j] ;<extra_id_6>else { current_sum<extra_id_7>} } } }  int current_sum = 0; for (int  col_sum[j]; if (current_sum > max_sum) {  0; }"], "perturbed_original": ["// AOJ 0098: Maximum Sum Sequence II // 2017.8.15 bal4u@uu // 2017.11.1 retry  getint() { int n = 0; while (*p  0xf); return n; } int main() { int n, r, c, k, ans; fgets(p=buf, 10, stdin), n =   c++, p++) { if (*p == '-') p++, a[r][c] = -getint(); else a[r][c] = getint(); } } for  0; c < n; c++) s[r][c+1] += s[r][c] + a[r][c]; ans = s[0][1]; for (c = 0;  n; k++) { int t = 0; for  += s[r][k] - s[r][c]; if (t > ans) ans = t; } } printf(\"%d\\n\", ans); return 0; }"], "original_ll": -1.0139570236206055, "sampled_ll": -0.3286702632904053, "all_perturbed_sampled_ll": [-2.1010754108428955], "all_perturbed_original_ll": [-2.153132915496826], "perturbed_sampled_ll": -2.1010754108428955, "perturbed_original_ll": -2.153132915496826, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class\nMain\n{\n  public void\n  run (\n    final java.util.Scanner sc,\n    final java.io.PrintStream out\n    )\n  {\n    int[ ][ ] a;\n    int N;\n    int i, j, k, l;\n    int res;\n\n    N = sc.nextInt ( );\n    a = new int[ N ][ N + 1 ];\n    for ( i = 0; i < N; ++i )\n    for ( j = 1; j <= N ; ++j )\n      a[ i ][ j ] = sc.nextInt ( );\n\n    for ( i = 0; i < N; ++i )\n    for ( j = 1; j <= N; ++j )\n      a[ i ][ j ] += a[ i ][ j - 1 ];\n\n    res = a[ 0 ][ 1 ];\n    for ( i = 0; i < N; ++i )\n    for ( j = i + 1; j <= N; ++j )\n    {\n      for ( k = 0; k < N; ++k )\n      {\n        int t = 0;\n\n        for ( l = k; l < N; ++l )\n        {\n          t += a[ l ][ j ] - a[ l ][ i ];\n          res = Math.max ( res, t );\n        }\n      }\n    }\n\n    out.println ( res );\n  }\n\n  public static void\n  main (\n    String[ ] args\n    )\n  {\n    ( new Main ( ) ).run ( new java.util.Scanner ( System.in ), System.out );\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] a = new int[n][n];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                a[i][j] = sc.nextInt();\n            }\n        }\n        \n        long maxSum = Long.MIN_VALUE;\n        \n        for (int top = 0; top < n; top++) {\n            int[] colSum = new int[n];\n            \n            for (int bottom = top; bottom < n; bottom++) {\n                for (int col = 0; col < n; col++) {\n                    colSum[col] += a[bottom][col];\n                }\n                \n                long currentSum = 0;\n                long maxEndingHere = Long.MIN_VALUE;\n                \n                for (int col = 0; col < n; col++) {\n                    currentSum += colSum[col];\n                    maxEndingHere = Math.max(maxEndingHere, currentSum);\n                    if (currentSum < 0) {\n                        currentSum = 0;\n                    }\n                }\n                \n                maxSum = Math.max(maxSum, maxEndingHere);\n            }\n        }\n        \n        System.out.println(maxSum);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in);  (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { a[i][j] = sc.nextInt(); } }  < n;  col = 0; col < n; col++) { colSum[col] += a[bottom][col]; } long currentSum = 0; long maxEndingHere =  { currentSum += colSum[col]; maxEndingHere = Math.max(maxEndingHere, currentSum); if (currentSum < 0) {  } System.out.println(maxSum); sc.close(); } }"], "perturbed_original": ["public class Main { public void run ( final java.util.Scanner sc, final java.io.PrintStream out ) { int[ ][ ] a; int N; int i,  ]; for ( i =  1; j <= N ; ++j ) a[ i ][ j ] = sc.nextInt ( ); for ( i = 0; i < N; ++i ) for ( j = 1; j <= N; ++j ) a[ i ][ j ] += a[ i ][ j - 1 ]; res = a[ 0  N; ++i ) for ( j = i + 1;  = 0; for ( l = k; l  j ] - a[ l  ( new Main ( ) ).run ( new java.util.Scanner ( System.in ), System.out ); } }"], "original_ll": -0.6675134897232056, "sampled_ll": -0.32110852003097534, "all_perturbed_sampled_ll": [-1.468299388885498], "all_perturbed_original_ll": [-1.7853232622146606], "perturbed_sampled_ll": -1.468299388885498, "perturbed_original_ll": -1.7853232622146606, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0098\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\ndef calc_points(n, array):\n    # \u53f3\u4e0b\u304b\u3089(x, y)\u307e\u3067\u306e\u9577\u65b9\u5f62\u306b\u542b\u307e\u308c\u308b\u5024\u306e\u548c\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for y in range(n - 1, -1, -1):\n        for x in range(n - 1, -1, -1):\n            dp[y][x] = dp[y+1][x] + dp[y][x+1] - dp[y+1][x+1] + array[y][x]\n    return dp\n\n\ndef solve(n, array):\n    ans = []\n    dp = calc_points(n, array)\n\n    for sy in range(n + 1):\n        for sx in range(n + 1):\n            for ey in range(sy, n + 1):\n                for ex in range(sx, n + 1):\n                    s1 = dp[sy][sx] #  \u53f3\u4e0b\u304b\u3089\u59cb\u70b9\u307e\u3067\n                    s2 = dp[sy][ex] #  \u91cd\u306a\u308a\u90e8\u5206\n                    s3 = dp[ey][sx] #  \u91cd\u306a\u308a\u90e8\u5206\n                    s4 = dp[ey][ex] #  \u91cd\u306a\u308a\u306e\u91cd\u306a\u308a\u90e8\u5206\n                    s = s1 - s2 -s3 + s4 #  (sx, sy) - (ex, ey) \u9577\u65b9\u5f62\u306e\u7f8e\u5473\u3057\u3055\u30dd\u30a4\u30f3\u30c8\n                    # area = abs(sy - ey) * abs(sx - ex) #  \u9577\u65b9\u5f62\u306e\u9762\u7a4d\n                    ans.append(s)\n    return max(ans)\n\n\ndef main(args):\n    array = []\n    # n = 3\n    # array.append([1, -2, 3])\n    # array.append([-4, 5, 6])\n    # array.append([7, 8, -9])\n\n    n = int(input())\n    for _ in range(n):\n        array.append([int(x) for x in input().split()])\n    ans = solve(n, array)\n    print(ans)\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n", "sampled": "def max_subarray_sum(arr):\n    if not arr:\n        return 0\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\nn = int(input())\nmatrix = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    matrix.append(row)\n\nmax_sum = float('-inf')\n\nfor top in range(n):\n    temp = [0] * n\n    for bottom in range(top, n):\n        for col in range(n):\n            temp[col] += matrix[bottom][col]\n        current_max = max_subarray_sum(temp)\n        max_sum = max(max_sum, current_max)\n\nprint(max_sum)\n", "perturbed_sampled": ["def max_subarray_sum(arr): if not arr: return 0 max_sum = float('-inf') current_sum = 0 for num in arr: current_sum = max(num, current_sum +  matrix = [] for _ in range(n): row = list(map(int,  = [0] * n for bottom in range(top, n): for  = max(max_sum, current_max) print(max_sum)"], "perturbed_original": ["# -*- coding: utf-8 -*- \"\"\" http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0098 \"\"\"  calc_points(n, array): # \u53f3\u4e0b\u304b\u3089(x, y)\u307e\u3067\u306e\u9577\u65b9\u5f62\u306b\u542b\u307e\u308c\u308b\u5024\u306e\u548c dp = [[0] * (n + 1) for _ in range(n + 1)] for y in range(n  + array[y][x] return dp def solve(n, array): ans = [] dp = calc_points(n, array) for sy in  ey in range(sy, n + 1): for ex in range(sx, n + 1):  = abs(sy - ey) * abs(sx - ex) # \u9577\u65b9\u5f62\u306e\u9762\u7a4d ans.append(s) return max(ans)  array.append([1, -2, 3]) # array.append([-4, 5, 6]) # array.append([7, 8, -9]) n = int(input()) for _ in range(n): array.append([int(x) for x in input().split()]) ans = solve(n, array) print(ans) if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -0.844601035118103, "sampled_ll": -0.47501662373542786, "all_perturbed_sampled_ll": [-1.8373395204544067], "all_perturbed_original_ll": [-1.595654845237732], "perturbed_sampled_ll": -1.8373395204544067, "perturbed_original_ll": -1.595654845237732, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <assert.h>\nint main(void){\n\tint i,x,n,q,a,v,aaa=0,vvv=0,vv[9000],f[1000001],next[1000001],prev[1000001];\n\tscanf(\"%d %d\",&n,&q);\n\tfor(i=0;i<=n;i++){f[i]=0;prev[i]=0;next[i]=0;}\n\tfor(i=0;i<9000;i++)vv[i]=0;\n\tfor(;q>0;q--){\n\t\tscanf(\"%d %d\",&a,&v);\n\n\t\tx=f[a];\n\n\t\tif(x>0){\n\t\t\tif(vv[x]==a){\n\t\t\t\tif(next[a]>0){vv[x]=next[a];}\n\t\t\t\telse vv[x]=0;\n\t\t\t}\n\t\t\tnext[prev[a]]=next[a];\n\t\t\tprev[next[a]]=prev[a];\n\t\t\tprev[0]=0;next[0]=0;\n\t\t}\n\n\t\tf[a]+=v;x+=v;\n\t\t\n\t\tif(x>0){\n\t\t\tif(a<vv[x] || vv[x]==0){\n\t\t\t\tprev[a]=0;\n\t\t\t\tnext[a]=vv[x];\n\t\t\t\tprev[vv[x]]=a;\n\t\t\t\tprev[0]=0;\n\t\t\t\tvv[x]=a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti=vv[x];\n\t\t\t\twhile(a>next[i] && next[i]>0){i=next[i];assert(i>0 && i<=n);}\n\t\t\t\tprev[a]=i;\n\t\t\t\tnext[a]=next[i];\n\t\t\t\tprev[next[i]]=a;\n\t\t\t\tnext[i]=a;\n\t\t\t\tprev[0]=0;\n\t\t\t}\n\t\t}else{prev[a]=0;next[a]=0;}\n\t\t\n\t\tif(v>0){if(x>vvv || (x==vvv && a<aaa)){vvv=x;aaa=a;}}\n\t\telse if(a==aaa){\n\t\t\ti=vvv;\n\t\t\t//for(i=vvv; vv[i]<1 && i>0 ;i--){assert(i>0 && i<9000);}\n\t\t\tvvv=i;\n\t\t\t//aaa=vv[i];\n\t\t}\n\t\tprintf(\"%d %d\\n\",aaa,vvv);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    long long *counts = (long long *)calloc(n + 1, sizeof(long long));\n    \n    int max_id = 1;\n    long long max_count = 0;\n    \n    for (int i = 0; i < q; i++) {\n        int a, v;\n        scanf(\"%d %d\", &a, &v);\n        \n        counts[a] += v;\n        \n        max_id = 1;\n        max_count = counts[1];\n        for (int j = 2; j <= n; j++) {\n            if (counts[j] > max_count) {\n                max_count = counts[j];\n                max_id = j;\n            }\n        }\n        \n        printf(\"%d %lld\\n\", max_id, max_count);\n    }\n    \n    free(counts);\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int )<extra_id_6>++<extra_id_7>) int exp0 =<extra_id_8>= (int)<extra_id_9>p; } if<extra_id_10>[1]<extra_id_11>(int)<extra_id_12>//<extra_id_13>++p; i<extra_id_14>if(i<q;<extra_id_15>{<extra_id_16>{ foreach (int<extra_id_17>) { if<extra_id_18>( int<extra_id_19>) { if ( i<extra_id_20>=<extra_id_21>2<extra_id_22>) { long)); int max_id = 1; long  < q; i++) { int a, v; scanf(\"%d %d\", &a, &v); counts[a] += v; max_id = 1; max_count = counts[1]; for (int j = 2; j <= n; j++)  = j; } } printf(\"%d %lld\\n\", max_id, max_count); } free(counts); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <assert.h> int main(void){ int i,x,n,q,a,v,aaa=0,vvv=0,vv[9000],f[1000001],next[1000001],prev[1000001]; scanf(\"%d %d\",&n,&q); for(i=0;i<=n;i++){f[i]=0;prev[i]=0;next[i]=0;} for(i=0;i<9000;i++)vv[i]=0; for(;q>0;q--){ scanf(\"%d %d\",&a,&v); x=f[a]; if(x>0){  if(x>0){ if(a<vv[x] || vv[x]==0){ prev[a]=0; next[a]=vv[x]; prev[vv[x]]=a; prev[0]=0; vv[x]=a;  prev[next[i]]=a; next[i]=a;  i=vvv; //for(i=vvv; vv[i]<1 && i>0 ;i--){assert(i>0 && i<9000);} vvv=i; //aaa=vv[i]; } printf(\"%d %d\\n\",aaa,vvv); } return 0; }"], "original_ll": -1.116189956665039, "sampled_ll": -0.5146515965461731, "all_perturbed_sampled_ll": [-2.037175178527832], "all_perturbed_original_ll": [-1.553134799003601], "perturbed_sampled_ll": -2.037175178527832, "perturbed_original_ll": -1.553134799003601, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class\nMain\n{\n  public void\n  run (\n    final java.util.Scanner sc,\n    final java.io.PrintStream out\n    )\n  {\n    Pair[ ] heap;\n    int[ ]  paeh;\n    int n, q;\n    int i;\n    \n    n = sc.nextInt ( );\n    q = sc.nextInt ( );\n\n    heap = new Pair[ n ];\n    paeh = new int[ n + 1 ];\n    for ( i = 1; i <= n; ++i )\n    {\n      paeh[ i ] = i - 1;\n      heap[ paeh[ i ] ] = new Pair ( i, 0 );\n    }\n\n    for ( ; q > 0; --q )\n    {\n      int a, v, b;\n\n      a = sc.nextInt ( );\n      v = sc.nextInt ( );\n      b = heap[ heap.length - 1 ].index;\n\n      swap ( heap, paeh[ a ], paeh[ b ] );\n      swap ( paeh, a, heap[ paeh[ a ] ].index );\n      for ( ; ; )\n      {\n        if ( paeh[ b ] * 2 + 2 < heap.length - 1\n          && heap[ paeh[ b ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] * 2 + 1 ] ) < 0\n          && heap[ paeh[ b ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] ] ) < 0 )\n        {\n          swap ( heap, paeh[ b ], paeh[ b ] * 2 + 2 );\n          swap ( paeh, b, heap[ paeh[ b ] ].index );\n        }\n        else if ( paeh[ b ] * 2 + 1 < heap.length - 1\n               && heap[ paeh[ b ] * 2 + 1 ].compareTo ( heap[ paeh[ b ] ] ) < 0 )\n        {\n          swap ( heap, paeh[ b ], paeh[ b ] * 2 + 1 );\n          swap ( paeh, b, heap[ paeh[ b ] ].index );\n        }\n        else break ;\n      }\n      heap[ paeh[ a ] ].value += v;\n      for ( ; ; )\n      {\n        if ( paeh[ a ] > 0\n          && heap[ paeh[ a ] ].compareTo ( heap[ ( paeh[ a ] - 1 ) / 2 ] ) < 0 )\n        {\n          swap ( heap, paeh[ a ], ( paeh[ a ] - 1 ) / 2 );\n          swap ( paeh, a, heap[ paeh[ a ] ].index );\n        }\n        else break ;\n      }\n      System.out.println ( heap[ 0 ].index + \" \" + heap[ 0 ].value );\n    }\n  }\n\n  private static void\n  swap (\n    int[ ] a,\n    int i,\n    int j\n    )\n  {\n    final int t = a[ i ];\n    a[ i ] = a[ j ];\n    a[ j ] = t;\n  }\n\n  private static <T> void\n  swap (\n    T[ ] a,\n    int i,\n    int j\n    )\n  {\n    final T t = a[ i ];\n    a[ i ] = a[ j ];\n    a[ j ] = t;\n  }\n\n  public static void\n  main (\n    final String[ ] args\n    )\n  {\n    ( new Main ( ) ).run ( new java.util.Scanner ( System.in ), System.out );\n  }\n\n  private class\n  Pair\n  implements Comparable<Pair>\n  {\n    public final int index;\n    public       int value;\n\n    public\n    Pair (\n      final int index,\n      final int value\n      )\n    {\n      this.index = index;\n      this.value = value;\n    }\n\n    public int\n    compareTo (\n      final Pair obj\n      )\n    {\n      if ( this.value == obj.value )\n        return ( this.index - obj.index );\n      return ( obj.value - this.value );\n    }\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int q = sc.nextInt();\n        \n        Map<Integer, Integer> counts = new HashMap<>();\n        \n        for (int i = 0; i < q; i++) {\n            int a = sc.nextInt();\n            int v = sc.nextInt();\n            \n            counts.put(a, counts.getOrDefault(a, 0) + v);\n            \n            int maxCount = Integer.MIN_VALUE;\n            int maxParticipant = Integer.MAX_VALUE;\n            \n            for (int participant = 1; participant <= n; participant++) {\n                int count = counts.getOrDefault(participant, 0);\n                if (count > maxCount || (count == maxCount && participant < maxParticipant)) {\n                    maxCount = count;\n                    maxParticipant = participant;\n                }\n            }\n            \n            System.out.println(maxParticipant + \" \" + maxCount);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new   i < q; i++) { int a = sc.nextInt(); int v = sc.nextInt(); counts.put(a, counts.getOrDefault(a, 0) + v); int maxCount = Integer.MIN_VALUE; int maxParticipant = Integer.MAX_VALUE; for (int participant = 1; participant  (count > maxCount || (count == maxCount && participant  } }"], "perturbed_original": ["public class Main { public void run ( final java.util.Scanner sc, final java.io.PrintStream  n, q; int i; n = sc.nextInt ( ); q = sc.nextInt ( ); heap = new Pair[ n ]; paeh = new int[ n + 1 ]; for ( i = 1; i <= n; ++i ) { paeh[ i ] = i - 1; heap[ paeh[ i ] ] = new Pair ( i, 0 ); } for (  b; a = sc.nextInt ( ); v = sc.nextInt ( ); b = heap[  paeh[  if ( paeh[ b ] * 2  ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] * 2 + 1 ] ) < 0 &&  heap[  ( heap, paeh[ b ], paeh[ b ] * 2 +   2 + 1 < heap.length  1 ].compareTo ( heap[ paeh[ b ] ] )  ( paeh, b, heap[ paeh[ b ] ].index ); } else break ; } heap[ paeh[  heap[ paeh[  { swap ( heap, paeh[ a ], ( paeh[ a ]  heap[ paeh[ a ] ].index ); } else  \" + heap[ 0 ].value   j ]; a[ j ] = t; } private static <T> void swap ( T[ ] a, int i, int j ) { final T t = a[ i ]; a[  t; } public static void main ( final String[ ] args ) { ( new Main ( ) ).run ( new java.util.Scanner ( System.in  this.index = index; this.value = value; } public int compareTo ( final Pair obj ) { if ( this.value == obj.value ) return ( this.index - obj.index ); return ( obj.value - this.value ); } } }"], "original_ll": -0.5393235683441162, "sampled_ll": -0.5077760815620422, "all_perturbed_sampled_ll": [-1.8192824125289917], "all_perturbed_original_ll": [-1.7994352579116821], "perturbed_sampled_ll": -1.8192824125289917, "perturbed_original_ll": -1.7994352579116821, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0099\n\"\"\"\nimport sys\nimport bisect\n\n\n\ndef main(args):\n    #data = [(1, 4), (2, 5), (1, 3), (3, 6), (2, 7)]\n    #data = [(1, 4), (2, 5), (2, -3),(3, 4), (1, -1)]\n    fisher, event = [int(x) for x in input().split(' ')]\n    fishes = [0 for _ in range(fisher + 1)]\n\n    winner = 9999999999\n    max_fish = -1\n    for _ in range(event):\n        id, fish = [int(x) for x in input().strip().split(' ')]\n        fishes[id] += fish\n        if fish > 0:\n            if fishes[id] > max_fish:\n                max_fish = fishes[id]\n                winner = id\n            elif fishes[id] == max_fish:\n                winner = min(winner, id)\n            else:\n                pass\n        else:\n            max_fish = max(fishes)\n            winner = fishes.index(max_fish)\n        print('{} {}'.format(winner, max_fish))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])", "sampled": "n, q = map(int, input().split())\ncounts = [0] * (n + 1)\n\nfor _ in range(q):\n    a, v = map(int, input().split())\n    counts[a] += v\n    \n    max_count = max(counts[1:n+1])\n    for i in range(1, n + 1):\n        if counts[i] == max_count:\n            print(i, max_count)\n            break\n", "perturbed_sampled": ["n, q = map(int, input().split()) counts = [0] * (n + 1) for _  max_count  counts[i] == max_count: print(i, max_count) break"], "perturbed_original": ["# -*- coding: utf-8 -*- \"\"\" http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0099 \"\"\" import sys import bisect def main(args): #data = [(1, 4), (2, 5), (1, 3),  _ in range(fisher + 1)] winner = 9999999999 max_fish = -1 for _ in range(event): id, fish = [int(x) for x in input().strip().split(' ')] fishes[id] += fish if fish > 0:  elif fishes[id] == max_fish: winner = min(winner, id) else: pass  if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -0.9914648532867432, "sampled_ll": -0.7045387029647827, "all_perturbed_sampled_ll": [-2.0860886573791504], "all_perturbed_original_ll": [-1.8324546813964844], "perturbed_sampled_ll": -2.0860886573791504, "perturbed_original_ll": -1.8324546813964844, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\tint n;\n\tint staff,price,sold;\n\twhile(1){\n\t\tint i,j = 0;\n\t\tint sccess[4000];\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0)\n\t\t\treturn 0;\n\t\t\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d %d %d\", &staff, &price, &sold);\n\t\t\tif(price * sold >= 1000000){\n\t\t\t\tsccess[j] = staff;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(j == 0){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\tfor(i = 0; j > i; i++){\n\t\t\tprintf(\"%d\\n\", sccess[i]);\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n != 0) {\n        int ids[4000];\n        long long sales[4000];\n        int count = 0;\n        \n        for(int i = 0; i < n; i++) {\n            int id, p, q;\n            scanf(\"%d %d %d\", &id, &p, &q);\n            \n            int found = -1;\n            for(int j = 0; j < count; j++) {\n                if(ids[j] == id) {\n                    found = j;\n                    break;\n                }\n            }\n            \n            if(found == -1) {\n                ids[count] = id;\n                sales[count] = (long long)p * q;\n                count++;\n            } else {\n                sales[found] += (long long)p * q;\n            }\n        }\n        \n        int found_any = 0;\n        for(int i = 0; i < count; i++) {\n            if(sales[i] >= 1000000) {\n                printf(\"%d\\n\", ids[i]);\n                found_any = 1;\n            }\n        }\n        \n        if(!found_any) {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; while(scanf(\"%d\", &n) && n != 0) { int ids[4000]; long long sales[4000]; int count = 0; for(int i =  -1; for(int j = 0; j  = id; sales[count] = (long long)p * q; count++; } else { sales[found] += (long long)p * q; } } int found_any = 0; for(int i =   } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int n; int staff,price,sold; while(1){ int i,j = 0;  = 0;i  if(j == 0){ printf(\"NA\\n\"); } for(i = 0; j > i; i++){ printf(\"%d\\n\", sccess[i]); } } }"], "original_ll": -1.183956503868103, "sampled_ll": -0.5220412015914917, "all_perturbed_sampled_ll": [-1.7754286527633667], "all_perturbed_original_ll": [-3.1017866134643555], "perturbed_sampled_ll": -1.7754286527633667, "perturbed_original_ll": -3.1017866134643555, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Sale Result\npublic class Main{\n\n\tstatic class P implements Comparable<P>{\n\t\tpublic int o;\n\t\tpublic long s;\n\t\tpublic int compareTo(P o) {\n\t\t\treturn this.o-o.o;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tList<Integer> l = new ArrayList<Integer>();\n\t\t\tP[] s = new P[4001];\n\t\t\tint id = 0;\n\t\t\twhile(n--!=0){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tif(s[d]==null){\n\t\t\t\t\ts[d] = new P();\n\t\t\t\t\ts[d].o = id++;\n\t\t\t\t}\n\t\t\t\tlong p = sc.nextLong();\n\t\t\t\tlong k = sc.nextLong();\n\t\t\t\ts[d].s+=p*k;\n\t\t\t}\n\t\t\tfor(int i=1;i<4001;i++)if(s[i]!=null&&1000000<=s[i].s)l.add(i);\n\t\t\tCollections.sort(l);\n\t\t\tif(l.isEmpty())System.out.println(\"NA\");\n\t\t\telse for(int i:l)System.out.println(i);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            LinkedHashMap<Integer, Long> sales = new LinkedHashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                int id = sc.nextInt();\n                long price = sc.nextLong();\n                long quantity = sc.nextLong();\n                long amount = price * quantity;\n                \n                sales.put(id, sales.getOrDefault(id, 0L) + amount);\n            }\n            \n            boolean found = false;\n            for (Map.Entry<Integer, Long> entry : sales.entrySet()) {\n                if (entry.getValue() >= 1000000) {\n                    System.out.println(entry.getKey());\n                    found = true;\n                }\n            }\n            \n            if (!found) {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; LinkedHashMap<Integer, Long> sales = new LinkedHashMap<>(); for (int i = 0; i < n; i++) { int id = sc.nextInt(); long price = sc.nextLong(); long quantity = sc.nextLong(); long amount  } sc.close(); } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Scanner; //Sale Result public class Main{ static class P implements Comparable<P>{ public int o; public long s;  static void  n =  new P[4001]; int id = 0; while(n--!=0){ int d = sc.nextInt(); if(s[d]==null){ s[d] = new P(); s[d].o = id++; } long p = sc.nextLong(); long k  i:l)System.out.println(i); } } }"], "original_ll": -0.9789004325866699, "sampled_ll": -0.45947757363319397, "all_perturbed_sampled_ll": [-1.401697039604187], "all_perturbed_original_ll": [-2.7076261043548584], "perturbed_sampled_ll": -1.401697039604187, "perturbed_original_ll": -2.7076261043548584, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nfrom collections import defaultdict\n\nfor s in sys.stdin:\n    n = int(s)\n    if n == 0:\n        break\n\n    d = defaultdict(int)\n    keys = []\n    for i in range(n):\n        e, p, q = map(int, input().split())\n        d[e] += p * q\n        if e not in keys:\n            keys.append(e)\n\n    # remove dup\n    is_exist = False\n\n    for key in keys:\n        v = d[key]\n        if v >= 1000000:\n            print(key)\n            is_exist = True\n\n    if not is_exist:\n        print('NA')", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    sales = {}\n    order = []\n    \n    for _ in range(n):\n        line = input().split()\n        employee_id = line[0]\n        p = int(line[1])\n        q = int(line[2])\n        \n        if employee_id not in sales:\n            sales[employee_id] = 0\n            order.append(employee_id)\n        \n        sales[employee_id] += p * q\n    \n    result = []\n    for employee_id in order:\n        if sales[employee_id] >= 1000000:\n            result.append(employee_id)\n    \n    if result:\n        for emp_id in result:\n            print(emp_id)\n    else:\n        print(\"NA\")\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break if<extra_id_2>result:<extra_id_3>] + p * q<extra_id_4>e<extra_id_5>e<extra_id_6>for f in result[1]<extra_id_7>= e[0] = f[1]<extra_id_8>f<extra_id_9>0 :<extra_id_10>/<extra_id_11>. extend ( sales<extra_id_12>= order order =<extra_id_13>== 0 :<extra_id_14>else: sales[employee_id ] +=<extra_id_15>* q ) result<extra_id_16>, - 1 ]<extra_id_17>if result<extra_id_18>) print(result<extra_id_19>;<extra_id_20>if p line =  if employee_id not in sales: sales[employee_id] = 0 order.append(employee_id) sales[employee_id] += p * q result =  if result: for emp_id in result: print(emp_id) else: print(\"NA\")"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys import os import math from  if n == 0: break d = defaultdict(int) keys = [] for i in range(n): e, p, q = map(int, input().split()) d[e] += p * q if e not   print(key) is_exist = True if not is_exist: print('NA')"], "original_ll": -1.1192142963409424, "sampled_ll": -0.7151361107826233, "all_perturbed_sampled_ll": [-2.3155179023742676], "all_perturbed_original_ll": [-2.5332930088043213], "perturbed_sampled_ll": -2.3155179023742676, "perturbed_original_ll": -2.5332930088043213, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n\tint n;\n\tchar in[1024], *ptr;\n\n\tscanf(\"%d \", &n);\n\n\twhile (n--) {\n\t\tfgets(in, 1023, stdin);\n\t\tptr = strstr(in, \"Hoshino\");\n\t\twhile (ptr != NULL) {\n\t\t\tptr[6] = 'a';\n\t\t\tptr = strstr(ptr, \"Hoshino\");\n\t\t}\n\t\tprintf(\"%s\", in);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    char line[1001];\n    char result[1001];\n    \n    scanf(\"%d\\n\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        fgets(line, sizeof(line), stdin);\n        \n        int len = strlen(line);\n        if (line[len-1] == '\\n') {\n            line[len-1] = '\\0';\n            len--;\n        }\n        \n        int j = 0;\n        int k = 0;\n        \n        while (j < len) {\n            if (j + 6 < len && strncmp(&line[j], \"Hoshino\", 7) == 0) {\n                strcpy(&result[k], \"Hoshina\");\n                k += 7;\n                j += 7;\n            } else if (j + 6 == len && strncmp(&line[j], \"Hoshino\", 7) == 0) {\n                strcpy(&result[k], \"Hoshina\");\n                k += 7;\n                j += 7;\n            } else {\n                result[k] = line[j];\n                k++;\n                j++;\n            }\n        }\n        \n        result[k] = '\\0';\n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; char line[1001]; char result[1001]; scanf(\"%d\\n\",  { fgets(line, sizeof(line), stdin); int len = strlen(line); if (line[len-1] == '\\n') { line[len-1] = '\\0'; len--; } int j = 0; int k = 0; while (j < len) { if (j  } else if (j + 6 ==  k += 7; j += 7; } else  '\\0'; printf(\"%s\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(void) { int n; char in[1024], *ptr; scanf(\"%d \", &n); while (n--) {   printf(\"%s\", in); } return 0; }"], "original_ll": -0.9559105038642883, "sampled_ll": -0.5093911290168762, "all_perturbed_sampled_ll": [-1.5215338468551636], "all_perturbed_original_ll": [-1.649060606956482], "perturbed_sampled_ll": -1.5215338468551636, "perturbed_original_ll": -1.649060606956482, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString str = sc.nextLine();\n\t\t\tstr = str.replaceAll(\"Hoshino\", \"Hoshina\");\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n}\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            String result = line.replace(\"Hoshino\", \"Hoshina\");\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main  = 0; i < n; i++) { String line = sc.nextLine(); String result = line.replace(\"Hoshino\", \"Hoshina\"); System.out.println(result); } sc.close(); } }"], "perturbed_original": ["import  for (int i = 0; i < n; i++) { String str = sc.nextLine(); str = str.replaceAll(\"Hoshino\", \"Hoshina\"); System.out.println(str); } } }"], "original_ll": -0.9755993485450745, "sampled_ll": -0.8541982173919678, "all_perturbed_sampled_ll": [-2.4306979179382324], "all_perturbed_original_ll": [-1.7977925539016724], "perturbed_sampled_ll": -2.4306979179382324, "perturbed_original_ll": -1.7977925539016724, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\ndef main():\n  n = int(sys.stdin.readline())\n  for _ in range(n):\n    line = sys.stdin.readline()\n    print(line.strip().replace(\"Hoshino\", \"Hoshina\"))\n\nif __name__ == \"__main__\":\n  main()", "sampled": "n = int(input())\nfor _ in range(n):\n    line = input()\n    print(line.replace(\"Hoshino\", \"Hoshina\"))\n", "perturbed_sampled": ["n = int(input()) for _ in range(n): line = input() print(line.replace(\"Hoshino\", \"Hoshina\"))"], "perturbed_original": ["import sys def main(): n  \"Hoshina\")) if __name__ == \"__main__\": main()"], "original_ll": -1.3790850639343262, "sampled_ll": -2.2178618907928467, "all_perturbed_sampled_ll": [-2.781747341156006], "all_perturbed_original_ll": [-4.367682933807373], "perturbed_sampled_ll": -2.781747341156006, "perturbed_original_ll": -4.367682933807373, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  int a[11][11]={};\n  int i,j,n,s,t;\n\n  for(;;){\n    scanf(\"%d\",&n);\n    if(!n)\n      break;\n    t=0;\n\n    for(i=0;i<n;i++){\n      s=0;\n      for(j=0;j<n;j++){\n\tscanf(\"%d\",&a[i][j]);\n\ts+=a[i][j];\n      }\n      a[i][n]=s;\n      t+=s;\n    }\n    a[n][n]=t;\n    for(j=0;j<n;j++){\n      s=0;\n      for(i=0;i<n;i++){\n\ts+=a[i][j];\n      }\n      a[n][j]=s;\n    }\n    for(i=0;i<=n;i++){\n      for(j=0;j<=n;j++){\n\tprintf(\"%5d\",a[i][j]);\n      }\n      puts(\"\");\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int table[n][n];\n        int rowSum[n];\n        int colSum[n];\n        int totalSum = 0;\n        \n        // Read input\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                scanf(\"%d\", &table[i][j]);\n            }\n        }\n        \n        // Calculate row sums\n        for(int i = 0; i < n; i++) {\n            rowSum[i] = 0;\n            for(int j = 0; j < n; j++) {\n                rowSum[i] += table[i][j];\n            }\n        }\n        \n        // Calculate column sums\n        for(int j = 0; j < n; j++) {\n            colSum[j] = 0;\n            for(int i = 0; i < n; i++) {\n                colSum[j] += table[i][j];\n            }\n        }\n        \n        // Calculate total sum\n        for(int i = 0; i < n; i++) {\n            totalSum += rowSum[i];\n        }\n        \n        // Print table with row sums\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                printf(\"%5d\", table[i][j]);\n            }\n            printf(\"%5d\\n\", rowSum[i]);\n        }\n        \n        // Print column sums and total sum\n        for(int j = 0; j < n; j++) {\n            printf(\"%5d\", colSum[j]);\n        }\n        printf(\"%5d\\n\", totalSum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) { scanf(\"%d\", &n); if(n == 0) break; int table[n][n]; int rowSum[n]; int colSum[n]; int totalSum = 0; // Read input for(int  for(int j = 0; j < n; j++) { rowSum[i] += table[i][j]; } } // Calculate column sums for(int j =  i = 0; i  table with row sums for(int i = 0; i < n; i++) { for(int  } printf(\"%5d\\n\", rowSum[i]); } // Print column sums and total sum for(int j = 0; j < n; j++) { printf(\"%5d\", colSum[j]); } printf(\"%5d\\n\", totalSum); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int a[11][11]={}; int i,j,n,s,t; for(;;){ scanf(\"%d\",&n); if(!n) break; t=0;  for(j=0;j<n;j++){ s=0; for(i=0;i<n;i++){ s+=a[i][j]; } a[n][j]=s; } for(i=0;i<=n;i++){ for(j=0;j<=n;j++){ printf(\"%5d\",a[i][j]); } puts(\"\"); } } return 0; }"], "original_ll": -0.7122858762741089, "sampled_ll": -0.26005569100379944, "all_perturbed_sampled_ll": [-1.2527343034744263], "all_perturbed_original_ll": [-1.1669913530349731], "perturbed_sampled_ll": -1.2527343034744263, "perturbed_original_ll": -1.1669913530349731, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n    public static void main(String args[]){\n        Scanner in = new Scanner(System.in);\n        while(true){\n            int n = in.nextInt();\n            if(n == 0) return ;\n            int mat[][] = new int[n+1][n+1];\n            for(int i=0; i<n; i++){\n                int sumr = 0;\n                for(int j=0; j<n; j++){\n                    mat[i][j] = in.nextInt();\n                    sumr += mat[i][j];\n                }\n                mat[i][n] = sumr;\n            }\n            for(int j=0; j<=n; j++){\n                int sumc = 0;\n                for(int i=0; i<n; i++){\n                    sumc += mat[i][j];\n                }\n                mat[n][j] = sumc;\n            }\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    System.out.printf(\"%5d\",mat[i][j]);\n                }\n                System.out.println();\n            }\n        }\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[][] table = new int[n][n];\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    table[i][j] = sc.nextInt();\n                }\n            }\n            \n            int[] rowSums = new int[n];\n            int[] colSums = new int[n];\n            \n            for (int i = 0; i < n; i++) {\n                int rowSum = 0;\n                for (int j = 0; j < n; j++) {\n                    rowSum += table[i][j];\n                }\n                rowSums[i] = rowSum;\n            }\n            \n            for (int j = 0; j < n; j++) {\n                int colSum = 0;\n                for (int i = 0; i < n; i++) {\n                    colSum += table[i][j];\n                }\n                colSums[j] = colSum;\n            }\n            \n            int totalSum = 0;\n            for (int i = 0; i < n; i++) {\n                totalSum += rowSums[i];\n            }\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    System.out.printf(\"%5d\", table[i][j]);\n                }\n                System.out.printf(\"%5d\\n\", rowSums[i]);\n            }\n            \n            for (int j = 0; j < n; j++) {\n                System.out.printf(\"%5d\", colSums[j]);\n            }\n            System.out.printf(\"%5d\\n\", totalSum);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n  i = 0; i < n; i++) { for (int j = 0; j < n; j++) { table[i][j] = sc.nextInt(); } } int[] rowSums = new int[n]; int[] colSums = new int[n]; for (int i = 0; i < n; i++) { int rowSum = 0; for (int j  }  < n; j++) { int colSum = 0; for (int i = 0; i < n; i++) { colSum += table[i][j]; } colSums[j] =  }  for (int j = 0; j < n; j++) { System.out.printf(\"%5d\",  totalSum); } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main{ public static void main(String  in.nextInt(); if(n == 0) return ;  sumr = 0; for(int j=0; j<n; j++){ mat[i][j] = in.nextInt(); sumr += mat[i][j]; } mat[i][n] = sumr; } for(int j=0; j<=n; j++){ int sumc = 0; for(int i=0;  for(int i=0;  } } }"], "original_ll": -0.469662606716156, "sampled_ll": -0.2247239500284195, "all_perturbed_sampled_ll": [-1.059361457824707], "all_perturbed_original_ll": [-1.7186458110809326], "perturbed_sampled_ll": -1.059361457824707, "perturbed_original_ll": -1.7186458110809326, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import functools\n\nn = input()\nwhile(n):\n    list = []\n    bottom_record = [0]*(n+1)\n\n    for i in range(0, n):\n        l = map(int, raw_input().split())\n        l.append(functools.reduce(lambda x, y: x + y, l))\n        bottom_record = [x + y for(x,y) in zip(bottom_record, l)]\n        print(' '.join(map(str, l))) \n    print(' '.join(map(str, bottom_record)))\n    n = input()", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    table = []\n    for i in range(n):\n        row = list(map(int, input().split()))\n        table.append(row)\n    \n    # Calculate row sums\n    row_sums = []\n    for row in table:\n        row_sums.append(sum(row))\n    \n    # Calculate column sums\n    col_sums = []\n    for j in range(n):\n        col_sum = sum(table[i][j] for i in range(n))\n        col_sums.append(col_sum)\n    \n    # Calculate total sum\n    total_sum = sum(row_sums)\n    \n    # Print the table with sums\n    for i in range(n):\n        for j in range(n):\n            print(f\"{table[i][j]:5d}\", end=\"\")\n        print(f\"{row_sums[i]:5d}\")\n    \n    # Print column sums row\n    for col_sum in col_sums:\n        print(f\"{col_sum:5d}\", end=\"\")\n    print(f\"{total_sum:5d}\")\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break table = [] for i in range(n):  = [] for row in  j in range(n): col_sum = sum(table[i][j] for i in range(n)) col_sums.append(col_sum) # Calculate total  for  # Print column sums row for col_sum in col_sums: print(f\"{col_sum:5d}\", end=\"\") print(f\"{total_sum:5d}\")"], "perturbed_original": [" = [0]*(n+1) for i in range(0, n): l = map(int, raw_input().split()) l.append(functools.reduce(lambda x, y: x + y, l)) bottom_record =  print(' '.join(map(str, bottom_record))) n = input()"], "original_ll": -1.5767993927001953, "sampled_ll": -0.45776593685150146, "all_perturbed_sampled_ll": [-2.1079297065734863], "all_perturbed_original_ll": [-2.1518192291259766], "perturbed_sampled_ll": -2.1079297065734863, "perturbed_original_ll": -2.1518192291259766, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tint n;\n\tchar event[8];\n\tint out = 0;\n\tint base[3] = {0};\n\tint i;\n\tint score;\n\t\n\tscanf(\"%d\", &n);\n\t\t\t \n\twhile (n != 0){\n\t\tscore = 0;\n\t\tbase[0] = 0;\n\t\tbase[1] = 0;\n\t\tbase[2] = 0;\n\t\tout = 0;\n\t\twhile (out < 3){\n\t\t\tscanf(\"%s\", event);\n\t\t\tif (strcmp(event, \"HIT\") == 0){\n\t\t\t\tbase[0]++;\n\t\t\t\tfor (i = 0; i < 3; i++){\n\t\t\t\t\tif (base[i] > 1){\n\t\t\t\t\t\tif (i < 2){\n\t\t\t\t\t\t\tbase[i + 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tscore++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbase[i]--;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strcmp(event, \"HOMERUN\") == 0){\n\t\t\t\tfor (i = 0; i < 3; i++){\n\t\t\t\t\tif (base[i] == 1){\n\t\t\t\t\t\tscore++;\n\t\t\t\t\t\tbase[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tscore++;\n\t\t\t}\n\t\t\telse if (strcmp(event, \"OUT\") == 0){\n\t\t\t\tout++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", score);\n\t\tn--;\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int base[4] = {0}; // base[1], base[2], base[3] for first, second, third\n        int score = 0;\n        int outs = 0;\n        char event[10];\n        \n        while (outs < 3 && scanf(\"%s\", event) == 1) {\n            if (strcmp(event, \"HIT\") == 0) {\n                if (base[3]) {\n                    score++;\n                    base[3] = 0;\n                }\n                if (base[2]) {\n                    base[3] = 1;\n                    base[2] = 0;\n                }\n                if (base[1]) {\n                    base[2] = 1;\n                    base[1] = 0;\n                }\n                base[1] = 1;\n            } else if (strcmp(event, \"HOMERUN\") == 0) {\n                score++; // batter scores\n                if (base[1]) {\n                    score++;\n                    base[1] = 0;\n                }\n                if (base[2]) {\n                    score++;\n                    base[2] = 0;\n                }\n                if (base[3]) {\n                    score++;\n                    base[3] = 0;\n                }\n            } else if (strcmp(event, \"OUT\") == 0) {\n                outs++;\n            }\n        }\n        \n        printf(\"%d\\n\", score);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; scanf(\"%d\", &n); while (n--) { int base[4] = {0}; // base[1], base[2], base[3] for first, second, third int score = 0; int  scanf(\"%s\", event) == 1) { if (strcmp(event, \"HIT\") == 0) { if (base[3]) { score++; base[3]  = 0; } if (base[1])   // batter scores if (base[1]) { score++; base[1]  } if (base[3]) { score++; base[3] = 0;  } } printf(\"%d\\n\", score); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(void) { int n; char event[8]; int out = 0; int base[3]   0; base[2] = 0; out = 0; while (out < 3){ scanf(\"%s\", event); if (strcmp(event, \"HIT\") == 0){ base[0]++; for   { score++; } base[i]--; } } } else  < 3; i++){ if (base[i] == 1){ score++; base[i] = 0; } } score++; } else  n--; } return 0; }"], "original_ll": -0.755157470703125, "sampled_ll": -0.5978079438209534, "all_perturbed_sampled_ll": [-1.6110105514526367], "all_perturbed_original_ll": [-2.1152665615081787], "perturbed_sampled_ll": -1.6110105514526367, "perturbed_original_ll": -2.1152665615081787, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint field = 0;\n\t\tlong scoreCount = 0;\n\t\tint outCount = 0;\n\t\tint finishedGame = 0;\n\t\ttry {\n\t\t\tint gameNumber = br.read();\n\t\t\twhile (finishedGame < gameNumber) {\n\t\t\t\tswitch (br.readLine()) {\n\t\t\t\tcase \"HIT\":\n\t\t\t\t\tif(field==3) {\n\t\t\t\t\t\tscoreCount++;\n\t\t\t\t\t}\n\t\t\t\t\tfield++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"OUT\":\n\t\t\t\t\toutCount++;\n\t\t\t\t\tif (outCount == 3) {\n\t\t\t\t\t\tSystem.out.println(scoreCount);\n\t\t\t\t\t\tscoreCount = 0;\n\t\t\t\t\t\toutCount = 0;\n\t\t\t\t\t\tfield = 0;\n\t\t\t\t\t\tfinishedGame++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"HOMERUN\":\n\t\t\t\t\tscoreCount += 1 + field;\n\t\t\t\t\tfield = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            int score = 0;\n            int outs = 0;\n            boolean[] bases = new boolean[3]; // 0: first, 1: second, 2: third\n            \n            while (outs < 3) {\n                String event = sc.nextLine().trim();\n                \n                if (event.equals(\"HIT\")) {\n                    if (bases[2]) {\n                        score++;\n                        bases[2] = false;\n                    }\n                    if (bases[1]) {\n                        bases[2] = true;\n                        bases[1] = false;\n                    }\n                    if (bases[0]) {\n                        bases[1] = true;\n                    }\n                    bases[0] = true;\n                } else if (event.equals(\"HOMERUN\")) {\n                    score++; // for the batter\n                    for (int j = 0; j < 3; j++) {\n                        if (bases[j]) {\n                            score++;\n                            bases[j] = false;\n                        }\n                    }\n                } else if (event.equals(\"OUT\")) {\n                    outs++;\n                }\n            }\n            \n            System.out.println(score);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc  i = 0; i < n; i++) {  = new boolean[3]; // 0: first, 1: second,  sc.nextLine().trim(); if (event.equals(\"HIT\")) { if (bases[2]) { score++; bases[2] = false; } if (bases[1]) { bases[2] = true; bases[1]  bases[0] = true; } else if (event.equals(\"HOMERUN\")) { score++; //  3; j++) { if (bases[j]) { score++; bases[j] = false; } } } else  }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; import java.util.List; public class Main { public static void main(String[] args) { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int field = 0; long scoreCount = 0;  field++; break; case \"OUT\": outCount++;  = 0; field = 0; finishedGame++; } break; case \"HOMERUN\": scoreCount += 1  catch (IOException e) { e.printStackTrace(); } } }"], "original_ll": -0.7825534343719482, "sampled_ll": -0.5429587364196777, "all_perturbed_sampled_ll": [-1.9419207572937012], "all_perturbed_original_ll": [-1.848954677581787], "perturbed_sampled_ll": -1.9419207572937012, "perturbed_original_ll": -1.848954677581787, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def hit(bases):\n    got_point = False\n    if bases[2]:\n        got_point = True\n    bases[0], bases[1], bases[2] = 1, bases[0], bases[1]\n    if got_point:\n        return 1\n    else:\n        return 0\n\ndef homerun(bases):\n    num_runner = bases.count(1)\n    bases[0], bases[1], bases[2] = 0, 0, 0\n    return num_runner + 1\n\nfor i in range(int(raw_input())):\n    bases = [0, 0, 0]\n    out_count = 0\n    points = 0\n    while out_count != 3:\n        event = raw_input()\n        if event == \"HIT\":\n            points += hit(bases)\n        elif event == \"HOMERUN\":\n            points += homerun(bases)\n        else:\n            out_count += 1\n    print points", "sampled": "n = int(input())\nfor _ in range(n):\n    score = 0\n    bases = [False, False, False]  # 1st, 2nd, 3rd base\n    outs = 0\n    \n    while outs < 3:\n        event = input().strip()\n        \n        if event == \"HIT\":\n            # Score runners from 3rd base\n            if bases[2]:\n                score += 1\n            # Advance runners\n            bases[2] = bases[1]\n            bases[1] = bases[0]\n            bases[0] = True\n            \n        elif event == \"HOMERUN\":\n            # Count runners on base\n            runners_on_base = sum(bases)\n            # Score all runners plus batter\n            score += runners_on_base + 1\n            # Clear all bases\n            bases = [False, False, False]\n            \n        elif event == \"OUT\":\n            outs += 1\n    \n    print(score)\n", "perturbed_sampled": ["n = int(input()) for _ in range(n): score = 0 bases = [False, False, False] # 1st, 2nd, 3rd base outs = 0 while outs < 3: event  3rd base if bases[2]:   all runners plus batter score += runners_on_base + 1 # Clear all bases bases = [False, False, False] elif event == \"OUT\": outs += 1 print(score)"], "perturbed_original": ["def hit(bases): got_point = False if bases[2]: got_point = True bases[0], bases[1], bases[2] = 1, bases[0], bases[1] if got_point: return 1 else: return  in range(int(raw_input())): bases = [0, 0, 0] out_count = 0 points =  points += homerun(bases) else: out_count += 1 print points"], "original_ll": -0.8319832682609558, "sampled_ll": -1.0202232599258423, "all_perturbed_sampled_ll": [-2.467710494995117], "all_perturbed_original_ll": [-1.919431447982788], "perturbed_sampled_ll": -2.467710494995117, "perturbed_original_ll": -1.919431447982788, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "C[51],c;\n#define min(a,b) ((a)<(b)?(a):(b))\nmain(i){\n\tC[1]=380;\n\tfor(i=2;i<=50;i++){\n\t\tc=9999;\n\t\tif(i>=2)c=min(c,C[i-2]+380);\n\t\tif(i>=3)c=min(c,C[i-3]+550);\n\t\tif(i>=5)c=min(c,C[i-5]+850);\n\t\tif(i>=10)c=min(c,C[i-10]+1520);\n\t\tif(i>=12)c=min(c,C[i-12]+1870);\n\t\tif(i>=15)c=min(c,C[i-15]+2244);\n\t\tC[i]=c;\n\t}\n\tfor(;~scanf(\"%d\",&i);)\n\t\ti&&printf(\"%d\\n\",C[(i+99)/100]);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a;\n    \n    while(scanf(\"%d\", &a) == 1 && a != 0) {\n        int minCost = -1;\n        \n        // Shop A: 200g bags, 380 yen, per 5 bags 20% discount\n        if(a % 200 == 0) {\n            int bags = a / 200;\n            int discountedBags = (bags / 5) * 5;\n            int normalBags = bags % 5;\n            int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380;\n            if(minCost == -1 || cost < minCost) {\n                minCost = cost;\n            }\n        }\n        \n        // Shop B: 300g bags, 550 yen, per 4 bags 15% discount\n        if(a % 300 == 0) {\n            int bags = a / 300;\n            int discountedBags = (bags / 4) * 4;\n            int normalBags = bags % 4;\n            int cost = (int)(discountedBags * 550 * 0.85) + normalBags * 550;\n            if(minCost == -1 || cost < minCost) {\n                minCost = cost;\n            }\n        }\n        \n        // Shop C: 500g bags, 850 yen, per 3 bags 12% discount\n        if(a % 500 == 0) {\n            int bags = a / 500;\n            int discountedBags = (bags / 3) * 3;\n            int normalBags = bags % 3;\n            int cost = (int)(discountedBags * 850 * 0.88) + normalBags * 850;\n            if(minCost == -1 || cost < minCost) {\n                minCost = cost;\n            }\n        }\n        \n        printf(\"%d\\n\", minCost);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  a != 0) { int minCost = -1; // Shop A: 200g bags, 380  0) { int bags = a / 200; int discountedBags  % 5; int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380; if(minCost == -1 || cost < minCost) { minCost = cost;  4 bags 15% discount if(a % 300 == 0) { int bags = a / 300; int discountedBags = (bags / 4) * 4; int normalBags  * 0.85) +  { minCost = cost; } } //  discount if(a % 500 == 0) { int bags = a / 500; int discountedBags = (bags /  * 850; if(minCost == -1 || cost  } return 0; }"], "perturbed_original": ["C[51],c; #define min(a,b) ((a)<(b)?(a):(b)) main(i){ C[1]=380; for(i=2;i<=50;i++){ c=9999; if(i>=2)c=min(c,C[i-2]+380); if(i>=3)c=min(c,C[i-3]+550); if(i>=5)c=min(c,C[i-5]+850); if(i>=10)c=min(c,C[i-10]+1520); if(i>=12)c=min(c,C[i-12]+1870); if(i>=15)c=min(c,C[i-15]+2244); C[i]=c; } for(;~scanf(\"%d\",&i);) i&&printf(\"%d\\n\",C[(i+99)/100]); }"], "original_ll": -1.167251706123352, "sampled_ll": -0.45538875460624695, "all_perturbed_sampled_ll": [-1.86762273311615], "all_perturbed_original_ll": [-1.2105352878570557], "perturbed_sampled_ll": -1.86762273311615, "perturbed_original_ll": -1.2105352878570557, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(true){ \n\t\t\tif(n == 0)break;\n\t\t\tSystem.out.println(min(n));\n\t\t\tn = sc.nextInt();\n\t\t}   \n\t}   \n\tstatic int min(int n){\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int c = n/500 ; c >= 0 ; c--){\n\t\t\tfor(int b = (n-c*500)/300 ; b >= 0 ; b--){\n\t\t\t\tif((n-c*500-b*300)%200 == 0){ \n\t\t\t\t\tint a = (n-c*500-b*300)/200;\n\t\t\t\t\tint cost = cost(a, b, c); \n\t\t\t\t\tif(cost < min){\n\t\t\t\t\t\tmin = cost;\n\t\t\t\t\t}   \n\t\t\t\t}   \n\t\t\t}   \n\t\t}   \n\t\treturn min;\n\t}   \n\tstatic int cost(int a, int b, int c){\n\t\treturn (a%5)*380+(a/5)*5*380*8/10+(b%4)*550+(b/4)*4*550*85/100+(c%3)*850+(c/3)*3*850*88/100;\n\t}   \n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int a = sc.nextInt();\n            if (a == 0) break;\n            \n            int minCost = Integer.MAX_VALUE;\n            \n            // Shop A: 200g per bag, 380 yen, 5 bags discount 20%\n            if (a % 200 == 0) {\n                int bags = a / 200;\n                int discountedBags = (bags / 5) * 5;\n                int normalBags = bags % 5;\n                int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380;\n                minCost = Math.min(minCost, cost);\n            }\n            \n            // Shop B: 300g per bag, 550 yen, 4 bags discount 15%\n            if (a % 300 == 0) {\n                int bags = a / 300;\n                int discountedBags = (bags / 4) * 4;\n                int normalBags = bags % 4;\n                int cost = (int)(discountedBags * 550 * 0.85) + normalBags * 550;\n                minCost = Math.min(minCost, cost);\n            }\n            \n            // Shop C: 500g per bag, 850 yen, 3 bags discount 12%\n            if (a % 500 == 0) {\n                int bags = a / 500;\n                int discountedBags = (bags / 3) * 3;\n                int normalBags = bags % 3;\n                int cost = (int)(discountedBags * 850 * 0.88) + normalBags * 850;\n                minCost = Math.min(minCost, cost);\n            }\n            \n            System.out.println(minCost);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public <extra_id_4>cost<extra_id_5>// Shop A:<extra_id_6>* 100g<extra_id_7>1) while (true) { int a = sc.nextInt(); if (a == 0) break; int minCost = Integer.MAX_VALUE; // Shop (bags / 4)<extra_id_8>}<extra_id_9>//<extra_id_10>bags<extra_id_11>- 0.855g if (a % 200 == 0) { int bags = a / 200; int discountedBags = (bags / 5) %<extra_id_12>= (int)(discountedBags *<extra_id_13>0) = (int)(discountedBags * 380 * 0.8) + normalBags * 380; minCost = Math.min(minCost, cost); } // Shop B: 300g <extra_id_14>bags discount 12% if (a<extra_id_15>0) % 300 == 0) { int bags <extra_id_16>850 g<extra_id_17>1<extra_id_18>550 (b * 4; int normalBags = bags % 4; int cost = (int)(discountedBags * 550  3 bags discount 12% if (a % 500 == 0)  (bags / 3) *  (int)(discountedBags * 850 * 0.88) + normalBags *  }"], "perturbed_original": ["import java.util.*; class Main{ public static void main(String[] args){ Scanner sc  0)break; System.out.println(min(n)); n = sc.nextInt(); } } static int min(int n){ int min = Integer.MAX_VALUE; for(int c = n/500 ; c  = (n-c*500-b*300)/200; int cost = cost(a, b, c); if(cost < min){ min =  cost(int a, int b, int c){ return (a%5)*380+(a/5)*5*380*8/10+(b%4)*550+(b/4)*4*550*85/100+(c%3)*850+(c/3)*3*850*88/100; } }"], "original_ll": -0.8748154640197754, "sampled_ll": -0.4312281906604767, "all_perturbed_sampled_ll": [-2.057858467102051], "all_perturbed_original_ll": [-1.7155048847198486], "perturbed_sampled_ll": -2.057858467102051, "perturbed_original_ll": -1.7155048847198486, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a=[(2,380),(3,550),(5,850),(10,1520),(12,1870),(15,2244)]\ndp=[1<<20]*51\nfor i,j in a:\n    dp[i]=j\n    for k in range(51-i):\n        if dp[k]!=1<<20 and dp[k+i]>dp[k]+j:\n            dp[k+i]=dp[k]+j\nwhile 1:\n    n=int(input())\n    if n==0:break\n    print(dp[n//100])", "sampled": "def calculate_cost(amount, bag_size, unit_price, discount_unit, discount_rate):\n    if amount % bag_size != 0:\n        return float('inf')\n    \n    num_bags = amount // bag_size\n    discounted_bags = (num_bags // discount_unit) * discount_unit\n    regular_bags = num_bags % discount_unit\n    \n    discounted_cost = discounted_bags * unit_price * (1 - discount_rate)\n    regular_cost = regular_bags * unit_price\n    \n    return int(discounted_cost + regular_cost)\n\nwhile True:\n    a = int(input())\n    if a == 0:\n        break\n    \n    # Shop A: 200g, 380 yen, per 5 bags, 20% off\n    cost_a = calculate_cost(a, 200, 380, 5, 0.20)\n    \n    # Shop B: 300g, 550 yen, per 4 bags, 15% off\n    cost_b = calculate_cost(a, 300, 550, 4, 0.15)\n    \n    # Shop C: 500g, 850 yen, per 3 bags, 12% off\n    cost_c = calculate_cost(a, 500, 850, 3, 0.12)\n    \n    print(min(cost_a, cost_b, cost_c))\n", "perturbed_sampled": ["def calculate_cost(amount, bag_size, unit_price, discount_unit, discount_rate): if amount % bag_size != 0: return float('inf') num_bags = amount //  (1 - discount_rate) regular_cost = regular_bags * unit_price return int(discounted_cost + regular_cost) while True: a = int(input()) if a == 0: break # Shop A: 200g, 380 yen, per 5 bags, 20%  B: 300g, 550 yen, per 4 bags, 15% off cost_b = calculate_cost(a, 300, 550, 4, 0.15) #  cost_c))"], "perturbed_original": ["a=[(2,380),(3,550),(5,850),(10,1520),(12,1870),(15,2244)] dp=[1<<20]*51 for i,j in a: dp[i]=j  1: n=int(input()) if n==0:break print(dp[n//100])"], "original_ll": -1.3855406045913696, "sampled_ll": -0.7567736506462097, "all_perturbed_sampled_ll": [-2.1596338748931885], "all_perturbed_original_ll": [-2.27496600151062], "perturbed_sampled_ll": -2.1596338748931885, "perturbed_original_ll": -2.27496600151062, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  int i,n,t[3];\n  int data,kari,hakari;\n\n  while(1){\n    scanf(\"%d%d%d\",&t[0],&t[1],&t[2]);\n    if(t[0] == 0 || t[1] == 0 || t[2] == 0)\n      break;\n    scanf(\"%d\",&n);\n    if(t[0] >= t[2]){\n      t[0] = t[2];\n       t[2] = -1;\n      }\n    if(t[1] >= t[2]&&t[2] != -1)\n      t[1] = t[2];\n    hakari = t[0] * t[0] + t[1] *t[1];\n    for(i = 0; i < n; i++){\n      scanf(\"%d\",&data);\n      data = data * 2;\n      data = data * data;\n      if(hakari < data)\n\tprintf(\"OK\\n\");\n      else \n\tprintf(\"NA\\n\");\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int A, B, C;\n    \n    while(1) {\n        scanf(\"%d %d %d\", &A, &B, &C);\n        \n        if(A == 0 && B == 0 && C == 0) break;\n        \n        int n;\n        scanf(\"%d\", &n);\n        \n        // Calculate the minimum diagonal of any face\n        // The cheese can pass through a circular hole if the diagonal of the smallest rectangular face\n        // can fit through the circle\n        double diag1 = sqrt(A * A + B * B);\n        double diag2 = sqrt(B * B + C * C);\n        double diag3 = sqrt(A * A + C * C);\n        \n        double min_diag = diag1;\n        if(diag2 < min_diag) min_diag = diag2;\n        if(diag3 < min_diag) min_diag = diag3;\n        \n        for(int i = 0; i < n; i++) {\n            int R;\n            scanf(\"%d\", &R);\n            \n            // The cheese can pass if the diameter of the hole is greater than the minimum diagonal\n            if(2 * R > min_diag) {\n                printf(\"OK\\n\");\n            } else {\n                printf(\"NA\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  scanf(\"%d %d %d\", &A, &B, &C); if(A  break; int n; scanf(\"%d\", &n); //  can pass through a circular hole if the diagonal of the smallest rectangular face // can fit through the circle double diag1 = sqrt(A * A + B * B); double diag2 = sqrt(B * B + C * C); double diag3 = sqrt(A *  = diag3; for(int i = 0; i < n; i++) {  the diameter of the hole is greater  printf(\"OK\\n\"); } else { printf(\"NA\\n\"); } } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int i,n,t[3]; int data,kari,hakari; while(1){ scanf(\"%d%d%d\",&t[0],&t[1],&t[2]); if(t[0] == 0 || t[1] == 0 || t[2] == 0) break;  } if(t[1] >= t[2]&&t[2] != -1) t[1] = t[2]; hakari = t[0]  n; i++){ scanf(\"%d\",&data); data = data * 2; data =  } return 0; }"], "original_ll": -1.146381139755249, "sampled_ll": -0.7895799279212952, "all_perturbed_sampled_ll": [-2.0731492042541504], "all_perturbed_original_ll": [-1.921256422996521], "perturbed_sampled_ll": -2.0731492042541504, "perturbed_original_ll": -1.921256422996521, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nimport java.util.Arrays;\n\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true)\n\t\t{\n\t\t\tint a[] = new int[3];\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\tif (a[0] == 0 && a[1] == 0 && a[2] == 0) break;\n\t\t\t\n\t\t\t//Arrays.sort(a);\n\t\t\tint minR = a[0] * a[0] + a[2] + a[2];\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tint r = sc.nextInt() * 2;\n\t\t\t\tif (minR < r * r) System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int A = sc.nextInt();\n            int B = sc.nextInt();\n            int C = sc.nextInt();\n            \n            if (A == 0 && B == 0 && C == 0) {\n                break;\n            }\n            \n            // Find the minimum diagonal among all three faces\n            // The cheese can pass through if oriented diagonally through a face\n            double diag1 = Math.sqrt(A * A + B * B);\n            double diag2 = Math.sqrt(B * B + C * C);\n            double diag3 = Math.sqrt(A * A + C * C);\n            \n            double minDiag = Math.min(diag1, Math.min(diag2, diag3));\n            \n            int n = sc.nextInt();\n            \n            for (int i = 0; i < n; i++) {\n                int R = sc.nextInt();\n                \n                if (2 * R > minDiag) {\n                    System.out.println(\"OK\");\n                } else {\n                    System.out.println(\"NA\");\n                }\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) {   C == 0) { break; } // Find  double diag1 = Math.sqrt(A * A + B * B); double diag2 = Math.sqrt(B * B + C * C); double diag3 = Math.sqrt(A * A + C * C); double minDiag = Math.min(diag1, Math.min(diag2, diag3)); int n = sc.nextInt(); for (int i = 0; i < n;  } } sc.close(); } }"], "perturbed_original": ["import  = 0; i < 3; i++)  0 && a[2] == 0) break; //Arrays.sort(a); int minR = a[0] * a[0] + a[2] + a[2]; int n = sc.nextInt(); for (int i = 0; i < n; i++) { int r = sc.nextInt() * 2; if (minR < r * r) System.out.println(\"OK\"); else System.out.println(\"NA\"); } } } }"], "original_ll": -0.793997585773468, "sampled_ll": -0.8123894333839417, "all_perturbed_sampled_ll": [-1.5536612272262573], "all_perturbed_original_ll": [-1.9114876985549927], "perturbed_sampled_ll": -1.5536612272262573, "perturbed_original_ll": -1.9114876985549927, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n a,b,_=sorted(map(int,input().split()))\n if a==0:break\n for _ in[0]*int(input()):print(\"OK\"if(int(input())*2)**2>a*a+b*b else\"NA\")\n", "sampled": "import math\n\nwhile True:\n    line = input().split()\n    A, B, C = int(line[0]), int(line[1]), int(line[2])\n    \n    if A == 0 and B == 0 and C == 0:\n        break\n    \n    # The smallest diagonal that can fit through a circle of radius R\n    # is when we orient the cheese optimally through the hole.\n    # The cheese can pass through if the smallest cross-sectional diagonal\n    # fits in the circle of radius R.\n    \n    # For a parallelepiped with dimensions A, B, C, the smallest\n    # cross-sectional diagonal occurs when we look at the rectangular\n    # faces. The diagonals of the three faces are:\n    # sqrt(A^2 + B^2), sqrt(B^2 + C^2), sqrt(A^2 + C^2)\n    \n    # The smallest of these is what we need to fit through the hole\n    # (divided by 2 for radius)\n    \n    sides = [A, B, C]\n    sides.sort()\n    \n    # The minimum diagonal is between the two smallest sides\n    min_diagonal = math.sqrt(sides[0]**2 + sides[1]**2)\n    min_radius_needed = min_diagonal / 2\n    \n    n = int(input())\n    \n    for _ in range(n):\n        R = int(input())\n        if R > min_radius_needed:\n            print(\"OK\")\n        else:\n            print(\"NA\")\n", "perturbed_sampled": ["import math while True: line = input().split() A, B, C = int(line[0]), int(line[1]), int(line[2]) if A  break # The smallest diagonal that can fit through a circle of radius R # is when we orient    occurs when we look at the rectangular # faces. The  sqrt(B^2 + C^2), sqrt(A^2 + C^2) # The smallest of these  (divided by 2 for radius) sides = [A, B, C] sides.sort() # The minimum diagonal is between the two smallest  2 n = int(input()) for _ in range(n): R = int(input()) if R > min_radius_needed: print(\"OK\") else: print(\"NA\")"], "perturbed_original": ["while 1: a,b,_=sorted(map(int,input().split())) if a==0:break for _ in[0]*int(input()):print(\"OK\"if(int(input())*2)**2>a*a+b*b else\"NA\")"], "original_ll": -2.487917423248291, "sampled_ll": -1.2673985958099365, "all_perturbed_sampled_ll": [-2.6206300258636475], "all_perturbed_original_ll": [-2.409452199935913], "perturbed_sampled_ll": -2.6206300258636475, "perturbed_original_ll": -2.409452199935913, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint expr(char **s);\n\nint number(char **s) {\n  int val = 0;\n  while ('0' <= **s && **s <= '9') {\n    val = val * 10 + **s - '0';\n    (*s)++;\n  }\n  return val;\n}\n\nint factor(char **s) {\n  if (**s == '(') {\n    (*s)++;\n    int val = expr(s);\n    (*s)++;\n    return val;\n  }\n  return number(s);\n}\n\nint term(char **s) {\n  int val = factor(s);\n  while (1) {\n    if (**s == '*') {\n      (*s)++;\n      val *= factor(s);\n    } else if (**s == '/') {\n      (*s)++;\n      val /= factor(s);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint expr(char **s) {\n  int val = term(s);\n  while (1) {\n    if (**s == '+') {\n      (*s)++;\n      val += term(s);\n    } else if (**s == '-') {\n      (*s)++;\n      val -= term(s);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  char s[101];\n  while (n--) {\n    scanf(\"%s\", s);\n    char *p = s;\n    printf(\"%d\\n\", expr(&p));\n  }\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar expr[105];\nint pos;\n\nlong long parse_expr();\nlong long parse_term();\nlong long parse_factor();\n\nlong long parse_number() {\n    long long num = 0;\n    int sign = 1;\n    \n    if (expr[pos] == '-') {\n        sign = -1;\n        pos++;\n    } else if (expr[pos] == '+') {\n        pos++;\n    }\n    \n    while (isdigit(expr[pos])) {\n        num = num * 10 + (expr[pos] - '0');\n        pos++;\n    }\n    \n    return sign * num;\n}\n\nlong long parse_factor() {\n    if (expr[pos] == '(') {\n        pos++; // skip '('\n        long long result = parse_expr();\n        pos++; // skip ')'\n        return result;\n    } else {\n        return parse_number();\n    }\n}\n\nlong long parse_term() {\n    long long result = parse_factor();\n    \n    while (expr[pos] == '*' || expr[pos] == '/') {\n        char op = expr[pos];\n        pos++;\n        long long right = parse_factor();\n        if (op == '*') {\n            result = result * right;\n        } else {\n            result = result / right;\n        }\n    }\n    \n    return result;\n}\n\nlong long parse_expr() {\n    long long result = parse_term();\n    \n    while (expr[pos] == '+' || expr[pos] == '-') {\n        char op = expr[pos];\n        pos++;\n        long long right = parse_term();\n        if (op == '+') {\n            result = result + right;\n        } else {\n            result = result - right;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    getchar();\n    \n    while (n--) {\n        fgets(expr, 105, stdin);\n        pos = 0;\n        long long result = parse_expr();\n        printf(\"%lld\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h>  long parse_term(); long long parse_factor(); long long parse_number() { long long num = 0; int sign = 1; if (expr[pos] == '-') { sign = -1; pos++; } else if (expr[pos] == '+') { pos++;  (expr[pos] - '0'); pos++; } return sign * num; } long long parse_factor() { if (expr[pos] == '(') { pos++; // skip '(' long long result = parse_expr(); pos++; // skip ')' return result; } else {  result = parse_factor(); while (expr[pos] == '*' || expr[pos] == '/') { char op = expr[pos]; pos++; long long right = parse_factor(); if  else { result = result / right; } } return result; } long  == '+' ||  =  { int n; scanf(\"%d\", &n); getchar();  }"], "perturbed_original": ["#include  = 0; while ('0' <= **s && **s <= '9') { val = val * 10 + **s - '0'; (*s)++; } return val; } int factor(char **s)  expr(s); (*s)++; return  val = factor(s); while (1)  } else if (**s == '/')  val = term(s); while (1) { if (**s == '+') { (*s)++; val += term(s); } else if (**s == '-') { (*s)++; val -= term(s); } else { break; } } return val; } int main()  scanf(\"%s\", s); char *p = s; printf(\"%d\\n\", expr(&p)); } }"], "original_ll": -0.36428573727607727, "sampled_ll": -0.29802146553993225, "all_perturbed_sampled_ll": [-1.5868489742279053], "all_perturbed_original_ll": [-1.397450566291809], "perturbed_sampled_ll": -1.5868489742279053, "perturbed_original_ll": -1.397450566291809, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic String str;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstr = sc.next();\n\t\t\tpos = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic int expression() {\n\t\tint ret = term();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '+') {\n\t\t\t\tpos++;\n\t\t\t\tret += term();\n\t\t\t} else if (str.charAt(pos) == '-') {\n\t\t\t\tpos++;\n\t\t\t\tret -= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int term() {\n\t\tint ret = factor();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '*') {\n\t\t\t\tpos++;\n\t\t\t\tret *= factor();\n\t\t\t} else if (str.charAt(pos) == '/') {\n\t\t\t\tpos++;\n\t\t\t\tret /= factor();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int factor() {\n\t\tif (str.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\tint temp = expression();\n\t\t\tpos++;\n\t\t\treturn temp;\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\n\tstatic int number() {\n\t\tint ret = 0;\n\t\twhile (Character.isDigit(str.charAt(pos))) {\n\t\t\tret *= 10;\n\t\t\tret += str.charAt(pos) - '0';\n\t\t\tpos++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static String expr;\n    static int pos;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            expr = sc.nextLine().trim();\n            pos = 0;\n            System.out.println(parseExpression());\n        }\n        sc.close();\n    }\n    \n    static long parseExpression() {\n        long result = parseTerm();\n        \n        while (pos < expr.length() && (expr.charAt(pos) == '+' || expr.charAt(pos) == '-')) {\n            char op = expr.charAt(pos);\n            pos++;\n            long term = parseTerm();\n            if (op == '+') {\n                result += term;\n            } else {\n                result -= term;\n            }\n        }\n        \n        return result;\n    }\n    \n    static long parseTerm() {\n        long result = parseFactor();\n        \n        while (pos < expr.length() && (expr.charAt(pos) == '*' || expr.charAt(pos) == '/')) {\n            char op = expr.charAt(pos);\n            pos++;\n            long factor = parseFactor();\n            if (op == '*') {\n                result *= factor;\n            } else {\n                result /= factor;\n            }\n        }\n        \n        return result;\n    }\n    \n    static long parseFactor() {\n        if (expr.charAt(pos) == '(') {\n            pos++;\n            long result = parseExpression();\n            pos++;\n            return result;\n        }\n        \n        boolean negative = false;\n        if (expr.charAt(pos) == '-') {\n            negative = true;\n            pos++;\n        } else if (expr.charAt(pos) == '+') {\n            pos++;\n        }\n        \n        long num = 0;\n        while (pos < expr.length() && Character.isDigit(expr.charAt(pos))) {\n            num = num * 10 + (expr.charAt(pos) - '0');\n            pos++;\n        }\n        \n        return negative ? -num : num;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  void main(String[] args) { Scanner sc = new Scanner(System.in); int  < n; i++) { expr =  expr.length() &&  = expr.charAt(pos); pos++; long term = parseTerm(); if  result -= term; } } return result; } static long parseTerm() { long result = parseFactor(); while (pos < expr.length() && (expr.charAt(pos) == '*' || expr.charAt(pos) == '/')) { char op = expr.charAt(pos); pos++; long factor = parseFactor(); if (op == '*') { result *= factor; } else { result /= factor;  (expr.charAt(pos) == '(') {  negative = false; if (expr.charAt(pos) == '-') { negative = true; pos++; } else if (expr.charAt(pos) == '+') { pos++; } long num =  num * 10  : num; } }"], "perturbed_original": ["import java.util.Scanner; public class Main  < n; i++) { str = sc.next(); pos = 0; System.out.println(expression()); } sc.close(); } static int expression() { int ret = term(); while   } return ret; } static int term() { int ret = factor(); while (str.charAt(pos) != '=') { if (str.charAt(pos) ==  == '/') { pos++; ret /= factor(); } else { break; } } return ret; } static  temp  } } static int number() { int ret = 0; while (Character.isDigit(str.charAt(pos))) { ret *= 10; ret += str.charAt(pos) - '0'; pos++; } return ret; } }"], "original_ll": -0.3343924283981323, "sampled_ll": -0.2706734538078308, "all_perturbed_sampled_ll": [-1.6322602033615112], "all_perturbed_original_ll": [-1.7002530097961426], "perturbed_sampled_ll": -1.6322602033615112, "perturbed_original_ll": -1.7002530097961426, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    rpn = \"\"\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            r = b/a\n            if b < 0 and b % a != 0:\n                r += 1\n            St.append(r)\n        else:\n            St.append(i)\n\n    return St[0]\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n    print int(RPN_cul(L))", "sampled": "def evaluate(expr):\n    expr = expr.strip().rstrip('=')\n    \n    def parse_number(s, i):\n        j = i\n        if j < len(s) and s[j] in '+-':\n            j += 1\n        while j < len(s) and s[j].isdigit():\n            j += 1\n        return int(s[i:j]), j\n    \n    def parse_factor(s, i):\n        if s[i] == '(':\n            val, j = parse_expr(s, i + 1)\n            return val, j + 1\n        else:\n            return parse_number(s, i)\n    \n    def parse_term(s, i):\n        left, i = parse_factor(s, i)\n        while i < len(s) and s[i] in '*/':\n            op = s[i]\n            right, i = parse_factor(s, i + 1)\n            if op == '*':\n                left = left * right\n            else:\n                left = int(left / right)\n        return left, i\n    \n    def parse_expr(s, i):\n        left, i = parse_term(s, i)\n        while i < len(s) and s[i] in '+-' and (i == 0 or s[i-1] not in '(+*-/'):\n            op = s[i]\n            right, i = parse_term(s, i + 1)\n            if op == '+':\n                left = left + right\n            else:\n                left = left - right\n        return left, i\n    \n    result, _ = parse_expr(expr, 0)\n    return result\n\nn = int(input())\nfor _ in range(n):\n    expr = input()\n    print(evaluate(expr))\n", "perturbed_sampled": ["def evaluate(expr): expr = expr.strip().rstrip('=') def parse_number(s, i): j = i if j < len(s) and s[j] in '+-': j += 1 while j < len(s) and s[j].isdigit(): j += 1 return int(s[i:j]), j def parse_factor(s, i): if s[i] == '(': val, j = parse_expr(s, i + 1) return val, j + 1 else: return parse_number(s, ' ') left<extra_id_8>+= 1<extra_id_9>* 2: i =<extra_id_10>'/' i =<extra_id_11>( i<extra_id_12>= parse_term(s, i)<extra_id_13>return left<extra_id_14>i<extra_id_15>.isdigit(): j +=<extra_id_16>elif<extra_id_17>expr_val =<extra_id_18>= 1 else:<extra_id_19>1 left<extra_id_20>=<extra_id_10>'+': op i < len(s) and s[i] in '*/': op = s[i] right, i =  left * right else: left =  i = parse_term(s, i)  ==  '+': left = left + right else:  _ in range(n): expr = input() print(evaluate(expr))"], "perturbed_original": ["def String2List(s): L = [] flag = True  flag: t = \"\" j =  break j += 1 L.append(t) flag = False elif not s[i].isdigit(): L.append(s[i]) flag = True return L def RPN_list(L): S, L2 = [], [] table  -1, \")\": -1} rpn = \"\" for i in L: if i.isdigit(): L2.append(i) elif i == \"(\": S.append(i) elif i == \")\": while S[-1] != \"(\": L2.append(S.pop()) S.pop() else: if len(S) != 0 and (table[S[-1]]  L2 def RPN_cul(L): St = [] for i in L: if i == '+': St.append(int(St.pop()) +  if b < 0 and b  s = raw_input() L = String2List(s[:-1]) L = RPN_list(L) print int(RPN_cul(L))"], "original_ll": -0.6815605759620667, "sampled_ll": -0.44928792119026184, "all_perturbed_sampled_ll": [-1.951513409614563], "all_perturbed_original_ll": [-1.9882320165634155], "perturbed_sampled_ll": -1.951513409614563, "perturbed_original_ll": -1.9882320165634155, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define DIGIT (pow(10, (strlen(num) - 1 -j)))\n\nint solved(char num[100], int i){\n  int s = 0, j;\n  for(j = 0;j < strlen(num);j++){\n    if(num[j] == 'X')\n      s += i * DIGIT;\n    else \n      s += (num[j] - '0') * DIGIT;\n  }\n  return s;\n}\n\nint main(){\n  int a, b, c, i, j;\n  char calc[100], *f, *s, *ans;\n  while(scanf(\"%s\", calc) != EOF){\n    f = strtok(calc, \"+\");\n    s = strtok(NULL, \"=\");\n    ans = strtok(NULL, \",\");\n    \n    for(i = 0;i < 10;i++)\n      if(solved(f, i) + solved(s, i) == solved(ans, i)){\n\tprintf(\"%d\\n\", i);\n\tbreak;\n      }\n    if(i > 9)\n      puts(\"NA\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint hasLeadingZero(char *str) {\n    if (strlen(str) > 1 && str[0] == '0') {\n        return 1;\n    }\n    return 0;\n}\n\nint checkEquation(char *left1, char *left2, char *right) {\n    if (hasLeadingZero(left1) || hasLeadingZero(left2) || hasLeadingZero(right)) {\n        return 0;\n    }\n    \n    long long num1 = atoll(left1);\n    long long num2 = atoll(left2);\n    long long sum = atoll(right);\n    \n    return (num1 + num2 == sum);\n}\n\nvoid replaceX(char *str, char digit, char *result) {\n    int i;\n    for (i = 0; str[i]; i++) {\n        if (str[i] == 'X') {\n            result[i] = digit;\n        } else {\n            result[i] = str[i];\n        }\n    }\n    result[i] = '\\0';\n}\n\nint main() {\n    char input[256];\n    \n    while (fgets(input, sizeof(input), stdin)) {\n        input[strcspn(input, \"\\n\")] = 0;\n        \n        char *plus = strchr(input, '+');\n        char *equal = strchr(input, '=');\n        \n        if (!plus || !equal) continue;\n        \n        char left1[128], left2[128], right[128];\n        \n        int len1 = plus - input;\n        int len2 = equal - plus - 1;\n        int len3 = strlen(equal + 1);\n        \n        strncpy(left1, input, len1);\n        left1[len1] = '\\0';\n        \n        strncpy(left2, plus + 1, len2);\n        left2[len2] = '\\0';\n        \n        strcpy(right, equal + 1);\n        \n        int found = -1;\n        int count = 0;\n        \n        for (int digit = 0; digit <= 9; digit++) {\n            char temp1[128], temp2[128], temp3[128];\n            char digitChar = '0' + digit;\n            \n            replaceX(left1, digitChar, temp1);\n            replaceX(left2, digitChar, temp2);\n            replaceX(right, digitChar, temp3);\n            \n            if (checkEquation(temp1, temp2, temp3)) {\n                found = digit;\n                count++;\n            }\n        }\n        \n        if (count == 1) {\n            printf(\"%d\\n\", found);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int hasLeadingZero(char *str) { if (strlen(str) > 1 && str[0] == '0') { return 1; } return 0; } int checkEquation(char *left1, char *left2, char *right) { if (hasLeadingZero(left1) || hasLeadingZero(left2)  = atoll(right); return (num1 + num2 == sum); } void replaceX(char *str, char digit, char  { if (str[i] == 'X')  char input[256];  *plus = strchr(input, '+'); char *equal = strchr(input, '='); if (!plus || !equal) continue; char left1[128], left2[128], right[128]; int len1  - 1; int len3 = strlen(equal + 1); strncpy(left1, input, len1); left1[len1] = '\\0'; strncpy(left2, plus +  digit = 0; digit <= 9; digit++) { char temp1[128], temp2[128], temp3[128]; char digitChar = '0'  temp3); if (checkEquation(temp1, temp2, temp3)) { found = digit; count++; } } if  } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <math.h>   } return s; } int main(){ int a, b, c, i,  f = strtok(calc, \"+\"); s = strtok(NULL, \"=\"); ans = strtok(NULL, \",\"); for(i = 0;i < 10;i++) if(solved(f, i) + solved(s, i) == solved(ans, i)){ printf(\"%d\\n\", i); break; } if(i > 9) puts(\"NA\"); } return 0; }"], "original_ll": -1.0497684478759766, "sampled_ll": -0.4702918529510498, "all_perturbed_sampled_ll": [-1.5472185611724854], "all_perturbed_original_ll": [-2.0798022747039795], "perturbed_sampled_ll": -1.5472185611724854, "perturbed_original_ll": -2.0798022747039795, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n    Scanner in = new Scanner(System.in);\n\n    void solve(){\n        String s;\n        while(in.hasNextLine()){\n            s = in.nextLine();\n            calc(s);\n        }\n    }\n    void calc(String str){\n        String a = str.substring(0, str.indexOf('+'));\n        String b = str.substring(str.indexOf('+') + 1, str.indexOf('='));\n        String c = str.substring(str.indexOf('=') + 1);\n        for(int i = 0; i < 10; i++){\n            String left = sum(a, b, i);\n            String right = c.replace(\"X\", String.valueOf(i));\n            if(left.equals(right)){\n                System.out.println(i);\n                return;\n            }\n        }\n        System.out.println(\"NA\");\n    }\n\n    String sum(String a, String b, int rep){\n        StringBuilder ans  = new StringBuilder();\n        a = new StringBuilder(a.replace(\"X\", String.valueOf(rep))).reverse().toString();\n        b = new StringBuilder(b.replace(\"X\", String.valueOf(rep))).reverse().toString();\n\n        int t = 0;\n        for(int i = 0; i < Math.max(a.length(), b.length()); i++){\n            int x = i < a.length() ? a.charAt(i) - '0' : 0;\n            int y = i < b.length() ? b.charAt(i) - '0' : 0;\n            ans.append(String.valueOf((x + y + t) % 10));\n            t = (x + y + t) / 10;\n        }\n\n        if(t != 0){\n            ans.append(String.valueOf(t));\n        }\n\n        return ans.reverse().toString();\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();    \n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String result = solve(line);\n            System.out.println(result);\n        }\n        sc.close();\n    }\n    \n    static String solve(String equation) {\n        String[] parts = equation.split(\"=\");\n        String leftSide = parts[0];\n        String rightSide = parts[1];\n        \n        String[] addends = leftSide.split(\"\\\\+\");\n        String num1Pattern = addends[0];\n        String num2Pattern = addends[1];\n        String sumPattern = rightSide;\n        \n        int validDigit = -1;\n        int validCount = 0;\n        \n        for (int x = 0; x <= 9; x++) {\n            String num1Str = num1Pattern.replace('X', (char)('0' + x));\n            String num2Str = num2Pattern.replace('X', (char)('0' + x));\n            String sumStr = sumPattern.replace('X', (char)('0' + x));\n            \n            // Check for leading zeros\n            if (num1Str.length() > 1 && num1Str.charAt(0) == '0') continue;\n            if (num2Str.length() > 1 && num2Str.charAt(0) == '0') continue;\n            if (sumStr.length() > 1 && sumStr.charAt(0) == '0') continue;\n            \n            try {\n                long num1 = Long.parseLong(num1Str);\n                long num2 = Long.parseLong(num2Str);\n                long sum = Long.parseLong(sumStr);\n                \n                if (num1 + num2 == sum) {\n                    validDigit = x;\n                    validCount++;\n                }\n            } catch (NumberFormatException e) {\n                // Skip invalid numbers\n            }\n        }\n        \n        if (validCount == 1) {\n            return String.valueOf(validDigit);\n        } else {\n            return \"NA\";\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[]  String line = sc.nextLine().trim(); if (line.isEmpty()) break; String  String num1Pattern = addends[0]; String num2Pattern = addends[1]; String sumPattern = rightSide; int   num1Pattern.replace('X', (char)('0' + x)); String num2Str = num2Pattern.replace('X', (char)('0'  Check for leading zeros if  > 1 && num2Str.charAt(0) == '0') continue; if (sumStr.length() > 1 && sumStr.charAt(0) == '0') continue;  long sum = Long.parseLong(sumStr); if (num1 + num2 == sum) { validDigit = x; validCount++; } } catch (NumberFormatException e) { // Skip invalid numbers } } if (validCount == 1) { return String.valueOf(validDigit); } else { return \"NA\"; } } }"], "perturbed_original": ["import java.util.*;  String s; while(in.hasNextLine()){ s = in.nextLine(); calc(s); } } void calc(String str){ String a = str.substring(0,  = str.substring(str.indexOf('=') + 1); for(int i = 0; i < 10; i++){ String left = sum(a, b, i); String right = c.replace(\"X\",  a, String b, int rep){ StringBuilder ans = new StringBuilder();  a.length() ? a.charAt(i) -  b.charAt(i) - '0' : 0; ans.append(String.valueOf((x + y + t) % 10)); t = (x + y + t) /  public static void main(String[] args){ new Main().solve(); } }"], "original_ll": -0.599596381187439, "sampled_ll": -0.4750162661075592, "all_perturbed_sampled_ll": [-1.912190318107605], "all_perturbed_original_ll": [-2.0777454376220703], "perturbed_sampled_ll": -1.912190318107605, "perturbed_original_ll": -2.0777454376220703, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        string = raw_input()\n    except EOFError:\n        break\n    for i in range(10):\n        translated = string.replace(\"X\",str(i))\n        left,right = translated.split(\"=\")\n        first,second = left.split(\"+\")\n        if i == 0 and any((first[0]==\"0\",second[0]==\"0\",right[0]==\"0\")):\n            continue\n        elif int(first) + int(second) == int(right):\n            print i\n            break\n    else:\n        print \"NA\"", "sampled": "import sys\n\ndef solve(equation):\n    parts = equation.split('=')\n    left_parts = parts[0].split('+')\n    num1 = left_parts[0]\n    num2 = left_parts[1]\n    result = parts[1]\n    \n    for digit in range(10):\n        digit_str = str(digit)\n        \n        # Replace X with the digit\n        n1 = num1.replace('X', digit_str)\n        n2 = num2.replace('X', digit_str)\n        res = result.replace('X', digit_str)\n        \n        # Check for leading zeros (except for single digit numbers)\n        if len(n1) > 1 and n1[0] == '0':\n            continue\n        if len(n2) > 1 and n2[0] == '0':\n            continue\n        if len(res) > 1 and res[0] == '0':\n            continue\n        \n        # Check if the equation holds\n        try:\n            if int(n1) + int(n2) == int(res):\n                return digit_str\n        except:\n            continue\n    \n    return \"NA\"\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        print(solve(line))\n", "perturbed_sampled": ["<extra_id_1>n1<extra_id_2>n2): try:<extra_id_3>) *<extra_id_4>'+'<extra_id_5>if len (<extra_id_6>1 and len (<extra_id_7>return \"NA\" if val in<extra_id_8>print ( \"Empty line:<extra_id_9>{ \"name\": x }<extra_id_10>result [ \"NID\"<extra_id_11>return result [<extra_id_12>digit\" for x<extra_id_13>str<extra_id_14>( ) for<extra_id_15>,<extra_id_16>) for d<extra_id_17>\"M\" : (<extra_id_18>* 10 +<extra_id_19>. split ( ) ) num1 = left_parts[0] num2 = left_parts[1] result  Replace X with the digit n1 = num1.replace('X', digit_str) n2 = num2.replace('X', digit_str) res = result.replace('X', digit_str) # Check for leading zeros (except for single digit numbers) if len(n1)  1 and res[0] == '0': continue # Check if  return digit_str except: continue return \"NA\" for line in sys.stdin: line = line.strip() if line: print(solve(line))"], "perturbed_original": ["while True: try: string = raw_input() except EOFError: break for i in range(10): translated =  int(right): print i break else: print \"NA\""], "original_ll": -1.2938416004180908, "sampled_ll": -0.6774694323539734, "all_perturbed_sampled_ll": [-2.4198834896087646], "all_perturbed_original_ll": [-3.1895482540130615], "perturbed_sampled_ll": -2.4198834896087646, "perturbed_original_ll": -3.1895482540130615, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,stk,x[3];\nchar tex[1000000],code[1000000];\nchar encode[64][6]={\n\"11010\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"11110\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"11100\",\n\"11101\",\n\"11011\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"11111\",\n\"\",\n\"00000\",\n\"00001\",\n\"00010\",\n\"00011\",\n\"00100\",\n\"00101\",\n\"00110\",\n\"00111\",\n\"01000\",\n\"01001\",\n\"01010\",\n\"01011\",\n\"01100\",\n\"01101\",\n\"01110\",\n\"01111\",\n\"10000\",\n\"10001\",\n\"10010\",\n\"10011\",\n\"10100\",\n\"10101\",\n\"10110\",\n\"10111\",\n\"11000\",\n\"11001\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\"}\n,decode[100000000];\n\nint main(){\n\tdecode[212]=' ';\n\tdecode[111111]='\\'';\n\tdecode[111122]=',';\n\tdecode[21121112]='-';\n\tdecode[121112]='.';\n\tdecode[111112]='?';\n\tdecode[211212]='A';\n\tdecode[21122121]='B';\n\tdecode[1212]='C';\n\tdecode[1112]='D';\n\tdecode[221]='E';\n\tdecode[12112]='F';\n\tdecode[21122122]='G';\n\tdecode[121111]='H';\n\tdecode[1222]='I';\n\tdecode[21122111]='J';\n\tdecode[1221]='K';\n\tdecode[11211]='L';\n\tdecode[21122112]='M';\n\tdecode[21122221]='N';\n\tdecode[11212]='O';\n\tdecode[222]='P';\n\tdecode[21122222]='Q';\n\tdecode[2111]='R';\n\tdecode[11221]='S';\n\tdecode[11222]='T';\n\tdecode[21122211]='U';\n\tdecode[21122212]='V';\n\tdecode[111121]='W';\n\tdecode[21121121]='X';\n\tdecode[21121122]='Y';\n\tdecode[21121111]='Z';\n\n\twhile(fgets(tex,900000,stdin)!=NULL){\n\t\tstrcpy(code,\"\");\n\t\tfor(i=0;i<strlen(tex);i++){\n\t\t\tstrcat(code,encode[tex[i]-' ']);\n\t\t}\n\t\tstk=0;\n\t\tfor(i=0;i<strlen(code);i++){\n\t\t\tstk=stk*10+code[i]-'0'+1;\n\t\t\tif(decode[stk]>0){\n\t\t\t\tprintf(\"%c\",decode[stk]);\n\t\t\t\tstk=0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%\\n\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* char_to_code[] = {\n    \"00000\", \"10000\", \"01000\", \"00100\", \"00010\", \"11000\", \"10100\", \"01100\",\n    \"00110\", \"10010\", \"01010\", \"11100\", \"10110\", \"01110\", \"11010\", \"11110\",\n    \"00001\", \"10001\", \"01001\", \"00101\", \"10101\", \"01101\", \"11001\", \"10011\",\n    \"01011\", \"11101\", \"10111\", \"01111\", \"11011\", \"11111\", \"00011\", \"00111\"\n};\n\nchar chars[] = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ'-.,?\";\n\nchar* code_to_char[] = {\n    \"0\", \"100\", \"10\", \"1\", \"1010\", \"10100\", \"101000\", \"101\",\n    \"110\", \"1100\", \"11\", \"10101\", \"101010\", \"10110\", \"101011\", \"101100\",\n    \"1011\", \"10111\", \"1000\", \"1001\", \"100100\", \"100101\", \"10010\", \"100110\",\n    \"100111\", \"10011\", \"101000\", \"101001\", \"101010\", \"101011\", \"11\", \"111\"\n};\n\nint main() {\n    char input[256];\n    \n    while (fgets(input, sizeof(input), stdin)) {\n        int len = strlen(input);\n        if (len > 0 && input[len-1] == '\\n') {\n            input[len-1] = '\\0';\n            len--;\n        }\n        \n        char binary[10000] = \"\";\n        \n        for (int i = 0; i < len; i++) {\n            char c = input[i];\n            int found = 0;\n            for (int j = 0; j < 32; j++) {\n                if (chars[j] == c) {\n                    strcat(binary, char_to_code[j]);\n                    found = 1;\n                    break;\n                }\n            }\n        }\n        \n        char result[1000] = \"\";\n        int pos = 0;\n        int binlen = strlen(binary);\n        \n        while (pos < binlen) {\n            int found = 0;\n            for (int trylen = 1; trylen <= binlen - pos && trylen <= 10; trylen++) {\n                char temp[20];\n                strncpy(temp, binary + pos, trylen);\n                temp[trylen] = '\\0';\n                \n                for (int j = 0; j < 32; j++) {\n                    if (strcmp(code_to_char[j], temp) == 0) {\n                        int resultlen = strlen(result);\n                        result[resultlen] = chars[j];\n                        result[resultlen + 1] = '\\0';\n                        pos += trylen;\n                        found = 1;\n                        break;\n                    }\n                }\n                if (found) break;\n            }\n            \n            if (!found) {\n                pos++;\n            }\n        }\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> char* char_to_code[] = { \"00000\", \"10000\", \"01000\", \"00100\", \"00010\", \"11000\", \"10100\", \"01100\", \"00110\", \"10010\", \"01010\", \"11100\", )<extra_id_1>) ) { i++ ;<extra_id_2>int i<extra_id_3>for (int j<extra_id_4>= 0; j<extra_id_5>; i++<extra_id_6>{ try<extra_id_7>=<extra_id_8>1; while (j <<extra_id_9>; trylen<extra_id_10>if (found) { strcat(result, char_to_code[j]);<extra_id_11>1;<extra_id_12>\"1000\", \"10110\", \"10111\", \"1000\",<extra_id_13>try<extra_id_14>for<extra_id_15>int j = 0; \"11001\", \"10011\", \"01011\", \"11101\", \"10111\", \"01111\", \"11011\", \"11111\", \"00011\", \"00111\" }; char chars[]  \"101010\", \"10110\", \"101011\", \"101100\", \"1011\", \"10111\", \"1000\", \"1001\", \"100100\", \"100101\", \"10010\", \"100110\", \"100111\", \"10011\", \"101000\", \"101001\", \"101010\", \"101011\", \"11\", \"111\" }; int main() { char input[256]; while (fgets(input,   } char binary[10000] = \"\"; for (int  =   strcat(binary, char_to_code[j]); found = 1; break; } } } char result[1000] = \"\"; int pos = 0; int binlen = strlen(binary); while (pos < binlen) { int found = 0; for (int trylen = 1; trylen <= binlen - pos && trylen <=  temp[trylen] = '\\0'; for (int j = 0; j <  resultlen = strlen(result);  trylen; found = 1; break;  } } printf(\"%s\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int i,stk,x[3];  \"\", \"11110\", \"\", \"\",  \"\", \"\", \"11111\", \"\", \"00000\", \"00001\",  \"01100\", \"01101\", \"01110\", \"01111\", \"10000\", \"10001\", \"10010\", \"10011\", \"10100\", \"10101\", \"10110\", \"10111\", \"11000\", \"11001\", \"\", \"\", \"\", \"\", \"\"}  decode[211212]='A'; decode[21122121]='B'; decode[1212]='C'; decode[1112]='D'; decode[221]='E'; decode[12112]='F'; decode[21122122]='G'; decode[121111]='H'; decode[1222]='I'; decode[21122111]='J'; decode[1221]='K'; decode[11211]='L'; decode[21122112]='M'; decode[21122221]='N'; decode[11212]='O'; decode[222]='P'; decode[21122222]='Q'; decode[2111]='R'; decode[11221]='S'; decode[11222]='T'; decode[21122211]='U'; decode[21122212]='V'; decode[111121]='W'; decode[21121121]='X';  stk=stk*10+code[i]-'0'+1; if(decode[stk]>0){ printf(\"%c\",decode[stk]); stk=0; } } printf(\"%\\n\"); } return 0; }"], "original_ll": -0.7034753561019897, "sampled_ll": -0.5052796006202698, "all_perturbed_sampled_ll": [-1.3231087923049927], "all_perturbed_original_ll": [-0.9657943844795227], "perturbed_sampled_ll": -1.3231087923049927, "perturbed_original_ll": -0.9657943844795227, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\n\npublic class Main {\n\n\tstatic final HashMap<Character, String> c1 = new HashMap<Character, String>(32) {\n\t\t{\n\t\t\tput('A', \"00000\");\n\t\t\tput('B', \"00001\");\n\t\t\tput('C', \"00010\");\n\t\t\tput('D', \"00011\");\n\t\t\tput('E', \"00100\");\n\t\t\tput('F', \"00101\");\n\t\t\tput('G', \"00110\");\n\t\t\tput('H', \"00111\");\n\t\t\tput('I', \"01000\");\n\t\t\tput('J', \"01001\");\n\t\t\tput('K', \"01010\");\n\t\t\tput('L', \"01011\");\n\t\t\tput('M', \"01100\");\n\t\t\tput('N', \"01101\");\n\t\t\tput('O', \"01110\");\n\t\t\tput('P', \"01111\");\n\t\t\tput('Q', \"10000\");\n\t\t\tput('R', \"10001\");\n\t\t\tput('S', \"10010\");\n\t\t\tput('T', \"10011\");\n\t\t\tput('U', \"10100\");\n\t\t\tput('V', \"10101\");\n\t\t\tput('W', \"10110\");\n\t\t\tput('X', \"10111\");\n\t\t\tput('Y', \"11000\");\n\t\t\tput('Z', \"11001\");\n\t\t\tput(' ', \"11010\");\n\t\t\tput('.', \"11011\");\n\t\t\tput(',', \"11100\");\n\t\t\tput('-', \"11101\");\n\t\t\tput('\\'', \"11110\");\n\t\t\tput('?', \"11111\");\n\t\t}\n\t};\n\n\tstatic final HashMap<String, Character> c2 = new HashMap<String, Character>(32) {\n\t\t{\n\t\t\tput(\"101\", ' ');\n\t\t\tput(\"000000\", '\\'');\n\t\t\tput(\"000011\", ',');\n\t\t\tput(\"10010001\", '-');\n\t\t\tput(\"010001\", '.');\n\t\t\tput(\"000001\", '?');\n\t\t\tput(\"100101\", 'A');\n\t\t\tput(\"10011010\", 'B');\n\t\t\tput(\"0101\", 'C');\n\t\t\tput(\"0001\", 'D');\n\t\t\tput(\"110\", 'E');\n\t\t\tput(\"01001\", 'F');\n\t\t\tput(\"10011011\", 'G');\n\t\t\tput(\"010000\", 'H');\n\t\t\tput(\"0111\", 'I');\n\t\t\tput(\"10011000\", 'J');\n\t\t\tput(\"0110\", 'K');\n\t\t\tput(\"00100\", 'L');\n\t\t\tput(\"10011001\", 'M');\n\t\t\tput(\"10011110\", 'N');\n\t\t\tput(\"00101\", 'O');\n\t\t\tput(\"111\", 'P');\n\t\t\tput(\"10011111\", 'Q');\n\t\t\tput(\"1000\", 'R');\n\t\t\tput(\"00110\", 'S');\n\t\t\tput(\"00111\", 'T');\n\t\t\tput(\"10011100\", 'U');\n\t\t\tput(\"10011101\", 'V');\n\t\t\tput(\"000010\", 'W');\n\t\t\tput(\"10010010\", 'X');\n\t\t\tput(\"10010011\", 'Y');\n\t\t\tput(\"10010000\", 'Z');\n\t\t}\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tif (line.isEmpty()) {\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tStringBuilder sb1, sb2;\n\t\t\tsb1 = new StringBuilder();\n\t\t\tsb2 = new StringBuilder();\n\t\t\t//\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tsb1.append(c1.get(c));\n\t\t\t}\n\t\t\t//\n\t\t\tString line2 = sb1.toString();\n\t\t\tfor (int i = 0; ; ) {\n\t\t\t\tchar c = 0;\n\t\t\t\tfor (int j = 3; j < 9 && i + j < line2.length(); j++) {\n\t\t\t\t\tif (c2.containsKey(line2.substring(i, i + j))) {\n\t\t\t\t\t\tc = c2.get(line2.substring(i, i + j));\n\t\t\t\t\t\tsb2.append(c);\n\t\t\t\t\t\ti += j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (c == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sb2.toString());\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static Map<Character, String> charToCode = new HashMap<>();\n    static Map<String, Character> codeToChar = new HashMap<>();\n    \n    static {\n        // First table (char to code)\n        charToCode.put('A', \"00000\");\n        charToCode.put('B', \"0001\");\n        charToCode.put('C', \"0010\");\n        charToCode.put('D', \"0011\");\n        charToCode.put('E', \"110\");\n        charToCode.put('F', \"1000\");\n        charToCode.put('G', \"1001\");\n        charToCode.put('H', \"1010\");\n        charToCode.put('I', \"1011\");\n        charToCode.put('J', \"0100\");\n        charToCode.put('K', \"0101\");\n        charToCode.put('L', \"0110\");\n        charToCode.put('M', \"0111\");\n        charToCode.put('N', \"10000\");\n        charToCode.put('O', \"10001\");\n        charToCode.put('P', \"111\");\n        charToCode.put('Q', \"10010\");\n        charToCode.put('R', \"10011\");\n        charToCode.put('S', \"10100\");\n        charToCode.put('T', \"10101\");\n        charToCode.put('U', \"10110\");\n        charToCode.put('V', \"10111\");\n        charToCode.put('W', \"11000\");\n        charToCode.put('X', \"11001\");\n        charToCode.put('Y', \"11010\");\n        charToCode.put('Z', \"11011\");\n        charToCode.put(' ', \"11100\");\n        charToCode.put('.', \"11101\");\n        charToCode.put(',', \"11110\");\n        charToCode.put('-', \"11111\");\n        charToCode.put('\\'', \"01010\");\n        charToCode.put('?', \"01011\");\n        \n        // Second table (code to char)\n        codeToChar.put(\"00\", 'A');\n        codeToChar.put(\"0100\", 'B');\n        codeToChar.put(\"0101\", 'C');\n        codeToChar.put(\"0110\", 'D');\n        codeToChar.put(\"110\", 'E');\n        codeToChar.put(\"01110\", 'F');\n        codeToChar.put(\"01111\", 'G');\n        codeToChar.put(\"1000\", 'H');\n        codeToChar.put(\"1001\", 'I');\n        codeToChar.put(\"10100\", 'J');\n        codeToChar.put(\"10101\", 'K');\n        codeToChar.put(\"10110\", 'L');\n        codeToChar.put(\"10111\", 'M');\n        codeToChar.put(\"1011\", 'N');\n        codeToChar.put(\"01010\", 'O');\n        codeToChar.put(\"111\", 'P');\n        codeToChar.put(\"01011\", 'Q');\n        codeToChar.put(\"1100\", 'R');\n        codeToChar.put(\"1101\", 'S');\n        codeToChar.put(\"00111\", 'T');\n        codeToChar.put(\"1110\", 'U');\n        codeToChar.put(\"11110\", 'V');\n        codeToChar.put(\"11111\", 'W');\n        codeToChar.put(\"10010\", 'X');\n        codeToChar.put(\"10011\", 'Y');\n        codeToChar.put(\"01000\", 'Z');\n        codeToChar.put(\"01001\", ' ');\n        codeToChar.put(\"10000\", '.');\n        codeToChar.put(\"10001\", ',');\n        codeToChar.put(\"0010\", '-');\n        codeToChar.put(\"0011\", '\\'');\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            \n            // Step 1: Convert each character to code\n            StringBuilder binary = new StringBuilder();\n            for (char c : line.toCharArray()) {\n                if (charToCode.containsKey(c)) {\n                    binary.append(charToCode.get(c));\n                }\n            }\n            \n            // Step 2: Decode using second table\n            StringBuilder result = new StringBuilder();\n            int i = 0;\n            while (i < binary.length()) {\n                boolean found = false;\n                for (int len = 1; len <= 5 && i + len <= binary.length(); len++) {\n                    String sub = binary.substring(i, i + len);\n                    if (codeToChar.containsKey(sub)) {\n                        result.append(codeToChar.get(sub));\n                        i += len;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    i++;\n                }\n            }\n            \n            System.out.println(result.toString());\n        }\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  new HashMap<>(); static Map<String, Character> codeToChar = new HashMap<>(); static { // First table (char to code) charToCode.put('A', \"00000\"); charToCode.put('B', \"0001\");  charToCode.put('H', \"1010\"); charToCode.put('I', \"1011\"); charToCode.put('J', \"0100\"); charToCode.put('K', \"0101\"); charToCode.put('L', \"0110\"); charToCode.put('M', \"0111\"); charToCode.put('N', \"10000\"); charToCode.put('O', \"10001\"); charToCode.put('P', \"111\"); charToCode.put('Q', \"10010\"); charToCode.put('R', \"10011\"); charToCode.put('S', \"10100\"); charToCode.put('T', \"10101\"); charToCode.put('U', \"10110\"); charToCode.put('V', \"10111\"); charToCode.put('W', \"11000\"); charToCode.put('X', \"11001\"); charToCode.put('Y', \"11010\"); charToCode.put('Z', \"11011\"); charToCode.put(' ', \"11100\"); charToCode.put('.', \"11101\"); charToCode.put(',', \"11110\"); charToCode.put('-',   'N'); codeToChar.put(\"01010\", 'O');   codeToChar.put(\"0010\", '-'); codeToChar.put(\"0011\", '\\''); } public static void main(String[] args) {  = sc.nextLine();  code StringBuilder binary  (charToCode.containsKey(c)) { binary.append(charToCode.get(c)); } } // Step 2: Decode using second table StringBuilder result = new StringBuilder(); int i = 0; while (i < binary.length()) { boolean found = false; for (int len = 1; len <= 5 && i +   = true; break; } } if (!found) { i++; } } System.out.println(result.toString()); } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.HashMap; public class Main { static final HashMap<Character, String> c1 = new HashMap<Character, String>(32) { { put('A', \"00000\"); put('B', \"00001\"); put('C', \"00010\"); put('D', \"00011\"); put('E', \"00100\"); put('F', \"00101\"); put('G', \"00110\"); put('H',  put('R', \"10001\"); put('S',  \"10111\"); put('Y', \"11000\"); put('Z', \"11001\"); put(' ', \"11010\"); put('.', \"11011\"); put(',', \"11100\"); put('-', \"11101\"); put('\\'', \"11110\");  '\\''); put(\"000011\",  'B'); put(\"0101\", 'C'); put(\"0001\", 'D'); put(\"110\", 'E'); put(\"01001\", 'F'); put(\"10011011\", 'G'); put(\"010000\", 'H'); put(\"0111\", 'I'); put(\"10011000\", 'J'); put(\"0110\", 'K'); put(\"00100\", 'L'); put(\"10011001\", 'M'); put(\"10011110\", 'N');  put(\"00111\", 'T'); put(\"10011100\", 'U'); put(\"10011101\", 'V'); put(\"000010\", 'W'); put(\"10010010\", 'X'); put(\"10010011\", 'Y');  line = \"\";  System.out.println(\"\"); continue; } StringBuilder sb1, sb2; sb1 = new StringBuilder(); sb2 = new StringBuilder(); // for (char c : line.toCharArray()) { sb1.append(c1.get(c)); } // String line2 = sb1.toString(); for (int i = 0; ; ) { char c =   sb2.append(c); i +=  } } System.out.println(sb2.toString()); } } }"], "original_ll": -0.3847379684448242, "sampled_ll": -0.29649993777275085, "all_perturbed_sampled_ll": [-0.9576988816261292], "all_perturbed_original_ll": [-0.9822264909744263], "perturbed_sampled_ll": -0.9576988816261292, "perturbed_original_ll": -0.9822264909744263, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "to_bin = dict(zip([chr(i) for i in range(ord(\"A\"), ord(\"Z\") + 1)] + [\" \", \".\", \",\", \"-\", \"'\", \"?\"],\n                  [bin(i)[2:7].zfill(5) for i in range(2 ** 5)]))\nto_chr = {\"101\":\" \", \"000000\":\"'\", \"000011\":\",\", \"10010001\":\"-\", \"010001\":\".\", \"000001\":\"?\", \"100101\":\"A\", \"10011010\":\"B\",\n          \"0101\":\"C\", \"0001\":\"D\", \"110\":\"E\", \"01001\":\"F\", \"10011011\":\"G\", \"010000\":\"H\", \"0111\":\"I\", \"10011000\":\"J\",\n          \"0110\":\"K\", \"00100\":\"L\", \"10011001\":\"M\", \"10011110\":\"N\", \"00101\":\"O\", \"111\":\"P\", \"10011111\":\"Q\", \"1000\":\"R\",\n          \"00110\":\"S\", \"00111\":\"T\", \"10011100\":\"U\", \"10011101\":\"V\", \"000010\":\"W\", \"10010010\":\"X\", \"10010011\":\"Y\", \"10010000\":\"Z\"}\n\nwhile True:\n  try:\n    s = input()\n  except EOFError:\n    break\n  bs = \"\".join([to_bin[c] for c in s])\n  ans = \"\"\n  while True:\n    length = 9\n    for i in range(length):\n      if bs[:i] in to_chr:\n        ans = ans + to_chr[bs[:i]]\n        bs = bs[i:]\n        break\n    else:\n      break\n  print(ans)\n", "sampled": "import sys\n\n# First conversion table (character to code)\nchar_to_code = {\n    'A': '00000', 'B': '10000', 'C': '01000', 'D': '00100', 'E': '00010',\n    'F': '10100', 'G': '01100', 'H': '00110', 'I': '10010', 'J': '01010',\n    'K': '00001', 'L': '10001', 'M': '01001', 'N': '00101', 'O': '10101',\n    'P': '01101', 'Q': '00011', 'R': '10011', 'S': '01011', 'T': '11000',\n    'U': '10110', 'V': '01110', 'W': '00111', 'X': '10111', 'Y': '01111',\n    'Z': '11001', \"'\": '11010', ',': '11011', '-': '11100', '.': '11101',\n    '?': '11110', ' ': '11111'\n}\n\n# Second conversion table (code to character)\ncode_to_char = {\n    '00': 'A', '0100': 'B', '0000': 'C', '100': 'D', '110': 'E',\n    '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J',\n    '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O',\n    '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T',\n    '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '0001': 'Y',\n    '10100': 'Z', '10101': \"'\", '10110': ',', '10111': '-', '11000': '.',\n    '11001': '?', '0000': ' '\n}\n\n# Fix the duplicate keys issue - need to check which mapping is correct\ncode_to_char = {\n    '00': 'A', '0100': 'B', '0000': 'C', '100': 'D', '110': 'E',\n    '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J',\n    '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O',\n    '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T',\n    '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '10100': 'Z',\n    '10101': \"'\", '10110': ',', '10111': '-', '11000': '.', '11001': '?'\n}\n\ndef decode(binary_str):\n    result = []\n    i = 0\n    while i < len(binary_str):\n        found = False\n        # Try lengths from 2 to 5\n        for length in range(2, 6):\n            if i + length <= len(binary_str):\n                substr = binary_str[i:i+length]\n                if substr in code_to_char:\n                    result.append(code_to_char[substr])\n                    i += length\n                    found = True\n                    break\n        if not found:\n            i += 1\n    return ''.join(result)\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    \n    # Step 1: Convert characters to binary using first table\n    binary = ''\n    for char in line:\n        if char in char_to_code:\n            binary += char_to_code[char]\n    \n    # Step 2: Convert binary to characters using second table\n    result = decode(binary)\n    print(result)\n", "perturbed_sampled": ["import sys # First conversion table (character to code) char_to_code = { 'A': '00000', 'B': '10000', 'C': '01000', 'D':  '10010', 'J': '01010', 'K': '00001', 'L': '10001', 'M': '01001', 'N': '00101', 'O': '10101', 'P': '01101', 'Q': '00011', 'R': '10011', 'S': '01011', 'T': '11000', 'U': '10110',   ' ': '11111' } # Second conversion table (code to character) code_to_char = { '00': 'A', '0100': 'B', '0000': 'C', '100': 'D', '110': 'E', '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J', '0001': 'K', '1100': 'L', '0101': 'M', '01':  'S', '11': 'T', '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '0001': 'Y', '10100': 'Z', '10101': \"'\", '10110': ',', '10111': '-', '11000': '.', '11001': '?', '0000': ' '  check which mapping is correct code_to_char =  'E', '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J', '0001': 'K', '1100': 'L', '0101': 'M', '01':  '1111': 'X', '10100': 'Z', '10101': \"'\", '10110': ',', '10111': '-', '11000': '.', '11001': '?' }  < len(binary_str): found = False # Try lengths from  +  in sys.stdin: line  characters  # Step 2: Convert binary to characters using second table result = decode(binary) print(result)"], "perturbed_original": ["to_bin = dict(zip([chr(i) for i in range(ord(\"A\"), ord(\"Z\") + 1)] + [\" \", \".\",  5)])) to_chr = {\"101\":\" \", \"000000\":\"'\", \"000011\":\",\", \"10010001\":\"-\", \"010001\":\".\", \"000001\":\"?\",   \"10011100\":\"U\", \"10011101\":\"V\", \"000010\":\"W\", \"10010010\":\"X\", \"10010011\":\"Y\", \"10010000\":\"Z\"} while True: try:  c in s]) ans = \"\" while True: length = 9 for i in range(length): if bs[:i] in to_chr:  break print(ans)"], "original_ll": -0.8399863839149475, "sampled_ll": -0.41601458191871643, "all_perturbed_sampled_ll": [-1.0137567520141602], "all_perturbed_original_ll": [-1.8167985677719116], "perturbed_sampled_ll": -1.0137567520141602, "perturbed_original_ll": -1.8167985677719116, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  long long int time[10001] = {}, wtime[10001] = {}, min, sum;\n  int j, k, n;\n  while(scanf(\"%d\", &n) && n){\n    for(j = 0;j < n;j++)\n      scanf(\"%lld\", &time[j]);\n\n    for(j = 0;j < n - 1;j++){\n      min = j;\n      for(k = j + 1;k < n;k++)\n\tmin = time[min] < time[k] ? min : k;\n      if(min != j){\n\ttime[min] += time[j];\n\ttime[j] = time[min] - time[j];\n\ttime[min] -= time[j];\n      }\n    }\n    sum = 0;\n    for(j = 1;j < n;j++){\n      wtime[j] = wtime[j - 1] + time[j - 1];\n      sum += wtime[j];\n    }\n    \n    printf(\"%lld\\n\", sum);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int times[10000];\n        \n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", &times[i]);\n        }\n        \n        qsort(times, n, sizeof(int), compare);\n        \n        long long total_wait = 0;\n        long long cumulative = 0;\n        \n        for(int i = 0; i < n; i++) {\n            total_wait += cumulative;\n            cumulative += times[i];\n        }\n        \n        printf(\"%lld\\n\", total_wait);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int  *(int*)b); } int main() { int n; while(scanf(\"%d\", &n) == 1 && n != 0) {   total_wait = 0; long long cumulative  { total_wait += cumulative; cumulative += times[i]; } printf(\"%lld\\n\", total_wait); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ long long int time[10001] = {}, wtime[10001] = <extra_id_2>, &time[10001];<extra_id_3>=<extra_id_4>( 1,&wtimes[10001]); wtime[10001] =<extra_id_5>0; } }<extra_id_6>{ s = 2;<extra_id_7>i =<extra_id_8>2; i<extra_id_9>;<extra_id_10>; m [ 1 ]<extra_id_11>i . y<extra_id_12>(<extra_id_13>(<extra_id_14>, (<extra_id_15>- i .<extra_id_16>;<extra_id_17>1); for(j=0; l<n;i++){ f[i]. n){ for(j = 0;j < n;j++) scanf(\"%lld\", &time[j]); for(j = 0;j < n - 1;j++){ min  != j){ time[min] += time[j]; time[j] = time[min] - time[j]; time[min] -= time[j]; } } sum = 0; for(j =  - 1]; sum += wtime[j]; } printf(\"%lld\\n\", sum); } return 0; }"], "original_ll": -0.7285519242286682, "sampled_ll": -0.5472394824028015, "all_perturbed_sampled_ll": [-2.3630640506744385], "all_perturbed_original_ll": [-1.967866063117981], "perturbed_sampled_ll": -2.3630640506744385, "perturbed_original_ll": -1.967866063117981, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.*;\npublic class Main {\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint [] data = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = sc.nextInt();\n\t\t\t\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tint [] data2 = new int[n];\n\t\t\tint sum = 0;\n\t\t\tdata2[0] = 0;\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tdata2[i] = data2[i-1] + data[i-1];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tsum += data2[i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] times = new int[n];\n            for (int i = 0; i < n; i++) {\n                times[i] = sc.nextInt();\n            }\n            \n            Arrays.sort(times);\n            \n            int totalWaitTime = 0;\n            int currentTime = 0;\n            \n            for (int i = 0; i < n; i++) {\n                totalWaitTime += currentTime;\n                currentTime += times[i];\n            }\n            \n            System.out.println(totalWaitTime);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  sc = new Scanner(System.in);  0) break; int[] times = new int[n]; for (int i = 0; i < n; i++) { times[i] =  0; for (int i = 0; i < n; i++) { totalWaitTime += currentTime; currentTime += times[i]; } System.out.println(totalWaitTime); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main  [] data = new int[n]; for(int   = 0; data2[0] = 0; for(int i = 1; i < n; i++){ data2[i] = data2[i-1] + data[i-1]; } for(int i = 0; i < n; i++){ sum += data2[i]; } System.out.println(sum); } } public static void main(String[] args) { Main obj = new Main(); obj.doit(); } }"], "original_ll": -0.6978098154067993, "sampled_ll": -0.3899305462837219, "all_perturbed_sampled_ll": [-1.7601698637008667], "all_perturbed_original_ll": [-1.4200894832611084], "perturbed_sampled_ll": -1.7601698637008667, "perturbed_original_ll": -1.4200894832611084, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = int(input())\nt = []\ns = 0\nsum = 0\n\nif n == 0:\n    print(n)\n\nelse:\n    for i in range(n):\n        s = int(input())\n        if s == 0:\n            break\n        else:\n            t.append(i)\n            t[i] = s\n            t.sort()\n\n    for m in range(n):\n        sum = sum + t[m]*(n-m-1)\n\n    print(sum)\n\n", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    times = []\n    for _ in range(n):\n        times.append(int(input()))\n    \n    times.sort()\n    \n    total_wait = 0\n    cumulative_time = 0\n    \n    for t in times:\n        total_wait += cumulative_time\n        cumulative_time += t\n    \n    print(total_wait)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0:  total_wait = 0 cumulative_time = 0 for t in times: total_wait += cumulative_time cumulative_time += t print(total_wait)"], "perturbed_original": ["n =  if  = int(input()) if s == 0: break else: t.append(i) t[i] = s t.sort() for m in range(n): sum = sum + t[m]*(n-m-1) print(sum)"], "original_ll": -1.1917861700057983, "sampled_ll": -0.8705251216888428, "all_perturbed_sampled_ll": [-2.3688559532165527], "all_perturbed_original_ll": [-2.87117862701416], "perturbed_sampled_ll": -2.3688559532165527, "perturbed_original_ll": -2.87117862701416, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "char S[99];\nint G(x,y){return y?G(y,x%y):x;}\nmain(g,X,Y,x,y,z,t,T,f){for(;~scanf(\"%d%d\",&x,&y);){\nfor(g=0,X=x,Y=y;g<90;g++)S[g]=X*10/Y+'0',X=X*10%y;\nsprintf(S,\"%.97f\",x/(double)y);\ng=G(x,y);x/=g;y/=g;\nfor(z=0;y%2==0;y/=2)z++;\nfor(f=0;y%5==0;y/=5)f++;\nif(y==1)t=0;else{x=1;t=0;do{x=x*10%y;t++;}while(x!=1);}\nif(z>f)f=z;\nS[f+t+2]=0;puts(S+2);\nif(t){\n\tfor(;f>0;f--)putchar(' ');\n\tfor(;t>0;t--)putchar('^');\n\tputs(\"\");\n}\n}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int p, q;\n    \n    while (scanf(\"%d %d\", &p, &q) == 2) {\n        char digits[85];\n        int remainders[1000005];\n        int positions[1000005];\n        \n        memset(remainders, -1, sizeof(remainders));\n        memset(positions, -1, sizeof(positions));\n        \n        int remainder = p % q;\n        int pos = 0;\n        int cycle_start = -1;\n        \n        while (remainder != 0) {\n            if (remainders[remainder] != -1) {\n                cycle_start = remainders[remainder];\n                break;\n            }\n            \n            remainders[remainder] = pos;\n            positions[pos] = remainder;\n            \n            remainder *= 10;\n            digits[pos] = (remainder / q) + '0';\n            remainder = remainder % q;\n            pos++;\n        }\n        \n        digits[pos] = '\\0';\n        \n        if (cycle_start == -1) {\n            // Non-repeating\n            printf(\"%s\\n\", digits);\n        } else {\n            // Repeating\n            printf(\"%s\\n\", digits);\n            for (int i = 0; i < cycle_start; i++) {\n                printf(\" \");\n            }\n            for (int i = cycle_start; i < pos; i++) {\n                printf(\"^\");\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int p, q; while  remainders[1000005]; int positions[1000005]; memset(remainders, -1, sizeof(remainders)); memset(positions, -1, sizeof(positions)); int remainder = p % q; int pos = 0; int cycle_start =  { cycle_start = remainders[remainder]; break; } remainders[remainder] = pos; positions[pos] = remainder; remainder *=  (cycle_start == -1) { // Non-repeating printf(\"%s\\n\", digits); } else { // Repeating printf(\"%s\\n\", digits);   pos; i++) { printf(\"^\"); } printf(\"\\n\"); } } return 0; }"], "perturbed_original": [" for(f=0;y%5==0;y/=5)f++; if(y==1)t=0;else{x=1;t=0;do{x=x*10%y;t++;}while(x!=1);} if(z>f)f=z; S[f+t+2]=0;puts(S+2); if(t){ for(;f>0;f--)putchar(' '); for(;t>0;t--)putchar('^'); puts(\"\"); } }exit(0);}"], "original_ll": -1.9757333993911743, "sampled_ll": -0.6496462225914001, "all_perturbed_sampled_ll": [-1.9408295154571533], "all_perturbed_original_ll": [-2.4097537994384766], "perturbed_sampled_ll": -1.9408295154571533, "perturbed_original_ll": -2.4097537994384766, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int p = sc.nextInt();\n\t\t\tfinal int q = sc.nextInt();\n\t\t\t\n\t\t\tif(p == 0 && q == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] mods = new int[q];\n\t\t\tArrays.fill(mods, -1);\n\t\t\t\n\t\t\tint cur = p * 10;\n\t\t\tint rep_start = -1;\n\t\t\tint rep_end = 0;\n\t\t\twhile(true){\n\t\t\t\tfinal int m = cur % q;\n\t\t\t\tSystem.out.print(cur / q);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(m == 0){\n\t\t\t\t\trep_start = rep_end;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(mods[m] >= 0){\n\t\t\t\t\trep_start = mods[m];\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tmods[m] = rep_end;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep_end++;\n\t\t\t\tcur = m * 10;\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tif(rep_start != rep_end){\n\t\t\t\tfor(int i = 0; i <= rep_end;i++){\n\t\t\t\t\tif(i <= rep_start){\n\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.print(\"^\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int p = sc.nextInt();\n            int q = sc.nextInt();\n            \n            StringBuilder decimal = new StringBuilder();\n            Map<Integer, Integer> remainderPos = new HashMap<>();\n            \n            int remainder = p % q;\n            int position = 0;\n            \n            while (remainder != 0 && !remainderPos.containsKey(remainder)) {\n                remainderPos.put(remainder, position);\n                remainder *= 10;\n                int digit = remainder / q;\n                decimal.append(digit);\n                remainder = remainder % q;\n                position++;\n            }\n            \n            if (remainder == 0) {\n                // Terminates\n                System.out.println(decimal.toString());\n            } else {\n                // Repeating\n                int cycleStart = remainderPos.get(remainder);\n                System.out.println(decimal.toString());\n                \n                StringBuilder marker = new StringBuilder();\n                for (int i = 0; i < cycleStart; i++) {\n                    marker.append(' ');\n                }\n                for (int i = cycleStart; i < decimal.length(); i++) {\n                    marker.append('^');\n                }\n                System.out.println(marker.toString());\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  new Scanner(System.in); while (sc.hasNext()) { int  new StringBuilder(); Map<Integer, Integer> remainderPos = new HashMap<>();  while (remainder != 0 && !remainderPos.containsKey(remainder)) { remainderPos.put(remainder, position); remainder *= 10; int digit = remainder / q;  // Repeating int cycleStart = remainderPos.get(remainder); System.out.println(decimal.toString()); StringBuilder marker = new StringBuilder(); for (int i = 0; i < cycleStart; i++) { marker.append('  i++) { marker.append('^'); } System.out.println(marker.toString()); } } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String[]  p = sc.nextInt(); final int q  cur = p * 10; int rep_start = -1; int rep_end = 0; while(true){ final int m = cur % q; System.out.print(cur / q); if(m == 0){ rep_start =  * 10; } System.out.println(); if(rep_start !=  rep_start){ System.out.print(\" \"); }else{ System.out.print(\"^\"); } } System.out.println(); } } } }"], "original_ll": -0.8742110729217529, "sampled_ll": -0.6729715466499329, "all_perturbed_sampled_ll": [-2.307762861251831], "all_perturbed_original_ll": [-2.2972824573516846], "perturbed_sampled_ll": -2.307762861251831, "perturbed_original_ll": -2.2972824573516846, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from decimal import *\nimport re\ndef solve2(m, n):\n    maxlen = 85\n    #PREC=200\n    PREC=300\n    getcontext().prec = PREC\n    x = Decimal(m) / Decimal(n)\n    s = x.to_eng_string()\n    if len(s) < PREC:\n        return(s[2:],'')\n    rep = 1\n    while True:\n        r = r'(.{%d})\\1{%d,}' % (rep, int(PREC/rep)-1)\n                                         #ex. '(.{6})\\\\1{12,}'\n        a=re.search(r, s)\n        if a:\n            break\n        rep += 1\n        if rep > maxlen:\n            raise ValueError('This cannot happen.')\n\n    u = s[2:a.start()+len(a.group(1))]\n    v = (' '*PREC + '^'*len(a.group(1)))[-len(u):]\n    return(u,v)\n\nwhile True:\n    try:\n        m,n = map(int, input().strip().split())\n        s,t = solve2(m, n)\n        print(s)\n        if t!='':\n            print(t)\n    except EOFError:\n        break", "sampled": "import sys\n\ndef solve(p, q):\n    # Calculate decimal representation of p/q\n    decimal_digits = []\n    remainders = {}\n    remainder = p % q\n    position = 0\n    \n    while remainder != 0 and remainder not in remainders:\n        remainders[remainder] = position\n        remainder *= 10\n        digit = remainder // q\n        decimal_digits.append(str(digit))\n        remainder = remainder % q\n        position += 1\n    \n    if remainder == 0:\n        # Terminating decimal\n        print(''.join(decimal_digits))\n    else:\n        # Repeating decimal\n        cycle_start = remainders[remainder]\n        print(''.join(decimal_digits))\n        \n        # Second line with spaces and carets\n        line2 = []\n        for i in range(len(decimal_digits)):\n            if i < cycle_start:\n                line2.append(' ')\n            else:\n                line2.append('^')\n        print(''.join(line2))\n\nfor line in sys.stdin:\n    p, q = map(int, line.strip().split())\n    solve(p, q)\n", "perturbed_sampled": ["import sys def solve(p,  remainders  while remainder != 0 and remainder not in remainders: remainders[remainder] = position remainder *= 10  q position += 1 if remainder == 0: #  print(''.join(decimal_digits)) # Second line with spaces and carets line2 = [] for i in range(len(decimal_digits)): if i <  p, q = map(int, line.strip().split()) solve(p, q)"], "perturbed_original": ["from decimal import * import re def solve2(m, n): maxlen = 85 #PREC=200   '(.{6})\\\\1{12,}' a=re.search(r, s) if a: break  happen.') u = s[2:a.start()+len(a.group(1))] v = (' '*PREC + '^'*len(a.group(1)))[-len(u):] return(u,v) while True: try: m,n = map(int, input().strip().split()) s,t = solve2(m, n) print(s) if t!='': print(t) except EOFError: break"], "original_ll": -1.6403121948242188, "sampled_ll": -0.8451234698295593, "all_perturbed_sampled_ll": [-3.0401084423065186], "all_perturbed_original_ll": [-2.79310941696167], "perturbed_sampled_ll": -3.0401084423065186, "perturbed_original_ll": -2.79310941696167, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "int G(x,y){return y?G(y,x%y):x;}\nint L(x,y){return x>y?(x/G(x,y)*y):(y/G(y,x)*x);}\nn[3],a[3],m[3];main(i,x){\n\tfor(;scanf(\"%d%d%d%d%d%d\",a,m,a+1,m+1,a+2,m+2),*m;){\n\t\tfor(i=3;i--;)for(x=n[i]=1;(x=a[i]*x%m[i])>1;n[i]++);\n\t\tprintf(\"%d\\n\",L(n[0],L(n[1],n[2])));\n\t}\n}", "sampled": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long lcm(long long a, long long b) {\n    return a / gcd(a, b) * b;\n}\n\nlong long find_period(long long a, long long m) {\n    long long x = 1;\n    long long period = 0;\n    \n    do {\n        x = (x * a) % m;\n        period++;\n    } while (x != 1);\n    \n    return period;\n}\n\nint main() {\n    long long a1, m1, a2, m2, a3, m3;\n    \n    while (1) {\n        scanf(\"%lld %lld %lld %lld %lld %lld\", &a1, &m1, &a2, &m2, &a3, &m3);\n        \n        if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) {\n            break;\n        }\n        \n        long long period1 = find_period(a1, m1);\n        long long period2 = find_period(a2, m2);\n        long long period3 = find_period(a3, m3);\n        \n        long long result = lcm(period1, lcm(period2, period3));\n        \n        printf(\"%lld\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> long long gcd(long  { long long temp = b; b = a % b; a = temp; } return a; } long long lcm(long long a, long long b) { return a / gcd(a, b) *  { long long x = 1; long long  % m; period++; }   { scanf(\"%lld %lld %lld %lld %lld %lld\", &a1, &m1, &a2, &m2, &a3, &m3); if (a1 == 0 && m1 == 0 && a2 ==  long long period3 = find_period(a3, m3); long long result = lcm(period1, lcm(period2, period3)); printf(\"%lld\\n\", result); } return 0; }"], "perturbed_original": ["int G(x,y){return y?G(y,x%y):x;} int L(x,y){return x>y?(x/G(x,y)*y):(y/G(y,x)*x);} n[3],a[3],m[3];main(i,x){ for(;scanf(\"%d%d%d%d%d%d\",a,m,a+1,m+1,a+2,m+2),*m;){ for(i=3;i--;)for(x=n[i]=1;(x=a[i]*x%m[i])>1;n[i]++); printf(\"%d\\n\",L(n[0],L(n[1],n[2]))); } }"], "original_ll": -1.6341581344604492, "sampled_ll": -0.2709316909313202, "all_perturbed_sampled_ll": [-1.3936989307403564], "all_perturbed_original_ll": [-1.7424174547195435], "perturbed_sampled_ll": -1.3936989307403564, "perturbed_original_ll": -1.7424174547195435, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.*;\nimport java.util.*;\n\n\n// \u0082\u00e6\u0082\u00ad\u008a\u00d4\u0088\u00e1\u0082\u00a4\u0082\u00c6\u0082\u00b1\u0082\u00eb\u0081B\n// \u0096\u00e2\u0091\u00e8\u0095\u00b6\u0082\u00c9\u008f\u0091\u0082\u00a2\u0082\u00c4\u0082\u00c8\u0082\u00ad\u0082\u00c4\u0082\u00e0\u0096\u00e2\u0091\u00e8\u0083Z\u0083b\u0083g\u0082\u00cd\u0095\u00a1\u0090\u0094\u0082\u00c5\u0090\u00e6\u0093\u00aa\u0082\u00aa0\u0082\u00c5\u008fI\u0097\u00b9\u0082\u00c5\u0082\u00a0\u0082\u00e9\u0081B\n// \u0096\u00e2\u0091\u00e8\u0083Z\u0083b\u0083g\u0082\u00cc\u008cJ\u0082\u00e8\u0095\u00d4\u0082\u00b5\u008e\u009e\u0082\u00c9\u008f\u0089\u008a\u00fa\u0089\u00bb\u0098R\u0082\u00ea\n\n// 2011/10/18\n\n//\u0081@0114 \u0094\u0088\npublic class Main {\n\n\t\n\tlong gcm(long a, long b) {\n\t\t\n\t\twhile(b != 0) {\n\t\t\tlong t = a % b;\n\t\t\ta = b;\n\t\t\tb = t;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcm(a, b);\n\t}\n\t\n\t// \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2\n\tboolean main() throws IOException {\n\n\t\tint[] ri = readIntArray();\n\t\tint a1 = ri[0];\n\t\tint m1 = ri[1];\n\t\tint a2 = ri[2];\n\t\tint m2 = ri[3];\n\t\tint a3 = ri[4];\n\t\tint m3 = ri[5];\n\t\tif (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) \n\t\t\treturn false; // \u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2\n\n\t\tint i;\n\t\tint x = 1;\n\t\tfor(i = 1;; i++) {\n\t\t\tx = (a1 * x) % m1;\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tlong v1 = i;\n\t\tx = 1;\n\t\tfor(i = 1;; i++) {\n\t\t\tx = (a2 * x) % m2;\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tlong v2 = i;\n\t\tx = 1;\n\t\tfor(i = 1;; i++) {\n\t\t\tx = (a3 * x) % m3;\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tlong v3 = i;\n\t\tlong r = lcm(lcm(v1, v2), v3);\n\t\t\n\t\t\n\t\t// \u0089\u00f0\u0082\u00cc\u0095\\\u008e\u00a6\n\t\tSystem.out.printf(\"%d\\n\", r);\n\t\t\n\t\treturn true; // \u0090\u00b3\u008f\u00ed\u008fI\u0097\u00b9 \u008e\u009f\u0082\u00d6\n\t}\n\t\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\t\t\t\n\t\t\tString inputStr = \"1 459550\\n\";\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr)); \n\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // \u008f\u0091\u0082\u00ab\u008e\u00cc\u0082\u00c4\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // \u0083R\u0083\u0093\u0083\\\u0081[\u0083\u008b\u0082\u00a9\u0082\u00e7\n\t\t}\n\t\t\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; /*i < N*/; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t}\n\n\t\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\t\n\n\t// \u0095W\u008f\u0080\u0093\u00fc\u0097\u00cd\u0082\u00e6\u0082\u00e81\u008ds\u0095\u00aa\u0082\u00cc\u0083X\u0083y\u0081[\u0083X\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0082\u00cc\u0090\u00ae\u0090\u0094\u0092l\u0082\u00f0\u0093\u00c7\u0082\u00de\n\t// EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7\n\tprivate static int[] readIntArray() throws IOException {\n\t\t\n\t\tString s = reader.readLine();\n\t\tif (s == null)\n\t\t\treturn null;\n\t\tString[] sp = s.split(\" \");\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\t\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long a1 = sc.nextLong();\n            long m1 = sc.nextLong();\n            long a2 = sc.nextLong();\n            long m2 = sc.nextLong();\n            long a3 = sc.nextLong();\n            long m3 = sc.nextLong();\n            \n            if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) {\n                break;\n            }\n            \n            long period1 = findPeriod(a1, m1);\n            long period2 = findPeriod(a2, m2);\n            long period3 = findPeriod(a3, m3);\n            \n            long result = lcm(lcm(period1, period2), period3);\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n    \n    private static long findPeriod(long a, long m) {\n        long x = 1;\n        long period = 0;\n        \n        do {\n            x = (a * x) % m;\n            period++;\n        } while (x != 1);\n        \n        return period;\n    }\n    \n    private static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n    \n    private static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void s ; ++<extra_id_2>int m ;<extra_id_3>{ long<extra_id_4>= a .<extra_id_5>m = (long)<extra_id_6>= a /<extra_id_7>m<extra_id_8>;<extra_id_9>} private static<extra_id_10>gcd ( long b<extra_id_11>temp = gcd ( b<extra_id_12>b )<extra_id_13>long<extra_id_14>+= f ; i -=<extra_id_15>temp<extra_id_16>) {<extra_id_17>temp<extra_id_18>= b ;<extra_id_19>)<extra_id_20>temp == b<extra_id_21>; } } private<extra_id_22>int s<extra_id_23>a & m > m<extra_id_24> {  sc.nextLong(); long  0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) { break; }  long period3 = findPeriod(a3, m3); long result = lcm(lcm(period1, period2), period3); System.out.println(result); } sc.close(); } private static long findPeriod(long a, long m) { long x = 1; long period = 0; do { x = (a * x) % m; period++; } while (x != 1); return period; } private static long gcd(long a, long b) { while (b != 0) { long  temp; }  }"], "perturbed_original": ["import java.io.*; import java.util.*; // \u0082\u00e6\u0082\u00ad\u008a\u00d4\u0088\u00e1\u0082\u00a4\u0082\u00c6\u0082\u00b1\u0082\u00eb\u0081B // \u0096\u00e2\u0091\u00e8\u0095\u00b6\u0082\u00c9\u008f\u0091\u0082\u00a2\u0082\u00c4\u0082\u00c8\u0082\u00ad\u0082\u00c4\u0082\u00e0\u0096\u00e2\u0091\u00e8\u0083Z\u0083b\u0083g\u0082\u00cd\u0095\u00a1\u0090\u0094\u0082\u00c5\u0090\u00e6\u0093\u00aa\u0082\u00aa0\u0082\u00c5\u008fI\u0097\u00b9\u0082\u00c5\u0082 \u0082\u00e9\u0081B // \u0096\u00e2\u0091\u00e8\u0083Z\u0083b\u0083g\u0082\u00cc\u008cJ\u0082\u00e8\u0095\u00d4\u0082\u00b5\u008e\u009e\u0082\u00c9\u008f\u0089\u008a\u00fa\u0089\u00bb\u0098R\u0082\u00ea // 2011/10/18 //\u0081@0114 \u0094\u0088  while(b != 0) { long t = a % b; a = b; b = t; } return a; } long lcm(long a, long b) { return a * b / gcm(a, b); } // \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2 boolean main() throws IOException { int[] ri = readIntArray(); int a1 = ri[0]; int m1 =  == 0 &&  0  // \u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2 int i; int x = 1; for(i = 1;; i++) { x = (a1 * x) % m1; if (x   x) % m2; if (x == 1) break; } long v2 = i; x  } long v3 = i; long r = lcm(lcm(v1, v2), v3); // \u0089\u00f0\u0082\u00cc\u0095\\\u008e\u00a6 System.out.printf(\"%d\\n\", r); return true; // \u0090\u00b3\u008f\u00ed\u008fI\u0097\u00b9 \u008e\u009f\u0082\u00d6 } // private final static boolean DEBUG = true; // debug private final static boolean DEBUG = false; // release public static void  System.out; String inputStr = \"1 459550\\n\"; reader = new BufferedReader(new  reader = new BufferedReader(new InputStreamReader(System.in)); // \u0083R\u0083\u0093\u0083\\\u0081[\u0083\u008b\u0082\u00a9\u0082\u00e7 }   throws IOException { String s = reader.readLine(); if (s  a = new  a[i] = Integer.parseInt(sp[i]); } return a; } }"], "original_ll": -1.3960696458816528, "sampled_ll": -0.2965705692768097, "all_perturbed_sampled_ll": [-1.771913766860962], "all_perturbed_original_ll": [-2.233283281326294], "perturbed_sampled_ll": -1.771913766860962, "perturbed_original_ll": -2.233283281326294, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# AOJ 0114: Electro-Fly\n# Python3 2018.6.18 bal4u\n\nfrom math import gcd\n\nwhile True:\n\ta1, m1, a2, m2, a3, m3 = list(map(int, input().split()))\n\tif a1 == 0: break\n\tn = 0\n\tb1, b2, b3 = 1, 1, 1\n\ta, b, c = 0, 0, 0\n\twhile True:\n\t\tif a == 0: b1 = (b1 * a1) % m1\n\t\tif b == 0: b2 = (b2 * a2) % m2\n\t\tif c == 0: b3 = (b3 * a3) % m3\n\t\tn += 1\n\t\tif a == 0 and b1 == 1: a = n\n\t\tif b == 0 and b2 == 1: b = n\n\t\tif c == 0 and b3 == 1: c = n\n\t\tif a != 0 and b != 0 and c != 0: break\n\t\n\tans = a // gcd(a,b) * b\n\tans = ans // gcd(ans, c) * c\n\tprint(ans)\n\n", "sampled": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef order_mod(a, m):\n    \"\"\"Find the multiplicative order of a modulo m\"\"\"\n    if gcd(a, m) != 1:\n        return -1\n    \n    order = 1\n    current = a % m\n    while current != 1:\n        current = (current * a) % m\n        order += 1\n    return order\n\nwhile True:\n    line = list(map(int, input().split()))\n    if line == [0, 0, 0, 0, 0, 0]:\n        break\n    \n    a1, m1, a2, m2, a3, m3 = line\n    \n    # Find the order of each coordinate\n    order1 = order_mod(a1, m1)\n    order2 = order_mod(a2, m2)\n    order3 = order_mod(a3, m3)\n    \n    # The minimum number of moves is the LCM of the three orders\n    result = lcm(lcm(order1, order2), order3)\n    print(result)\n", "perturbed_sampled": ["import  a, b = b, a % b return a def lcm(a, b): return a *  order of a modulo m\"\"\" if gcd(a, m) != 1: return -1 order = 1 current = a % m while current != 1: current = (current *  line = list(map(int, input().split())) if line ==   each coordinate order1 = order_mod(a1, m1) order2 = order_mod(a2, m2) order3  the LCM of the three orders result = lcm(lcm(order1, order2), order3) print(result)"], "perturbed_original": ["# AOJ 0114: Electro-Fly # Python3 2018.6.18 bal4u from math import gcd while True: a1, m1, a2, m2, a3, m3 = list(map(int, input().split())) if a1 ==  while True:  m1 if b == 0: b2 = (b2 * a2) % m2 if c == 0: b3 = (b3 *  if c == 0 and b3 == 1: c = n if a != 0 and b != 0 and c != 0: break ans = a  * c print(ans)"], "original_ll": -1.010331392288208, "sampled_ll": -0.6145464181900024, "all_perturbed_sampled_ll": [-2.2572429180145264], "all_perturbed_original_ll": [-2.4712975025177], "perturbed_sampled_ll": -2.2572429180145264, "perturbed_original_ll": -2.4712975025177, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,h,w,min,ans,mat[700][700],max[700][700];\nchar c;\n\nint main(){\n\twhile(scanf(\"%d %d\",&h,&w)*h*w){\n\t\tfor(i=0;i<h;i++){\n\t\t\tk=0;\n\t\t\tscanf(\"\\n\");\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\"%c\",&c);\n\t\t\t\tif(c=='.')k++; else k=0;\n\t\t\t\tmat[i][j]=k;\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tfor(j=w-1;j>=0;j--){\n\t\t\tfor(k=h-1;k>=0;k--){\n\t\t\t\tmin=mat[k][j];\n\t\t\t\tfor(i=1;i+k<h;i++){\n\t\t\t\t\tif(min>mat[i+k][j])min=mat[i+k][j];\n\t\t\t\t\tif(min==0)break;\n\t\t\t\t\tif(min*(i+1)>ans)ans=min*(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int H, W;\n    char grid[505][505];\n    int height[505][505];\n    \n    while (scanf(\"%d %d\", &H, &W) == 2 && (H || W)) {\n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        // Calculate height array\n        memset(height, 0, sizeof(height));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == '.') {\n                    if (i == 0) {\n                        height[i][j] = 1;\n                    } else {\n                        height[i][j] = height[i-1][j] + 1;\n                    }\n                } else {\n                    height[i][j] = 0;\n                }\n            }\n        }\n        \n        int maxArea = 0;\n        \n        // For each row, find largest rectangle in histogram\n        for (int i = 0; i < H; i++) {\n            // For each column as left boundary\n            for (int left = 0; left < W; left++) {\n                if (height[i][left] == 0) continue;\n                \n                int minHeight = height[i][left];\n                for (int right = left; right < W; right++) {\n                    if (height[i][right] == 0) break;\n                    \n                    if (height[i][right] < minHeight) {\n                        minHeight = height[i][right];\n                    }\n                    \n                    int width = right - left + 1;\n                    int area = minHeight * width;\n                    if (area > maxArea) {\n                        maxArea = area;\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", maxArea);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int  W)) { for (int i = 0; i <  memset(height, 0, sizeof(height)); for (int i =  '.')  else { height[i][j] = height[i-1][j] + 1; } } else {  // For each row,  i < H; i++) { // For  left < W; left++) { if (height[i][left] == 0) continue; int minHeight = height[i][left]; for (int right = left; right < W; right++) { if (height[i][right] == 0) break; if (height[i][right] < minHeight) { minHeight = height[i][right]; } int width = right - left + 1; int area = minHeight * width; if (area  printf(\"%d\\n\", maxArea); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int i,j,k,h,w,min,ans,mat[700][700],max[700][700]; char c; int main(){ while(scanf(\"%d %d\",&h,&w)*h*w){ for(i=0;i<h;i++){  } } printf(\"%d\\n\",ans); } return 0; }"], "original_ll": -0.9389068484306335, "sampled_ll": -0.4290648102760315, "all_perturbed_sampled_ll": [-1.450897216796875], "all_perturbed_original_ll": [-1.7801275253295898], "perturbed_sampled_ll": -1.450897216796875, "perturbed_original_ll": -1.7801275253295898, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n//Rectangular Searching\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif((h|w)==0)break;\n\t\t\tchar[][] m = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)m[i]=sc.next().toCharArray();\n\t\t\tint[][] c = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tint x = 1;\n\t\t\t\tfor(int j=w-1;j>=0;j--){\n\t\t\t\t\tif(m[i][j]=='.'){\n\t\t\t\t\t\tc[i][j] = x++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tc[i][j] = 0;\n\t\t\t\t\t\tx = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(0<i&&c[i][j]==c[i-1][j]||c[i][j]==0)continue;\n\t\t\t\t\tint k = 1;\n\t\t\t\t\tint min = c[i][j];\n\t\t\t\t\tmax = Math.max(max, k*min);\n\t\t\t\t\twhile(i+k<h&&c[i+k][j]>0){\n\t\t\t\t\t\tmin = Math.min(min, c[i+k][j]);\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tmax = Math.max(max, k*min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int H = sc.nextInt();\n            int W = sc.nextInt();\n            \n            if (H == 0 && W == 0) break;\n            \n            sc.nextLine();\n            char[][] grid = new char[H][W];\n            \n            for (int i = 0; i < H; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            \n            int[][] height = new int[H][W];\n            \n            for (int j = 0; j < W; j++) {\n                for (int i = 0; i < H; i++) {\n                    if (grid[i][j] == '*') {\n                        height[i][j] = 0;\n                    } else {\n                        if (i == 0) {\n                            height[i][j] = 1;\n                        } else {\n                            height[i][j] = height[i-1][j] + 1;\n                        }\n                    }\n                }\n            }\n            \n            int maxArea = 0;\n            \n            for (int i = 0; i < H; i++) {\n                maxArea = Math.max(maxArea, largestRectangleInHistogram(height[i]));\n            }\n            \n            System.out.println(maxArea);\n        }\n        \n        sc.close();\n    }\n    \n    static int largestRectangleInHistogram(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        int n = heights.length;\n        \n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && heights[i] < heights[stack.peek()]) {\n                int h = heights[stack.pop()];\n                int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            stack.push(i);\n        }\n        \n        while (!stack.isEmpty()) {\n            int h = heights[stack.pop()];\n            int w = stack.isEmpty() ? n : n - stack.peek() - 1;\n            maxArea = Math.max(maxArea, h * w);\n        }\n        \n        return maxArea;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int  0 && W == 0) break; sc.nextLine(); char[][] grid = new char[H][W]; for (int i = 0; i  j = 0; j < W; j++) { grid[i][j] = line.charAt(j); } } int[][] height = new int[H][W]; for (int j =  {   H; i++) { maxArea = Math.max(maxArea, largestRectangleInHistogram(height[i])); } System.out.println(maxArea); } sc.close(); } static int largestRectangleInHistogram(int[] heights) { Stack<Integer> stack = new Stack<>();  (!stack.isEmpty() && heights[i] < heights[stack.peek()]) { int h = heights[stack.pop()]; int w = stack.isEmpty() ? i : i - stack.peek() - 1; maxArea = Math.max(maxArea, h  = heights[stack.pop()]; int w = stack.isEmpty() ? n :  w); } return maxArea; } }"], "perturbed_original": ["import java.util.Scanner; //Rectangular Searching public class Main{ public static void main(String[] args) { Scanner  w = sc.nextInt(); if((h|w)==0)break; char[][] m = new  x++; } else{ c[i][j] = 0; x = 1; } } }  k = 1;  = Math.min(min, c[i+k][j]); k++; max = Math.max(max, k*min); } } } System.out.println(max); } } }"], "original_ll": -0.6733659505844116, "sampled_ll": -0.23286686837673187, "all_perturbed_sampled_ll": [-1.246988296508789], "all_perturbed_original_ll": [-2.6328587532043457], "perturbed_sampled_ll": -1.246988296508789, "perturbed_original_ll": -2.6328587532043457, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import product\nwhile(True):\n    H,W = map(int,input().split())\n    if not H: break\n    ma = 0\n    for i in range(H):\n        ma |= (int(input().replace(\".\",\"0\").replace(\"*\",\"1\"),2) << ((H-i-1)*W))\n    flag = False\n    hw = [[h,w] for h,w in product(range(H,0,-1),range(W,0,-1))]\n    hw = sorted(hw,key=lambda x: -x[1]*x[0])\n    ans = 0\n    for h,w in hw:\n        for i,j in product(range(H-h+1),range(W-w+1)):\n            b = (sum([((2**w-1) << j) << k*W for k in range(h)]) ) << i*W\n            c = ma&b\n            if not c :flag = True; ans = max(ans,h*w); break\n        else:\n            continue\n        if flag: break\n    print(ans)\n\n", "sampled": "def maximal_rectangle(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    \n    H = len(matrix)\n    W = len(matrix[0])\n    \n    # Build height matrix\n    heights = [[0] * W for _ in range(H)]\n    \n    for j in range(W):\n        for i in range(H):\n            if matrix[i][j] == '.':\n                if i == 0:\n                    heights[i][j] = 1\n                else:\n                    heights[i][j] = heights[i-1][j] + 1\n            else:\n                heights[i][j] = 0\n    \n    # Find max rectangle for each row using histogram method\n    max_area = 0\n    \n    for i in range(H):\n        max_area = max(max_area, largest_rectangle_in_histogram(heights[i]))\n    \n    return max_area\n\ndef largest_rectangle_in_histogram(heights):\n    stack = []\n    max_area = 0\n    index = 0\n    \n    while index < len(heights):\n        if not stack or heights[index] >= heights[stack[-1]]:\n            stack.append(index)\n            index += 1\n        else:\n            top = stack.pop()\n            width = index if not stack else index - stack[-1] - 1\n            area = heights[top] * width\n            max_area = max(max_area, area)\n    \n    while stack:\n        top = stack.pop()\n        width = index if not stack else index - stack[-1] - 1\n        area = heights[top] * width\n        max_area = max(max_area, area)\n    \n    return max_area\n\nwhile True:\n    line = input().split()\n    H, W = int(line[0]), int(line[1])\n    \n    if H == 0 and W == 0:\n        break\n    \n    matrix = []\n    for _ in range(H):\n        row = input().strip()\n        matrix.append(row)\n    \n    result = maximal_rectangle(matrix)\n    print(result)\n", "perturbed_sampled": ["def maximal_rectangle(matrix): if not matrix or not matrix[0]: return 0 H  = [[0] * W for _ in range(H)]  == '.': if i == 0: heights[i][j]  = 0 #  = 0 for i in range(H): max_area = max(max_area, largest_rectangle_in_histogram(heights[i])) return max_area def largest_rectangle_in_histogram(heights):  index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top =  - 1 area = heights[top] * width max_area = max(max_area, area) return max_area while True: line = input().split() H, W = int(line[0]), int(line[1]) if H == 0 and W == 0: break matrix = [] for _ in range(H): row = input().strip() matrix.append(row) result = maximal_rectangle(matrix) print(result)"], "perturbed_original": ["from itertools import product while(True): H,W = map(int,input().split()) if not H: break  << ((H-i-1)*W)) flag  = sorted(hw,key=lambda x: -x[1]*x[0]) ans =  = (sum([((2**w-1) << j) << k*W for k in range(h)]) ) << i*W c = ma&b if  continue if flag: break print(ans)"], "original_ll": -1.3689463138580322, "sampled_ll": -0.36668893694877625, "all_perturbed_sampled_ll": [-1.4842402935028076], "all_perturbed_original_ll": [-3.3660166263580322], "perturbed_sampled_ll": -1.4842402935028076, "perturbed_original_ll": -3.3660166263580322, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#define rep(i,n) for(i=0;i<n;i++)\nint min(int a,int b){return a<b?a:b;}\nint main(void)\n{\n  int n,m,mat[20][20],i,j,k,a,b,c,d;\n  scanf(\"%d%d\",&n,&m);\n  rep(i,n)rep(j,n)mat[i][j]=i-j?1<<21:0;\n  rep(i,m){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--;\n    mat[a][b]=c;mat[b][a]=d;\n  }\n  rep(i,n)rep(j,n)rep(k,n)mat[j][k]=min(mat[j][k],mat[j][i]+mat[i][k]);\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--;\n  printf(\"%d\\n\",c-mat[a][b]-mat[b][a]-d);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 21\n#define INF INT_MAX\n\nint n, m;\nint cost[MAX_N][MAX_N];\nint dist[MAX_N];\nint visited[MAX_N];\n\nvoid dijkstra(int start) {\n    for (int i = 1; i <= n; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    dist[start] = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int u = -1;\n        int minDist = INF;\n        for (int j = 1; j <= n; j++) {\n            if (!visited[j] && dist[j] < minDist) {\n                minDist = dist[j];\n                u = j;\n            }\n        }\n        \n        if (u == -1) break;\n        visited[u] = 1;\n        \n        for (int v = 1; v <= n; v++) {\n            if (cost[u][v] != INF && dist[u] != INF) {\n                if (dist[u] + cost[u][v] < dist[v]) {\n                    dist[v] = dist[u] + cost[u][v];\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cost[i][j] = INF;\n        }\n    }\n    \n    for (int i = 0; i < m; i++) {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        cost[a][b] = c;\n        cost[b][a] = d;\n    }\n    \n    int s, g, V, P;\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n    \n    dijkstra(s);\n    int costToG = dist[g];\n    \n    dijkstra(g);\n    int costFromG = dist[s];\n    \n    int totalCost = costToG + costFromG + P;\n    int reward = V - totalCost;\n    \n    printf(\"%d\\n\", reward);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h> #define  dist[i]  (int i = 0;  minDist = INF; for (int j = 1;  minDist) { minDist = dist[j]; u = j; } } if (u  1; v <= n; v++) { if (cost[u][v] != INF && dist[u] != INF) { if (dist[u] + cost[u][v] < dist[v]) { dist[v] = dist[u] + cost[u][v]; } } } } } int main() { scanf(\"%d\", &n); scanf(\"%d\", &m); for (int i = 1; i <=  n; j++) { cost[i][j] = INF; } } for (int i = 0; i < m; i++) { int a, b, c, d; scanf(\"%d,%d,%d,%d\", &a, &b, &c,  int totalCost = costToG + costFromG + P; int reward = V - totalCost; printf(\"%d\\n\", reward); return 0; }"], "perturbed_original": ["#include<stdio.h> #define rep(i,n) for(i=0;i<n;i++) int min(int a,int b){return a<b?a:b;} int main(void) {  printf(\"%d\\n\",c-mat[a][b]-mat[b][a]-d); return 0; }"], "original_ll": -0.9509952664375305, "sampled_ll": -0.3812393844127655, "all_perturbed_sampled_ll": [-1.5204647779464722], "all_perturbed_original_ll": [-2.152554750442505], "perturbed_sampled_ll": -1.5204647779464722, "perturbed_original_ll": -2.152554750442505, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final int INF = Integer.MAX_VALUE;\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\t}\n\t\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\t//int[][] d = new int[n][n]; \n\t\tint m = sc.nextInt();\n\t\tint[][] road = new int[m][4];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tString s = sc.next();\n\t\t\tString[] ss = s.split(\",\");\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\troad[i][j] = Integer.parseInt(ss[j]);\n\t\t\t}\n\t\t}\n\t\tint[] input = new int[4];\n\t\tString s = sc.next();\n\t\tString[] ss = s.split(\",\");\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tinput[j] = Integer.parseInt(ss[j]);\n\t\t}\n\t\tint start = input[0];\n\t\tint goal = input[1];\n\t\t//start\u304b\u3089goal\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u6c42\u3081\u308b\n\t\t//start\u304b\u3089\u306e\u8ddd\u96e2\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\td[start - 1] = 0;\n\t\twhile(true){\n\t\t\tboolean bChange = false;\n\t\t\t//\u9053\u3092\u898b\u3066\u3044\u304f\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint from = road[i][0];\n\t\t\t\tint to = road[i][1];\n\t\t\t\tint cost = road[i][2];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfrom = road[i][1];\n\t\t\t\tto = road[i][0];\n\t\t\t\tcost = road[i][3];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//print(d);\n\t\t\tif(bChange == false) break;\n\t\t}\n\t\tint sum = d[goal - 1];\n\t\t\n\t\t//\u4eca\u5ea6\u306f\u30b4\u30fc\u30eb\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2\n\t\tstart = input[1];\n\t\tgoal = input[0];\n\t\tArrays.fill(d, INF);\n\t\td[start - 1] = 0;\n\t\twhile(true){\n\t\t\tboolean bChange = false;\n\t\t\t//\u9053\u3092\u898b\u3066\u3044\u304f\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint from = road[i][0];\n\t\t\t\tint to = road[i][1];\n\t\t\t\tint cost = road[i][2];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfrom = road[i][1];\n\t\t\t\tto = road[i][0];\n\t\t\t\tcost = road[i][3];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//print(d);\n\t\t\tif(bChange == false) break;\n\t\t}\n\t\t//System.out.println(d[goal - 1]);\n\t\tsum += d[goal - 1];\n\t\t\n\t\tSystem.out.println(input[2] - input[3] - sum);\n\t\t\n\t}\n\t\n\tpublic static void print(int[] d){\n\t\tfor(int a : d){\n\t\t\tSystem.out.print(a + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to;\n        int cost;\n        \n        Edge(int to, int cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        sc.nextLine();\n        \n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            int c = Integer.parseInt(parts[2]);\n            int d = Integer.parseInt(parts[3]);\n            \n            graph.get(a).add(new Edge(b, c));\n            graph.get(b).add(new Edge(a, d));\n        }\n        \n        String[] lastLine = sc.nextLine().split(\",\");\n        int s = Integer.parseInt(lastLine[0]);\n        int g = Integer.parseInt(lastLine[1]);\n        int V = Integer.parseInt(lastLine[2]);\n        int P = Integer.parseInt(lastLine[3]);\n        \n        int[] distToG = dijkstra(graph, n, s, g);\n        int[] distFromG = dijkstra(graph, n, g, s);\n        \n        int minCost = distToG[g] + distFromG[s];\n        int reward = V - P - minCost;\n        \n        System.out.println(reward);\n        \n        sc.close();\n    }\n    \n    static int[] dijkstra(List<List<Edge>> graph, int n, int start, int end) {\n        int[] dist = new int[n + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        pq.offer(new int[]{start, 0});\n        \n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int u = curr[0];\n            int d = curr[1];\n            \n            if (d > dist[u]) continue;\n            \n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                int newDist = dist[u] + edge.cost;\n                \n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.offer(new int[]{v, newDist});\n                }\n            }\n        }\n        \n        return dist;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static  } public static void main(String[] args) { Scanner sc  sc.nextInt();  0; i <= n; i++) { graph.add(new ArrayList<>()); } for (int i = 0; i < m; i++) { String line = sc.nextLine();  = Integer.parseInt(parts[1]); int c = Integer.parseInt(parts[2]); int d = Integer.parseInt(parts[3]); graph.get(a).add(new Edge(b, c)); graph.get(b).add(new Edge(a, d)); } String[] lastLine = sc.nextLine().split(\",\"); int s = Integer.parseInt(lastLine[0]); int g = Integer.parseInt(lastLine[1]); int V = Integer.parseInt(lastLine[2]); int P = Integer.parseInt(lastLine[3]); int[] distToG = dijkstra(graph, n, s, g); int[] distFromG = dijkstra(graph, n, g,  int[] dijkstra(List<List<Edge>> graph, int n, int  new PriorityQueue<>((a, b) -> a[1] - b[1]);   > dist[u]) continue; for (Edge edge : graph.get(u)) { int v = edge.to; int newDist = dist[u] + edge.cost; if (newDist < dist[v]) { dist[v] =  }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { /** * @param args */ public static final int INF = Integer.MAX_VALUE; public static void main(String[] args) { doIt(); } public static void doIt(){ Scanner sc = new Scanner(System.in); int n = sc.nextInt(); //int[][] d = new int[n][n]; int m = sc.nextInt(); int[][] road = new  = 0; j < 4; j++){ road[i][j] = Integer.parseInt(ss[j]); } } int[] input =  for(int j = 0; j < 4; j++){ input[j] = Integer.parseInt(ss[j]); } int start =  0;  = road[i][1]; int cost = road[i][2];  d[from -  to = road[i][0]; cost = road[i][3]; if(d[from - 1] != INF && d[from -  } } //print(d); if(bChange == false) break; } int sum = d[goal - 1]; //\u4eca\u5ea6\u306f\u30b4\u30fc\u30eb\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2 start = input[1]; goal = input[0]; Arrays.fill(d, INF); d[start - 1]  = 0; i < m; i++){ int from = road[i][0]; int to = road[i][1]; int cost = road[i][2]; if(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){ d[to - 1] = d[from - 1] + cost; bChange = true; }  d[from - 1] + cost; bChange = true; } } //print(d); if(bChange == false) break; } //System.out.println(d[goal - 1]); sum += d[goal - 1]; System.out.println(input[2]  System.out.println(); } }"], "original_ll": -0.4383089244365692, "sampled_ll": -0.3426697552204132, "all_perturbed_sampled_ll": [-1.3367489576339722], "all_perturbed_original_ll": [-1.397267460823059], "perturbed_sampled_ll": -1.3367489576339722, "perturbed_original_ll": -1.397267460823059, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def floyd(P,m):\n    for k in range(m):\n        for i in range(m):\n            for j in range(m):\n                P[i][j]=min(P[i][j],P[i][k]+P[k][j])\n\nn=input()\nm=input()\nINF=1e10\nC=[[INF]*n for i in range(n)]\nfor i in range(n):\n    C[i][i]=0\nfor i in range(m):\n    a1,b1,c1,d1=map(int,raw_input().split(\",\"))\n    C[a1-1][b1-1]=c1\n    C[b1-1][a1-1]=d1\nfloyd(C,n)\nx1,x2,y1,y2=map(int,raw_input().split(\",\"))\nprint y1-y2-C[x1-1][x2-1]-C[x2-1][x1-1]", "sampled": "import sys\nfrom collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start, n):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, cost in graph[u]:\n            if dist[u] + cost < dist[v]:\n                dist[v] = dist[u] + cost\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist\n\nn = int(input())\nm = int(input())\n\ngraph_forward = defaultdict(list)\ngraph_backward = defaultdict(list)\n\nfor _ in range(m):\n    line = input().strip()\n    parts = line.split(',')\n    a = int(parts[0])\n    b = int(parts[1])\n    c = int(parts[2])\n    d = int(parts[3])\n    \n    graph_forward[a].append((b, c))\n    graph_backward[b].append((a, d))\n\nlast_line = input().strip()\nparts = last_line.split(',')\ns = int(parts[0])\ng = int(parts[1])\nV = int(parts[2])\nP = int(parts[3])\n\ndist_from_s = dijkstra(graph_forward, s, n)\ndist_from_g = dijkstra(graph_backward, g, n)\n\ntotal_cost = dist_from_s[g] + dist_from_g[s] + P\nreward = V - total_cost\n\nprint(reward)\n", "perturbed_sampled": ["import sys from collections import defaultdict import heapq def dijkstra(graph, start, n): dist = [float('inf')] * (n + 1) dist[start] = 0 pq = [(0, start)] while pq: d, u = heapq.heappop(pq) if d > dist[u]: continue for v, cost in graph[u]: if  = int(input()) graph_forward = defaultdict(list) graph_backward = defaultdict(list) for _ in range(m):  c)) graph_backward[b].append((a, d)) last_line = input().strip() parts = last_line.split(',') s = int(parts[0])  total_cost = dist_from_s[g] + dist_from_g[s] + P reward = V - total_cost print(reward)"], "perturbed_original": ["def floyd(P,m): for k in range(m):  m=input() INF=1e10 C=[[INF]*n for i in range(n)] for i in range(n): C[i][i]=0 for i in range(m): a1,b1,c1,d1=map(int,raw_input().split(\",\")) C[a1-1][b1-1]=c1 C[b1-1][a1-1]=d1 floyd(C,n) x1,x2,y1,y2=map(int,raw_input().split(\",\")) print y1-y2-C[x1-1][x2-1]-C[x2-1][x1-1]"], "original_ll": -0.7996338605880737, "sampled_ll": -0.5793449878692627, "all_perturbed_sampled_ll": [-1.7241346836090088], "all_perturbed_original_ll": [-1.3191496133804321], "perturbed_sampled_ll": -1.7241346836090088, "perturbed_original_ll": -1.3191496133804321, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\n#define MAX 100\nchar farm[MAX][MAX];\n\nvoid divide(int i, int j, int H, int W, char moji)\n{\n    if( farm[i][j] == moji ){\n        farm[i][j] = '+';\n        if( j + 1 < W ) divide(i, j + 1, H, W, moji);\n        if( i + 1 < H ) divide(i + 1, j, H, W, moji);\n        if( j - 1 >= 0 )divide(i, j - 1, H, W, moji);\n        if( i - 1 >= 0 )divide(i - 1, j, H, W, moji);\n    }\n}\n\nint main()\n{\n    int H, W, i, j, cnt;\n    while(1){\n        cnt = 0;\n        scanf(\"%d %d\", &H, &W);\n        if(H == 0 && W == 0) break;\n\n        for(i = 0; i < H; i++){\n            scanf(\"%s\", farm[i]);\n        }\n        for(i = 0; i < H; i++ ){\n            for(j = 0; j < W; j++){\n                if(farm[i][j] == '+') continue;\n                cnt++;\n                divide(i, j, H, W, farm[i][j]);\n            }\n        }\n        printf(\"%d\\n\", cnt);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nchar grid[100][101];\nint visited[100][100];\nint H, W;\n\nvoid dfs(int i, int j, char c) {\n    if (i < 0 || i >= H || j < 0 || j >= W) return;\n    if (visited[i][j]) return;\n    if (grid[i][j] != c) return;\n    \n    visited[i][j] = 1;\n    \n    dfs(i-1, j, c);\n    dfs(i+1, j, c);\n    dfs(i, j-1, c);\n    dfs(i, j+1, c);\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &H, &W);\n        if (H == 0 && W == 0) break;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        memset(visited, 0, sizeof(visited));\n        \n        int count = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (!visited[i][j]) {\n                    dfs(i, j, grid[i][j]);\n                    count++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> char grid[100][101]; int visited[100][100]; int H, W;  0 || j >=  visited[i][j] = 1; dfs(i-1, j, c);  int main() { while (1) { scanf(\"%d %d\", &H, &W); if (H  = 0; i < H; i++) { scanf(\"%s\", grid[i]); } memset(visited, 0, sizeof(visited)); int count = 0; for (int i = 0; i < H; i++) { for (int j = 0; j < W;  } } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["#include<stdio.h> #define MAX 100 char +=<extra_id_3>j,<extra_id_4>W, H);<extra_id_5>- (H <<<extra_id_6>{ for( i<extra_id_7>j; i<H;<extra_id_8>= [<extra_id_9>[j]); if(i <<extra_id_10>j ; j++){<extra_id_11>j);<extra_id_12>= j-1; char moji) { if( farm[i][j] == moji ){ farm[i][j] = <extra_id_13>) i<extra_id_14>j ]<extra_id_15>] =<extra_id_16>farm[i][ +  ) divide(i + 1, j,  1 >= 0 )divide(i - 1, j, H, W, moji); } } int main() { int H, W, i, j, cnt; while(1){ cnt = 0; scanf(\"%d %d\", &H, &W); if(H == 0 && W == 0) break; for(i = 0; i < H; i++){ scanf(\"%s\", farm[i]);  = 0;  j, H, W, farm[i][j]); } } printf(\"%d\\n\", cnt); } return 0; }"], "original_ll": -0.5726313591003418, "sampled_ll": -0.2833107113838196, "all_perturbed_sampled_ll": [-1.271243929862976], "all_perturbed_original_ll": [-2.36466908454895], "perturbed_sampled_ll": -1.271243929862976, "perturbed_original_ll": -2.36466908454895, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\t\n\tint[][] offset = new int[][]{\n\t\t\t{-1, 0}, {1, 0}, {0, -1}, {0, 1}\n\t};\n\n\n\tpublic Main() throws IOException, StackOverflowError{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> Ans = new ArrayList<Integer>();\n\t\tString line = in.readLine();\n\t\tString[] dst = line.split(\" \");\n\t\tInteger.parseInt(dst[0]);\n\n\t\t\n\t}\n\n\tpublic void grouping(int[][] data, int[][] label, int x, int y){\n\t\tList<point> cue = new ArrayList<point>();\n\t\tcue.add(new point(x, y));\n\t\twhile(cue.size() != 0){\n\t\t\tpoint p = cue.get(0);\n\t\t\tcue.remove(0);\n\t\t\tfor(int d=0; d<4; d++){\n\t\t\t\tint xx = p.x + offset[d][0];\n\t\t\t\tint yy = p.y + offset[d][1];\n\t\t\t\tif(label[yy][xx] == 0 && data[yy][xx] == data[p.y][p.x]){\n\t\t\t\t\tlabel[yy][xx] = label[p.y][p.x];\n\t\t\t\t\tcue.add(new point(xx, yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass point{\n\tint x;\n\tint y;\n\t\n\tpublic point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int H, W;\n    static char[][] grid;\n    static boolean[][] visited;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            H = sc.nextInt();\n            W = sc.nextInt();\n            \n            if (H == 0 && W == 0) break;\n            \n            grid = new char[H][W];\n            visited = new boolean[H][W];\n            \n            for (int i = 0; i < H; i++) {\n                String line = sc.next();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            \n            int count = 0;\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (!visited[i][j]) {\n                        dfs(i, j, grid[i][j]);\n                        count++;\n                    }\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n    \n    static void dfs(int x, int y, char fruit) {\n        if (x < 0 || x >= H || y < 0 || y >= W) return;\n        if (visited[x][y]) return;\n        if (grid[x][y] != fruit) return;\n        \n        visited[x][y] = true;\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            dfs(nx, ny, fruit);\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int H, W; static char[][] grid; static boolean[][] visited; static int[] dx = {-1, 1, 0, 0}; static int[] dy = {0, 0, -1, 1}; public static  (true) { H =  == 0) break; grid = new char[H][W]; visited = new boolean[H][W]; for (int i = 0; i < H; i++) { String line = sc.next();  grid[i][j] = line.charAt(j); } } int count =    || x >= H || y < 0 || y >= W) return; if (visited[x][y]) return; if (grid[x][y] != fruit) return; visited[x][y] = true;  int  dy[i]; dfs(nx, ny, fruit); } } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static void main(String args[]){ try{ new Main(); }catch(IOException [ [d+1])<extra_id_8>for ( p=new<extra_id_9>( ) ;<extra_id_10>++ ) {<extra_id_11>+<extra_id_12>}<extra_id_13>< 4; m++){ int xx<extra_id_14>. x ;<extra_id_15>else{ this.x = ( int<extra_id_16>) + 0}, {1, 0}, {0, -1}, {0, 1} };  InputStreamReader(System.in)); List<Integer> Ans = new ArrayList<Integer>(); String line = in.readLine(); String[] dst = line.split(\" \"); Integer.parseInt(dst[0]); } public void grouping(int[][] data, int[][] label, int  y));  d<4; d++){ int xx = p.x +  yy)); }  public point(int x, int y){ this.x = x; this.y = y; } }"], "original_ll": -0.8477228879928589, "sampled_ll": -0.22697803378105164, "all_perturbed_sampled_ll": [-1.4109835624694824], "all_perturbed_original_ll": [-2.7542366981506348], "perturbed_sampled_ll": -1.4109835624694824, "perturbed_original_ll": -2.7542366981506348, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def wa(h, w, f):\n    if not (0 <= h <= H-1 and 0 <= w <= W-1):\n        return\n    elif mapp[h][w] != f:\n        return\n    else:\n        mapp[h][w] = '$'\n        wa(h, w+1, f)\n        wa(h-1, w, f)\n        wa(h, w-1, f)\n        wa(h+1, w, f)\n\nwhile True:\n    H, W = map(int, raw_input().split(' '))\n    if H == 0: break\n    mapp = [list(raw_input()) for i in range(H)]\n    count = 0\n    for h in range(H):\n        for w in range(W):\n            if mapp[h][w] == '@':\n                wa(h, w, '@')\n            elif mapp[h][w] == '#':\n                wa(h, w, '#')\n            elif mapp[h][w] == '*':\n                wa(h, w, '*')\n            else:\n                continue\n            count += 1\n    else:\n        print count", "sampled": "def count_regions(H, W, grid):\n    visited = [[False] * W for _ in range(H)]\n    count = 0\n    \n    def dfs(i, j, fruit_type):\n        if i < 0 or i >= H or j < 0 or j >= W:\n            return\n        if visited[i][j]:\n            return\n        if grid[i][j] != fruit_type:\n            return\n        \n        visited[i][j] = True\n        dfs(i-1, j, fruit_type)\n        dfs(i+1, j, fruit_type)\n        dfs(i, j-1, fruit_type)\n        dfs(i, j+1, fruit_type)\n    \n    for i in range(H):\n        for j in range(W):\n            if not visited[i][j]:\n                dfs(i, j, grid[i][j])\n                count += 1\n    \n    return count\n\nwhile True:\n    line = input().split()\n    H, W = int(line[0]), int(line[1])\n    \n    if H == 0 and W == 0:\n        break\n    \n    grid = []\n    for _ in range(H):\n        grid.append(input().strip())\n    \n    result = count_regions(H, W, grid)\n    print(result)\n", "perturbed_sampled": ["def count_regions(H,  i < 0 or i >= H or j < 0 or j >= W: return if visited[i][j]:  j, fruit_type) dfs(i+1, j, fruit_type) dfs(i, j-1, fruit_type) dfs(i, j+1, fruit_type) for i in range(H): for j in range(W): if not visited[i][j]: dfs(i, j,  input().split() H, W =  break grid = [] for _ in range(H): grid.append(input().strip()) result = count_regions(H, W, grid) print(result)"], "perturbed_original": [" mapp[h][w] != f: return else: mapp[h][w] = '$' wa(h, w+1, f) wa(h-1, w, f) wa(h, w-1, f) wa(h+1,  if H == 0:  0 for h in range(H): for w in range(W): if mapp[h][w] == '@': wa(h, w, '@') elif mapp[h][w] == '#': wa(h, w, '#') elif mapp[h][w] == '*': wa(h, w, '*') else: continue count += 1 else: print count"], "original_ll": -0.7019229531288147, "sampled_ll": -0.3945903480052948, "all_perturbed_sampled_ll": [-1.7710100412368774], "all_perturbed_original_ll": [-1.4395296573638916], "perturbed_sampled_ll": -1.7710100412368774, "perturbed_original_ll": -1.4395296573638916, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0119\nTitle Taro's obsession\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define SHOUGENNO 100\n#define NINZUU 20\nint n,m;\nint x[SHOUGENNO],y[SHOUGENNO];\nint flag[NINZUU+1];\n//\nvoid show()\n{\n  int i;\n  for(i=1;i<=n;i++)\n    printf(\"%d:\",flag[i]);\n  printf(\"\\n\");\n}\nmain()\n{\n  int i,cnt;\n\n  scanf(\"%d \",&n);\n  scanf(\"%d \",&m);\n  for(i=0;i<m;i++)\n    scanf(\"%d %d\",&x[i],&y[i]);\n  for(i=0;i<n;i++)\n    flag[i]=0;\n\n  cnt=n;\n\n  while(cnt>1)\n    {\n      for(i=1;i<=n;i++)\n\tif(flag[i]>0)\n\t  flag[i]=0;\n      //show();\n      for(i=0;i<m;i++)\n\tif(flag[x[i]]!=-1)\n\t  flag[y[i]]=1;\n      for(i=1;i<=n;i++)\n\t{\n\t  if(flag[i]==0 && i!=2)\n\t    {\n\t      printf(\"%d\\n\",i);\n\t      cnt--;\n\t      flag[i]=-1;\n\t    }\n\t}\n      //show();\n    }\n  printf(\"2\\n\");\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int m, n;\n    scanf(\"%d\", &m);\n    scanf(\"%d\", &n);\n    \n    int adj[21][21] = {0};\n    int indegree[21] = {0};\n    \n    for (int i = 0; i < n; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        if (!adj[x][y]) {\n            adj[x][y] = 1;\n            indegree[y]++;\n        }\n    }\n    \n    int result[21];\n    int used[21] = {0};\n    int pos = 0;\n    \n    while (pos < m) {\n        for (int i = 1; i <= m; i++) {\n            if (used[i]) continue;\n            if (indegree[i] == 0) {\n                result[pos++] = i;\n                used[i] = 1;\n                for (int j = 1; j <= m; j++) {\n                    if (adj[i][j]) {\n                        indegree[j]--;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    \n    for (int i = 0; i < m; i++) {\n        printf(\"%d\\n\", result[i]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include x,<extra_id_1>; // In<extra_id_2>x, y; scanf(\"%d %d %d<extra_id_3>=<extra_id_4>; // In<extra_id_5>adj[adj[adj][adj][adj[adj][adj][adj][indegree][adj] ==<extra_id_6>) { indegree[indegree][i]; }<extra_id_7>=<extra_id_8>{1,<extra_id_9>{0};<extra_id_10>= 0; } switch<extra_id_11>case<extra_id_12>1; for<extra_id_13>{ 3<extra_id_14>1; continue; if ( &m); scanf(\"%d\", &n); int adj[21][21] = {0}; int indegree[21] = {0}; for  x, y; scanf(\"%d %d\", &x, &y);  result[21]; int used[21] = {0}; int pos = 0; while (pos < m) { for (int i = 1; i <= m; i++) { if (used[i]) continue; if (indegree[i] == 0) { result[pos++] = i; used[i] = 1; for   printf(\"%d\\n\", result[i]); } return 0; }"], "perturbed_original": ["/* AizuOnline A0119 Title Taro's obsession */ #include <stdio.h> // Select Below //#include <stdlib.h> //#include <string.h> //#include <float.h> //#include <math.h> //#include <limits.h> //Global printf(\"3\\n\"); flag[i]=1;<extra_id_1>j ; j<extra_id_2>flag[j]; return(0); }<extra_id_3>|= flag[(j+1)*i[j][j]<extra_id_4>n)<extra_id_5>n ;<extra_id_6>; j = (<extra_id_7>f_bidx ) ] ;<extra_id_8>; for (<extra_id_9>i = 0 ;<extra_id_10>( j ) {<extra_id_11>n =<extra_id_12>x ; t = 0 int x[SHOUGENNO],y[SHOUGENNO]; int flag[NINZUU+1]; // void  int i,cnt; scanf(\"%d \",&n); scanf(\"%d \",&m); for(i=0;i<m;i++) scanf(\"%d %d\",&x[i],&y[i]); for(i=0;i<n;i++) flag[i]=0; cnt=n; while(cnt>1) { for(i=1;i<=n;i++)  printf(\"2\\n\"); return(0); }"], "original_ll": -1.4016071557998657, "sampled_ll": -0.3959541916847229, "all_perturbed_sampled_ll": [-2.0041303634643555], "all_perturbed_original_ll": [-2.562027931213379], "perturbed_sampled_ll": -2.0041303634643555, "perturbed_original_ll": -2.562027931213379, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n    \npublic class Main {\n    public static void main(String[] args) {\n        (new Main()).execute();\n    }\n    private void execute() {\n        Scanner sc = new Scanner(System.in);\n\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        ObsessionComparator comp = new ObsessionComparator(m);\n        for(int i = 0 ; i < n ; i++) {comp.add(sc.nextInt(), sc.nextInt());}\n        \n        Integer[] list = new Integer[m];\n        for(int i = 0 ; i < m ; i++) {list[i] = Integer.valueOf(i+1);}\n        \n        Arrays.sort(list, comp);\n        \n        for(Integer i : list){System.out.println(i);}\n        sc.close();\n    }\n    \n    private class ObsessionComparator implements Comparator<Integer> {\n    \tprivate Map<Integer, Set<Integer>> sortMap = new HashMap<Integer, Set<Integer>>();\n    \tprivate ObsessionComparator(int count) {\n    \t\tfor(int i = 1 ; i <= count ; i++) {\n    \t\t\tsortMap.put(Integer.valueOf(i), new HashSet<Integer>());\n    \t\t}\n    \t}\n\n    \tprivate void add(Integer x, Integer y) {\n    \t\tsortMap.get(x).add(y);\n    \t}\n    \tprivate boolean isSorted(Integer x, Integer y) {\n    \t\tif(sortMap.get(x).contains(y)) {\n    \t\t\treturn true;\n    \t\t} else if(sortMap.get(x).isEmpty()) {\n    \t\t\treturn false;\n    \t\t} else {\n    \t\t\tfor(Integer next : sortMap.get(x)) {\n    \t\t\t\tif(isSorted(next, y)){\n    \t\t\t\t\treturn true;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn false;\n    \t\t}\n    \t}\n    \t\n    \t@Override\n\t\tpublic int compare(Integer arg0, Integer arg1) {\n    \t\treturn isSorted(arg0, arg1) ? -1 : 1;\n\t\t}\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        \n        List<List<Integer>> graph = new ArrayList<>();\n        int[] indegree = new int[m + 1];\n        \n        for (int i = 0; i <= m; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            graph.get(x).add(y);\n            indegree[y]++;\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 1; i <= m; i++) {\n            if (indegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            result.add(current);\n            \n            for (int next : graph.get(current)) {\n                indegree[next]--;\n                if (indegree[next] == 0) {\n                    queue.offer(next);\n                }\n            }\n        }\n        \n        for (int suspect : result) {\n            System.out.println(suspect);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  indegree = new int[m + 1]; for (int i = 0; i  Queue<Integer> queue = new LinkedList<>(); for (int i = 1; i <= m; i++) { if (indegree[i] == 0) { queue.offer(i); } } List<Integer> result = new ArrayList<>(); while (!queue.isEmpty()) { int current = queue.poll(); result.add(current); for (int next : graph.get(current)) { indegree[next]--; if (indegree[next] == 0) { queue.offer(next); } } } for (int suspect : result) { System.out.println(suspect); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Comparator; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Scanner; import java.util.Set; public class Main {  void execute() { Scanner sc = new Scanner(System.in);  < n ; i++) {comp.add(sc.nextInt(), sc.nextInt());} Integer[] list = new Integer[m]; for(int i = 0 ; i < m ; i++) {list[i] =  i = 1 ; i <= count ; i++) { sortMap.put(Integer.valueOf(i), new HashSet<Integer>()); } } private void add(Integer x, Integer y) { sortMap.get(x).add(y); } private boolean isSorted(Integer x, Integer y) { if(sortMap.get(x).contains(y)) { return  } } return false; } } @Override public int compare(Integer arg0,  } } }"], "original_ll": -0.726981520652771, "sampled_ll": -0.29570454359054565, "all_perturbed_sampled_ll": [-1.0181773900985718], "all_perturbed_original_ll": [-1.714767575263977], "perturbed_sampled_ll": -1.0181773900985718, "perturbed_original_ll": -1.714767575263977, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def solve(a):\n\tif len(a) == m: return a\n\tfor i in M-set(a):\n\t\tfor x,y in xy:\n\t\t\tif x == i and y not in a: break\n\t\telse:\n\t\t\tr = solve([i]+a)\n\t\t\tif r: return r\nm = input()\nM = set(range(1,m+1))\nxy = [map(int,raw_input().split()) for i in range(input())]\nfor i in solve([]): print i", "sampled": "from collections import defaultdict, deque\n\ndef topological_sort(m, edges):\n    # Build adjacency list and in-degree count\n    graph = defaultdict(list)\n    in_degree = [0] * (m + 1)\n    \n    for x, y in edges:\n        graph[x].append(y)\n        in_degree[y] += 1\n    \n    # Find all nodes with in-degree 0\n    queue = deque()\n    for i in range(1, m + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    result = []\n    while queue:\n        # Pick the smallest numbered node (for consistency)\n        queue = deque(sorted(queue))\n        node = queue.popleft()\n        result.append(node)\n        \n        # Reduce in-degree for neighbors\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result\n\n# Read input\nm = int(input())\nn = int(input())\nedges = []\nfor _ in range(n):\n    x = int(input())\n    y = int(input())\n    edges.append((x, y))\n\n# Perform topological sort\norder = topological_sort(m, edges)\n\n# Output result\nfor suspect in order:\n    print(suspect)\n", "perturbed_sampled": ["from collections  * (m +  # Find all nodes with in-degree  1): if in_degree[i] == 0: queue.append(i) result = [] while queue: # Pick the smallest numbered node (for consistency) queue =  for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return result #  [] for _ in range(n): x = int(input()) y = int(input()) edges.append((x, y)) # Perform topological sort order = topological_sort(m, edges) # Output result for suspect in order: print(suspect)"], "perturbed_original": ["def solve(a): if len(a) == m: return a for i in M-set(a): for x,y  a: break else: r = solve([i]+a) if r: return r m = input() M = set(range(1,m+1)) xy =  i"], "original_ll": -1.5008050203323364, "sampled_ll": -0.6565148234367371, "all_perturbed_sampled_ll": [-2.270627737045288], "all_perturbed_original_ll": [-2.892108917236328], "perturbed_sampled_ll": -2.270627737045288, "perturbed_original_ll": -2.892108917236328, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define SQ(x) ((x) * (x))\n#define INF (100000000)\n#define EPS (1e-5)\n\ndouble len;\ndouble cake[12];\ndouble dp[1 << 12][12];\nint n;\n\ndouble min(double a, double b)\n{\n    return (b > a ? a : b);\n}\n\ndouble tsp(int bit, int now)\n{\n    int i;\n    double res;\n    \n    if (dp[bit][now] >= 0){\n        return (dp[bit][now]);\n    }\n    \n    if (bit == (1 << n) - 1 && now == 0){\n        return (dp[bit][now] = 0);\n    }\n    \n    res = INF;\n    for (i = 0; i < n; i++){\n        if (!((bit >> i) & 1)){\n            res = min(res, tsp(bit | (1 << i), i) + sqrt(SQ(cake[i] + cake[now]) - SQ(cake[i] - cake[now])));\n        }\n    }\n    \n    return (dp[bit][now] = res);\n}\n\nint main(void)\n{\n    int i, j;\n    \n    while (scanf(\"%lf\", &len) != EOF){\n        getchar();\n        n = 0;\n        while (1){\n            scanf(\"%lf\", &cake[n++]);\n            \n            if (getchar() == '\\n'){\n                break;\n            }\n        }\n        \n        for (i = 0; i < (1 << 12); i++){\n            for (j = 0; j < 12; j++){\n                dp[i][j] = -1 * INF;\n            }\n        }\n        \n        if (tsp(0, 0) < len + EPS){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\nint n;\nint r[12];\nint perm[12];\nint used[12];\ndouble W;\n\ndouble calc_width(int *order, int len) {\n    if (len == 0) return 0;\n    if (len == 1) return 2.0 * r[order[0]];\n    \n    double pos[12];\n    pos[0] = r[order[0]];\n    \n    for (int i = 1; i < len; i++) {\n        double max_pos = r[order[i]];\n        \n        for (int j = 0; j < i; j++) {\n            double ri = r[order[i]];\n            double rj = r[order[j]];\n            double d = 2.0 * sqrt(ri * rj);\n            double candidate = pos[j] + d;\n            if (candidate > max_pos) {\n                max_pos = candidate;\n            }\n        }\n        \n        pos[i] = max_pos;\n    }\n    \n    double max_right = 0;\n    for (int i = 0; i < len; i++) {\n        double right = pos[i] + r[order[i]];\n        if (right > max_right) {\n            max_right = right;\n        }\n    }\n    \n    return max_right;\n}\n\nint try_permutation(int depth) {\n    if (depth == n) {\n        double width = calc_width(perm, n);\n        return width <= W + 1e-9;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!used[i]) {\n            used[i] = 1;\n            perm[depth] = i;\n            if (try_permutation(depth + 1)) {\n                return 1;\n            }\n            used[i] = 0;\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    char line[1000];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        n = 0;\n        char *token = strtok(line, \" \\n\");\n        W = atof(token);\n        \n        while ((token = strtok(NULL, \" \\n\")) != NULL) {\n            r[n++] = atoi(token);\n        }\n        \n        if (n == 0) continue;\n        \n        memset(used, 0, sizeof(used));\n        \n        if (try_permutation(0)) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h>  int used[12];  == 0) return 0; if (len == 1) return 2.0 * r[order[0]];  i < len; i++) { double max_pos = r[order[i]]; for (int j =  double  rj); double candidate = pos[j]  0; for (int i = 0; i < len;  > max_right) { max_right = right; } } return max_right; }  width = calc_width(perm, n); return width <= W + 1e-9; } for (int i = 0; i < n; i++) { if (!used[i]) { used[i] = 1; perm[depth] = i; if (try_permutation(depth + 1)) { return 1; } used[i] = 0; } } return 0; } int main() { char  ((token = strtok(NULL, \" \\n\")) != NULL) { r[n++] = atoi(token); } if (n == 0) continue; memset(used, 0, sizeof(used));  return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <math.h> #define SQ(x) ((x) * (x)) #define INF (100000000) #define EPS (1e-5) double len; double cake[12]; double dp[1 << 12][12]; int n; double min(double a, double b) { return (b > a ? a : b); } double tsp(int bit, int now)  (dp[bit][now]); } if (bit == (1 << n) - 1 && now == 0){ return (dp[bit][now] = 0); } res = INF; for (i = 0; i < n; i++){ if  &len)  (j = 0; j  if (tsp(0, 0) < len + EPS){ printf(\"OK\\n\"); } else { printf(\"NA\\n\"); } } return (0); }"], "original_ll": -0.6855278611183167, "sampled_ll": -0.5793856382369995, "all_perturbed_sampled_ll": [-1.9235484600067139], "all_perturbed_original_ll": [-1.6418825387954712], "perturbed_sampled_ll": -1.9235484600067139, "perturbed_original_ll": -1.6418825387954712, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tArrayList<String> Ans = new ArrayList<String>();\n\t\tString line;\n\n\t\twhile((line = in.readLine()) != null){\n\t\t\tString[] dst = line.split(\" \");\n\t\t\tint size = Integer.parseInt(dst[0]);\n\n\t\t\tif(size == 0) break;\n\t\t\tint[] seq = new int[dst.length-1];\n\t\t\tint[] radius = new int[dst.length-1];\n\t\t\tfor(int i=1; i<dst.length; i++){\n\t\t\t\tradius[i-1] = Integer.parseInt(dst[i]);\n\t\t\t}\n\n\t\t\tfor(int i=0; i<dst.length-1; i++){\n\t\t\t\tseq[i] = i;\n\t\t\t}\n\n\t\t\tint ok = 0;\n\t\t\tdo{\n//\t\t\t\tfor(int i=0; i<seq.length; i++){\n//\t\t\t\t\tSystem.out.print(seq[i]);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\n\t\t\t\tdouble cakes = calcSize(radius, seq);\n\t\t\t\tif(size >= cakes){\n\t\t\t\t\tAns.add(\"OK\");\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}while(nextArray(seq));\n\n\t\t\tif(ok == 0){\n\t\t\t\tAns.add(\"NA\");\n\t\t\t}\n\t\t}\n\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tSystem.out.println(Ans.get(n));\n\t\t}\n\t}\n\n\tpublic boolean nextArray(int[] seq){\n\t\tint s = seq.length-1;\n\t\twhile(true){\n\t\t\tif(seq[s] > seq[s-1]){\n\t\t\t\tint min = seq[s];\n\t\t\t\tint index = s;\n\t\t\t\tfor(int n=s+1; n<seq.length; n++){\n\t\t\t\t\tif(min > seq[n] && seq[n] > seq[s-1]){\n\t\t\t\t\t\tmin = seq[n];\n\t\t\t\t\t\tindex = n;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tseq[index] = seq[s-1];\n\t\t\t\tseq[s-1] = min;\n\t\t\t\tArrays.sort(seq, s, seq.length-1);\n\t\t\t\treturn true;\n\n\t\t\t}else{\n\t\t\t\ts--;\n\t\t\t}\n\n\t\t\tif(s == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic double calcSize(int[] data, int[] seq){\n\t\tdouble sum = 0.0;\n\t\t\n\t\t\n\t\treturn sum;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static double EPS = 1e-9;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) continue;\n            \n            String[] parts = line.split(\"\\\\s+\");\n            int W = Integer.parseInt(parts[0]);\n            \n            List<Integer> radii = new ArrayList<>();\n            for (int i = 1; i < parts.length; i++) {\n                radii.add(Integer.parseInt(parts[i]));\n            }\n            \n            int n = radii.size();\n            if (n == 0) {\n                System.out.println(\"OK\");\n                continue;\n            }\n            \n            boolean found = false;\n            int[] perm = new int[n];\n            for (int i = 0; i < n; i++) {\n                perm[i] = i;\n            }\n            \n            do {\n                double width = calculateWidth(radii, perm);\n                if (width <= W + EPS) {\n                    found = true;\n                    break;\n                }\n            } while (nextPermutation(perm));\n            \n            System.out.println(found ? \"OK\" : \"NA\");\n        }\n        \n        sc.close();\n    }\n    \n    static double calculateWidth(List<Integer> radii, int[] perm) {\n        int n = perm.length;\n        if (n == 0) return 0;\n        if (n == 1) return 2.0 * radii.get(perm[0]);\n        \n        double[] positions = new double[n];\n        positions[0] = radii.get(perm[0]);\n        \n        for (int i = 1; i < n; i++) {\n            double maxPos = radii.get(perm[i]);\n            \n            for (int j = 0; j < i; j++) {\n                double r1 = radii.get(perm[j]);\n                double r2 = radii.get(perm[i]);\n                double dist = 2.0 * Math.sqrt(r1 * r2);\n                double pos = positions[j] + dist;\n                maxPos = Math.max(maxPos, pos);\n            }\n            \n            positions[i] = maxPos;\n        }\n        \n        double minX = Double.MAX_VALUE;\n        double maxX = -Double.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            double r = radii.get(perm[i]);\n            minX = Math.min(minX, positions[i] - r);\n            maxX = Math.max(maxX, positions[i] + r);\n        }\n        \n        return maxX - minX;\n    }\n    \n    static boolean nextPermutation(int[] array) {\n        int i = array.length - 2;\n        while (i >= 0 && array[i] >= array[i + 1]) {\n            i--;\n        }\n        \n        if (i < 0) {\n            return false;\n        }\n        \n        int j = array.length - 1;\n        while (array[j] <= array[i]) {\n            j--;\n        }\n        \n        swap(array, i, j);\n        reverse(array, i + 1, array.length - 1);\n        \n        return true;\n    }\n    \n    static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    \n    static void reverse(int[] array, int start, int end) {\n        while (start < end) {\n            swap(array, start, end);\n            start++;\n            end--;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static double EPS = 1e-9; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String line =  = Integer.parseInt(parts[0]); List<Integer> radii = new ArrayList<>(); for (int i = 1; i < parts.length; i++) { radii.add(Integer.parseInt(parts[i])); } int n = radii.size(); if (n == 0) { System.out.println(\"OK\"); continue; } boolean found = false; int[] perm = new int[n]; for (int   (width <= W +  System.out.println(found ? \"OK\" : \"NA\"); } sc.close(); } static double calculateWidth(List<Integer> radii, int[] perm) { int n = perm.length; if (n == 0) return 0; if (n ==  < n; i++)  j < i; j++) {  positions[j] + dist; maxPos = Math.max(maxPos, pos); } positions[i] = maxPos; } double minX = Double.MAX_VALUE; double maxX = -Double.MAX_VALUE; for (int i  >= array[i + 1]) { i--; } if (i < 0) { return false; } int j = array.length - 1; while (array[j] <= array[i]) { j--; } swap(array, i, j); reverse(array, i + 1, array.length -  int j) { int temp = array[i]; array[i] = array[j];  start, end); start++; end--; } } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static void main(String args[]){ try{ new Main(); }catch(IOException err){ err.printStackTrace(); } } public   Integer.parseInt(dst[0]);  radius = new int[dst.length-1]; for(int i=1; i<dst.length; i++){  i; } int ok  // } // System.out.println(); double cakes = calcSize(radius, seq); if(size >= cakes){ Ans.add(\"OK\"); ok = 1; break; } }while(nextArray(seq));  System.out.println(Ans.get(n)); } } public boolean  int min = seq[s]; int index = s; for(int n=s+1; n<seq.length; n++){ if(min >  n; } } seq[index] = seq[s-1]; seq[s-1] = min; Arrays.sort(seq, s, seq.length-1); return true; }else{ s--; } if(s == 0){ return false; } } } public double calcSize(int[]  }"], "original_ll": -0.726965606212616, "sampled_ll": -0.37368282675743103, "all_perturbed_sampled_ll": [-1.5216014385223389], "all_perturbed_original_ll": [-2.3433892726898193], "perturbed_sampled_ll": -1.5216014385223389, "perturbed_original_ll": -2.3433892726898193, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0120\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\ndef calc_width(cakes):\n    # ??\u00b1????????????????????????(?????????)????????????????????????????????????????\u00a8??????????\n    if len(cakes) == 1:\n        return cakes[0]*2\n\n    prev_r = cakes[0]\n    width = prev_r\n\n    for r in cakes[1:]:\n        h_diff = abs(prev_r - r)\n        w = ((prev_r + r)**2 - h_diff**2)**0.5\n        width += w\n        prev_r = r\n    width += cakes[-1]\n\n    return width\n\n\ndef main(args):\n    for line in sys.stdin:\n        data = [int(x) for x in line.strip().split()]\n        box_size = data[0]\n        temp = data[1:]\n        temp.sort()\n\n        # ??\u00b1??????????????????????????????????????????????????????????????????????????????\n        min_width = float('inf')\n\n        cakes = [temp[0]]\n        temp = temp[1:]\n        pick_large = True\n        while temp:\n            if pick_large:\n                pick = temp[-1]\n                temp = temp[:-1]\n                pick_large = False\n                diff_front = abs(pick - cakes[0])\n                diff_rear = abs(pick - cakes[-1])\n                if diff_front > diff_rear:\n                    cakes.insert(0, pick)\n                else:\n                    cakes.append(pick)\n            else:\n                pick = temp[0]\n                temp = temp[1:]\n                pick_large = True\n                diff_front = abs(pick - cakes[0])\n                diff_rear = abs(pick - cakes[-1])\n                if diff_front > diff_rear:\n                    cakes.insert(0, pick)\n                else:\n                    cakes.append(pick)\n\n        result = calc_width(cakes)\n        min_width = min(result, min_width)\n\n        if min_width <= box_size:\n            print('OK')\n        else:\n            print('NA')\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    ", "sampled": "import sys\nimport math\nfrom itertools import permutations\n\ndef calc_distance(r1, r2):\n    # Distance between centers of two circles touching each other and both touching the bottom\n    return 2 * math.sqrt(r1 * r2)\n\ndef calc_width(radii):\n    if len(radii) == 0:\n        return 0\n    if len(radii) == 1:\n        return 2 * radii[0]\n    \n    # Position circles one by one\n    positions = [radii[0]]  # x-coordinate of center of each circle\n    \n    for i in range(1, len(radii)):\n        # Find the rightmost position where circle i can be placed\n        min_x = radii[i]  # At least this far from left wall\n        \n        for j in range(i):\n            # Must be at least calc_distance away from circle j\n            required_dist = calc_distance(radii[i], radii[j])\n            min_x = max(min_x, positions[j] + required_dist)\n        \n        positions.append(min_x)\n    \n    # Total width is rightmost position + its radius\n    return positions[-1] + radii[-1]\n\ndef solve(W, radii):\n    n = len(radii)\n    \n    if n == 0:\n        return \"OK\"\n    \n    # Try all permutations\n    for perm in permutations(radii):\n        width = calc_width(list(perm))\n        if width <= W:\n            return \"OK\"\n    \n    return \"NA\"\n\nfor line in sys.stdin:\n    parts = list(map(int, line.strip().split()))\n    W = parts[0]\n    radii = parts[1:]\n    print(solve(W, radii))\n", "perturbed_sampled": ["import  # Distance between centers of two circles touching each other and both touching the bottom return 2 * math.sqrt(r1 * r2) def calc_width(radii): if len(radii) == 0: return 0 if len(radii) == 1: return 2 * radii[0] # Position circles one  each circle for i in range(1, len(radii)): # Find  = radii[i] # At least this far from left wall for j in range(i): # Must be at least calc_distance away from circle j  positions.append(min_x) # Total width is rightmost position + its radius return   perm in permutations(radii): width =  line in  parts[1:] print(solve(W, radii))"], "perturbed_original": ["# -*- coding: utf-8 -*- \"\"\" http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0120 \"\"\" import sys from sys import stdin input = stdin.readline def calc_width(cakes): # ??\u00b1????????????????????????(?????????)????????????????????????????????????????\u00a8?????????? if len(cakes) == 1: return cakes[0]*2 prev_r = cakes[0] width = prev_r for r in cakes[1:]: h_diff = abs(prev_r - r) w = ((prev_r + r)**2 - h_diff**2)**0.5 width += w prev_r = r width += cakes[-1] return width def main(args): for line in sys.stdin: data  = [temp[0]] temp =  temp[-1] temp = temp[:-1] pick_large = False diff_front =  abs(pick - cakes[0]) diff_rear =  cakes.append(pick) result = calc_width(cakes) min_width  if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -0.9871365427970886, "sampled_ll": -0.9655501246452332, "all_perturbed_sampled_ll": [-2.9261083602905273], "all_perturbed_original_ll": [-2.1815967559814453], "perturbed_sampled_ll": -2.9261083602905273, "perturbed_original_ll": -2.1815967559814453, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<cstdlib>\n\nusing namespace std;\n\n#define maxn 305\n\nint map[3][5];\n\nint main()\n{\n\tint i,j;\ncin>>i;\ncout<<1<<endl;\n\n\n\treturn 0;\n}\n\n", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_STATES 362880\n\ntypedef struct {\n    int state[8];\n    int dist;\n} Node;\n\nint visited[MAX_STATES];\nNode queue[MAX_STATES];\nint front, rear;\n\nint encode(int state[8]) {\n    int code = 0;\n    int base = 1;\n    for (int i = 7; i >= 0; i--) {\n        int digit = state[i];\n        for (int j = i + 1; j < 8; j++) {\n            if (state[j] < state[i]) digit--;\n        }\n        code += digit * base;\n        base *= (8 - i);\n    }\n    return code;\n}\n\nint bfs(int start[8]) {\n    memset(visited, -1, sizeof(visited));\n    front = rear = 0;\n    \n    memcpy(queue[rear].state, start, sizeof(int) * 8);\n    queue[rear].dist = 0;\n    rear++;\n    \n    int start_code = encode(start);\n    visited[start_code] = 0;\n    \n    int goal[8] = {0, 1, 2, 3, 4, 5, 6, 7};\n    int goal_code = encode(goal);\n    \n    if (start_code == goal_code) return 0;\n    \n    while (front < rear) {\n        Node current = queue[front++];\n        \n        int pos0 = -1;\n        for (int i = 0; i < 8; i++) {\n            if (current.state[i] == 0) {\n                pos0 = i;\n                break;\n            }\n        }\n        \n        int row = pos0 / 4;\n        int col = pos0 % 4;\n        \n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n        \n        for (int d = 0; d < 4; d++) {\n            int new_row = row + dr[d];\n            int new_col = col + dc[d];\n            \n            if (new_row >= 0 && new_row < 2 && new_col >= 0 && new_col < 4) {\n                int new_pos = new_row * 4 + new_col;\n                \n                int new_state[8];\n                memcpy(new_state, current.state, sizeof(int) * 8);\n                \n                int temp = new_state[pos0];\n                new_state[pos0] = new_state[new_pos];\n                new_state[new_pos] = temp;\n                \n                int new_code = encode(new_state);\n                \n                if (visited[new_code] == -1) {\n                    visited[new_code] = current.dist + 1;\n                    \n                    if (new_code == goal_code) {\n                        return current.dist + 1;\n                    }\n                    \n                    memcpy(queue[rear].state, new_state, sizeof(int) * 8);\n                    queue[rear].dist = current.dist + 1;\n                    rear++;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int state[8];\n    \n    while (scanf(\"%d\", &state[0]) == 1) {\n        for (int i = 1; i < 8; i++) {\n            scanf(\"%d\", &state[i]);\n        }\n        \n        int result = bfs(state);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAX_STATES 362880 typedef struct {  = 0; int base = 1; for (int i  state[i]; for (int j = i + 1; j < 8;  digit * base; base *= (8 - i); } return code; } int bfs(int start[8]) { memset(visited, -1, sizeof(visited));  = 0; int  int goal_code  < rear) { Node current = queue[front++]; int pos0 = -1; for (int i = 0; i < 8; i++) { if (current.state[i] == 0) { pos0 = i; break; } } int row = pos0 / 4; int col = pos0 % 4; int dr[] = {-1, 1, 0, 0};  = 0;  dr[d]; int new_col =  2 && new_col >= 0 && new_col < 4) { int new_pos = new_row * 4 + new_col; int new_state[8]; memcpy(new_state, current.state, sizeof(int) * 8); int temp =  encode(new_state); if (visited[new_code] == -1) { visited[new_code] = current.dist + 1; if (new_code  sizeof(int)  } } return -1; } int main()   &state[i]); } int result = bfs(state); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#include<iostream> #include<cstdio> #include<queue> #include<algorithm> #include<string> #include<vector> #include<cstdlib> using namespace std; #define  cout<<1<<endl; return 0; }"], "original_ll": -1.8874130249023438, "sampled_ll": -0.4108114540576935, "all_perturbed_sampled_ll": [-1.729025959968567], "all_perturbed_original_ll": [-1.9788100719451904], "perturbed_sampled_ll": -1.729025959968567, "perturbed_original_ll": -1.9788100719451904, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\n\tvoid run() {\n\t\tHashMap<ArrayList<Integer>, Integer> hm = new HashMap<ArrayList<Integer>, Integer>();\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tint cnt = 0;\n\t\thm.put(list, cnt);\n\n\t\tLinkedList<ArrayList<Integer>> queue = new LinkedList<ArrayList<Integer>>();\n\t\tqueue.add(list);\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint size = queue.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tArrayList<Integer> l = queue.poll();\n\t\t\t\tint zeroIndex = 0;\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (l.get(j) == 0) {\n\t\t\t\t\t\tzeroIndex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (zeroIndex - 1 >= 0 && zeroIndex != 4) {\n\t\t\t\t\tArrayList<Integer> add = new ArrayList<Integer>(l);\n\t\t\t\t\tint t = l.get(zeroIndex);\n\t\t\t\t\tint r = l.get(zeroIndex - 1);\n\t\t\t\t\tadd.set(zeroIndex, r);\n\t\t\t\t\tadd.set(zeroIndex - 1, t);\n\t\t\t\t\tif (!hm.containsKey(add)) {\n\t\t\t\t\t\thm.put(add, cnt + 1);\n\t\t\t\t\t\tqueue.add(add);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (zeroIndex + 1 < 8 && zeroIndex != 3) {\n\t\t\t\t\tArrayList<Integer> add = new ArrayList<Integer>(l);\n\t\t\t\t\tint t = l.get(zeroIndex);\n\t\t\t\t\tint r = l.get(zeroIndex + 1);\n\t\t\t\t\tadd.set(zeroIndex, r);\n\t\t\t\t\tadd.set(zeroIndex + 1, t);\n\t\t\t\t\tif (!hm.containsKey(add)) {\n\t\t\t\t\t\thm.put(add, cnt + 1);\n\t\t\t\t\t\tqueue.add(add);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrayList<Integer> add = new ArrayList<Integer>(l);\n\t\t\t\tint t = l.get(zeroIndex);\n\t\t\t\tint r = l.get((zeroIndex + 4) % 8);\n\t\t\t\tadd.set(zeroIndex, r);\n\t\t\t\tadd.set((zeroIndex + 4) % 8, t);\n\t\t\t\tif (!hm.containsKey(add)) {\n\t\t\t\t\thm.put(add, cnt + 1);\n\t\t\t\t\tqueue.add(add);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\twhile (sc2.hasNext()) {\n\t\t\tString input[] = sc2.nextLine().split(\" \");\n\t\t\tArrayList<Integer> in = new ArrayList<Integer>();\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tin.add(Integer.valueOf(input[i]));\n\t\t\t}\n\t\t\tSystem.out.println(hm.get(in));\n\t\t}\n\t}\n\n\tboolean check(ArrayList<Integer> list) {\n\t\tboolean judge = true;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif (list.get(i) != i) {\n\t\t\t\tjudge = false;\n\t\t\t}\n\t\t}\n\t\treturn judge;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static final int[] TARGET = {0, 1, 2, 3, 4, 5, 6, 7};\n    static final int[][] MOVES = {{1}, {0, 2}, {1, 3}, {2}, {5}, {4, 6}, {5, 7}, {6}};\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\"\\\\s+\");\n            int[] initial = new int[8];\n            for (int i = 0; i < 8; i++) {\n                initial[i] = Integer.parseInt(parts[i]);\n            }\n            \n            System.out.println(bfs(initial));\n        }\n        sc.close();\n    }\n    \n    static int bfs(int[] initial) {\n        if (Arrays.equals(initial, TARGET)) {\n            return 0;\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        State start = new State(initial, 0);\n        queue.offer(start);\n        visited.add(stateToString(initial));\n        \n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            \n            int zeroPos = -1;\n            for (int i = 0; i < 8; i++) {\n                if (current.board[i] == 0) {\n                    zeroPos = i;\n                    break;\n                }\n            }\n            \n            for (int nextPos : MOVES[zeroPos]) {\n                int[] newBoard = current.board.clone();\n                newBoard[zeroPos] = newBoard[nextPos];\n                newBoard[nextPos] = 0;\n                \n                if (Arrays.equals(newBoard, TARGET)) {\n                    return current.moves + 1;\n                }\n                \n                String stateStr = stateToString(newBoard);\n                if (!visited.contains(stateStr)) {\n                    visited.add(stateStr);\n                    queue.offer(new State(newBoard, current.moves + 1));\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static String stateToString(int[] board) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 8; i++) {\n            sb.append(board[i]);\n        }\n        return sb.toString();\n    }\n    \n    static class State {\n        int[] board;\n        int moves;\n        \n        State(int[] board, int moves) {\n            this.board = board;\n            this.moves = moves;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {  5, 6, 7}; static final int[][] MOVES = {{1}, {0, 2}, {1, 3}, {2}, {5},  { Scanner  sc.nextLine().trim();  8; i++) { initial[i] = Integer.parseInt(parts[i]); } System.out.println(bfs(initial)); } sc.close(); } static int bfs(int[] initial) {  = new State(initial, 0); queue.offer(start); visited.add(stateToString(initial)); while (!queue.isEmpty()) { State current = queue.poll(); int zeroPos = -1;  if (current.board[i] == 0) { zeroPos = i; break; } }  newBoard[zeroPos] = newBoard[nextPos]; newBoard[nextPos] = 0; if (Arrays.equals(newBoard, TARGET)) { return  { visited.add(stateStr); queue.offer(new State(newBoard, current.moves + 1)); } } } return -1; } static String  i = 0; i < 8; i++) { sb.append(board[i]); } return sb.toString(); } static class State { int[] board; int moves; State(int[] board, int moves) { this.board = board; this.moves = moves; } } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; <extra_id_9>r.toShort();<extra_id_10>return<extra_id_11>} }<extra_id_12>{<extra_id_13>j = 0; = new MyScanner(); Scanner sc2 = new Scanner(System.in); void run() { HashMap<ArrayList<Integer>, Integer> hm = new HashMap<ArrayList<Integer>, Integer>(); ArrayList<Integer> list = new class<extra_id_14>{ while (<extra_id_15>|= e){<extra_id_16>] =<extra_id_17>; if<extra_id_18>] . length<extra_id_19> { list.add(i); } int cnt = 0; hm.put(list, cnt);  size = queue.size(); for (int i = 0; i < size; i++) { ArrayList<Integer> l = queue.poll(); int zeroIndex = 0; for (int j = 0; j < 8; j++) { if (l.get(j)  -  = new ArrayList<Integer>(l); int t = l.get(zeroIndex); int r = l.get(zeroIndex - 1); add.set(zeroIndex, r); add.set(zeroIndex - 1, t); if (!hm.containsKey(add))  + 1 < 8 && zeroIndex  = l.get(zeroIndex); int r = l.get(zeroIndex +  hm.put(add, cnt + 1); queue.add(add); } } ArrayList<Integer> add = new ArrayList<Integer>(l); int  8); add.set(zeroIndex, r); add.set((zeroIndex + 4) % 8, t); if (!hm.containsKey(add)) {  = new ArrayList<Integer>(); for (int i = 0; i < 8; i++) { in.add(Integer.valueOf(input[i])); } System.out.println(hm.get(in)); } } boolean  = 0; i < 8; i++) { if (list.get(i) != i) { judge  { System.out.println(Arrays.deepToString(o)); } void debug2(int[][] array) { for (int  j = 0;  class  System.in.read(); while (c != '-' && (c < '0' || '9' < c))  res = 0; do { res *=  while ('0' <= c && c <= '9'); return res; } catch (Exception e)  new StringBuilder(\"\"); int c = System.in.read(); while (Character.isWhitespace(c)) c = System.in.read();  res.toString(); } catch (Exception e) { return null; } } } }"], "original_ll": -0.4051997661590576, "sampled_ll": -0.3509499728679657, "all_perturbed_sampled_ll": [-1.6720280647277832], "all_perturbed_original_ll": [-1.8658111095428467], "perturbed_sampled_ll": -1.6720280647277832, "perturbed_original_ll": -1.8658111095428467, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import deque\n\ndic = {}\ndic[(0,1,2,3,4,5,6,7)] = 0\n\n\nswap_dic = {0:(1, 4), 1:(0, 2, 5), 2:(1, 3, 6), 3:(2, 7),\n            4:(0, 5), 5:(1, 4, 6), 6:(2, 5, 7), 7:(3, 6)}\n\ndef swap(puz, i, j):\n  new = [k for k in puz]\n  new[i], new[j] = new[j], new[i]\n  return tuple(new)\n\nque = deque()\nque.append((0, (0,1,2,3,4,5,6,7)))\nwhile que:\n  score, puz = que.popleft()\n  score += 1\n  z_ind = puz.index(0)\n\n  for swap_ind in swap_dic[z_ind]:\n    new_puz = swap(puz, z_ind, swap_ind)\n    if not new_puz in dic:\n      dic[new_puz] = score\n      que.append((score, new_puz))\n\nwhile True:\n  try:\n    print(dic[tuple(map(int, input().split()))])\n  except EOFError:\n    break\n", "sampled": "from collections import deque\nimport sys\n\ndef solve(start):\n    goal = tuple(range(8))\n    if start == goal:\n        return 0\n    \n    visited = {start}\n    queue = deque([(start, 0)])\n    \n    while queue:\n        state, dist = queue.popleft()\n        \n        # Find position of 0\n        pos = state.index(0)\n        row = pos // 4\n        col = pos % 4\n        \n        # Try all 4 directions\n        moves = []\n        if col > 0:  # left\n            moves.append(pos - 1)\n        if col < 3:  # right\n            moves.append(pos + 1)\n        if row > 0:  # up\n            moves.append(pos - 4)\n        if row < 1:  # down\n            moves.append(pos + 4)\n        \n        for new_pos in moves:\n            new_state = list(state)\n            new_state[pos], new_state[new_pos] = new_state[new_pos], new_state[pos]\n            new_state = tuple(new_state)\n            \n            if new_state == goal:\n                return dist + 1\n            \n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, dist + 1))\n    \n    return -1\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        nums = tuple(map(int, line.split()))\n        print(solve(nums))\n", "perturbed_sampled": ["from collections import deque import sys def solve(start): goal   row = pos // 4 col = pos % 4 # Try all 4 directions moves = [] if col > 0: # left moves.append(pos - 1)  row > 0: # up moves.append(pos - 4) if row <  new_state = list(state) new_state[pos], new_state[new_pos] =  dist + 1 if new_state not in visited: visited.add(new_state)  line = line.strip() if line: nums = tuple(map(int, line.split())) print(solve(nums))"], "perturbed_original": ["from collections import deque dic = {} dic[(0,1,2,3,4,5,6,7)] = 0 swap_dic = {0:(1, 4), 1:(0, 2, 5), 2:(1, 3, 6), 3:(2, 7), 4:(0, 5), 5:(1, 4, 6), 6:(2, 5, 7), 7:(3, 6)} def swap(puz, i,  = new[j], new[i] return tuple(new) que = deque() que.append((0, (0,1,2,3,4,5,6,7))) while  swap_ind)  while True: try: print(dic[tuple(map(int, input().split()))]) except EOFError: break"], "original_ll": -0.7301717400550842, "sampled_ll": -0.6495038866996765, "all_perturbed_sampled_ll": [-2.389636993408203], "all_perturbed_original_ll": [-1.433479905128479], "perturbed_sampled_ll": -2.389636993408203, "perturbed_original_ll": -1.433479905128479, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>          // printf(), scanf()\n#include <stdbool.h>\n\n#define MAX_N 10\n#define MAX_M 10\n#define MAX_G 9\n\nint sx, sy;\nint n;\nint scx[MAX_N], scy[MAX_N];\n\nbool\nb_survival()\n{\n\tbool field[MAX_M][MAX_M];\n\tint px[MAX_G], py[MAX_G];\n\tstatic const int dx2[12] = {-1, 0, 1, 2, 2, 2,-1, 0, 1,-2,-2,-2};\n\tstatic const int dy2[12] = {-2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1};\n\n\tint ix = 0;\n\tpx[ix] = sx, py[ix] = sy;\n\tix++;\n\n\tfor (int u = 0; u < n; ++u)\n\t{\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = scx[u] + dx, ny = scy[u] + dy;\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)\n\t\t\t\t\tfield[ny][nx] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 12; ++j)\n\t\t\t{\n\t\t\t\tint nx = px[i] + dx2[j], ny = py[i] + dy2[j];\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)\n\t\t\t\t\tfield[ny][nx] = true;\n\t\t\t}\n\t\t}\n\n\t\tix = 0;\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = scx[u] + dx, ny = scy[u] + dy;\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M && field[ny][nx])\n\t\t\t\t{\n\t\t\t\t\tpx[ix] = nx;\n\t\t\t\t\tpy[ix] = ny;\n\t\t\t\t\tix++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ix == 0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint lineno = 0;\n\twhile (true)\n\t{\n\t\tlineno++;\n\t\tscanf(\"%d%d\", &sx, &sy);\n\t\tif (sx == 0 && sy == 0)\n\t\t\tbreak;\n\n\t\tlineno++;\n\t\tscanf(\"%d\", &n);\n\n\t\tlineno++;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tscanf(\"%d%d\", &scx[i], &scy[i]);\n\n\t\tprintf(\"%s\\n\", b_survival() ? \"OK\" : \"NA\");\n\t}\n\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint can_reach(int fx, int fy, int sx, int sy) {\n    int dx = abs(fx - sx);\n    int dy = abs(fy - sy);\n    \n    if ((dx == 2 && dy == 2) || (dx == 0 && dy == 3) || (dx == 3 && dy == 0)) {\n        return 1;\n    }\n    return 0;\n}\n\nint in_spray(int x, int y, int sx, int sy) {\n    int dx = abs(x - sx);\n    int dy = abs(y - sy);\n    \n    if (dx <= 1 && dy <= 1) {\n        return 1;\n    }\n    return 0;\n}\n\nint in_bounds(int x, int y) {\n    return x >= 0 && x <= 9 && y >= 0 && y <= 9;\n}\n\nint solve(int px, int py, int n, int sx[], int sy[]) {\n    int possible[10][10];\n    int next_possible[10][10];\n    \n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            possible[i][j] = 0;\n        }\n    }\n    \n    for (int x = 0; x < 10; x++) {\n        for (int y = 0; y < 10; y++) {\n            if (can_reach(px, py, x, y) && in_bounds(x, y) && in_spray(x, y, sx[0], sy[0])) {\n                possible[x][y] = 1;\n            }\n        }\n    }\n    \n    for (int i = 1; i < n; i++) {\n        for (int x = 0; x < 10; x++) {\n            for (int y = 0; y < 10; y++) {\n                next_possible[x][y] = 0;\n            }\n        }\n        \n        for (int fx = 0; fx < 10; fx++) {\n            for (int fy = 0; fy < 10; fy++) {\n                if (possible[fx][fy]) {\n                    for (int tx = 0; tx < 10; tx++) {\n                        for (int ty = 0; ty < 10; ty++) {\n                            if (can_reach(fx, fy, tx, ty) && in_bounds(tx, ty) && in_spray(tx, ty, sx[i], sy[i])) {\n                                next_possible[tx][ty] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (int x = 0; x < 10; x++) {\n            for (int y = 0; y < 10; y++) {\n                possible[x][y] = next_possible[x][y];\n            }\n        }\n    }\n    \n    for (int x = 0; x < 10; x++) {\n        for (int y = 0; y < 10; y++) {\n            if (possible[x][y]) {\n                return 1;\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int px, py;\n    \n    while (scanf(\"%d %d\", &px, &py) == 2) {\n        if (px == 0 && py == 0) {\n            break;\n        }\n        \n        int n;\n        scanf(\"%d\", &n);\n        \n        int sx[10], sy[10];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &sx[i], &sy[i]);\n        }\n        \n        if (solve(px, py, n, sx, sy)) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>   = abs(fy - sy); if ((dx == 2 && dy == 2) || (dx == 0 && dy == 3) || (dx == 3  dy = abs(y -  return 1; } return 0; } int in_bounds(int x, int y) { return x >= 0 &&  int sx[], int  0; i < 10; i++) { for (int j = 0; j < 10; j++) { possible[i][j] = 0;  in_bounds(x, y) && in_spray(x, y, sx[0], sy[0]))  = 1; i < n; i++) { for (int x = 0; x < 10; x++) { for (int y = 0; y < 10; y++) { next_possible[x][y] = 0; } } for (int  fy = 0; fy < 10; fy++) { if (possible[fx][fy]) { for (int tx = 0; tx < 10; tx++) { for (int ty = 0;  && in_bounds(tx, ty) &&  } } } } for (int x  = 0; y  { for (int y = 0; y <  } return 0; } int main() { int px, py; while (scanf(\"%d %d\", &px, &py) == 2) { if (px == 0 && py == 0) { break; } int n; scanf(\"%d\", &n); int sx[10], sy[10]; for (int i = 0; i < n; i++) { scanf(\"%d %d\", &sx[i], &sy[i]); } if (solve(px, py, n, sx,  0; }"], "perturbed_original": ["#include <stdio.h> // printf(), scanf() #include <stdbool.h> --;<extra_id_12>*argv);<extra_id_13>!= -1) {<extra_id_14>+= n; if<extra_id_15><=<extra_id_16>%*argv%s=%s%s\" sx, sy; int n; int scx[MAX_N], scy[MAX_N]; bool b_survival()  = {-1, 0, 1, 2, 2,  1, 2, 2, 2,-1, 0, 1}; int ix = 0; px[ix] = sx, py[ix] = sy; ix++; for (int u = 0; u < n; ++u) { for (int dy = -1; dy <= 1; ++dy) { for (int dx = -1; dx <= 1; ++dx) { int nx  (0 <= nx && nx < MAX_M && 0 <=  for  (int j = 0; j < 12; ++j) { int  0 <= ny && ny < MAX_M) field[ny][nx] = true; } } ix = 0; for (int dy = -1; dy <= 1; ++dy) { for (int dx = -1; dx <= 1; ++dx) { int nx  <= ny &&  argc, char **argv) { int lineno = 0; while (true) { lineno++; scanf(\"%d%d\",  break; lineno++; scanf(\"%d\", &n); lineno++; for (int i = 0; i < n; ++i) scanf(\"%d%d\", &scx[i],  }"], "original_ll": -0.6098967790603638, "sampled_ll": -0.3121703565120697, "all_perturbed_sampled_ll": [-1.3155637979507446], "all_perturbed_original_ll": [-1.936800241470337], "perturbed_sampled_ll": -1.3155637979507446, "perturbed_original_ll": -1.936800241470337, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] fy = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 };\n\tstatic int[] fx = { -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint kx = scanner.nextInt();\n\t\t\tint ky = scanner.nextInt();\n\t\t\tif (ky == 0 && kx == 0)\n\t\t\t\tbreak;\n\t\t\tint n = scanner.nextInt();\n\t\t\tint[][] num = new int[n][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tnum[i][0] = scanner.nextInt();\n\t\t\t\tnum[i][1] = scanner.nextInt();\n\t\t\t}\n\t\t\tDeque<int[]> deque = new ArrayDeque<int[]>();\n\t\t\tdeque.offer(new int[] { ky, kx });\n\t\t\tboolean flag = true;\n\t\t\tloop: for (int i = 0; i < n; i++) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tDeque<int[]> dequetmp = new ArrayDeque<int[]>();\n\t\t\t\twhile (size-- > 0) {\n\t\t\t\t\tint[] m = deque.pop();\n\t\t\t\t\tslove(m, num[i], dequetmp);\n\t\t\t\t}\n\t\t\t\tif (dequetmp.isEmpty()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t\tdeque = dequetmp;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"OK\" : \"NA\");\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[] m, int[] num, Deque<int[]> dequetmp) {\n\t\tboolean[][] map = new boolean[14][14];\n\t\tfor (int i = 1; i < 4; i++) {\n\t\t\tfor (int j = 1; j < 4; j++) {\n\t\t\t\tint y = num[1] + i;\n\t\t\t\tint x = num[0] + j;\n\t\t\t\tif (2 <= y && y <= 12 && 2 <= x && x <= 12)\n\t\t\t\t\tmap[y][x] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < fy.length; i++) {\n\t\t\tint py = m[0] + fy[i] + 2;\n\t\t\tint px = m[1] + fx[i] + 2;\n\t\t\tif (map[py][px]) {\n\t\t\t\tpy -= 2;\n\t\t\t\tpx -= 2;\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor (int[] t : dequetmp) {\n\t\t\t\t\tif (t[0] == py && t[1] == px) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tdequetmp.push(new int[] { py, px });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[][] jumpOffsets = {\n        {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2},\n        {1, -2}, {1, 2}, {2, -1}, {2, 1}\n    };\n    \n    static int[][] waterOffsets = {\n        {-1, -1}, {-1, 0}, {-1, 1},\n        {0, -1}, {0, 0}, {0, 1},\n        {1, -1}, {1, 0}, {1, 1}\n    };\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int px = sc.nextInt();\n            int py = sc.nextInt();\n            \n            if (px == 0 && py == 0) break;\n            \n            int n = sc.nextInt();\n            int[][] sprinklers = new int[n][2];\n            \n            for (int i = 0; i < n; i++) {\n                sprinklers[i][0] = sc.nextInt();\n                sprinklers[i][1] = sc.nextInt();\n            }\n            \n            if (canSurvive(px, py, sprinklers)) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static boolean canSurvive(int px, int py, int[][] sprinklers) {\n        Set<String> currentPositions = new HashSet<>();\n        currentPositions.add(px + \",\" + py);\n        \n        for (int i = 0; i < sprinklers.length; i++) {\n            int sx = sprinklers[i][0];\n            int sy = sprinklers[i][1];\n            \n            Set<String> nextPositions = new HashSet<>();\n            \n            for (String posStr : currentPositions) {\n                String[] parts = posStr.split(\",\");\n                int x = Integer.parseInt(parts[0]);\n                int y = Integer.parseInt(parts[1]);\n                \n                for (int[] offset : jumpOffsets) {\n                    int nx = x + offset[0];\n                    int ny = y + offset[1];\n                    \n                    if (nx >= 0 && nx <= 9 && ny >= 0 && ny <= 9) {\n                        if (isInWaterRange(nx, ny, sx, sy)) {\n                            nextPositions.add(nx + \",\" + ny);\n                        }\n                    }\n                }\n            }\n            \n            if (nextPositions.isEmpty()) {\n                return false;\n            }\n            \n            currentPositions = nextPositions;\n        }\n        \n        return true;\n    }\n    \n    static boolean isInWaterRange(int x, int y, int sx, int sy) {\n        for (int[] offset : waterOffsets) {\n            if (sx + offset[0] == x && sy + offset[1] == y) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int[][] jumpOffsets = { {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2},   {0, 0}, {0, 1}, {1, -1}, {1, 0}, {1, 1} }; public static void main(String[] args) { Scanner sc = new  = sc.nextInt(); if  i = 0; i < n; i++) { sprinklers[i][0] = sc.nextInt(); sprinklers[i][1] = sc.nextInt(); } if (canSurvive(px, py, sprinklers)) {  boolean canSurvive(int px,  currentPositions.add(px + \",\" + py); for (int i =  int sy = sprinklers[i][1]; Set<String> nextPositions = new HashSet<>(); for (String posStr : currentPositions) {  = Integer.parseInt(parts[1]); for (int[] offset : jumpOffsets) { int nx = x + offset[0];  { nextPositions.add(nx + \",\" + ny); } } } } if (nextPositions.isEmpty()) { return false; } currentPositions = nextPositions; } return true; }  { for (int[] offset : waterOffsets) {  == y) { return true; } } return false; } }"], "perturbed_original": ["import java.util.ArrayDeque; import java.util.Deque; import java.util.Scanner; public class Main { static int[]  1, 1, 2, 2, 2 }; static int[] fx = { -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1 }; public static void main(String[] args) { Scanner scanner  num = new int[n][2]; for (int i = 0; i < n; i++) { num[i][0] = scanner.nextInt(); num[i][1] = scanner.nextInt(); } Deque<int[]> deque = new ArrayDeque<int[]>(); deque.offer(new int[] { ky, kx }); boolean flag = true; loop: for (int i = 0; i < n; i++) { int size = deque.size(); Deque<int[]> dequetmp = new  slove(m, num[i], dequetmp); } if (dequetmp.isEmpty())  } System.out.println(flag ? \"OK\" : \"NA\"); } } private static void slove(int[] m, int[] num, Deque<int[]> dequetmp) { boolean[][] map = new boolean[14][14]; for (int i = 1; i < 4; i++) {  <= 12 && 2 <= x && x <=   + fy[i] + 2; int px = m[1]  px -=  { flag = false; break; } } if (flag)  } }"], "original_ll": -0.5472045540809631, "sampled_ll": -0.37590184807777405, "all_perturbed_sampled_ll": [-1.574857234954834], "all_perturbed_original_ll": [-1.5556623935699463], "perturbed_sampled_ll": -1.574857234954834, "perturbed_original_ll": -1.5556623935699463, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "R1=range(-2,3)\nR2=range(-1,2)\nA1=[(x,y) for x in R1 for y in R1 if 3<x**2+y**2<6]\nA2=[(x,y) for x in R2 for y in R2]\ndef fi(): return map(int,raw_input().split(\" \"))\ndef f(p,i):\n  x,y=p\n  A=[A1,A2][i>0]\n  return set([(x+dx,y+dy) for dx,dy in A if 0<=x+dx<10 and 0<=y+dy<10])\n\nwhile 1:\n  xf,yf=fi()\n  if yf==xf==0: break\n  raw_input()\n  tmp=fi()\n  PA=zip(tmp[0::2],tmp[1::2])\n  FA=set([(xf,yf)])\n  for ps in PA:\n    SA=f(ps,1)\n    tmp=set([])\n    for pf in FA: tmp=tmp|(SA&f(pf,0))\n    FA=tmp\n  print [\"NA\",\"OK\"][len(FA)>0]", "sampled": "import sys\nfrom collections import deque\n\ndef get_jump_positions(x, y):\n    \"\"\"Returns all valid positions that can be reached from (x, y) with one jump\"\"\"\n    jumps = [\n        (-2, -1), (-2, 1), (2, -1), (2, 1),\n        (-1, -2), (-1, 2), (1, -2), (1, 2)\n    ]\n    positions = []\n    for dx, dy in jumps:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx <= 9 and 0 <= ny <= 9:\n            positions.append((nx, ny))\n    return positions\n\ndef get_water_positions(x, y):\n    \"\"\"Returns all positions covered by water from sprinkler at (x, y)\"\"\"\n    positions = set()\n    for dx in range(-2, 3):\n        for dy in range(-2, 3):\n            if abs(dx) + abs(dy) <= 2:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx <= 9 and 0 <= ny <= 9:\n                    positions.add((nx, ny))\n    return positions\n\ndef solve(px, py, sprinklers):\n    n = len(sprinklers)\n    \n    # BFS to find if there's a path\n    # State: (current_position, sprinkler_index)\n    # We start by jumping from initial position when first sprinkler activates\n    \n    if n == 0:\n        return \"NA\"\n    \n    # Get all positions reachable from initial position\n    initial_jumps = get_jump_positions(px, py)\n    \n    # Check which of these positions are covered by first sprinkler\n    first_sprinkler_water = get_water_positions(sprinklers[0][0], sprinklers[0][1])\n    \n    # Queue: (position, sprinkler_index)\n    queue = deque()\n    visited = set()\n    \n    for pos in initial_jumps:\n        if pos in first_sprinkler_water:\n            queue.append((pos, 0))\n            visited.add((pos, 0))\n    \n    # If we reach the last sprinkler, we survived\n    while queue:\n        (x, y), spr_idx = queue.popleft()\n        \n        # If we're at the last sprinkler, we survived\n        if spr_idx == n - 1:\n            return \"OK\"\n        \n        # Try to jump to next sprinkler's water area\n        next_spr_idx = spr_idx + 1\n        next_water = get_water_positions(sprinklers[next_spr_idx][0], sprinklers[next_spr_idx][1])\n        \n        # Get all positions we can jump to\n        jump_positions = get_jump_positions(x, y)\n        \n        for next_pos in jump_positions:\n            if next_pos in next_water:\n                state = (next_pos, next_spr_idx)\n                if state not in visited:\n                    visited.add(state)\n                    queue.append(state)\n    \n    return \"NA\"\n\n# Read input\nwhile True:\n    line = input().split()\n    px, py = int(line[0]), int(line[1])\n    \n    if px == 0 and py == 0:\n        break\n    \n    n = int(input())\n    coords = list(map(int, input().split()))\n    \n    sprinklers = []\n    for i in range(n):\n        x = coords[2 * i]\n        y = coords[2 * i + 1]\n        sprinklers.append((x, y))\n    \n    result = solve(px, py, sprinklers)\n    print(result)\n", "perturbed_sampled": ["import sys from collections import deque def get_jump_positions(x, y): \"\"\"Returns all valid positions that can be reached from (x, y) with one jump\"\"\" jumps = [ (-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2),  +  and 0 <=  (x, y)\"\"\" positions = set() for dx in range(-2, 3): for dy in range(-2, 3): if abs(dx) + abs(dy) <= 2: nx, ny = x + dx, y + dy if 0 <= nx  return positions def solve(px, py, sprinklers): n  # State:  when first sprinkler activates if n == 0:  initial_jumps = get_jump_positions(px, py) # Check which of these positions are covered by first sprinkler first_sprinkler_water = get_water_positions(sprinklers[0][0],  set() for pos in initial_jumps: if pos in first_sprinkler_water: queue.append((pos, 0)) visited.add((pos, 0)) # If we reach the  queue.popleft() # If we're at the last sprinkler, we survived if spr_idx == n - 1: return \"OK\" # Try to jump to next  to jump_positions = get_jump_positions(x, y) for next_pos in jump_positions: if next_pos  visited: visited.add(state)  in range(n): x = coords[2 * i] y = coords[2 * i + 1] sprinklers.append((x, y)) result = solve(px, py, sprinklers) print(result)"], "perturbed_original": [" R1 if 3<x**2+y**2<6] A2=[(x,y)  return map(int,raw_input().split(\" \")) def f(p,i): x,y=p  0<=y+dy<10]) while 1: xf,yf=fi() if yf==xf==0: break raw_input() tmp=fi() PA=zip(tmp[0::2],tmp[1::2]) FA=set([(xf,yf)]) for ps in PA: SA=f(ps,1) tmp=set([]) for pf in FA: tmp=tmp|(SA&f(pf,0)) FA=tmp print [\"NA\",\"OK\"][len(FA)>0]"], "original_ll": -1.399677038192749, "sampled_ll": -0.6926193237304688, "all_perturbed_sampled_ll": [-1.8570622205734253], "all_perturbed_original_ll": [-2.8885231018066406], "perturbed_sampled_ll": -1.8570622205734253, "perturbed_original_ll": -2.8885231018066406, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  float x,y;\n  \n  while(scanf(\"%f%f\",&x,&y)!=EOF){   \n    if(x<35.5&&y<71)\n      puts(\"AAA\");\n    else if(x<37.5&&y<77)\n      puts(\"AA\");\n    else if(x<40&&y<83)\n      puts(\"A\");\n    else if(x<43&&y<89)\n      puts(\"B\");\n    else if(x<50&&y<105)\n      puts(\"C\");\n    else if(x<55&&y<116)\n      puts(\"D\");\n    else if(x<70&&y<148)\n      puts(\"E\");\n    else\n      puts(\"NA\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double t1, t2;\n    \n    while (scanf(\"%lf %lf\", &t1, &t2) == 2) {\n        if (t1 < 35.50 && t2 < 71.00) {\n            printf(\"AAA\\n\");\n        } else if (t1 < 37.50 && t2 < 77.00) {\n            printf(\"AA\\n\");\n        } else if (t1 < 40.00 && t2 < 83.00) {\n            printf(\"A\\n\");\n        } else if (t1 < 43.00 && t2 < 89.00) {\n            printf(\"B\\n\");\n        } else if (t1 < 50.00 && t2 < 105.00) {\n            printf(\"C\\n\");\n        } else if (t1 < 55.00 && t2 < 116.00) {\n            printf(\"D\\n\");\n        } else if (t1 < 70.00 && t2 < 148.00) {\n            printf(\"E\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" %lf\", &t1, &t2) == 2)  printf(\"AAA\\n\"); } else if (t1 < 37.50 && t2 < 77.00) { printf(\"AA\\n\"); } else if (t1 < 40.00 && t2 < 83.00) {  89.00) { printf(\"B\\n\"); } else if (t1 < 50.00 && t2 < 105.00) { printf(\"C\\n\"); } else if (t1 < 55.00 && t2 < 116.00) {  return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ float x,y; while(scanf(\"%f%f\",&x,&y)!=EOF){ if(x<35.5&&y<71) puts(\"AAA\");  if(x<50&&y<105) puts(\"C\"); else if(x<55&&y<116) puts(\"D\"); else if(x<70&&y<148) puts(\"E\"); else puts(\"NA\"); } return 0; }"], "original_ll": -0.9567145705223083, "sampled_ll": -0.5097765922546387, "all_perturbed_sampled_ll": [-1.194952368736267], "all_perturbed_original_ll": [-1.6322948932647705], "perturbed_sampled_ll": -1.194952368736267, "perturbed_original_ll": -1.6322948932647705, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble eps=0.000000000000000001;\n\t\twhile(sc.hasNext()){\n\t\t\tdouble n=sc.nextDouble();\n\t\t\tdouble m=sc.nextDouble();\n\t\t\tif(n<35.5-eps && m<71.0-eps){\n\t\t\t\tSystem.out.println(\"AAA\");\n\t\t\t}\n\t\t\telse if(n<37.5-eps && m<77.0-eps){\n\t\t\t\tSystem.out.println(\"AA\");\n\t\t\t}\n\t\t\telse if(n<40.0-eps && m<83.0-eps){\n\t\t\t\tSystem.out.println(\"A\");\n\t\t\t}\n\t\t\telse if(n<43.0-eps && m<89.0-eps){\n\t\t\t\tSystem.out.println(\"B\");\n\t\t\t}\n\t\t\telse if(n<50.0-eps && m<105.0-eps){\n\t\t\t\tSystem.out.println(\"C\");\n\t\t\t}\n\t\t\telse if(n<55.0-eps && m<116.0-eps){\n\t\t\t\tSystem.out.println(\"D\");\n\t\t\t}\n\t\t\telse if(n<70.0-eps && m<148.0-eps){\n\t\t\t\tSystem.out.println(\"E\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double t1 = sc.nextDouble();\n            double t2 = sc.nextDouble();\n            \n            String result = \"NA\";\n            \n            if (t1 < 35.50 && t2 < 71.00) {\n                result = \"AAA\";\n            } else if (t1 < 37.50 && t2 < 77.00) {\n                result = \"AA\";\n            } else if (t1 < 40.00 && t2 < 83.00) {\n                result = \"A\";\n            } else if (t1 < 43.00 && t2 < 89.00) {\n                result = \"B\";\n            } else if (t1 < 50.00 && t2 < 105.00) {\n                result = \"C\";\n            } else if (t1 < 55.00 && t2 < 116.00) {\n                result = \"D\";\n            } else if (t1 < 70.00 && t2 < 148.00) {\n                result = \"E\";\n            }\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main {   = sc.nextDouble(); String  \"AA\"; } else if (t1 < 40.00 && t2 < 83.00) { result = \"A\"; } else if (t1 < 43.00 && t2 < 89.00) { result =  105.00) { result = \"C\"; } else if (t1 < 55.00 && t2 < 116.00) { result = \"D\"; } else if (t1 < 70.00 && t2 < 148.00) { result = \"E\"; } System.out.println(result); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc=new Scanner(System.in); double eps=0.000000000000000001;  else if(n<37.5-eps && m<77.0-eps){ System.out.println(\"AA\"); } else if(n<40.0-eps && m<83.0-eps){  } else if(n<70.0-eps && m<148.0-eps){ System.out.println(\"E\"); } else{ System.out.println(\"NA\"); } } } }"], "original_ll": -0.589601993560791, "sampled_ll": -0.4822142720222473, "all_perturbed_sampled_ll": [-1.3573662042617798], "all_perturbed_original_ll": [-1.394124984741211], "perturbed_sampled_ll": -1.3573662042617798, "perturbed_original_ll": -1.394124984741211, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n# 500 M\t1000 M\n# AAA \u7d1a\t35 \u79d2 50\t1 \u5206 11 \u79d2 00\n# AA \u7d1a\t37 \u79d2 50\t1 \u5206 17 \u79d2 00\n# A \u7d1a\t40 \u79d2 00\t1 \u5206 23 \u79d2 00\n# B \u7d1a\t43 \u79d2 00\t1 \u5206 29 \u79d2 00\n# C \u7d1a\t50 \u79d2 00\t1 \u5206 45 \u79d2 00\n# D \u7d1a\t55 \u79d2 00\t1 \u5206 56 \u79d2 00\n# E \u7d1a\t1\u520610 \u79d2 00\t2 \u5206 28 \u79d2 00\n\nranks = [\"AAA\",\"AA\",\"A\",\"B\",\"C\",\"D\",\"E\",\"NA\"]\ntimesA = [35.50,37.50,40,43,50,55,70]\ntimesB = [71,77,83,89,105,116,148]\n\nwhile(1):\n    try:\n        a,b = (float(x) for x in input().split())\n        rankA = rankB = 7\n        # checkA\n        for i in range(0,7):\n            if timesA[i] > a:\n                rankA = i\n                break\n        # checkB\n        for i in range(rankA,7):\n            if timesB[i] > b:\n                rankB = max(rankA,i)\n                break\n        print(ranks[rankB])\n    except:\n        break\n", "sampled": "import sys\n\ngrades = [\n    (\"AAA\", 35.50, 71.00),\n    (\"AA\", 37.50, 77.00),\n    (\"A\", 40.00, 83.00),\n    (\"B\", 43.00, 89.00),\n    (\"C\", 50.00, 105.00),\n    (\"D\", 55.00, 116.00),\n    (\"E\", 70.00, 148.00)\n]\n\nfor line in sys.stdin:\n    t1, t2 = map(float, line.strip().split())\n    \n    result = \"NA\"\n    for grade, time_500, time_1000 in grades:\n        if t1 < time_500 and t2 < time_1000:\n            result = grade\n            break\n    \n    print(result)\n", "perturbed_sampled": ["import sys grades  83.00), (\"B\", 43.00, 89.00),  for line in sys.stdin: t1, t2 = map(float, line.strip().split()) result = \"NA\" for grade, time_500, time_1000 in grades: if t1 < time_500 and t2 < time_1000: result = grade break print(result)"], "perturbed_original": [" 50  50 1 \u5206 17 \u79d2 00 # A \u7d1a 40 \u79d2 00 1 \u5206 23 \u79d2 00 # B \u7d1a 43 \u79d2 00 1  1 \u5206 45 \u79d2 00 # D \u7d1a 55 \u79d2 00 1 \u5206  [35.50,37.50,40,43,50,55,70] timesB = [71,77,83,89,105,116,148] while(1): try: a,b = (float(x) for x in input().split()) rankA =  timesA[i] > a: rankA = i break # checkB for i in range(rankA,7): if timesB[i] > b: rankB = max(rankA,i) break print(ranks[rankB]) except: break"], "original_ll": -1.0338561534881592, "sampled_ll": -0.9333469867706299, "all_perturbed_sampled_ll": [-2.004598379135132], "all_perturbed_original_ll": [-1.9133825302124023], "perturbed_sampled_ll": -2.004598379135132, "perturbed_original_ll": -1.9133825302124023, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\ntypedef struct{\n  char name[20];\n  int point;\n}P;\nmain(){\n  int a,b,c,n,i,j,flag=0;\n  while(1){\n\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    if(flag!=0)printf(\"\\n\");\n    flag=1;\n    P temp[n];\n    P flg;\n    for(i=0;i<n;i++){\n      scanf(\"%s %d %d %d\",temp[i].name,&a,&b,&c);\n      temp[i].point=a*3+c;\n    }\n\n    for(i=0;i<n-1;i++){\n      for(j=n-1;j>i;j--){\n\tif(temp[j].point>temp[j-1].point){\n\t  flg=temp[j];\n\t  temp[j]=temp[j-1];\n\t  temp[j-1]=flg;\n\t}\n      }\n    }\n    for(i=0;i<n;i++)printf(\"%s,%d\\n\",temp[i].name,temp[i].point);}\n    \n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[21];\n    int points;\n    int order;\n} Team;\n\nint main() {\n    int n;\n    int first = 1;\n    \n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        if (!first) {\n            printf(\"\\n\");\n        }\n        first = 0;\n        \n        Team teams[10];\n        \n        for (int i = 0; i < n; i++) {\n            int w, l, d;\n            scanf(\"%s %d %d %d\", teams[i].name, &w, &l, &d);\n            teams[i].points = w * 3 + d * 1;\n            teams[i].order = i;\n        }\n        \n        // Bubble sort\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - 1 - i; j++) {\n                if (teams[j].points < teams[j + 1].points ||\n                    (teams[j].points == teams[j + 1].points && teams[j].order > teams[j + 1].order)) {\n                    Team temp = teams[j];\n                    teams[j] = teams[j + 1];\n                    teams[j + 1] = temp;\n                }\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%s,%d\\n\", teams[i].name, teams[i].points);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef struct { char name[21]; int points; int order; }  Team teams[10]; for (int i = 0; i < n; i++) { int w, l, d; scanf(\"%s %d %d %d\", teams[i].name, &w, &l, &d); teams[i].points = w *  Bubble sort for (int i = 0; i < n  < n - 1 - i; j++)  teams[j + 1].points && teams[j].order > teams[j + 1].order)) { Team  1] = temp; } } }  printf(\"%s,%d\\n\", teams[i].name, teams[i].points); } } return 0; }"], "perturbed_original": ["#include<stdio.h> typedef struct{ char name[20]; int point; }P; main(){ int a,b,c,n,i,j,flag=0; while(1){ scanf(\"%d\",&n); if(n==0)break; if(flag!=0)printf(\"\\n\");  } } for(i=0;i<n;i++)printf(\"%s,%d\\n\",temp[i].name,temp[i].point);} return 0; }"], "original_ll": -0.9878860712051392, "sampled_ll": -0.431863397359848, "all_perturbed_sampled_ll": [-1.6212409734725952], "all_perturbed_original_ll": [-1.8030279874801636], "perturbed_sampled_ll": -1.6212409734725952, "perturbed_original_ll": -1.8030279874801636, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n  public static void main (String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    String out = \"\";\n    while (scanner.hasNext()) {\n      int n = scanner.nextInt();\n      if (n == 0) {\n        break;\n      }\n      List<String> ts = new ArrayList<String>();\n      for (int ii = 0; ii < n; ii++) {\n        String t = scanner.next();\n        int w = scanner.nextInt();\n        int l = scanner.nextInt();\n        int d = scanner.nextInt();\n        String wp = \"0000\" + (w * 3 + d);\n        wp = wp.substring(wp.length() - 5);\n        String idx = \"00\" + (n - ii);\n        idx = idx.substring(idx.length() - 3);\n        ts.add(wp + \",\" + idx + \",\" + t);\n      }\n      Collections.sort(ts);\n      Collections.reverse(ts);\n      for (String el : ts) {\n        String[] works = el.split(\",\");\n        int wp = Integer.parseInt(works[0]);\n        out += works[2] + \",\" + wp + \"\\n\";\n      }\n      out += \"\\n\";\n    }\n    System.out.print(out.substring(0, out.length() - 1));\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Team {\n        String name;\n        int points;\n        int order;\n        \n        Team(String name, int points, int order) {\n            this.name = name;\n            this.points = points;\n            this.order = order;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        boolean first = true;\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            if (!first) {\n                System.out.println();\n            }\n            first = false;\n            \n            List<Team> teams = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                int w = sc.nextInt();\n                int l = sc.nextInt();\n                int d = sc.nextInt();\n                \n                int points = w * 3 + d * 1;\n                teams.add(new Team(name, points, i));\n            }\n            \n            teams.sort((a, b) -> {\n                if (a.points != b.points) {\n                    return b.points - a.points;\n                }\n                return a.order - b.order;\n            });\n            \n            for (Team team : teams) {\n                System.out.println(team.name + \",\" + team.points);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Team { String name; int points; int order; Team(String name, int points, int  = false; List<Team> teams = new ArrayList<>(); for (int i = 0; i < n; i++) { String name = sc.next(); int w = sc.nextInt();   points, i)); } teams.sort((a, b) -> { if (a.points != b.points) { return b.points - a.points; } return a.order - b.order; }); for (Team team : teams) { System.out.println(team.name + \",\" + team.points); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main { public static void main (String[] args) { Scanner scanner = new  = scanner.nextInt(); if (n == 0)  t  int d = scanner.nextInt(); String wp = \"0000\" + (w * 3 + d); wp = wp.substring(wp.length() - 5); String idx = \"00\" + (n - ii); idx = idx.substring(idx.length() - 3); ts.add(wp  Collections.reverse(ts); for   + \"\\n\"; } out += \"\\n\"; } System.out.print(out.substring(0, out.length() - 1)); } }"], "original_ll": -0.8904496431350708, "sampled_ll": -0.3944127559661865, "all_perturbed_sampled_ll": [-1.3665575981140137], "all_perturbed_original_ll": [-2.3346354961395264], "perturbed_sampled_ll": -1.3665575981140137, "perturbed_original_ll": -2.3346354961395264, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "isPrint = False\n\nwhile True:\n\n    inputCount = int(input())\n\n    if inputCount == 0:\n        break\n\n    if isPrint:\n        print()\n    else:\n        isPrint = True\n\n    matchList = []\n\n    for lp in range(inputCount):\n\n        name, win, lose, draw = [item for item in input().split(\" \")]\n        score = int(win) * 3 + int(draw)\n\n        matchList.append([name, score])\n\n    matchList.sort(key=lambda item: -item[1])\n\n    for name, score in matchList:\n        print(name + \",\" + str(score))\n\n", "sampled": "results = []\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    teams = []\n    for i in range(n):\n        parts = input().split()\n        name = parts[0]\n        w = int(parts[1])\n        l = int(parts[2])\n        d = int(parts[3])\n        points = w * 3 + d * 1\n        teams.append((name, points, i))\n    \n    teams.sort(key=lambda x: (-x[1], x[2]))\n    \n    result = []\n    for team in teams:\n        result.append(f\"{team[0]},{team[1]}\")\n    \n    results.append(result)\n\nfor i, result in enumerate(results):\n    for line in result:\n        print(line)\n    if i < len(results) - 1:\n        print()\n", "perturbed_sampled": ["results = [] while  = [] for i in range(n): parts = input().split() name = parts[0] w = int(parts[1]) l = int(parts[2]) d = int(parts[3]) points = w * 3 + d * 1 teams.append((name, points, i)) teams.sort(key=lambda x: (-x[1], x[2])) result = []  len(results) - 1: print()"], "perturbed_original": ["isPrint = False while True: inputCount  in range(inputCount): name,  score = int(win) * 3 + int(draw) matchList.append([name, score]) matchList.sort(key=lambda item: -item[1]) for name, score in matchList: print(name + \",\" + str(score))"], "original_ll": -1.2044012546539307, "sampled_ll": -0.5875434279441833, "all_perturbed_sampled_ll": [-1.6682076454162598], "all_perturbed_original_ll": [-2.8176522254943848], "perturbed_sampled_ll": -1.6682076454162598, "perturbed_original_ll": -2.8176522254943848, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<time.h>\n#include<string.h>\nint main(void) {\n\ttime_t tim1,tim2;\n\tstruct tm d;\n\tdouble diff;\n\tint year1, year2, month1, month2, day1, day2;\n\twhile (1) {\n\t\tscanf(\"%d %d %d %d %d %d\",&year1,&month1,&day1,&year2,&month2,&day2);\n\t\tif (month1 == -1 || year1 == -1 || day1 == -1 ||month2 == -1 || year2 == -1 || day2 == -1) break;\n\t\tmemset(&d,0,sizeof(d));\n\t\td.tm_year = year1 - 1900;\n\t\td.tm_mon = month1 - 1;\n\t\td.tm_mday = day1;\n\t\ttim1 = mktime(&d);\n\t\td.tm_year = year2 - 1900;\n\t\td.tm_mon = month2 - 1;\n\t\td.tm_mday = day2;\n\t\ttim2 = mktime(&d);\n\n\t\tdiff = difftime(tim2, tim1);\n\n\t\tprintf(\"%d\\n\",(int)(diff/60/60/24+0.5));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint is_leap(int year) {\n    if (year % 400 == 0) return 1;\n    if (year % 100 == 0) return 0;\n    if (year % 4 == 0) return 1;\n    return 0;\n}\n\nint days_in_month(int year, int month) {\n    int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    if (month == 2 && is_leap(year)) {\n        return 29;\n    }\n    return days[month];\n}\n\nint days_from_epoch(int year, int month, int day) {\n    int total = 0;\n    \n    // Add days for complete years from year 1\n    for (int y = 1; y < year; y++) {\n        if (is_leap(y)) {\n            total += 366;\n        } else {\n            total += 365;\n        }\n    }\n    \n    // Add days for complete months in the current year\n    for (int m = 1; m < month; m++) {\n        total += days_in_month(year, m);\n    }\n    \n    // Add the days\n    total += day;\n    \n    return total;\n}\n\nint main() {\n    int y1, m1, d1, y2, m2, d2;\n    \n    while (scanf(\"%d %d %d %d %d %d\", &y1, &m1, &d1, &y2, &m2, &d2) == 6) {\n        if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) {\n            break;\n        }\n        \n        int days1 = days_from_epoch(y1, m1, d1);\n        int days2 = days_from_epoch(y2, m2, d2);\n        \n        printf(\"%d\\n\", days2 - days1);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int is_leap(int year)  (year %  int  31, 30, 31, 31, 30, 31, 30, 31}; if (month == 2 && is_leap(year)) { return 29; }  { int total = 0; // Add days for complete years from year 1 for (int y = 1; y  } else  complete  } // Add the days total += day; return total; } int main() { int y1, m1, d1, y2, m2, d2; while (scanf(\"%d %d %d %d  || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) { break; } int days1 = days_from_epoch(y1, m1, d1); int days2 = days_from_epoch(y2, m2, d2); printf(\"%d\\n\", days2 - days1); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<time.h> #include<string.h> int  year1, year2, month1, month2, day1, day2; while (1) { scanf(\"%d %d %d %d %d %d\",&year1,&month1,&day1,&year2,&month2,&day2); if (month1 == -1 || year1 == -1 || day1 ==  == -1) break; memset(&d,0,sizeof(d)); d.tm_year = year1 - 1900; d.tm_mon = month1  = day2; tim2 = mktime(&d); diff = difftime(tim2, tim1); printf(\"%d\\n\",(int)(diff/60/60/24+0.5)); } return 0; }"], "original_ll": -0.6324153542518616, "sampled_ll": -0.31366246938705444, "all_perturbed_sampled_ll": [-1.5592737197875977], "all_perturbed_original_ll": [-1.363810420036316], "perturbed_sampled_ll": -1.5592737197875977, "perturbed_original_ll": -1.363810420036316, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n\npublic class Main {\n\n\tfinal int DAY_MONTH[]={0, 31, 28, 31, 30, 31, 30, 31, 31, 30 ,31, 30 ,31};\n\t\n\tScanner sc;\n\t\n\tint isLeap(int y){\n\t\tif(y%4==0){\n\t\t\tif(y%100==0){\n\t\t\t\tif(y%400==0){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tint dayCount(int y, int m1, int d1, int m2, int d2){\n\t\tint days=-d1;\n\t\tfor(int m=m1;m<=m2;++m){\n\t\t\tdays+=DAY_MONTH[m];\n\t\t\tif(m==2) days+=isLeap(y);\n\t\t}\n\t\tdays-=DAY_MONTH[m2]+(m2==2?isLeap(y):0)-d2;\n\t\treturn days;\n\t}\n\t\n\tint solve(int y1, int m1, int d1, int y2, int m2, int d2){\n\t\tint days=0;\n\t\tif(y2-y1>=2){\n\t\t\tfor(int y=y1+1;y<y2;++y){\n\t\t\t\tdays+=365+isLeap(y);\n\t\t\t}\n\t\t}\n\t\tif(y2-y1>=1){\n\t\t\tdays+=dayCount(y1, m1, d1, 12, 31)+dayCount(y2, 1, 1, m2, d2)+1;\n\t\t}\n\t\telse{\n\t\t\tdays=dayCount(y1, m1, d1, m2, d2);\n\t\t}\n\t\treturn days;\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint y1=ni(), m1=ni(), d1=ni(), y2=ni(), m2=ni(), d2=ni();\n\t\t\tif(y1<0||m1<0||d1<0||y2<0||m2<0||d2<0) break;\n\t\t\t\n\t\t\tSystem.out.println(solve(y1, m1, d1, y2, m2, d2));\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int y1 = sc.nextInt();\n            int m1 = sc.nextInt();\n            int d1 = sc.nextInt();\n            int y2 = sc.nextInt();\n            int m2 = sc.nextInt();\n            int d2 = sc.nextInt();\n            \n            if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) {\n                break;\n            }\n            \n            int days = countDays(y1, m1, d1, y2, m2, d2);\n            System.out.println(days);\n        }\n        \n        sc.close();\n    }\n    \n    static int countDays(int y1, int m1, int d1, int y2, int m2, int d2) {\n        int days1 = toDays(y1, m1, d1);\n        int days2 = toDays(y2, m2, d2);\n        return days2 - days1;\n    }\n    \n    static int toDays(int year, int month, int day) {\n        int days = 0;\n        \n        // Count days for complete years from year 1\n        for (int y = 1; y < year; y++) {\n            if (isLeapYear(y)) {\n                days += 366;\n            } else {\n                days += 365;\n            }\n        }\n        \n        // Count days for complete months in the current year\n        for (int m = 1; m < month; m++) {\n            days += getDaysInMonth(year, m);\n        }\n        \n        // Add remaining days\n        days += day;\n        \n        return days;\n    }\n    \n    static boolean isLeapYear(int year) {\n        if (year % 400 == 0) {\n            return true;\n        }\n        if (year % 100 == 0) {\n            return false;\n        }\n        if (year % 4 == 0) {\n            return true;\n        }\n        return false;\n    }\n    \n    static int getDaysInMonth(int year, int month) {\n        int[] days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        \n        if (month == 2 && isLeapYear(year)) {\n            return 29;\n        }\n        \n        return days[month];\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int y1 = sc.nextInt(); int  sc.nextInt(); int m2 = sc.nextInt(); int d2  || d1 < 0 || y2  { break; }   d1, int y2, int m2, int d2)  toDays(y2, m2, d2); return days2 - days1; } static int toDays(int year, int month, int day) { int days =  for  (isLeapYear(y)) { days += 366; } else { days += 365; } } // Count days for complete  m < month; m++)  days += day; return days; } static boolean isLeapYear(int year) { if (year % 400 ==  0) { return  true; } return false; } static int getDaysInMonth(int year, int month) { int[] days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  return days[month]; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { final int DAY_MONTH[]={0, 31,  return 1; } } else{ return 0; }  int d2){ int days=-d1;  int solve(int y1, int m1, int d1, int y2, int m2, int d2){ int days=0; if(y2-y1>=2){ for(int y=y1+1;y<y2;++y){ days+=365+isLeap(y); } } if(y2-y1>=1){ days+=dayCount(y1, m1, d1, 12, 31)+dayCount(y2, 1, 1, m2, d2)+1; } else{ days=dayCount(y1, m1, d1, m2, d2); } return days; } int ni(){ return sc.nextInt(); } void io(){ sc=new Scanner(System.in); while(true){ int y1=ni(),  y2, m2, d2)); } sc.close(); } public static void  } }"], "original_ll": -0.5285140872001648, "sampled_ll": -0.24100540578365326, "all_perturbed_sampled_ll": [-1.342590570449829], "all_perturbed_original_ll": [-1.5275342464447021], "perturbed_sampled_ll": -1.342590570449829, "perturbed_original_ll": -1.5275342464447021, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f1():\n    if y1 == y2 and m1 == m2:\n        return d2- d1\n    \n    a = 0\n    if y1 % 400 == 0 or (y1 % 4 == 0 and y1 % 100 != 0):\n        a = 29\n    else:\n        a = 28\n    \n    t = 0\n    if m1 in [4,6,9,11]:\n        t += (30 - d1 + 1)\n    elif m1 in [1,3,5,7,8,10,12]:\n        t += (31 - d1 + 1)\n    else:\n        t += (a - d1 + 1)\n        \n        \n    if y1 == y2:\n        return f3(t, m1+1)\n    else:\n        for m in range(m1+1, 13):\n            if m in [4,6,9,11]:\n                t += 30\n            elif m in [1,3,5,7,8,10,12]:\n                t += 31\n            else:\n                t += a\n            \n        return f2(t)\n    \ndef f2(t):\n    for y in range(y1+1, y2):\n        if y % 400 == 0 or (y % 4 == 0 and y % 100 != 0):\n            t += 366\n        else:\n            t += 365\n    \n    return f3(t, 1)\n    \ndef f3(t, s):\n    a = 0\n    if y2 % 400 == 0 or (y2 % 4 == 0 and y2 % 100 != 0):\n        a = 29\n    else:\n        a = 28\n        \n    for m in range(s, m2):\n        if m in [4,6,9,11]:\n            t += 30\n        elif m in [1,3,5,7,8,10,12]:\n            t += 31\n        else:\n            t += a\n            \n    t += (d2 - 1)\n            \n    return t\n            \nwhile True:\n    y1, m1, d1, y2, m2, d2 = map(int, raw_input().split())\n    if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0:\n        break\n    print f1()", "sampled": "def is_leap_year(year):\n    if year % 400 == 0:\n        return True\n    if year % 100 == 0:\n        return False\n    if year % 4 == 0:\n        return True\n    return False\n\ndef days_in_month(year, month):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month in [4, 6, 9, 11]:\n        return 30\n    elif month == 2:\n        return 29 if is_leap_year(year) else 28\n\ndef days_from_epoch(year, month, day):\n    # Calculate days from year 0\n    days = 0\n    \n    # Add days for complete years\n    for y in range(1, year):\n        if is_leap_year(y):\n            days += 366\n        else:\n            days += 365\n    \n    # Add days for complete months in the current year\n    for m in range(1, month):\n        days += days_in_month(year, m)\n    \n    # Add remaining days\n    days += day\n    \n    return days\n\nwhile True:\n    line = list(map(int, input().split()))\n    y1, m1, d1, y2, m2, d2 = line\n    \n    if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0:\n        break\n    \n    days1 = days_from_epoch(y1, m1, d1)\n    days2 = days_from_epoch(y2, m2, d2)\n    \n    print(days2 - days1)\n", "perturbed_sampled": ["def is_leap_year(year): if year % 400 ==  False if year % 4 == 0: return True return False def days_in_month(year, month): if month in [1, 3, 5,  6, 9, 11]: return 30 elif month == 2: return 29 if is_leap_year(year) else 28 def days_from_epoch(year, month, day): # Calculate days from year 0 days = 0 # Add days  days for complete months in the current year for m  = list(map(int, input().split())) y1, m1,  or m1 <  m2 < 0 or d2 < 0: break days1 = days_from_epoch(y1, m1, d1) days2 = days_from_epoch(y2, m2, d2) print(days2 - days1)"], "perturbed_original": ["def f1(): if y1 == y2 and <extra_id_11>- m1<extra_id_12>: d1 -= 31<extra_id_13>. split (<extra_id_14>1 y1 % 400 == 0 or (y1 % 4 == 0 and y1 % 100 != 0): a = 29 else: a = 28 t = 0 if m1 in [4,6,9,11]: t += (30 - d1 + 1) elif m1 in [1,3,5,7,8,10,12]: t += (31 - d1 + 1) else: t += (a - d1 + 1) if y1 == y2: return f3(t, m1+1) else: for m in range(m1+1, 13): if m in [4,6,9,11]: t += 30  a  def f3(t, s): a = 0  while True: y1, m1, d1, y2, m2, d2 = map(int, raw_input().split()) if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0: break print f1()"], "original_ll": -0.5237615704536438, "sampled_ll": -0.3621664345264435, "all_perturbed_sampled_ll": [-1.7178014516830444], "all_perturbed_original_ll": [-1.4256393909454346], "perturbed_sampled_ll": -1.7178014516830444, "perturbed_original_ll": -1.4256393909454346, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "v[81],e[81];\nB(p,s0,s1){\n\tint f[10]={0},i,j;\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tif(f[v[p]])\n\t\t\t\te[~f[v[p]]]=e[p]=1;\n\t\t\telse\n\t\t\t\tf[v[p]]=~p;\n\t\t\tp+=s0;\n\t\t}\n\t\tp+=s1-3*s0;\n\t}\n}\nmain(i,f){\n\tscanf(\"%*d\\n\");\n\tfor(f=i=0;~scanf(\"%d\",v+i);){\n\t\tif(++i==81){\n\t\t\tmemset(e,0,sizeof(e));\n\t\t\tfor(i=0;i<9;i++){\n\t\t\t\tB(0+i*9,1+0*9,3+0*9);\n\t\t\t\tB(i+0*9,0+1*9,0+3*9);\n\t\t\t\tB(i%3*3+i/3*3*9,1+0*9,0+1*9);\n\t\t\t}\n\t\t\tif(f++)\n\t\t\t\tputs(\"\");\n\t\t\tfor(i=0;i<81;i++){\n\t\t\t\tprintf(\"%c%d\",e[i]?'*':' ',v[i]);\n\t\t\t\tif(i%9==8)\n\t\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t\ti=0;\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int dataset = 0; dataset < n; dataset++) {\n        int grid[9][9];\n        int error[9][9];\n        \n        // Read input\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                scanf(\"%d\", &grid[i][j]);\n                error[i][j] = 0;\n            }\n        }\n        \n        // Check rows\n        for (int i = 0; i < 9; i++) {\n            int count[10] = {0};\n            for (int j = 0; j < 9; j++) {\n                count[grid[i][j]]++;\n            }\n            for (int j = 0; j < 9; j++) {\n                if (count[grid[i][j]] > 1) {\n                    error[i][j] = 1;\n                }\n            }\n        }\n        \n        // Check columns\n        for (int j = 0; j < 9; j++) {\n            int count[10] = {0};\n            for (int i = 0; i < 9; i++) {\n                count[grid[i][j]]++;\n            }\n            for (int i = 0; i < 9; i++) {\n                if (count[grid[i][j]] > 1) {\n                    error[i][j] = 1;\n                }\n            }\n        }\n        \n        // Check 3x3 blocks\n        for (int block_i = 0; block_i < 3; block_i++) {\n            for (int block_j = 0; block_j < 3; block_j++) {\n                int count[10] = {0};\n                for (int i = block_i * 3; i < block_i * 3 + 3; i++) {\n                    for (int j = block_j * 3; j < block_j * 3 + 3; j++) {\n                        count[grid[i][j]]++;\n                    }\n                }\n                for (int i = block_i * 3; i < block_i * 3 + 3; i++) {\n                    for (int j = block_j * 3; j < block_j * 3 + 3; j++) {\n                        if (count[grid[i][j]] > 1) {\n                            error[i][j] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Output\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (error[i][j]) {\n                    printf(\"*%d\", grid[i][j]);\n                } else {\n                    printf(\" %d\", grid[i][j]);\n                }\n                if (j < 8) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n        \n        if (dataset < n - 1) {\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main()  dataset < n; dataset++) { int grid[9][9]; int  j < 9; j++) { scanf(\"%d\", &grid[i][j]); error[i][j] = 0; } } // Check rows for (int i = 0; i < 9; i++) { int count[10] = {0}; for (int   if  // Check columns for (int j = 0; j  } for (int i = 0; i < 9; i++) { if (count[grid[i][j]] > 1) { error[i][j] = 1; } } } // Check 3x3 blocks for (int block_i = 0; block_i  < 3; block_j++)  j < block_j * 3 + 3; j++) { count[grid[i][j]]++; } } for (int i =  i++) { for (int j = block_j * 3; j < block_j * 3 + 3; j++) { if (count[grid[i][j]] > 1) { error[i][j] = 1; } } } } } //  { for (int j = 0; j < 9; j++) { if (error[i][j]) { printf(\"*%d\", grid[i][j]);  8) printf(\" \"); } printf(\"\\n\"); } if (dataset < n - 1) { printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["v[81],e[81]; B(p,s0,s1){ int f[10]={0},i,j; for(i=0;i<3;i++){ for(j=0;j<3;j++){ if(f[v[p]]) e[~f[v[p]]]=e[p]=1; else f[v[p]]=~p; p+=s0; } p+=s1-3*s0; } } main(i,f){ scanf(\"%*d\\n\"); for(f=i=0;~scanf(\"%d\",v+i);){ if(++i==81){  ',v[i]); if(i%9==8) puts(\"\"); } i=0; } } }"], "original_ll": -1.4610804319381714, "sampled_ll": -0.21174786984920502, "all_perturbed_sampled_ll": [-1.196282982826233], "all_perturbed_original_ll": [-2.26313853263855], "perturbed_sampled_ll": -1.196282982826233, "perturbed_original_ll": -2.26313853263855, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nclass Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        for (int i = 0; i < n; i++) {\n            int[][] map = new int[9][9];\n            boolean[][] ok = new boolean[9][9];\n            for (int j = 0; j < 9; j++) {\n                String[] input = br.readLine().split(\" \");\n                for (int k = 0; k < 9; k++) {\n                    map[j][k] = Integer.parseInt(input[k]);\n                }\n            }\n\n            // horizontal check\n            for (int j = 0; j < 9; j++) {\n                boolean[] oneToNine = new boolean[10]; // index0\u306f\u4f7f\u308f\u306a\u3044\n                for (int k = 0; k < 9; k++) {\n                    if (!oneToNine[map[j][k]]) {\n                        oneToNine[map[j][k]] = true;\n                    } else {\n                        ok[j][k] = true;\n                        for (int l = 0; l < k; l++) {\n                            if (map[j][l] == map[j][k]) {\n                                ok[j][l] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // vertical check\n            for (int j = 0; j < 9; j++) {\n                boolean[] oneToNine = new boolean[10];\n                for (int k = 0; k < 9; k++) {\n                    if (!oneToNine[map[k][j]]) {\n                        oneToNine[map[k][j]] = true;\n                    } else {\n                        ok[k][j] = true;\n                        for (int l = 0; l < k; l++) {\n                            if (map[l][j] == map[k][j]) {\n                                ok[l][j] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // display\n            for (int j = 0; j < 9; j++) {\n                for (int k = 0; k < 9; k++) {\n                    if (ok[j][k])\n                        System.out.print(\"*\");\n                    else\n                        System.out.print(\" \");\n\n                    System.out.print(map[j][k]);\n                }\n                System.out.println();\n            }\n\n        }\n    }\n}\n", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int t = 0; t < n; t++) {\n            if (t > 0) {\n                System.out.println();\n            }\n            \n            int[][] grid = new int[9][9];\n            for (int i = 0; i < 9; i++) {\n                String line = sc.nextLine();\n                String[] tokens = line.trim().split(\"\\\\s+\");\n                for (int j = 0; j < 9; j++) {\n                    grid[i][j] = Integer.parseInt(tokens[j]);\n                }\n            }\n            \n            boolean[][] error = new boolean[9][9];\n            \n            // Check rows\n            for (int i = 0; i < 9; i++) {\n                int[] count = new int[10];\n                for (int j = 0; j < 9; j++) {\n                    count[grid[i][j]]++;\n                }\n                for (int j = 0; j < 9; j++) {\n                    if (count[grid[i][j]] > 1) {\n                        error[i][j] = true;\n                    }\n                }\n            }\n            \n            // Check columns\n            for (int j = 0; j < 9; j++) {\n                int[] count = new int[10];\n                for (int i = 0; i < 9; i++) {\n                    count[grid[i][j]]++;\n                }\n                for (int i = 0; i < 9; i++) {\n                    if (count[grid[i][j]] > 1) {\n                        error[i][j] = true;\n                    }\n                }\n            }\n            \n            // Check 3x3 blocks\n            for (int blockRow = 0; blockRow < 3; blockRow++) {\n                for (int blockCol = 0; blockCol < 3; blockCol++) {\n                    int[] count = new int[10];\n                    for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) {\n                        for (int j = blockCol * 3; j < blockCol * 3 + 3; j++) {\n                            count[grid[i][j]]++;\n                        }\n                    }\n                    for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) {\n                        for (int j = blockCol * 3; j < blockCol * 3 + 3; j++) {\n                            if (count[grid[i][j]] > 1) {\n                                error[i][j] = true;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // Output\n            for (int i = 0; i < 9; i++) {\n                for (int j = 0; j < 9; j++) {\n                    if (error[i][j]) {\n                        System.out.print(\"*\");\n                    } else {\n                        System.out.print(\" \");\n                    }\n                    System.out.print(grid[i][j]);\n                }\n                System.out.println();\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { for<extra_id_10>i<extra_id_11>j <<extra_id_12>[ j <<extra_id_13>i ++ ) { if<extra_id_14>tokens [<extra_id_15>] ;<extra_id_16>= false<extra_id_17>) {<extra_id_18>+= 1 ; p<extra_id_19>[ j ]<extra_id_20>- 1 ] ; i<extra_id_21>j<extra_id_22>] +<extra_id_23>} else { error [<extra_id_24> Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); for (int t = 0; t  }  i < 9; i++) { String line = sc.nextLine(); String[] tokens   new boolean[9][9]; // Check rows for (int i = 0; i < 9; i++) { int[] count = new int[10]; for (int j = 0; j < 9; j++) { count[grid[i][j]]++; } for (int j = 0; j < 9;  } } } // Check columns for (int j  new int[10]; for (int i = 0; i < 9; i++) { count[grid[i][j]]++; } for (int i =  { error[i][j] = true; } } } // Check 3x3 blocks  for (int  < blockCol * 3 + 3; j++) { count[grid[i][j]]++; } } for (int i = blockRow * 3;  (int j = blockCol * 3; j < blockCol * 3 + 3; j++) { if (count[grid[i][j]] > 1) { error[i][j] = true; } } }  j < 9; j++) { if (error[i][j]) { System.out.print(\"*\"); } else { System.out.print(\" \"); } System.out.print(grid[i][j]); } System.out.println(); } } sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.io.BufferedReader; import java.io.InputStreamReader; class Main { public static void main(String[] args)  < n; i++) { int[][] map = new int[9][9]; boolean[][] ok = new boolean[9][9]; for (int j = 0; j < 9;  = 0; k < 9; k++)  k = 0; k < 9; k++) { if (!oneToNine[map[j][k]]) { oneToNine[map[j][k]] = true; } else { ok[j][k] = true; for (int l = 0; l < k; l++) {  } } } } // vertical check for (int j = 0;  { if (!oneToNine[map[k][j]]) { oneToNine[map[k][j]] = true;   { ok[l][j] = true; break;  = 0; j < 9; j++) { for (int k = 0; k < 9; k++) { if (ok[j][k]) System.out.print(\"*\"); else System.out.print(\" \"); System.out.print(map[j][k]); } System.out.println(); } } } }"], "original_ll": -0.3718263804912567, "sampled_ll": -0.1958947628736496, "all_perturbed_sampled_ll": [-1.5218793153762817], "all_perturbed_original_ll": [-1.181294322013855], "perturbed_sampled_ll": -1.5218793153762817, "perturbed_original_ll": -1.181294322013855, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "R=range(9)\ndef f1(M):\n  global F\n  for y in R:\n    A=M[y]\n    if len(set(A))==9: continue\n    for x in R:\n      if A.count(A[x])>=2: F[y][x]=\"*\"\n  return\ndef f2(M):\n  global F\n  for x in R:\n    A=[M[y][x] for y in R]\n    if len(set(A))==9: continue\n    for y in R:\n      if A.count(A[y])>=2: F[y][x]=\"*\"\n  return\ndef f3(M):\n  global F\n  for i in R:\n    x=i%3*3\n    y=i/3*3\n    A=M[y][x:x+3]+M[y+1][x:x+3]+M[y+2][x:x+3]\n    if len(set(A))==9: continue\n    for j in R:\n      if A.count(A[j])>=2: F[y+j/3][x+j%3]=\"*\"\n  return\n\nn=input()\nwhile n:\n  M=[]\n  F=[[\" \" for _ in [0]*9] for _ in [0]*9]\n  M=[map(int,raw_input().split()) for _ in [0]*9]\n  f1(M)\n  f2(M)\n  f3(M)\n  for i in R:\n    s=zip(F[i],map(str,M[i]))\n    print \"\".join([a+b for a,b in s])\n  if n>1: print\n  n-=1", "sampled": "def solve():\n    n = int(input())\n    \n    for dataset_idx in range(n):\n        grid = []\n        for _ in range(9):\n            row = list(map(int, input().split()))\n            grid.append(row)\n        \n        # Mark errors\n        errors = [[False] * 9 for _ in range(9)]\n        \n        # Check rows\n        for i in range(9):\n            counts = {}\n            for j in range(9):\n                val = grid[i][j]\n                if val not in counts:\n                    counts[val] = []\n                counts[val].append(j)\n            \n            for val, positions in counts.items():\n                if len(positions) > 1:\n                    for j in positions:\n                        errors[i][j] = True\n        \n        # Check columns\n        for j in range(9):\n            counts = {}\n            for i in range(9):\n                val = grid[i][j]\n                if val not in counts:\n                    counts[val] = []\n                counts[val].append(i)\n            \n            for val, positions in counts.items():\n                if len(positions) > 1:\n                    for i in positions:\n                        errors[i][j] = True\n        \n        # Check 3x3 blocks\n        for block_row in range(3):\n            for block_col in range(3):\n                counts = {}\n                for i in range(block_row * 3, block_row * 3 + 3):\n                    for j in range(block_col * 3, block_col * 3 + 3):\n                        val = grid[i][j]\n                        if val not in counts:\n                            counts[val] = []\n                        counts[val].append((i, j))\n                \n                for val, positions in counts.items():\n                    if len(positions) > 1:\n                        for i, j in positions:\n                            errors[i][j] = True\n        \n        # Output\n        for i in range(9):\n            output = []\n            for j in range(9):\n                if errors[i][j]:\n                    output.append('*' + str(grid[i][j]))\n                else:\n                    output.append(' ' + str(grid[i][j]))\n            print(''.join(output))\n        \n        if dataset_idx < n - 1:\n            print()\n\nsolve()\n", "perturbed_sampled": ["def solve(): n = int(input()) for dataset_idx  = list(map(int, input().split())) grid.append(row) # Mark errors errors = [[False]  i in range(9): counts = {} for j in  = [] counts[val].append(j) for val, positions  errors[i][j] = True # Check columns for j in range(9): counts = {} for i in range(9): val = grid[i][j] if val not in counts: counts[val] = [] counts[val].append(i) for val, positions in counts.items(): if len(positions) > 1: for  * 3 + 3): for j in range(block_col * 3,  not in counts: counts[val]  len(positions) > 1: for i, j in positions: errors[i][j] =  for j in range(9): if errors[i][j]: output.append('*' + str(grid[i][j])) else: output.append(' ' + str(grid[i][j])) print(''.join(output)) if dataset_idx < n - 1: print() solve()"], "perturbed_original": ["R=range(9) def f1(M): global F for y  if A.count(A[x])>=2: F[y][x]=\"*\" return def f2(M):  A.count(A[y])>=2: F[y][x]=\"*\" return def f3(M): global F for i in R: x=i%3*3 y=i/3*3 A=M[y][x:x+3]+M[y+1][x:x+3]+M[y+2][x:x+3] if len(set(A))==9: continue for j in R: if A.count(A[j])>=2: F[y+j/3][x+j%3]=\"*\" return n=input() while n: M=[]  M=[map(int,raw_input().split()) for _ in [0]*9] f1(M) f2(M) f3(M) for i in  print n-=1"], "original_ll": -0.7744231820106506, "sampled_ll": -0.3624174892902374, "all_perturbed_sampled_ll": [-1.9339650869369507], "all_perturbed_original_ll": [-1.642745852470398], "perturbed_sampled_ll": -1.9339650869369507, "perturbed_original_ll": -1.642745852470398, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-7)\n\ntypedef struct {\n\tint x,y,r;\n} wall_t;\n\ntypedef struct {\n\tint tx,ty,sx,sy;\n} query_t;\n\nint hitcheck_circle(wall_t w,query_t q) {\n\tint in=0;\n\tint a,b,c;\n\tint minx,miny,maxx,maxy,temp;\n\t/* sieve */\n\tminx=q.tx;maxx=q.sx;\n\tif(minx>maxx){temp=minx;minx=maxx;maxx=temp;}\n\tminy=q.ty;maxy=q.sy;\n\tif(miny>maxy){temp=miny;miny=maxy;maxy=temp;}\n\tif(w.x+w.r<minx || maxx<w.x-w.r)return 0;\n\tif(w.y+w.r<miny || maxy<w.y-w.r)return 0;\n\t/* check if dist<=r */\n\tif((q.tx-w.x)*(q.tx-w.x)+(q.ty-w.y)*(q.ty-w.y)<=w.r*w.r)in++;\n\tif((q.sx-w.x)*(q.sx-w.x)+(q.sy-w.y)*(q.sy-w.y)<=w.r*w.r)in++;\n\tif(in==1)return 1;\n\tif(in==2)return 0;\n\ta=q.ty-q.sy;\n\tb=q.sx-q.tx;\n\tc=(q.tx-q.sx)*q.ty-(q.ty-q.sy)*q.tx;\n\tif((a*w.x+b*w.y+c)*(a*w.x+b*w.y+c)<=w.r*w.r*(a*a+b*b)) {\n\t\t/* check if really hit */\n\t\tc=-c; /* convert a*x+b*y+c=0 to a*x+b*y=c */\n\t\tif(b==0) {\n\t\t\tdouble yy=w.r*w.r-((double)c/a-w.x)*((double)c/a-w.x);\n\t\t\tdouble y1,y2;\n\t\t\ty1=sqrt(yy);y2=-y1;\n\t\t\ty1+=w.y;y2+=w.y;\n\t\t\treturn (miny<y1+EPS && y1<maxy+EPS) || (miny<y2+EPS && y2<maxy+EPS);\n\t\t} else {\n\t\t\tdouble cb=(double)c/b;\n\t\t\tdouble ab=(double)a/b;\n\t\t\tdouble x2k,xk,tk;\n\t\t\tdouble x1,x2;\n\t\t\tx2k=1.0+ab*ab;\n\t\t\txk=-2*w.x+2.0*(w.y-cb)*ab;\n\t\t\ttk=w.x*w.x+(w.y-cb)*(w.y-cb)-w.r*w.r;\n\t\t\tx1=(-xk+sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k);\n\t\t\tx2=(-xk-sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k);\n\t\t\treturn (minx<x1+EPS && x1<maxx+EPS) || (minx<x2+EPS && x2<maxx+EPS);\n\t\t}\n\t}\n\treturn 0;\n}\nint main(void) {\n\tint n;\n\twall_t w[100];\n\tint m;\n\tint i;\n\twhile(scanf(\"%d\",&n)==1 && n>0) {\n\t\tfor(i=0;i<n;i++)scanf(\"%d%d%d\",&w[i].x,&w[i].y,&w[i].r);\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<m;i++) {\n\t\t\tquery_t q;\n\t\t\tint j;\n\t\t\tint hidden;\n\t\t\tscanf(\"%d%d%d%d\",&q.tx,&q.ty,&q.sx,&q.sy);\n\t\t\thidden=0;\n\t\t\tif(q.tx!=q.sx || q.ty!=q.sy) {\n\t\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\t\tif(hitcheck_circle(w[j],q)) {\n\t\t\t\t\t\thidden=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tputs(hidden?\"Safe\":\"Danger\");\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point center;\n    double radius;\n} Circle;\n\nint isInsideCircle(Point p, Circle c) {\n    double dx = p.x - c.center.x;\n    double dy = p.y - c.center.y;\n    return (dx * dx + dy * dy) < (c.radius * c.radius);\n}\n\nint lineSegmentIntersectsCircle(Point p1, Point p2, Circle c) {\n    // Check if either endpoint is inside the circle\n    if (isInsideCircle(p1, c) || isInsideCircle(p2, c)) {\n        return 1;\n    }\n    \n    // Vector from p1 to p2\n    double dx = p2.x - p1.x;\n    double dy = p2.y - p1.y;\n    \n    // Vector from p1 to circle center\n    double fx = c.center.x - p1.x;\n    double fy = c.center.y - p1.y;\n    \n    // Project circle center onto line segment\n    double len_sq = dx * dx + dy * dy;\n    double t = (fx * dx + fy * dy) / len_sq;\n    \n    // Clamp t to [0, 1] to stay on segment\n    if (t < 0) t = 0;\n    if (t > 1) t = 1;\n    \n    // Find closest point on segment\n    double closest_x = p1.x + t * dx;\n    double closest_y = p1.y + t * dy;\n    \n    // Check distance from closest point to circle center\n    double dist_x = c.center.x - closest_x;\n    double dist_y = c.center.y - closest_y;\n    double dist_sq = dist_x * dist_x + dist_y * dist_y;\n    \n    return dist_sq < (c.radius * c.radius);\n}\n\nint isBlocked(Point taro, Point oni, Circle walls[], int n) {\n    // Check if Taro and Oni are both inside the same circle\n    for (int i = 0; i < n; i++) {\n        if (isInsideCircle(taro, walls[i]) && isInsideCircle(oni, walls[i])) {\n            // Both inside same wall, check if blocked by another wall\n            int blocked = 0;\n            for (int j = 0; j < n; j++) {\n                if (i != j && lineSegmentIntersectsCircle(taro, oni, walls[j])) {\n                    blocked = 1;\n                    break;\n                }\n            }\n            if (!blocked) {\n                return 0; // They can see each other\n            }\n        }\n    }\n    \n    // Check if line segment intersects any wall\n    for (int i = 0; i < n; i++) {\n        int taroInside = isInsideCircle(taro, walls[i]);\n        int oniInside = isInsideCircle(oni, walls[i]);\n        \n        // If one is inside and one is outside, blocked\n        if (taroInside != oniInside) {\n            return 1;\n        }\n        \n        // If both outside, check if line intersects wall\n        if (!taroInside && !oniInside) {\n            if (lineSegmentIntersectsCircle(taro, oni, walls[i])) {\n                return 1;\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Circle walls[100];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf %lf\", &walls[i].center.x, &walls[i].center.y, &walls[i].radius);\n        }\n        \n        int m;\n        scanf(\"%d\", &m);\n        \n        for (int i = 0; i < m; i++) {\n            Point taro, oni;\n            scanf(\"%lf %lf %lf %lf\", &taro.x, &taro.y, &oni.x, &oni.y);\n            \n            if (isBlocked(taro, oni, walls, n)) {\n                printf(\"Safe\\n\");\n            } else {\n                printf(\"Danger\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" } Circle; int isInsideCircle(Point p, Circle c) { double dx = p.x - c.center.x; double dy = p.y - c.center.y;  * c.radius); } int lineSegmentIntersectsCircle(Point p1, Point p2, Circle c) { // Check if either endpoint is inside the circle if (isInsideCircle(p1, c) || isInsideCircle(p2, c)) { return 1; } // Vector from p1 to p2 double dx  // Vector  p1.x; double fy = c.center.y - p1.y; // Project circle center onto line segment double len_sq = dx * dx + dy * dy; double t   on segment double closest_x =  t * dy;  dist_x = c.center.x - closest_x; double dist_y = c.center.y - closest_y; double dist_sq = dist_x * dist_x + dist_y * dist_y; return dist_sq < (c.radius * c.radius); } int isBlocked(Point taro, Point oni, Circle walls[], int n) { // Check if Taro and  = 0; i < n; i++) { if (isInsideCircle(taro, walls[i]) && isInsideCircle(oni, walls[i])) {   j < n;  { blocked = 1; break; } } if (!blocked) { return 0; // They can see each other  wall for (int i = 0; i < n; i++) { int taroInside = isInsideCircle(taro, walls[i]); int oniInside = isInsideCircle(oni, walls[i]); // If one  check if line intersects wall if (!taroInside && !oniInside) { if (lineSegmentIntersectsCircle(taro, oni, walls[i])) { return  != 0) { Circle walls[100]; for (int i =  &walls[i].center.y, &walls[i].radius); } int m; scanf(\"%d\", &m); for (int  if (isBlocked(taro, oni, walls, n)) { printf(\"Safe\\n\"); } else { printf(\"Danger\\n\"); } } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> #define EPS (1e-7) typedef  in=0; int a,b,c; int minx,miny,maxx,maxy,temp;  0; if(w.y+w.r<miny || maxy<w.y-w.r)return 0; /* check if dist<=r */ if((q.tx-w.x)*(q.tx-w.x)+(q.ty-w.y)*(q.ty-w.y)<=w.r*w.r)in++;  a*x+b*y+c=0 to a*x+b*y=c */ if(b==0) { double yy=w.r*w.r-((double)c/a-w.x)*((double)c/a-w.x); double y1,y2; y1=sqrt(yy);y2=-y1; y1+=w.y;y2+=w.y;  { double cb=(double)c/b; double ab=(double)a/b; double x2k,xk,tk; double x1,x2; x2k=1.0+ab*ab; xk=-2*w.x+2.0*(w.y-cb)*ab; tk=w.x*w.x+(w.y-cb)*(w.y-cb)-w.r*w.r; x1=(-xk+sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k); x2=(-xk-sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k); return (minx<x1+EPS && x1<maxx+EPS) || (minx<x2+EPS && x2<maxx+EPS); } } return 0; } int main(void) { int n; wall_t w[100]; int m; int i; while(scanf(\"%d\",&n)==1 && n>0) { for(i=0;i<n;i++)scanf(\"%d%d%d\",&w[i].x,&w[i].y,&w[i].r); scanf(\"%d\",&m);  if(q.tx!=q.sx  } } puts(hidden?\"Safe\":\"Danger\"); } } return 0; }"], "original_ll": -0.8675102591514587, "sampled_ll": -0.4703758955001831, "all_perturbed_sampled_ll": [-1.5288176536560059], "all_perturbed_original_ll": [-1.607743740081787], "perturbed_sampled_ll": -1.5288176536560059, "perturbed_original_ll": -1.607743740081787, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> Ans = new ArrayList<Integer>();\n\t\tString line;\n\n\t\twhile((line = in.readLine()) != null){\n\t\t\tint nTube = Integer.parseInt(line);\n\n\t\t\tif(nTube==0) break;\n\n\t\t\tTube[] tubes = new Tube[nTube];\n\t\t\tfor(int n=0; n<nTube; n++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tint x = Integer.parseInt(dst[0]);\n\t\t\t\tint y = Integer.parseInt(dst[1]);\n\t\t\t\tint r = Integer.parseInt(dst[2]);\n\t\t\t\ttubes[n] = new Tube(x, y, r);\n\t\t\t}\n\n\t\t\tline = in.readLine();\n\t\t\tint nSet = Integer.parseInt(line);\n\t\t\tfor(int n=0; n<nSet; n++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tdouble x1 = Double.parseDouble(dst[0]);\n\t\t\t\tdouble y1 = Double.parseDouble(dst[1]);\n\t\t\t\tdouble x2 = Double.parseDouble(dst[2]);\n\t\t\t\tdouble y2 = Double.parseDouble(dst[3]);\n\n\t\t\t\tint hide = 0;\n\t\t\t\tfor(int m=0; m<tubes.length; m++){\n\t\t\t\t\tdouble a, b, c, d, e1, e2, x0, min, max;\n\t\t\t\t\tif(x1 != x2){\n\t\t\t\t\t\tdouble p = (y1 - y2) / (x1 - x2);\n\t\t\t\t\t\tdouble q = y1 - p * x1;\n\t\t\t\t\t\ta = p * p + 1.0;\n\t\t\t\t\t\tb = 2.0 * p * (q - tubes[m].y) - 2.0 * tubes[m].x;\n\t\t\t\t\t\tc = Math.pow(tubes[m].x, 2.0) + Math.pow(q - tubes[m].y, 2.0) - Math.pow(tubes[m].r, 2.0);\n\t\t\t\t\t\td = b * b - 4.0 * a * c;\n\t\t\t\t\t\te1 = a * x1 * x1 + b * x1 + c;\n\t\t\t\t\t\te2 = a * x2 * x2 + b * x2 + c;\n\t\t\t\t\t\tx0 = - b / (2.0 * a);\n\t\t\t\t\t\tmin = Math.min(x1, x2);\n\t\t\t\t\t\tmax = Math.max(x1, x2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta = 1.0;\n\t\t\t\t\t\tb = -2.0 * tubes[m].y;\n\t\t\t\t\t\tc = Math.pow(tubes[m].y, 2.0) + Math.pow(x1 - tubes[m].x, 2.0) - Math.pow(tubes[m].r, 2.0);\n\t\t\t\t\t\td = b * b - 4.0 * a * c;\n\t\t\t\t\t\te1 = a * y1 * y1 + b * y1 + c;\n\t\t\t\t\t\te2 = a * y2 * y2 + b * y2 + c;\n\t\t\t\t\t\tx0 = - b / (2.0 * a);\n\t\t\t\t\t\tmin = Math.min(y1, y2);\n\t\t\t\t\t\tmax = Math.max(y1, y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(x0 >= min && x0 <= max){\n\t\t\t\t\t\tif(d*e1 >= 0 || d*e2 >= 0){\n\t\t\t\t\t\t\tAns.add(1);\n\t\t\t\t\t\t\thide = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(e1 * e2 <= 0){\n\t\t\t\t\t\t\tAns.add(1);\n\t\t\t\t\t\t\thide = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(hide == 0){\n\t\t\t\t\tAns.add(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tint i = Ans.get(n);\n\t\t\tif(i==1){\n\t\t\t\tSystem.out.println(\"Safe\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"Danger\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Tube{\n\tdouble x;\n\tdouble y;\n\tdouble r;\n\n\tpublic Tube(int x, int y, int r){\n\t\tthis.x = (double)x;\n\t\tthis.y = (double)y;\n\t\tthis.r = (double)r;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Circle {\n        double x, y, r;\n        Circle(double x, double y, double r) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            Circle[] walls = new Circle[n];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                double wx = Double.parseDouble(parts[0]);\n                double wy = Double.parseDouble(parts[1]);\n                double r = Double.parseDouble(parts[2]);\n                walls[i] = new Circle(wx, wy, r);\n            }\n            \n            int m = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < m; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                double tx = Double.parseDouble(parts[0]);\n                double ty = Double.parseDouble(parts[1]);\n                double sx = Double.parseDouble(parts[2]);\n                double sy = Double.parseDouble(parts[3]);\n                \n                boolean visible = isVisible(tx, ty, sx, sy, walls);\n                System.out.println(visible ? \"Danger\" : \"Safe\");\n            }\n        }\n    }\n    \n    static boolean isVisible(double tx, double ty, double sx, double sy, Circle[] walls) {\n        // Check if both points are inside the same wall\n        for (Circle wall : walls) {\n            boolean tInside = isInside(tx, ty, wall);\n            boolean sInside = isInside(sx, sy, wall);\n            \n            if (tInside && sInside) {\n                // Both inside same wall - check if line segment intersects any other wall\n                boolean blocked = false;\n                for (Circle other : walls) {\n                    if (other == wall) continue;\n                    if (lineIntersectsCircle(tx, ty, sx, sy, other)) {\n                        blocked = true;\n                        break;\n                    }\n                }\n                if (!blocked) return true;\n            } else if (tInside || sInside) {\n                // One inside, one outside - not visible\n                return false;\n            }\n        }\n        \n        // Both outside all walls - check if line segment intersects any wall\n        for (Circle wall : walls) {\n            if (lineIntersectsCircle(tx, ty, sx, sy, wall)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    static boolean isInside(double px, double py, Circle circle) {\n        double dx = px - circle.x;\n        double dy = py - circle.y;\n        return dx * dx + dy * dy < circle.r * circle.r;\n    }\n    \n    static boolean lineIntersectsCircle(double x1, double y1, double x2, double y2, Circle circle) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double fx = x1 - circle.x;\n        double fy = y1 - circle.y;\n        \n        double a = dx * dx + dy * dy;\n        double b = 2 * (fx * dx + fy * dy);\n        double c = fx * fx + fy * fy - circle.r * circle.r;\n        \n        double discriminant = b * b - 4 * a * c;\n        \n        if (discriminant < 0) {\n            return false;\n        }\n        \n        double sqrtDisc = Math.sqrt(discriminant);\n        double t1 = (-b - sqrtDisc) / (2 * a);\n        double t2 = (-b + sqrtDisc) / (2 * a);\n        \n        // Check if intersection points are within the line segment\n        if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {\n            return true;\n        }\n        \n        // Check if the segment is completely inside the circle\n        if (t1 < 0 && t2 > 1) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class Circle { double x, y, r; Circle(double  void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new  int n = Integer.parseInt(line.trim()); if (n == 0) break; Circle[] walls = new Circle[n]; for  parts  double r = Double.parseDouble(parts[2]); walls[i] = new Circle(wx, wy, r); } int m = Integer.parseInt(br.readLine().trim()); for (int i = 0; i < m; i++) { String[]  Double.parseDouble(parts[1]); double sx = Double.parseDouble(parts[2]); double sy = Double.parseDouble(parts[3]); boolean visible = isVisible(tx, ty, sx, sy, walls); System.out.println(visible ? \"Danger\" : \"Safe\"); } } } static boolean isVisible(double tx, double  if both points  { boolean tInside = isInside(tx,   if line segment intersects any other wall boolean blocked = false; for (Circle other : walls) {  (!blocked) return true; } else if (tInside || sInside) { // One inside, one outside  all walls - check if line  } } return true; } static boolean isInside(double px, double py,  dy = py - circle.y; return  circle.r; } static boolean lineIntersectsCircle(double x1,  dx = x2 - x1; double dy  double fy = y1 - circle.y; double a = dx * dx + dy * dy; double b = 2 * (fx * dx + fy * dy); double c = fx * fx + fy * fy - circle.r * circle.r; double discriminant = b * b - 4 * a *  points are within the line segment if ((t1 >= 0 && t1 <= 1)  inside the circle if (t1 < 0 && t2 > 1) { return true; } return false; } }"], "perturbed_original": ["import java.io.*;  try{ new Main();  in = new BufferedReader(new InputStreamReader(System.in)); List<Integer> Ans = new ArrayList<Integer>(); String line; while((line = in.readLine()) !=  new Tube[nTube]; for(int n=0; n<nTube; n++){ line = in.readLine(); String[] dst = line.split(\" \"); int x = Integer.parseInt(dst[0]); int y = Integer.parseInt(dst[1]); int r = Integer.parseInt(dst[2]); tubes[n] = new  y1 =  hide = 0; for(int m=0; m<tubes.length; m++){ double a, b, c, d, e1, e2, x0, min, max; if(x1 != x2){ double p = (y1 - y2) / (x1 - x2); double q = y1 - p * x1; a = p * p  tubes[m].y) - 2.0 * tubes[m].x;  Math.pow(tubes[m].r, 2.0); d = b * b - 4.0 * a * c; e1 = a * x1 * x1 + b * x1 + c; e2 = a * x2 * x2 + b * x2 + c; x0 = - b  Math.max(x1, x2); } else{ a = 1.0; b = -2.0 * tubes[m].y; c = Math.pow(tubes[m].y,  = b * b -   a * y2 * y2 + b * y2 +   = 1; break; } } } if(hide  int i = Ans.get(n); if(i==1){ System.out.println(\"Safe\"); }else{ System.out.println(\"Danger\"); } } }  Tube(int x, int y, int r){ this.x = (double)x; this.y = (double)y; this.r = (double)r; } }"], "original_ll": -0.5060805082321167, "sampled_ll": -0.38281363248825073, "all_perturbed_sampled_ll": [-1.669617772102356], "all_perturbed_original_ll": [-1.6148607730865479], "perturbed_sampled_ll": -1.669617772102356, "perturbed_original_ll": -1.6148607730865479, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math as M\ndef R(A): return (A[0]**2+A[1]**2)**.5\ndef I(i): return [map(int,raw_input().split()) for _ in [0]*i]\ndef C(a,b): return a>b or abs(a-b)<1e-6\ndef f(e1):\n  tx,ty,sx,sy=e1\n  x=[]\n  for e2 in WP:\n    wx,wy,r=e2\n    wt=[tx-wx,ty-wy]; rwt=R(wt)\n    sw=[wx-sx,wy-sy]; rsw=R(sw)\n    st=[tx-sx,ty-sy]; rst=R(st)\n    F=[rwt<r,rsw<r]\n    if rst==0: c=1\n    elif F==[1,1]: c=1\n    elif F==[1,0] or F==[0,1]: c=0\n    elif F==[0,0]:\n      c=0\n      a=M.pi/2-M.acos(r/rsw)\n      b=M.acos((sw[0]*st[0]+sw[1]*st[1])/rsw/rst)\n#      if C(a,b) and C(rst**2,rsw**2-r**2): c=0\n#      else: c=1\n    x.append(c)\n  return all(x)\n\nwhile 1:\n  n=input()\n  if n==0: break\n  WP=I(n)\n  P=I(input())\n  for e in P: print [\"Safe\",\"Danger\"][f(e)]", "sampled": "import math\n\ndef point_in_circle(px, py, cx, cy, r):\n    dist_sq = (px - cx) ** 2 + (py - cy) ** 2\n    return dist_sq < r ** 2\n\ndef line_segment_intersects_circle(x1, y1, x2, y2, cx, cy, r):\n    # Check if either endpoint is inside the circle\n    if point_in_circle(x1, y1, cx, cy, r) or point_in_circle(x2, y2, cx, cy, r):\n        return True\n    \n    # Vector from point 1 to point 2\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    # Vector from point 1 to circle center\n    fx = x1 - cx\n    fy = y1 - cy\n    \n    # Quadratic equation coefficients for line-circle intersection\n    a = dx * dx + dy * dy\n    b = 2 * (fx * dx + fy * dy)\n    c = fx * fx + fy * fy - r * r\n    \n    discriminant = b * b - 4 * a * c\n    \n    if discriminant < 0:\n        return False\n    \n    # Check if intersection points are within the line segment\n    sqrt_discriminant = math.sqrt(discriminant)\n    t1 = (-b - sqrt_discriminant) / (2 * a)\n    t2 = (-b + sqrt_discriminant) / (2 * a)\n    \n    # Check if any t is in [0, 1]\n    if (0 <= t1 <= 1) or (0 <= t2 <= 1):\n        return True\n    \n    return False\n\ndef is_visible(tx, ty, sx, sy, walls):\n    # Check if both Taro and Oni are inside the same wall\n    taro_walls = []\n    oni_walls = []\n    \n    for wx, wy, r in walls:\n        if point_in_circle(tx, ty, wx, wy, r):\n            taro_walls.append((wx, wy, r))\n        if point_in_circle(sx, sy, wx, wy, r):\n            oni_walls.append((wx, wy, r))\n    \n    # If they are both inside the same wall\n    for tw in taro_walls:\n        if tw in oni_walls:\n            # They are in the same wall, check if any other wall blocks\n            for wx, wy, r in walls:\n                if (wx, wy, r) != tw:\n                    if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r):\n                        return False\n            return True\n    \n    # If one is inside a wall and the other is not, they can't see each other\n    if len(taro_walls) > 0 or len(oni_walls) > 0:\n        return False\n    \n    # Both are outside all walls, check if any wall blocks the line of sight\n    for wx, wy, r in walls:\n        if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r):\n            return False\n    \n    return True\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    walls = []\n    for _ in range(n):\n        wx, wy, r = map(int, input().split())\n        walls.append((wx, wy, r))\n    \n    m = int(input())\n    for _ in range(m):\n        tx, ty, sx, sy = map(int, input().split())\n        if is_visible(tx, ty, sx, sy, walls):\n            print(\"Danger\")\n        else:\n            print(\"Safe\")\n", "perturbed_sampled": ["import math   y2, cx, cy, r): # Check if  cy, r) or point_in_circle(x2, y2, cx, cy, r): return True # Vector from point 1 to point 2 dx = x2 - x1 dy = y2 - y1 # Vector from point 1 to circle center fx = x1 - cx fy = y1 - cy # Quadratic equation coefficients for line-circle intersection a = dx * dx + dy * dy b = 2 * (fx * dx +  * fy - r * r discriminant = b * b - 4 * a * c if discriminant <  the line segment sqrt_discriminant = math.sqrt(discriminant) t1 = (-b - sqrt_discriminant) / (2 *  and Oni are  wx, wy,  the same wall for tw  the same wall, check if any other  wy, r) != tw: if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r): return False return True # If one is inside a wall and the other is  outside all walls, check if any wall blocks the line of sight for wx, wy, r in walls: if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r): return False return True while True: n = int(input())  in range(n): wx, wy, r = map(int, input().split()) walls.append((wx, wy, r)) m = int(input()) for _ in range(m): tx, ty, sx, sy = map(int, input().split()) if is_visible(tx, ty, sx, sy, walls): print(\"Danger\") else: print(\"Safe\")"], "perturbed_original": ["import math as M def R(A): return (A[0]**2+A[1]**2)**.5 def I(i): return [map(int,raw_input().split())  def f(e1): tx,ty,sx,sy=e1 x=[] for e2 in WP: wx,wy,r=e2  elif   c=1 x.append(c) return all(x) while 1: n=input() if n==0: break WP=I(n) P=I(input()) for e in P: print [\"Safe\",\"Danger\"][f(e)]"], "original_ll": -1.4878954887390137, "sampled_ll": -0.5434557199478149, "all_perturbed_sampled_ll": [-1.9684463739395142], "all_perturbed_original_ll": [-2.8275136947631836], "perturbed_sampled_ll": -1.9684463739395142, "perturbed_original_ll": -2.8275136947631836, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\nint n,i,j,p;\nchar c,t,l[27];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tgetchar();\n\tfor(i=0;i<n;i++)\n\t{\n\t\tp=13;\n\t\tmemset(l,0,27);\n\t\tfor(;scanf(\"%c\",&l[p])!=-1;)\n\t\t{\n\t\t\t~scanf(\"%c\",&c);\n\t\t\tif(c=='-'||c=='<')\n\t\t\t\tgetchar(),c=='-'?p++:p--;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(j=0;!l[j];j++);\n\t\tputs(l+j);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    getchar();\n    \n    for (int i = 0; i < n; i++) {\n        char line[1025];\n        fgets(line, 1025, stdin);\n        \n        // Parse the movements\n        char cars[26];\n        int carCount = 0;\n        int carPos[26]; // Position of each car (a-z)\n        for (int j = 0; j < 26; j++) {\n            carPos[j] = -1;\n        }\n        \n        // Parse first car\n        char currentCar = line[0];\n        cars[carCount] = currentCar;\n        carPos[currentCar - 'a'] = carCount;\n        carCount++;\n        \n        int pos = 0;\n        int minPos = 0, maxPos = 0;\n        \n        // Parse movements\n        int idx = 1;\n        while (line[idx] != '\\0' && line[idx] != '\\n') {\n            // Read direction\n            char dir[3];\n            dir[0] = line[idx];\n            dir[1] = line[idx + 1];\n            dir[2] = '\\0';\n            idx += 2;\n            \n            // Read next car\n            char nextCar = line[idx];\n            idx++;\n            \n            int nextCarIdx = nextCar - 'a';\n            \n            if (strcmp(dir, \"->\") == 0) {\n                // Moving to next car (right)\n                if (carPos[nextCarIdx] == -1) {\n                    // New car on the right\n                    pos++;\n                    carPos[nextCarIdx] = pos;\n                    if (pos > maxPos) maxPos = pos;\n                } else {\n                    pos = carPos[nextCarIdx];\n                }\n            } else { // \"<-\"\n                // Moving to previous car (left)\n                if (carPos[nextCarIdx] == -1) {\n                    // New car on the left\n                    pos--;\n                    carPos[nextCarIdx] = pos;\n                    if (pos < minPos) minPos = pos;\n                } else {\n                    pos = carPos[nextCarIdx];\n                }\n            }\n        }\n        \n        // Build result string\n        int length = maxPos - minPos + 1;\n        char result[27];\n        for (int j = 0; j < length; j++) {\n            result[j] = ' ';\n        }\n        result[length] = '\\0';\n        \n        for (int j = 0; j < 26; j++) {\n            if (carPos[j] != -1) {\n                int actualPos = carPos[j] - minPos;\n                result[actualPos] = 'a' + j;\n            }\n        }\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int main() { int n;  n; i++) { char line[1025]; fgets(line, 1025, stdin); // Parse the movements char cars[26]; int carCount = 0; int carPos[26]; // Position of each  j++)  currentCar  carCount++; int pos = 0; int minPos = 0, maxPos = 0; // Parse movements int idx =  (right) if (carPos[nextCarIdx] == -1) { //  (pos > maxPos) maxPos = pos; } else { pos = carPos[nextCarIdx]; } } else { // \"<-\" // Moving to previous car (left) if (carPos[nextCarIdx] == -1) { // New car on the left pos--; carPos[nextCarIdx] = pos; if (pos < minPos) minPos = pos; }  result string int length = maxPos  0; j < length; j++) { result[j] = ' '; } result[length] = '\\0'; for (int j  -1) { int actualPos = carPos[j] - minPos; result[actualPos] = 'a' + j; } } printf(\"%s\\n\", result); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> int n,i,j,p; char c,t,l[27]; int main()  if(c=='-'||c=='<') getchar(),c=='-'?p++:p--; else break; } for(j=0;!l[j];j++); puts(l+j); } return 0; }"], "original_ll": -1.5378084182739258, "sampled_ll": -0.5911639928817749, "all_perturbed_sampled_ll": [-1.9153859615325928], "all_perturbed_original_ll": [-2.5092408657073975], "perturbed_sampled_ll": -1.9153859615325928, "perturbed_original_ll": -2.5092408657073975, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "package jp.ac.saburou.volume1;\n\nimport java.util.Scanner;\n\nclass p130 {\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint[][] result = null;\n\t\tfor (int t = 0; t < n; t++) {\n\t\t\tchar[] train = s.next().toCharArray();\n\t\t\tif (train.length > 1) {\n\t\t\t\tresult = createTrainGraph(train);\n\t\t\t\t/* \u5148\u982d\u8eca\u4e21\u3092\u6c7a\u5b9a\u3059\u308b */\n\t\t\t\tint next = NO_CONNECTION;\n\t\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\t\tif (result[i][0] == NO_CONNECTION\n\t\t\t\t\t\t\t&& result[i][1] != NO_CONNECTION) {\n\t\t\t\t\t\tnext = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* \u51fa\u529b */\n\t\t\t\twhile (next != -1) {\n\t\t\t\t\tSystem.out.printf(\"%c\", next + 'a');\n\t\t\t\t\tnext = result[next][REAR];\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t} else {\n\t\t\t\tSystem.out.println(train[0]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic final int FRONT = 0;\n\tstatic final int REAR = 1;\n\tstatic final int NO_CONNECTION = -1;\n\n\tstatic int[][] createTrainGraph(char[] input) {\n\t\tint[][] train = new int[26][2];\n\t\tfor (int i = 0; i < train.length; i++) {\n\t\t\tfor (int j = 0; j < train[0].length; j++) {\n\t\t\t\ttrain[i][j] = NO_CONNECTION;\n\t\t\t}\n\t\t}\n\t\tboolean front = false;\n\t\tint before = input[0];\n\t\tfor (int i = 1; i < input.length; i++) {\n\t\t\tint current = input[i];\n\t\t\tif ('a' <= current && current <= 'z') {\n\t\t\t\tif (front) {\n\t\t\t\t\ttrain[before - 'a'][FRONT] = current - 'a';\n\t\t\t\t\ttrain[current - 'a'][REAR] = before - 'a';\n\t\t\t\t} else {\n\t\t\t\t\ttrain[before - 'a'][REAR] = current - 'a';\n\t\t\t\t\ttrain[current - 'a'][FRONT] = before - 'a';\n\t\t\t\t}\n\t\t\t\tbefore = current;\n\t\t\t} else if (current == '>') {\n\t\t\t\tfront = false;\n\t\t\t} else if (current == '<') {\n\t\t\t\tfront = true;\n\t\t\t}\n\t\t}\n\t\treturn train;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            System.out.println(solve(line));\n        }\n        sc.close();\n    }\n    \n    static String solve(String record) {\n        String[] tokens = record.split(\"(<-|->)\");\n        String[] directions = record.split(\"[a-z]\");\n        \n        Map<Character, Set<Character>> next = new HashMap<>();\n        Map<Character, Set<Character>> prev = new HashMap<>();\n        Set<Character> cars = new HashSet<>();\n        \n        for (String token : tokens) {\n            if (!token.isEmpty()) {\n                char c = token.charAt(0);\n                cars.add(c);\n                next.putIfAbsent(c, new HashSet<>());\n                prev.putIfAbsent(c, new HashSet<>());\n            }\n        }\n        \n        for (int i = 0; i < tokens.length - 1; i++) {\n            char from = tokens[i].charAt(0);\n            char to = tokens[i + 1].charAt(0);\n            String dir = directions[i + 1];\n            \n            if (dir.equals(\"->\")) {\n                next.get(from).add(to);\n                prev.get(to).add(from);\n            } else {\n                prev.get(from).add(to);\n                next.get(to).add(from);\n            }\n        }\n        \n        // Build the train\n        List<Character> train = new ArrayList<>();\n        \n        // Find a starting car (one with no prev or just one end)\n        char start = ' ';\n        for (char c : cars) {\n            Set<Character> p = prev.get(c);\n            Set<Character> n = next.get(c);\n            \n            // Remove inconsistencies\n            p.removeAll(n);\n            n.removeAll(p);\n            \n            if (p.isEmpty()) {\n                start = c;\n                break;\n            }\n        }\n        \n        if (start == ' ') {\n            start = cars.iterator().next();\n        }\n        \n        // Build forward\n        Set<Character> visited = new HashSet<>();\n        char current = start;\n        train.add(current);\n        visited.add(current);\n        \n        while (true) {\n            Set<Character> nextCars = next.get(current);\n            nextCars.removeAll(prev.get(current));\n            \n            char nextCar = ' ';\n            for (char c : nextCars) {\n                if (!visited.contains(c)) {\n                    nextCar = c;\n                    break;\n                }\n            }\n            \n            if (nextCar == ' ') break;\n            \n            train.add(nextCar);\n            visited.add(nextCar);\n            current = nextCar;\n        }\n        \n        // Build backward from start\n        current = start;\n        while (true) {\n            Set<Character> prevCars = prev.get(current);\n            prevCars.removeAll(next.get(current));\n            \n            char prevCar = ' ';\n            for (char c : prevCars) {\n                if (!visited.contains(c)) {\n                    prevCar = c;\n                    break;\n                }\n            }\n            \n            if (prevCar == ' ') break;\n            \n            train.add(0, prevCar);\n            visited.add(prevCar);\n            current = prevCar;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : train) {\n            result.append(c);\n        }\n        \n        return result.toString();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); for (int i = 0;  tokens  cars = new HashSet<>(); for (String token :  next.putIfAbsent(c, new HashSet<>()); prev.putIfAbsent(c, new HashSet<>()); } } for (int i = 0; i < tokens.length - 1; i++) { char from = tokens[i].charAt(0);  + 1];  } } // Build  starting car (one with no prev or just one end) char start = ' '; for  n  '  visited = new HashSet<>(); char current = start; train.add(current); visited.add(current); while (true) { Set<Character> nextCars = next.get(current); nextCars.removeAll(prev.get(current)); char nextCar = ' '; for (char c : nextCars) { if (!visited.contains(c)) { nextCar = c; break; } } if (nextCar == ' ') break; train.add(nextCar); visited.add(nextCar); current = nextCar; } // Build backward from start current = start; while (true) { Set<Character> prevCars = prev.get(current); prevCars.removeAll(next.get(current)); char prevCar = ' '; for (char c :   current = prevCar; } StringBuilder result  } return result.toString(); } }"], "perturbed_original": ["package jp.ac.saburou.volume1; import java.util.Scanner; class p130 { public static void  = 0; t <  1) { result = createTrainGraph(train); /* \u5148\u982d\u8eca\u4e21\u3092\u6c7a\u5b9a\u3059\u308b */ int  != NO_CONNECTION) { next =  System.out.println(); } else { System.out.println(train[0]); } } } static final int FRONT = 0; static final int REAR = 1; static final int NO_CONNECTION = -1; static int[][] createTrainGraph(char[] input) { int[][] train = new int[26][2]; for  int before = input[0]; for (int i = 1;  ('a' <= current && current <= 'z') { if (front) { train[before - 'a'][FRONT] = current - 'a'; train[current - 'a'][REAR] = before - 'a'; } else { train[before - 'a'][REAR] = current - 'a'; train[current - 'a'][FRONT] = before - 'a'; } before = current; } else if (current == '>') { front =  true; } } return train; } }"], "original_ll": -0.7178160548210144, "sampled_ll": -0.5110052227973938, "all_perturbed_sampled_ll": [-1.6366416215896606], "all_perturbed_original_ll": [-1.8137048482894897], "perturbed_sampled_ll": -1.6366416215896606, "perturbed_original_ll": -1.8137048482894897, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# AOJ 0130 Train\n# Python3 2018.6.19 bal4u\n\nfor _ in range(int(input())):\n\ts = list(input())\n\tans = []\n\tdir = '>'\n\tfor i in range(len(s)):\n\t\tif s[i].isalpha():\n\t\t\tif dir == '>':\n\t\t\t\tif s[i] not in ans: ans.append(s[i])\n\t\t\telse:\n\t\t\t\tif s[i] not in ans: ans.insert(0, s[i])\n\t\telif s[i] == '>' or s[i] == '<': dir = s[i]\n\tprint(*ans, sep='')\n", "sampled": "def solve(s):\n    # Parse the movements\n    tokens = s.replace('<-', ' <- ').replace('->', ' -> ').split()\n    \n    # Build adjacency relationships\n    cars = set()\n    neighbors = {}\n    \n    current = tokens[0]\n    cars.add(current)\n    \n    i = 1\n    while i < len(tokens):\n        direction = tokens[i]\n        next_car = tokens[i + 1]\n        cars.add(next_car)\n        \n        if current not in neighbors:\n            neighbors[current] = set()\n        if next_car not in neighbors:\n            neighbors[next_car] = set()\n        \n        neighbors[current].add(next_car)\n        neighbors[next_car].add(current)\n        \n        current = next_car\n        i += 2\n    \n    # Find the train composition (it forms a path)\n    # Find cars with degree 1 (endpoints)\n    endpoints = []\n    for car in cars:\n        if car not in neighbors or len(neighbors[car]) == 1:\n            endpoints.append(car)\n    \n    # If no endpoints found (circular), pick any car\n    if not endpoints:\n        endpoints = [list(cars)[0]]\n    \n    # Build the path from one endpoint\n    start = endpoints[0]\n    path = [start]\n    visited = {start}\n    current = start\n    \n    while True:\n        if current not in neighbors:\n            break\n        next_found = False\n        for next_car in neighbors[current]:\n            if next_car not in visited:\n                path.append(next_car)\n                visited.add(next_car)\n                current = next_car\n                next_found = True\n                break\n        if not next_found:\n            break\n    \n    return ''.join(path)\n\nn = int(input())\nfor _ in range(n):\n    s = input().strip()\n    print(solve(s))\n", "perturbed_sampled": ["def solve(s): # Parse the movements tokens = s.replace('<-', ' <-  set() neighbors = {} current = tokens[0] cars.add(current) i =  2 # Find the train composition (it forms a path) # Find  in cars: if car not in neighbors or  pick any car if not endpoints: endpoints = [list(cars)[0]] # Build the path from one endpoint start = endpoints[0] path =  current not in neighbors: break next_found = False for next_car in neighbors[current]: if next_car not in visited:  not next_found: break return ''.join(path) n = int(input()) for _ in range(n): s = input().strip() print(solve(s))"], "perturbed_original": [" in range(int(input())): s = list(input()) ans = [] dir = '>' for i in range(len(s)): if s[i].isalpha():  else: if s[i] not in ans: ans.insert(0, s[i]) elif s[i] == '>' or s[i] == '<': dir = s[i] print(*ans, sep='')"], "original_ll": -1.544116735458374, "sampled_ll": -0.8853259682655334, "all_perturbed_sampled_ll": [-3.1716208457946777], "all_perturbed_original_ll": [-1.7156943082809448], "perturbed_sampled_ll": -3.1716208457946777, "perturbed_original_ll": -1.7156943082809448, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint i,j,n,s[12][12],a[12][12];\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tfor(i=0;i<10;i++)for(j=0;j<10;j++)scanf(\"%d\",&s[i][j]);\n\t\tmemset(a,0,sizeof(a));\n\t\tfor(i=0;i<9;i++){\n\t\t\tfor(j=0;j<10;j++){\n\t\t\t\tif(s[i][j]%2==1){\n\t\t\t\t\ta[i+1][j]=1;\n\t\t\t\t\ts[i][j]++;\n\t\t\t\t\ts[i+1][j]++;\n\t\t\t\t\ts[i+1][j-1]++;\n\t\t\t\t\ts[i+1][j+1]++;\n\t\t\t\t\ts[i+2][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<10;i++){for(j=0;j<10;j++)printf(\"%d \",a[i][j]);printf(\"\\n\");}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int grid[10][10];\n        int solution[10][10] = {0};\n        \n        // Read input\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        \n        // Solve using Gaussian elimination in GF(2)\n        // Each cell (i,j) being hit affects itself and neighbors\n        // We need to solve: A*x = b where A is the effect matrix\n        \n        // Create augmented matrix\n        int matrix[100][101];\n        for (int i = 0; i < 100; i++) {\n            for (int j = 0; j <= 100; j++) {\n                matrix[i][j] = 0;\n            }\n        }\n        \n        // Build the system of equations\n        for (int row = 0; row < 10; row++) {\n            for (int col = 0; col < 10; col++) {\n                int eq = row * 10 + col;\n                matrix[eq][100] = grid[row][col];\n                \n                // Check which positions affect this cell\n                for (int r = 0; r < 10; r++) {\n                    for (int c = 0; c < 10; c++) {\n                        int var = r * 10 + c;\n                        // Position (r,c) affects (row,col) if:\n                        // - (r,c) == (row,col) or\n                        // - (r,c) is adjacent to (row,col)\n                        if ((r == row && c == col) ||\n                            (r == row && (c == col-1 || c == col+1)) ||\n                            (c == col && (r == row-1 || r == row+1))) {\n                            matrix[eq][var] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Gaussian elimination in GF(2)\n        for (int col = 0; col < 100; col++) {\n            // Find pivot\n            int pivot = -1;\n            for (int row = col; row < 100; row++) {\n                if (matrix[row][col] == 1) {\n                    pivot = row;\n                    break;\n                }\n            }\n            \n            if (pivot == -1) continue;\n            \n            // Swap rows\n            if (pivot != col) {\n                for (int j = 0; j <= 100; j++) {\n                    int temp = matrix[col][j];\n                    matrix[col][j] = matrix[pivot][j];\n                    matrix[pivot][j] = temp;\n                }\n            }\n            \n            // Eliminate\n            for (int row = 0; row < 100; row++) {\n                if (row != col && matrix[row][col] == 1) {\n                    for (int j = 0; j <= 100; j++) {\n                        matrix[row][j] ^= matrix[col][j];\n                    }\n                }\n            }\n        }\n        \n        // Back substitution to get solution\n        int result[100] = {0};\n        for (int i = 0; i < 100; i++) {\n            result[i] = matrix[i][100];\n        }\n        \n        // Convert to 2D and output\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                if (j > 0) printf(\" \");\n                printf(\"%d\", result[i * 10 + j]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n); while (n--) { int grid[10][10]; int solution[10][10] = {0}; // Read input for (int i = 0;  j < 10; j++) { scanf(\"%d\", &grid[i][j]); } } // Solve using Gaussian elimination in GF(2) // Each cell (i,j)   = 0; i < 100; i++)  < 10; row++) { for (int col = 0; col  + col; matrix[eq][100] = grid[row][col]; // Check which positions affect this cell for (int r = 0; r < 10; r++) { for (int c = 0;  10 + c; // Position (r,c) affects (row,col) if: //  to (row,col) if ((r == row && c == col) || (r ==  == row+1))) { matrix[eq][var] = 1; } } } } } // Gaussian elimination in GF(2) for (int col = 0; col < 100; col++) { // Find pivot int pivot = -1; for (int row =  == -1) continue; // Swap rows if (pivot != col) { for (int j  matrix[col][j];  for (int row  col && matrix[row][col] == 1) { for (int j = 0; j <= 100;  Back substitution to get solution int  100; i++) { result[i] = matrix[i][100]; } // Convert to 2D and output for (int i = 0;  printf(\" \"); printf(\"%d\", result[i * 10 + j]); } printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h>  for(j=0;j<10;j++){ if(s[i][j]%2==1){ a[i+1][j]=1; s[i][j]++; s[i+1][j]++; s[i+1][j-1]++; s[i+1][j+1]++; s[i+2][j]++; } } } for(i=0;i<10;i++){for(j=0;j<10;j++)printf(\"%d \",a[i][j]);printf(\"\\n\");} } return 0; }"], "original_ll": -0.6766581535339355, "sampled_ll": -0.4786827564239502, "all_perturbed_sampled_ll": [-1.7776238918304443], "all_perturbed_original_ll": [-1.2481439113616943], "perturbed_sampled_ll": -1.7776238918304443, "perturbed_original_ll": -1.2481439113616943, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic byte ans[][];\n\n\tpublic static boolean f(int a[][], int s[], int n) {\n\t\tif (10 <= n) {\n\t\t\tint b[][] = new int[10][10];\n\t\t\tans = new byte[10][10];\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tb[i][j] = a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif (s[i] == 1) {\n\t\t\t\t\treverse(b, 0, i);\n\t\t\t\t\tans[0][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (b[i - 1][j] == 1) {\n\t\t\t\t\t\treverse(b, i, j);\n\t\t\t\t\t\tans[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (check(b)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\ts[n] = 0;\n\t\t\tif (f(a, s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ts[n] = 1;\n\t\t\tif (f(a, s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void reverse(int a[][], int i, int j) {\n\t\ta[i][j] = (a[i][j] + 1) % 2;\n\t\tif (0 <= i - 1) {\n\t\t\ta[i - 1][j] = (a[i - 1][j] + 1) % 2;\n\t\t}\n\t\tif (i + 1 < 10) {\n\t\t\ta[i + 1][j] = (a[i + 1][j] + 1) % 2;\n\t\t}\n\t\tif (0 <= j - 1) {\n\t\t\ta[i][j - 1] = (a[i][j - 1] + 1) % 2;\n\t\t}\n\t\tif (j + 1 < 10) {\n\t\t\ta[i][j + 1] = (a[i][j + 1] + 1) % 2;\n\t\t}\n\t}\n\n\tpublic static boolean check(int a[][]) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (a[i][j] == 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tint a[][];\n\n\t\tn = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta = new int[10][10];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\ta[j][k] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tf(a, new int[10], 0);\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tString s = \"\";\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\tSystem.out.print(s + ans[j][k]);\n\t\t\t\t\ts = \" \";\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int t = 0; t < n; t++) {\n            int[][] grid = new int[10][10];\n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    grid[i][j] = sc.nextInt();\n                }\n            }\n            \n            int[][] result = solve(grid);\n            \n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    if (j > 0) System.out.print(\" \");\n                    System.out.print(result[i][j]);\n                }\n                System.out.println();\n            }\n        }\n        sc.close();\n    }\n    \n    static int[][] solve(int[][] grid) {\n        // Use Gaussian elimination over GF(2)\n        // Each cell (i,j) can be toggled, affecting itself and neighbors\n        // We need to solve for which cells to toggle to turn all lights off\n        \n        int[][] solution = new int[10][10];\n        \n        // Create augmented matrix for the system\n        // 100 variables (one for each cell), 100 equations (one for each cell)\n        int size = 100;\n        int[][] matrix = new int[size][size + 1];\n        \n        // Build the system of equations\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                int row = i * 10 + j;\n                \n                // Check which toggles affect cell (i,j)\n                for (int ti = 0; ti < 10; ti++) {\n                    for (int tj = 0; tj < 10; tj++) {\n                        int col = ti * 10 + tj;\n                        \n                        // Cell (ti,tj) affects (i,j) if they are adjacent\n                        if ((ti == i && tj == j) ||\n                            (ti == i && Math.abs(tj - j) == 1) ||\n                            (tj == j && Math.abs(ti - i) == 1)) {\n                            matrix[row][col] = 1;\n                        }\n                    }\n                }\n                \n                // Right side: current state of cell (i,j)\n                matrix[row][size] = grid[i][j];\n            }\n        }\n        \n        // Gaussian elimination in GF(2)\n        for (int col = 0; col < size; col++) {\n            // Find pivot\n            int pivot = -1;\n            for (int row = col; row < size; row++) {\n                if (matrix[row][col] == 1) {\n                    pivot = row;\n                    break;\n                }\n            }\n            \n            if (pivot == -1) continue;\n            \n            // Swap rows\n            if (pivot != col) {\n                int[] temp = matrix[col];\n                matrix[col] = matrix[pivot];\n                matrix[pivot] = temp;\n            }\n            \n            // Eliminate\n            for (int row = 0; row < size; row++) {\n                if (row != col && matrix[row][col] == 1) {\n                    for (int c = 0; c <= size; c++) {\n                        matrix[row][c] ^= matrix[col][c];\n                    }\n                }\n            }\n        }\n        \n        // Back substitution\n        int[] vars = new int[size];\n        for (int i = 0; i < size; i++) {\n            vars[i] = matrix[i][size];\n        }\n        \n        // Convert to 2D array\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                solution[i][j] = vars[i * 10 + j];\n            }\n        }\n        \n        return solution;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  new Scanner(System.in); int n = sc.nextInt(); for (int  } int[][] result =  j++) {  } sc.close(); } static int[][] solve(int[][] grid) { // Use Gaussian elimination  int[][] solution = new int[10][10]; //  for each cell), 100 equations (one for each cell) int size = 100; int[][] matrix = new int[size][size + 1]; // Build the system of equations for (int i = 0; i < 10; i++) { for (int j = 0; j <  j; // Check which  < 10; ti++) { for (int tj =  * 10 + tj; // Cell (ti,tj) affects (i,j) if they are adjacent if ((ti == i && tj == j) || (ti == i && Math.abs(tj - j) == 1) || (tj == j && Math.abs(ti - i) == 1)) { matrix[row][col] = 1; } }  = grid[i][j]; } } // Gaussian elimination in GF(2) for (int col =  pivot = -1; for  } if (pivot == -1) continue; // Swap rows if (pivot != col) { int[]  size; row++) { if (row != col && matrix[row][col] == 1) { for (int c = 0; c <= size; c++) { matrix[row][c] ^= matrix[col][c]; } } } } // Back substitution int[] vars = new int[size]; for (int i = 0; i < size; i++) { vars[i] = matrix[i][size]; } // Convert to 2D array  for (int j = 0; j < 10; j++)  return solution; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { static byte ans[][]; public static boolean f(int a[][], int s[], int n) { if  = new byte[10][10]; for  (int j = 0; j < 10; j++) { b[i][j] = a[i][j]; } } for (int i = 0; i < 10; i++) { if (s[i] == 1) { reverse(b, 0, i); ans[0][i] = 1; } } for (int i = 1; i < 10; i++) { for (int j = 0; j < 10; j++) { if (b[i - 1][j]  } } if (check(b)) { return true; } } else { s[n] = 0; if  = 1; if (f(a, s,  } public static void reverse(int a[][], int i, int  (0 <= i - 1) { a[i - 1][j]  (i  (a[i][j - 1] + 1) %  2; } } public static boolean check(int a[][]) { for (int  j = 0; j < 10; j++) { if (a[i][j] == 1) { return false;  int a[][]; n = sc.nextInt(); for (int i =  { for (int k = 0; k  new int[10], 0); for (int j = 0; j < 10; j++) { String s = \"\"; for (int k = 0; k < 10;  System.out.println(); } } } }"], "original_ll": -0.3113326132297516, "sampled_ll": -0.46916189789772034, "all_perturbed_sampled_ll": [-1.6654016971588135], "all_perturbed_original_ll": [-1.341232180595398], "perturbed_sampled_ll": -1.6654016971588135, "perturbed_original_ll": -1.341232180595398, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def attack(table, i, j):\n    table[i][j] = 1 - table[i][j]\n    table[i-1][j] = 1 - table[i-1][j]\n    table[i+1][j] = 1 - table[i+1][j]\n    table[i][j-1] = 1 - table[i][j-1]\n    table[i][j+1] = 1 - table[i][j+1]\n\ndef printans(ans):\n    for i in range(1, 11):\n        for j in range(1, 11):\n            print(ans[i][j], end=\"\")\n            if j < 10:\n                print(\" \", end=\"\")\n        print(\"\")\n\ndef solve(table, i, j, ans):\n\n    #print(i,j)\n    if i == 11:\n        flag = True\n        for k in range(1,11):\n            if table[10][k] == 1:\n                flag = False\n                break\n        if flag:\n            printans(ans)\n        return\n\n    if table[i-1][j] == 1:\n        ans[i][j] = 1\n        attack(table, i, j)\n        if j == 10:\n            solve(table, i+1, 1, ans)\n        else:\n            solve(table, i, j+1, ans)\n        attack(table, i, j)\n        ans[i][j] = 0\n    else:\n        ans[i][j] = 0\n        if j == 10:\n            solve(table, i+1, 1, ans)\n        else:\n            solve(table, i, j+1, ans)\n\n\ndef check(table, i, ans):\n\n    if i == 11:\n        solve(table, 2, 1, ans)\n        return\n\n    ans[1][i] = 0\n    check(table, i+1, ans)\n\n    ans[1][i] = 1\n    attack(table, 1, i)\n    check(table, i+1, ans)\n    attack(table, 1, i)\n\nN = int(input())\n\nfor l in range(N):\n    table= [[0 for i in range(12)] for j in range(12)]\n    ans= [[0 for i in range(12)] for j in range(12)]\n    for i in range(1, 11):\n        nums = [int(k) for k in input().split()]\n        for j in range(1, 11):\n            table[i][j] = nums[j-1]\n\n    check(table, 1, ans)\n", "sampled": "def solve_lights_out(grid):\n    # This is a lights-out puzzle problem over GF(2)\n    # We need to solve a system of linear equations in GF(2)\n    \n    # Create the coefficient matrix\n    # For a 10x10 grid, we have 100 variables and 100 equations\n    n = 10\n    size = n * n\n    \n    # Build the augmented matrix [A|b]\n    # A[i][j] = 1 if pressing button j affects light i\n    A = [[0] * size for _ in range(size)]\n    b = [0] * size\n    \n    # Fill the coefficient matrix\n    for i in range(n):\n        for j in range(n):\n            light_idx = i * n + j\n            b[light_idx] = grid[i][j]\n            \n            # Pressing button at (r, c) affects lights at (r, c) and adjacent cells\n            for r in range(n):\n                for c in range(n):\n                    button_idx = r * n + c\n                    \n                    # Check if pressing button (r,c) affects light (i,j)\n                    if (r == i and c == j):\n                        continue  # The button itself doesn't light up\n                    \n                    # Check if (i,j) is adjacent to (r,c)\n                    if (abs(r - i) + abs(c - j)) == 1:\n                        A[light_idx][button_idx] = 1\n    \n    # Gaussian elimination in GF(2)\n    augmented = [A[i] + [b[i]] for i in range(size)]\n    \n    # Forward elimination\n    for col in range(size):\n        # Find pivot\n        pivot_row = -1\n        for row in range(col, size):\n            if augmented[row][col] == 1:\n                pivot_row = row\n                break\n        \n        if pivot_row == -1:\n            continue\n        \n        # Swap rows\n        augmented[col], augmented[pivot_row] = augmented[pivot_row], augmented[col]\n        \n        # Eliminate\n        for row in range(size):\n            if row != col and augmented[row][col] == 1:\n                for k in range(size + 1):\n                    augmented[row][k] ^= augmented[col][k]\n    \n    # Back substitution\n    solution = [0] * size\n    for i in range(size):\n        if augmented[i][i] == 1:\n            solution[i] = augmented[i][size]\n    \n    # Convert solution to 2D grid\n    result = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            result[i][j] = solution[i * n + j]\n    \n    return result\n\n# Read input\nn_datasets = int(input())\nfor _ in range(n_datasets):\n    grid = []\n    for i in range(10):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    result = solve_lights_out(grid)\n    \n    for row in result:\n        print(' '.join(map(str, row)))\n", "perturbed_sampled": ["def solve_lights_out(grid): # This is a  a system of linear equations in GF(2) # Create the coefficient matrix # For a 10x10  10 size = n * n # Build the augmented  affects light i A =  * size # Fill the coefficient matrix for i in range(n): for j in range(n):  # Pressing button at (r, c) affects  range(n):  continue # The button itself doesn't light up # Check if  abs(c - j)) == 1:  elimination for col in range(size): # Find pivot pivot_row = -1 for row in range(col, size): if augmented[row][col] == 1: pivot_row = row break if pivot_row == -1: continue # Swap rows augmented[col], augmented[pivot_row] = augmented[pivot_row], augmented[col] # Eliminate for row in range(size): if row != col and augmented[row][col] == 1: for k in range(size + 1): augmented[row][k] ^= augmented[col][k] # Back substitution solution = [0] * size for i in   _ in range(n)] for i in range(n): for j in range(n): result[i][j] =  n_datasets = int(input()) for _  = list(map(int, input().split())) grid.append(row) result = solve_lights_out(grid) for row in result: print(' '.join(map(str, row)))"], "perturbed_original": ["def attack(table, i, j): table[i][j] = 1 - table[i][j] table[i-1][j]  = 1 - table[i][j-1] table[i][j+1] = 1 - table[i][j+1] def printans(ans): for i in range(1, 11): for j in range(1, 11): print(ans[i][j], end=\"\") if j < 10: print(\" \", end=\"\") print(\"\") def solve(table, i,  =   solve(table, i+1, 1, ans) else: solve(table, i, j+1, ans) attack(table, i, j) ans[i][j] = 0 else: ans[i][j]  else: solve(table, i, j+1, ans) def check(table, i, ans): if  0 check(table, i+1, ans) ans[1][i] = 1 attack(table, 1, i) check(table, i+1, ans) attack(table, 1, i) N = int(input()) for l in range(N): table= [[0 for i in range(12)]  for j in range(12)] for   1, ans)"], "original_ll": -0.48895296454429626, "sampled_ll": -0.6873090267181396, "all_perturbed_sampled_ll": [-2.1675546169281006], "all_perturbed_original_ll": [-1.3788973093032837], "perturbed_sampled_ll": -2.1675546169281006, "perturbed_original_ll": -1.3788973093032837, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // qsort()\n#include <string.h>         // memset(), memcpy(), strchr()\n#include <stdbool.h>\n\n// #define DEBUG 1\n\n#define MAX_W 20\n#define MAX_H 20\n#define MAX_N 10\n\ntypedef struct order_tbl\n{\n\tint s;\n\tint bx;\n\tint by;\n\tint angle;\n\tdouble rate;\n} order_t;\n\nconst char NUL = '\\0';\n\n#ifdef DEBUG\nstatic int O = 0;\n#endif\n\nint H, W;\nchar field[MAX_H][MAX_W + 1];\nchar puzzle[MAX_H][MAX_W + 1];\nint n;\nint h0[MAX_N][4];\nint w0[MAX_N][4];\nchar piece[MAX_N][4][MAX_H][MAX_W + 1];\nint k;\nint t[MAX_N];\n\nvoid\nbury(order_t *u)\n{\n\tint s = u->s;\n\tint a = u->angle;\n\tint h = h0[s][a];\n\tint w = w0[s][a];\n\n\tfor (int y = 0; y < h; ++y)\n\t{\n\t\tfor (int x = 0; x < w; ++x)\n\t\t{\n\t\t\tif (piece[s][a][y][x] == '#')\n\t\t\t\tfield[u->by + y][u->bx + x] = '*';\n\t\t}\n\t}\n}\n\ndouble\nfitin(order_t *u, int a, int bx, int by)\n{\n\tint s = u->s;\n\tint h = h0[s][a];\n\tint w = w0[s][a];\n\n\tint dx[4] = { 0, 1, 0,-1};\n\tint dy[4] = { 1, 0,-1, 0};\n\n\tint count = 0;\n\tint total = 0;\n\tfor (int x = -1; x <= w; ++x)\n\t{\n\t\tint nx = bx + x;\n\t\tfor (int y = -1; y <= h; ++y)\n\t\t{\n\t\t\tint ny = by + y;\n\t\t\tif (0 <= x && x < w && 0 <= y && y < h && piece[s][a][y][x] == '#')\n\t\t\t{\n\t\t\t\tif (0 <= nx && nx < W && 0 <= ny && ny < H && field[ny][nx] != '.')\n\t\t\t\t\treturn -100.0;\n\t\t\t}\n\t\t\telse // piece[s][a][y][x] == '.' ?\n\t\t\t{\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\t{\n\t\t\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\t\t\tif (0 <= tx && tx < w && 0 <= ty && ty < h && piece[s][a][ty][tx] == '#')\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (i < 4)\n\t\t\t\t{\n\t\t\t\t\ttotal++;\n\t\t\t\t\tif (nx < 0 || W <= nx || ny < 0 || H <= ny || field[ny][nx] != '.')\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count * 100.0 / total;\n}\n\nvoid\nprobe(order_t *u)\n{\n\tint s = u->s;\n\tfor (int a = 0; a < 4; ++a)\n\t{\n\t\tint h = h0[s][a];\n\t\tint w = w0[s][a];\n\n\t\tint fx = strchr(piece[s][a][0], '#') - piece[s][a][0];\n\t\tfor (int by = 0; by + h <= H; ++by)\n\t\t{\n\t\t\tfor (int bx = 0; bx + w <= W; ++bx)\n\t\t\t{\n\t\t\t\tif (field[by][bx + fx] == '.')\n\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\tO++;\n#endif\n\t\t\t\t\tdouble r = fitin(u, a, bx, by);\n\t\t\t\t\tif (r > u->rate)\n\t\t\t\t\t{\n\t\t\t\t\t\tu->rate = r;\n\t\t\t\t\t\tu->bx = bx;\n\t\t\t\t\t\tu->by = by;\n\t\t\t\t\t\tu->angle = a;\n\n\t\t\t\t\t\tif (u->rate >= 100.0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbury(u);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint\ncmp_func(const void *l_, const void *r_)\n{\n\tconst order_t *l = (const order_t*) l_;\n\tconst order_t *r = (const order_t*) r_;\n\n\tif (l->rate < r->rate)\n\t\treturn 1;\n\n\tif (l->rate > r->rate)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nbool\nsolve()\n{\n\torder_t u;\n\torder_t order[MAX_N];\n\tint memo[MAX_N];\n\tint ix, ix2;\n\n\tmemcpy(field, puzzle, sizeof(field));\n\tix = 0;\n\tfor (int i = 0; i < k; ++i)\n\t\tmemo[ix++] = t[i];\n\n\twhile (ix != 0)\n\t{\n\t\tix2 = 0;\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n#ifdef DEBUG\n\t\t\tmemset(&u, 0x00, sizeof(u));\n#endif\n\t\t\tu.s = memo[i];\n\t\t\tu.rate = -100.0;\n\t\t\tprobe(&u);\n\t\t\tif (u.rate != 100.0)\n\t\t\t\torder[ix2++] = u;\n\t\t}\n\n\t\tif (ix2 == 0)\n\t\t\tbreak;\n\n\t\tqsort(order, ix2, sizeof(order_t), cmp_func);\n\t\tif (order[0].rate == -100.0)\n\t\t\treturn false;\n\n\t\tbury(&order[0]);\n\n\t\tix = 0;\n\t\tfor (int i = 1; i < ix2; ++i)\n\t\t\tmemo[ix++] = order[i].s;\n\t}\n\n\tfor (int y = 0; y < H; ++y)\n\t{\n\t\tfor (int x = 0; x < W; ++x)\n\t\t{\n\t\t\tif (field[y][x] == '.')\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\\n\", &H, &W);\n\t\tif (H == 0 && W == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < H; ++i)\n\t\t\tscanf(\"%s\", &puzzle[i][0]);\n\n\t\tscanf(\"%d\", &n);\n\t\tfor (int s = 0; s < n; ++s)\n\t\t{\n\t\t\tscanf(\"%d%d\\n\", &h0[s][0], &w0[s][0]);\n\t\t\tint h = h0[s][0];\n\t\t\tint w = w0[s][0];\n\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t\tscanf(\"%s\", &piece[s][0][y][0]);\n\n\t\t\th0[s][1] = w;\n\t\t\tw0[s][1] = h;\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tpiece[s][1][x][h - y - 1] = piece[s][0][y][x];\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tpiece[s][1][x][h] = NUL;\n#endif\n\n\t\t\th0[s][2] = h;\n\t\t\tw0[s][2] = w;\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tpiece[s][2][h - 1 - y][w - 1 - x] = piece[s][0][y][x];\n\n#ifdef DEBUG\n\t\t\t\tpiece[s][2][h - 1 - y][w] = NUL;\n#endif\n\t\t\t}\n\n\t\t\tw0[s][3] = h;\n\t\t\th0[s][3] = w;\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tpiece[s][3][w - 1 - x][y] = piece[s][0][y][x];\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tpiece[s][3][x][h] = NUL;\n#endif\n\t\t}\n\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\t\tfor (int i = 0; i < p; ++i)\n\t\t{\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor (int j = 0; j < k; ++j)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &t[j]);\n\t\t\t\tt[j]--;\n\t\t\t}\n\n\t\t\tprintf(\"%s\\n\", solve() ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tfprintf(stderr, \"O:%d\\n\", O);\n#endif\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 20\n#define MAX_PIECES 10\n\nchar grid[MAX_SIZE][MAX_SIZE+1];\nchar pieces[MAX_PIECES][MAX_SIZE][MAX_SIZE+1];\nint piece_h[MAX_PIECES], piece_w[MAX_PIECES];\nint H, W, n;\n\ntypedef struct {\n    char data[MAX_SIZE][MAX_SIZE+1];\n    int h, w;\n} Piece;\n\nvoid rotate90(Piece *src, Piece *dst) {\n    dst->h = src->w;\n    dst->w = src->h;\n    for (int i = 0; i < dst->h; i++) {\n        for (int j = 0; j < dst->w; j++) {\n            dst->data[i][j] = src->data[src->h - 1 - j][i];\n        }\n        dst->data[i][dst->w] = '\\0';\n    }\n}\n\nint canPlace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {\n    for (int i = 0; i < p->h; i++) {\n        for (int j = 0; j < p->w; j++) {\n            if (p->data[i][j] == '#') {\n                if (y + i >= H || x + j >= W || board[y+i][x+j] != '.') {\n                    return 0;\n                }\n            }\n        }\n    }\n    return 1;\n}\n\nvoid place(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {\n    for (int i = 0; i < p->h; i++) {\n        for (int j = 0; j < p->w; j++) {\n            if (p->data[i][j] == '#') {\n                board[y+i][x+j] = '#';\n            }\n        }\n    }\n}\n\nvoid unplace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {\n    for (int i = 0; i < p->h; i++) {\n        for (int j = 0; j < p->w; j++) {\n            if (p->data[i][j] == '#') {\n                board[y+i][x+j] = '.';\n            }\n        }\n    }\n}\n\nint isComplete(char board[MAX_SIZE][MAX_SIZE+1]) {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (board[i][j] == '.') return 0;\n        }\n    }\n    return 1;\n}\n\nint solve(char board[MAX_SIZE][MAX_SIZE+1], Piece rotations[][4], int selected[], int k, int used[], int idx) {\n    if (isComplete(board)) {\n        for (int i = 0; i < k; i++) {\n            if (!used[i]) return 0;\n        }\n        return 1;\n    }\n    \n    if (idx >= k) return 0;\n    \n    for (int pi = 0; pi < k; pi++) {\n        if (used[pi]) continue;\n        \n        for (int rot = 0; rot < 4; rot++) {\n            for (int y = 0; y < H; y++) {\n                for (int x = 0; x < W; x++) {\n                    if (canPlace(board, &rotations[pi][rot], y, x)) {\n                        place(board, &rotations[pi][rot], y, x);\n                        used[pi] = 1;\n                        if (solve(board, rotations, selected, k, used, idx + 1)) {\n                            return 1;\n                        }\n                        used[pi] = 0;\n                        unplace(board, &rotations[pi][rot], y, x);\n                    }\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint checkPlayer(int selected[], int k) {\n    char board[MAX_SIZE][MAX_SIZE+1];\n    for (int i = 0; i < H; i++) {\n        strcpy(board[i], grid[i]);\n    }\n    \n    Piece rotations[MAX_PIECES][4];\n    for (int i = 0; i < k; i++) {\n        int idx = selected[i] - 1;\n        rotations[i][0].h = piece_h[idx];\n        rotations[i][0].w = piece_w[idx];\n        for (int r = 0; r < piece_h[idx]; r++) {\n            strcpy(rotations[i][0].data[r], pieces[idx][r]);\n        }\n        \n        rotate90(&rotations[i][0], &rotations[i][1]);\n        rotate90(&rotations[i][1], &rotations[i][2]);\n        rotate90(&rotations[i][2], &rotations[i][3]);\n    }\n    \n    int used[MAX_PIECES] = {0};\n    return solve(board, rotations, selected, k, used, 0);\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &H, &W);\n        if (H == 0 && W == 0) break;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        scanf(\"%d\", &n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &piece_h[i], &piece_w[i]);\n            for (int j = 0; j < piece_h[i]; j++) {\n                scanf(\"%s\", pieces[i][j]);\n            }\n        }\n        \n        int p;\n        scanf(\"%d\", &p);\n        for (int i = 0; i < p; i++) {\n            int k;\n            scanf(\"%d\", &k);\n            int selected[MAX_PIECES];\n            for (int j = 0; j < k; j++) {\n                scanf(\"%d\", &selected[j]);\n            }\n            \n            if (checkPlayer(selected, k)) {\n                printf(\"YES\\n\");\n            } else {\n                printf(\"NO\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  10 char grid[MAX_SIZE][MAX_SIZE+1]; char pieces[MAX_PIECES][MAX_SIZE][MAX_SIZE+1]; int piece_h[MAX_PIECES], piece_w[MAX_PIECES]; int H, W,  Piece; void rotate90(Piece  j++) { dst->data[i][j] = src->data[src->h - 1 -  Piece *p, int y, int x) { for (int i = 0; i  <  + i  !=  }  j++) { if (p->data[i][j] == '#') { board[y+i][x+j] = '#'; } } } } void unplace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) { for (int i = 0; i < p->h; i++) { for (int  == '#') { board[y+i][x+j] = '.'; } } } } int isComplete(char board[MAX_SIZE][MAX_SIZE+1]) { for (int i = 0;  return 0; } } return 1; } int solve(char board[MAX_SIZE][MAX_SIZE+1], Piece rotations[][4], int selected[], int k, int used[], int idx) { if (isComplete(board)) { for (int i = 0; i < k; i++) { if (!used[i]) return 0; } return 1; } if (idx >= k) return 0;  if (used[pi]) continue; for (int rot = 0; rot < 4; rot++) { for (int y = 0; y < H; y++) { for (int x = 0; x < W; x++) { if (canPlace(board, &rotations[pi][rot], y, x)) { place(board, &rotations[pi][rot], y, x); used[pi] =  } int checkPlayer(int selected[], int k) { char board[MAX_SIZE][MAX_SIZE+1]; for (int i  k; i++) { int idx  for (int r = 0; r < piece_h[idx]; r++) { strcpy(rotations[i][0].data[r], pieces[idx][r]); } rotate90(&rotations[i][0], &rotations[i][1]); rotate90(&rotations[i][1], &rotations[i][2]); rotate90(&rotations[i][2], &rotations[i][3]); } int used[MAX_PIECES] = {0}; return solve(board, rotations, selected, k, used, 0); }  if   } scanf(\"%d\", &n); for (int  &piece_h[i], &piece_w[i]); for (int j = 0; j < piece_h[i]; j++) { scanf(\"%s\", pieces[i][j]); } } int p; scanf(\"%d\", &p); for (int i = 0; i < p; i++) { int k; scanf(\"%d\", &k); int selected[MAX_PIECES]; for (int j  if (checkPlayer(selected, k)) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } } return 0; }"], "perturbed_original": ["#include <stdio.h> // printf(), scanf() #include <stdlib.h> // qsort() #include <string.h> // memset(), memcpy(), strchr() #include <stdbool.h> // #define DEBUG 1 #define MAX_W 20 #define MAX_H 20 #define MAX_N 10 typedef struct order_tbl {  } order_t; const char   piece[MAX_N][4][MAX_H][MAX_W + 1]; int k; int t[MAX_N]; void bury(order_t *u) { int s = u->s; int a = u->angle; int h = h0[s][a]; int w = w0[s][a]; for (int y = 0; y < h; ++y) { for (int x  '#') field[u->by + y][u->bx +  u->s; int h = h0[s][a]; int w = w0[s][a]; int dx[4] = { 0, 1, 0,-1}; int dy[4] = { 1, 0,-1, 0}; int count = 0;  <= w; ++x) { int nx = bx + x; for  ny = by + y; if (0 <= x && x < w && 0 <= y && y < h && piece[s][a][y][x] == '#') { if  return -100.0; } else // piece[s][a][y][x] == '.' ? { int i; for (i = 0; i < 4; ++i) { int  if (0 <= tx && tx < w && 0 <= ty && ty < h && piece[s][a][ty][tx] == '#') break; }  || W <= nx || ny < 0 || H <= ny ||  * 100.0  ++a) { int h = h0[s][a]; int w = w0[s][a];  = 0; by + h <= H; ++by)  W; ++bx) { if (field[by][bx + fx] == '.') { #ifdef DEBUG O++; #endif double r = fitin(u, a, bx, by); if (r > u->rate) { u->rate = r; u->bx = bx; u->by = by; u->angle = a; if (u->rate >= 100.0)  int cmp_func(const void *l_, const void *r_) { const order_t *l = (const order_t*) l_; const order_t *r  if  { order_t u; order_t  { ix2 = 0; for (int i = 0; i < ix; ++i)  ix2, sizeof(order_t), cmp_func); if (order[0].rate == -100.0) return false; bury(&order[0]); ix = 0; for (int i  ++x) { if (field[y][x] == '.') return false; } } return true; } int main(int argc, char  == 0 && W == 0) break; for (int i = 0; i < H;  y = 0; y < h; ++y) scanf(\"%s\", &piece[s][0][y][0]); h0[s][1] = w; w0[s][1] = h; for (int y =  1] =  y < h; ++y) { for (int x = 0; x < w; ++x) piece[s][2][h - 1 - y][w - 1  y][w] = NUL; #endif } w0[s][3] = h; h0[s][3] = w; for (int y = 0; y < h; ++y) { for (int x =  0; x < w; ++x) piece[s][3][x][h] = NUL; #endif } int p; scanf(\"%d\", &p); for (int i = 0; i < p; ++i) { scanf(\"%d\", &k); for (int j =  printf(\"%s\\n\", solve() ? \"YES\" : \"NO\"); } } #ifdef DEBUG fprintf(stderr, \"O:%d\\n\", O); #endif return 0; }"], "original_ll": -0.5772164463996887, "sampled_ll": -0.3136232793331146, "all_perturbed_sampled_ll": [-1.2502694129943848], "all_perturbed_original_ll": [-1.5551154613494873], "perturbed_sampled_ll": -1.2502694129943848, "perturbed_original_ll": -1.5551154613494873, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.util.Calendar.Builder;\n\nimport javax.jws.soap.SOAPBinding.Use;\n\n\n\npublic class Main {\n\tstatic int H;\n\tstatic int W;\n\tstatic int[] map;\n\tstatic Piece[] p;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif(H == 0 && W == 0) break;\n\t\t\tmap = new int[H];\n\t\t\tint mapCount = 0;\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tString in = sc.next();\n\t\t\t\tin = in.replace('.', '0');\n\t\t\t\tin = in.replace('#', '1');\n\t\t\t\tint bin = Integer.parseInt(in,2);\n\t\t\t\tmap[i] = bin;\n\t\t\t\tmapCount += W - Integer.bitCount(bin);\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tp = new Piece[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tString[] map = new String[h];\n\t\t\t\tfor(int j = 0; j < h; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[j] = in;\n\t\t\t\t}\n\t\t\t\tp[i] = new Piece(h,w,map);\n\t\t\t}\n\t\t\t\n\t\t\tint p = sc.nextInt();\n\t\t\tfor(int i = 0; i < p; i++) {\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tint[] t = new int[k];\n\t\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\t\tt[j] = sc.nextInt()-1;\n\t\t\t\t}\n\t\t\t\tint bitCount = 0;\n\t\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\t\tfor(int l = 0; l < Main.p[t[j]].h[0]; l++) {\n\t\t\t\t\t\tbitCount += Integer.bitCount(Main.p[t[j]].map[0][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean ans = false;\n\t\t\t\tif(bitCount == mapCount) {\n\t\t\t\t\tans = check(new boolean[k],t,map,0,0,0);\n\t\t\t\t}\n\t\t\t\tif(ans) System.out.println(\"YES\");\n\t\t\t\telse System.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean check(boolean[] used, int[] use, int[] map, int y, int x,int c) {\n\t\tif(x == W) return check(used,use,map,y+1,0,c);\n\t\tif(y == H && c == use.length) {\n\t\t\treturn true;\n\t\t}\n\t\telse if(y == H) return false;\n\t\tif((map[y] & (1 << (W - x - 1))) == 0) {\n\t\t\tfor(int i = 0; i < use.length; i++) {\n\t\t\t\tif(used[i]) continue;\n\t\t\t\tint sel = use[i];\n\t\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\t\tint xx = x - p[sel].vw[j];\n\t\t\t\t\tif(xx < 0) continue;\n\t\t\t\t\tboolean cf = checkCanFill(y,xx,j,map,p[sel]);\n\t\t\t\t\tif(!cf) continue;\n\t\t\t\t\tfill(y,xx,j,map,p[sel]);\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tboolean rt = check(used,use,map,y,x+1,c+1);\n\t\t\t\t\tif(rt) {\n\t\t\t\t\t\tused[i] = false;\n\t\t\t\t\t\tfill(y,xx,j,map,p[sel]);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tused[i] = false;\n\t\t\t\t\tfill(y,xx,j,map,p[sel]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn check(used,use,map,y,x+1,c);\n\t\t}\n\t}\n\tstatic boolean checkCanFill(int A, int B, int C,int[] map, Piece p) {\n\t\tif(p.h[C] + A > H) return false;\n\t\tif(p.w[C] + B > W || W - p.w[C] - B < 0) return false;\n\t\tfor(int i = 0; i < p.h[C]; i++) {\n\t\t\tif((map[i + A] & (p.map[C][i] << (W - p.w[C] - B))) != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic void fill(int A, int B, int C, int[] map, Piece p) {\n\t\tfor(int i = 0; i < p.h[C]; i++) {\n\t\t\tmap[i + A] ^= (p.map[C][i] << (W - p.w[C] - B));\n\t\t}\n\t}\n\tstatic boolean checkFill(int[] map) {\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tif(map[i] != (1 << W)-1) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic String[] rotate(String[] map) {\n\t\tchar[][] in = new char[map.length][];\n\t\tfor(int i = 0; i < map.length; i++) {\n\t\t\tin[i] = map[i].toCharArray();\n\t\t}\n\t\tchar[][] ret = new char[in[0].length][in.length];\n\t\tfor(int i = 0; i < in[0].length; i++) {\n\t\t\tfor(int j = 0; j < in.length; j++) {\n\t\t\t\tret[i][j] = in[in.length - j - 1][i];\n\t\t\t}\n\t\t}\n\t\tString[] retu = new String[ret.length];\n\t\tfor(int i = 0; i < ret.length; i++) {\n\t\t\tretu[i] = String.valueOf(ret[i]);\n\t\t}\n\t\treturn retu;\n\t\t\n\t}\n\t\n\t\n\tstatic class Piece {\n\t\tint[] h;\n\t\tint[] w;\n\t\tint[][] map;\n\t\tint[] vw;\n\t\tPiece(int a, int b, String[] c) {\n\t\t\th = new int[4];\n\t\t\tw = new int[4];\n\t\t\tvw = new int[4];\n\t\t\tmap = new int[4][];\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\th[i] = a;\n\t\t\t\tw[i] = b;\n\t\t\t\tmap[i] = new int[h[i]];\n\t\t\t\tfor(int j = 0; j < w[i]; j++) {\n\t\t\t\t\tif(c[0].charAt(j) == '#') {\n\t\t\t\t\t\tvw[i] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < h[i]; j++) {\n\t\t\t\t\tString in = c[j];\n\t\t\t\t\tin = in.replace('.', '0');\n\t\t\t\t\tin = in.replace('#', '1');\n\t\t\t\t\tint bin = Integer.parseInt(in,2);\n\t\t\t\t\tmap[i][j] = bin;\n\t\t\t\t}\n\t\t\t\tint tmp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = tmp;\n\t\t\t\tc = rotate(c);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        if (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static char[][] grid;\n    static List<char[][]> pieces;\n    static int H, W;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] hw = line.trim().split(\"\\\\s+\");\n            H = Integer.parseInt(hw[0]);\n            W = Integer.parseInt(hw[1]);\n            \n            if (H == 0 && W == 0) break;\n            \n            grid = new char[H][W];\n            for (int i = 0; i < H; i++) {\n                String row = br.readLine();\n                grid[i] = row.toCharArray();\n            }\n            \n            int n = Integer.parseInt(br.readLine().trim());\n            pieces = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                String[] size = br.readLine().trim().split(\"\\\\s+\");\n                int h = Integer.parseInt(size[0]);\n                int w = Integer.parseInt(size[1]);\n                char[][] piece = new char[h][w];\n                for (int j = 0; j < h; j++) {\n                    String row = br.readLine();\n                    piece[j] = row.toCharArray();\n                }\n                pieces.add(piece);\n            }\n            \n            int p = Integer.parseInt(br.readLine().trim());\n            \n            for (int i = 0; i < p; i++) {\n                String[] selection = br.readLine().trim().split(\"\\\\s+\");\n                int k = Integer.parseInt(selection[0]);\n                List<Integer> selected = new ArrayList<>();\n                for (int j = 1; j <= k; j++) {\n                    selected.add(Integer.parseInt(selection[j]) - 1);\n                }\n                \n                if (canSolve(selected)) {\n                    System.out.println(\"YES\");\n                } else {\n                    System.out.println(\"NO\");\n                }\n            }\n        }\n    }\n    \n    static boolean canSolve(List<Integer> selected) {\n        char[][] testGrid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                testGrid[i][j] = grid[i][j];\n            }\n        }\n        \n        return tryPlace(testGrid, selected, 0);\n    }\n    \n    static boolean tryPlace(char[][] testGrid, List<Integer> selected, int idx) {\n        if (idx == selected.size()) {\n            return isComplete(testGrid);\n        }\n        \n        int pieceIdx = selected.get(idx);\n        char[][] piece = pieces.get(pieceIdx);\n        \n        for (int rot = 0; rot < 4; rot++) {\n            char[][] rotated = rotate(piece, rot);\n            for (int i = 0; i <= H - rotated.length; i++) {\n                for (int j = 0; j <= W - rotated[0].length; j++) {\n                    if (canPlace(testGrid, rotated, i, j)) {\n                        char[][] backup = copyGrid(testGrid);\n                        place(testGrid, rotated, i, j);\n                        if (tryPlace(testGrid, selected, idx + 1)) {\n                            return true;\n                        }\n                        restoreGrid(testGrid, backup);\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    static boolean canPlace(char[][] testGrid, char[][] piece, int r, int c) {\n        for (int i = 0; i < piece.length; i++) {\n            for (int j = 0; j < piece[0].length; j++) {\n                if (piece[i][j] == '#') {\n                    if (testGrid[r + i][c + j] != '.') {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    \n    static void place(char[][] testGrid, char[][] piece, int r, int c) {\n        for (int i = 0; i < piece.length; i++) {\n            for (int j = 0; j < piece[0].length; j++) {\n                if (piece[i][j] == '#') {\n                    testGrid[r + i][c + j] = '#';\n                }\n            }\n        }\n    }\n    \n    static boolean isComplete(char[][] testGrid) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (testGrid[i][j] == '.') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    static char[][] rotate(char[][] piece, int times) {\n        char[][] result = piece;\n        for (int t = 0; t < times; t++) {\n            int h = result.length;\n            int w = result[0].length;\n            char[][] newPiece = new char[w][h];\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    newPiece[j][h - 1 - i] = result[i][j];\n                }\n            }\n            result = newPiece;\n        }\n        return result;\n    }\n    \n    static char[][] copyGrid(char[][] grid) {\n        char[][] copy = new char[grid.length][grid[0].length];\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                copy[i][j] = grid[i][j];\n            }\n        }\n        return copy;\n    }\n    \n    static void restoreGrid(char[][] grid, char[][] backup) {\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                grid[i][j] = backup[i][j];\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class  H, W; public static void main(String[] args) throws IOException { BufferedReader br =  W = Integer.parseInt(hw[1]); if (H == 0 && W == 0) break; grid = new char[H][W]; for  row =  = new ArrayList<>(); for (int i = 0; i < n; i++) { String[] size = br.readLine().trim().split(\"\\\\s+\"); int h = Integer.parseInt(size[0]); int w =  0; j < h;  pieces.add(piece); } int p = Integer.parseInt(br.readLine().trim()); for (int i = 0; i  j = 1; j <= k; j++) { selected.add(Integer.parseInt(selection[j]) - 1); } if (canSolve(selected)) { System.out.println(\"YES\");  { testGrid[i][j] = grid[i][j];  testGrid, List<Integer> selected, int idx) { if (idx == selected.size()) { return isComplete(testGrid); } int pieceIdx = selected.get(idx); char[][] piece = pieces.get(pieceIdx); for (int  = rotate(piece, rot); for (int i = 0;  copyGrid(testGrid); place(testGrid, rotated, i, j); if (tryPlace(testGrid, selected, idx + 1)) { return true; } restoreGrid(testGrid,  canPlace(char[][] testGrid, char[][] piece, int r, int c) { for (int i = 0; i < piece.length; i++) { for (int j = 0; j < piece[0].length; j++) { if (piece[i][j] == '#') { if (testGrid[r + i][c + j] != '.') { return false;   i = 0; i < piece.length;  j++) { if (piece[i][j] == '#') { testGrid[r + i][c + j] = '#'; } } } } static boolean isComplete(char[][] testGrid) { for (int i = 0; i < H; i++) { for (int j =  static   int h = result.length; int w = result[0].length; char[][] newPiece = new char[w][h]; for (int i = 0; i < h; i++) { for (int j = 0; j < w; j++) { newPiece[j][h - 1 - i] = result[i][j]; }  copyGrid(char[][] grid) { char[][] copy = new char[grid.length][grid[0].length]; for (int i = 0; i < grid.length; i++) { for (int j = 0; j < grid[0].length; j++) { copy[i][j] =  char[][] backup) { for (int i = 0;  } } }"], "perturbed_original": ["import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.util.*; import  static int W; static int[] map; static  = new FastScanner(); //Scanner sc =  = sc.nextInt(); W = sc.nextInt(); if(H == 0 && W == 0) break; map = new  = in.replace('.', '0'); in = in.replace('#', '1'); int bin = Integer.parseInt(in,2); map[i] = bin; mapCount += W - Integer.bitCount(bin); } int n = sc.nextInt(); p = new Piece[n]; for(int i = 0; i < n; i++) { int h = sc.nextInt(); int w = sc.nextInt(); String[]  = sc.nextInt(); for(int i = 0; i  k; j++) { t[j] = sc.nextInt()-1; }  Main.p[t[j]].h[0]; l++) { bitCount += Integer.bitCount(Main.p[t[j]].map[0][l]); }  = check(new boolean[k],t,map,0,0,0); } if(ans) System.out.println(\"YES\"); else System.out.println(\"NO\"); } } } static boolean check(boolean[] used, int[] use, int[] map, int y, int x,int  if(y == H) return false; if((map[y] & (1 << (W - x - 1))) == 0) { for(int i = 0; i < use.length; i++) {  j < 4; j++) { int xx =  checkCanFill(y,xx,j,map,p[sel]); if(!cf) continue; fill(y,xx,j,map,p[sel]); used[i] = true; boolean rt = check(used,use,map,y,x+1,c+1); if(rt)  return check(used,use,map,y,x+1,c); } } static boolean  if(p.h[C] +  || W - p.w[C] - B < 0) return false; for(int i = 0; i < p.h[C]; i++) { if((map[i + A] & (p.map[C][i] << (W - p.w[C] - B))) != 0) return false; } return true; } static void fill(int A, int B, int C,  < p.h[C]; i++) { map[i + A] ^= (p.map[C][i] << (W - p.w[C] - B)); } } static boolean checkFill(int[]  return true; } static String[] rotate(String[] map) { char[][] in = new char[map.length][]; for(int  map[i].toCharArray(); } char[][] ret = new char[in[0].length][in.length]; for(int i = 0; i < in[0].length; i++) { for(int j = 0; j  Piece(int a, int b, String[]  vw = new int[4]; map = new int[4][]; for(int i = 0; i < 4; i++) { h[i] = a; w[i] = b; map[i] = new int[h[i]]; for(int j  = 0; j <  map[i][j] = bin; } int tmp = a; a = b; b = tmp; c =  InputStream in = System.in; private final  private int buflen = 0; private boolean hasNextByte() { if (ptr < buflen) { return true; }else{ ptr = 0; try { buflen = in.read(buffer); } catch (IOException e) { e.printStackTrace(); } if (buflen <= 0)  private static boolean isPrintableChar(int c) {  skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;} public boolean hasNext() { skipUnprintable(); return hasNextByte();}  public long nextLong() { if (!hasNext()) throw new  b = readByte(); if (b == '-')  < '0' || '9' <  b && b <= '9') { n *= 10; n += b - '0'; }else if(b == -1 || !isPrintableChar(b)){ return minus ? -n : n; }else{ throw new NumberFormatException(); } b = readByte(); } } public int nextInt() { if (!hasNext()) throw new NoSuchElementException();  = readByte(); if (b == '-') { minus = true; b = readByte(); } if (b < '0' || '9' < b) { throw new NumberFormatException(); } while(true){ if ('0' <= b && b  '0'; }else if(b == -1 || !isPrintableChar(b)){  } b = readByte(); } } }"], "original_ll": -0.45830273628234863, "sampled_ll": -0.2564164400100708, "all_perturbed_sampled_ll": [-1.2262308597564697], "all_perturbed_original_ll": [-1.5904496908187866], "perturbed_sampled_ll": -1.2262308597564697, "perturbed_original_ll": -1.5904496908187866, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import copy\ndef rot90(A):\n  return zip(*A[::-1])\n\ndef count_board(Board):\n  X = [[0 for _ in [0]*(Width+1)] for _ in [0]*(Height+1)]\n  for i in range(Height)[::-1]:\n    for j in range(Width)[::-1]:\n      X[i][j] = X[i+1][j] + X[i][j+1] - X[i+1][j+1] + (Board[i][j]=='.')\n  return X\n\ndef check_sum(TRIALS):\n  return sum([B[e] for e in TRIALS]) != DOTS[0][0]\n\ndef tmp_put(Board, piece, y, x):\n  N = range(len(piece[0]))\n  for i in range(len(piece)):\n    tmp = piece[i]\n    BoardRow = Board[y+i]\n    for j in N:\n      if tmp[j]=='#' and BoardRow[x+j]!='.': return 0\n  return 1\n\ndef get_put(Board, piece, y, x, mode):\n  c = '#.'[mode]\n  W = range(len(piece[0]))\n  for i in range(len(piece)):\n    tmp = piece[i]\n    Y = y+i\n    for j in W:\n      if tmp[j]=='#': Board[Y][x+j]=c\n  return Board\n\ndef PrintBoard(Board):\n  for e in Board:\n    print \"\".join(e)\n  print\n  return\n\ndef PrintDots(DOTS):\n  for e in DOTS:\n    print e\n  print\n  return\n\ndef solve(TRIALS, Board):\n  if TRIALS==[]: return 1\n  n = TRIALS[0]\n  DOTS = count_board(Board)\n  for direction in C[n]:\n    P = PIECE[(n, direction)]\n    h = len(P)\n    w = len(P[0])\n    s = B[n]\n    POS=[]\n    H = range(Height-h+1)\n    W = range(Width-w+1)\n    for i in H:\n      A1 = DOTS[i]\n      A2 = DOTS[i+h]\n      for j in W:\n        tmp = A1[j] - A2[j] - A1[j+w] + A2[j+w]\n        if tmp>=s and tmp_put(Board, P, i, j):\n          Board = get_put(Board, P, i, j, 0)\n          if solve(TRIALS[1:], Board): return 1\n          Board = get_put(Board, P, i, j, 1)\n  return 0\n\ndef CheckPieceType(i):\n  def f(x1, x2):\n    for j in range(len(PIECE[i, x1])):\n      if \"\".join(PIECE[i, x1][j])!=\"\".join(PIECE[i, x2][j]): return 0\n    return 1\n  flg = [0,1,2,3]\n  for a, b in [[0,1], [1,3], [0,2]]:\n    if f(a, b): flg[b] = flg[a]\n  return list(set(flg))\n\nwhile 1:\n  Height, Width = map(int,raw_input().split())\n  if Height*Width==0: break\n  try: Board = [list(raw_input()) for _ in [0]*Height]\n  except: break\n  DOTS = count_board(Board)\n  PIECE = {}\n  n = input()\n  B = [0] * n\n  C = [[0, 0, 0, 0] for _ in [0] * n]\n  for i in range(n):\n    height, width = map(int, raw_input().split())\n    tmp = [list(raw_input()) for _ in [0] * height]\n    B[i] = sum([e.count('#') for e in tmp])\n    for direction in [0, 1, 2, 3]:\n      PIECE[(i, direction)] = tmp\n      tmp = rot90(tmp)\n    C[i] = CheckPieceType(i)\n  for _ in [0]*input():\n    a = map(int, raw_input().split())[1:]\n    a = sorted([[B[e-1], e-1] for e in a], key = lambda x:{-x[0]})\n    TRIALS = list(zip(*a)[1])\n    if check_sum(TRIALS): print \"NO\"\n    else: print [\"NO\", \"YES\"][solve(TRIALS, copy.deepcopy(Board))]", "sampled": "import sys\nfrom copy import deepcopy\n\ndef read_input():\n    datasets = []\n    while True:\n        line = sys.stdin.readline()\n        if not line:\n            break\n        parts = line.strip().split()\n        if len(parts) == 2:\n            H, W = int(parts[0]), int(parts[1])\n            if H == 0 and W == 0:\n                break\n            \n            # Read puzzle grid\n            grid = []\n            for _ in range(H):\n                grid.append(sys.stdin.readline().strip())\n            \n            # Read number of pieces\n            n = int(sys.stdin.readline().strip())\n            \n            # Read pieces\n            pieces = []\n            for _ in range(n):\n                h = int(sys.stdin.readline().strip())\n                w = int(sys.stdin.readline().strip())\n                piece = []\n                for _ in range(h):\n                    piece.append(sys.stdin.readline().strip())\n                pieces.append(piece)\n            \n            # Read players\n            p = int(sys.stdin.readline().strip())\n            players = []\n            for _ in range(p):\n                line = sys.stdin.readline().strip().split()\n                k = int(line[0])\n                selected = [int(line[i+1]) - 1 for i in range(k)]\n                players.append(selected)\n            \n            datasets.append((H, W, grid, pieces, players))\n    \n    return datasets\n\ndef rotate_90(piece):\n    h = len(piece)\n    w = len(piece[0])\n    rotated = []\n    for j in range(w):\n        row = \"\"\n        for i in range(h-1, -1, -1):\n            row += piece[i][j]\n        rotated.append(row)\n    return rotated\n\ndef get_rotations(piece):\n    rotations = [piece]\n    current = piece\n    for _ in range(3):\n        current = rotate_90(current)\n        rotations.append(current)\n    return rotations\n\ndef get_piece_coords(piece):\n    coords = []\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if piece[i][j] == '#':\n                coords.append((i, j))\n    return coords\n\ndef try_place(grid, H, W, piece, start_r, start_c):\n    piece_coords = get_piece_coords(piece)\n    placed = []\n    for dr, dc in piece_coords:\n        r = start_r + dr\n        c = start_c + dc\n        if r < 0 or r >= H or c < 0 or c >= W:\n            return None\n        if grid[r][c] != '.':\n            return None\n        placed.append((r, c))\n    return placed\n\ndef solve(H, W, grid, selected_pieces):\n    # Create a mutable grid\n    target = []\n    for i in range(H):\n        row = list(grid[i])\n        target.append(row)\n    \n    # Get all rotations for each piece\n    all_rotations = []\n    for piece in selected_pieces:\n        all_rotations.append(get_rotations(piece))\n    \n    def backtrack(piece_idx):\n        if piece_idx == len(selected_pieces):\n            # Check if all '.' are filled\n            for i in range(H):\n                for j in range(W):\n                    if target[i][j] == '.':\n                        return False\n            return True\n        \n        piece_rotations = all_rotations[piece_idx]\n        \n        for rotation in piece_rotations:\n            # Try all possible positions\n            for start_r in range(-19, H+20):\n                for start_c in range(-19, W+20):\n                    placed = try_place(target, H, W, rotation, start_r, start_c)\n                    if placed:\n                        # Mark cells\n                        for r, c in placed:\n                            target[r][c] = '#'\n                        \n                        if backtrack(piece_idx + 1):\n                            return True\n                        \n                        # Unmark cells\n                        for r, c in placed:\n                            target[r][c] = '.'\n        \n        return False\n    \n    return backtrack(0)\n\ndef main():\n    datasets = read_input()\n    \n    for H, W, grid, pieces, players in datasets:\n        for selected_indices in players:\n            selected_pieces = [pieces[i] for i in selected_indices]\n            if solve(H, W, grid, selected_pieces):\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from copy import deepcopy def read_input(): datasets = [] while True: line = sys.stdin.readline() if not line: break parts = line.strip().split() if len(parts) == 2: H, W = int(parts[0]),  in range(H): grid.append(sys.stdin.readline().strip()) # Read number of  pieces.append(piece) # Read players p = int(sys.stdin.readline().strip()) players = [] for _ in range(p): line = sys.stdin.readline().strip().split() k =  i  def get_rotations(piece): rotations = [piece] current = piece for _ in range(3): current = rotate_90(current) rotations.append(current) return rotations def get_piece_coords(piece):  range(len(piece[i])): if piece[i][j] == '#': coords.append((i, j)) return coords def try_place(grid, H, W, piece, start_r, start_c): piece_coords = get_piece_coords(piece) placed = []  c = start_c + dc if r <  return None placed.append((r, c)) return placed def solve(H, W, grid, selected_pieces): #  range(H): row = list(grid[i]) target.append(row)  for piece in selected_pieces: all_rotations.append(get_rotations(piece)) def backtrack(piece_idx): if piece_idx == len(selected_pieces): # Check if all '.' are filled for i in range(H): for j in range(W): if target[i][j] == '.': return False return True piece_rotations =  for start_r in range(-19, H+20): for start_c in range(-19, W+20): placed = try_place(target, H, W, rotation, start_r, start_c) if placed:  '#' if backtrack(piece_idx + 1): return True # Unmark cells for r, c in placed: target[r][c] = '.' return False return backtrack(0) def main(): datasets = read_input()   solve(H, W, grid, selected_pieces): print(\"YES\") else: print(\"NO\") if __name__ == \"__main__\": main()"], "perturbed_original": ["import copy def rot90(A): return zip(*A[::-1]) def count_board(Board): X = [[0 for _ in [0]*(Width+1)] for _ in [0]*(Height+1)] for i in range(Height)[::-1]: for j in  return X def  tmp_put(Board, piece, y, x): N = range(len(piece[0])) for i in range(len(piece)): tmp = piece[i] BoardRow =  0 return 1 def get_put(Board,  for i in range(len(piece)): tmp = piece[i] Y  Board def PrintBoard(Board): for e in Board: print \"\".join(e) print return def PrintDots(DOTS): for e in DOTS:  w = len(P[0]) s = B[n] POS=[] H =  DOTS[i] A2 =   j): Board = get_put(Board, P, i, j, 0) if solve(TRIALS[1:], Board): return 1 Board = get_put(Board, P, i, j, 1) return 0 def CheckPieceType(i): def f(x1, x2): for j in range(len(PIECE[i, x1])):  [0,1,2,3] for a, b in [[0,1], [1,3], [0,2]]: if f(a, b): flg[b] = flg[a] return list(set(flg)) while 1: Height, Width = map(int,raw_input().split()) if Height*Width==0: break try: Board = [list(raw_input()) for _ in [0]*Height] except: break DOTS = count_board(Board) PIECE = {} n = input() B   height, width = map(int, raw_input().split()) tmp = [list(raw_input()) for  CheckPieceType(i) for _ in [0]*input(): a = map(int, raw_input().split())[1:] a = sorted([[B[e-1], e-1] for e in a], key =  print [\"NO\", \"YES\"][solve(TRIALS, copy.deepcopy(Board))]"], "original_ll": -1.1150410175323486, "sampled_ll": -0.5357298851013184, "all_perturbed_sampled_ll": [-1.6542421579360962], "all_perturbed_original_ll": [-2.234873056411743], "perturbed_sampled_ll": -1.6542421579360962, "perturbed_original_ll": -2.234873056411743, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint rotate(char pat[8][9]) {\n\tchar buf[8][9];\n\tint x,y;\n\tfor(y=0;y<8;y++) {\n\t\tfor(x=0;x<8;x++) {\n\t\t\tbuf[x][7-y]=pat[y][x];\n\t\t}\n\t}\n\tmemcpy(pat,buf,sizeof(pat));\n}\n\nint main(void) {\n\tchar buf[8][9];\n\tint i;\n\tfor(i=0;i<8;i++)scanf(\"%s\",buf[i]);\n\trotate(buf);\n\tputs(\"90\");\n\tfor(i=0;i<8;i++)printf(\"%s\\n\",buf[i]);\n\trotate(buf);\n\tputs(\"180\");\n\tfor(i=0;i<8;i++)printf(\"%s\\n\",buf[i]);\n\trotate(buf);\n\tputs(\"270\");\n\tfor(i=0;i<8;i++)printf(\"%s\\n\",buf[i]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    char pattern[8][9];\n    int i, j;\n    \n    // Read input\n    for (i = 0; i < 8; i++) {\n        scanf(\"%s\", pattern[i]);\n    }\n    \n    // 90 degrees\n    printf(\"90\\n\");\n    for (i = 0; i < 8; i++) {\n        for (j = 7; j >= 0; j--) {\n            printf(\"%c\", pattern[j][i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    // 180 degrees\n    printf(\"180\\n\");\n    for (i = 7; i >= 0; i--) {\n        for (j = 7; j >= 0; j--) {\n            printf(\"%c\", pattern[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    // 270 degrees\n    printf(\"270\\n\");\n    for (i = 7; i >= 0; i--) {\n        for (j = 0; j < 8; j++) {\n            printf(\"%c\", pattern[j][i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { char pattern[8][9]; int i, j; //  (i = 0; i < 8; i++) { for (j = 7; j >=  degrees printf(\"180\\n\"); for (i = 7; i >= 0; i--) { for  } printf(\"\\n\"); }  0; i--) { for (j = 0; j < 8; j++) { printf(\"%c\", pattern[j][i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include  } int main(void) { char buf[8][9]; int i; for(i=0;i<8;i++)scanf(\"%s\",buf[i]); rotate(buf); puts(\"90\"); for(i=0;i<8;i++)printf(\"%s\\n\",buf[i]); rotate(buf); puts(\"180\"); for(i=0;i<8;i++)printf(\"%s\\n\",buf[i]); rotate(buf); puts(\"270\"); for(i=0;i<8;i++)printf(\"%s\\n\",buf[i]); return 0; }"], "original_ll": -0.7540631294250488, "sampled_ll": -0.34170857071876526, "all_perturbed_sampled_ll": [-1.5151598453521729], "all_perturbed_original_ll": [-0.9114212989807129], "perturbed_sampled_ll": -1.5151598453521729, "perturbed_original_ll": -0.9114212989807129, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tchar[][] pattern = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tline = br.readLine();\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tpattern[i][j] = line.charAt(j);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 3; i++) {\n\t\t\tpattern = rotate(pattern);\n\t\t\tSystem.out.println(i * 90);\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tSystem.out.println(new String(pattern[j]));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic char[][] rotate(char[][] pattern) {\n\t\tchar[][] rotate = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\trotate[j][7 - i] = pattern[i][j];\n\t\t\t}\n\t\t}\n\t\treturn rotate;\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        char[][] pattern = new char[8][8];\n        \n        for (int i = 0; i < 8; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 8; j++) {\n                pattern[i][j] = line.charAt(j);\n            }\n        }\n        \n        // 90 degrees\n        System.out.println(\"90\");\n        char[][] rotated90 = rotate90(pattern);\n        printPattern(rotated90);\n        \n        // 180 degrees\n        System.out.println(\"180\");\n        char[][] rotated180 = rotate90(rotated90);\n        printPattern(rotated180);\n        \n        // 270 degrees\n        System.out.println(\"270\");\n        char[][] rotated270 = rotate90(rotated180);\n        printPattern(rotated270);\n        \n        sc.close();\n    }\n    \n    private static char[][] rotate90(char[][] pattern) {\n        char[][] result = new char[8][8];\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                result[i][j] = pattern[7 - j][i];\n            }\n        }\n        return result;\n    }\n    \n    private static void printPattern(char[][] pattern) {\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                System.out.print(pattern[i][j]);\n            }\n            System.out.println();\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); char[][] pattern = new char[8][8]; for (int i = 0; i < 8; i++) { String line  degrees  char[][] rotated180 = rotate90(rotated90); printPattern(rotated180);  = new char[8][8]; for (int i = 0; i < 8; i++) { for  private static void printPattern(char[][] pattern) { for (int i = 0; i < 8; i++) { for (int j = 0; j < 8; j++) { System.out.print(pattern[i][j]); } System.out.println(); } } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = \"\"; char[][] pattern  8; i++) { line = br.readLine();   * 90); for  String(pattern[j])); } } } static char[][] rotate(char[][] pattern) { char[][] rotate = new char[8][8]; for (int i = 0; i < 8; i++) { for (int j = 0; j  } return rotate; } }"], "original_ll": -0.43604421615600586, "sampled_ll": -0.2759386897087097, "all_perturbed_sampled_ll": [-1.132320523262024], "all_perturbed_original_ll": [-1.7124401330947876], "perturbed_sampled_ll": -1.132320523262024, "perturbed_original_ll": -1.7124401330947876, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "d=[list(raw_input()) for i in range(8)]\np=[d,[],[],[]]\nfor r in range(3):\n\tprint 90*(r+1)\n\tfor j in range(8):\n\t\tp[r+1].append([p[r][i][j] for i in range(7,-1,-1)])\n\t\tprint \"\".join(p[r+1][j])", "sampled": "# Read input\npattern = []\nfor _ in range(8):\n    pattern.append(input())\n\n# 90 degree rotation (clockwise)\nrotated_90 = []\nfor col in range(8):\n    row_str = \"\"\n    for row in range(7, -1, -1):\n        row_str += pattern[row][col]\n    rotated_90.append(row_str)\n\n# 180 degree rotation\nrotated_180 = []\nfor row in range(7, -1, -1):\n    rotated_180.append(pattern[row][::-1])\n\n# 270 degree rotation (clockwise)\nrotated_270 = []\nfor col in range(7, -1, -1):\n    row_str = \"\"\n    for row in range(8):\n        row_str += pattern[row][col]\n    rotated_270.append(row_str)\n\n# Output\nprint(\"90\")\nfor row in rotated_90:\n    print(row)\nprint(\"180\")\nfor row in rotated_180:\n    print(row)\nprint(\"270\")\nfor row in rotated_270:\n    print(row)\n", "perturbed_sampled": ["# Read input pattern = [] for _ in  for col in range(8): row_str = \"\" for row  degree rotation rotated_180 = [] for row in range(7, -1, -1): rotated_180.append(pattern[row][::-1]) # 270 degree rotation (clockwise)  rotated_270.append(row_str) # Output print(\"90\") for row in rotated_90: print(row) print(\"180\") for row in rotated_180: print(row) print(\"270\") for row in rotated_270: print(row)"], "perturbed_original": ["d=[list(raw_input())  90*(r+1) for j in range(8): p[r+1].append([p[r][i][j] for i in range(7,-1,-1)]) print \"\".join(p[r+1][j])"], "original_ll": -1.6898950338363647, "sampled_ll": -0.4012436866760254, "all_perturbed_sampled_ll": [-2.0152859687805176], "all_perturbed_original_ll": [-2.6217310428619385], "perturbed_sampled_ll": -2.0152859687805176, "perturbed_original_ll": -2.6217310428619385, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n\n  int n, sum, in, i;\n\n  sum = 0;\n\n  scanf(\"%d\",&n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\",&in);\n    sum += in;\n  }\n\n  printf(\"%d\\n\",sum/n);\n\n  return 0;\n\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n        int v;\n        scanf(\"%d\", &v);\n        sum += v;\n    }\n    \n    printf(\"%lld\\n\", sum / n);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\",  0; i < n; i++) { int v; scanf(\"%d\", &v); sum += v; } printf(\"%lld\\n\", sum / n); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int n,  i < n; i++){ scanf(\"%d\",&in); sum += in; } printf(\"%d\\n\",sum/n); return 0; }"], "original_ll": -1.1532410383224487, "sampled_ll": -0.5788486003875732, "all_perturbed_sampled_ll": [-1.5509848594665527], "all_perturbed_original_ll": [-2.5130791664123535], "perturbed_sampled_ll": -1.5509848594665527, "perturbed_original_ll": -2.5130791664123535, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\n\n\n \npublic class Main {\n  public static void main(String[] args) {\n    InputReader sc = new InputReader(System.in);\n \n    int n = sc.nextInt();\n    long sum = 0;\n    for(int i = 0; i < n; i++){\n      sum += sc.nextInt();\n    }\n    System.out.println(sum/n);\n\n\n  }\n \n  \n \n  static class InputReader {\n      private InputStream stream;\n      private byte[] buf = new byte[1024];\n      private int curChar;\n      private int numChars;\n      private SpaceCharFilter filter;\n\n      public InputReader(InputStream stream) {\n          this.stream = stream;\n      }\n \n      public int next() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = stream.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n \n      public String nextStr() {\n        int c = next();\n        while(isSpaceChar(c)){c = next();}\n        StringBuffer str = new StringBuffer();\n        do{\n          str.append((char)c);\n          c = next();\n        }while(!isSpaceChar(c));\n        return str.toString();\n      }\n\n      public int nextInt() {\n          int c = next();\n          while (isSpaceChar(c))\n              c = next();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = next();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = next();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public boolean isSpaceChar(int c) {\n          if (filter != null)\n              return filter.isSpaceChar(c);\n          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n \n      public interface SpaceCharFilter {\n          public boolean isSpaceChar(int ch);\n      }\n  }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += sc.nextInt();\n        }\n        System.out.println(sum / n);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new  sum += sc.nextInt(); } System.out.println(sum / n); sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.util.Arrays; import java.util.InputMismatchException; import java.util.LinkedList; public class Main { public static void main(String[] args)  < n; i++){ sum += sc.nextInt(); } System.out.println(sum/n); } static class InputReader { private InputStream stream;  int  stream; } public int next() { if (numChars == -1) throw new InputMismatchException(); if (curChar >= numChars) { curChar =  return -1; } return buf[curChar++]; } public String nextStr() { int c = next(); while(isSpaceChar(c)){c = next();} StringBuffer str = new  (isSpaceChar(c)) c = next(); int sgn = 1; if (c == '-') { sgn = -1; c = next(); } int res = 0; do { if  = next(); } while  { if (filter != null) return filter.isSpaceChar(c); return c == ' ' || c ==  c == -1; } public interface SpaceCharFilter { public boolean isSpaceChar(int ch); } } }"], "original_ll": -0.38447561860084534, "sampled_ll": -0.47175759077072144, "all_perturbed_sampled_ll": [-1.8796361684799194], "all_perturbed_original_ll": [-1.630428671836853], "perturbed_sampled_ll": -1.8796361684799194, "perturbed_original_ll": -1.630428671836853, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def main():\n    n = int(input())\n    a = 0\n    for _ in range(n):\n        a += int(input())\n    ans = a // n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()", "sampled": "n = int(input())\ntotal = 0\nfor _ in range(n):\n    total += int(input())\nprint(total // n)\n", "perturbed_sampled": ["n = int(input()) total = 0 for _ in range(n): total += int(input()) print(total // n)"], "perturbed_original": ["def main(): n  += int(input()) ans = a // n print(ans) if __name__ == \"__main__\": main()"], "original_ll": -0.7381988763809204, "sampled_ll": -1.1758366823196411, "all_perturbed_sampled_ll": [-1.7080930471420288], "all_perturbed_original_ll": [-2.592209815979004], "perturbed_sampled_ll": -1.7080930471420288, "perturbed_original_ll": -2.592209815979004, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n    int n;\n    int h, m;\n    int i;\n    double angle;\n    \n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++){\n        scanf(\"%d:%d\", &h, &m);\n        \n        angle = h * 360 / 12 + 360 / 12 * m / 60.0;\n        angle -= (360 / 60 * m);\n        \n        if (angle > 180){\n            angle -= 360;\n        }\n        \n        if (-30 < angle && angle < 30){\n            printf(\"alert\\n\");\n        }\n        else if (-90 < angle && angle < 90){\n            printf(\"warning\\n\");\n        }\n        else {\n            printf(\"safe\\n\");\n        }\n    }\n    return (0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        int hh, mm;\n        scanf(\"%d:%d\", &hh, &mm);\n        \n        // Calculate angle of minute hand (6 degrees per minute)\n        double minute_angle = mm * 6.0;\n        \n        // Calculate angle of hour hand (30 degrees per hour + 0.5 degrees per minute)\n        double hour_angle = (hh % 12) * 30.0 + mm * 0.5;\n        \n        // Calculate the absolute difference\n        double diff = abs(hour_angle - minute_angle);\n        if (diff > 180.0) {\n            diff = 360.0 - diff;\n        }\n        \n        // Determine the output\n        if (diff >= 0 && diff < 30) {\n            printf(\"alert\\n\");\n        } else if (diff >= 90 && diff <= 180) {\n            printf(\"safe\\n\");\n        } else {\n            printf(\"warning\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int main() { int n; scanf(\"%d\", &n); for (int i = 0; i < n; i++) { int hh, mm; scanf(\"%d:%d\",  per minute) double minute_angle = mm * 6.0; // Calculate angle of hour hand (30 degrees per hour + 0.5 degrees per minute) double hour_angle = (hh % 12) * 30.0 +  { printf(\"alert\\n\"); } else  } else { printf(\"warning\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int n; int h, m; int i; double angle; scanf(\"%d\", &n);  &m);  12 * m / 60.0; angle -= (360 / 60 * m); if (angle > 180){ angle  angle < 90){ printf(\"warning\\n\"); } else { printf(\"safe\\n\"); } } return (0); }"], "original_ll": -0.8103087544441223, "sampled_ll": -0.5629788637161255, "all_perturbed_sampled_ll": [-1.6309646368026733], "all_perturbed_original_ll": [-2.1436197757720947], "perturbed_sampled_ll": -1.6309646368026733, "perturbed_original_ll": -2.1436197757720947, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main{\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        for(int i=0;i<n;i++) {\n           String[] s=sc.next().split(\":\");\n           int a=Integer.parseInt(s[0])*60;\n           int b=Integer.parseInt(s[1]);\n           int d=Math.abs((a+b)/2-b*6);\n           System.out.println(d<30||d>330?\"alert\":d<90||d>270?\"warning\":\"safe\");\n        }\n    }\n}\n", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String time = sc.nextLine();\n            String[] parts = time.split(\":\");\n            int hh = Integer.parseInt(parts[0]);\n            int mm = Integer.parseInt(parts[1]);\n            \n            // Calculate angle of hour hand from 12 o'clock\n            // Hour hand moves 30 degrees per hour and 0.5 degrees per minute\n            double hourAngle = (hh % 12) * 30.0 + mm * 0.5;\n            \n            // Calculate angle of minute hand from 12 o'clock\n            // Minute hand moves 6 degrees per minute\n            double minuteAngle = mm * 6.0;\n            \n            // Calculate the difference\n            double diff = Math.abs(hourAngle - minuteAngle);\n            \n            // The angle should be the smaller one (between 0 and 180)\n            if (diff > 180) {\n                diff = 360 - diff;\n            }\n            \n            if (diff >= 0 && diff < 30) {\n                System.out.println(\"alert\");\n            } else if (diff >= 90 && diff <= 180) {\n                System.out.println(\"safe\");\n            } else {\n                System.out.println(\"warning\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[]  = time.split(\":\"); int hh =  degrees per hour and 0.5 degrees per minute double hourAngle = (hh % 12) * 30.0 + mm * 0.5; // Calculate angle of minute hand from 12 o'clock // Minute hand moves 6 degrees  The angle should be the smaller one (between 0 and 180) if (diff > 180) { diff = 360 - diff; } if (diff >= 0 && diff < 30) {  180) { System.out.println(\"safe\"); } else { System.out.println(\"warning\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main{ public static void  { String[] s=sc.next().split(\":\"); int a=Integer.parseInt(s[0])*60; int b=Integer.parseInt(s[1]); int d=Math.abs((a+b)/2-b*6); System.out.println(d<30||d>330?\"alert\":d<90||d>270?\"warning\":\"safe\"); } } }"], "original_ll": -1.302575707435608, "sampled_ll": -0.5041465163230896, "all_perturbed_sampled_ll": [-2.072124481201172], "all_perturbed_original_ll": [-2.085414409637451], "perturbed_sampled_ll": -2.072124481201172, "perturbed_original_ll": -2.085414409637451, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N = int(input())\nfor i in range(N):\n    h, m = map(int, input().split(\":\"))\n    d = abs(60*h - 11*m)\n    v = min(d, 720 - d)\n    if v < 60:\n        print(\"alert\")\n    elif v < 180:\n        print(\"warning\")\n    else:\n        print(\"safe\")\n\n", "sampled": "n = int(input())\nfor _ in range(n):\n    time = input().strip()\n    hh, mm = map(int, time.split(':'))\n    \n    # Calculate hour hand angle (from 12 o'clock)\n    hour_angle = (hh % 12) * 30 + mm * 0.5\n    \n    # Calculate minute hand angle (from 12 o'clock)\n    minute_angle = mm * 6\n    \n    # Calculate the difference\n    diff = abs(hour_angle - minute_angle)\n    \n    # Take the smaller angle\n    if diff > 180:\n        diff = 360 - diff\n    \n    # Determine the status\n    if 0 <= diff < 30:\n        print(\"alert\")\n    elif 90 <= diff <= 180:\n        print(\"safe\")\n    else:\n        print(\"warning\")\n", "perturbed_sampled": [" angle (from 12 o'clock) hour_angle =  mm * 6 # Calculate the difference diff = abs(hour_angle - minute_angle) # Take the smaller angle if diff > 180: diff = 360 - diff # Determine the status if 0 <= diff < 30: print(\"alert\") elif 90 <= diff <= 180: print(\"safe\") else: print(\"warning\")"], "perturbed_original": ["N = int(input()) for i in range(N): h, m = map(int, input().split(\":\")) d =  v < 60: print(\"alert\") elif v < 180: print(\"warning\") else: print(\"safe\")"], "original_ll": -1.263045310974121, "sampled_ll": -0.7824774384498596, "all_perturbed_sampled_ll": [-1.780480980873108], "all_perturbed_original_ll": [-1.8804007768630981], "perturbed_sampled_ll": -1.780480980873108, "perturbed_original_ll": -1.8804007768630981, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\tint i,j,num[24+1],temp01;\n\tfloat time[24+1],temp02;\n\tfor(i=0;i<24;i++) {\n\t\tscanf(\"%d %f\",&num[i],&time[i]);\n\t}\n\tfor(i=0;i<8-1;i++) {\n\t\tfor(j=i+1;j<8;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=8;i<16-1;i++) {\n\t\tfor(j=i+1;j<16;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=16;i<24-1;i++) {\n\t\tfor(j=i+1;j<24;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<2;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t\ttime[i]=100.00;\n\t}\n\tfor(i=8;i<10;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t\ttime[i]=100.00;\n\t}\n\tfor(i=16;i<18;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t\ttime[i]=100.00;\n\t}\n\tfor(i=0;i<24-1;i++) {\n\t\tfor(j=i+1;j<24;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<2;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int player;\n    double time;\n} Record;\n\nint compare(const void *a, const void *b) {\n    Record *r1 = (Record *)a;\n    Record *r2 = (Record *)b;\n    if (r1->time < r2->time) return -1;\n    if (r1->time > r2->time) return 1;\n    return 0;\n}\n\nint main() {\n    Record groups[3][8];\n    Record qualifiers[8];\n    Record others[18];\n    int others_count = 0;\n    \n    // Read input\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 8; j++) {\n            scanf(\"%d %lf\", &groups[i][j].player, &groups[i][j].time);\n        }\n    }\n    \n    // Sort each group by time\n    for (int i = 0; i < 3; i++) {\n        qsort(groups[i], 8, sizeof(Record), compare);\n    }\n    \n    // First 2 from each group\n    qualifiers[0] = groups[0][0];\n    qualifiers[1] = groups[0][1];\n    qualifiers[2] = groups[1][0];\n    qualifiers[3] = groups[1][1];\n    qualifiers[4] = groups[2][0];\n    qualifiers[5] = groups[2][1];\n    \n    // Collect 3rd place and below from all groups\n    for (int i = 0; i < 3; i++) {\n        for (int j = 2; j < 8; j++) {\n            others[others_count++] = groups[i][j];\n        }\n    }\n    \n    // Sort others by time\n    qsort(others, others_count, sizeof(Record), compare);\n    \n    // Top 2 from others\n    qualifiers[6] = others[0];\n    qualifiers[7] = others[1];\n    \n    // Output\n    for (int i = 0; i < 8; i++) {\n        printf(\"%d %.2f\\n\", qualifiers[i].player, qualifiers[i].time);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int player; double time; } Record;  (r1->time < r2->time) return -1; if (r1->time > r2->time) return 1; return 0; } int main() { Record groups[3][8]; Record qualifiers[8]; Record others[18]; int others_count = 0;  < 8; j++) { scanf(\"%d %lf\", &groups[i][j].player, &groups[i][j].time);  i = 0; i < 3; i++) { qsort(groups[i], 8, sizeof(Record), compare); } // First 2 from each group qualifiers[0] = groups[0][0];  =  } // Sort others by time qsort(others, others_count, sizeof(Record), compare); // Top 2 from others qualifiers[6] = others[0]; qualifiers[7] = others[1]; // Output for (int i = 0; i < 8; i++) { printf(\"%d %.2f\\n\", qualifiers[i].player, qualifiers[i].time); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int i,j,num[24+1],temp01; float time[24+1],temp02;  { temp01=num[i]; num[i]=num[j]; num[j]=temp01; temp02=time[i]; time[i]=time[j]; time[j]=temp02; } } } for(i=8;i<16-1;i++) { for(j=i+1;j<16;j++)  num[i]=num[j]; num[j]=temp01; temp02=time[i]; time[i]=time[j]; time[j]=temp02; } } } for(i=0;i<2;i++) { printf(\"%d %f\\n\",num[i],time[i]); time[i]=100.00; } for(i=8;i<10;i++) { printf(\"%d %f\\n\",num[i],time[i]); time[i]=100.00; } for(i=16;i<18;i++) { printf(\"%d %f\\n\",num[i],time[i]); time[i]=100.00; } for(i=0;i<24-1;i++)  time[j]=temp02; } } } for(i=0;i<2;i++) { printf(\"%d %f\\n\",num[i],time[i]); } return 0; }"], "original_ll": -0.36738166213035583, "sampled_ll": -0.4540741741657257, "all_perturbed_sampled_ll": [-1.3003196716308594], "all_perturbed_original_ll": [-0.9614807963371277], "perturbed_sampled_ll": -1.3003196716308594, "perturbed_original_ll": -0.9614807963371277, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\nclass Player implements Comparable<Player>{\n\tint party;\n\tint num;\n\tString time;\n\tPlayer(int p,int n,String t){\n\t\tthis.party = p;\n\t\tthis.num = n;\n\t\tthis.time = t;\n\t}\n\t/*@Override\n\tpublic int compareTo(Player p) {\n\t\treturn this.time.compareTo(p.num);\n\t}\n\t*/\n\t@Override\n\tpublic int compareTo(Player o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn this.time.compareTo(o.time);\n\t}\n\t\n}\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tPlayer[] person = new Player[24];\n\t\tint[][] rank = new int[3][8];\n\t\tint[] cnt = new int[3]; \n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tint cnt3 = 0;\n\t\tfor(int i = 0;i < 3;i++){\n\t\t\tfor(int j = 0;j < 8;j++){\n\t\t\t\tperson[i*8+j] = new Player(i,sc.nextInt(),sc.next());\n\t\t\t}\n\t\t}\n\t\tArrays.sort(person);\n\t\tfor(int i = 0;i < 24;i++){\n\t\t\trank[person[i].party][cnt[person[i].party]] = i;\n\t\t\tcnt[person[i].party]++;\n\t\t}\n\t\tfor(int i = 0;i < 3;i++){\n\t\t\tfor(int j = 0;j < 2;j++){\n\t\t\t\tSystem.out.println(person[rank[i][j]].num+\" \"+person[rank[i][j]].time);\n\t\t\t\tperson[rank[i][j]].time = \"999\";\n\t\t\t}\n\t\t}\n\t\tArrays.sort(person);\n\t\tfor(int j = 0;j < 2;j++){\n\t\t\tSystem.out.println(person[j].num+\" \"+person[j].time);\n\t\t}\n\t\t\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Athlete implements Comparable<Athlete> {\n        int number;\n        double time;\n        \n        Athlete(int number, double time) {\n            this.number = number;\n            this.time = time;\n        }\n        \n        @Override\n        public int compareTo(Athlete other) {\n            return Double.compare(this.time, other.time);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        List<Athlete>[] groups = new List[3];\n        for (int i = 0; i < 3; i++) {\n            groups[i] = new ArrayList<>();\n        }\n        \n        // Read input\n        for (int i = 0; i < 24; i++) {\n            int number = sc.nextInt();\n            double time = sc.nextDouble();\n            int group = i / 8;\n            groups[group].add(new Athlete(number, time));\n        }\n        \n        // Sort each group by time\n        for (int i = 0; i < 3; i++) {\n            Collections.sort(groups[i]);\n        }\n        \n        // Output top 2 from each group\n        List<Athlete> finalists = new ArrayList<>();\n        for (int i = 0; i < 3; i++) {\n            finalists.add(groups[i].get(0));\n            finalists.add(groups[i].get(1));\n        }\n        \n        // Get 3rd place and below from all groups\n        List<Athlete> remaining = new ArrayList<>();\n        for (int i = 0; i < 3; i++) {\n            for (int j = 2; j < groups[i].size(); j++) {\n                remaining.add(groups[i].get(j));\n            }\n        }\n        \n        // Sort remaining athletes and get top 2\n        Collections.sort(remaining);\n        finalists.add(remaining.get(0));\n        finalists.add(remaining.get(1));\n        \n        // Output all finalists\n        for (Athlete a : finalists) {\n            System.out.println(a.number + \" \" + a.time);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  time;  time; } @Override public int compareTo(Athlete other) { return Double.compare(this.time, other.time); } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); List<Athlete>[] groups = new List[3]; for (int i  ArrayList<>(); } // Read  { int number = sc.nextInt(); double time = sc.nextDouble(); int group = i / 8; groups[group].add(new Athlete(number, time)); } // Sort  < 3; i++)  List<Athlete> finalists = new ArrayList<>(); for (int i = 0; i < 3; i++) { finalists.add(groups[i].get(0)); finalists.add(groups[i].get(1));  List<Athlete> remaining = new ArrayList<>(); for (int i = 0; i < 3; i++)  finalists for (Athlete a : finalists) { System.out.println(a.number + \" \" + a.time); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; class Player implements Comparable<Player>{ int party; int num; String time; Player(int p,int n,String t){ this.party = p; this.num = n; this.time = t; } /*@Override public int compareTo(Player p) { return this.time.compareTo(p.num); } */ @Override public int compareTo(Player o) { // TODO Auto-generated method stub return this.time.compareTo(o.time); } }  cnt3 = 0; for(int  i = 0;i < 24;i++){ rank[person[i].party][cnt[person[i].party]] = i; cnt[person[i].party]++; } for(int i =  \"+person[rank[i][j]].time); person[rank[i][j]].time = \"999\"; } } Arrays.sort(person); for(int j = 0;j < 2;j++){ System.out.println(person[j].num+\" \"+person[j].time); } } }"], "original_ll": -0.6950618028640747, "sampled_ll": -0.41957589983940125, "all_perturbed_sampled_ll": [-1.524102807044983], "all_perturbed_original_ll": [-1.5520812273025513], "perturbed_sampled_ll": -1.524102807044983, "perturbed_original_ll": -1.5520812273025513, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "l1,l2,l3=[],[],[]\nfinal=[]\ncount=0\nfor i in range(24):\n    p,t=map(float,input().split())\n    if count<=7:l1.append([t,p])\n    elif 7<count<=15:l2.append([t,p])\n    elif 15<count<=23:l3.append([t,p])\n    count +=1\nl1=sorted(l1)\nl2=sorted(l2)\nl3=sorted(l3)\nfinal +=[l1[0],l1[1],l2[0],l2[1],l3[0],l3[1]]\ndel l1[0],l1[0],l2[0],l2[0],l3[0],l3[0]\nthird=sorted(l1+l2+l3)\nfinal +=[third[0],third[1]]\nfor i in range(8):print(int(final[i][1]),final[i][0])\n", "sampled": "# Read all 24 runners\nrunners = []\nfor i in range(24):\n    line = input().split()\n    p = int(line[0])\n    t = float(line[1])\n    runners.append((p, t))\n\n# Split into 3 groups\ngroup1 = runners[0:8]\ngroup2 = runners[8:16]\ngroup3 = runners[16:24]\n\n# Sort each group by time\ngroup1.sort(key=lambda x: x[1])\ngroup2.sort(key=lambda x: x[1])\ngroup3.sort(key=lambda x: x[1])\n\n# Top 2 from each group\nqualifiers = []\nqualifiers.append(group1[0])\nqualifiers.append(group1[1])\nqualifiers.append(group2[0])\nqualifiers.append(group2[1])\nqualifiers.append(group3[0])\nqualifiers.append(group3[1])\n\n# Collect 3rd place and below from all groups\nremaining = []\nremaining.extend(group1[2:])\nremaining.extend(group2[2:])\nremaining.extend(group3[2:])\n\n# Sort remaining by time and take top 2\nremaining.sort(key=lambda x: x[1])\nqualifiers.append(remaining[0])\nqualifiers.append(remaining[1])\n\n# Output\nfor p, t in qualifiers:\n    print(f\"{p} {t:.2f}\")\n", "perturbed_sampled": ["# Read all 24 runners runners = [] for i in range(24): line = input().split() p = int(line[0]) t = float(line[1]) runners.append((p,  by time group1.sort(key=lambda x: x[1]) group2.sort(key=lambda x: x[1]) group3.sort(key=lambda x: x[1]) # Top 2  Sort remaining by time and take top 2 remaining.sort(key=lambda x: x[1]) qualifiers.append(remaining[0]) qualifiers.append(remaining[1]) # Output for p, t in qualifiers: print(f\"{p} {t:.2f}\")"], "perturbed_original": ["l1,l2,l3=[],[],[] final=[] count=0 for  count +=1 l1=sorted(l1) l2=sorted(l2) l3=sorted(l3) final +=[l1[0],l1[1],l2[0],l2[1],l3[0],l3[1]] del l1[0],l1[0],l2[0],l2[0],l3[0],l3[0] third=sorted(l1+l2+l3) final +=[third[0],third[1]] for i in range(8):print(int(final[i][1]),final[i][0])"], "original_ll": -0.9173847436904907, "sampled_ll": -0.6935495734214783, "all_perturbed_sampled_ll": [-1.9131523370742798], "all_perturbed_original_ll": [-1.2048213481903076], "perturbed_sampled_ll": -1.9131523370742798, "perturbed_original_ll": -1.2048213481903076, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n  char w[201];\n  int a,i,j,k;\n  scanf(\"%d\",&a);\n  for(j=0;j<a;j++){\n    scanf(\"%s\",w);\n    if(w[0]!='>'){printf(\"NA\\n\");continue;}\n    if(w[1]=='\\''){\n      for(i=2;w[i]!='#';i++){\n\tif(w[i]!='='){printf(\"NA\\n\");continue;}\n      }\n      int t=i-1;\n      for(k=t;t>0;t--){\n\tif(w[i++]!='='){printf(\"NA\\n\");continue;}\n      }\n      if(w[i++]!='~'){printf(\"NA\\n\");continue;}\n      if(w[i]!='\\0'){printf(\"NA\\n\");continue;}\n      printf(\"A\\n\");\n    }\n    if(w[1]=='^'){\n      for(i=2;w[i]=='~';i+=2){\n\tif(w[i]!='Q'){printf(\"NA\\n\");continue;}\n\tif(w[i+1]!='='){printf(\"NA\\n\");continue;}\n      }\n      if(w[i]!='~'){printf(\"NA\\n\");continue;}\n      if(w[i+1]!='~'){printf(\"NA\\n\");continue;}\n      if(w[i+2]!='\\0'){printf(\"NA\\n\");continue;}\n      printf(\"B\\n\");\n    }\n  }\nreturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint checkA(char *s) {\n    int len = strlen(s);\n    if (len < 6) return 0;\n    if (s[0] != '>' || s[1] != '\\'') return 0;\n    if (s[len-1] != '~') return 0;\n    \n    int i = 2;\n    int count1 = 0;\n    while (i < len && s[i] == '=') {\n        count1++;\n        i++;\n    }\n    \n    if (count1 == 0) return 0;\n    if (i >= len || s[i] != '#') return 0;\n    i++;\n    \n    int count2 = 0;\n    while (i < len && s[i] == '=') {\n        count2++;\n        i++;\n    }\n    \n    if (count2 != count1) return 0;\n    if (i != len - 1) return 0;\n    if (s[i] != '~') return 0;\n    \n    return 1;\n}\n\nint checkB(char *s) {\n    int len = strlen(s);\n    if (len < 6) return 0;\n    if (s[0] != '>' || s[1] != '^') return 0;\n    if (len < 2 || s[len-1] != '~' || s[len-2] != '~') return 0;\n    \n    int i = 2;\n    int count = 0;\n    while (i < len - 2) {\n        if (s[i] == 'Q' && i + 1 < len - 2 && s[i+1] == '=') {\n            count++;\n            i += 2;\n        } else {\n            return 0;\n        }\n    }\n    \n    if (count == 0) return 0;\n    if (i != len - 2) return 0;\n    \n    return 1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        char s[201];\n        scanf(\"%s\", s);\n        \n        if (checkA(s)) {\n            printf(\"A\\n\");\n        } else if (checkB(s)) {\n            printf(\"B\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int checkA(char *s) { int len = strlen(s); if (len < 6) return  = 2; int count1 = 0; while  } if (count1 == 0) return 0; if (i >= len  0;  i++; } if (count2 != count1) return 0; if  '~') return  = strlen(s); if (len < 6) return 0; if (s[0] != '>' || s[1] !=  '~' || s[len-2] != '~') return 0; int  len -  < len - 2 && s[i+1] == '=') { count++; i  (count == 0) return 0; if (i != len - 2) return 0; return 1; } int main() { int n; scanf(\"%d\",  { char s[201]; scanf(\"%s\", s); if (checkA(s)) { printf(\"A\\n\"); } else if (checkB(s)) { printf(\"B\\n\"); } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ char }<extra_id_2>i=k;k =i;k=w.length;for(i=0;i<k;i++){printf(\"NA\\n\");for(k--;k--){ if(w[k]=='Q'){printf(\"NA\\n\");continue;}<extra_id_3>if(q==-2){if(k!='A'){printf(\"NA\\n\");continue; } int t=i-1; for(k=t;t>0;t--){ if(w[i++]!='='){printf(\"NA\\n\");continue;} } if(w[i++]!='~'){printf(\"NA\\n\");continue;} if(w[i]!='\\0'){printf(\"NA\\n\");continue;} printf(\"A\\n\"); } if(w[1]=='^'){ for(i=2;w[i]=='~';i+=2){ if(w[i]!='Q'){printf(\"NA\\n\");continue;} if(w[i+1]!='='){printf(\"NA\\n\");continue;} } if(w[i]!='~'){printf(\"NA\\n\");continue;} if(w[i+1]!='~'){printf(\"NA\\n\");continue;} if(w[i+2]!='\\0'){printf(\"NA\\n\");continue;} printf(\"B\\n\"); } } return 0; }"], "original_ll": -0.9893012642860413, "sampled_ll": -0.4636233448982239, "all_perturbed_sampled_ll": [-1.615818738937378], "all_perturbed_original_ll": [-1.8108142614364624], "perturbed_sampled_ll": -1.615818738937378, "perturbed_original_ll": -1.8108142614364624, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<String> Ans = new ArrayList<String>();\n\t\tString line = in.readLine();\n\t\t\n\t\tint size = Integer.parseInt(line);\n\t\tfor(int n=0; n<size; n++){\n\t\t\tline = in.readLine();\n\t\t\tint type = 0;\n\t\t\t\n\t\t\tString c = line.substring(0, 2);\n\t\t\tif(c.equals(\">'\")){\n\t\t\t\tint count = 0;\n\t\t\t\tint sharp = 0;\n\t\t\t\tfor(int i=2; i<line.length(); i++){\n\t\t\t\t\tc = line.substring(i, i+1);\n\t\t\t\t\tif(c.equals(\"=\")){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(c.equals(\"#\")){\n\t\t\t\t\t\tif(count > 0){\n\t\t\t\t\t\t\tcount = -count;\n\t\t\t\t\t\t\tsharp = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(c.equals(\"~\")){\n\t\t\t\t\t\tif(i != line.length()-1){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(count==0 && sharp==1){\n\t\t\t\t\t\t\ttype = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(c.equals(\">^\")){\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i=2; i<line.length(); i++){\n\t\t\t\t\tc = line.substring(i, i+1);\n\t\t\t\t\tif(count%2==0 && count>=2 && c.equals(\"~\")){\n\t\t\t\t\t\tif(i==line.length()-1){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tc = line.substring(i+1, i+2);\n\t\t\t\t\t\tif(c.equals(\"~\")){\n\t\t\t\t\t\t\ttype = 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2==0){\n\t\t\t\t\t\tif(!c.equals(\"Q\")){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2==1){\n\t\t\t\t\t\tif(!c.equals(\"=\")){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!c.equals(\"Q\") && !c.equals(\"=\") && !c.equals(\"~\")){\n\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttype = -1;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(type){\n\t\t\t\tcase 1:\n\t\t\t\t\tAns.add(\"A\");\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 2:\n\t\t\t\t\tAns.add(\"B\");\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tAns.add(\"NA\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tSystem.out.println(Ans.get(n));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String s = sc.nextLine();\n            System.out.println(classify(s));\n        }\n        sc.close();\n    }\n    \n    static String classify(String s) {\n        if (isTypeA(s)) {\n            return \"A\";\n        } else if (isTypeB(s)) {\n            return \"B\";\n        } else {\n            return \"NA\";\n        }\n    }\n    \n    static boolean isTypeA(String s) {\n        // Pattern: >'=+#=+~\n        // Must start with >'\n        if (!s.startsWith(\">'\")) {\n            return false;\n        }\n        \n        // Must end with ~\n        if (!s.endsWith(\"~\")) {\n            return false;\n        }\n        \n        // Find # position\n        int hashPos = s.indexOf('#');\n        if (hashPos == -1) {\n            return false;\n        }\n        \n        // Check if there's only one #\n        if (s.indexOf('#', hashPos + 1) != -1) {\n            return false;\n        }\n        \n        // Extract parts\n        String beforeHash = s.substring(2, hashPos);\n        String afterHash = s.substring(hashPos + 1, s.length() - 1);\n        \n        // Both parts must be non-empty and consist only of '='\n        if (beforeHash.length() == 0 || afterHash.length() == 0) {\n            return false;\n        }\n        \n        // Both parts must have same length and only contain '='\n        if (beforeHash.length() != afterHash.length()) {\n            return false;\n        }\n        \n        for (char c : beforeHash.toCharArray()) {\n            if (c != '=') {\n                return false;\n            }\n        }\n        \n        for (char c : afterHash.toCharArray()) {\n            if (c != '=') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    static boolean isTypeB(String s) {\n        // Pattern: >^(Q=)+~~\n        // Must start with >^\n        if (!s.startsWith(\">^\")) {\n            return false;\n        }\n        \n        // Must end with ~~\n        if (!s.endsWith(\"~~\")) {\n            return false;\n        }\n        \n        // Extract middle part\n        String middle = s.substring(2, s.length() - 2);\n        \n        // Middle must be non-empty\n        if (middle.length() == 0) {\n            return false;\n        }\n        \n        // Middle must be repetitions of \"Q=\"\n        if (middle.length() % 2 != 0) {\n            return false;\n        }\n        \n        for (int i = 0; i < middle.length(); i += 2) {\n            if (middle.charAt(i) != 'Q' || middle.charAt(i + 1) != '=') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": [" args) { Scanner  (int i = 0; i  sc.close(); }  } else if (isTypeB(s)) {  boolean isTypeA(String s) { // Pattern: >'=+#=+~ // Must start with >' if (!s.startsWith(\">'\")) { return false; } // Must end  # position int hashPos = s.indexOf('#'); if (hashPos ==  = s.substring(2, hashPos); String afterHash = s.substring(hashPos + 1, s.length() - 1); // Both parts must be non-empty and consist only of '=' if (beforeHash.length() == 0 || afterHash.length() ==  same length and only contain '=' if (beforeHash.length() != afterHash.length()) { return false; } for (char c : beforeHash.toCharArray()) { if (c != '=')  { if (c != '=') { return false; } } return true; } static boolean isTypeB(String s) { // Pattern: >^(Q=)+~~ // Must start with >^ if (!s.startsWith(\">^\")) { return false; } // Must end with   must be non-empty if (middle.length() == 0) { return false; } // Middle must be repetitions of \"Q=\" if  1) != '=') { return false; } } return true; } }"], "perturbed_original": [" } public Main() throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); List<String>  = Integer.parseInt(line); for(int n=0; n<size; n++){ line = in.readLine(); int type = 0; String c = line.substring(0, 2); if(c.equals(\">'\")){ int count = 0; int sharp = 0; for(int i=2; i<line.length(); i++){ c = line.substring(i, i+1); if(c.equals(\"=\")){ count++; } else if(c.equals(\"#\")){ if(count > 0){ count = -count; sharp = 1; } else{ type = -1;  -1; break; } if(count==0  -1; break; } } else{ type = -1; break; } } } else  = line.substring(i, i+1); if(count%2==0 && count>=2 && c.equals(\"~\")){ if(i==line.length()-1){ type =  } if(i%2==0){ if(!c.equals(\"Q\")){ type =  break; } count++; } if(!c.equals(\"Q\") && !c.equals(\"=\") &&  = -1; } switch(type){  } } for(int n=0; n<Ans.size(); n++){ System.out.println(Ans.get(n)); } } }"], "original_ll": -0.6221852898597717, "sampled_ll": -0.567301869392395, "all_perturbed_sampled_ll": [-2.0265915393829346], "all_perturbed_original_ll": [-1.6377878189086914], "perturbed_sampled_ll": -2.0265915393829346, "perturbed_original_ll": -1.6377878189086914, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nN = int(input())\n\ndef is_A(s):\n    if s[0:2] != \">'\":\n        return False\n\n    if s[-1] != '~':\n        return False\n\n    body = s[2:-1]\n\n    if len(body) % 2 == 0:\n        return False\n\n    # body = '==#=='\n    center_index = len(body) // 2\n    if body[center_index] != '#':\n        return False\n\n    if body.count('#') != 1:\n        return False\n\n    lst = body.split('#')\n    if len(lst) != 2:\n        return False\n\n    if len(lst[0]) > 0 and lst[0] == lst[1] and len(lst[0]) == lst[0].count('='):\n        return True\n    else:\n        return False\n\ndef is_B(s):\n    if s[0:2] != \">^\":\n        return False\n\n    if s[-2:] != '~~':\n        return False\n\n    body = s[2:-2]\n\n    if len(body) % 2 != 0:\n        return False\n    elif body.count('Q=') > 0 and body.count('Q=') == len(body) // 2:\n        return True\n    else:\n        return False\n\nfor s in sys.stdin:\n    s = s.strip()\n\n    if is_A(s):\n        print('A')\n    elif is_B(s):\n        print('B')\n    else:\n        print('NA')", "sampled": "import re\n\nn = int(input())\nfor _ in range(n):\n    s = input().strip()\n    \n    # Check for Type A: >'=+#=+~\n    match_a = re.match(r\"^>\\'(=+)#\\1~$\", s)\n    if match_a:\n        print(\"A\")\n        continue\n    \n    # Check for Type B: >^(Q=)+~~\n    match_b = re.match(r\"^>\\^(Q=)+~~$\", s)\n    if match_b:\n        print(\"B\")\n        continue\n    \n    print(\"NA\")\n", "perturbed_sampled": ["import re n =   print(\"A\") continue # Check for Type B: >^(Q=)+~~ match_b = re.match(r\"^>\\^(Q=)+~~$\", s) if match_b: print(\"B\") continue print(\"NA\")"], "perturbed_original": ["# -*- coding: utf-8 -*-  s[0:2]  body = s[2:-1] if len(body) %   if body.count('#') != 1: return False lst = body.split('#') if len(lst) != 2: return False if len(lst[0]) > 0 and lst[0] == lst[1] and len(lst[0]) == lst[0].count('='): return True else: return False def is_B(s): if s[0:2] != \">^\": return False if s[-2:] != '~~':  0: return False elif body.count('Q=') > 0 and body.count('Q=') == len(body) // 2: return True else:  is_A(s): print('A') elif is_B(s): print('B') else: print('NA')"], "original_ll": -0.9821922779083252, "sampled_ll": -1.7302114963531494, "all_perturbed_sampled_ll": [-4.296154975891113], "all_perturbed_original_ll": [-1.9301151037216187], "perturbed_sampled_ll": -4.296154975891113, "perturbed_original_ll": -1.9301151037216187, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(){\n\tchar tei[15]={0,1,2,3,4,5,6,7,8,9,5,4,3,2,1},ans[1000][20];\n\tint n,i,to,from,j;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tif(from<to){\n\t\t\t\tfor(j=from;j<to;j++){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",to);\n\t\t}else if(to==5){\n\t\t\tfor(j=from;j<=9;j++){\n\t\t\t\tprintf(\"%d \",j);\n\t\t\t}\n\t\t\tputs(\"5\");\n\t\t}else if(from>to){\n\t\t\tif(from>=6&&from<=9){\n\t\t\t\tfor(j=from;j<=9;j++){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tfor(j=5;j>to;j--){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",to);\n\t\t\t}else{\n\t\t\t\tfor(j=from;j>to;j--){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int start, end;\n        scanf(\"%d %d\", &start, &end);\n        \n        // Calculate distances for different routes\n        int dist_forward = 0;\n        int dist_backward = 0;\n        \n        // Going forward (clockwise direction)\n        if (start <= 5 && end <= 5) {\n            if (end > start) {\n                dist_forward = end - start;\n            } else {\n                // Need to go through the loop\n                dist_forward = (5 - start) + 1 + (9 - 5) + 1 + (5 - end);\n            }\n        } else if (start <= 5 && end > 5) {\n            // From main line to loop\n            if (start <= 5) {\n                dist_forward = (5 - start) + (end - 5);\n            }\n        } else if (start > 5 && end <= 5) {\n            // From loop to main line\n            if (end <= 5) {\n                if (start == 9) dist_forward = 1 + end;\n                else if (start == 8) dist_forward = 2 + end;\n                else if (start == 7) dist_forward = 3 + end;\n                else if (start == 6) dist_forward = 4 + end;\n            }\n        } else {\n            // Both in loop\n            if (end > start) {\n                dist_forward = end - start;\n            } else {\n                dist_forward = (9 - start) + 1 + (end - 5);\n            }\n        }\n        \n        // Going backward (counter-clockwise)\n        if (start <= 5 && end <= 5) {\n            if (end < start) {\n                dist_backward = start - end;\n            } else {\n                // Need to go through the loop\n                dist_backward = start + 1 + (9 - 5) + 1 + (5 - end);\n            }\n        } else if (start <= 5 && end > 5) {\n            // From main line to loop through 0\n            dist_backward = start + 1 + (9 - end) + 1;\n        } else if (start > 5 && end <= 5) {\n            // From loop to main line\n            if (start == 6) dist_backward = 1 + (5 - end);\n            else if (start == 7) dist_backward = 2 + (5 - end);\n            else if (start == 8) dist_backward = 3 + (5 - end);\n            else if (start == 9) dist_backward = 4 + (5 - end);\n        } else {\n            // Both in loop\n            if (end < start) {\n                dist_backward = start - end;\n            } else {\n                dist_backward = (start - 5) + 1 + (9 - end) + 1;\n            }\n        }\n        \n        // Choose the shorter route\n        int go_forward = (dist_forward <= dist_backward);\n        \n        int pos = start;\n        printf(\"%d\", pos);\n        \n        while (pos != end) {\n            if (go_forward) {\n                if (pos < 5) {\n                    pos++;\n                } else if (pos == 5) {\n                    if (end > 5 || end == 0) {\n                        pos = 6;\n                    } else {\n                        pos--;\n                    }\n                } else if (pos >= 6 && pos <= 8) {\n                    pos++;\n                } else if (pos == 9) {\n                    pos = 5;\n                }\n            } else {\n                if (pos > 0 && pos <= 5) {\n                    pos--;\n                } else if (pos == 6) {\n                    pos = 5;\n                } else if (pos >= 7 && pos <= 9) {\n                    pos--;\n                } else if (pos == 0) {\n                    pos = 1;\n                }\n            }\n            printf(\" %d\", pos);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() {  scanf(\"%d %d\", &start, &end); // Calculate distances for different routes int dist_forward = 0; int dist_backward = 0; // Going forward (clockwise direction) if (start  start) { dist_forward = end -  loop dist_forward =  1 + (5  loop if (start <= 5) { dist_forward = (5 - start) + (end  end <= 5) { //  end; else if (start == 7) dist_forward  = 4 + end; } }  { dist_forward = end - start; } else { dist_forward = (9 - start) + 1 + (end - 5); }  end <= 5) { if (end < start) { dist_backward = start - end; } else { // Need to go through the loop dist_backward = start + 1 + (9 - 5) + 1 + (5 - end); } } else if (start <= 5 && end > 5) {  start + 1 + (9 - end) + 1; } else if (start > 5 && end <= 5) {  { // Both in loop if (end < start) { dist_backward = start - end; } else { dist_backward = (start - 5) + 1 + (9 - end) + 1; } } //  int pos = start; printf(\"%d\", pos); while (pos != end)  } else if (pos == 5) { if (end  else if (pos == 9) { pos =  pos <= 5) { pos--; } else if (pos == 6) { pos = 5; } else if (pos >= 7 && pos <= 9) { pos--; } else if (pos == 0) { pos = 1; } } printf(\" %d\", pos); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ char tei[15]={0,1,2,3,4,5,6,7,8,9,5,4,3,2,1},ans[1000][20]; int n,i,to,from,j; scanf(\"%d\",&n); for(i=0;i<n;i++){  for(j=from;j<=9;j++){ printf(\"%d \",j); }  \",j); } printf(\"%d\\n\",to); }else{ for(j=from;j>to;j--){ printf(\"%d \",j); } printf(\"%d\\n\",to); } } } return 0; }"], "original_ll": -0.8347354531288147, "sampled_ll": -0.5302675366401672, "all_perturbed_sampled_ll": [-1.5500239133834839], "all_perturbed_original_ll": [-1.5483759641647339], "perturbed_sampled_ll": -1.5500239133834839, "perturbed_original_ll": -1.5483759641647339, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nclass Main{\n    public static void main(String[] args){\n\tBufferedReader sc=new BufferedReader(new InputStreamReader(System.in));\n\ttry {\n\t    int n = Integer.valueOf(sc.readLine());\n\t    ArrayList<Integer> road;\n\t    for(int i=0; i<n; i++){\n\t\troad = new ArrayList<Integer>();\n\t\tString[] st = sc.readLine().split(\" \");\n\t\tint in = Integer.valueOf(st[0]), out = Integer.valueOf(st[1]);\n\t\tif(in<=5)\n\t\t    if(in>out)\n\t\t\tfor(int j=in; j>=out; j--)\n\t\t\t    road.add(j);\n\t\t    else\n\t\t\tfor(int j=in; j<=out; j++)\n\t\t\t    road.add(j);\n\t\telse{\n\t\t    if(out>in)\n\t\t\tfor(int j=in; j<=out; j++)\n\t\t\t    road.add(j);\n\t\t    else{\n\t\t\tfor(int j=in; j<=9; j++)\n\t\t\t    road.add(j);\n\t\t\tif(out>=5){\n\t\t\t    for(int j=5; j>=0; j--)\n\t\t\t\troad.add(j);\n\t\t\t    for(int j=1; j<=out; j++)\n\t\t\t\troad.add(j);\n\t\t\t}\n\t\t\telse\n\t\t\t    for(int j=5; j>=out; j--)\n\t\t\t\troad.add(j);\n\t\t    }\n\t\t}\n\t\tfor(int j=0; j<road.size()-1; j++)\n\t\t    System.out.print(road.get(j)+\" \");\n\t\tSystem.out.println(road.get(road.size()-1));\n\t    }\n\t}catch(Exception e){\n\t    System.out.println(\"Error\");\n\t}\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            int start = sc.nextInt();\n            int end = sc.nextInt();\n            \n            List<Integer> path = findPath(start, end);\n            \n            for (int j = 0; j < path.size(); j++) {\n                if (j > 0) System.out.print(\" \");\n                System.out.print(path.get(j));\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n    \n    static List<Integer> findPath(int start, int end) {\n        List<Integer> path = new ArrayList<>();\n        \n        // Calculate distances for both directions\n        int dist1 = distanceClockwise(start, end);\n        int dist2 = distanceCounterClockwise(start, end);\n        \n        if (dist1 <= dist2) {\n            // Go clockwise\n            int current = start;\n            path.add(current);\n            while (current != end) {\n                current = next(current);\n                path.add(current);\n            }\n        } else {\n            // Go counterclockwise\n            int current = start;\n            path.add(current);\n            while (current != end) {\n                current = prev(current);\n                path.add(current);\n            }\n        }\n        \n        return path;\n    }\n    \n    static int distanceClockwise(int start, int end) {\n        int dist = 0;\n        int current = start;\n        while (current != end) {\n            current = next(current);\n            dist++;\n            if (dist > 20) return Integer.MAX_VALUE; // Safety check\n        }\n        return dist;\n    }\n    \n    static int distanceCounterClockwise(int start, int end) {\n        int dist = 0;\n        int current = start;\n        while (current != end) {\n            current = prev(current);\n            dist++;\n            if (dist > 20) return Integer.MAX_VALUE; // Safety check\n        }\n        return dist;\n    }\n    \n    static int next(int pos) {\n        if (pos >= 0 && pos < 5) {\n            return pos + 1;\n        } else if (pos == 5) {\n            return 6;\n        } else if (pos == 6) {\n            return 7;\n        } else if (pos == 7) {\n            return 8;\n        } else if (pos == 8) {\n            return 9;\n        } else if (pos == 9) {\n            return 5;\n        }\n        return -1;\n    }\n    \n    static int prev(int pos) {\n        if (pos >= 1 && pos <= 5) {\n            return pos - 1;\n        } else if (pos == 6) {\n            return 5;\n        } else if (pos == 7) {\n            return 6;\n        } else if (pos == 8) {\n            return 7;\n        } else if (pos == 9) {\n            return 8;\n        } else if (pos == 0) {\n            return -1; // Can't go back from 0\n        }\n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i < n; i++) { int start = sc.nextInt(); int end = sc.nextInt(); List<Integer> path = findPath(start, end); for  (j > 0) System.out.print(\" \"); System.out.print(path.get(j));  end) { List<Integer> path = new ArrayList<>(); // Calculate distances for both directions int dist1 = distanceClockwise(start, end);  // Go clockwise int current = start;  } } else { // Go counterclockwise int current = start; path.add(current); while (current != end) { current = prev(current); path.add(current); } } return  != end) { current = next(current); dist++; if (dist  } static int distanceCounterClockwise(int start, int end) { int dist  return Integer.MAX_VALUE; // Safety check } return dist; } static int next(int pos) { if (pos >= 0 && pos < 5) { return pos + 1; }  if (pos == 6) { return 7; } else if (pos == 7)  (pos == 6) { return 5; } else if (pos == 7) { return 6; } else if  == 0) { return -1; // Can't go back from 0 } return -1; } }"], "perturbed_original": ["import java.io.*; import java.util.*; import java.math.*; class Main{ public static void main(String[] args){ BufferedReader sc=new BufferedReader(new InputStreamReader(System.in)); try { int n = Integer.valueOf(sc.readLine()); ArrayList<Integer> road; for(int i=0; i<n; i++){ road = new  for(int j=in; j<=out; j++)  j>=0;  j=5; j>=out; j--) road.add(j); } } for(int j=0; j<road.size()-1; j++) System.out.print(road.get(j)+\" \"); System.out.println(road.get(road.size()-1)); } }catch(Exception e){ System.out.println(\"Error\"); } } }"], "original_ll": -0.7480449676513672, "sampled_ll": -0.3217506408691406, "all_perturbed_sampled_ll": [-1.5831786394119263], "all_perturbed_original_ll": [-1.6033611297607422], "perturbed_sampled_ll": -1.5831786394119263, "perturbed_original_ll": -1.6033611297607422, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for _ in [0]*input():\n  A = \"012345678954321\"\n  A += A\n  a, b = raw_input().split()\n  i1 = A.index(a)\n  i2 = A.index(a,i1+1)\n  i3 = A.index(b,i1)\n  if i2<i3: i1=i2\n  print \" \".join(A[i1:i3+1])", "sampled": "from collections import deque\n\ndef find_path(start, end):\n    # BFS to find shortest path\n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        current, path = queue.popleft()\n        \n        if current == end:\n            return path\n        \n        # Get neighbors based on bus route structure\n        neighbors = []\n        \n        if current == 0:\n            neighbors = [1]\n        elif current == 1:\n            neighbors = [0, 2]\n        elif current == 2:\n            neighbors = [1, 3]\n        elif current == 3:\n            neighbors = [2, 4]\n        elif current == 4:\n            neighbors = [3, 5]\n        elif current == 5:\n            neighbors = [4, 6, 9]\n        elif current == 6:\n            neighbors = [5, 7]\n        elif current == 7:\n            neighbors = [6, 8]\n        elif current == 8:\n            neighbors = [7, 9]\n        elif current == 9:\n            neighbors = [8, 5]\n        \n        for neighbor in neighbors:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, path + [neighbor]))\n    \n    return []\n\nn = int(input())\nfor _ in range(n):\n    start, end = map(int, input().split())\n    path = find_path(start, end)\n    print(' '.join(map(str, path)))\n", "perturbed_sampled": ["from collections  return path # Get neighbors based on bus route structure neighbors = [] if current == 0: neighbors = [1] elif current ==  = [1, 3] elif current == 3: neighbors = [2, 4] elif current  neighbors = [4, 6, 9] elif current == 6: neighbors = [5, 7]  == 8: neighbors = [7, 9] elif current == 9: neighbors = [8, 5] for neighbor in neighbors: if neighbor not in visited:  for _ in range(n): start, end = map(int, input().split()) path = find_path(start, end) print(' '.join(map(str, path)))"], "perturbed_original": ["for _ in [0]*input(): A = \"012345678954321\" A += A a, b = raw_input().split()  i2<i3: i1=i2 print \" \".join(A[i1:i3+1])"], "original_ll": -1.3952627182006836, "sampled_ll": -0.45526358485221863, "all_perturbed_sampled_ll": [-1.8721481561660767], "all_perturbed_original_ll": [-2.3156392574310303], "perturbed_sampled_ll": -1.8721481561660767, "perturbed_original_ll": -2.3156392574310303, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0141:   Spiral Pattern\n// 2017.8.4\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *gets(char *);\nchar buf[100];\n\nchar a[105][105];\n#define U 1\n#define R 2\n#define D 3\n#define L 4\n\nint main()\n{\n\tint r, c, n, d, stop;\n\tint ci, cn;\n\n\tgets(buf);\n\tcn = atoi(buf);\n\tfor (ci = 0; ci < cn; ci++) {\n\t\tgets(buf);\n\t\tn = atoi(buf);\n\t\tmemset(a, ' ', sizeof(a));\n\t\tfor (r = 0; r < n + 4; r += n + 3) {\n\t\t\tfor (c = 0; c < n + 4; c++) a[r][c] = '#';\n\t\t}\n\t\tfor (c = 0; c < n + 4; c += n + 3) {\n\t\t\tfor (r = 0; r < n + 4; r++) a[r][c] = '#';\n\t\t}\n\t\tr = n + 1, c = 2, d = U, stop = 0, a[r][c] = '#';\n\t\twhile (1) {\n\t\t\tif (stop >= 4) break;\n\t\t\tif (d == U) {\n\t\t\t\tif (a[r-2][c] == '#' || a[r-1][c] == '#' || a[r-1][c+1] == '#') d = R, stop++;\n\t\t\t\telse a[--r][c] = '#', stop = 0;\n\t\t\t}\n\t\t\tif (d == R) {\n\t\t\t\tif (a[r][c+2] == '#' || a[r][c+1] == '#' || a[r+1][c+1] == '#') d = D, stop++;\n\t\t\t\telse a[r][++c] = '#', stop = 0;\n\t\t\t}\n\t\t\tif (d == D) {\n\t\t\t\tif (a[r+2][c] == '#' || a[r+1][c] == '#' || a[r+1][c-1] == '#') d = L, stop++;\n\t\t\t\telse a[++r][c] = '#', stop = 0;\n\t\t\t}\n\t\t\tif (d == L){\n\t\t\t\tif (a[r][c-2] == '#' || a[r][c-1] == '#' || a[r-1][c-1] == '#') d = U, stop++;\n\t\t\t\telse a[r][--c] = '#', stop = 0;\n\t\t\t}\n\t\t}\n\t\tif (ci > 0) putchar('\\n');\n\t\tfor (r = 2; r < n + 2; r++) {\n\t\t\ta[r][n + 2] = 0;\n\t\t\tputs(a[r]+2);\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int d, n;\n    scanf(\"%d\", &d);\n    \n    for (int dataset = 0; dataset < d; dataset++) {\n        scanf(\"%d\", &n);\n        \n        char grid[100][100];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = ' ';\n            }\n        }\n        \n        int minRow = 0, maxRow = n - 1;\n        int minCol = 0, maxCol = n - 1;\n        \n        while (minRow <= maxRow && minCol <= maxCol) {\n            // Bottom row (left to right)\n            for (int j = minCol; j <= maxCol; j++) {\n                grid[maxRow][j] = '#';\n            }\n            \n            // Right column (bottom to top)\n            for (int i = maxRow; i >= minRow; i--) {\n                grid[i][maxCol] = '#';\n            }\n            \n            // Top row (right to left)\n            if (minRow < maxRow) {\n                for (int j = maxCol; j >= minCol; j--) {\n                    grid[minRow][j] = '#';\n                }\n            }\n            \n            // Left column (top to bottom)\n            if (minCol < maxCol) {\n                for (int i = minRow; i <= maxRow; i++) {\n                    grid[i][minCol] = '#';\n                }\n            }\n            \n            minRow += 2;\n            maxRow -= 2;\n            minCol += 2;\n            maxCol -= 2;\n        }\n        \n        // Print grid\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                printf(\"%c\", grid[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        \n        if (dataset < d - 1) {\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int d, n; scanf(\"%d\", &d); for  &n); char  { for (int j = 0; j <  minRow =  maxCol = n - 1; while (minRow <= maxRow &&   top) for (int i = maxRow; i >= minRow; i--)  left) if (minRow < maxRow) { for (int j = maxCol; j >= minCol; j--) { grid[minRow][j] = '#'; } } // Left column (top to bottom) if  <= maxRow; i++) { grid[i][minCol] = '#'; } } minRow += 2; maxRow -= 2; minCol += 2; maxCol -= 2; } // Print grid for (int i = 0; i <  n; j++) { printf(\"%c\", grid[i][j]);  printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0141: Spiral Pattern // 2017.8.4 #include <stdio.h>  a[105][105]; #define U 1 #define R 2 #define D 3 #define  (ci = 0; ci < cn; ci++) { gets(buf); n = atoi(buf); memset(a, ' ', sizeof(a)); for (r = 0; r < n + 4;  c < n +  c < n +  0; r < n + 4; r++) a[r][c] = '#'; } r = n + 1, c = 2, d = U, stop = 0, a[r][c] = '#'; while (1) { if (stop >= 4) break; if (d  '#' || a[r-1][c+1] == '#') d = R,  D, stop++; else a[r][++c] = '#', stop = 0; } if (d == D) { if (a[r+2][c] == '#' ||   == '#' || a[r-1][c-1] == '#') d = U, stop++; else a[r][--c] = '#', stop  (r = 2; r < n + 2; r++) { a[r][n + 2] = 0; puts(a[r]+2); } } return 0; }"], "original_ll": -0.6953409910202026, "sampled_ll": -0.323183536529541, "all_perturbed_sampled_ll": [-1.6332792043685913], "all_perturbed_original_ll": [-1.7755879163742065], "perturbed_sampled_ll": -1.6332792043685913, "perturbed_original_ll": -1.7755879163742065, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint D = sc.nextInt();\n\t\tboolean first = true;\n\t\twhile (D-- > 0) {\n\t\t\tif (!first) {\n\t\t\t\tSystem.out.println();\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tchar[][] field = new char[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(field[i], ' ');\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfield[i][0] = '#';\n\t\t\t\tfield[0][i] = '#';\n\t\t\t}\n\t\t\tif (n < 3) {\n\t\t\t\tdebug2(field);\n\t\t\t} else if (n == 3) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfield[i][n - 1] = '#';\n\t\t\t\t}\n\t\t\t\tdebug2(field);\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfield[i][n - 1] = '#';\n\t\t\t\t}\n\t\t\t\tint nowX = n - 1;\n\t\t\t\tint nowY = n - 1;\n\t\t\t\tboolean go = true;\n\t\t\t\twhile (go) {\n\t\t\t\t\tgo = false;\n\t\t\t\t\twhile (nowX - 2 >= 0 && field[nowY - 1][nowX - 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY][nowX - 2] != '#' && field[nowY][nowX-1] != '#') {\n\t\t\t\t\t\tfield[nowY][--nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t\twhile (nowY - 2 >= 0 && field[nowY - 1][nowX + 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY - 2][nowX] != '#' && field[nowY-1][nowX] != '#') {\n\t\t\t\t\t\tfield[--nowY][nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t\twhile (nowX + 2 < n && field[nowY + 1][nowX + 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY][nowX + 2] != '#' ) {\n\t\t\t\t\t\tfield[nowY][++nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t\twhile (nowY + 2 < n && field[nowY + 1][nowX - 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY + 2][nowX] != '#' ) {\n\t\t\t\t\t\tfield[++nowY][nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdebug2(field);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int d = sc.nextInt();\n        \n        for (int dataset = 0; dataset < d; dataset++) {\n            int n = sc.nextInt();\n            char[][] grid = new char[n][n];\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = ' ';\n                }\n            }\n            \n            int row = n - 1;\n            int col = 0;\n            int dir = 0; // 0: right, 1: up, 2: left, 3: down\n            int[] dr = {0, -1, 0, 1};\n            int[] dc = {1, 0, -1, 0};\n            \n            int steps = n;\n            int currentSteps = 0;\n            int dirChanges = 0;\n            boolean placed = false;\n            \n            while (steps > 0) {\n                for (int i = 0; i < steps; i++) {\n                    if (row >= 0 && row < n && col >= 0 && col < n) {\n                        grid[row][col] = '#';\n                    }\n                    if (i < steps - 1) {\n                        row += dr[dir];\n                        col += dc[dir];\n                    }\n                }\n                \n                row += dr[dir];\n                col += dc[dir];\n                \n                dir = (dir + 1) % 4;\n                dirChanges++;\n                \n                if (dirChanges % 2 == 0) {\n                    steps--;\n                }\n            }\n            \n            for (int i = 0; i < n; i++) {\n                System.out.println(new String(grid[i]));\n            }\n            \n            if (dataset < d - 1) {\n                System.out.println();\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) {  (int dataset = 0; dataset < d; dataset++) { int n = sc.nextInt(); char[][] grid = new char[n][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { grid[i][j]  1; int col = 0; int dir = 0; // 0: right, 1: up, 2: left, 3:  =  false; while (steps > 0) { for (int i = 0; i < steps; i++) { if (row >= 0 &&  steps - 1) { row +=   if (dirChanges % 2 == 0) { steps--; } } for (int i =  sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main {  int mod = 1000000007;  dy = { 0, 1, -1, 0 }; void run() { int D  { if (!first)  char[][] field = new  {  '#'; } if (n < 3) { debug2(field); } else if (n ==  } else { for (int i = 0; i < n; i++) { field[i][n - 1] = '#'; } int nowX = n - 1; int nowY = n -  2] != '#' && field[nowY][nowX-1] != '#') { field[nowY][--nowX] = '#'; go =   != '#' && field[nowY-1][nowX] != '#') { field[--nowY][nowX] = '#'; go = true; } while  1] != '#' && field[nowY][nowX +  true; } while (nowY + 2 <  field[nowY + 2][nowX] != '#' ) { field[++nowY][nowX] = '#'; go = true; } } debug2(field); } } } public static void main(String[] args) { new Main().run(); } void debug(Object... o) { System.out.println(Arrays.deepToString(o)); } void debug2(char[][] array) { for (int i = 0; i < array.length; i++) { for (int j = 0; j < array[i].length; j++) { System.out.print(array[i][j]); } System.out.println(); } } class MyScanner { int nextInt() { try { int c = System.in.read(); while (c != '-' && (c < '0' || '9' < c)) c = System.in.read(); if (c == '-') return -nextInt(); int res =  '0'; c  -1; } } double nextDouble() { return Double.parseDouble(next()); }  int c =  } while (!Character.isWhitespace(c = System.in.read())); return  } }"], "original_ll": -0.43283236026763916, "sampled_ll": -0.5072506070137024, "all_perturbed_sampled_ll": [-1.6402212381362915], "all_perturbed_original_ll": [-1.4695987701416016], "perturbed_sampled_ll": -1.6402212381362915, "perturbed_original_ll": -1.4695987701416016, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def move(self, offset):\n        self.x += offset[0]\n        self.y += offset[1]\n\n    def move_offset(self, offset, multiple=1):\n        x = self.x + offset[0] * multiple\n        y = self.y + offset[1] * multiple\n        return Vector(x, y)\n\n\nclass Pattern:\n    NOTHING = \" \"\n    EXIST = \"#\"\n    SENTINEL = \"?\"\n\n    MOVE = [\n        [[-1, -1], [-1, +0], [-1, +1]],\n        [[-1, +1], [-0, +1], [+1, +1]],\n        [[+1, +1], [+1, +0], [+1, -1]],\n        [[+1, -1], [+0, -1], [-1, -1]],\n    ]\n\n    @classmethod\n    def create_area(cls, size):\n        area = [[cls.SENTINEL] * 2 + [cls.NOTHING] * size + [cls.SENTINEL] * 2 for _ in range(size)]\n        tmp = [[cls.SENTINEL] * size + [cls.SENTINEL] * 2 * 2]\n        area = tmp * 2 + area + tmp * 2\n        return area\n\n    @classmethod\n    def even_spiral_pattern(cls, area, point):\n        move_index = 0\n        area[point.x][point.y] = cls.EXIST\n\n        while True:\n\n            left, center, right = cls.MOVE[move_index]\n            end1, end2 = point.move_offset(left), point.move_offset(right)\n            offset, offset2 = point.move_offset(center), point.move_offset(center, 2)\n\n            if area[end1.x][end1.y] == cls.EXIST or area[end2.x][end2.y] == cls.EXIST:\n                return area\n            elif area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST:\n                point.move(center)\n                area[point.x][point.y] = cls.EXIST\n            else:\n                move_index += 1\n                move_index %= 4\n\n    @classmethod\n    def odd_spiral_pattern(cls, area, point):\n        move_index = 0\n        is_end = False\n        area[point.x][point.y] = cls.EXIST\n\n        while True:\n\n            left, center, right = cls.MOVE[move_index]\n            offset, offset2 = point.move_offset(center), point.move_offset(center, 2)\n\n            if area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST:\n                point.move(center)\n                area[point.x][point.y] = cls.EXIST\n                is_end = False\n            else:\n                if is_end:\n                    return area\n                else:\n                    is_end = True\n\n                move_index += 1\n                move_index %= 4\n\n    @classmethod\n    def formater(cls, area):\n        output = [\"\".join(item[2:-2]) for item in area[2:-2]]\n        output = \"\\n\".join(output)\n        return output\n\n    @classmethod\n    def solve(cls, size):\n        area = cls.create_area(size)\n        point = Vector(size - 1 + 2, 2)\n\n        if size % 2 == 0:\n            result = cls.even_spiral_pattern(area, point)\n        else:\n            result = cls.odd_spiral_pattern(area, point)\n\n        return cls.formater(result)\n\n\nsizes = [int(input()) for _ in range(int(input()))]\nresults = [Pattern.solve(num) for num in sizes]\nprint(\"\\n\\n\".join(results))\n\n", "sampled": "def generate_spiral(n):\n    grid = [[' ' for _ in range(n)] for _ in range(n)]\n    \n    # Start from bottom-left, go clockwise\n    row, col = n - 1, 0\n    dr, dc = 0, 1  # Start moving right\n    \n    visited = set()\n    visited.add((row, col))\n    grid[row][col] = '#'\n    \n    while True:\n        # Try to move in current direction\n        next_row, next_col = row + dr, col + dc\n        \n        # Check if we can continue in current direction\n        can_continue = (0 <= next_row < n and \n                       0 <= next_col < n and \n                       (next_row, next_col) not in visited)\n        \n        if can_continue:\n            row, col = next_row, next_col\n            visited.add((row, col))\n            grid[row][col] = '#'\n        else:\n            # Try to turn clockwise\n            # Clockwise from bottom-left: right(0,1) -> up(-1,0) -> left(0,-1) -> down(1,0)\n            if (dr, dc) == (0, 1):  # right -> up\n                dr, dc = -1, 0\n            elif (dr, dc) == (-1, 0):  # up -> left\n                dr, dc = 0, -1\n            elif (dr, dc) == (0, -1):  # left -> down\n                dr, dc = 1, 0\n            elif (dr, dc) == (1, 0):  # down -> right\n                dr, dc = 0, 1\n            \n            next_row, next_col = row + dr, col + dc\n            \n            # Check if we can move after turning\n            if (0 <= next_row < n and \n                0 <= next_col < n and \n                (next_row, next_col) not in visited):\n                row, col = next_row, next_col\n                visited.add((row, col))\n                grid[row][col] = '#'\n            else:\n                # Can't move anywhere, done\n                break\n    \n    return grid\n\nd = int(input())\nresults = []\n\nfor i in range(d):\n    n = int(input())\n    grid = generate_spiral(n)\n    results.append(grid)\n\nfor i, grid in enumerate(results):\n    for row in grid:\n        print(''.join(row))\n    if i < len(results) - 1:\n        print()\n", "perturbed_sampled": [" dc = 0, 1 # Start moving right visited = set()  move in current direction next_row, next_col = row + dr, col + dc # Check if we can continue in current direction can_continue =  n and (next_row, next_col) not in visited) if can_continue: row, col = next_row, next_col visited.add((row, col)) grid[row][col] = '#' else: # Try to turn clockwise # Clockwise from bottom-left: right(0,1) -> up(-1,0) -> left(0,-1) -> down(1,0) if (dr, dc) == (0, 1): # right ->   -1 elif (dr, dc) == (0, -1): # left -> down dr, dc  down -> right dr, dc  + dc # Check if we can move after turning if  n and (next_row, next_col) not in visited): row, col = next_row, next_col visited.add((row, col)) grid[row][col] = '#' else:  int(input()) results = [] for i in range(d): n = int(input()) grid  print()"], "perturbed_original": ["class Vector: def __init__(self, x,  self.x +=  self.x + offset[0] * multiple y = self.y  MOVE = [ [[-1, -1], [-1, +0], [-1, +1]], [[-1, +1], [-0, +1], [+1, +1]], [[+1, +1], [+1, +0], [+1, -1]], [[+1, -1], [+0, -1],  * 2 +  2 * 2]  = 0 area[point.x][point.y] = cls.EXIST while True: left, center, right = cls.MOVE[move_index]  2) if area[end1.x][end1.y] == cls.EXIST or area[end2.x][end2.y] == cls.EXIST: return area elif area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST: point.move(center) area[point.x][point.y] = cls.EXIST else: move_index += 1 move_index %= 4 @classmethod def odd_spiral_pattern(cls, area, point): move_index = 0 is_end = False area[point.x][point.y] = cls.EXIST while True: left, center, right = cls.MOVE[move_index] offset, offset2 = point.move_offset(center), point.move_offset(center, 2) if  cls.EXIST is_end = False else: if is_end: return area else: is_end   = \"\\n\".join(output)  = Vector(size - 1 + 2, 2) if size  = cls.odd_spiral_pattern(area, point) return cls.formater(result) sizes = [int(input()) for _ in range(int(input()))] results = [Pattern.solve(num) for num in sizes] print(\"\\n\\n\".join(results))"], "original_ll": -0.7079124450683594, "sampled_ll": -0.5174083113670349, "all_perturbed_sampled_ll": [-1.8964282274246216], "all_perturbed_original_ll": [-1.8470858335494995], "perturbed_sampled_ll": -1.8964282274246216, "perturbed_original_ll": -1.8470858335494995, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\nint main(){\n  int exp[10001], n, i, j, mod[10001], a[10001], c, count[6000], h, d;\n\n  for(i = 1; i < 10001; ++i) exp[i] = i * i;\n\n  while(scanf(\"%d\", &n) && n){\n    memset(count , 0, sizeof(count));\n    for(i = 1; i < n; ++i) mod[i] = exp[i] % n;\n    c = 0;\n    for(i = 1; i < n; ++i){\n      for(j = 0; j < c; ++j)\n\tif(mod[i] == a[j]) break;\n      if(j == c) a[c++] = mod[i];\n    }\n    h = (n - 1) / 2;\n    for(i = 0; i < c; ++i){\n      for(j = 0; j < c; ++j){\n\tif(a[i] != a[j]){\n\t  d = a[i] - a[j];\n\t  if(d < 0) d += n;\n\t  if(d > h) d = n - d;\n\t  count[d]++;\n\t}\n      }\n    }\n\n    for(i = 1; i <= h; ++i) printf(\"%d\\n\", count[i]);  \n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int *squares = (int*)malloc(n * sizeof(int));\n        int unique_count = 0;\n        int *unique_squares = (int*)malloc(n * sizeof(int));\n        \n        // Calculate squares mod n\n        for(int i = 1; i < n; i++) {\n            squares[i] = (i * i) % n;\n        }\n        \n        // Find unique squares\n        for(int i = 1; i < n; i++) {\n            int found = 0;\n            for(int j = 0; j < unique_count; j++) {\n                if(unique_squares[j] == squares[i]) {\n                    found = 1;\n                    break;\n                }\n            }\n            if(!found) {\n                unique_squares[unique_count++] = squares[i];\n            }\n        }\n        \n        int max_diff = (n - 1) / 2;\n        int *count = (int*)calloc(max_diff + 1, sizeof(int));\n        \n        // Calculate differences\n        for(int i = 0; i < unique_count; i++) {\n            for(int j = 0; j < unique_count; j++) {\n                if(i != j) {\n                    int a = unique_squares[i];\n                    int b = unique_squares[j];\n                    int diff = a - b;\n                    \n                    // If negative, add n\n                    if(diff < 0) {\n                        diff += n;\n                    }\n                    \n                    // If greater than (n-1)/2, subtract from n\n                    if(diff > max_diff) {\n                        diff = n - diff;\n                    }\n                    \n                    if(diff >= 1 && diff <= max_diff) {\n                        count[diff]++;\n                    }\n                }\n            }\n        }\n        \n        // Output counts\n        for(int i = 1; i <= max_diff; i++) {\n            printf(\"%d\\n\", count[i]);\n        }\n        \n        free(squares);\n        free(unique_squares);\n        free(count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int main() { int n; while(1) { scanf(\"%d\", &n); if(n == 0) break; int *squares = (int*)malloc(n * sizeof(int)); int unique_count = 0; int *unique_squares = (int*)malloc(n * sizeof(int)); //  n; i++) { squares[i] = (i * i) % n; } // Find unique squares for(int i  { if(unique_squares[j] == squares[i])  = squares[i]; } } int  = 0; i < unique_count; i++) { for(int j =  int a = unique_squares[i]; int b = unique_squares[j]; int  if(diff < 0) { diff += n; } // If greater than (n-1)/2, subtract from n if(diff > max_diff) { diff = n - diff; } if(diff >= 1 && diff <= max_diff) {  } free(squares); free(unique_squares); free(count); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(){ int exp[10001], n, i, j, mod[10001], a[10001], c, count[6000],   0, sizeof(count)); for(i = 1; i < n; ++i) mod[i] = exp[i] % n; c =  (n - 1) / 2; for(i = 0; i < c; ++i){ for(j = 0; j < c; ++j){ if(a[i] != a[j]){ d = a[i] - a[j]; if(d < 0) d += n; if(d >  for(i = 1; i <= h; ++i) printf(\"%d\\n\", count[i]); } return 0; }"], "original_ll": -0.7689151167869568, "sampled_ll": -0.4971469044685364, "all_perturbed_sampled_ll": [-1.603145956993103], "all_perturbed_original_ll": [-1.426668405532837], "perturbed_sampled_ll": -1.603145956993103, "perturbed_original_ll": -1.426668405532837, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t\tSystem.out.flush();\n\t}\n\n\tvoid solve(){\n\t\tTreeSet<Integer> set=new TreeSet<Integer>();\n\t\tfor(int i=1; i<n; i++){\n\t\t\tset.add(i*i%n);\n\t\t}\n\t\tint[] c=new int[n];\n\t\tfor(int j : set){\n\t\t\tfor(int i : set){\n\t\t\t\tif(i!=j){\n\t\t\t\t\tint a=i-j;\n\t\t\t\t\tif(a<0){\n\t\t\t\t\t\ta+=n;\n\t\t\t\t\t}\n\t\t\t\t\tif(a>(n-1)/2){\n\t\t\t\t\t\ta=n-a;\n\t\t\t\t\t}\n\t\t\t\t\tc[a]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// debug(set.toArray());\n\t\t// debug(c);\n\t\tfor(int i=1; i<=(n-1)/2; i++){\n\t\t\tprintln(\"\"+c[i]);\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tSystem.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            // Step 1: Calculate squares mod n\n            Set<Integer> squares = new HashSet<>();\n            for (int i = 1; i < n; i++) {\n                int sq = (i * i) % n;\n                squares.add(sq);\n            }\n            \n            // Step 2: Calculate differences between all pairs\n            List<Integer> squareList = new ArrayList<>(squares);\n            int maxDiff = (n - 1) / 2;\n            int[] frequency = new int[maxDiff + 1];\n            \n            for (int i = 0; i < squareList.size(); i++) {\n                for (int j = i + 1; j < squareList.size(); j++) {\n                    int a = squareList.get(i);\n                    int b = squareList.get(j);\n                    \n                    // Calculate difference\n                    int diff = a - b;\n                    \n                    // If negative, add n\n                    if (diff < 0) {\n                        diff += n;\n                    }\n                    \n                    // If greater than (n-1)/2, subtract from n\n                    if (diff > maxDiff) {\n                        diff = n - diff;\n                    }\n                    \n                    frequency[diff]++;\n                }\n            }\n            \n            // Step 3: Output frequencies for 1 to (n-1)/2\n            for (int i = 1; i <= maxDiff; i++) {\n                System.out.println(frequency[i]);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void  { int n = sc.nextInt(); if (n == 0) break; // Step 1: Calculate squares mod n  ArrayList<>(squares); int maxDiff = (n - 1) / 2; int[] frequency = new int[maxDiff + 1]; for (int i = 0; i < squareList.size(); i++) { for (int j = i + 1; j < squareList.size(); j++) { int a = squareList.get(i); int b = squareList.get(j); // Calculate difference int diff = a - b; // If negative, add n if (diff < 0) {  from n if  frequency[diff]++; } } // Step  =  } }"], "perturbed_original": ["import java.util.*; import java.lang.*; import java.math.*; import java.io.*; import static java.lang.Math.*; import static  EPS=1e-9; int n; void run(){ for(;;){ n=sc.nextInt(); if(n==0){ break; } solve(); } System.out.flush();  set.add(i*i%n); } int[] c=new int[n]; for(int j : set){  // debug(c); for(int i=1; i<=(n-1)/2;  print(String s){ System.out.print(s); } void println(String s){ System.out.println(s); } public static void main(String[] args){ System.setOut(new PrintStream(new BufferedOutputStream(System.out))); new Main().run(); } }"], "original_ll": -0.901170015335083, "sampled_ll": -0.574683666229248, "all_perturbed_sampled_ll": [-1.8322960138320923], "all_perturbed_original_ll": [-2.065962314605713], "perturbed_sampled_ll": -1.8322960138320923, "perturbed_original_ll": -2.065962314605713, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import itertools\n\nr = 10001\ns = int(r**0.5)\np = [1]*r\np[0] = 0\nfor i in range(1,s):\n\tif p[i]:\n\t\tp[2*i + 1::i + 1] = [0 for x in range(2*i + 1, r, i + 1)]\n\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\tm = (n - 1) / 2\n\ta = sorted(list(set([i**2%n for i in range(1,n)])))\n\tl = len(a)\n\tif n%4 == 3 and p[n - 1] == 1:\n\t\tll = l*(l - 1) / m\n\t\tfor i in range(m):\n\t\t\tprint ll\n\t\tcontinue\n\th = [0]*(m+1)\n\tfor i,j in itertools.combinations(a,2):\n\t\td = j - i\n\t\th[min(d,n - d)] += 2\n\tfor i in range(1,m+1):\n\t\tprint h[i]", "sampled": "def solve(n):\n    # Calculate squares mod n\n    squares = set()\n    for i in range(1, n):\n        squares.add((i * i) % n)\n    \n    squares = list(squares)\n    \n    # Calculate differences\n    max_diff = (n - 1) // 2\n    diff_count = [0] * (max_diff + 1)\n    \n    for i in range(len(squares)):\n        for j in range(i + 1, len(squares)):\n            a = squares[i]\n            b = squares[j]\n            \n            # Calculate difference\n            diff = a - b\n            if diff < 0:\n                diff += n\n            if diff > max_diff:\n                diff = n - diff\n            \n            diff_count[diff] += 1\n    \n    # Output frequencies for 1 to max_diff\n    for i in range(1, max_diff + 1):\n        print(diff_count[i])\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    solve(n)\n", "perturbed_sampled": ["def solve(n): # Calculate squares mod n squares = set() for i in range(1, n): squares.add((i * i) % n) squares = list(squares) # Calculate differences max_diff = (n - 1) // 2 diff_count  for j in range(i + 1,  diff = a  diff > max_diff: diff = n  to  True: n = int(input()) if n == 0: break solve(n)"], "perturbed_original": [" x in range(2*i + 1, r, i + 1)] while 1: n = input() if n == 0:  sorted(list(set([i**2%n for i in range(1,n)]))) l = len(a) if n%4 == 3 and p[n - 1] == 1: ll = l*(l - 1) /  [0]*(m+1) for i,j in itertools.combinations(a,2): d = j - i h[min(d,n - d)] += 2 for i in range(1,m+1): print h[i]"], "original_ll": -1.3470165729522705, "sampled_ll": -0.7597257494926453, "all_perturbed_sampled_ll": [-2.53225040435791], "all_perturbed_original_ll": [-2.327824592590332], "perturbed_sampled_ll": -2.53225040435791, "perturbed_original_ll": -2.327824592590332, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-2 0143   Altair and Vega\n// 2017.8.8\n\n#include <stdio.h>\n\nint atSameSide(int x1, int y1, int x2, int y2, int xa, int ya, int xb, int yb)\n{\n\tint sa, sb;\n\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n//\tif (sb == 0) return 0;  \t\t // xb,yb in line\n\treturn (sa * sb >= 0);           // xa,ya xb,yb at same side\n}\n\nint main()\n{\n\tint n;\n\tint x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\tint kin, sin;\n\n\tscanf(\"%d\", &n);\n\twhile (n-- > 0) {\n\t\tscanf(\"%d%d%d%d%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3, &xk, &yk, &xs, &ys);\n\t\tkin = atSameSide(x1, y1, x2, y2, x3, y3, xk, yk) &&\n\t\t\t  atSameSide(x2, y2, x3, y3, x1, y1, xk, yk) &&\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xk, yk);\n\t\tsin = atSameSide(x1, y1, x2, y2, x3, y3, xs, ys) &&\n\t\t  \t  atSameSide(x2, y2, x3, y3, x1, y1, xs, ys) &&\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xs, ys);\n\t\tputs(kin ^ sin ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint sign(double x) {\n    if (x > 0) return 1;\n    if (x < 0) return -1;\n    return 0;\n}\n\ndouble cross_product(double x1, double y1, double x2, double y2, double x3, double y3) {\n    return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n}\n\nint point_in_triangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {\n    double d1 = cross_product(x1, y1, x2, y2, px, py);\n    double d2 = cross_product(x2, y2, x3, y3, px, py);\n    double d3 = cross_product(x3, y3, x1, y1, px, py);\n    \n    int s1 = sign(d1);\n    int s2 = sign(d2);\n    int s3 = sign(d3);\n    \n    int has_neg = (s1 < 0) || (s2 < 0) || (s3 < 0);\n    int has_pos = (s1 > 0) || (s2 > 0) || (s3 > 0);\n    \n    return !(has_neg && has_pos);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        double xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\",\n              &xp1, &yp1, &xp2, &yp2, &xp3, &yp3, &xk, &yk, &xs, &ys);\n        \n        int k_inside = point_in_triangle(xk, yk, xp1, yp1, xp2, yp2, xp3, yp3);\n        int s_inside = point_in_triangle(xs, ys, xp1, yp1, xp2, yp2, xp3, yp3);\n        \n        if (k_inside != s_inside) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  cross_product(double x1, double y1, double x2, double  (x3 - x1); } int point_in_triangle(double px, double py, double x1, double y1, double  = cross_product(x1, y1, x2,  px, py); double d3 = cross_product(x3, y3, x1, y1, px, py); int s1 = sign(d1); int s2 = sign(d2); int s3 = sign(d3); int has_neg  (s2 > 0) || (s3 > 0); return !(has_neg && has_pos);  i = 0; i < n; i++) { double xp1,  %lf %lf %lf %lf %lf %lf %lf %lf %lf\", &xp1, &yp1, &xp2, &yp2, &xp3, &yp3, &xk, &yk,  yp2, xp3, yp3); int s_inside = point_in_triangle(xs, ys, xp1, yp1, xp2, yp2, xp3, yp3); if (k_inside != s_inside) { printf(\"OK\\n\"); } else { printf(\"NG\\n\"); } } return 0; }"], "perturbed_original": ["// Aizu Vol-2 0143 Altair and Vega // 2017.8.8 #include <stdio.h> int atSameSide(int x1, int y1, int x2, int  int sa, sb; sa = (x2 - x1) * (ya  sb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb); // if (sb == 0) return 0; // xb,yb in line return (sa * sb  x3, y3, xk, yk, xs, ys; int kin, sin; scanf(\"%d\", &n); while (n-- > 0) { scanf(\"%d%d%d%d%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3, &xk, &yk, &xs, &ys); kin = atSameSide(x1, y1, x2, y2, x3, y3, xk, yk) && atSameSide(x2, y2, x3,   : \"NG\"); } return 0; }"], "original_ll": -0.8120945692062378, "sampled_ll": -0.3405817747116089, "all_perturbed_sampled_ll": [-1.4312167167663574], "all_perturbed_original_ll": [-1.6904301643371582], "perturbed_sampled_ll": -1.4312167167663574, "perturbed_original_ll": -1.6904301643371582, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tint n = in.nextInt();\n\t\tfor(int i=0;i<n;i++)new AOJ0143().doIt();\n\t\t\n\t}\n\tclass AOJ0143{\n\t\tvoid doIt(){\n\t\t\tPoint2D ps[] = new Point2D[3];\n\t\t\tfor(int i=0;i<3;i++)ps[i] = new Point2D.Double(in.nextInt(),in.nextInt());;\n\t\t\tPoint2D a = new Point2D.Double(in.nextInt(),in.nextInt());\n\t\t\tPoint2D b = new Point2D.Double(in.nextInt(),in.nextInt());\n\t\t\tint c = contains(ps, a);\n\t\t\tint d = contains(ps, b);\n//\t\t\tSystem.out.println(c+\" \"+d);\n\t\t\tif(c==d)System.out.println(\"NG\");\n\t\t\telse System.out.println(\"OK\");\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tdouble cross(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getY()-p1.getY()*p2.getX();\n\t\t}\n\t\tdouble dot(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getX()+p1.getY()*p2.getY();\n\t\t}\n\t\tprivate int contains(Point2D[] plist,Point2D p) {\n\t\t\tboolean isin = false;\n\t\t\tint n = plist.length;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint2D a = sub(plist[i], p);\n\t\t\t\tPoint2D b = sub(plist[(i+1) % n], p);\n\t\t\t\tif(a.getY() > b.getY()){\n\t\t\t\t\tPoint2D temp = (Point2D) a.clone();\n\t\t\t\t\ta = b;\n\t\t\t\t\tb = temp;\n\t\t\t\t}\n\t\t\t\tif(a.getY() <= 0 && 0 < b.getY()){\n\t\t\t\t\tif(cross(a,b) < 0) isin = ! isin;\n\t\t\t\t}\n\t\t\t\tif(cross(a,b) == 0 && dot(a, b) <= 0) return 0;\n\t\t\t}\n\t\t\treturn isin ? 1 : -1;\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double xp1 = sc.nextDouble();\n            double yp1 = sc.nextDouble();\n            double xp2 = sc.nextDouble();\n            double yp2 = sc.nextDouble();\n            double xp3 = sc.nextDouble();\n            double yp3 = sc.nextDouble();\n            double xk = sc.nextDouble();\n            double yk = sc.nextDouble();\n            double xs = sc.nextDouble();\n            double ys = sc.nextDouble();\n            \n            boolean kInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xk, yk);\n            boolean sInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xs, ys);\n            \n            if (kInside != sInside) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NG\");\n            }\n        }\n        sc.close();\n    }\n    \n    static boolean isInside(double x1, double y1, double x2, double y2, double x3, double y3, double px, double py) {\n        double sign1 = sign(px, py, x1, y1, x2, y2);\n        double sign2 = sign(px, py, x2, y2, x3, y3);\n        double sign3 = sign(px, py, x3, y3, x1, y1);\n        \n        boolean hasNeg = (sign1 < 0) || (sign2 < 0) || (sign3 < 0);\n        boolean hasPos = (sign1 > 0) || (sign2 > 0) || (sign3 > 0);\n        \n        return !(hasNeg && hasPos);\n    }\n    \n    static double sign(double px, double py, double x1, double y1, double x2, double y2) {\n        return (px - x2) * (y1 - y2) - (x1 - x2) * (py - y2);\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i < n; i++) { double xp1 = sc.nextDouble(); double yp1 = sc.nextDouble(); double xp2 = sc.nextDouble(); double yp2 = sc.nextDouble(); double xp3 = sc.nextDouble();  sc.nextDouble(); boolean kInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xk, yk); boolean sInside = isInside(xp1, yp1, xp2, yp2,  } else { System.out.println(\"NG\"); } } sc.close();  y2,  sign1 = sign(px, py, x1, y1, x2, y2); double sign2 = sign(px, py, x2, y2, x3, y3); double sign3 = sign(px, py, x3, y3, x1, y1); boolean  py, double x1, double y1, double x2, double y2) { return (px - x2) * (y1  } }"], "perturbed_original": ["import java.awt.geom.Point2D; import java.util.Scanner; public class Main { Scanner in = new Scanner(System.in); public static  i=0;i<3;i++)ps[i] = new Point2D.Double(in.nextInt(),in.nextInt());; Point2D a = new Point2D.Double(in.nextInt(),in.nextInt());  else System.out.println(\"OK\"); } Point2D sub(Point2D p1,Point2D p2){ return new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY()); } double cross(Point2D p1,Point2D p2){ return p1.getX()*p2.getY()-p1.getY()*p2.getX(); } double dot(Point2D p1,Point2D p2){ return p1.getX()*p2.getX()+p1.getY()*p2.getY(); } private int contains(Point2D[] plist,Point2D p) { boolean isin = false; int  Point2D b = sub(plist[(i+1) % n], p); if(a.getY() > b.getY()){ Point2D temp = (Point2D) a.clone(); a  0 < b.getY()){ if(cross(a,b) < 0) isin = ! isin; } if(cross(a,b) == 0 && dot(a, b) <= 0) return  }"], "original_ll": -0.6758890151977539, "sampled_ll": -0.3457350730895996, "all_perturbed_sampled_ll": [-1.2081477642059326], "all_perturbed_original_ll": [-1.3216043710708618], "perturbed_sampled_ll": -1.2081477642059326, "perturbed_original_ll": -1.3216043710708618, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    @staticmethod\n    def cross_product(point1, point2):\n        return point1.x * point2.y - point1.y * point2.x\n\n\nclass Triangle:\n    def __init__(self, x1, y1, x2, y2, x3, y3):\n        self.point1 = Vector(x1, y1)\n        self.point2 = Vector(x2, y2)\n        self.point3 = Vector(x3, y3)\n\n    def is_contain(self, point):\n        line1 = point - self.point1\n        line2 = self.point2 - self.point1\n        direct1 = Vector.cross_product(line1, line2)\n\n        line1 = point - self.point2\n        line2 = self.point3 - self.point2\n        direct2 = Vector.cross_product(line1, line2)\n\n        line1 = point - self.point3\n        line2 = self.point1 - self.point3\n        direct3 = Vector.cross_product(line1, line2)\n\n        if 0 < direct1 and 0 < direct2 and 0 < direct3:\n            return 1\n        elif direct1 < 0 and direct2 < 0 and direct3 < 0:\n            return 1\n        else:\n            return -1\n\n\nfor _ in range(int(input())):\n    data = [int(item) for item in input().split(\" \")]\n\n    triangle = Triangle(data[0], data[1], data[2], data[3], data[4], data[5])\n    altair_point = Vector(data[6], data[7])\n    vega_point = Vector(data[8], data[9])\n\n    is_contain1 = triangle.is_contain(altair_point)\n    is_contain2 = triangle.is_contain(vega_point)\n    result = is_contain1 * is_contain2\n\n    if result == -1:\n        print(\"OK\")\n    else:\n        print(\"NG\")\n\n", "sampled": "def sign(p1, p2, p3):\n    return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n\ndef point_in_triangle(pt, v1, v2, v3):\n    d1 = sign(pt, v1, v2)\n    d2 = sign(pt, v2, v3)\n    d3 = sign(pt, v3, v1)\n    \n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    \n    return not (has_neg and has_pos)\n\nn = int(input())\nfor _ in range(n):\n    coords = list(map(int, input().split()))\n    p1 = (coords[0], coords[1])\n    p2 = (coords[2], coords[3])\n    p3 = (coords[4], coords[5])\n    k = (coords[6], coords[7])\n    s = (coords[8], coords[9])\n    \n    k_inside = point_in_triangle(k, p1, p2, p3)\n    s_inside = point_in_triangle(s, p1, p2, p3)\n    \n    if (k_inside and not s_inside) or (not k_inside and s_inside):\n        print(\"OK\")\n    else:\n        print(\"NG\")\n", "perturbed_sampled": ["def sign(p1, p2, p3):  - p3[0]) * (p1[1] - p3[1]) def point_in_triangle(pt, v1, v2, v3): d1 =  sign(pt, v3, v1)  (d2 > 0) or (d3 > 0) return not (has_neg and has_pos)  input().split())) p1 = (coords[0], coords[1]) p2 = (coords[2], coords[3]) p3 = (coords[4], coords[5]) k = (coords[6], coords[7]) s = (coords[8], coords[9]) k_inside  p3) if (k_inside and not s_inside) or (not k_inside and s_inside): print(\"OK\") else: print(\"NG\")"], "perturbed_original": ["class Vector: def __init__(self, x, y): self.x =   Vector(x1, y1) self.point2 = Vector(x2, y2) self.point3 = Vector(x3, y3) def  - self.point1 direct1 = Vector.cross_product(line1, line2) line1 = point - self.point2 line2 = self.point3 - self.point2 direct2 = Vector.cross_product(line1, line2) line1 = point - self.point3  0 < direct1 and 0 < direct2 and 0 < direct3: return 1 elif direct1 < 0 and direct2 < 0 and direct3  range(int(input())): data = [int(item) for item in input().split(\" \")] triangle  data[7]) vega_point = Vector(data[8], data[9]) is_contain1 = triangle.is_contain(altair_point) is_contain2 = triangle.is_contain(vega_point) result = is_contain1 * is_contain2 if result == -1: print(\"OK\") else: print(\"NG\")"], "original_ll": -0.5240759253501892, "sampled_ll": -0.3540908098220825, "all_perturbed_sampled_ll": [-1.5063010454177856], "all_perturbed_original_ll": [-1.7663922309875488], "perturbed_sampled_ll": -1.5063010454177856, "perturbed_original_ll": -1.7663922309875488, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint r[100][100];\nint n;\n\nint dijkstra(int start, int goal) {\n  int i;\n  int minimum, p;\n  int d[100], f[100];\n\n  for(i = 0; i < 100; i++) {\n    d[i] = 100000;\n    f[i] = 0;\n  }\n  d[start-1] = 1;\n  while(1) {\n    minimum = 100000;\n    for(i = 0; i < n; i++) {\n      if(d[i] < minimum && f[i] == 0) {\n\tminimum = d[i];\n\tp = i;\n      }\n    }\n    if(minimum == 100000) break;\n    f[p] = 1;\n\n    for(i = 0; i < n; i++) {\n      if(d[p] + r[p][i] < d[i]) {\n\td[i] = d[p] + r[p][i];\n      }\n    }\n  }\n\n  return d[goal-1];\n}\n\nint main() {\n  int i, j, r1, k1, p, s1, d1, v1, temp;\n\n  for(i = 0; i < 100; i++)\n    for(j = 0; j < 100; j++)\n      r[i][j] = 100000;\n\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; i++) {\n    scanf(\"%d %d\", &r1, &k1);\n    for(j = 0; j < k1; j++) {\n      scanf(\"%d\", &temp);\n      r[r1-1][temp-1] = 1;\n    }\n  }\n  scanf(\"%d\", &p);\n  for(i = 0; i < p; i++) {\n    scanf(\"%d %d %d\", &s1, &d1, &v1);\n    temp = dijkstra(s1, d1);\n    if(v1 - temp < 0) {\n      printf(\"NA\\n\");\n    } else {\n      printf(\"%d\\n\", temp);\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 101\n#define INF INT_MAX\n\nint adj[MAX_N][MAX_N];\nint adjCount[MAX_N];\nint dist[MAX_N];\nint visited[MAX_N];\n\nint bfs(int start, int end, int n) {\n    int queue[MAX_N * MAX_N];\n    int front = 0, rear = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    \n    queue[rear++] = start;\n    dist[start] = 1;\n    visited[start] = 1;\n    \n    while (front < rear) {\n        int u = queue[front++];\n        \n        if (u == end) {\n            return dist[end];\n        }\n        \n        for (int i = 0; i < adjCount[u]; i++) {\n            int v = adj[u][i];\n            if (!visited[v]) {\n                visited[v] = 1;\n                dist[v] = dist[u] + 1;\n                queue[rear++] = v;\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i <= n; i++) {\n        adjCount[i] = 0;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        int r, k;\n        scanf(\"%d %d\", &r, &k);\n        adjCount[r] = k;\n        for (int j = 0; j < k; j++) {\n            scanf(\"%d\", &adj[r][j]);\n        }\n    }\n    \n    int p;\n    scanf(\"%d\", &p);\n    \n    for (int i = 0; i < p; i++) {\n        int s, d, v;\n        scanf(\"%d %d %d\", &s, &d, &v);\n        \n        int minDist = bfs(s, d, n);\n        \n        if (minDist == -1) {\n            printf(\"NA\\n\");\n        } else {\n            int hops = minDist - 1;\n            if (v >= hops) {\n                printf(\"%d\\n\", minDist);\n            } else {\n                printf(\"NA\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h>  int dist[MAX_N]; int visited[MAX_N]; int bfs(int start, int end, int n)  = 0; for (int i =  =  1; while (front < rear) { int u = queue[front++]; if (u == end) { return dist[end]; } for (int i = 0;  1; queue[rear++] = v; } } } return -1; } int main() { int n; scanf(\"%d\", &n); for (int i = 1; i <= n; i++) { adjCount[i] = 0; } for (int i = 0; i < n; i++) { int r, k; scanf(\"%d %d\",  j < k; j++) { scanf(\"%d\",  = 0; i  %d\", &s,  == -1) { printf(\"NA\\n\"); } else { int hops =  } else { printf(\"NA\\n\"); } } } return 0; }"], "perturbed_original": ["#include <stdio.h> int r[100][100]; int n; int dijkstra(int start, int goal) { int  = 0; } d[start-1] = 1; while(1) { minimum = 100000; for(i = 0; i < n; i++) { if(d[i] < minimum && f[i] == 0) { minimum = d[i]; p = i; } } if(minimum == 100000) break; f[p] = 1; for(i = 0; i < n; i++) { if(d[p] + r[p][i] < d[i]) { d[i] = d[p] + r[p][i]; } }  r1, k1, p, s1, d1,  = 0; j < 100; j++) r[i][j] = 100000; scanf(\"%d\",  %d\", &r1,  &temp); r[r1-1][temp-1] =  p; i++) { scanf(\"%d %d %d\", &s1, &d1, &v1); temp  }"], "original_ll": -0.5074681639671326, "sampled_ll": -0.4202021360397339, "all_perturbed_sampled_ll": [-1.6511366367340088], "all_perturbed_original_ll": [-1.3612715005874634], "perturbed_sampled_ll": -1.6511366367340088, "perturbed_original_ll": -1.3612715005874634, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = in.readLine();\n\t\n\t\tint size = Integer.parseInt(line);\n\t\tNode[] nodes = new Node[size];\n\t\tfor(int i=0; i<size; i++){\n\t\t\tline = in.readLine();\n\t\t\tString[] tmp = line.split(\" \");\n\t\t\tint id = Integer.parseInt(tmp[0])-1;\n\t\t\tnodes[id] = new Node();\n\t\t\tint n_to = Integer.parseInt(tmp[1]);\n\t\t\tfor(int j=2; j<2+n_to; j++){\n\t\t\t\tint to = Integer.parseInt(tmp[j])-1;\n\t\t\t\tnodes[id].add_edge(to, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tline = in.readLine();\n\t\tsize = Integer.parseInt(line);\n\t\tfor(int i=0; i<size; i++){\n\t\t\tNode[] clone = deepClone(nodes);\n\t\t\tline = in.readLine();\n\t\t\tString[] tmp = line.split(\" \");\n\t\t\tint s = Integer.parseInt(tmp[0])-1;\n\t\t\tint g = Integer.parseInt(tmp[1])-1;\n\t\t\tint ttl = Integer.parseInt(tmp[2]);\n\t\t\tint total = calcCost(clone, s, g);\n\t\t\tif(ttl >= total && total != -1){\n\t\t\t\tSystem.out.println(total);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int calcCost(Node[] nodes, int s, int g){\n\t\tList<Node> que = new ArrayList<Node>();\n\t\tnodes[s].cost = 1;\n\t\tque.add(nodes[s]);\n\t\tNode done = null;\n\t\twhile(que.size()!=0){\n\t\t\tdone = que.get(0);\n\t\t\tque.remove(0);\n\t\t\tdone.visited = true;\n\t\t\tfor(int i=0; i<done.edge_to.size(); i++){\n\t\t\t\tint cost = done.cost + done.edge_cost.get(i);\n\t\t\t\tint to = done.edge_to.get(i);\n\t\t\t\tif(nodes[to].cost < 0 || cost < nodes[to].cost){\n\t\t\t\t\tnodes[to].cost = cost;\n\t\t\t\t\tif(!que.contains(nodes[to])){\n\t\t\t\t\t\tque.add(nodes[to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nodes[g].cost;\n\t}\n\t\n\tpublic Node[] deepClone(Node[] nodes){\n\t\tint m = nodes.length;\n\t\tNode[] clone = new Node[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tclone[i] = new Node(nodes[i]);\n\t\t}\n\t\treturn clone;\n\t}\n}\n\nclass Node{\n\tint cost;\n\tboolean visited;\n\tList<Integer> edge_to;\n\tList<Integer> edge_cost;\n\t\n\tpublic Node(){\n\t\tthis.cost = -1;\n\t\tthis.visited = false;\n\t\tthis.edge_cost = new ArrayList<Integer>();\n\t\tthis.edge_to = new ArrayList<Integer>();\n\t}\n\t\n\tpublic Node(Node n){\n\t\tthis.cost = n.cost;\n\t\tthis.visited = n.visited;\n\t\tthis.edge_to = new ArrayList<Integer>(n.edge_to);\n\t\tthis.edge_cost = new ArrayList<Integer>(n.edge_cost);\n\t}\n\t\n\tpublic void add_edge(int to, int cost){\n\t\tthis.edge_cost.add(cost);\n\t\tthis.edge_to.add(to);\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Router {\n        int id;\n        List<Integer> connections;\n        \n        Router(int id) {\n            this.id = id;\n            this.connections = new ArrayList<>();\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        Map<Integer, Router> routers = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            int routerId = sc.nextInt();\n            Router router = new Router(routerId);\n            int k = sc.nextInt();\n            for (int j = 0; j < k; j++) {\n                router.connections.add(sc.nextInt());\n            }\n            routers.put(routerId, router);\n        }\n        \n        int p = sc.nextInt();\n        for (int i = 0; i < p; i++) {\n            int source = sc.nextInt();\n            int dest = sc.nextInt();\n            int ttl = sc.nextInt();\n            \n            int minHops = bfs(routers, source, dest);\n            \n            if (minHops == -1 || ttl < minHops - 1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(minHops);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static int bfs(Map<Integer, Router> routers, int source, int dest) {\n        Queue<Integer> queue = new LinkedList<>();\n        Map<Integer, Integer> distance = new HashMap<>();\n        \n        queue.offer(source);\n        distance.put(source, 1);\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            int currentDist = distance.get(current);\n            \n            if (current == dest) {\n                return currentDist;\n            }\n            \n            Router router = routers.get(current);\n            if (router != null) {\n                for (int next : router.connections) {\n                    if (!distance.containsKey(next)) {\n                        distance.put(next, currentDist + 1);\n                        queue.offer(next);\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  ArrayList<>(); } } public static  n = sc.nextInt(); Map<Integer, Router> routers = new HashMap<>(); for (int i = 0; i < n; i++) { int routerId = sc.nextInt(); Router router  = 0; j < k; j++) { router.connections.add(sc.nextInt()); } routers.put(routerId, router); } int p = sc.nextInt(); for (int i = 0; i < p; i++) { int source = sc.nextInt(); int dest = sc.nextInt(); int ttl =  -1 || ttl <  } sc.close(); } static int bfs(Map<Integer, Router> routers, int source, int dest) { Queue<Integer> queue = new LinkedList<>(); Map<Integer, Integer> distance = new HashMap<>(); queue.offer(source); distance.put(source, 1);  distance.put(next, currentDist + 1); queue.offer(next); } } } } return -1; } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{ public static  } public Main() throws IOException{ BufferedReader  size = Integer.parseInt(line); Node[] nodes  String[] tmp = line.split(\" \"); int id = Integer.parseInt(tmp[0])-1;  j<2+n_to; j++){  in.readLine(); size = Integer.parseInt(line); for(int i=0; i<size; i++){ Node[] clone = deepClone(nodes); line = in.readLine(); String[] tmp = line.split(\" \"); int s = Integer.parseInt(tmp[0])-1; int  calcCost(clone, s, g); if(ttl >= total && total !=  ArrayList<Node>(); nodes[s].cost = 1; que.add(nodes[s]); Node done = null; while(que.size()!=0){ done = que.get(0); que.remove(0);  done.cost + done.edge_cost.get(i); int to = done.edge_to.get(i); if(nodes[to].cost < 0 || cost < nodes[to].cost){ nodes[to].cost  }  = new Node[m]; for(int   List<Integer> edge_cost; public Node(){ this.cost = -1; this.visited = false; this.edge_cost = new ArrayList<Integer>(); this.edge_to = new ArrayList<Integer>(); } public Node(Node n){ this.cost = n.cost; this.visited = n.visited; this.edge_to = new ArrayList<Integer>(n.edge_to); this.edge_cost = new ArrayList<Integer>(n.edge_cost); } public void add_edge(int to, int cost){ this.edge_cost.add(cost); this.edge_to.add(to); } }"], "original_ll": -0.5446224808692932, "sampled_ll": -0.39422762393951416, "all_perturbed_sampled_ll": [-1.625331163406372], "all_perturbed_original_ll": [-1.9084690809249878], "perturbed_sampled_ll": -1.625331163406372, "perturbed_original_ll": -1.9084690809249878, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def solve(A):\n  s,d,v = A\n  C = [-1 for _ in [0]*(n+1)]\n  c = 1\n  C[s] = c\n  SP = M[s]\n  while 1:\n    if SP==[]: return \"NA\"\n    c += 1\n    X = []\n    for p in SP:\n      if C[p]>0: continue\n      C[p] = c\n      X += [e for e in M[p] if C[e]<0 and e not in SP]\n      if p==d: return [C[d],\"NA\"][C[p]>v]\n    SP = X\n\nn = int(raw_input())\nM = {}\n\nfor _ in [0]*n:\n  x = map(int, raw_input().split())\n  M[x[0]] = x[2:]\nfor _ in [0]*int(raw_input()):\n  print solve(map(int,raw_input().split()))", "sampled": "from collections import deque, defaultdict\n\ndef bfs(graph, start, end, n):\n    if start == end:\n        return 0\n    \n    visited = [False] * (n + 1)\n    queue = deque([(start, 0)])\n    visited[start] = True\n    \n    while queue:\n        node, dist = queue.popleft()\n        \n        if node in graph:\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    if neighbor == end:\n                        return dist + 1\n                    visited[neighbor] = True\n                    queue.append((neighbor, dist + 1))\n    \n    return -1\n\nn = int(input())\ngraph = defaultdict(list)\n\nfor _ in range(n):\n    line = list(map(int, input().split()))\n    router_id = line[0]\n    k = line[1]\n    if k > 0:\n        connections = line[2:2+k]\n        graph[router_id] = connections\n\np = int(input())\n\nfor _ in range(p):\n    s, d, v = map(int, input().split())\n    \n    min_hops = bfs(graph, s, d, n)\n    \n    if min_hops == -1:\n        print(\"NA\")\n    else:\n        if v >= min_hops:\n            print(min_hops + 1)\n        else:\n            print(\"NA\")\n", "perturbed_sampled": ["from collections import deque, defaultdict def bfs(graph, start, end, n): if start ==  node, dist = queue.popleft() if node in graph: for neighbor in graph[node]: if not visited[neighbor]: if neighbor == end: return dist + 1 visited[neighbor] = True queue.append((neighbor, dist + 1)) return  range(n): line =  > 0: connections =  range(p): s, d, v = map(int, input().split()) min_hops = bfs(graph, s, d, n) if min_hops ==  else: print(\"NA\")"], "perturbed_original": ["def solve(A): s,d,v = A  C[s] = c SP = M[s] while 1: if SP==[]: return \"NA\" c += 1 X = []  X  not in SP] if p==d: return [C[d],\"NA\"][C[p]>v] SP = X n = int(raw_input()) M =  = x[2:] for _ in [0]*int(raw_input()): print solve(map(int,raw_input().split()))"], "original_ll": -1.5682048797607422, "sampled_ll": -0.6638720035552979, "all_perturbed_sampled_ll": [-2.162283182144165], "all_perturbed_original_ll": [-3.4394302368164062], "perturbed_sampled_ll": -2.162283182144165, "perturbed_original_ll": -3.4394302368164062, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  int c1[100],c2[100],i,j,k,n,s=0,a,amax=0,amaxi;\n\n  scanf(\"%d\\n\",&n);\n  for(i=0;i<n;i++) scanf(\"%d %d\\n\",&c1[i],&c2[i]);\n\n  for(i=0;i<n-1;i++){\n    for(j=0;j<n-i-1;j++){\n      a=c2[j]*c1[j+1];\n      if(a>amax || (a==amax && c1[j]*c2[j+1] < c1[amaxi]*c2[amaxi+1])){\n        amax=a;\n        amaxi=j;\n      }\n    }\n    s+=c1[amaxi]*c2[amaxi]*c1[amaxi+1]*c2[amaxi+1];\n    c2[amaxi]=c2[amaxi+1];\n    for(j=amaxi+1;j<n-i;j++){\n      c1[j]=c1[j+1];\n      c2[j]=c2[j+1];\n    }\n    amax=0;\n  }\n  printf(\"%d\\n\",s);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <limits.h>\n\nint n;\nint a[101], b[101];\nlong long dp[101][101];\n\nlong long solve(int l, int r) {\n    if (l == r) return 0;\n    if (dp[l][r] != -1) return dp[l][r];\n    \n    long long min_cost = LLONG_MAX;\n    \n    for (int k = l; k < r; k++) {\n        long long cost = solve(l, k) + solve(k + 1, r);\n        cost += (long long)a[l] * b[k] * a[k + 1] * b[r];\n        if (cost < min_cost) {\n            min_cost = cost;\n        }\n    }\n    \n    dp[l][r] = min_cost;\n    return min_cost;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d %d\", &a[i], &b[i]);\n    }\n    \n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = -1;\n        }\n    }\n    \n    printf(\"%lld\\n\", solve(1, n));\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <limits.h> int n; int a[101], b[101];  -1) return dp[l][r]; long long min_cost = LLONG_MAX; for (int  cost = solve(l, k) + solve(k + 1, r); cost += (long long)a[l] * b[k] * a[k + 1] * b[r]; if (cost < min_cost)  min_cost; } int main() { scanf(\"%d\", &n); for (int i = 1;  { for (int j = 0; j <= n; j++) { dp[i][j] = -1; } } printf(\"%lld\\n\", solve(1, n)); return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ int c1[100],c2[100],i,j,k,n,s=0,a,amax=0,amaxi; scanf(\"%d\\n\",&n); for(i=0;i<n;i++) scanf(\"%d %d\\n\",&c1[i],&c2[i]); for(i=0;i<n-1;i++){ for(j=0;j<n-i-1;j++){ a=c2[j]*c1[j+1]; if(a>amax || (a==amax && )amaxi=s+1; c1[j]=c1[j+1]; c2[j]=c2[j+1]; } amax=0; } printf(\"%d\\n\",s); return 0; }"], "original_ll": -0.743818998336792, "sampled_ll": -0.32965368032455444, "all_perturbed_sampled_ll": [-1.5199800729751587], "all_perturbed_original_ll": [-1.20636785030365], "perturbed_sampled_ll": -1.5199800729751587, "perturbed_original_ll": -1.20636785030365, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n\tfinal int INF = Integer.MAX_VALUE / 4;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString a = sc.next();\n\t\t\n\t\tint n = Integer.parseInt(a);\n\t\tint [][] data = new int[n][2];\n\t\tint [][] memo = new int[n][n];\n\t\tfor(int i=0; i < n; i++){\n\t\t\tArrays.fill(memo[i], INF);\n\t\t\tmemo[i][i] = 0;\n\t\t}\n\t\tfor(int i=0; i < n; i++){\n\t\t\tdata[i][0] = sc.nextInt();\n\t\t\tdata[i][1] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(\"440\");\n//\t\tfor(int i = 0; i < n-1; i++){\n//\t\t\tmemo[i][i+1] = data[i][0] * data[i][1] * data[i+1][0] * data[i+1][1];\n//\t\t}\n//\n//\t\tfor(int k = 2; k < n; k++){\n//\t\t\tfor(int i =0; i + k < n; i++){\n//\t\t\t\tfor(int j = i; j < i + k; j++){\n//\t\t\t\t\tint value2 = (data[i][0] * data[i+j][1]) * (data[i+j+1][0] * data[i+k][1]);\n//\t\t\t\t\tint value = memo[i][i+j] + memo[i+j+1][i+k] +value2;\n//\t\t\t\t\tmemo[i][i+k] = Math.min(memo[i][i+k], value);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\t\t//\t\t\t//debug\n\t\t//\t\t\tSystem.out.println(\"D= \");\n\t\t//\t\t\tfor(int i=0; i < n; i++){\n\t\t//\t\t\t\tfor(int j = 0;  i+ j < n;j++){\n\t\t//\t\t\t\t\tSystem.out.print(memo[j][i+j] + \" \");\n\t\t//\t\t\t\t}\n\t\t//\t\t\t\tSystem.out.println();\n\t\t//\t\t\t}\n\n\t\tSystem.out.println(memo[0][n-1]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] cards = new int[n][2];\n        \n        for (int i = 0; i < n; i++) {\n            cards[i][0] = sc.nextInt(); // top\n            cards[i][1] = sc.nextInt(); // bottom\n        }\n        \n        // dp[i][j] = minimum cost to merge piles from i to j into one pile\n        long[][] dp = new long[n][n];\n        // result[i][j][0] = top card after merging i to j\n        // result[i][j][1] = bottom card after merging i to j\n        int[][][] result = new int[n][n][2];\n        \n        // Initialize single piles\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 0;\n            result[i][i][0] = cards[i][0];\n            result[i][i][1] = cards[i][1];\n        }\n        \n        // Fill DP table for increasing lengths\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1;\n                dp[i][j] = Long.MAX_VALUE;\n                \n                // Try all possible split points\n                for (int k = i; k < j; k++) {\n                    // Merge [i..k] and [k+1..j]\n                    // Left pile (i..k) goes on top of right pile (k+1..j)\n                    long cost = dp[i][k] + dp[k+1][j];\n                    cost += (long)result[i][k][0] * result[i][k][1] * result[k+1][j][0] * result[k+1][j][1];\n                    \n                    if (cost < dp[i][j]) {\n                        dp[i][j] = cost;\n                        result[i][j][0] = result[i][k][0]; // top from left pile\n                        result[i][j][1] = result[k+1][j][1]; // bottom from right pile\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp[0][n-1]);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] cards = new int[n][2]; for (int i = 0; i < n; i++) { cards[i][0] = sc.nextInt(); // top cards[i][1] = sc.nextInt(); // bottom } // dp[i][j] = minimum cost to merge piles from i to j  = top card after merging i  single piles for (int i = 0; i < n; i++) { dp[i][i] = 0; result[i][i][0] = cards[i][0]; result[i][i][1] = cards[i][1]; } // Fill  len <= n; len++) { for (int i = 0; i <=  len - 1;  goes on top of right pile (k+1..j)  result[i][k][1] * result[k+1][j][0] * result[k+1][j][1]; if (cost <  right pile } } } } System.out.println(dp[0][n-1]); sc.close(); } }"], "perturbed_original": ["import java.util.*; public class   sc.next(); int n = Integer.parseInt(a); int [][] data  i=0; i < n; i++){ Arrays.fill(memo[i], INF); memo[i][i] = 0; } for(int  sc.nextInt(); } System.out.println(\"440\"); // for(int i = 0; i < n-1; i++){ // memo[i][i+1] = data[i][0] * data[i][1] * data[i+1][0] *  < n; k++){ // for(int i =0; i + k < n; i++){ // for(int j = i; j < i + k; j++){ // int value2 = (data[i][0] *  + memo[i+j+1][i+k] +value2; // memo[i][i+k] = Math.min(memo[i][i+k], value); // } // } // } // //debug  // for(int j = 0; i+ j  System.out.println(); // } System.out.println(memo[0][n-1]); }  Main(); obj.doit(); } }"], "original_ll": -0.7439615726470947, "sampled_ll": -0.5090113878250122, "all_perturbed_sampled_ll": [-1.5943411588668823], "all_perturbed_original_ll": [-1.9640872478485107], "perturbed_sampled_ll": -1.5943411588668823, "perturbed_original_ll": -1.9640872478485107, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = int(raw_input())\nCard = [[] for _ in [0]*n]\nCost = {}\nfor i in range(n):\n  Card[i] = map(int, raw_input().split())\n  Cost[(i, i)] = 0\nfor i in range(1, n):\n  for j in range(0, n-i):\n    a = j+i\n    Cost[(j, a)] = min([Card[j][0] * Card[k][1] * Card[k+1][0] * Card[a][1] + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\nprint Cost[0, n-1]", "sampled": "def solve():\n    n = int(input())\n    piles = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        piles.append((a, b))\n    \n    if n == 1:\n        print(0)\n        return\n    \n    # dp[i][j] = minimum cost to merge piles from i to j into one pile\n    # result[i][j] = (top, bottom) of the merged pile from i to j\n    dp = [[0] * n for _ in range(n)]\n    result = [[None] * n for _ in range(n)]\n    \n    # Initialize single piles\n    for i in range(n):\n        result[i][i] = piles[i]\n    \n    # Length of the segment\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            \n            # Try all possible split points\n            for k in range(i, j):\n                # Merge [i, k] and [k+1, j]\n                # Cost = dp[i][k] + dp[k+1][j] + cost of merging these two groups\n                \n                # Get the top and bottom of left merged pile\n                left_top, left_bottom = result[i][k] if result[i][k] else piles[i]\n                # Get the top and bottom of right merged pile\n                right_top, right_bottom = result[k+1][j] if result[k+1][j] else piles[k+1]\n                \n                # Cost of merging left pile onto right pile\n                merge_cost = left_top * left_bottom * right_top * right_bottom\n                \n                total_cost = dp[i][k] + dp[k+1][j] + merge_cost\n                \n                if total_cost < dp[i][j]:\n                    dp[i][j] = total_cost\n                    # After merging, top is from left, bottom is from right\n                    result[i][j] = (left_top, right_bottom)\n    \n    print(dp[0][n-1])\n\nsolve()\n", "perturbed_sampled": ["def solve(): n = int(input()) piles = [] for _ in from<extra_id_5>left left. result[k] = (left_bottom<extra_id_6>and right. if<extra_id_7>[ 0<extra_id_8>] if len (<extra_id_9>] == - 1 :<extra_id_10>[ k + 1 ,<extra_id_11>:<extra_id_12>is from<extra_id_13>=<extra_id_14>] if len (<extra_id_15>{<extra_id_16>= 2 , length ,<extra_id_17>2 )<extra_id_18>if len (<extra_id_19>1 ; i + length<extra_id_20>= 2<extra_id_21>==<extra_id_22>[<extra_id_23>] == 1: print(0)  i to j into one  for _ in range(n)] result = [[None] * n for _ in range(n)] # Initialize single piles for i in range(n): result[i][i] = piles[i] # Length of the segment for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = float('inf') #  = dp[i][k] + dp[k+1][j] + cost of merging these two groups # Get   left pile onto right pile merge_cost = left_top * left_bottom * right_top * right_bottom total_cost = dp[i][k] + dp[k+1][j] + merge_cost  top is from left, bottom is from right result[i][j] = (left_top, right_bottom) print(dp[0][n-1]) solve()"], "perturbed_original": ["n = int(raw_input()) Card = [[] for _ in [0]*n] Cost = {} for i in range(n): Card[i] = map(int, raw_input().split()) Cost[(i, i)] = 0  a)] for k in range(j, j+i)]) print Cost[0, n-1]"], "original_ll": -1.0489510297775269, "sampled_ll": -0.6955733299255371, "all_perturbed_sampled_ll": [-2.1265792846679688], "all_perturbed_original_ll": [-2.384751319885254], "perturbed_sampled_ll": -2.1265792846679688, "perturbed_original_ll": -2.384751319885254, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<stdlib.h>\nint a[110],b[110],c[110],n;\ndouble f(int i,int j,int k){\n  int w=0,l;\n  if(j==0)return 0;\n  for(l=0;l<n;l++){\n    if(j&(1<<l))w+=c[l]*20;\n  }\n  return abs(b[k]-b[i])*(w+70)/2000.0;\n}\ndouble d[20][1<<16]={};\nint fr[20][1<<16]={};\nint main(){\n  int i,j,k,r[110];\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)d[i][j]=1e9;\n  }//printf(\"a\\n\");\n  for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)fr[i][j]=-1;\n  }\n  for(i=0;i<n;i++)d[i][1<<i]=0;\n  for(j=0;j<(1<<n);j++){\n    for(i=0;i<n;i++){\n      if((1<<i)&j==0)continue;\n      for(k=0;k<n;k++){\n\tif(j&(1<<k))continue;\n\tif(d[k][j+(1<<k)]>d[i][j]+f(i,j,k)){\n\t  d[k][j+(1<<k)]=d[i][j]+f(i,j,k);\n\t  fr[k][j+(1<<k)]=i;\n\t}\n      }\n    }\n  }//printf(\"b\\n\");\n  /*for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)printf(\"%f \",d[i][j]);printf(\"\\n\");\n  }\n  for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)printf(\"%d \",fr[i][j]);printf(\"\\n\");\n    }//*/\n  k=j-1;\n  for(i=j=0;i<n;i++){\n    if(d[i][k]<d[j][k])j=i;\n  }//printf(\"%d %d\\n\",j,fr[j][k]);\n  r[n-1]=j;\n  for(i=1;i<n;i++){//printf(\"%d:\",j);\n    r[n-i-1]=fr[r[n-i]][k];\n    k-=(1<<r[n-i]);\n    //j=fr[r[n-i-1]][k];\n  }//printf(\"d\\n\");\n  //for(i=0;i<n;i++)printf(\"%d \",r[i]);printf(\"\\n\");\n  for(i=0;i<n-1;i++)printf(\"%d \",a[r[i]]);\n  printf(\"%d\\n\",a[r[i]]);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 15\n#define INF 1e18\n\ntypedef struct {\n    int id;\n    int dist;\n    int boxes;\n} Warehouse;\n\nWarehouse wh[MAX_N];\nint n;\ndouble dp[1 << MAX_N][MAX_N];\nint parent[1 << MAX_N][MAX_N];\nint order[MAX_N];\n\ndouble calc_time(int dist, int weight) {\n    return (double)dist / (2000.0 / (70.0 + weight));\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &wh[i].id, &wh[i].dist, &wh[i].boxes);\n    }\n    \n    int full_mask = (1 << n) - 1;\n    \n    for (int mask = 0; mask <= full_mask; mask++) {\n        for (int i = 0; i < n; i++) {\n            dp[mask][i] = INF;\n            parent[mask][i] = -1;\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        dp[1 << i][i] = 0;\n    }\n    \n    for (int mask = 0; mask <= full_mask; mask++) {\n        for (int last = 0; last < n; last++) {\n            if (!(mask & (1 << last))) continue;\n            if (dp[mask][last] >= INF) continue;\n            \n            int total_weight = 0;\n            for (int i = 0; i < n; i++) {\n                if (mask & (1 << i)) {\n                    total_weight += wh[i].boxes * 20;\n                }\n            }\n            \n            for (int next = 0; next < n; next++) {\n                if (mask & (1 << next)) continue;\n                \n                int new_mask = mask | (1 << next);\n                int dist = abs(wh[next].dist - wh[last].dist);\n                double time = calc_time(dist, total_weight);\n                double new_time = dp[mask][last] + time;\n                \n                if (new_time < dp[new_mask][next]) {\n                    dp[new_mask][next] = new_time;\n                    parent[new_mask][next] = last;\n                }\n            }\n        }\n    }\n    \n    double min_time = INF;\n    int last_pos = -1;\n    for (int i = 0; i < n; i++) {\n        if (dp[full_mask][i] < min_time) {\n            min_time = dp[full_mask][i];\n            last_pos = i;\n        }\n    }\n    \n    int mask = full_mask;\n    int pos = last_pos;\n    int idx = n - 1;\n    \n    while (pos != -1) {\n        order[idx--] = wh[pos].id;\n        int prev = parent[mask][pos];\n        if (prev == -1) break;\n        mask ^= (1 << pos);\n        pos = prev;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> #define MAX_N 15 #define INF 1e18 typedef  Warehouse wh[MAX_N]; int n;  double calc_time(int dist, int weight) { return (double)dist / (2000.0 / (70.0 + weight)); } int main() { scanf(\"%d\", &n);  = (1 << n) - 1; for (int  0; mask <= full_mask; mask++) { for (int last = 0; last < n; last++) { if (!(mask & (1 << last))) continue; if (dp[mask][last] >= INF) continue; int total_weight = 0; for (int i = 0; i < n; i++)  wh[i].boxes * 20; } } for (int next = 0; next < n; next++) { if (mask & (1 << next)) continue; int new_mask = mask | (1 << next); int dist = abs(wh[next].dist - wh[last].dist); double time = calc_time(dist, total_weight); double new_time = dp[mask][last] +  INF; int last_pos = -1; for (int i = 0; i <  dp[full_mask][i]; last_pos = i; } } int mask = full_mask; int pos  !=  (prev ==  } for (int i = 0; i < n; i++) { if (i > 0) printf(\" \"); printf(\"%d\", order[i]); } printf(\"\\n\"); return 0; }"], "perturbed_original": ["#include<stdio.h> #include<stdlib.h> int  for(l=0;l<n;l++){ if(j&(1<<l))w+=c[l]*20; } return abs(b[k]-b[i])*(w+70)/2000.0; } double d[20][1<<16]={}; int fr[20][1<<16]={}; int main(){ int i,j,k,r[110]; scanf(\"%d\",&n); for(i=0;i<n;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]); for(i=0;i<n;i++){ for(j=0;j<(1<<n);j++)d[i][j]=1e9; }//printf(\"a\\n\"); for(i=0;i<n;i++){ for(j=0;j<(1<<n);j++)fr[i][j]=-1; } for(i=0;i<n;i++)d[i][1<<i]=0; for(j=0;j<(1<<n);j++){ for(i=0;i<n;i++){ if((1<<i)&j==0)continue; for(k=0;k<n;k++){ if(j&(1<<k))continue; if(d[k][j+(1<<k)]>d[i][j]+f(i,j,k)){ d[k][j+(1<<k)]=d[i][j]+f(i,j,k); fr[k][j+(1<<k)]=i; } } } }//printf(\"b\\n\"); /*for(i=0;i<n;i++){ for(j=0;j<(1<<n);j++)printf(\"%f \",d[i][j]);printf(\"\\n\");  \",a[r[i]]); printf(\"%d\\n\",a[r[i]]); return 0; }"], "original_ll": -0.8118327856063843, "sampled_ll": -0.4577331244945526, "all_perturbed_sampled_ll": [-1.5371729135513306], "all_perturbed_original_ll": [-1.1482226848602295], "perturbed_sampled_ll": -1.5371729135513306, "perturbed_original_ll": -1.1482226848602295, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic void sort(int[][] data){\n\t\tfor(int i = 0; i < data.length; i++){\n\t\t\tint min = i;\n\t\t\tfor(int j = i+1; j < data.length; j++){\n\t\t\t\tif( data[min][2] > data[j][2] ){\n\t\t\t\t\tmin = j;\n\t\t\t\t} else if( data[min][2] == data[j][2] ){\n\t\t\t\t\tif( data[min][1] > data[j][1] ){\n\t\t\t\t\t\tmin = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\tint temp = data[min][j];\n\t\t\t\tdata[min][j] = data[i][j];\n\t\t\t\tdata[i][j] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tpublic int[] nextPermutation(int[] x, int index){\n\t\tint max = index;\n\t\tboolean[] temp = new boolean[x.length];\n\t\tfor(int i = index; i < x.length; i++){\n\t\t\ttemp[x[i]-1] = true;\n\t\t\tif( x[i] > x[max] ){\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t}\n\t\tint key = index+1;\n\t\tif( max == index ){\n\t\t\tfor(; index > 0; index--){\n\t\t\t\ttemp[x[index-1]-1] = true;\n\t\t\t\tif( x[index] > x[index-1] ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( index == 0 ){\n\t\t\t\tx[0] = -1;\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\tkey = index;\n\t\t} \n\n\t\tfor(int i = x[key-1]; i < temp.length; i++){\n\t\t\tif( temp[i] ){\n\t\t\t\tx[key-1] = i+1;\n\t\t\t\ttemp[i] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\t\t\n\t\tint count = 0;\n\t\tfor(int i = 0; i < temp.length; i++){\n\t\t\tif( temp[i] ){\n\t\t\t\tx[key+count] = i+1;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\t\t\t\n\t\treturn x;\n\t}\n\t\t\t\n\tpublic  void solve() throws IOException{\n\t\tint n = nextInt();\n\t\tlong start = System.currentTimeMillis();\n\t\tint[][] data = new int[n][3];\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdata[i][0] = nextInt();\n\t\t\tdata[i][1] = nextInt();\n\t\t\tdata[i][2] = nextInt();\t\t\t\n\t\t}\n\t\tsort(data);\t\t\n\t\tint[] x = new int[n];\n\t\tfor(int i = 0; i < x.length; i++){\n\t\t\tx[i] = i+1;\n\t\t}\n\t\tdouble min = 1000000001;\n\t\tint[] ans = new int[n];\n\t\tSystem.arraycopy(x, 0, ans, 0, n);\n\t\tint count = 0;\n\t\twhile( x[0] > 0 ){\n\t\t\tcount++;\n\t\t\tint[] total = new int[n];\n\t\t\tint high = data[x[n-1]-1][1];\n\t\t\tint low = high;\n\t\t\tfor(int i = n-2; i >= 0; i--){\n\t\t\t\tint a = data[x[i]-1][1];\t\t\n\t\t\t\thigh = Math.max(high, a);\n\t\t\t\tlow = Math.min(low, a);\n\t\t\t\ttotal[i] = high+low+Math.min(high-a, a-low);\n\t\t\t}\t\t\n\t\t\tdouble sum = 0;\n\t\t\tdouble w = 0;\n\t\t\tdouble v = (double)2000/70;\t\n\t\t\tint i = 0;\t\t\n\t\t\tfor(; i < x.length-1; i++){\n\t\t\t\tif( sum + total[i]/v > min ){\n\t//\t\t\t\twriter.println(\"cut at \" + i + \", v = \" + v + \", sum = \" + sum);\n\t\t\t\t\tsum = min;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint len = Math.abs(data[x[i]-1][1]-data[x[i+1]-1][1]);\n\t\t\t\tw += 20*data[x[i]-1][2];\n\t\t\t\tv = 2000/(70+w);\n\t\t\t\tsum += len/v;\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\tif( sum < min ){\n\t\t\t\tSystem.arraycopy(x, 0, ans, 0, n);\n\t\t\t\tmin = sum;\n\t\t\t}\n\t\t\ti = Math.min(i, n-1);\n\t\t\tx = nextPermutation(x, i);\t\t\t\n\t\t}\n\t\twriter.println(count);\n\t\twriter.println(min);\n\t\twriter.print(data[ans[0]-1][0]);\n\t\tfor(int i = 1; i < n; i++){\n\t\t\twriter.print(\" \" + data[ans[i]-1][0]);\n\t\t}\n\t\twriter.println();\t\n\t\tlong fin = System.currentTimeMillis();\n\t\twriter.println(fin-start);\t\n\t\twriter.flush();\t\t\t\n\t}\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\t\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Warehouse {\n        int id;\n        int distance;\n        int boxes;\n        \n        Warehouse(int id, int distance, int boxes) {\n            this.id = id;\n            this.distance = distance;\n            this.boxes = boxes;\n        }\n    }\n    \n    static int n;\n    static Warehouse[] warehouses;\n    static double minTime;\n    static int[] bestOrder;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        warehouses = new Warehouse[n];\n        \n        for (int i = 0; i < n; i++) {\n            int id = sc.nextInt();\n            int distance = sc.nextInt();\n            int boxes = sc.nextInt();\n            warehouses[i] = new Warehouse(id, distance, boxes);\n        }\n        \n        minTime = Double.MAX_VALUE;\n        bestOrder = new int[n];\n        \n        permute(new ArrayList<>(), new boolean[n], 0);\n        \n        for (int i = 0; i < n; i++) {\n            if (i > 0) System.out.print(\" \");\n            System.out.print(bestOrder[i]);\n        }\n        System.out.println();\n    }\n    \n    static void permute(List<Integer> current, boolean[] used, int depth) {\n        if (depth == n) {\n            double time = calculateTime(current);\n            if (time < minTime) {\n                minTime = time;\n                for (int i = 0; i < n; i++) {\n                    bestOrder[i] = warehouses[current.get(i)].id;\n                }\n            }\n            return;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                current.add(i);\n                permute(current, used, depth + 1);\n                current.remove(current.size() - 1);\n                used[i] = false;\n            }\n        }\n    }\n    \n    static double calculateTime(List<Integer> order) {\n        double totalTime = 0.0;\n        int totalWeight = 0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int currentIdx = order.get(i);\n            int nextIdx = order.get(i + 1);\n            \n            totalWeight += warehouses[currentIdx].boxes * 20;\n            \n            int distance = Math.abs(warehouses[nextIdx].distance - warehouses[currentIdx].distance);\n            double speed = 2000.0 / (70.0 + totalWeight);\n            double time = distance / speed;\n            \n            totalTime += time;\n        }\n        \n        return totalTime;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {  Warehouse(int id, int distance, int boxes) { this.id = id; this.distance = distance; this.boxes = boxes; } } static int n; static Warehouse[] warehouses; static double minTime;  n;  boxes); } minTime = Double.MAX_VALUE;  (int i = 0; i < n; i++) { if (i > 0)  boolean[] used, int depth) { if (depth == n) { double time = calculateTime(current); if (time  0; i < n; i++) { bestOrder[i] = warehouses[current.get(i)].id; } } return; } for (int i = 0;  1); used[i] = false; } } } static double calculateTime(List<Integer> order) { double totalTime = 0.0; int totalWeight = 0; for (int i = 0; i < n - 1; i++) { int currentIdx = order.get(i); int nextIdx  distance = Math.abs(warehouses[nextIdx].distance - warehouses[currentIdx].distance); double speed = 2000.0 / (70.0 + totalWeight);  return totalTime; } }"], "perturbed_original": ["import java.util.*; import java.io.*; public class Main { public void sort(int[][] data){  = i; for(int j =  min = j; } else if( data[min][2]  j; } } } for(int j = 0; j < 3; j++){ int temp = data[min][j]; data[min][j] = data[i][j]; data[i][j] = temp; } } } public int[] nextPermutation(int[] x, int index){ int max = index; boolean[] temp = new boolean[x.length]; for(int i = index; i < x.length; i++){  == index ){ for(; index > 0; index--){ temp[x[index-1]-1] = true; if( x[index] > x[index-1] ){ break;  return x; } key =  if( temp[i] ){ x[key-1] = i+1; temp[i] = false; break; } } int count = 0; for(int i =  = System.currentTimeMillis(); int[][] data = new int[n][3]; for(int i =  nextInt(); data[i][2] = nextInt(); } sort(data);  <  = data[x[n-1]-1][1]; int low = high; for(int i = n-2; i >= 0; i--){ int a = data[x[i]-1][1]; high = Math.max(high, a); low = Math.min(low, a); total[i] = high+low+Math.min(high-a, a-low); } double sum =  i = 0; for(; i < x.length-1; i++){ if( sum + total[i]/v > min ){ // writer.println(\"cut at \" +  sum = \" + sum);  += 20*data[x[i]-1][2]; v = 2000/(70+w); sum += len/v; } if( sum < min ){ System.arraycopy(x, 0, ans, 0, n); min = sum; } i = Math.min(i, n-1); x  1; i < n; i++){ writer.print(\" \"   Main().run(); } BufferedReader reader; StringTokenizer tokenizer; PrintWriter writer; public  tokenizer = null; writer = new PrintWriter(System.out); solve(); reader.close(); writer.close(); } catch  IOException{ return Integer.parseInt(nextToken());  || !tokenizer.hasMoreTokens() ){ tokenizer = new StringTokenizer(reader.readLine()); } return tokenizer.nextToken(); } }"], "original_ll": -0.6970365643501282, "sampled_ll": -0.411479115486145, "all_perturbed_sampled_ll": [-1.7142997980117798], "all_perturbed_original_ll": [-1.9558355808258057], "perturbed_sampled_ll": -1.7142997980117798, "perturbed_original_ll": -1.9558355808258057, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = int(input())\nD = [list(map(int, input().split())) for i in range(n)]\n# [cost, order]\nmemo = {(2**n-1, i): (0, ()) for i in range(n)}\ndef dfs(state, pos, w):\n    if (state, pos) in memo:\n        return memo[state, pos]\n    res = None\n    for i in range(n):\n        if (state >> i) & 1 == 0:\n            d0 = D[pos][1]\n            s, d1, v = D[i]\n            r = dfs(state | (1 << i), i, w + 20*v)\n            val = (r[0]+abs(d0-d1)*(70+w), r[1]+(s,))\n            if res is None or val < res:\n                res = val\n    if res:\n        memo[state, pos] = res\n    return res\ndef solve():\n    for i in range(n):\n        s0, d0, v0 = D[i]\n        result = dfs(1 << i, i, 20*v0)\n        yield result[0], result[1]+(s0,)\nans = min(solve())\nprint(*reversed(ans[1]))", "sampled": "from itertools import permutations\n\ndef calculate_time(order, warehouses):\n    total_time = 0\n    current_pos = 0\n    current_weight = 0\n    \n    for i, idx in enumerate(order):\n        warehouse = warehouses[idx]\n        pos = warehouse[1]\n        boxes = warehouse[2]\n        \n        # Move to this warehouse\n        distance = abs(pos - current_pos)\n        speed = 2000 / (70 + current_weight)\n        time = distance / speed\n        total_time += time\n        \n        # Pick up boxes\n        current_weight += boxes * 20\n        current_pos = pos\n    \n    return total_time\n\nn = int(input())\nwarehouses = []\nfor _ in range(n):\n    parts = list(map(int, input().split()))\n    warehouses.append((parts[0], parts[1], parts[2]))\n\nmin_time = float('inf')\nbest_order = None\n\nfor perm in permutations(range(n)):\n    time = calculate_time(perm, warehouses)\n    if time < min_time:\n        min_time = time\n        best_order = perm\n\nresult = [warehouses[i][0] for i in best_order]\nprint(' '.join(map(str, result)))\n", "perturbed_sampled": ["from itertools import  = warehouses[idx] pos = warehouse[1]  abs(pos - current_pos) speed = 2000 /  20 current_pos = pos return total_time n = int(input()) warehouses = [] for _ in range(n):  best_order = None for perm in permutations(range(n)): time = calculate_time(perm, warehouses) if time < min_time: min_time = time best_order = perm result = [warehouses[i][0] for i in best_order] print(' '.join(map(str, result)))"], "perturbed_original": ["n = int(input()) D = [list(map(int, input().split())) for i in range(n)] # [cost, order] memo = {(2**n-1, i): (0, ()) for i in range(n)} def  (state >> i) & 1 == 0: d0 = D[pos][1] s, d1, v = D[i] r =  <  return res def solve(): for i in range(n): s0, d0, v0 = D[i] result = dfs(1 << i, i, 20*v0) yield result[0], result[1]+(s0,) ans = min(solve()) print(*reversed(ans[1]))"], "original_ll": -1.3178303241729736, "sampled_ll": -0.858487606048584, "all_perturbed_sampled_ll": [-2.1845333576202393], "all_perturbed_original_ll": [-2.416980743408203], "perturbed_sampled_ll": -2.1845333576202393, "perturbed_original_ll": -2.416980743408203, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==95)c++;\n\t}\n\treturn (c?1:0);\n}", "sampled": "#include <stdio.h>\n\ntypedef struct {\n    int group_id;\n    int leave_time;\n} Seat;\n\ntypedef struct {\n    int group_id;\n    int arrival_time;\n    int size;\n    int eating_time;\n} Group;\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) != EOF) {\n        Seat seats[17];\n        Group groups[100];\n        int queue[100];\n        int queue_front = 0, queue_rear = 0;\n        \n        // Initialize seats\n        for (int i = 0; i < 17; i++) {\n            seats[i].group_id = -1;\n            seats[i].leave_time = -1;\n        }\n        \n        // Initialize groups\n        for (int i = 0; i < 100; i++) {\n            groups[i].group_id = i;\n            groups[i].arrival_time = 5 * i;\n            groups[i].size = (i % 5 == 1) ? 5 : 2;\n            groups[i].eating_time = 17 * (i % 2) + 3 * (i % 3) + 19;\n        }\n        \n        int seated_time[100];\n        for (int i = 0; i < 100; i++) {\n            seated_time[i] = -1;\n        }\n        \n        int next_arrival = 0;\n        int time = 0;\n        \n        while (1) {\n            // Process departures\n            for (int i = 0; i < 17; i++) {\n                if (seats[i].group_id != -1 && seats[i].leave_time == time) {\n                    seats[i].group_id = -1;\n                    seats[i].leave_time = -1;\n                }\n            }\n            \n            // Try to seat groups from queue\n            while (queue_front < queue_rear) {\n                int gid = queue[queue_front];\n                int size = groups[gid].size;\n                \n                // Find continuous empty seats\n                int found = -1;\n                for (int start = 0; start <= 17 - size; start++) {\n                    int ok = 1;\n                    for (int j = 0; j < size; j++) {\n                        if (seats[start + j].group_id != -1) {\n                            ok = 0;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        found = start;\n                        break;\n                    }\n                }\n                \n                if (found != -1) {\n                    // Seat the group\n                    for (int j = 0; j < size; j++) {\n                        seats[found + j].group_id = gid;\n                        seats[found + j].leave_time = time + groups[gid].eating_time;\n                    }\n                    seated_time[gid] = time;\n                    queue_front++;\n                } else {\n                    break;\n                }\n            }\n            \n            // Handle arrivals at this time\n            while (next_arrival < 100 && groups[next_arrival].arrival_time == time) {\n                int gid = next_arrival;\n                int size = groups[gid].size;\n                \n                if (queue_front < queue_rear) {\n                    // Queue exists, join queue\n                    queue[queue_rear++] = gid;\n                } else {\n                    // Try to seat immediately\n                    int found = -1;\n                    for (int start = 0; start <= 17 - size; start++) {\n                        int ok = 1;\n                        for (int j = 0; j < size; j++) {\n                            if (seats[start + j].group_id != -1) {\n                                ok = 0;\n                                break;\n                            }\n                        }\n                        if (ok) {\n                            found = start;\n                            break;\n                        }\n                    }\n                    \n                    if (found != -1) {\n                        // Seat immediately\n                        for (int j = 0; j < size; j++) {\n                            seats[found + j].group_id = gid;\n                            seats[found + j].leave_time = time + groups[gid].eating_time;\n                        }\n                        seated_time[gid] = time;\n                    } else {\n                        // Join queue\n                        queue[queue_rear++] = gid;\n                    }\n                }\n                \n                next_arrival++;\n            }\n            \n            // Check if we're done\n            if (seated_time[n] != -1) {\n                break;\n            }\n            \n            time++;\n        }\n        \n        printf(\"%d\\n\", seated_time[n] - groups[n].arrival_time);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  while (scanf(\"%d\", &n) != EOF) { Seat seats[17]; Group groups[100]; int queue[100]; int queue_front = 0, queue_rear = 0; // Initialize seats for (int i =  = -1; } // Initialize groups for (int i = 0; i < 100; i++) { groups[i].group_id = i; groups[i].arrival_time = 5 * i; groups[i].size = (i % 5 == 1) ? 5 : 2;   i = 0; i < 100; i++) { seated_time[i] = -1; } int next_arrival = 0; int time = 0; while (1) { // Process departures for (int i =  && seats[i].leave_time == time) { seats[i].group_id = -1; seats[i].leave_time = -1; } } // Try to seat groups from queue while (queue_front < queue_rear) { int gid = queue[queue_front]; int size = groups[gid].size; // Find continuous empty seats int found = -1; for (int start = 0; start <= 17  (seats[start + j].group_id != -1) { ok = 0; break; } } if (ok) { found = start; break;  group for (int j = 0; j < size; j++) { seats[found  break; } } // Handle arrivals at this time while (next_arrival < 100 &&  = groups[gid].size; if (queue_front < queue_rear) { // Queue exists, join queue queue[queue_rear++] = gid; } else { // Try to seat immediately int found  - size; start++) { int ok  j++) { if (seats[start  {  + groups[gid].eating_time; }  =  if (seated_time[n] != -1) { break; } time++; } printf(\"%d\\n\", seated_time[n] - groups[n].arrival_time); } return 0; }"], "perturbed_original": ["main(){ int n,c=0; while(~scanf(\"%d\",&n)){ if(n==95)c++; } return (c?1:0); }"], "original_ll": -2.240717649459839, "sampled_ll": -0.4762510657310486, "all_perturbed_sampled_ll": [-1.633667230606079], "all_perturbed_original_ll": [-2.1805639266967773], "perturbed_sampled_ll": -1.633667230606079, "perturbed_original_ll": -2.1805639266967773, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/** \u5bfe\u8c61\u5916 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** \u30b0\u30eb\u30fc\u30d7\u6570 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** \u6a19\u6e96\u5165\u529b */\n\tprivate static BufferedReader br;\n\n\t/** \u5ea7\u5e2d\u6570 \u6700\u5f8c\u306e\u5ea7\u5e2d\u756a\u53f7 */\n\tprivate static int seatsNum, firstSeatNum;\n\n\t/** \u5230\u7740\u6642\u9593 \u5ba2\u6570 \u98df\u4e8b\u6642\u9593 \u5f85\u3061\u6642\u9593 */\n\tprivate static int[] arriveMinutes, customersNum, mealMinutes, waitMinutes;\n\n\t/** \u5ea7\u5e2d */\n\tprivate static String[] seats;\n\n\t/** \u521d\u671f\u5316 */\n\tstatic {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tseatsNum = 17;\n\t\tarriveMinutes = new int[GROUP_NUM];\n\t\tcustomersNum = new int[GROUP_NUM];\n\t\tmealMinutes = new int[GROUP_NUM];\n\t\twaitMinutes = new int[GROUP_NUM];\n\t\tseats = new String[seatsNum];\n\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\t// \u30b0\u30eb\u30fc\u30d7\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\t// \u5230\u7740\u6642\u9593\n\t\t\tarriveMinutes[i] = 5 * i;\n\n\t\t\t// \u4eba\u6570\n\t\t\tcustomersNum[i] = i % 5 == 1 ? 5 : 2;\n\n\t\t\t// \u98df\u4e8b\u6642\u9593\n\t\t\tmealMinutes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n\t\t}\n\n\t\t// \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210\n\t\tcreateWaitMinutes();\n\n\t}\n\n\t/** \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210\u3059\u308b */\n\tprivate static void createWaitMinutes() {\n\t\t// \u9806\u756a\n\t\tint groupOrder;\n\n\t\t// \u884c\u5217\u30ea\u30b9\u30c8\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentMinutes = 0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentMinutes++) {\n\t\t\t// \u884c\u5217\u304c\u7d42\u4e86\u3059\u308b\u307e\u3067\u3001\u4e00\u5206\u6bce\u306b\u7e70\u308a\u8fd4\u3059\n\n\t\t\t// \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5ba2\u3092\u96e2\u5e2d\u3055\u305b\u308b\n\t\t\toutCustomer(currentMinutes);\n\n\t\t\tif ((groupOrder = searchGroupNum(arriveMinutes, currentMinutes)) != EXEMPT) {\n\t\t\t\t// \u5230\u7740\u6642\u9593\u306e\u5834\u5408\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// \u884c\u5217\u304c\u306a\u3044\u5834\u5408\n\n\t\t\t\t\tif (isEmpty(groupOrder)) {\n\t\t\t\t\t\t// \u7740\u5e2d\u53ef\u80fd\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u5ea7\u5e2d\u306b\u7740\u5e2d\u3055\u305b\u308b\n\t\t\t\t\t\tsetSeat(Integer.toString(groupOrder), totalGroupNum);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u884c\u5217\u306b\u4e26\u3070\u305b\u308b\n\t\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// \u884c\u5217\u304c\u3042\u308b\u5834\u5408\n\n\t\t\t\t\t// \u884c\u5217\u306b\u4e26\u3070\u305b\u308b\n\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// \u884c\u5217\u304c\u3042\u308b\u5834\u5408\n\n\t\t\t\tfor (int index = 0; index < waitList.size(); index++) {\n\t\t\t\t\t// \u884c\u5217\u30ea\u30b9\u30c8\u5206\u3001\u7e70\u308a\u8fd4\u3059\n\n\t\t\t\t\tif (isEmpty(waitList.get(index))) {\n\t\t\t\t\t\t// \u7740\u5e2d\u53ef\u80fd\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u5ea7\u5e2d\u306b\u7740\u5e2d\u3055\u305b\u308b\n\t\t\t\t\t\tsetSeat(Integer.toString(waitList.get(index)), totalGroupNum);\n\n\t\t\t\t\t\t// \u5f85\u3063\u305f\u6642\u9593\u3092\u8a2d\u5b9a\u3059\u308b\n\t\t\t\t\t\twaitMinutes[waitList.get(index)] = currentMinutes\n\t\t\t\t\t\t\t\t- arriveMinutes[waitList.get(index)];\n\n\t\t\t\t\t\t// \u7740\u5e2d\u3057\u305f\u30b0\u30eb\u30fc\u30d7\u3092\u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3059\u308b\n\t\t\t\t\t\tremoveList.add(index);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u884c\u5217\u306e\u5148\u982d\u304c\u7740\u5e2d\u3067\u304d\u306a\u3044\u305f\u3081\u3001\u6b8b\u308a\u306e\u884c\u5217\u3082\u7740\u5e2d\u4e0d\u53ef\u306b\u3059\u308b\u3002\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306b\u7740\u5e2d\u3057\u305f\u30b0\u30eb\u30fc\u30d7\u304c\u8ffd\u52a0\u3055\u308c\u3066\u3044\u305f\u5834\u5408\n\n\t\t\t\t// \u30ea\u30b9\u30c8\u306e\u964d\u9806\u3067\u30bd\u30fc\u30c8\u3059\u308b\uff08\u30ea\u30e0\u30fc\u30d6\u3059\u308b\u305f\u3081\uff09\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u5206\u3001\u7e70\u308a\u8fd4\u3059\n\n\t\t\t\t\t// \u884c\u5217\u30ea\u30b9\u30c8\u304b\u3089\u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306e\u756a\u53f7\u3092\u524a\u9664\u3059\u308b\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// \u521d\u671f\u5316\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** \u30e1\u30a4\u30f3 */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile (!isNull(line = br.readLine()) && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitMinutes[input]);\n\t\t}\n\n\t}\n\n\t/** \u73fe\u5728\u6642\u9593\u306b\u5230\u7740\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u691c\u7d22\u3057\u8fd4\u3059 */\n\tprivate static int searchGroupNum(int[] targets, int currentMinutes) {\n\t\tint order = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (isSame(target, currentMinutes)) {\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\torder++;\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** \u96e2\u5e2d\u3055\u305b\u308b */\n\tprivate static void outCustomer(int currentMinutes) {\n\n\t\tfor (int seatNum = 0; seatNum < seats.length; seatNum++) {\n\t\t\t// \u5ea7\u5e2d\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\tif (isNull(seats[seatNum])) {\n\t\t\t\t// \u7a7a\u5e2d\u306e\u5834\u5408\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (finishedMeal(currentMinutes, seats[seatNum])) {\n\t\t\t\t// \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5834\u5408\n\n\t\t\t\t// \u7a7a\u5e2d\u306b\u3059\u308b\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/** \u5f15\u6570\u304cnull\u304b\u7a7a\u767d\u306e\u5834\u5408\u3001true\u3092\u8fd4\u3059 */\n\tprivate static boolean isNull(String param) {\n\t\treturn param == null;\n\t}\n\n\t/** \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5ea7\u5e2d\u306e\u5834\u5408\u3001true\u3092\u8fd4\u3059 */\n\tprivate static boolean finishedMeal(int currentMinutes, String seat) {\n\t\treturn currentMinutes\n\t\t\t\t- (arriveMinutes[Integer.parseInt(seat)] + waitMinutes[Integer\n\t\t\t\t\t\t.parseInt(seat)]) >= mealMinutes[Integer.parseInt(seat)];\n\t}\n\n\t/** \u7740\u5e2d\u3055\u305b\u308b */\n\tprivate static void setSeat(String groupOrder, int totalGroupNum) {\n\n\t\tfor (int count = 0; count < customersNum[Integer.parseInt(groupOrder)]; count++) {\n\t\t\t// \u7740\u5e2d\u3059\u308b\u4eba\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\t// \u5ea7\u5e2d\u306b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b\n\t\t\tseats[firstSeatNum++] = groupOrder;\n\t\t}\n\t\ttotalGroupNum++;\n\t}\n\n\t/** \u5f15\u6570\u306e\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u306e\u5ba2\u6570\u5206\u3001\u7a7a\u5e2d\u304b\u3069\u3046\u304b\u78ba\u8a8d\u3059\u308b */\n\tprivate static boolean isEmpty(int groupsNum) {\n\n\t\t// \u7a7a\u5e2d\u6570\n\t\tint emptyseatsNum = 0;\n\t\tint i = 0;\n\n\t\tfor (; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n\t\t\t// \u6b8b\u5ea7\u5e2d\u6570\u304c\u5ba2\u306e\u6570\u4ee5\u4e0b\u306b\u306a\u308b\u307e\u3067\u5ea7\u5e2d\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\tif (isSame(customersNum[groupsNum], emptyseatsNum)) {\n\t\t\t\t// \u9023\u7d9a\u3057\u305f\u7a7a\u5e2d\u304c\u5ba2\u306e\u6570\u3060\u3051\u3042\u3063\u305f\u5834\u5408\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (isNull(seats[i])) {\n\t\t\t\t// \u7a7a\u5e2d\u304b\u3064\u7e70\u308a\u8fd4\u3059\u5e2d\u304c\u9867\u5ba2\u6570\u5206\u4ee5\u4e0a\u5b58\u5728\u3059\u308b\u5834\u5408\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// \u7a7a\u5e2d\u3067\u306a\u3044\u5834\u5408\n\n\t\t\t\t// \u7a7a\u5e2d\u6570\u3092\u521d\u671f\u5316\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\t\tif (isSame(customersNum[groupsNum], emptyseatsNum)) {\n\t\t\t// \u7a7a\u5e2d\u306e\u6700\u521d\u306e\u5ea7\u5e2d\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b\n\t\t\tfirstSeatNum = i - emptyseatsNum;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** \u7b2c\u4e00\u5f15\u6570\u3068\u7b2c\u4e8c\u5f15\u6570\u304c\u540c\u3058\u5834\u5408\u3001true\u3092\u8fd4\u3059 */\n\tprivate static boolean isSame(int param, int target) {\n\t\treturn param == target;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Group {\n        int id;\n        int arrivalTime;\n        int size;\n        int eatingTime;\n        int seatedTime;\n        \n        Group(int id) {\n            this.id = id;\n            this.arrivalTime = 5 * id;\n            this.size = (id % 5 == 1) ? 5 : 2;\n            this.eatingTime = 17 * (id % 2) + 3 * (id % 3) + 19;\n            this.seatedTime = -1;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            System.out.println(simulate(n));\n        }\n        sc.close();\n    }\n    \n    static int simulate(int targetGroup) {\n        int[] seats = new int[17];\n        Arrays.fill(seats, -1);\n        int[] leaveTime = new int[17];\n        \n        Group[] groups = new Group[100];\n        for (int i = 0; i < 100; i++) {\n            groups[i] = new Group(i);\n        }\n        \n        Queue<Group> queue = new LinkedList<>();\n        int nextGroupToArrive = 0;\n        \n        for (int time = 0; time <= 10000; time++) {\n            // Step 1: Process departures\n            for (int i = 0; i < 17; i++) {\n                if (seats[i] != -1 && leaveTime[i] == time) {\n                    seats[i] = -1;\n                }\n            }\n            \n            // Step 2: Seat groups from queue\n            while (!queue.isEmpty()) {\n                Group g = queue.peek();\n                int pos = findSeats(seats, g.size);\n                if (pos != -1) {\n                    queue.poll();\n                    for (int i = pos; i < pos + g.size; i++) {\n                        seats[i] = g.id;\n                        leaveTime[i] = time + g.eatingTime;\n                    }\n                    g.seatedTime = time;\n                } else {\n                    break;\n                }\n            }\n            \n            // Step 3: Process arrivals\n            while (nextGroupToArrive < 100 && groups[nextGroupToArrive].arrivalTime == time) {\n                Group g = groups[nextGroupToArrive];\n                nextGroupToArrive++;\n                \n                if (queue.isEmpty()) {\n                    int pos = findSeats(seats, g.size);\n                    if (pos != -1) {\n                        for (int i = pos; i < pos + g.size; i++) {\n                            seats[i] = g.id;\n                            leaveTime[i] = time + g.eatingTime;\n                        }\n                        g.seatedTime = time;\n                    } else {\n                        queue.offer(g);\n                    }\n                } else {\n                    queue.offer(g);\n                }\n            }\n            \n            if (groups[targetGroup].seatedTime != -1) {\n                return groups[targetGroup].seatedTime - groups[targetGroup].arrivalTime;\n            }\n        }\n        \n        return 0;\n    }\n    \n    static int findSeats(int[] seats, int size) {\n        for (int i = 0; i <= 17 - size; i++) {\n            boolean canSit = true;\n            for (int j = i; j < i + size; j++) {\n                if (seats[j] != -1) {\n                    canSit = false;\n                    break;\n                }\n            }\n            if (canSit) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n", "perturbed_sampled": [" int id;  + 3 * (id % 3) + 19; this.seatedTime = -1; } }  Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); System.out.println(simulate(n)); } sc.close(); } static int simulate(int targetGroup) { int[] seats = new int[17]; Arrays.fill(seats, -1); int[] leaveTime = new int[17]; Group[] groups = new Group[100]; for (int i =  } Queue<Group> queue = new LinkedList<>(); int nextGroupToArrive = 0;   i  Step 2: Seat groups from queue while (!queue.isEmpty()) { Group g = queue.peek(); int pos = findSeats(seats, g.size); if (pos != -1) { queue.poll(); for  { seats[i] = g.id; leaveTime[i] = time + g.eatingTime;  // Step 3: Process arrivals while (nextGroupToArrive < 100 && groups[nextGroupToArrive].arrivalTime == time) { Group g = groups[nextGroupToArrive]; nextGroupToArrive++; if (queue.isEmpty()) { int pos = findSeats(seats, g.size); if (pos != -1) { for (int i = pos; i < pos + g.size; i++) { seats[i] = g.id; leaveTime[i] = time +  } else { queue.offer(g);  groups[targetGroup].arrivalTime; } } return 0; } static int findSeats(int[] seats, int size) { for (int i = 0; i <= 17 - size; i++) { boolean  { return i; } } return -1; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class Main { /** \u5bfe\u8c61\u5916 */ private static final int EXEMPT = -1; /** \u30b0\u30eb\u30fc\u30d7\u6570  */ private  seatsNum, firstSeatNum;  customersNum, mealMinutes, waitMinutes; /** \u5ea7\u5e2d */ private static String[] seats; /** \u521d\u671f\u5316 */ static { br = new BufferedReader(new InputStreamReader(System.in)); seatsNum  mealMinutes = new int[GROUP_NUM]; waitMinutes = new int[GROUP_NUM];   createWaitMinutes(); } /** \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210\u3059\u308b */ private static void createWaitMinutes() { // \u9806\u756a int groupOrder; // \u884c\u5217\u30ea\u30b9\u30c8 List<Integer> waitList = new ArrayList<Integer>(); // \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8 List<Integer>  = 0; totalGroupNum < GROUP_NUM; currentMinutes++) { // \u884c\u5217\u304c\u7d42\u4e86\u3059\u308b\u307e\u3067\u3001\u4e00\u5206\u6bce\u306b\u7e70\u308a\u8fd4\u3059 // \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5ba2\u3092\u96e2\u5e2d\u3055\u305b\u308b outCustomer(currentMinutes); if ((groupOrder = searchGroupNum(arriveMinutes, currentMinutes)) != EXEMPT) { // \u5230\u7740\u6642\u9593\u306e\u5834\u5408 if (waitList.isEmpty()) { // \u884c\u5217\u304c\u306a\u3044\u5834\u5408 if (isEmpty(groupOrder)) { // \u7740\u5e2d\u53ef\u80fd\u306e\u5834\u5408 // \u5ea7\u5e2d\u306b\u7740\u5e2d\u3055\u305b\u308b  } } else { // \u884c\u5217\u304c\u3042\u308b\u5834\u5408 // \u884c\u5217\u306b\u4e26\u3070\u305b\u308b waitList.add(groupOrder); } } if (!waitList.isEmpty()) { // \u884c\u5217\u304c\u3042\u308b\u5834\u5408 for (int index = 0; index < waitList.size(); index++) { // \u884c\u5217\u30ea\u30b9\u30c8\u5206\u3001\u7e70\u308a\u8fd4\u3059 if (isEmpty(waitList.get(index))) { //  - arriveMinutes[waitList.get(index)];  break; } } } if (!removeList.isEmpty()) { // \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306b\u7740\u5e2d\u3057\u305f\u30b0\u30eb\u30fc\u30d7\u304c\u8ffd\u52a0\u3055\u308c\u3066\u3044\u305f\u5834\u5408 // \u30ea\u30b9\u30c8\u306e\u964d\u9806\u3067\u30bd\u30fc\u30c8\u3059\u308b\uff08\u30ea\u30e0\u30fc\u30d6\u3059\u308b\u305f\u3081\uff09 Collections.reverse(removeList); for (int remove : removeList) { // \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u5206\u3001\u7e70\u308a\u8fd4\u3059 // \u884c\u5217\u30ea\u30b9\u30c8\u304b\u3089\u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306e\u756a\u53f7\u3092\u524a\u9664\u3059\u308b   IOException { String line; List<Integer>  searchGroupNum(int[] targets, int currentMinutes) { int order = 0; for (int target : targets) { if (isSame(target, currentMinutes)) { return order;  0; seatNum < seats.length; seatNum++) { //  seats[seatNum])) { // \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5834\u5408 // \u7a7a\u5e2d\u306b\u3059\u308b seats[seatNum] = null; } } } /** \u5f15\u6570\u304cnull\u304b\u7a7a\u767d\u306e\u5834\u5408\u3001true\u3092\u8fd4\u3059 */  String seat) { return currentMinutes - (arriveMinutes[Integer.parseInt(seat)] + waitMinutes[Integer .parseInt(seat)]) >= mealMinutes[Integer.parseInt(seat)]; } /** \u7740\u5e2d\u3055\u305b\u308b */ private static void setSeat(String groupOrder, int totalGroupNum) { for (int count = 0; count < customersNum[Integer.parseInt(groupOrder)]; count++) { // \u7740\u5e2d\u3059\u308b\u4eba\u6570\u5206\u7e70\u308a\u8fd4\u3059 // \u5ea7\u5e2d\u306b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b seats[firstSeatNum++] = groupOrder; } totalGroupNum++; } /** \u5f15\u6570\u306e\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u306e\u5ba2\u6570\u5206\u3001\u7a7a\u5e2d\u304b\u3069\u3046\u304b\u78ba\u8a8d\u3059\u308b */ private static boolean isEmpty(int groupsNum) { // \u7a7a\u5e2d\u6570 int emptyseatsNum =  || customersNum[groupsNum]  emptyseatsNum)) { // \u9023\u7d9a\u3057\u305f\u7a7a\u5e2d\u304c\u5ba2\u306e\u6570\u3060\u3051\u3042\u3063\u305f\u5834\u5408  else { //  emptyseatsNum)) { //  false; } /** \u7b2c\u4e00\u5f15\u6570\u3068\u7b2c\u4e8c\u5f15\u6570\u304c\u540c\u3058\u5834\u5408\u3001true\u3092\u8fd4\u3059 */ private static boolean isSame(int param, int target) { return param == target; } }"], "original_ll": -0.9253481030464172, "sampled_ll": -0.5416736602783203, "all_perturbed_sampled_ll": [-1.5778158903121948], "all_perturbed_original_ll": [-1.892865538597107], "perturbed_sampled_ll": -1.5778158903121948, "perturbed_original_ll": -1.892865538597107, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0147\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\nfrom collections import deque\ninput = stdin.readline\n\n\nclass Seat():\n    def __init__(self, n):\n        self.seat = '_' * n\n\n    def get(self, num):\n        i = self.seat.find('_'*num)\n        if i != -1:\n            self.seat = self.seat[0:i] + 'o'*num + self.seat[i+num:]\n            return i\n        return None\n\n    def release(self, i, num):\n        self.seat = self.seat[0:i] + '_'*num + self.seat[i+num:]\n\n\ndef solve():\n    waiting_time = [-1] * 100\n    NUM_OF_SEAT = 17\n    seat = Seat(NUM_OF_SEAT)\n    LEAVE = 0\n    COME = 1\n    in_out = []                 #  ??\\?????????????????????????????????\n    Q = deque()                      #  ??\u00a7??????????????????\n    # 100???????????\\????????????????????????\n    for group_id in range(100):\n        if group_id % 5 == 1:\n            num = 5\n        else:\n            num = 2\n        heappush(in_out, (group_id * 5, COME, NUM_OF_SEAT+1, group_id, num))\n\n    while in_out:\n        time, event, start_seat, group_id, num = heappop(in_out)\n        if event == COME:\n            Q.append((time, group_id, num))\n        else:\n            seat.release(start_seat, num)\n        while Q:\n            res = seat.get(Q[0][2])\n            if res is not None:\n                arrive, group_id, num = Q.popleft()\n                waiting_time[group_id] = time - arrive\n                eating_time = 17 * (group_id % 2) + 3*(group_id % 3) + 19\n                heappush(in_out, (time + eating_time, LEAVE, res, group_id, num))\n            else:\n                break\n    return waiting_time\n\n\ndef main(args):\n    waiting_time = solve()\n\n    for line in sys.stdin:\n        print(waiting_time[int(line)])\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    ", "sampled": "import sys\n\ndef solve(n):\n    # Initialize seats (17 seats, -1 means empty)\n    seats = [-1] * 17\n    # Queue of groups waiting\n    queue = []\n    # Dictionary to store group info: arrival_time, size, eat_time, seated_time\n    groups = {}\n    \n    # Generate all 100 groups\n    for i in range(100):\n        arrival = 5 * i\n        size = 5 if i % 5 == 1 else 2\n        eat_time = 17 * (i % 2) + 3 * (i % 3) + 19\n        groups[i] = {\n            'arrival': arrival,\n            'size': size,\n            'eat_time': eat_time,\n            'seated_time': None,\n            'leave_time': None\n        }\n    \n    # Simulate\n    max_time = 5 * 99 + 100  # Safe upper bound\n    \n    for t in range(max_time + 1):\n        # Step 1: Remove groups whose eating time is up\n        for seat_idx in range(17):\n            if seats[seat_idx] != -1:\n                group_id = seats[seat_idx]\n                if groups[group_id]['leave_time'] == t:\n                    seats[seat_idx] = -1\n        \n        # Step 2: Try to seat groups from queue\n        while queue:\n            group_id = queue[0]\n            size = groups[group_id]['size']\n            \n            # Find leftmost position where group can sit\n            seated = False\n            for start in range(18 - size):\n                if all(seats[start + j] == -1 for j in range(size)):\n                    # Seat the group\n                    for j in range(size):\n                        seats[start + j] = group_id\n                    groups[group_id]['seated_time'] = t\n                    groups[group_id]['leave_time'] = t + groups[group_id]['eat_time']\n                    queue.pop(0)\n                    seated = True\n                    break\n            \n            if not seated:\n                break\n        \n        # Step 3: Handle arriving groups\n        for i in range(100):\n            if groups[i]['arrival'] == t:\n                if queue:\n                    # Queue exists, join queue\n                    queue.append(i)\n                else:\n                    # No queue, try to seat directly\n                    size = groups[i]['size']\n                    seated = False\n                    for start in range(18 - size):\n                        if all(seats[start + j] == -1 for j in range(size)):\n                            # Seat the group\n                            for j in range(size):\n                                seats[start + j] = i\n                            groups[i]['seated_time'] = t\n                            groups[i]['leave_time'] = t + groups[i]['eat_time']\n                            seated = True\n                            break\n                    \n                    if not seated:\n                        queue.append(i)\n        \n        # Check if group n has been seated\n        if groups[n]['seated_time'] is not None:\n            wait_time = groups[n]['seated_time'] - groups[n]['arrival']\n            return wait_time\n    \n    return 0\n\n# Read input and process\nfor line in sys.stdin:\n    n = int(line.strip())\n    print(solve(n))\n", "perturbed_sampled": ["import sys def solve(n): # Initialize seats (17 seats, -1 means empty) seats = [-1] * 17 # Queue of groups waiting queue = [] # Dictionary  {}  = 5 *  else 2 eat_time = 17 *  19 groups[i] = { 'arrival': arrival, 'size': size, 'eat_time': eat_time, 'seated_time': None, 'leave_time': None } # Simulate  1: Remove groups whose eating time is up for seat_idx  groups[group_id]['leave_time'] == t: seats[seat_idx] = -1 #  group_id = queue[0] size = groups[group_id]['size'] # Find leftmost position where group can sit seated = False for start in range(18 - size): if all(seats[start + j] == -1 for j in range(size)): # Seat the group for j in range(size): seats[start + j] = group_id groups[group_id]['seated_time'] = t groups[group_id]['leave_time'] = t + groups[group_id]['eat_time']  Step 3: Handle arriving groups for i in range(100): if  queue.append(i) else: # No queue, try to seat directly size = groups[i]['size'] seated  + j] == -1  in range(size): seats[start + j] = i  None: wait_time = groups[n]['seated_time'] - groups[n]['arrival'] return wait_time return 0 #  int(line.strip()) print(solve(n))"], "perturbed_original": ["# -*- coding: utf-8 -*- \"\"\"  stdin.readline class Seat(): def __init__(self, n): self.seat = '_' * n def get(self, num): i = self.seat.find('_'*num) if i !=  return None def release(self, i, num): self.seat = self.seat[0:i] + '_'*num + self.seat[i+num:] def solve(): waiting_time = [-1] * 100 NUM_OF_SEAT = 17  # 100???????????\\???????????????????????? for group_id  COME,   seat.release(start_seat, num) while Q: res = seat.get(Q[0][2]) if res is not None: arrive, group_id, num = Q.popleft() waiting_time[group_id] = time - arrive eating_time = 17 * (group_id % 2) + 3*(group_id % 3) + 19 heappush(in_out, (time + eating_time, LEAVE, res, group_id, num)) else: break return waiting_time def main(args):  == '__main__': main(sys.argv[1:])"], "original_ll": -1.2137213945388794, "sampled_ll": -0.8377719521522522, "all_perturbed_sampled_ll": [-2.270890951156616], "all_perturbed_original_ll": [-2.5523176193237305], "perturbed_sampled_ll": -2.270890951156616, "perturbed_original_ll": -2.5523176193237305, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint a,n,i;\n\tprintf(\"?????\u00a3????????\u00a3????????\u00b0?????\\?????????????????????\",a);\n\tscanf(\"%d\",&a) ;\n\ti=a%39;\n\tif(i==0)\n\t{\n\t\tprintf(\"????????????????????????\");\n\t}\n\telse\n\t{\n\t\tprintf(\"3C%d\\n\",i);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a;\n    while (scanf(\"%d\", &a) != EOF) {\n        int student = a % 39;\n        if (student == 0) {\n            student = 39;\n        }\n        printf(\"3C%02d\\n\", student);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main()  student = a % 39; if (student == 0) { student = 39; } printf(\"3C%02d\\n\", student); } return 0; }"], "perturbed_original": [" i=a%39; if(i==0) { printf(\"????????????????????????\"); } else { printf(\"3C%d\\n\",i); } return 0; }"], "original_ll": -2.141200065612793, "sampled_ll": -1.0620944499969482, "all_perturbed_sampled_ll": [-2.3305225372314453], "all_perturbed_original_ll": [-2.4238948822021484], "perturbed_sampled_ll": -2.3305225372314453, "perturbed_original_ll": -2.4238948822021484, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tSystem.out.printf(\"3C%01d\\n\",(sc.nextInt())%39);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int candies = sc.nextInt();\n            int studentNumber = candies % 39;\n            \n            if (studentNumber == 0) {\n                studentNumber = 39;\n            }\n            \n            System.out.printf(\"3C%02d%n\", studentNumber);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) {  System.out.printf(\"3C%02d%n\", studentNumber); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class  = new Scanner(System.in); while(sc.hasNext()){ System.out.printf(\"3C%01d\\n\",(sc.nextInt())%39); } } }"], "original_ll": -1.4276636838912964, "sampled_ll": -1.0039668083190918, "all_perturbed_sampled_ll": [-1.813154935836792], "all_perturbed_original_ll": [-2.9571704864501953], "perturbed_sampled_ll": -1.813154935836792, "perturbed_original_ll": -2.9571704864501953, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "try:\n    while True:\n        ame = int(input())\n        num1 = ame % 39\n        if num1 == 0:\n            num1 = 39\n        if num1 < 10:\n            print(\"3C0\" + str(num1))\n        else:\n            print(\"3C\" + str(num1))\nexcept EOFError as e:\n    num = 0\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    a = int(line.strip())\n    student = a % 39\n    if student == 0:\n        student = 39\n    print(f\"3C{student:02d}\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: a = int(line.strip())  = 39 print(f\"3C{student:02d}\")"], "perturbed_original": ["try: while True: ame  0: num1 = 39 if num1 < 10: print(\"3C0\" + str(num1)) else: print(\"3C\" + str(num1)) except EOFError as e: num = 0"], "original_ll": -1.33604896068573, "sampled_ll": -1.728090763092041, "all_perturbed_sampled_ll": [-3.864443063735962], "all_perturbed_original_ll": [-2.638707160949707], "perturbed_sampled_ll": -3.864443063735962, "perturbed_original_ll": -2.638707160949707, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint rn[4], ln[4];\n\nint main(void)\n{\n\tdouble right, left;\n\tdouble EPS;\n\tint i;\n\t\n\tEPS = 1e-8;\n\t\n\twhile (scanf(\"%lf %lf\", &right, &left) != EOF){\n\t\t\n\t\tif (right >= 1.1){\n\t\t\trn[0]++;\n\t\t}\n\t\telse if (right >= 0.6){\n\t\t\trn[1]++;\n\t\t}\n\t\telse if(right >= 0.2){\n\t\t\trn[2]++;\n\t\t}\n\t\telse {\n\t\t\trn[3]++;\n\t\t}\n\t\tif (left >= 1.1){\n\t\t\tln[0]++;\n\t\t}\n\t\telse if (left >= 0.6){\n\t\t\tln[1]++;\n\t\t}\n\t\telse if(left >= 0.2){\n\t\t\tln[2]++;\n\t\t}\n\t\telse {\n\t\t\tln[3]++;\n\t\t}\n\t}\n\tfor (i = 0; i < 4; i++){\n\t\tprintf(\"%d %d\\n\", rn[i], ln[i]);\n\t}\n\treturn (0);\n}\n\t\t\t", "sampled": "#include <stdio.h>\n\nint main() {\n    double l, r;\n    int countA_L = 0, countA_R = 0;\n    int countB_L = 0, countB_R = 0;\n    int countC_L = 0, countC_R = 0;\n    int countD_L = 0, countD_R = 0;\n    \n    while (scanf(\"%lf %lf\", &l, &r) == 2) {\n        // Left eye\n        if (l >= 1.1) {\n            countA_L++;\n        } else if (l >= 0.6) {\n            countB_L++;\n        } else if (l >= 0.2) {\n            countC_L++;\n        } else {\n            countD_L++;\n        }\n        \n        // Right eye\n        if (r >= 1.1) {\n            countA_R++;\n        } else if (r >= 0.6) {\n            countB_R++;\n        } else if (r >= 0.2) {\n            countC_R++;\n        } else {\n            countD_R++;\n        }\n    }\n    \n    printf(\"%d %d\\n\", countA_L, countA_R);\n    printf(\"%d %d\\n\", countB_L, countB_R);\n    printf(\"%d %d\\n\", countC_L, countC_R);\n    printf(\"%d %d\\n\", countD_L, countD_R);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { <extra_id_1>{ countC_R++;<extra_id_2>if (l ><extra_id_3>= 0.2}<extra_id_4>if (r<extra_id_5>{ countD_R++; }<extra_id_6>countD_R++; } //<extra_id_7>int<extra_id_8>#endif int p<extra_id_9>= 0 ; int<extra_id_10>] l<extra_id_11>0b ( 100000000<extra_id_12>b<extra_id_13>) ; break<extra_id_14>{<extra_id_15>}<extra_id_16>,<extra_id_17>) .<extra_id_18>, & f ) ;<extra_id_19>, \"<extra_id_20>[<extra_id_21>) { return<extra_id_22>e int countB_L = 0, countB_R = 0; int countC_L = 0, countC_R = 0; int countD_L = 0, countD_R = 0; while (scanf(\"%lf %lf\", &l, &r) == 2) {  else if (l >= 0.6) { countB_L++; } else if (l >= 0.2) { countC_L++; } else { countD_L++; } //  if (r >= 0.6) { countB_R++; } else if (r  }"], "perturbed_original": ["#include <stdio.h> int rn[4], ln[4]; int main(void) { double right, left; double EPS; int i; EPS = 1e-8;  1.1){ rn[0]++; } else if (right   else if (left >= 0.6){  ln[3]++; } } for (i = 0; i < 4; i++){ printf(\"%d %d\\n\", rn[i], ln[i]); } return (0); }"], "original_ll": -0.7815167903900146, "sampled_ll": -0.3809066414833069, "all_perturbed_sampled_ll": [-1.740275502204895], "all_perturbed_original_ll": [-2.036062240600586], "perturbed_sampled_ll": -1.740275502204895, "perturbed_original_ll": -2.036062240600586, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tScanner sc;\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner (System.in);\n\t\t\n\t\tint[][] num=new int[4][2];\n\t\tfor(int[] e:num)Arrays.fill(e,0);\n\t\tint side=0;\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tdouble eye=nd();\n\t\t\tif(eye>=1.1) ++num[0][side];\n\t\t\telse if(eye>=0.6) ++num[1][side];\n\t\t\telse if(eye>=0.2) ++num[2][side];\n\t\t\telse ++num[3][side];\n\t\t\tside^=1;\n\t\t}\n\t\tfor(int i=0;i<4;++i)System.out.println(num[i][0]+\" \"+num[i][1]);\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int[] leftCount = new int[4];\n        int[] rightCount = new int[4];\n        \n        while (sc.hasNext()) {\n            double left = sc.nextDouble();\n            double right = sc.nextDouble();\n            \n            leftCount[getCategory(left)]++;\n            rightCount[getCategory(right)]++;\n        }\n        \n        for (int i = 0; i < 4; i++) {\n            System.out.println(leftCount[i] + \" \" + rightCount[i]);\n        }\n        \n        sc.close();\n    }\n    \n    private static int getCategory(double vision) {\n        if (vision >= 1.1) {\n            return 0; // A\n        } else if (vision >= 0.6) {\n            return 1; // B\n        } else if (vision >= 0.2) {\n            return 2; // C\n        } else {\n            return 3; // D\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  rightCount = new int[4]; while (sc.hasNext())  4; i++)  private static int getCategory(double vision) { if (vision >= 1.1) { return 0; // A } else if (vision >= 0.6) { return 1; // B } else if (vision >= 0.2) { return 2;  } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { Scanner sc; double nd(){ return sc.nextDouble(); }  int side=0; while(sc.hasNext()){ double eye=nd();   main(String[] args) { // TODO Auto-generated method stub new Main().io(); } }"], "original_ll": -1.0694659948349, "sampled_ll": -0.4807198941707611, "all_perturbed_sampled_ll": [-2.0098655223846436], "all_perturbed_original_ll": [-2.92710280418396], "perturbed_sampled_ll": -2.0098655223846436, "perturbed_original_ll": -2.92710280418396, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "c = [1.1,0.6,0.2,0.0]\nr = [0,0,0,0,0,0,0,0]\nwhile 1:\n    try:\n        e = map(float, raw_input().split())\n        for i in range(2):\n            for j in range(4):\n                if e[i] >= c[j]:\n                \tr[i+2*j] += 1\n                \tbreak\n    except:\n        break\nfor i in range(0,8,2):\n\tprint r[i],r[i+1]", "sampled": "import sys\n\ndef classify(vision):\n    if vision >= 1.1:\n        return 'A'\n    elif vision >= 0.6:\n        return 'B'\n    elif vision >= 0.2:\n        return 'C'\n    else:\n        return 'D'\n\nleft_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0}\nright_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0}\n\nfor line in sys.stdin:\n    l, r = map(float, line.strip().split())\n    left_count[classify(l)] += 1\n    right_count[classify(r)] += 1\n\nprint(left_count['A'], right_count['A'])\nprint(left_count['B'], right_count['B'])\nprint(left_count['C'], right_count['C'])\nprint(left_count['D'], right_count['D'])\n", "perturbed_sampled": ["import sys def classify(vision): if vision >= 1.1: return  0.2: return 'C' else: return 'D' left_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0} right_count = {'A': 0, 'B': 0, 'C': 0, 'D':  right_count['B']) print(left_count['C'], right_count['C']) print(left_count['D'], right_count['D'])"], "perturbed_original": ["c = [1.1,0.6,0.2,0.0] r = [0,0,0,0,0,0,0,0] while 1: try: e = map(float, raw_input().split()) for i in range(2): for j in range(4): if e[i] >=  range(0,8,2): print r[i],r[i+1]"], "original_ll": -1.1868014335632324, "sampled_ll": -0.5989325642585754, "all_perturbed_sampled_ll": [-1.7123626470565796], "all_perturbed_original_ll": [-1.7969279289245605], "perturbed_sampled_ll": -1.7123626470565796, "perturbed_original_ll": -1.7969279289245605, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "m[4][65536],i,l,L,p,c;main(n){for(;~scanf(\"%d\\n\",&n);L=n&&!printf(\"%d\\n\",L))for(p=255;++p<256-~n*n;)for(c=getchar(i=4);i--;L=l>L?l:L)l=m[i][p]=c-49?0:m[i][p-(i?n+i-1:1)]+1;}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    char grid[256][256];\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        for(int i = 0; i < n; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        int max_count = 0;\n        \n        // Check horizontal\n        for(int i = 0; i < n; i++) {\n            int count = 0;\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n            }\n        }\n        \n        // Check vertical\n        for(int j = 0; j < n; j++) {\n            int count = 0;\n            for(int i = 0; i < n; i++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n            }\n        }\n        \n        // Check diagonal (top-left to bottom-right)\n        // Starting from first row\n        for(int start_col = 0; start_col < n; start_col++) {\n            int count = 0;\n            int i = 0, j = start_col;\n            while(i < n && j < n) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j++;\n            }\n        }\n        // Starting from first column (excluding 0,0)\n        for(int start_row = 1; start_row < n; start_row++) {\n            int count = 0;\n            int i = start_row, j = 0;\n            while(i < n && j < n) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j++;\n            }\n        }\n        \n        // Check diagonal (top-right to bottom-left)\n        // Starting from first row\n        for(int start_col = 0; start_col < n; start_col++) {\n            int count = 0;\n            int i = 0, j = start_col;\n            while(i < n && j >= 0) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j--;\n            }\n        }\n        // Starting from last column (excluding 0,n-1)\n        for(int start_row = 1; start_row < n; start_row++) {\n            int count = 0;\n            int i = start_row, j = n - 1;\n            while(i < n && j >= 0) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j--;\n            }\n        }\n        \n        printf(\"%d\\n\", max_count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n; char grid[256][256]; while(scanf(\"%d\", &n) == 1 &&  < n; i++) { int count = 0; for(int j  { count++; if(count > max_count) max_count = count; } else { count = 0; } } }  0; i < n; i++) { if(grid[i][j]  } else { count = 0; } } } // Check diagonal (top-left to bottom-right)   j < n) { if(grid[i][j] == '1') { count++; if(count > max_count) max_count = count; } else {  from first column (excluding 0,0) for(int start_row = 1;  count++; if(count > max_count) max_count = count; } else { count  (top-right to bottom-left) // Starting from first row for(int start_col = 0; start_col < n; start_col++) { int count =  n && j >= 0) { if(grid[i][j] == '1') { count++; if(count > max_count) max_count = count; } else { count = 0; } i++; j--; } } // Starting from last column  { int count = 0; int i = start_row, j = n - 1; while(i < n && j >= 0) { if(grid[i][j] == '1') {  count = 0; } i++; j--; } } printf(\"%d\\n\", max_count); } return 0; }"], "perturbed_original": ["m[4][65536],i,l,L,p,c;main(n){for(;~scanf(\"%d\\n\",&n);L=n&&!printf(\"%d\\n\",L))for(p=255;++p<256-~n*n;)for(c=getchar(i=4);i--;L=l>L?l:L)l=m[i][p]=c-49?0:m[i][p-(i?n+i-1:1)]+1;}"], "original_ll": -2.8749964237213135, "sampled_ll": -0.2009437382221222, "all_perturbed_sampled_ll": [-1.3329992294311523], "all_perturbed_original_ll": [-2.8749964237213135], "perturbed_sampled_ll": -1.3329992294311523, "perturbed_original_ll": -2.8749964237213135, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] map = new boolean[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tchar[] ch = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tmap[i][j] = ch[j] == '1';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(map[i][j] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(map[j][i] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j <= i; j++){\n\t\t\t\t\t//System.out.print(\"( \" + (i - j) +\" \" + j + \") \");\n\t\t\t\t\tif(map[i - j][j] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = n - 1; j >= i; j--){\n\t\t\t\t\t//System.out.print(\"( \" + j +\" \" + (j - i) + \") \");\n\t\t\t\t\tif(map[j][j-i] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < (n - i) ; j++){\n\t\t\t\t\t//System.out.print(\"( \" + (j) +\" \" + (i+j) + \") \");\n\t\t\t\t\tif(map[j][i+j] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < (n - i); j++){\n\t\t\t\t\t//System.out.print(\"( \" + (i + j) +\" \" + (i) + \") \");\n\t\t\t\t\tif(map[i+j][i] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[][] grid = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                String line = sc.next();\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = line.charAt(j) - '0';\n                }\n            }\n            \n            int maxConsecutive = 0;\n            \n            // Check horizontal\n            for (int i = 0; i < n; i++) {\n                int count = 0;\n                for (int j = 0; j < n; j++) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n            }\n            \n            // Check vertical\n            for (int j = 0; j < n; j++) {\n                int count = 0;\n                for (int i = 0; i < n; i++) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n            }\n            \n            // Check diagonal (top-left to bottom-right)\n            for (int start = 0; start < n; start++) {\n                // Starting from first row\n                int count = 0;\n                for (int i = 0, j = start; i < n && j < n; i++, j++) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n                \n                // Starting from first column (skip 0,0 as it's already covered)\n                if (start > 0) {\n                    count = 0;\n                    for (int i = start, j = 0; i < n && j < n; i++, j++) {\n                        if (grid[i][j] == 1) {\n                            count++;\n                            maxConsecutive = Math.max(maxConsecutive, count);\n                        } else {\n                            count = 0;\n                        }\n                    }\n                }\n            }\n            \n            // Check diagonal (top-right to bottom-left)\n            for (int start = 0; start < n; start++) {\n                // Starting from first row\n                int count = 0;\n                for (int i = 0, j = start; i < n && j >= 0; i++, j--) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n                \n                // Starting from last column (skip top-right corner as it's already covered)\n                if (start > 0) {\n                    count = 0;\n                    for (int i = start, j = n - 1; i < n && j >= 0; i++, j--) {\n                        if (grid[i][j] == 1) {\n                            count++;\n                            maxConsecutive = Math.max(maxConsecutive, count);\n                        } else {\n                            count = 0;\n                        }\n                    }\n                }\n            }\n            \n            System.out.println(maxConsecutive);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  = new Scanner(System.in); while (true) { int n = sc.nextInt(); if  (int i = 0; i < n; i++) { String line = sc.next(); for (int j = 0; j < n;  maxConsecutive = 0; // Check horizontal for (int i = 0; i < n; i++) { int count =  { if (grid[i][j] == 1) { count++; maxConsecutive = Math.max(maxConsecutive, count); } else { count = 0; } } } // Check vertical for (int j = 0; j < n; j++) { int count = 0; for  } else { count = 0;  (int start  =  n; i++, j++) { if  else { count = 0; } } // Starting from first column (skip 0,0 as it's  for  && j  count++; maxConsecutive = Math.max(maxConsecutive, count); } else { count = 0; } } } }   row int count = 0; for  == 1) { count++; maxConsecutive = Math.max(maxConsecutive, count); } else  column (skip top-right corner as it's already covered)  i = start, j = n - 1; i < n && j >= 0; i++, j--) { if (grid[i][j] == 1) { count++; maxConsecutive = Math.max(maxConsecutive, count); } else { count = 0; } } } } System.out.println(maxConsecutive); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.LinkedList; import java.util.List; import java.util.Scanner; public class Main  for(int i = 0; i < n; i++){ char[] ch = sc.next().toCharArray(); for(int j  = 0; i < n; i++){ int count = 0; for(int j =  } for(int i = 0; i < n; i++){ int count = 0; for(int j = 0; j <= i; j++){ //System.out.print(\"( \" + (i - j) +\"  int count = 0; for(int j = n - 1; j >= i; j--){ //System.out.print(\"( \" + j +\" \" + (j - i) + \") \"); if(map[j][j-i] == true){ count++; } } //System.out.println(); max = Math.max(max, count); } for(int i = 0; i < n; i++){ int count =  ; j++){ //System.out.print(\"( \" + (j) +\" \" + (i+j) + \") \"); if(map[j][i+j] == true){ count++; } } //System.out.println(); max = Math.max(max, count); }  - i); j++){ //System.out.print(\"( \" + (i + j) +\" \" + (i) + \") \"); if(map[i+j][i] == true){ count++; } } //System.out.println(); max = Math.max(max, count); } System.out.println(max); } } }"], "original_ll": -0.3178330659866333, "sampled_ll": -0.2092655748128891, "all_perturbed_sampled_ll": [-1.4373639822006226], "all_perturbed_original_ll": [-1.0520161390304565], "perturbed_sampled_ll": -1.4373639822006226, "perturbed_original_ll": -1.0520161390304565, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def ge(n):\n    for i in xrange(n):\n        yield [(i,j) for j in xrange(n)]\n        yield [(j,i) for j in xrange(n)]\n        yield [(i-j,j) for j in xrange(i+1)]\n        yield [(n-i+j-1,n-j-1) for j in xrange(i+1)]\n\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    A = [map(int,list(raw_input())) for _ in xrange(n)]\n    print max(sum(map(lambda (i,j): A[i][j], p)) for p in ge(n))", "sampled": "def count_consecutive(line):\n    max_count = 0\n    current_count = 0\n    for char in line:\n        if char == '1':\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n    return max_count\n\ndef solve(n, grid):\n    max_consecutive = 0\n    \n    # Check horizontal\n    for row in grid:\n        max_consecutive = max(max_consecutive, count_consecutive(row))\n    \n    # Check vertical\n    for col in range(n):\n        column = ''.join(grid[row][col] for row in range(n))\n        max_consecutive = max(max_consecutive, count_consecutive(column))\n    \n    # Check diagonals (top-left to bottom-right)\n    # Diagonals starting from first row\n    for start_col in range(n):\n        diagonal = ''.join(grid[i][start_col + i] for i in range(n - start_col))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    # Diagonals starting from first column (excluding top-left corner)\n    for start_row in range(1, n):\n        diagonal = ''.join(grid[start_row + i][i] for i in range(n - start_row))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    # Check diagonals (top-right to bottom-left)\n    # Diagonals starting from first row\n    for start_col in range(n):\n        diagonal = ''.join(grid[i][start_col - i] for i in range(start_col + 1))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    # Diagonals starting from last column (excluding top-right corner)\n    for start_row in range(1, n):\n        diagonal = ''.join(grid[start_row + i][n - 1 - i] for i in range(n - start_row))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    return max_consecutive\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    grid = []\n    for _ in range(n):\n        grid.append(input().strip())\n    \n    result = solve(n, grid)\n    print(result)\n", "perturbed_sampled": ["def count_consecutive(line): max_count = 0 current_count = 0 for char in line: if char == '1': current_count += 1 max_count = max(max_count, current_count) else: current_count = 0  horizontal for row  range(n)) max_consecutive = max(max_consecutive, count_consecutive(column)) # Check diagonals (top-left to bottom-right) # Diagonals starting from first row for start_col in range(n): diagonal = ''.join(grid[i][start_col +  count_consecutive(diagonal)) # Diagonals starting from first column (excluding top-left corner) for start_row in range(1, n): diagonal = ''.join(grid[start_row   = ''.join(grid[i][start_col - i] for i in range(start_col + 1)) max_consecutive = max(max_consecutive, count_consecutive(diagonal)) # Diagonals starting from last column (excluding top-right corner) for start_row in range(1, n): diagonal = ''.join(grid[start_row + i][n - 1 - i]  return  result = solve(n, grid) print(result)"], "perturbed_original": ["def ge(n): for i in xrange(n): yield [(i,j) for j in xrange(n)] yield [(j,i) for j in xrange(n)] yield [(i-j,j) for j in xrange(i+1)] yield [(n-i+j-1,n-j-1) for j in xrange(i+1)] while A[j],<extra_id_1>i-j], p) if<extra_id_2>j<extra_id_3>] )<extra_id_4>]<extra_id_5>for<extra_id_6>j in<extra_id_7>] if<extra_id_8>==<extra_id_9>] :<extra_id_10>} else<extra_id_11>) yield [(i-j,j)]<extra_id_12>) for j<extra_id_13>j in<extra_id_14>}<extra_id_15>(n,A.get(j)] A[i][j], p)) for p in ge(n))"], "original_ll": -1.1642400026321411, "sampled_ll": -0.32120296359062195, "all_perturbed_sampled_ll": [-1.4722095727920532], "all_perturbed_original_ll": [-2.075368642807007], "perturbed_sampled_ll": -1.4722095727920532, "perturbed_original_ll": -2.075368642807007, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\ntypedef struct{\n\tint no;\n\tint score;\n} Info;\n\nvoid sortInfo(int n,Info t[]){\n\tint i,j;\n\tfor(i=0;i<n-1;i++){\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tif(t[i].score < t[j].score ||\n\t\t\t   t[i].score == t[j].score && t[i].no > t[j].no){\n\t\t\t\tInfo tmp = t[i];\n\t\t\t\tt[i] = t[j];\n\t\t\t\tt[j] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint scoring(void){\n\tint i, x, total, frame, time, sum, flgSpare, flgStrike;\n\t\n\ttotal = sum = 0;\n\tframe = time = 1;\n\tflgSpare = flgStrike = 0;\n\t\n\twhile(frame < 10){\n\t\tscanf(\"%d\",&x);\n\t\tsum += x;\n\t\t\n\t\tif(flgSpare){\n\t\t\ttotal += x;\n\t\t\tflgSpare = 0;\n\t\t}\n\t\telse if(flgStrike){\n\t\t\tif(flgStrike == 3){\n\t\t\t\ttotal += x;\n\t\t\t\tflgStrike--;\n\t\t\t}\n\t\t\ttotal += x;\n\t\t\tflgStrike--;\n\t\t}\n\t\t\n\t\tif(time == 2){\n\t\t\ttotal += sum;\n\t\t\tif(sum == 10){\n\t\t\t\tflgSpare = 1;\n\t\t\t}\n\t\t\tsum = 0;\n\t\t\ttime = 1;\n\t\t\tframe++;\n\t\t}\n\t\telse if(time == 1){\n\t\t\ttime++;\n\t\t\tif(x == 10){\n\t\t\t\ttotal += 10;\n\t\t\t\tflgStrike += 2;\n\t\t\t\tsum = 0;\n\t\t\t\ttime = 1;\n\t\t\t\tframe++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0;i<3;i++){\n\t\tif(i == 2 && sum < 10) break;\n\t\t\n\t\tscanf(\"%d\",&x);\n\t\ttotal += x;\n\t\tsum += x;\n\t\t\n\t\tif(flgSpare){\n\t\t\ttotal += x;\n\t\t\tflgSpare = 0;\n\t\t}\n\t\telse if(flgStrike){\n\t\t\tif(flgStrike == 3){\n\t\t\t\ttotal += x;\n\t\t\t\tflgStrike--;\n\t\t\t}\n\t\t\ttotal += x;\n\t\t\tflgStrike--;\n\t\t}\n\t}\n\n\treturn total;\n}\n\nint main(void){\n\tint i, n;\n\tInfo info[40];\n\t\n\twhile(scanf(\"%d\",&n) && n){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&info[i].no);\n\t\t\tinfo[i].score = scoring();\n\t\t}\n\t\tsortInfo(n,info);\n\t\tfor(i=0;i<n;i++){\n\t\t\tprintf(\"%d %d\\n\",info[i].no,info[i].score);\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int score;\n} Player;\n\nint calculate_score(int pins[], int n) {\n    int total = 0;\n    int pin_idx = 0;\n    \n    for (int frame = 0; frame < 10; frame++) {\n        if (frame < 9) {\n            if (pins[pin_idx] == 10) { // Strike\n                total += 10 + pins[pin_idx + 1] + pins[pin_idx + 2];\n                pin_idx++;\n            } else if (pins[pin_idx] + pins[pin_idx + 1] == 10) { // Spare\n                total += 10 + pins[pin_idx + 2];\n                pin_idx += 2;\n            } else {\n                total += pins[pin_idx] + pins[pin_idx + 1];\n                pin_idx += 2;\n            }\n        } else { // 10th frame\n            total += pins[pin_idx] + pins[pin_idx + 1];\n            if (pins[pin_idx] == 10 || pins[pin_idx] + pins[pin_idx + 1] == 10) {\n                total += pins[pin_idx + 2];\n            }\n        }\n    }\n    \n    return total;\n}\n\nint compare_players(const void *a, const void *b) {\n    Player *pa = (Player *)a;\n    Player *pb = (Player *)b;\n    \n    if (pa->score != pb->score) {\n        return pb->score - pa->score; // Higher score first\n    }\n    return pa->id - pb->id; // Lower ID first\n}\n\nint main() {\n    int m;\n    \n    while (scanf(\"%d\", &m) == 1 && m != 0) {\n        Player players[40];\n        \n        for (int i = 0; i < m; i++) {\n            int id;\n            int pins[21];\n            int n = 0;\n            \n            scanf(\"%d\", &id);\n            \n            while (n < 21) {\n                if (scanf(\"%d\", &pins[n]) != 1) break;\n                n++;\n                \n                // Check if we should stop reading (peek next character)\n                int c = getchar();\n                if (c == '\\n' || c == EOF) {\n                    ungetc(c, stdin);\n                    break;\n                }\n                ungetc(c, stdin);\n            }\n            \n            players[i].id = id;\n            players[i].score = calculate_score(pins, n);\n        }\n        \n        qsort(players, m, sizeof(Player), compare_players);\n        \n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", players[i].id, players[i].score);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int id; int score; } Player; int calculate_score(int pins[], int n) { int total = 0; int pin_idx = 0; for (int frame =  { if (pins[pin_idx] == 10) { // Strike total += 10 + pins[pin_idx + 1] +  10 + pins[pin_idx + 2]; pin_idx += 2; } else { total += pins[pin_idx] +  2]; } } } return total; } int compare_players(const void *a, const void *b) { Player *pa = (Player *)a; Player *pb = (Player *)b; if (pa->score != pb->score) { return pb->score - pa->score; //   &m) == 1 && m != 0) { Player players[40]; for (int i = 0;  { if (scanf(\"%d\", &pins[n])  reading (peek next character) int c =  ungetc(c, stdin); break; } ungetc(c, stdin); } players[i].id = id;  (int i = 0; i < m; i++) { printf(\"%d %d\\n\", players[i].id, players[i].score); } } return 0; }"], "perturbed_original": ["#include <stdio.h> typedef struct{ int no; int score; } Info; void sortInfo(int n,Info t[]){ int i,j; for(i=0;i<n-1;i++){ for(j=i+1;j<n;j++){ if(t[i].score < t[j].score || t[i].score  sum, flgSpare, flgStrike; total  = flgStrike = 0; while(frame < 10){ scanf(\"%d\",&x); sum += x; if(flgSpare){ total += x; flgSpare = 0; }  total += x; flgStrike--; } if(time == 2){ total += sum; if(sum == 10){ flgSpare = 1; } sum = 0; time = 1; frame++; } else  flgStrike += 2;  scanf(\"%d\",&x); total += x; sum += x; if(flgSpare){ total += x; flgSpare = 0; } else  main(void){ int i, n; Info info[40]; while(scanf(\"%d\",&n) && n){ for(i=0;i<n;i++){ scanf(\"%d\",&info[i].no); info[i].score = scoring(); } sortInfo(n,info); for(i=0;i<n;i++){ printf(\"%d %d\\n\",info[i].no,info[i].score); } } return 0; }"], "original_ll": -0.6524258852005005, "sampled_ll": -0.4492418169975281, "all_perturbed_sampled_ll": [-1.5987812280654907], "all_perturbed_original_ll": [-1.3241304159164429], "perturbed_sampled_ll": -1.5987812280654907, "perturbed_original_ll": -1.3241304159164429, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass score implements Comparable<score> {\n\t\tString id;\n\t\tint s;\n\n\t\tscore(Scanner sc) {\n\t\t\tid = sc.next();\n\t\t\tint f = 0;\n\t\t\tint x1 = 0;\n\t\t\tint x2 = 0;\n\t\t\tint c = 0;\n\t\t\tint q = 0;\n\t\t\tint e = 0;\n\t\t\ts = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif(f == 9 && e == 1 && c==3){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(f == 9 && e == 0 && c==2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (x1 > 0) {\n\t\t\t\t\tx1--;\n\t\t\t\t\ts+=v;\n\t\t\t\t}\n\t\t\t\tif (x2 > 0) {\n\t\t\t\t\tx2--;\n\t\t\t\t\tx1++;\n\t\t\t\t\ts+=v;\n\t\t\t\t}\n\t\t\t\ts+=v;\n//\t\t\t\tSystem.out.println(s);\n\t\t\t\tif (f == 9) {\n\t\t\t\t\tif(c==0){\n\t\t\t\t\t\tif(v==10){\n\t\t\t\t\t\t\te=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq=v;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}else if(c== 1 && q+v==10){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t} else if (v == 10) {\n\t\t\t\t\tx2 += 1;\n\t\t\t\t\tc = 0;\n\t\t\t\t\tq=0;\n\t\t\t\t\tf++;\n\t\t\t\t} else if (q + v == 10) {\n\t\t\t\t\tx1 += 1;\n\t\t\t\t\tc = 0;\n\t\t\t\t\tq=0;\n\t\t\t\t\tf++;\n\t\t\t\t} else if (c == 1) {\n\t\t\t\t\tc = 0;\n\t\t\t\t\tq=0;\n\t\t\t\t\tf++;\n\t\t\t\t} else {\n\t\t\t\t\tq = v;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(score arg0) {\n\t\t\tint a;\n\t\t\ta = arg0.s - s;\n\t\t\tif (a == 0) {\n\t\t\t\ta = id.compareTo(arg0.id);\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tscore[] c = new score[n];\n\t\t\tfor(int i =0;i<n;i++){\n\t\t\t//\tSystem.out.println(i);\n\t\t\t\tc[i] = new score(sc);\n\t\t\t}\n\t\t\tArrays.sort(c);\n\t\t\t\n\t\t\tfor(int i =0 ; i < n;i++){\n\t\t\t\tSystem.out.println(c[i].id+\" \"+c[i].s);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Player implements Comparable<Player> {\n        int id;\n        int score;\n        \n        public Player(int id, int score) {\n            this.id = id;\n            this.score = score;\n        }\n        \n        @Override\n        public int compareTo(Player other) {\n            if (this.score != other.score) {\n                return other.score - this.score;\n            }\n            return this.id - other.id;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            if (m == 0) break;\n            \n            List<Player> players = new ArrayList<>();\n            \n            for (int i = 0; i < m; i++) {\n                int id = sc.nextInt();\n                List<Integer> rolls = new ArrayList<>();\n                \n                String line = sc.nextLine().trim();\n                String[] tokens = line.split(\"\\\\s+\");\n                for (String token : tokens) {\n                    rolls.add(Integer.parseInt(token));\n                }\n                \n                int score = calculateScore(rolls);\n                players.add(new Player(id, score));\n            }\n            \n            Collections.sort(players);\n            \n            for (Player p : players) {\n                System.out.println(p.id + \" \" + p.score);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static int calculateScore(List<Integer> rolls) {\n        int score = 0;\n        int rollIndex = 0;\n        \n        for (int frame = 0; frame < 10; frame++) {\n            if (frame < 9) {\n                if (rolls.get(rollIndex) == 10) {\n                    score += 10 + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);\n                    rollIndex++;\n                } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) {\n                    score += 10 + rolls.get(rollIndex + 2);\n                    rollIndex += 2;\n                } else {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1);\n                    rollIndex += 2;\n                }\n            } else {\n                if (rolls.get(rollIndex) == 10) {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);\n                    rollIndex += 3;\n                } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);\n                    rollIndex += 3;\n                } else {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1);\n                    rollIndex += 2;\n                }\n            }\n        }\n        \n        return score;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Player implements Comparable<Player> {  int compareTo(Player other) { if (this.score  - other.id; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int m = sc.nextInt(); if (m == 0) break; List<Player>  < m; i++) { int id = sc.nextInt(); List<Integer>  } int score = calculateScore(rolls); players.add(new Player(id, score)); } Collections.sort(players); for (Player p : players) { System.out.println(p.id + \" \" + p.score); } } sc.close(); } static int calculateScore(List<Integer> rolls) { int score = 0; int rollIndex  == 10)  + 1) == 10) { score += 10 + rolls.get(rollIndex + 2); rollIndex += 2; } else { score += rolls.get(rollIndex) + rolls.get(rollIndex + 1); rollIndex += 2; } } else  rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);  + 1) + rolls.get(rollIndex +  + rolls.get(rollIndex + 1); rollIndex += 2; } } } return score; } }"], "perturbed_original": ["import java.util.*; import java.lang.*; import java.math.*; public class Main  = sc.next();  = 0; int c = 0; int q = 0; int e = 0; s = 0; for (;;)  && c==2){ break; } int v = sc.nextInt(); if (x1 > 0) { x1--; s+=v; } if  } q=v; c++; }else if(c== 1 && q+v==10){ e=1; c++; }else{ c++; } } else if (v ==  } else if (q + v ==  } else if (c == 1)  = v; c++; } } } @Override  id.compareTo(arg0.id); } return a; } } void run() { for (;;) { int n = sc.nextInt(); if  score[n]; for(int i =0;i<n;i++){ // System.out.println(i); c[i] = new score(sc); } Arrays.sort(c); for(int i =0 ; i < n;i++){ System.out.println(c[i].id+\" \"+c[i].s); } } } public static void main(String[] args) { Main m = new Main(); m.run(); } }"], "original_ll": -0.8214938044548035, "sampled_ll": -0.2747756242752075, "all_perturbed_sampled_ll": [-1.3250436782836914], "all_perturbed_original_ll": [-2.03900408744812], "perturbed_sampled_ll": -1.3250436782836914, "perturbed_original_ll": -2.03900408744812, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f1():\n    frame = 1\n    total = 0\n    i = 0\n    while frame < 10:\n        if score[i] == 10:\n            total += (score[i] + score[i+1] + score[i+2])\n            i += 1\n        elif score[i] + score[i+1] == 10:\n            total += (score[i] + score[i+1] + score[i+2])\n            i += 2\n        else:\n            total += (score[i] + score[i+1])\n            i += 2\n        frame += 1\n    else:\n        total += sum(score[i:])\n        res[sn] = total\n\ndef f2():\n    for k, v in sorted(res.items(), key=lambda x: (x[1], x[0]), reverse=True):\n        print -k, v\n\nwhile True:\n    n = input()\n    if n == 0: break\n    res = {}\n    for i in range(n):\n        L = map(int, raw_input().split())\n        sn = -L[0]\n        score = L[1:]\n        f1()\n    else:\n        f2()", "sampled": "def calculate_bowling_score(pins):\n    score = 0\n    pin_idx = 0\n    \n    for frame in range(10):\n        if frame < 9:  # Frames 1-9\n            if pins[pin_idx] == 10:  # Strike\n                score += 10 + pins[pin_idx + 1] + pins[pin_idx + 2]\n                pin_idx += 1\n            elif pins[pin_idx] + pins[pin_idx + 1] == 10:  # Spare\n                score += 10 + pins[pin_idx + 2]\n                pin_idx += 2\n            else:  # Regular\n                score += pins[pin_idx] + pins[pin_idx + 1]\n                pin_idx += 2\n        else:  # Frame 10\n            score += pins[pin_idx] + pins[pin_idx + 1] + pins[pin_idx + 2]\n            pin_idx += 3\n    \n    return score\n\nwhile True:\n    m = int(input())\n    if m == 0:\n        break\n    \n    results = []\n    for _ in range(m):\n        data = list(map(int, input().split()))\n        student_id = data[0]\n        pins = data[1:]\n        score = calculate_bowling_score(pins)\n        results.append((student_id, score))\n    \n    # Sort by score (descending), then by student_id (ascending)\n    results.sort(key=lambda x: (-x[1], x[0]))\n    \n    for student_id, score in results:\n        print(f\"{student_id} {score}\")\n", "perturbed_sampled": [" in range(10): if frame < 9: # Frames 1-9 if pins[pin_idx] == 10: # Strike score += 10 +  elif pins[pin_idx]  # Regular score +=  Frame 10 score += pins[pin_idx] + pins[pin_idx + 1]  True: m = int(input()) if m == 0: break results = [] for _ in range(m): data =  calculate_bowling_score(pins) results.append((student_id, score)) # Sort by score (descending), then by student_id (ascending) results.sort(key=lambda x: (-x[1], x[0])) for student_id, score in results: print(f\"{student_id} {score}\")"], "perturbed_original": ["def f1(): frame = 1 total = 0 i = 0 while  + score[i+1] + score[i+2])  += (score[i] + score[i+1] + score[i+2]) i += 2 else: total += (score[i] + score[i+1]) i += 2 frame += 1 else:  v in sorted(res.items(), key=lambda x: (x[1], x[0]), reverse=True): print -k, v  res = {} for  score = L[1:] f1() else: f2()"], "original_ll": -0.798305332660675, "sampled_ll": -0.4987947642803192, "all_perturbed_sampled_ll": [-2.001269817352295], "all_perturbed_original_ll": [-2.1228561401367188], "perturbed_sampled_ll": -2.001269817352295, "perturbed_original_ll": -2.1228561401367188, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0153: Triangle and Circle\n// 2017.8.12 bal4u@uu\n\n#include <stdio.h>\n\nlong long x[10], y[10];\nlong long xe, ye, r;\n\nint atSameSide(long long x1, long long y1, long long x2, long long y2,\n\tlong long xa, long long ya, long long xb, long long yb)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n\treturn (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0);\n}\n\nint between(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n\tsb = (x1 - x2) * (x - x2) + (y1 - y2) * (y - y2);\n\treturn (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0);\n}\n\nint disCmp(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y, long long r)\n{\n\tlong long a, b, c, t;\t\t\t/* ax + by + c = 0 */\n\tlong long squ;\n\ta = y1 - y2, b = x2 - x1, c = y2*x1-x2*y1;\n\tsqu = a*a + b*b;\n\tif (squ == 0) return 0;\n\tt = (a * x) + (b * y) + c;\n\tt = t*t - r*r*squ;\n\tif (t > 0) return 1;\n\tif (t < 0) return -1;\n\treturn 0;\n}\n\nint main()\n{\n\tint i, f;\n\tlong long d[3], rr;\n\n\twhile (1) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tscanf(\"%lld%lld\", x + i, y + i);\n\t\t\tif (!i && !x[0] && !y[0]) return 0;\n\t\t\tx[i + 3] = x[i], y[i + 3] = y[i];\n\t\t}\n\t\tscanf(\"%lld%lld%lld\", &xe, &ye, &r); rr = r*r;\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = (x[i] - xe)*(x[i] - xe) + (y[i] - ye)*(y[i] - ye);\n\t\tif (rr >= d[0] && rr >= d[1] && rr >= d[2]) { puts(\"b\"); continue; }\n\t\tif (rr >= d[0] || rr >= d[1] || rr >= d[2]) { puts(\"c\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tf = atSameSide(x[i], y[i], x[i + 1], y[i + 1],\n\t\t\t\tx[i + 2], y[i + 2], xe, ye);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = disCmp(x[i], y[i], x[i + 1], y[i + 1], xe, ye, r);\n\t\tif (f) { puts(d[0] >= 0 && d[1] >= 0 && d[2] >= 0 ? \"a\" : \"c\"); continue; }\n\t\tif (d[0] > 0 && d[1] > 0 && d[2] > 0) { puts(\"d\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tif (between(x[i], y[i], x[i + 1], y[i + 1], xe, ye) && d[i] <= 0) f = 0;\n\t\tputs(f ? \"d\" : \"c\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble dist(Point a, Point b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\ndouble dot(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y);\n}\n\ndouble cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble distPointToSegment(Point p, Point a, Point b) {\n    if (dot(a, b, p) < -EPS) return dist(p, a);\n    if (dot(b, a, p) < -EPS) return dist(p, b);\n    return fabs(cross(a, b, p)) / dist(a, b);\n}\n\nint pointInTriangle(Point p, Point t1, Point t2, Point t3) {\n    double c1 = cross(t1, t2, p);\n    double c2 = cross(t2, t3, p);\n    double c3 = cross(t3, t1, p);\n    \n    if (c1 >= -EPS && c2 >= -EPS && c3 >= -EPS) return 1;\n    if (c1 <= EPS && c2 <= EPS && c3 <= EPS) return 1;\n    return 0;\n}\n\nint main() {\n    int x1, y1, x2, y2, x3, y3, xc, yc, r;\n    \n    while (1) {\n        scanf(\"%d %d\", &x1, &y1);\n        if (x1 == 0 && y1 == 0) break;\n        scanf(\"%d %d\", &x2, &y2);\n        scanf(\"%d %d\", &x3, &y3);\n        scanf(\"%d %d\", &xc, &yc);\n        scanf(\"%d\", &r);\n        \n        Point t1 = {x1, y1};\n        Point t2 = {x2, y2};\n        Point t3 = {x3, y3};\n        Point c = {xc, yc};\n        \n        // Check if circle is inside triangle\n        int circleInTriangle = 1;\n        if (!pointInTriangle(c, t1, t2, t3)) {\n            circleInTriangle = 0;\n        } else {\n            double d1 = distPointToSegment(c, t1, t2);\n            double d2 = distPointToSegment(c, t2, t3);\n            double d3 = distPointToSegment(c, t3, t1);\n            if (d1 < r - EPS || d2 < r - EPS || d3 < r - EPS) {\n                circleInTriangle = 0;\n            }\n        }\n        \n        // Check if triangle is inside circle\n        int triangleInCircle = 1;\n        if (dist(c, t1) > r + EPS || dist(c, t2) > r + EPS || dist(c, t3) > r + EPS) {\n            triangleInCircle = 0;\n        }\n        \n        // Check if they intersect\n        int intersect = 0;\n        double d1 = distPointToSegment(c, t1, t2);\n        double d2 = distPointToSegment(c, t2, t3);\n        double d3 = distPointToSegment(c, t3, t1);\n        \n        if (d1 <= r + EPS || d2 <= r + EPS || d3 <= r + EPS) {\n            if (pointInTriangle(c, t1, t2, t3) || \n                dist(c, t1) <= r + EPS || \n                dist(c, t2) <= r + EPS || \n                dist(c, t3) <= r + EPS) {\n                intersect = 1;\n            }\n        }\n        \n        if (circleInTriangle) {\n            printf(\"a\\n\");\n        } else if (triangleInCircle) {\n            printf(\"b\\n\");\n        } else if (intersect) {\n            printf(\"c\\n\");\n        } else {\n            printf(\"d\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #define EPS 1e-9 typedef struct { double x, y; } Point; double dist(Point a,  dy = a.y - b.y; return sqrt(dx * dx + dy *  return (b.x -  (c.y - a.y); } double cross(Point a, Point b, Point c) { return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x); } double distPointToSegment(Point p, Point a, Point b) { if (dot(a, b, p) < -EPS) return dist(p, a); if (dot(b, a, p) < -EPS) return dist(p, b); return fabs(cross(a, b, p)) / dist(a, b); } int pointInTriangle(Point p, Point t1, Point t2, Point t3) {  t3, p); double c3 = cross(t3, t1, p); if (c1 >= -EPS && c2 >= -EPS && c3 >= -EPS) return 1; if (c1 <= EPS && c2 <= EPS && c3  (x1 == 0 && y1 == 0) break; scanf(\"%d %d\", &x2, &y2); scanf(\"%d %d\", &x3, &y3); scanf(\"%d %d\", &xc, &yc); scanf(\"%d\", &r);  Point t3 = {x3, y3}; Point c = {xc,  = 1; if (!pointInTriangle(c, t1, t2, t3)) { circleInTriangle = 0; } else {  t2, t3); double d3 = distPointToSegment(c, t3, t1); if (d1 < r - EPS ||   (dist(c,  + EPS || dist(c, t3) > r +  intersect int  d2 <= r + EPS || d3 <= r + EPS)  EPS || dist(c, t3) <= r + EPS) { intersect = 1;  else { printf(\"d\\n\"); } } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0153:  x[10], y[10]; long long xe,  long x2, long long y2, long long xa, long long ya, long long xb, long long yb) { long long sa, sb; sa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1  y1) + (y2  && sb >= 0) ||  long  - x1) + (y2 - y1) * (y - y1); sb = (x1 - x2) * (x - x2) + (y1 - y2) * (y - y2); return (sa >= 0 && sb >= 0) || (sa < 0 &&  y1, long long x2, long long y2, long long x, long long  */ long long squ; a = y1 - y2, b = x2 - x1, c = y2*x1-x2*y1; squ = a*a + b*b; if (squ == 0) return 0; t = (a * x) + (b *  > 0) return 1; if (t < 0)  (i = 0; i < 3; i++) { scanf(\"%lld%lld\", x  !y[0]) return 0; x[i + 3] = x[i], y[i + 3] = y[i]; } scanf(\"%lld%lld%lld\", &xe, &ye, &r); rr = r*r;  d[1] && rr >= d[2]) { puts(\"b\"); continue; } if (rr >= d[0] || rr >= d[1]  = 1, i = 0; f  + 1], y[i  \"a\" : \"c\"); continue; } if (d[0] > 0 && d[1] > 0 && d[2] > 0) { puts(\"d\"); continue; } for (f = 1, i = 0; f && i < 3; i++) if (between(x[i], y[i], x[i + 1], y[i + 1], xe, ye) && d[i] <= 0) f = 0; puts(f ? \"d\" : \"c\"); } return 0; }"], "original_ll": -0.6763666868209839, "sampled_ll": -0.3005899488925934, "all_perturbed_sampled_ll": [-1.3000198602676392], "all_perturbed_original_ll": [-1.6763384342193604], "perturbed_sampled_ll": -1.3000198602676392, "perturbed_original_ll": -1.6763384342193604, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c1\u306e\u9802\u70b9\u306e\u5ea7\u6a19x1 y1\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 2\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c2\u306e\u9802\u70b9\u306e\u5ea7\u6a19x2 y2\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 3\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c3\u306e\u9802\u70b9\u306e\u5ea7\u6a19x3 y3\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 4\u884c\u76ee \u5186\u306e\u4e2d\u5fc3\u306e\u5ea7\u6a19x4 y4\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 5\u884c\u76ee \u5186\u306e\u534a\u5f84r\uff08\u6574\u6570\uff09\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tif (r * r >= max) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(Line.distanceSP(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line(\n\t\t\t\t\t\tps[i], ps[(i + 1) % 3]), ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble ep = new Line(ps[i], ps[(i + 1) % 3]).ep(new Line(ps[i],\n\t\t\t\t\t\tps[3]));\n\t\t\t\tif (ep < 0)\n\t\t\t\t\tleft = false;\n\t\t\t\telse if (ep > 0)\n\t\t\t\t\tright = false;\n\t\t\t}\n\t\t\tboolean in = left | right;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n\t}\n}\n\n// Output\n//\n// \u5165\u529b\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3054\u3068\u306b\u4ee5\u4e0b\u306e\u5224\u5b9a\u7d50\u679c\u3092\u51fa\u529b\u3057\u307e\u3059\u3002\n//\n// \u5186\u304c\u4e09\u89d2\u5f62\u306b\u542b\u307e\u308c\u308b\u5834\u5408 a\n// \u4e09\u89d2\u5f62\u304c\u5186\u306b\u542b\u307e\u308c\u308b\u5834\u5408 b\n// \u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u3067\u3001\u5171\u901a\u90e8\u5206\u304c\u3042\u308b\u5834\u5408\u306b\u306f c\n// \u5171\u901a\u90e8\u5206\u304c\u306a\u3044\u5834\u5408\u306b\u306f d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic static double distanceSP(Line s, Point2D.Double p) {\n\t\tPoint2D.Double r = proj(s, p);\n\t\tif (intersectSP(s, r))\n\t\t\treturn norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p)));\n\t}\n\n\tpublic static boolean intersectSP(Line s, Point2D.Double p) {\n\t\treturn ccw(s.p1, s.p2, p) == 0;\n\t}\n\n\tpublic static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n\t\tPoint2D.Double p = sub(b, a);\n\t\tPoint2D.Double q = sub(c, a);\n\t\tif (extp(p, q) > EPS)\n\t\t\treturn 1; // counter clockwise\n\t\tif (extp(p, q) < -EPS)\n\t\t\treturn -1; // clockwise\n\t\tif (inp(p, q) < -EPS)\n\t\t\treturn 2; // c--a--b on line\n\t\tif (Math.abs(norm(p) - norm(q)) < EPS)\n\t\t\treturn -2; // a--b--c on line\n\t\treturn 0; // a--c--b(or a--c=b) on line\n\t}\n\n\tpublic static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn new Point2D.Double(p1.x - p2.x, p1.y - p2.y);\n\t}\n\n\tpublic static Point2D.Double proj(Line l, Point2D.Double p) {\n\t\tdouble t = inp(sub(p, l.p1), sub(l.p1, l.p2))\n\t\t\t\t/ Math.pow(norm(sub(l.p1, l.p2)), 2);\n\t\tPoint2D.Double tp = sub(l.p1, l.p2);\n\t\treturn new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);\n\t}\n\n\tpublic static double inp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\tpublic static double extp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tpublic static final double EPS = 1.0e-8;\n\n\tpublic static double norm(Point2D.Double p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final double EPS = 1e-9;\n    \n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n        Point sub(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n        Point mul(double t) {\n            return new Point(x * t, y * t);\n        }\n        double dot(Point p) {\n            return x * p.x + y * p.y;\n        }\n        double cross(Point p) {\n            return x * p.y - y * p.x;\n        }\n        double norm() {\n            return Math.sqrt(x * x + y * y);\n        }\n    }\n    \n    static double distancePointToSegment(Point p, Point a, Point b) {\n        if (a.sub(b).norm() < EPS) return a.sub(p).norm();\n        Point ab = b.sub(a);\n        Point ap = p.sub(a);\n        double t = ap.dot(ab) / ab.dot(ab);\n        if (t < 0) return ap.norm();\n        if (t > 1) return p.sub(b).norm();\n        Point projection = a.add(ab.mul(t));\n        return p.sub(projection).norm();\n    }\n    \n    static boolean isPointInTriangle(Point p, Point a, Point b, Point c) {\n        double d1 = b.sub(a).cross(p.sub(a));\n        double d2 = c.sub(b).cross(p.sub(b));\n        double d3 = a.sub(c).cross(p.sub(c));\n        \n        boolean hasNeg = (d1 < -EPS) || (d2 < -EPS) || (d3 < -EPS);\n        boolean hasPos = (d1 > EPS) || (d2 > EPS) || (d3 > EPS);\n        \n        return !(hasNeg && hasPos);\n    }\n    \n    static boolean circleInTriangle(Point c, double r, Point a, Point b, Point p) {\n        if (!isPointInTriangle(c, a, b, p)) return false;\n        \n        double d1 = distancePointToSegment(c, a, b);\n        double d2 = distancePointToSegment(c, b, p);\n        double d3 = distancePointToSegment(c, p, a);\n        \n        return d1 >= r - EPS && d2 >= r - EPS && d3 >= r - EPS;\n    }\n    \n    static boolean triangleInCircle(Point c, double r, Point a, Point b, Point p) {\n        double d1 = c.sub(a).norm();\n        double d2 = c.sub(b).norm();\n        double d3 = c.sub(p).norm();\n        \n        return d1 <= r + EPS && d2 <= r + EPS && d3 <= r + EPS;\n    }\n    \n    static boolean circleSegmentIntersect(Point c, double r, Point a, Point b) {\n        double dist = distancePointToSegment(c, a, b);\n        return dist <= r + EPS;\n    }\n    \n    static boolean hasIntersection(Point c, double r, Point a, Point b, Point p) {\n        if (circleSegmentIntersect(c, r, a, b)) return true;\n        if (circleSegmentIntersect(c, r, b, p)) return true;\n        if (circleSegmentIntersect(c, r, p, a)) return true;\n        \n        if (isPointInTriangle(c, a, b, p)) return true;\n        \n        return false;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] tokens = line.trim().split(\"\\\\s+\");\n            if (tokens.length == 2 && tokens[0].equals(\"0\") && tokens[1].equals(\"0\")) {\n                break;\n            }\n            \n            Point p1 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            Point p2 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            Point p3 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            Point center = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            double radius = Double.parseDouble(tokens[0]);\n            \n            if (circleInTriangle(center, radius, p1, p2, p3)) {\n                System.out.println(\"a\");\n            } else if (triangleInCircle(center, radius, p1, p2, p3)) {\n                System.out.println(\"b\");\n            } else if (hasIntersection(center, radius, p1, p2, p3)) {\n                System.out.println(\"c\");\n            } else {\n                System.out.println(\"d\");\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static final double EPS = 1e-9; static class Point { double x, y; Point(double x, double  - p.y); } Point add(Point p) {  mul(double t) { return  p.y; } double cross(Point p) { return x * p.y - y * p.x; } double norm() { return  double distancePointToSegment(Point p, Point a, Point b) { if (a.sub(b).norm() < EPS) return a.sub(p).norm(); Point ab  return p.sub(projection).norm(); } static boolean isPointInTriangle(Point p, Point a, Point b, Point c) { double d1 = b.sub(a).cross(p.sub(a)); double d2 = c.sub(b).cross(p.sub(b)); double d3 = a.sub(c).cross(p.sub(c)); boolean hasNeg = (d1 < -EPS) || (d2 < -EPS) || (d3 < -EPS); boolean hasPos = (d1 > EPS) || (d2 > EPS) || (d3 > EPS); return !(hasNeg && hasPos); } static boolean  b, p); double d3 =  d2 >= r - EPS && d3 >= r - EPS; } static boolean triangleInCircle(Point c, double r,  c.sub(a).norm(); double d2 = c.sub(b).norm(); double d3 = c.sub(p).norm(); return d1 <= r + EPS && d2 <= r  <= r + EPS; } static boolean  {  b, p)) return true; if (circleSegmentIntersect(c, r, p, a)) return  } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[]  Double.parseDouble(tokens[1])); tokens = br.readLine().trim().split(\"\\\\s+\"); Point p2 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1])); tokens =  Point center = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1])); tokens = br.readLine().trim().split(\"\\\\s+\"); double radius = Double.parseDouble(tokens[0]); if (circleInTriangle(center, radius, p1, p2, p3)) { System.out.println(\"a\");  } else if (hasIntersection(center, radius, p1, p2, p3)) { System.out.println(\"c\"); } else { System.out.println(\"d\"); } } } }"], "perturbed_original": ["import java.awt.geom.Point2D; import java.util.Scanner; public class  Scanner sc = new Scanner(System.in); sc.useDelimiter(\",|\\\\s+\"); while (true)  ((x1 | y1) == 0) break; int x2 = sc.nextInt(); int y2 = sc.nextInt(); int x3 = sc.nextInt(); int y3 = sc.nextInt(); int x4 = sc.nextInt();  \u4e09\u89d2\u5f62\u306e\u7b2c1\u306e\u9802\u70b9\u306e\u5ea7\u6a19x1 y1\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09 // 2\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c2\u306e\u9802\u70b9\u306e\u5ea7\u6a19x2 y2\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09 // 3\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c3\u306e\u9802\u70b9\u306e\u5ea7\u6a19x3 y3\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09 // 4\u884c\u76ee  new Point2D.Double[4]; ps[0] = new Point2D.Double(x1, y1); ps[1] = new Point2D.Double(x2, y2); ps[2] = new Point2D.Double(x3, y3); ps[3] = new Point2D.Double(x4, y4);  < 3; i++) { max = Math.max(max, nor(ps[3], ps[i])); } if (r * r >= max) { System.out.println(\"b\"); continue;  3; i++) { double ep = new Line(ps[i], ps[(i + 1) % 3]).ep(new Line(ps[i], ps[3])); if (ep < 0) left = false; else if (ep > 0) right = false; } boolean in = left  if (!in && r < min) System.out.println(\"d\"); else System.out.println(\"c\"); } } public static double nor(Point2D.Double p, Point2D.Double q) { return (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y); } } // Output // // \u5165\u529b\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3054\u3068\u306b\u4ee5\u4e0b\u306e\u5224\u5b9a\u7d50\u679c\u3092\u51fa\u529b\u3057\u307e\u3059\u3002 // // \u5186\u304c\u4e09\u89d2\u5f62\u306b\u542b\u307e\u308c\u308b\u5834\u5408 a  Line { public Point2D.Double p1; public Point2D.Double p2;  p2; } public double length() { return Math.sqrt((p1.x - p2.x)  - p2.y)); } public  = l.p2; return (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) *  q1 = l.p1; Point2D.Double q2 = l.p2; return (p2.x -  (q2.x -  a, Point2D.Double b, Point2D.Double c) {  clockwise if (extp(p, q) < -EPS) return -1; //  on line if (Math.abs(norm(p)  static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) { return new Point2D.Double(p1.x - p2.x,  / Math.pow(norm(sub(l.p1, l.p2)), 2); Point2D.Double tp = sub(l.p1, l.p2); return new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y); } public static double inp(Point2D.Double p1, Point2D.Double p2) { return p1.x * p2.x + p1.y * p2.y; } public static double extp(Point2D.Double p1, Point2D.Double p2) { return p1.x * p2.y - p2.x *  static double norm(Point2D.Double  { Line p1q1 = new  if (ip1 <= 0) return p1q1.length(); else if (0 < ip1 && ip1 < ip2) { double d2 = ip1 / this.length(); double size = p1q1.length();  { Line p2q1 = new Line(p2, q1); return p2q1.length(); } }  Line p1q2 = new Line(p1, q2); Line q1p1 = new Line(q1, p1); Line q1p2 = new Line(q1, p2); if (this.ep(p1q1) * this.ep(p1q2) < 0 && q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0) return true; else return false; } public  = Double.MAX_VALUE; Point2D.Double q1 = q1q2.p1; Point2D.Double q2 = q1q2.p2; ans = Math.min(ans, this.disToPoint(q1)); ans  p1 + \"=>\" + p2; } }"], "original_ll": -0.6008069515228271, "sampled_ll": -0.3229215741157532, "all_perturbed_sampled_ll": [-1.1770914793014526], "all_perturbed_original_ll": [-1.3473384380340576], "perturbed_sampled_ll": -1.1770914793014526, "perturbed_original_ll": -1.3473384380340576, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def In(): return map(int,raw_input().split())\ndef D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5\ndef side(a, b, c): return (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])>0\ndef isIn(x,p0,p1,p2): return (side(p0,p1,x)==side(p1,p2,x)==side(p2,p0,x))\ndef S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0\ndef H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3)\ndef CinT(P4,r,P1,P2,P3):\n  f1 = isIn(P4,P1,P2,P3)\n  f = [H(P4,P1,P2)>=r, H(P4,P2,P3)>=r, H(P4,P3,P1)>=r]\n  if f1:\n    if all(f): return 1\n    elif any(f): return 3\n  return 0\n\ndef TinC(P4,r,P1,P2,P3):\n  f = [D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r]\n  if all(f): return 2\n  elif any(f): return 3\n  return 0\n  \nwhile 1:\n  P1 = In()\n  if P1[0]==P1[1]==0: break\n  P2 = In()\n  P3 = In()\n  P4 = In()\n  r = int(raw_input())\n  f = CinT(P4,r,P1,P2,P3)\n  if not f: f = TinC(P4,r,P1,P2,P3)\n  print 'dabc'[f]", "sampled": "import sys\nfrom math import sqrt\n\ndef read_input():\n    datasets = []\n    lines = sys.stdin.read().strip().split('\\n')\n    i = 0\n    while i < len(lines):\n        parts = lines[i].split()\n        if len(parts) == 2 and parts[0] == '0' and parts[1] == '0':\n            break\n        \n        # Read 3 triangle vertices\n        x1, y1 = map(int, lines[i].split())\n        x2, y2 = map(int, lines[i+1].split())\n        x3, y3 = map(int, lines[i+2].split())\n        \n        # Read circle center and radius\n        xc, yc = map(int, lines[i+3].split())\n        r = int(lines[i+4])\n        \n        datasets.append(((x1, y1), (x2, y2), (x3, y3), (xc, yc), r))\n        i += 5\n    \n    return datasets\n\ndef distance(p1, p2):\n    return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef point_to_segment_distance(p, a, b):\n    ax, ay = a\n    bx, by = b\n    px, py = p\n    \n    abx = bx - ax\n    aby = by - ay\n    apx = px - ax\n    apy = py - ay\n    \n    ab_ab = abx * abx + aby * aby\n    if ab_ab == 0:\n        return distance(p, a)\n    \n    ap_ab = apx * abx + apy * aby\n    t = max(0, min(1, ap_ab / ab_ab))\n    \n    closest_x = ax + t * abx\n    closest_y = ay + t * aby\n    \n    return distance(p, (closest_x, closest_y))\n\ndef point_in_triangle(p, v1, v2, v3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    \n    d1 = sign(p, v1, v2)\n    d2 = sign(p, v2, v3)\n    d3 = sign(p, v3, v1)\n    \n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    \n    return not (has_neg and has_pos)\n\ndef circle_in_triangle(v1, v2, v3, center, r):\n    # Check if center is in triangle\n    if not point_in_triangle(center, v1, v2, v3):\n        return False\n    \n    # Check distance from center to all edges\n    d1 = point_to_segment_distance(center, v1, v2)\n    d2 = point_to_segment_distance(center, v2, v3)\n    d3 = point_to_segment_distance(center, v3, v1)\n    \n    return d1 >= r and d2 >= r and d3 >= r\n\ndef triangle_in_circle(v1, v2, v3, center, r):\n    d1 = distance(center, v1)\n    d2 = distance(center, v2)\n    d3 = distance(center, v3)\n    \n    return d1 <= r and d2 <= r and d3 <= r\n\ndef circle_triangle_intersect(v1, v2, v3, center, r):\n    # Check if any vertex is inside or on the circle\n    for v in [v1, v2, v3]:\n        if distance(center, v) <= r:\n            return True\n    \n    # Check if center is inside triangle\n    if point_in_triangle(center, v1, v2, v3):\n        return True\n    \n    # Check if any edge intersects the circle\n    for a, b in [(v1, v2), (v2, v3), (v3, v1)]:\n        if point_to_segment_distance(center, a, b) <= r:\n            return True\n    \n    return False\n\ndef solve(v1, v2, v3, center, r):\n    if circle_in_triangle(v1, v2, v3, center, r):\n        return 'a'\n    elif triangle_in_circle(v1, v2, v3, center, r):\n        return 'b'\n    elif circle_triangle_intersect(v1, v2, v3, center, r):\n        return 'c'\n    else:\n        return 'd'\n\ndatasets = read_input()\nfor v1, v2, v3, center, r in datasets:\n    print(solve(v1, v2, v3, center, r))\n", "perturbed_sampled": ["import sys from math  i = 0 while i < len(lines): parts = lines[i].split() if len(parts) == 2 and parts[0] == '0' and parts[1] ==  map(int, lines[i].split()) x2, y2 = map(int, lines[i+1].split()) x3, y3 =  = map(int, lines[i+3].split()) r  r))  px, py = p abx = bx - ax aby  = py - ay  ab_ab == 0: return distance(p, a) ap_ab = apx * abx + apy * aby t = max(0, min(1, ap_ab / ab_ab)) closest_x = ax + t * abx closest_y = ay +  v2, v3): def sign(p1, p2, p3): return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1]) d1 = sign(p, v1, v2) d2 = sign(p, v2, v3) d3 = sign(p, v3, v1) has_neg = (d1 < 0) or (d2 <  or (d2 > 0) or (d3 > 0) return not (has_neg and has_pos) def circle_in_triangle(v1, v2, v3, center, r): # Check if center is in   v1, v2) d2 = point_to_segment_distance(center, v2, v3) d3 = point_to_segment_distance(center, v3, v1) return d1 >= r and d2 >=  r): d1 = distance(center, v1) d2 = distance(center, v2)  <= r and d3 <=  any vertex is inside or on the circle  r: return True # Check if center is inside triangle if  v3, center, r): if circle_in_triangle(v1, v2, v3, center, r): return 'a' elif triangle_in_circle(v1, v2, v3, center, r): return 'b' elif circle_triangle_intersect(v1, v2,  read_input() for  center, r))"], "perturbed_original": [" S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0 def H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3) def CinT(P4,r,P1,P2,P3): f1 = isIn(P4,P1,P2,P3) f = [H(P4,P1,P2)>=r, H(P4,P2,P3)>=r, H(P4,P3,P1)>=r] if f1: if all(f): return 1 elif any(f): return  if all(f): return 2 elif any(f): return 3 return 0 while 1: P1 = In() if P1[0]==P1[1]==0: break P2 = In() P3 = In() P4 = In() r = int(raw_input())  'dabc'[f]"], "original_ll": -0.8484145998954773, "sampled_ll": -0.33735522627830505, "all_perturbed_sampled_ll": [-1.5266432762145996], "all_perturbed_original_ll": [-1.5680750608444214], "perturbed_sampled_ll": -1.5266432762145996, "perturbed_original_ll": -1.5680750608444214, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint count;\nvoid solve(int depth, int card[][2], int n, int total, int goal) {\n\tint i;\n\tif(depth == n) {\n\t\tif(total == goal)\n\t\t\tcount++;\n\t\treturn;\n\t}\n\t\n\tfor(i=0;i<=card[depth][1];i++) {\n\t\tsolve(depth+1, card, n, total + card[depth][0] * i, goal);\n\t}\n}\n\nint main(void) {\n\tint n, g;\n\tint i;\n\tint goal;\n\tint j[1001];\n\tint card[1001][2];\n\twhile(1) {\n\t\tcount = 0;\n\t\tscanf(\"%d\\n\", &n);\n\t\tif(n==0) break;\n\t\tfor(i=0;i<n;i++) {\n\t\t\tscanf(\"%d %d\\n\", &card[i][0], &card[i][1]);\n\t\t}\n\t\tscanf(\"%d\\n\", &g);\n\t\tfor(i-0;i<g;i++) {\n\t\t\tscanf(\"%d\\n\", &goal);\n\t\t\tsolve(0, card, n, 0, goal);\t\n\t\t\tprintf(\"%d\\n\", count);\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint m, g;\nint a[7], b[7];\nint n;\nint count;\n\nvoid dfs(int idx, int sum) {\n    if (idx == m) {\n        if (sum == n) {\n            count++;\n        }\n        return;\n    }\n    \n    for (int i = 0; i <= b[idx]; i++) {\n        dfs(idx + 1, sum + i * a[idx]);\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &m);\n        if (m == 0) break;\n        \n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d\", &a[i], &b[i]);\n        }\n        \n        scanf(\"%d\", &g);\n        \n        for (int i = 0; i < g; i++) {\n            scanf(\"%d\", &n);\n            count = 0;\n            dfs(0, 0);\n            printf(\"%d\\n\", count);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int count; void  if (sum == n)   i * a[idx]); } } int main() { while (1) { scanf(\"%d\", &m); if (m  m; i++) { scanf(\"%d %d\", &a[i], &b[i]); } scanf(\"%d\", &g); for (int i = 0; i < g; i++) { scanf(\"%d\", &n); count = 0; dfs(0, 0); printf(\"%d\\n\", count); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int count; void solve(int depth, int card[][2], int n, int total, int goal) { int i; if(depth == n) { if(total == goal) count++;  card[1001][2]; while(1) { count = 0; scanf(\"%d\\n\", &n); if(n==0)  for(i-0;i<g;i++) { scanf(\"%d\\n\", &goal); solve(0, card, n, 0, goal); printf(\"%d\\n\", count); } } return 0; }"], "original_ll": -0.7972354888916016, "sampled_ll": -0.5349566340446472, "all_perturbed_sampled_ll": [-1.5693998336791992], "all_perturbed_original_ll": [-1.9266061782836914], "perturbed_sampled_ll": -1.5693998336791992, "perturbed_original_ll": -1.9266061782836914, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class AOJ_0154{\n    class Card{\n        int a;\n        int b;\n        Card(int a, int b){\n            this.a = a;\n            this.b = b;\n        }\n    }\n    void run(){\n        Scanner sc = new Scanner(System.in);\n        while(true){\n            int[] card_num = new int[101];\n            int m = sc.nextInt();\n            if(m==0){\n                break;\n            }\n            Card[] cards = new Card[m];\n            for(int i = 0; i < m; i++){\n                cards[i] = new Card(sc.nextInt(), sc.nextInt());\n            }\n            int ub = 7*100*10;\n            int[] dp = new int[ub];\n            dp[0] = 1;\n            for(int i = 0; i < m; i++){\n                for(int ii = 7 * 100 * 10 - cards[i].a -1; ii >= 0; ii--){\n                    for(int iii = 1; iii <= cards[i].b; iii++){\n                        if(ii + cards[i].a*iii < ub-1){\n                            dp[ii + cards[i].a*iii] += dp[ii];\n                        }\n                    }\n                }\n            }\n            /*\n              System.out.println(Arrays.toString(dp));\n              for(int i = 0; i < 100; i++){\n              System.out.println(i + \" : \" + dp[i]);\n              }\n            */\n            int g = sc.nextInt();\n            for(int i = 0; i < g; i++){\n                System.out.println(dp[sc.nextInt()]);\n            }\n        }\n    }\n    public static void main(String[] args){\n        new AOJ_0154().run();\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[] values;\n    static int[] counts;\n    static int m;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            m = sc.nextInt();\n            if (m == 0) break;\n            \n            values = new int[m];\n            counts = new int[m];\n            \n            for (int i = 0; i < m; i++) {\n                values[i] = sc.nextInt();\n                counts[i] = sc.nextInt();\n            }\n            \n            int g = sc.nextInt();\n            for (int i = 0; i < g; i++) {\n                int n = sc.nextInt();\n                int result = countCombinations(n);\n                System.out.println(result);\n            }\n        }\n        sc.close();\n    }\n    \n    static int countCombinations(int target) {\n        return dfs(0, target);\n    }\n    \n    static int dfs(int index, int remaining) {\n        if (remaining == 0) {\n            return 1;\n        }\n        if (remaining < 0 || index >= m) {\n            return 0;\n        }\n        \n        int total = 0;\n        for (int i = 0; i <= counts[index]; i++) {\n            int newRemaining = remaining - (i * values[index]);\n            if (newRemaining < 0) break;\n            total += dfs(index + 1, newRemaining);\n        }\n        \n        return total;\n    }\n}\n", "perturbed_sampled": [" int[] counts; static int  (m == 0) break; values = new int[m]; counts = new int[m]; for (int  sc.nextInt(); counts[i] = sc.nextInt(); } int g = sc.nextInt(); for (int i = 0; i < g; i++) { int n  } static int countCombinations(int target) { return dfs(0, target); } static int dfs(int index, int remaining) { if (remaining == 0) { return 1; } if  } int total = 0; for (int i = 0; i <= counts[index];  if (newRemaining < 0) break;  }"], "perturbed_original": ["import java.util.*; public  } void run(){ Scanner sc = new Scanner(System.in); while(true){ int[] card_num = new int[101]; int m = sc.nextInt(); if(m==0){ break; } Card[] cards = new Card[m]; for(int i = 0;  m; i++){ for(int ii =  0; ii--){ for(int iii = 1; iii <= cards[i].b; iii++){ if(ii + cards[i].a*iii < ub-1){ dp[ii + cards[i].a*iii] +=  0; i  } */ int g = sc.nextInt(); for(int i = 0; i < g; i++){ System.out.println(dp[sc.nextInt()]); } } } public static void main(String[] args){ new AOJ_0154().run(); } }"], "original_ll": -0.7539686560630798, "sampled_ll": -0.45200634002685547, "all_perturbed_sampled_ll": [-2.042691707611084], "all_perturbed_original_ll": [-1.9414918422698975], "perturbed_sampled_ll": -2.042691707611084, "perturbed_original_ll": -1.9414918422698975, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfrom array import array\n\ndef main():\n\twhile True:\n\t\tm = input()\n\t\tif m == 0: return 0\n\t\tdp = [array('I', [0] * 1001) for i in range(m + 1)]\n\t\tdp[0][0] = 1\n\t\tfor i in xrange(m):\n\t\t\tv, c = map(int, raw_input().split())\n\t\t\tfor j in xrange(1001):\n\t\t\t\tfor k in xrange(c + 1):\n\t\t\t\t\tnext = j + v * k\n\t\t\t\t\tif next > 1000: continue\n\t\t\t\t\tdp[i + 1][next] += dp[i][j]\n\t\tn = input()\n\t\tfor i in range(n):\n\t\t\tx = input()\n\t\t\tprint dp[m][x]\n\nif __name__ == '__main__':\n\tsys.exit(main())", "sampled": "import sys\nfrom itertools import product\n\ndef count_combinations(cards, target):\n    count = 0\n    # Generate all possible combinations\n    ranges = [range(b + 1) for a, b in cards]\n    \n    for combination in product(*ranges):\n        total = sum(combination[i] * cards[i][0] for i in range(len(cards)))\n        if total == target:\n            count += 1\n    \n    return count\n\ndef main():\n    lines = []\n    for line in sys.stdin:\n        lines.append(line.strip())\n    \n    idx = 0\n    while idx < len(lines):\n        m = int(lines[idx])\n        if m == 0:\n            break\n        \n        idx += 1\n        cards = []\n        for _ in range(m):\n            a, b = map(int, lines[idx].split())\n            cards.append((a, b))\n            idx += 1\n        \n        g = int(lines[idx])\n        idx += 1\n        \n        for _ in range(g):\n            n = int(lines[idx])\n            idx += 1\n            result = count_combinations(cards, n)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from itertools import product def count_combinations(cards, target):  1 return count def main(): lines = [] for line in  = int(lines[idx])  [] for _ in range(m): a, b = map(int, lines[idx].split()) cards.append((a, b)) idx += 1 g = int(lines[idx]) idx += 1 for _ in range(g): n = int(lines[idx]) idx += 1 result = count_combinations(cards, n) print(result) if __name__ == \"__main__\": main()"], "perturbed_original": ["import sys from array import array def main(): while True:  = [array('I', [0] * 1001) for i in range(m + 1)] dp[0][0] = 1   1000: continue dp[i + 1][next] += dp[i][j] n = input() for i in range(n): x = input() print dp[m][x] if __name__ == '__main__': sys.exit(main())"], "original_ll": -0.790590763092041, "sampled_ll": -0.6858313083648682, "all_perturbed_sampled_ll": [-1.737596035003662], "all_perturbed_original_ll": [-2.010908603668213], "perturbed_sampled_ll": -1.737596035003662, "perturbed_original_ll": -2.010908603668213, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "//from PKU1125\n#define M 101\ndouble dist[M][M],d;\nnext[M][M],x[M],y[M];\nmain(){\n\tint a,b,k,n,i,j;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\t/*initialize*/\n\t\tfor(i=1;i<=n;i++)scanf(\"%d\",&a),scanf(\"%d%d\",x+a,y+a);\n\t\tfor(i=1;i<=n;i++)for(j=1;j<=n;next[i][j]=j,j++)\n\t\t\tdist[i][j]=(d=hypot(x[i]-x[j],y[i]-y[j]))<50.1?d:999;\n\n\t\t{/*warshall-floyd*/\n\t\t\tint k,i,j;\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\t\tif(dist[i][j]>dist[i][k]+dist[k][j])\n\t\t\t\t\t\t\tdist[i][j]=dist[i][k]+dist[k][j],next[i][j]=next[i][k];\n\t\t\t\t\t}\n\t\t}\n\n\t\t{/*query*/\n\t\t\tfor(scanf(\"%d\",&k);k;k--){\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\tif(dist[a][b]>998)puts(\"NA\");\n\t\t\t\telse{\n\t\t\t\t\tfor(j=a;j!=b;j=next[j][b])printf(\"%d \",j);\n\t\t\t\t\tprintf(\"%d\\n\",b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}exit(0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#define MAX_N 101\n#define INF 1e9\n\ntypedef struct {\n    int id;\n    int x, y;\n} Building;\n\nBuilding buildings[MAX_N];\nint n;\ndouble dist[MAX_N][MAX_N];\nint next_node[MAX_N][MAX_N];\n\ndouble calc_dist(int i, int j) {\n    double dx = buildings[i].x - buildings[j].x;\n    double dy = buildings[i].y - buildings[j].y;\n    return sqrt(dx * dx + dy * dy);\n}\n\nvoid floyd_warshall() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                dist[i][j] = 0;\n                next_node[i][j] = -1;\n            } else {\n                double d = calc_dist(i, j);\n                if (d <= 50.0) {\n                    dist[i][j] = d;\n                    next_node[i][j] = j;\n                } else {\n                    dist[i][j] = INF;\n                    next_node[i][j] = -1;\n                }\n            }\n        }\n    }\n    \n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                    next_node[i][j] = next_node[i][k];\n                }\n            }\n        }\n    }\n}\n\nvoid print_path(int start, int end) {\n    if (dist[start][end] >= INF) {\n        printf(\"NA\\n\");\n        return;\n    }\n    \n    printf(\"%d\", buildings[start].id);\n    int current = start;\n    while (current != end) {\n        current = next_node[current][end];\n        printf(\" %d\", buildings[current].id);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %d\", &buildings[i].id, &buildings[i].x, &buildings[i].y);\n        }\n        \n        floyd_warshall();\n        \n        int m;\n        scanf(\"%d\", &m);\n        \n        for (int i = 0; i < m; i++) {\n            int s, g;\n            scanf(\"%d %d\", &s, &g);\n            \n            int si = -1, gi = -1;\n            for (int j = 0; j < n; j++) {\n                if (buildings[j].id == s) si = j;\n                if (buildings[j].id == g) gi = j;\n            }\n            \n            print_path(si, gi);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <math.h> #include <string.h> #define MAX_N 101 #define INF 1e9 typedef struct { int id; int x, y; } Building; Building buildings[MAX_N]; int n; double dist[MAX_N][MAX_N]; int next_node[MAX_N][MAX_N]; double calc_dist(int i, int j) { double dx = buildings[i].x - buildings[j].x; double dy = buildings[i].y - buildings[j].y; return sqrt(dx * dx + dy * dy); } void floyd_warshall() { for (int i = 0; i < n; i++) { for (int j =  50.0)  dist[i][j] = INF; next_node[i][j] = -1; } } } } for (int k = 0; k < n; k++)  { for (int  void print_path(int start, int end) { if (dist[start][end] >= INF) { printf(\"NA\\n\"); return; } printf(\"%d\", buildings[start].id); int current = start; while (current != end) {  < n; i++) { scanf(\"%d %d  = 0; j < n; j++) { if (buildings[j].id == s) si = j; if (buildings[j].id == g) gi = j; } print_path(si, gi); } } return 0; }"], "perturbed_original": ["//from PKU1125  /*initialize*/ for(i=1;i<=n;i++)scanf(\"%d\",&a),scanf(\"%d%d\",x+a,y+a); for(i=1;i<=n;i++)for(j=1;j<=n;next[i][j]=j,j++) dist[i][j]=(d=hypot(x[i]-x[j],y[i]-y[j]))<50.1?d:999; {/*warshall-floyd*/ int k,i,j; for(k=1;k<=n;k++) for(i=1;i<=n;i++) for(j=1;j<=n;j++){ if(dist[i][j]>dist[i][k]+dist[k][j]) dist[i][j]=dist[i][k]+dist[k][j],next[i][j]=next[i][k]; } } {/*query*/ for(scanf(\"%d\",&k);k;k--){ scanf(\"%d%d\",&a,&b); if(dist[a][b]>998)puts(\"NA\"); else{ for(j=a;j!=b;j=next[j][b])printf(\"%d \",j); printf(\"%d\\n\",b); } } } }exit(0); }"], "original_ll": -1.1463114023208618, "sampled_ll": -0.29177767038345337, "all_perturbed_sampled_ll": [-1.1057748794555664], "all_perturbed_original_ll": [-1.439687967300415], "perturbed_sampled_ll": -1.1057748794555664, "perturbed_original_ll": -1.439687967300415, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\npublic class Main {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic Scanner stdIn = new Scanner(System.in);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic int INF = 2 << 20;\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdouble [][] cost = new double[n+1][n+1];\n\t\t\t\n\t\t\tfor(int i = 0; i < n+1; i++) {\n\t\t\t\tArrays.fill(cost[i], INF);\n\t\t\t}\n\t\t\tData[] list = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tlist[i] = new Data(a,b,c);\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tdouble sum = Math.sqrt((list[i].x - list[j].x)*(list[i].x - list[j].x) + (list[i].y - list[j].y) * (list[i].y - list[j].y));\n\t\t\t\t\tif(sum > 50.0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcost[list[i].id][list[j].id] = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tdouble[] d = new double[n+1];\n\t\t\t\tboolean[] used = new boolean[n+1];\n\t\t\t\tint[] prev = new int[n+1];\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint g = sc.nextInt();\n\t\t\t\t\n\t\t\t\tArrays.fill(d, INF);\n\t\t\t\tArrays.fill(used, false);\n\t\t\t\tArrays.fill(prev, -1);\n\t\t\t\td[s] = 0;\n\t\t\t\t\n\t\t\t\twhile(true) {\n\t\t\t\t\tint v = -1;\n\t\t\t\t\tfor(int u= 0; u < n+1; u++) {\n\t\t\t\t\t\tif(!used[u] && (v == -1 || d[u] < d[v])) v = u;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(v == -1) break;\n\t\t\t\t\tused[v] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor(int u = 0; u < n+1; u++) {\n\t\t\t\t\t\tif(d[u] > d[v] + cost[v][u]) {\n\t\t\t\t\t\t\td[u] = d[v] + cost[v][u];\n\t\t\t\t\t\t\tprev[u] = v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(d[g] == INF) {\n\t\t\t\t\tout.println(\"NA\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tArrayList<Integer> Xist = new ArrayList<Integer>();\n\t\t\t\tfor(; g != -1; g = prev[g]) Xist.add(g);\n\t\t\t\t\n\t\t\t\tCollections.reverse(Xist);\n\t\t\t\tout.print(Xist.get(0));\n\t\t\t\tfor(int j = 1; j < Xist.size(); j++) {\n\t\t\t\t\tout.print(\" \" + Xist.get(j));\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\tout.flush();\n\t}\n\t\n\tstatic class Data {\n\t\tint id;\n\t\tint x;\n\t\tint y;\n\t\t\n\t\tData(int a, int b, int c) {\n\t\t\tid = a;\n\t\t\tx = b;\n\t\t\ty = c;\n\t\t}\n\t}\n\t\n\n\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n     \n    public int nextInt() {\n        return (int)nextLong();\n    }\n     \n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n     \n \n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Building {\n        int id;\n        int x, y;\n        \n        Building(int id, int x, int y) {\n            this.id = id;\n            this.x = x;\n            this.y = y;\n        }\n        \n        double distance(Building other) {\n            return Math.sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        int buildingId;\n        double distance;\n        \n        State(int buildingId, double distance) {\n            this.buildingId = buildingId;\n            this.distance = distance;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Double.compare(this.distance, other.distance);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            Map<Integer, Building> buildings = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                int id = sc.nextInt();\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                buildings.put(id, new Building(id, x, y));\n            }\n            \n            int m = sc.nextInt();\n            \n            for (int i = 0; i < m; i++) {\n                int start = sc.nextInt();\n                int goal = sc.nextInt();\n                \n                List<Integer> path = findPath(buildings, start, goal);\n                \n                if (path == null) {\n                    System.out.println(\"NA\");\n                } else {\n                    StringBuilder sb = new StringBuilder();\n                    for (int j = 0; j < path.size(); j++) {\n                        if (j > 0) sb.append(\" \");\n                        sb.append(path.get(j));\n                    }\n                    System.out.println(sb.toString());\n                }\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static List<Integer> findPath(Map<Integer, Building> buildings, int start, int goal) {\n        Map<Integer, Double> dist = new HashMap<>();\n        Map<Integer, Integer> prev = new HashMap<>();\n        PriorityQueue<State> pq = new PriorityQueue<>();\n        \n        for (int id : buildings.keySet()) {\n            dist.put(id, Double.MAX_VALUE);\n        }\n        \n        dist.put(start, 0.0);\n        pq.offer(new State(start, 0.0));\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            int currentId = current.buildingId;\n            \n            if (current.distance > dist.get(currentId)) {\n                continue;\n            }\n            \n            if (currentId == goal) {\n                break;\n            }\n            \n            Building currentBuilding = buildings.get(currentId);\n            \n            for (int nextId : buildings.keySet()) {\n                if (nextId == currentId) continue;\n                \n                Building nextBuilding = buildings.get(nextId);\n                double distance = currentBuilding.distance(nextBuilding);\n                \n                if (distance <= 50.0) {\n                    double newDist = dist.get(currentId) + distance;\n                    \n                    if (newDist < dist.get(nextId)) {\n                        dist.put(nextId, newDist);\n                        prev.put(nextId, currentId);\n                        pq.offer(new State(nextId, newDist));\n                    }\n                }\n            }\n        }\n        \n        if (!prev.containsKey(goal) && start != goal) {\n            return null;\n        }\n        \n        List<Integer> path = new ArrayList<>();\n        int current = goal;\n        \n        while (current != start) {\n            path.add(current);\n            if (!prev.containsKey(current)) {\n                return null;\n            }\n            current = prev.get(current);\n        }\n        path.add(start);\n        \n        Collections.reverse(path);\n        return path;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {  other) { return  distance; } @Override public int compareTo(State other) { return Double.compare(this.distance, other.distance); } } public static void main(String[] args) { Scanner  sc.nextInt(); if (n == 0) break;  0; i < n; i++) { int id = sc.nextInt(); int x = sc.nextInt(); int y = sc.nextInt(); buildings.put(id, new Building(id, x, y));  int goal = sc.nextInt();  { System.out.println(\"NA\");  (j > 0) sb.append(\" \"); sb.append(path.get(j)); } System.out.println(sb.toString()); } } } sc.close(); } static List<Integer> findPath(Map<Integer, Building>  new HashMap<>(); Map<Integer, Integer> prev = new HashMap<>(); PriorityQueue<State> pq = new PriorityQueue<>(); for (int id  0.0)); while (!pq.isEmpty()) { State current = pq.poll(); int currentId = current.buildingId; if (current.distance > dist.get(currentId)) { continue; } if  for (int nextId : buildings.keySet()) { if (nextId == currentId) continue; Building nextBuilding = buildings.get(nextId); double distance = currentBuilding.distance(nextBuilding); if (distance <= 50.0) { double newDist = dist.get(currentId) + distance; if (newDist < dist.get(nextId)) { dist.put(nextId, newDist); prev.put(nextId, currentId); pq.offer(new State(nextId, newDist)); } } } } if (!prev.containsKey(goal) && start !=  int current = goal; while (current != start) { path.add(current); if (!prev.containsKey(current)) { return null; } current = prev.get(current); } path.add(start); Collections.reverse(path); return path; } }"], "perturbed_original": ["import java.io.IOException; import java.io.InputStream;  import java.util.Scanner; public class Main { static PrintWriter out = new PrintWriter(System.out); static Scanner stdIn = new Scanner(System.in); static FastScanner sc = new   if(n == 0) break; double [][] cost = new double[n+1][n+1]; for(int i = 0; i < n+1; i++) { Arrays.fill(cost[i], INF); } Data[] list = new Data[n]; for(int i = 0; i < n; i++) { int  0;  < n; j++) { double sum  } cost[list[i].id][list[j].id] = sum; } } int m = sc.nextInt(); for(int i = 0; i < m; i++) { double[] d = new double[n+1]; boolean[] used = new boolean[n+1]; int[] prev = new int[n+1]; int s = sc.nextInt(); int g = sc.nextInt();  {  u++) { if(!used[u] && (v == -1 || d[u] < d[v])) v = u;   out.println(\"NA\"); continue; }  = prev[g]) Xist.add(g); Collections.reverse(Xist); out.print(Xist.get(0)); for(int  + Xist.get(j)); } out.println(); } } out.flush(); } static class Data { int  c) { id = a; x = b; y = c;  = System.in; private final byte[] buffer = new byte[1024]; private int ptr = 0; private int buflen = 0; private boolean hasNextByte() { if (ptr < buflen) { return true; }else{ ptr = 0; try  } if (buflen <= 0) { return  boolean isPrintableChar(int c) { return 33 <= c && c <= 126;} private void skipUnprintable()  new NoSuchElementException(); StringBuilder sb  nextLong() { if (!hasNext()) throw new NoSuchElementException(); long n  if (b == '-') { minus = true; b = readByte(); } if (b < '0' || '9' < b) {  b <= '9') { n *= 10; n += b - '0'; }else if(b == -1 || !isPrintableChar(b)){ return minus ? -n : n; }else{ throw new  { return (int)nextLong(); } public double nextDouble() { return Double.parseDouble(next()); } }"], "original_ll": -0.4043050706386566, "sampled_ll": -0.2971985936164856, "all_perturbed_sampled_ll": [-1.3540209531784058], "all_perturbed_original_ll": [-1.5868560075759888], "perturbed_sampled_ll": -1.3540209531784058, "perturbed_original_ll": -1.5868560075759888, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import copy, math\n\ndef f(n, d, D, res, buil):\n    global sd, ans\n    d += D\n    res.append(n)\n    if sd is not None and sd <= d:\n        return\n    elif n == g:\n        ans = res\n        sd = d\n        return\n    else:\n        new_buil = copy.deepcopy(buil)\n        A = new_buil[n]\n        del new_buil[n]\n        for m, B in new_buil.items():\n            D = py(A, B)\n            if D:\n                f(m, d, D, res[:], new_buil)\n            \ndef py(A, B):\n    x = 0\n    y = 1\n    D = math.sqrt((B[x]-A[x])**2+(B[y]-A[y])**2)\n    if D <= 50:\n        return D\n\nwhile True:\n    N = input()\n    if N == 0: break\n    buil = {}\n    for i in range(N):\n        n, x, y = map(int, raw_input().split())\n        buil[n] = (x, y)\n    for i in range(input()):\n        s, g = map(int, raw_input().split())\n        sd = None\n        ans = None\n        f(s, 0, 0, [], buil)\n        if ans:\n            print ' '.join(map(str, ans))\n        else:\n            print 'NA'", "sampled": "import sys\nfrom collections import deque\nimport math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef bfs(start, goal, buildings, adjacency):\n    if start == goal:\n        return [start]\n    \n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        current, path = queue.popleft()\n        \n        for neighbor in adjacency[current]:\n            if neighbor in visited:\n                continue\n            \n            visited.add(neighbor)\n            new_path = path + [neighbor]\n            \n            if neighbor == goal:\n                return new_path\n            \n            queue.append((neighbor, new_path))\n    \n    return None\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    buildings = {}\n    for _ in range(n):\n        parts = list(map(int, input().split()))\n        b_id = parts[0]\n        x = parts[1]\n        y = parts[2]\n        buildings[b_id] = (x, y)\n    \n    # Build adjacency list\n    adjacency = {b_id: [] for b_id in buildings}\n    for b1 in buildings:\n        for b2 in buildings:\n            if b1 != b2:\n                dist = distance(buildings[b1], buildings[b2])\n                if dist <= 50:\n                    adjacency[b1].append(b2)\n    \n    m = int(input())\n    results = []\n    for _ in range(m):\n        s, g = map(int, input().split())\n        path = bfs(s, g, buildings, adjacency)\n        if path is None:\n            results.append(\"NA\")\n        else:\n            results.append(\" \".join(map(str, path)))\n    \n    for result in results:\n        print(result)\n", "perturbed_sampled": ["import sys from collections import deque import math def distance(p1, p2): return math.sqrt((p1[0] - p2[0])**2 +  = {start} while queue: current, path = queue.popleft() for neighbor in  new_path)) return None  buildings = {} for _ in range(n): parts = list(map(int, input().split())) b_id = parts[0] x = parts[1] y = parts[2] buildings[b_id] = (x, y) # Build adjacency list adjacency = {b_id: [] for b_id in buildings} for b1 in buildings: for b2 in buildings: if  50: adjacency[b1].append(b2) m = int(input()) results = [] for _  results.append(\" \".join(map(str, path))) for result in results: print(result)"], "perturbed_original": ["import copy, math def f(n, d, D, res, buil): global sd, ans d += D res.append(n) if sd is not None and sd <= d: return elif n ==  D <= 50: return D while True: N = input() if N == 0: break buil = {} for i in range(N): n, x, y = map(int, raw_input().split()) buil[n] = (x, y) for  None ans = None f(s, 0, 0, [], buil) if ans: print ' '.join(map(str, ans)) else: print 'NA'"], "original_ll": -1.1736546754837036, "sampled_ll": -0.4460444450378418, "all_perturbed_sampled_ll": [-1.5310155153274536], "all_perturbed_original_ll": [-2.3562350273132324], "perturbed_sampled_ll": -1.5310155153274536, "perturbed_original_ll": -2.3562350273132324, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ty;\n    int tx;\n    int sharp;\n} POINT;\n\nPOINT queue[10000000];\nint head, tail;\n\nvoid enq(POINT t)\n{\n    queue[tail++] = t;\n    if (tail == 10000000){\n        tail = 0;\n    }\n}\n\nvoid deq(POINT *t)\n{\n    *t = queue[head++];\n    if (head == 10000000){\n        head = 0;\n    }\n}\n\nint main(void)\n{\n    POINT temp, add;\n    int ans;\n    int i, j;\n    int x, y;\n    int mx, my;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int cost[102][102];\n    char map[102][103];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        getchar();\n        \n        memset(map, '.', sizeof(map));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%c\", &map[i][j]);\n                \n                if (map[i][j] == '&'){\n                    temp.tx = j;\n                    temp.ty = i;\n                }\n            }\n            getchar();\n        }\n        \n        for (i = 0; i <= y + 1; i++){\n            for (j = 0; j <= x + 1; j++){\n                cost[i][j] = 100000;\n            }\n        }\n        \n        cost[temp.ty][temp.tx] = 0;\n        temp.sharp = 0;\n        head = tail = 0;\n        enq(temp);\n        ans = 100000;\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (0 == temp.tx || 0 == temp.ty || x + 1 == temp.tx || y + 1 == temp.ty){\n                ans = (ans > temp.sharp ? temp.sharp : ans);\n                continue;\n            }\n            \n            for (i = 0; i < 4; i++){\n                mx = temp.tx + dx[i];\n                my = temp.ty + dy[i];\n                add = temp;\n                if (cost[my][mx] > add.sharp){\n                    if ((map[my][mx] == '.') && map[temp.ty][temp.tx] == '#'){\n                        add.sharp++;\n                    }\n                    cost[my][mx] = add.sharp;\n                    add.tx = mx;\n                    add.ty = my;\n                    enq(add);\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAXN 105\n\ntypedef struct {\n    int x, y, cost;\n} State;\n\ntypedef struct {\n    State data[MAXN * MAXN];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue *q) {\n    q->front = 0;\n    q->rear = 0;\n}\n\nvoid enqueue(Queue *q, State s) {\n    q->data[q->rear++] = s;\n}\n\nState dequeue(Queue *q) {\n    return q->data[q->front++];\n}\n\nint isEmpty(Queue *q) {\n    return q->front == q->rear;\n}\n\nint main() {\n    int n, m;\n    char grid[MAXN][MAXN];\n    int dist[MAXN][MAXN];\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    \n    while (scanf(\"%d %d\", &n, &m) == 2 && (n || m)) {\n        int startX = -1, startY = -1;\n        \n        for (int i = 0; i < m; i++) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '&') {\n                    startX = i;\n                    startY = j;\n                }\n                dist[i][j] = INT_MAX;\n            }\n        }\n        \n        // Check if we can reach from boundary\n        Queue q;\n        initQueue(&q);\n        \n        // Start from all boundary cells\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || i == m-1 || j == 0 || j == n-1) {\n                    State s;\n                    s.x = i;\n                    s.y = j;\n                    if (grid[i][j] == '#') {\n                        s.cost = 1;\n                    } else {\n                        s.cost = 0;\n                    }\n                    dist[i][j] = s.cost;\n                    enqueue(&q, s);\n                }\n            }\n        }\n        \n        while (!isEmpty(&q)) {\n            State cur = dequeue(&q);\n            int x = cur.x;\n            int y = cur.y;\n            int cost = cur.cost;\n            \n            if (cost > dist[x][y]) continue;\n            \n            for (int d = 0; d < 4; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                \n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    int newCost = cost;\n                    if (grid[x][y] == '#' && grid[nx][ny] != '#') {\n                        newCost = cost + 1;\n                    }\n                    \n                    if (newCost < dist[nx][ny]) {\n                        dist[nx][ny] = newCost;\n                        State ns;\n                        ns.x = nx;\n                        ns.y = ny;\n                        ns.cost = newCost;\n                        enqueue(&q, ns);\n                    }\n                }\n            }\n        }\n        \n        if (dist[startX][startY] == INT_MAX) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", dist[startX][startY]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h>  y, cost; } State; typedef struct { State data[MAXN * MAXN]; int front, rear; }  0; } void enqueue(Queue *q, State s) { q->data[q->rear++] = s; } State dequeue(Queue *q) { return q->data[q->front++]; } int isEmpty(Queue *q) { return q->front == q->rear;  dist[MAXN][MAXN]; int dx[] = {0, 0, 1, -1}; int dy[]  == 2 && (n || m)) { int startX = -1, startY = -1; for (int i = 0; i < m;  < n; j++) { if  we can reach from boundary Queue q;  = 0; i  < n; j++) { if (i == 0 || i ==   } } } while (!isEmpty(&q)) { State cur = dequeue(&q); int x = cur.x; int y = cur.y; int cost = cur.cost; if (cost > dist[x][y]) continue; for  + dy[d]; if (nx >= 0 && nx < m && ny >= 0 && ny < n) { int newCost = cost; if (grid[x][y] == '#' &&  if (newCost < dist[nx][ny]) { dist[nx][ny] = newCost; State ns;  ns); } } } } if (dist[startX][startY] == INT_MAX) { printf(\"-1\\n\"); } else { printf(\"%d\\n\", dist[startX][startY]); } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> typedef struct { int ty; int tx; int sharp;  { queue[tail++] = t; if (tail == 10000000){ tail =  int main(void) { POINT  int  dy[4] = {0, 1, 0, -1}; int cost[102][102]; char map[102][103]; while (1){ scanf(\"%d%d\", &x, &y); if  sizeof(map)); for (i = 1; i  j++){ scanf(\"%c\", &map[i][j]); if (map[i][j]  getchar(); } for (i = 0; i <= y +  enq(temp); ans = 100000; while (head != tail){ deq(&temp); if (0 == temp.tx || 0 ==  1 == temp.ty){ ans = (ans > temp.sharp ? temp.sharp : ans); continue; } for (i = 0; i < 4; i++){ mx =  temp; if (cost[my][mx] > add.sharp){ if ((map[my][mx] == '.') && map[temp.ty][temp.tx] == '#'){ add.sharp++; } cost[my][mx] = add.sharp; add.tx = mx; add.ty = my; enq(add); } } } printf(\"%d\\n\", ans); } return (0); }"], "original_ll": -0.5829373598098755, "sampled_ll": -0.3412652611732483, "all_perturbed_sampled_ll": [-1.4496663808822632], "all_perturbed_original_ll": [-1.83247971534729], "perturbed_sampled_ll": -1.4496663808822632, "perturbed_original_ll": -1.83247971534729, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tint gy = -1;\n\t\t\tint gx = -1;\n\t\t\tboolean[][] map = new boolean[h + 2][w + 2];\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (c[j - 1] == '#') {\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t} else if (c[j - 1] == '&') {\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\t\t\tint[][] cnt = new int[h + 2][w + 2];\n\t\t\t\n\t\t\tfor (int[] c : cnt) {\n\t\t\t\tArrays.fill(c, 1 << 10);\n\t\t\t}\n\t\t\tcnt[0][0] = 0;\n\t\t\tDeque<List<Integer>> deque = new ArrayDeque<List<Integer>>();\n\t\t\tdeque.offer(Arrays.asList(0, 0));\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tList<Integer> list = deque.poll();\n\t\t\t\tint y = list.get(0);\n\t\t\t\tint x = list.get(1);\n\t\t\t\tfor (int[] d : dxy) {\n\t\t\t\t\tint dy = y + d[0];\n\t\t\t\t\tint dx = x + d[1];\n\t\t\t\t\tif (0 <= dy && dy < h + 2 && 0 <= dx & dx < w + 2) {\n\t\t\t\t\t\tint r;\n\t\t\t\t\t\tif (map[y][x] && !map[dy][dx]) {\n\t\t\t\t\t\t\tr = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cnt[dy][dx] > cnt[y][x] + r) {\n\t\t\t\t\t\t\tcnt[dy][dx] = cnt[y][x] + r;\n\t\t\t\t\t\t\tdeque.offer(Arrays.asList(dy, dx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt[gy][gx]);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class State implements Comparable<State> {\n        int x, y, climbs;\n        \n        State(int x, int y, int climbs) {\n            this.x = x;\n            this.y = y;\n            this.climbs = climbs;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return this.climbs - other.climbs;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            int n = Integer.parseInt(parts[0]);\n            int m = Integer.parseInt(parts[1]);\n            \n            if (n == 0 && m == 0) break;\n            \n            char[][] grid = new char[m][n];\n            int targetX = -1, targetY = -1;\n            \n            for (int i = 0; i < m; i++) {\n                String row = br.readLine();\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = row.charAt(j);\n                    if (grid[i][j] == '&') {\n                        targetX = i;\n                        targetY = j;\n                    }\n                }\n            }\n            \n            int result = solve(grid, m, n, targetX, targetY);\n            System.out.println(result);\n        }\n    }\n    \n    static int solve(char[][] grid, int m, int n, int targetX, int targetY) {\n        int[][] minClimbs = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(minClimbs[i], Integer.MAX_VALUE);\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        \n        // Start from all border cells\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {\n                    int initialClimbs = (grid[i][j] == '#') ? 1 : 0;\n                    pq.offer(new State(i, j, initialClimbs));\n                    minClimbs[i][j] = initialClimbs;\n                }\n            }\n        }\n        \n        int[] dx = {-1, 1, 0, 0};\n        int[] dy = {0, 0, -1, 1};\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            if (current.x == targetX && current.y == targetY) {\n                return current.climbs;\n            }\n            \n            if (current.climbs > minClimbs[current.x][current.y]) {\n                continue;\n            }\n            \n            for (int i = 0; i < 4; i++) {\n                int nx = current.x + dx[i];\n                int ny = current.y + dy[i];\n                \n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    boolean currentInMoat = (grid[current.x][current.y] == '#');\n                    boolean nextInMoat = (grid[nx][ny] == '#');\n                    \n                    int newClimbs = current.climbs;\n                    if (currentInMoat && !nextInMoat) {\n                        newClimbs++;\n                    }\n                    \n                    if (newClimbs < minClimbs[nx][ny]) {\n                        minClimbs[nx][ny] = newClimbs;\n                        pq.offer(new State(nx, ny, newClimbs));\n                    }\n                }\n            }\n        }\n        \n        return minClimbs[targetX][targetY];\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  Comparable<State>  = climbs; } @Override public int compareTo(State other) { return this.climbs - other.climbs; } } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] parts = line.trim().split(\"\\\\s+\"); int n = Integer.parseInt(parts[0]); int  0) break; char[][] grid = new  row = br.readLine(); for (int j = 0;  == '&') { targetX = i; targetY = j; }  int n, int targetX, int targetY) { int[][] minClimbs = new int[m][n]; for (int i = 0; i  new PriorityQueue<>(); // Start from all border cells for (int i = 0; i < m; i++) { for (int j = 0; j <  m - 1 || j  initialClimbs = (grid[i][j] == '#') ? 1 :  } int[] dx = {-1, 1, 0, 0}; int[] dy  = pq.poll(); if (current.x == targetX && current.y == targetY) { return current.climbs; } if (current.climbs > minClimbs[current.x][current.y]) { continue; } for (int i =  (nx >= 0  boolean nextInMoat = (grid[nx][ny] == '#'); int newClimbs = current.climbs; if (currentInMoat && !nextInMoat) { newClimbs++; } if (newClimbs <  } } } return minClimbs[targetX][targetY]; } }"], "perturbed_original": ["import java.util.ArrayDeque; import java.util.Arrays; import java.util.Deque; import java.util.List;  { int  -1; int gx = -1; boolean[][] map = new boolean[h + 2][w +  {  <= w; j++) { if (c[j - 1] == '#') { map[i][j] = true; } else if (c[j - 1] == '&') { gy = i; gx = j; } } } int[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } }; int[][] cnt = new int[h + 2][w + 2];   d : dxy) { int dy = y + d[0]; int dx = x + d[1]; if (0 <= dy && dy < h + 2 && 0 <= dx & dx < w + 2) { int r; if (map[y][x]  = 0; } if (cnt[dy][dx] > cnt[y][x] + r) {  } System.out.println(cnt[gy][gx]); } } }"], "original_ll": -0.45212188363075256, "sampled_ll": -0.29742056131362915, "all_perturbed_sampled_ll": [-1.5152140855789185], "all_perturbed_original_ll": [-1.4388362169265747], "perturbed_sampled_ll": -1.5152140855789185, "perturbed_original_ll": -1.4388362169265747, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from heapq import heappush, heappop\n\nwhile True:\n  n, m = map(int, input().split())\n  if n == 0: break\n\n  mp = [\"X\" + input() + \"X\" for _ in range(m)]\n  mp.insert(0, \"X\" * (n + 2))\n  mp.append(\"X\" * (n + 2))\n  \n  que = []\n  visited = [[False] * (n + 2) for _ in range(m + 2)]\n  sur_flag = False\n  for i in range(1, n + 1):\n    if mp[1][i] ==\"&\" or mp[m][i] == \"&\":\n      sur_flag = True\n      break\n    c1, s1 = (1, 0) if mp[1][i] == \"#\" else (0, 1)\n    c2, s2 = (1, 0) if mp[m][i] == \"#\" else (0, 1)\n    heappush(que, (c1, s1, (i, 1)))\n    heappush(que, (c2, s2, (i, m)))\n    visited[1][i] = True\n    visited[m][i] = True\n  \n  for i in range(1, m + 1):\n    if mp[i][1] == \"&\" or mp[i][n] == \"&\":\n      sur_flag = True\n      break\n    c1, s1 = (1, 0) if mp[i][1] == \"#\" else (0, 1)\n    c2, s2 = (1, 0) if mp[i][n] == \"#\" else (0, 1)\n    heappush(que, (c1, s1, (1, i)))\n    heappush(que, (c2, s2, (n, i)))\n    visited[i][1] = True\n    visited[i][n] = True\n  \n  if sur_flag:\n    print(0)\n    continue\n  \n  direct = ((0, 1), (0, -1), (1, 0), (-1, 0))\n  reached = False\n  \n  while que and not reached:\n    cost, status, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      newx, newy = x + dx, y + dy\n      if not visited[newy][newx]:\n        visited[newy][newx] = True\n        if mp[newy][newx] == \"&\":\n          print(cost)\n          reached = True\n          break\n        elif mp[newy][newx] == \"#\":\n          if status == 1:\n            heappush(que, (cost + 1, 0, (newx, newy)))\n          else:\n            heappush(que, (cost, 0, (newx, newy)))\n        elif mp[newy][newx] == \".\":\n          heappush(que,(cost, 1, (newx, newy)))\n", "sampled": "from collections import deque\n\ndef solve(n, m, grid):\n    # Find the position of '&' (castle keep)\n    castle_pos = None\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '&':\n                castle_pos = (i, j)\n                break\n        if castle_pos:\n            break\n    \n    # BFS with state (row, col, climbs)\n    # We want to find minimum climbs to reach castle from outside\n    # Outside means any position on the border or reachable from border\n    \n    # Use 0-1 BFS (or Dijkstra-like approach)\n    # State: (climbs, row, col, in_moat)\n    # in_moat: True if currently in a moat\n    \n    visited = {}  # (row, col, in_moat) -> min_climbs\n    pq = deque()\n    \n    # Start from all border positions\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or i == m-1 or j == 0 or j == n-1:\n                in_moat = (grid[i][j] == '#')\n                pq.append((0, i, j, in_moat))\n                visited[(i, j, in_moat)] = 0\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    while pq:\n        climbs, row, col, in_moat = pq.popleft()\n        \n        if row == castle_pos[0] and col == castle_pos[1]:\n            return climbs\n        \n        if visited.get((row, col, in_moat), float('inf')) < climbs:\n            continue\n        \n        for dr, dc in directions:\n            nr, nc = row + dr, col + dc\n            if 0 <= nr < m and 0 <= nc < n:\n                next_is_moat = (grid[nr][nc] == '#')\n                \n                # Calculate climbs needed\n                new_climbs = climbs\n                if in_moat and not next_is_moat:\n                    # Climbing out of moat\n                    new_climbs = climbs + 1\n                \n                if visited.get((nr, nc, next_is_moat), float('inf')) > new_climbs:\n                    visited[(nr, nc, next_is_moat)] = new_climbs\n                    if new_climbs == climbs:\n                        pq.appendleft((new_climbs, nr, nc, next_is_moat))\n                    else:\n                        pq.append((new_climbs, nr, nc, next_is_moat))\n    \n    return -1\n\nwhile True:\n    line = input().split()\n    n, m = int(line[0]), int(line[1])\n    if n == 0 and m == 0:\n        break\n    \n    grid = []\n    for _ in range(m):\n        grid.append(input().strip())\n    \n    result = solve(n, m, grid)\n    print(result)\n", "perturbed_sampled": ["from collections  of '&' (castle keep) castle_pos = None for i in range(m): for j in range(n): if grid[i][j] == '&': castle_pos = (i, j) break if castle_pos: break # BFS  minimum climbs to  BFS (or Dijkstra-like approach) # State: (climbs, row, col, in_moat) # in_moat: True if currently in a moat visited = {} # (row, col, in_moat) -> min_climbs pq =  range(m): for j in range(n): if i == 0 or i == m-1 or j  '#') pq.append((0, i, j, in_moat)) visited[(i,  in_moat = pq.popleft() if row == castle_pos[0] and col == castle_pos[1]: return climbs if visited.get((row, col, in_moat), float('inf')) < climbs: continue  dr, col + dc if 0 <= nr < m and 0  not  1 if visited.get((nr, nc, next_is_moat), float('inf')) > new_climbs: visited[(nr, nc, next_is_moat)] = new_climbs if new_climbs == climbs: pq.appendleft((new_climbs, nr, nc, next_is_moat)) else: pq.append((new_climbs, nr, nc, next_is_moat)) return -1 while True: line = input().split() n, m  0: break grid =  grid) print(result)"], "perturbed_original": ["from heapq  input() + \"X\" for _ in range(m)] mp.insert(0, \"X\" * (n + 2)) mp.append(\"X\" * (n + 2))  for i in range(1, n + 1): if mp[1][i] ==\"&\" or  c2, s2 = (1,  s1, (i, 1))) heappush(que, (c2, s2, (i, m))) visited[1][i] = True visited[m][i] = True for i in range(1, m + 1): if mp[i][1] == \"&\" or  c2, s2 = (1, 0) if mp[i][n] == \"#\" else (0, 1) heappush(que, (c1, s1, (1, i))) heappush(que, (c2, s2, (n, i))) visited[i][1] = True visited[i][n] = True if sur_flag: print(0) continue direct = ((0, 1), (0, -1), (1, 0), (-1, 0)) reached = False while que and  = True break elif mp[newy][newx] == \"#\": if status == 1: heappush(que, (cost + 1, 0, (newx, newy))) else: heappush(que, (cost, 0, (newx, newy))) elif mp[newy][newx] == \".\": heappush(que,(cost, 1, (newx, newy)))"], "original_ll": -0.47431817650794983, "sampled_ll": -0.7222892642021179, "all_perturbed_sampled_ll": [-1.9449191093444824], "all_perturbed_original_ll": [-1.3704729080200195], "perturbed_sampled_ll": -1.9449191093444824, "perturbed_original_ll": -1.3704729080200195, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n\tint h;\n\tint r;\n} DOLL;\n\nint cmp(const void *a, const void *b)\n{\n\tDOLL x, y;\n\t\n\tx = *(DOLL *)a;\n\ty = *(DOLL *)b;\n\t\n\tif (x.r - y.r){\n\t\treturn (x.r - y.r);\n\t}\n\treturn (x.h - y.h);\n}\n\nint main(void)\n{\n\tDOLL rusd[256];\n\tint dp[256];\n\tint n, m;\n\tint i, j;\n\tint ans;\n\t\n\twhile (1){\n\t\tans = 0;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) break;\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d\", &rusd[i].h, &rusd[i].r);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor (j = 0; j < m; j++){\n\t\t\tscanf(\"%d %d\", &rusd[n + j].h, &rusd[n + j].r);\n\t\t}\n\t\tqsort(rusd, n + m, sizeof(DOLL), cmp);\n\t\t\n\t\tfor (i = 0; i < n + m; i++){\n\t\t\tdp[i] = 1;\n\t\t\tfor (j = 0; j < i; j++){\n\t\t\t\tif (rusd[i].h > rusd[j].h && rusd[i].r > rusd[j].r){\n\t\t\t\t\tif (dp[i] < dp[j] + 1){\n\t\t\t\t\t\tdp[i] = dp[j] + 1;\n\t\t\t\t\t\tif (ans < dp[i]){\n\t\t\t\t\t\t\tans = dp[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int h, r;\n} Doll;\n\nint n, m;\nDoll dolls[205];\nint dp[205];\nint parent[205];\n\nint canContain(int i, int j) {\n    return dolls[i].h < dolls[j].h && dolls[i].r < dolls[j].r;\n}\n\nint compare(const void *a, const void *b) {\n    Doll *da = (Doll *)a;\n    Doll *db = (Doll *)b;\n    if (da->h != db->h) return da->h - db->h;\n    return da->r - db->r;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &dolls[i].h, &dolls[i].r);\n        }\n        \n        scanf(\"%d\", &m);\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d\", &dolls[n + i].h, &dolls[n + i].r);\n        }\n        \n        int total = n + m;\n        \n        qsort(dolls, total, sizeof(Doll), compare);\n        \n        for (int i = 0; i < total; i++) {\n            dp[i] = 1;\n            parent[i] = -1;\n        }\n        \n        int maxLen = 1;\n        for (int i = 1; i < total; i++) {\n            for (int j = 0; j < i; j++) {\n                if (canContain(j, i)) {\n                    if (dp[j] + 1 > dp[i]) {\n                        dp[i] = dp[j] + 1;\n                        parent[i] = j;\n                    }\n                }\n            }\n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n            }\n        }\n        \n        printf(\"%d\\n\", maxLen);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int parent[205];  const void *b) {  if (da->h  } int main() { while (1) { scanf(\"%d\", &n); if (n == 0) break; for (int i = 0; i < n; i++) { scanf(\"%d %d\", &dolls[i].h, &dolls[i].r); } scanf(\"%d\", &m); for (int i = 0; i < m; i++) { scanf(\"%d %d\",  n + m; qsort(dolls, total, sizeof(Doll), compare); for (int i = 0; i < total; i++) { dp[i] =  (int i = 1; i < total; i++)  { if (canContain(j, i)) { if (dp[j] + 1 > dp[i]) { dp[i] = dp[j] + 1;  { maxLen = dp[i]; } } printf(\"%d\\n\", maxLen); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> #include <string.h> typedef struct { int =<extra_id_1>m ;<extra_id_2>++) { if (n<extra_id_3>0)<extra_id_4>=<extra_id_5>0 ;<extra_id_6>) ans =<extra_id_7>) ans = 10 ;<extra_id_8>} d3_dust<extra_id_9>int<extra_id_10>= 0<extra_id_11>0 )<extra_id_12>if ( ans ==<extra_id_13>return (0); } decimal<extra_id_14>- 1<extra_id_15>; } m = n<extra_id_16>return - 1 ; return (x.r - y.r); } return (x.h - y.h); } int main(void) { DOLL rusd[256]; int dp[256]; int n, m; int i, j; int ans; while (1){ ans = 0; memset(dp, 0, sizeof(dp)); scanf(\"%d\", &n); if (n == 0) break;  j < m; j++){ scanf(\"%d %d\", &rusd[n + j].h, &rusd[n + j].r); } qsort(rusd, n + m, sizeof(DOLL), cmp); for (i = 0; i < n + m; i++){ dp[i] = 1;  > rusd[j].h && rusd[i].r > rusd[j].r){  1; if (ans <  ans); } return (0); }"], "original_ll": -0.505160391330719, "sampled_ll": -0.3884802758693695, "all_perturbed_sampled_ll": [-1.5106054544448853], "all_perturbed_original_ll": [-1.9093912839889526], "perturbed_sampled_ll": -1.5106054544448853, "perturbed_original_ll": -1.9093912839889526, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[][] data;\n\tint[] memo;\n\tboolean[] use;\n\tint n, m, N;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdata = new int[201][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tdata[i][0] = sc.nextInt();\n\t\t\t\tdata[i][1] = sc.nextInt();\n\t\t\t}\n\t\t\tm = sc.nextInt();\n\t\t\tfor (int i = n; i < m + n; i++) {\n\t\t\t\tdata[i][0] = sc.nextInt();\n\t\t\t\tdata[i][1] = sc.nextInt();\n\t\t\t}\n\n\t\t\tN = n + m;\n\t\t\tmemo = new int[n + m];\n\t\t\tuse = new boolean[n + m];\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tans = Math.max(ans, dfs(i));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tint dfs(int index) {\n\t\tif (memo[index] > 0) {\n\t\t\treturn memo[index];\n\t\t}\n\t\tint res = 1;\n\t\tuse[index] = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!use[i]) {\n\t\t\t\tif (data[i][0] < data[index][0] && data[i][1] < data[index][1]) {\n\t\t\t\t\tres = Math.max(res, dfs(i) + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tuse[index] = false;\n\t\treturn memo[index] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Doll implements Comparable<Doll> {\n        int h, r;\n        \n        Doll(int h, int r) {\n            this.h = h;\n            this.r = r;\n        }\n        \n        @Override\n        public int compareTo(Doll other) {\n            if (this.h != other.h) {\n                return this.h - other.h;\n            }\n            return this.r - other.r;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            List<Doll> dolls = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                int h = sc.nextInt();\n                int r = sc.nextInt();\n                dolls.add(new Doll(h, r));\n            }\n            \n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                int h = sc.nextInt();\n                int r = sc.nextInt();\n                dolls.add(new Doll(h, r));\n            }\n            \n            Collections.sort(dolls);\n            \n            int[] dp = new int[dolls.size()];\n            Arrays.fill(dp, 1);\n            \n            for (int i = 1; i < dolls.size(); i++) {\n                for (int j = 0; j < i; j++) {\n                    if (dolls.get(j).h < dolls.get(i).h && dolls.get(j).r < dolls.get(i).r) {\n                        dp[i] = Math.max(dp[i], dp[j] + 1);\n                    }\n                }\n            }\n            \n            int max = 0;\n            for (int i = 0; i < dolls.size(); i++) {\n                max = Math.max(max, dp[i]);\n            }\n            \n            System.out.println(max);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Doll implements Comparable<Doll> { int h, r; Doll(int h, int r) { <extra_id_12>> dp<extra_id_13>{ continue ; } if<extra_id_14>== Doll ( h<extra_id_15>r = dolls. compareTo(Doll other) { if (this.h != other.h) { return this.h - other.h; } return this.r - other.r; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) {  dolls = new ArrayList<>(); for (int i = 0; i < n; i++) { int h = sc.nextInt(); int  i++) { int h = sc.nextInt(); int r  i < dolls.size(); i++) { for (int j = 0; j < i; j++) { if (dolls.get(j).h  dp[j] + 1); }  0; i <  sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { MyScanner sc = new MyScanner(); Scanner sc2 = new Scanner(System.in); int mod = 1000000007; int[][] data; int[] memo; boolean[] use; int n, m, N; void run() { for  return; } data = new int[201][2]; for (int i = 0; i  sc.nextInt(); data[i][1] = sc.nextInt(); } N = n  (int i = 0; i < N; i++) { ans  { if (memo[index] > 0) { return memo[index]; } int res = 1; use[index]  i++) { if (!use[i]) { if (data[i][0] < data[index][0] && data[i][1] < data[index][1]) { res = Math.max(res, dfs(i)  = res; } public static  { System.out.println(Arrays.deepToString(o)); } void debug2(int[][] array) { for (int  j = 0; j < array[i].length; j++) { System.out.print(array[i][j]); } System.out.println();  int c = System.in.read();  *= 10; res +=  (Exception e) { return -1; } } double nextDouble() { return Double.parseDouble(next()); } String next() { try { StringBuilder res = new StringBuilder(\"\"); int c = System.in.read(); while (Character.isWhitespace(c)) c = System.in.read(); do { res.append((char) c); } while (!Character.isWhitespace(c = System.in.read())); return res.toString(); } catch (Exception e) { return null; } } } }"], "original_ll": -0.4549693763256073, "sampled_ll": -0.25210440158843994, "all_perturbed_sampled_ll": [-1.9052983522415161], "all_perturbed_original_ll": [-1.5102920532226562], "perturbed_sampled_ll": -1.9052983522415161, "perturbed_original_ll": -1.5102920532226562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from operator import itemgetter\n\ndef f(f1, f2):\n    res = 1\n    c = 0\n    i = 0\n    while c < len(L)-1:\n        if L[i][f1] > L[i+1][f1] and L[i][f2] > L[i+1][f2]:\n            res += 1\n            i += 1\n        else:\n            del L[i+1]\n        c += 1\n    return res\n\nwhile True:\n    n = input()\n    if n == 0: break\n    L = [map(int, raw_input().split()) for i in range(n)]\n    for i in range(input()):\n        L.append(map(int, raw_input().split()))\n    else:\n        h = 0\n        r = 1\n        L.sort(key=itemgetter(0,1), reverse=True)\n        res1 = f(h, r)\n        L.sort(key=itemgetter(1,0), reverse=True)\n        res2 = f(r, h)\n        if res2 < res1:\n            print res1\n        else:\n            print res2", "sampled": "import sys\nfrom bisect import bisect_left\n\ndef longest_chain(dolls):\n    if not dolls:\n        return 0\n    \n    # Sort by height, then by radius\n    dolls.sort()\n    \n    # dp[i] = minimum radius for a chain of length i+1\n    dp = []\n    \n    for h, r in dolls:\n        # Find the longest chain where we can add this doll\n        # We need to find largest index where dp[index] < r\n        pos = bisect_left(dp, r)\n        \n        if pos < len(dp):\n            dp[pos] = r\n        else:\n            dp.append(r)\n    \n    return len(dp)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    dolls1 = []\n    for _ in range(n):\n        h, r = map(int, input().split())\n        dolls1.append((h, r))\n    \n    m = int(input())\n    dolls2 = []\n    for _ in range(m):\n        h, r = map(int, input().split())\n        dolls2.append((h, r))\n    \n    # Combine all dolls\n    all_dolls = dolls1 + dolls2\n    \n    # Find longest chain\n    result = longest_chain(all_dolls)\n    print(result)\n", "perturbed_sampled": ["import sys from  # Sort by  for a chain of length i+1  the longest chain where we can  where dp[index] < r pos = bisect_left(dp, r)  len(dp) while True: n = int(input()) if n == 0: break dolls1 = [] for _  = int(input()) dolls2 = [] for _ in range(m): h, r = map(int, input().split()) dolls2.append((h, r)) # Combine all dolls all_dolls = dolls1 + dolls2 # Find longest chain result = longest_chain(all_dolls) print(result)"], "perturbed_original": ["from operator import itemgetter def f(f1, f2):   L[i+1][f2]: res += 1 i  while True: n = input() if n == 0: break L = [map(int, raw_input().split()) for i in range(n)] for i in range(input()): L.append(map(int, raw_input().split())) else: h = 0 r = 1 L.sort(key=itemgetter(0,1), reverse=True) res1 = f(h, r) L.sort(key=itemgetter(1,0), reverse=True)  else: print res2"], "original_ll": -0.9160102605819702, "sampled_ll": -0.9002872109413147, "all_perturbed_sampled_ll": [-2.812814712524414], "all_perturbed_original_ll": [-2.099921703338623], "perturbed_sampled_ll": -2.812814712524414, "perturbed_original_ll": -2.099921703338623, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int n,c;\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    for(c=0;n!=1;c++){\n      if(n%2==0){\n\tn/=2;\n      }\n      else{\n\tn=n*3+1;\n      }\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int count = 0;\n        while(n != 1) {\n            if(n % 2 == 0) {\n                n = n / 2;\n            } else {\n                n = 3 * n + 1;\n            }\n            count++;\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) { scanf(\"%d\", &n); if(n  { if(n % 2 == 0) { n = n / 2; } else { n = 3 * n  }"], "perturbed_original": ["#include<stdio.h> int main(){ int n,c;  } printf(\"%d\\n\",c); } return 0; }"], "original_ll": -0.8659563660621643, "sampled_ll": -0.4436354339122772, "all_perturbed_sampled_ll": [-1.5954192876815796], "all_perturbed_original_ll": [-3.148172378540039], "perturbed_sampled_ll": -1.5954192876815796, "perturbed_original_ll": -3.148172378540039, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n\n\tfinal Scanner stdin = new Scanner(System.in);\n\n\twhile ( true ) {\n\t    int n = stdin.nextInt();\n\t    if ( n == 0 ) {\n\t\tbreak;\n\t    }\n\n\t    int count = 0;\n\t    while ( n != 1 ) {\n\t\tif ( n % 2 == 0 ) {\n\t\t    n /= 2;\n\t\t} else {\n\t\t    n = n * 3 + 1;\n\t\t}\n\t\tcount++;\n\t    }\n\t    System.out.println( count );\n\t}\t\n    }    \n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            while (n != 1) {\n                if (n % 2 == 0) {\n                    n = n / 2;\n                } else {\n                    n = n * 3 + 1;\n                }\n                count++;\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int count = 0; while (n !=  = n / 2; } else { n = n *  }"], "perturbed_original": ["import java.util.*; import java.io.*; class Main { public static void main(String[] args) { final Scanner stdin  = stdin.nextInt(); if ( n == 0 ) { break; } int count  ( n  else { n = n * 3 + 1; } count++; } System.out.println( count ); } } }"], "original_ll": -0.72200608253479, "sampled_ll": -0.3652181625366211, "all_perturbed_sampled_ll": [-2.2139132022857666], "all_perturbed_original_ll": [-2.2176198959350586], "perturbed_sampled_ll": -2.2139132022857666, "perturbed_original_ll": -2.2176198959350586, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n\tn = int(input())\n\tif n == 0: break\n\tk = 0\n\twhile n > 1:\n\t\tif n & 1:\n\t\t\tn = n + ((n+1)>>1)\n\t\t\tk += 2\n\t\telse:\n\t\t\tn >>= 1\n\t\t\tk += 1\n\tprint(k)\n", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = 0\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        count += 1\n    \n    print(count)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break count =  0: n  + 1 count += 1 print(count)"], "perturbed_original": ["while True: n = int(input()) if n == 0: break k = 0 while n > 1: if n & 1: n  1 k += 1 print(k)"], "original_ll": -1.0102958679199219, "sampled_ll": -0.4923757314682007, "all_perturbed_sampled_ll": [-2.387267827987671], "all_perturbed_original_ll": [-1.789486050605774], "perturbed_sampled_ll": -2.387267827987671, "perturbed_original_ll": -1.789486050605774, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\nint n,a[1001],b[1001],c[1001],i,k=1001;\ndouble x,y,z,d[1001],w=10000;\nwhile(1){\nscanf(\"%d\\n\",&n);\nif(n==0){\nbreak;\n}\nfor(i=0;i<n;i++){\nscanf(\"%d %d %d\\n\",&a[i],&b[i],&c[i]);\nx=b[i],y=c[i];\nx=x/100;\nz=y/(x*x);\nif(z>22){\nz=z-22;\n}\nelse{\nz=22-z;\n}\nd[i]=z;\nif((z<w) || (z==w && k>a[i])){\nw=z;\nk=a[i];\n}\n}\nfor(i=0;i<n;i++){\nif(w==d[i]){\nprintf(\"%d\\n\",a[i]);\nbreak;\n}\n}\nw=10000,k=1001;\n}\nreturn 0;\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int best_p = -1;\n        double min_diff = -1;\n        \n        for(int i = 0; i < n; i++) {\n            int p, h, w;\n            scanf(\"%d %d %d\", &p, &h, &w);\n            \n            double height_m = h / 100.0;\n            double bmi = w / (height_m * height_m);\n            double diff = fabs(bmi - 22.0);\n            \n            if(min_diff < 0 || diff < min_diff || (diff == min_diff && p < best_p)) {\n                min_diff = diff;\n                best_p = p;\n            }\n        }\n        \n        printf(\"%d\\n\", best_p);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main() { int n; while(scanf(\"%d\", &n) == 1 && n != 0) { int best_p = -1; double min_diff = -1; for(int i = 0; i < n; i++) { int p, h, w; scanf(\"%d %d %d\", &p,  = w   best_p = p; } } printf(\"%d\\n\", best_p); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int n,a[1001],b[1001],c[1001],i,k=1001; double x,y,z,d[1001],w=10000; while(1){ scanf(\"%d\\n\",&n); if(n==0){ break; } for(i=0;i<n;i++){ scanf(\"%d %d %d\\n\",&a[i],&b[i],&c[i]); x=b[i],y=c[i]; x=x/100; z=y/(x*x); if(z>22){ z=z-22; } else{ z=22-z; }  0; }"], "original_ll": -1.0706024169921875, "sampled_ll": -0.6591346263885498, "all_perturbed_sampled_ll": [-1.3457199335098267], "all_perturbed_original_ll": [-1.4859248399734497], "perturbed_sampled_ll": -1.3457199335098267, "perturbed_original_ll": -1.4859248399734497, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tR[] rs;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint id=sc.nextInt();\n\t\t\t\tint h=sc.nextInt();\n\t\t\t\tint w=sc.nextInt();\n\t\t\t\trs[i]=new R(id, h, w);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tArrays.sort(rs);\n\t\tprintln(\"\"+rs[0].id);\n\t}\n\n\tclass R implements Comparable<R>{\n\t\tint id;\n\t\tdouble error;\n\n\t\tR(int id, int h, int w){\n\t\t\tthis.id=id;\n\t\t\terror=Math.abs(22-10000.*w/h/h);\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(R r){\n\t\t\tif(error+EPS<r.error){\n\t\t\t\treturn -1;\n\t\t\t}else if(error>r.error+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn id-r.id;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int bestP = Integer.MAX_VALUE;\n            double minDiff = Double.MAX_VALUE;\n            \n            for (int i = 0; i < n; i++) {\n                int p = sc.nextInt();\n                int h = sc.nextInt();\n                int w = sc.nextInt();\n                \n                double heightInMeters = h / 100.0;\n                double bmi = w / (heightInMeters * heightInMeters);\n                double diff = Math.abs(bmi - 22.0);\n                \n                if (diff < minDiff || (diff == minDiff && p < bestP)) {\n                    minDiff = diff;\n                    bestP = p;\n                }\n            }\n            \n            System.out.println(bestP);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" break; int bestP = Integer.MAX_VALUE; double minDiff = Double.MAX_VALUE; for (int i = 0; i < n; i++) { int p = sc.nextInt(); int  h / 100.0; double bmi = w / (heightInMeters * heightInMeters); double diff = Math.abs(bmi - 22.0); if (diff < minDiff || (diff == minDiff  p; } } System.out.println(bestP); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.lang.*; import java.math.*; import java.io.*; import static java.lang.Math.*; import static java.util.Arrays.*; public  } rs=new R[n]; for(int i=0; i<n; i++){ int id=sc.nextInt(); int h=sc.nextInt(); int w=sc.nextInt(); rs[i]=new R(id, h, w); } solve(); } } void solve(){ Arrays.sort(rs); println(\"\"+rs[0].id); } class R implements Comparable<R>{ int id;  } void debug(Object... os){ System.err.println(Arrays.deepToString(os)); }  public static void main(String[] args){ // System.setOut(new PrintStream(new BufferedOutputStream(System.out))); new Main().run(); } }"], "original_ll": -0.8436276912689209, "sampled_ll": -0.5821609497070312, "all_perturbed_sampled_ll": [-1.6619588136672974], "all_perturbed_original_ll": [-1.5087759494781494], "perturbed_sampled_ll": -1.6619588136672974, "perturbed_original_ll": -1.5087759494781494, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = input()\n    if n == 0: break\n    pb = None\n    ans = 0\n    for i in range(n):\n        i, h, w = map(int, raw_input().split())\n        bmi = w/((float(h)/100)**2)\n        a = abs(22-bmi)\n        if pb is None:\n            pb = a\n            ans = i\n        elif pb is not None and a < pb:\n            pb = a\n            ans = i\n    else:\n        print ans", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    best_person = None\n    best_diff = float('inf')\n    \n    for _ in range(n):\n        data = list(map(int, input().split()))\n        p, h, w = data[0], data[1], data[2]\n        \n        # Convert height from cm to m\n        h_m = h / 100.0\n        \n        # Calculate BMI\n        bmi = w / (h_m * h_m)\n        \n        # Calculate difference from ideal BMI (22)\n        diff = abs(bmi - 22)\n        \n        # Update best if this is closer, or same distance but smaller reception number\n        if diff < best_diff or (diff == best_diff and p < best_person):\n            best_diff = diff\n            best_person = p\n    \n    print(best_person)\n", "perturbed_sampled": ["while True: n = int(input()) if n  _ in range(n): data = list(map(int,  height  Calculate BMI bmi = w / (h_m * h_m) # Calculate difference from ideal BMI (22) diff = abs(bmi - 22) # Update best if this is closer, or same distance but smaller reception number if diff <  = diff best_person = p print(best_person)"], "perturbed_original": ["while True: n = input() if n == 0: break pb = None ans = 0 for i in range(n): i,  = i elif pb is not None  else: print ans"], "original_ll": -1.3892873525619507, "sampled_ll": -0.9226909279823303, "all_perturbed_sampled_ll": [-3.4481427669525146], "all_perturbed_original_ll": [-3.0794248580932617], "perturbed_sampled_ll": -3.4481427669525146, "perturbed_original_ll": -3.0794248580932617, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int n,x,y,h,w,s,s1,s2,a,i;\n  int m[]={600,800,1000,1200,1400,1600,0};\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    a=0;\n    for(i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x,&y,&h,&w);\n      if     (x+y+h>160)s1=6;\n      else if(x+y+h>140)s1=5;\n      else if(x+y+h>120)s1=4;\n      else if(x+y+h>100)s1=3;\n      else if(x+y+h> 80)s1=2;\n      else if(x+y+h> 60)s1=1;\n      else              s1=0;\n      if     (w>25)s2=6;\n      else if(w>20)s2=5;\n      else if(w>15)s2=4;\n      else if(w>10)s2=3;\n      else if(w>5 )s2=2;\n      else if(w>2 )s2=1;\n      else         s2=0;\n      if(s1>s2)s=s1;\n      else     s=s2;\n      a+=m[s];\n    }\n    printf(\"%d\\n\",a);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        int total = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int x, y, h, w;\n            scanf(\"%d %d %d %d\", &x, &y, &h, &w);\n            \n            int size = x + y + h;\n            int price = 0;\n            \n            // Determine the category based on size and weight\n            if (size <= 60 && w <= 2) {\n                price = 600;\n            } else if (size <= 80 && w <= 5) {\n                price = 800;\n            } else if (size <= 100 && w <= 10) {\n                price = 1000;\n            } else if (size <= 120 && w <= 15) {\n                price = 1200;\n            } else if (size <= 140 && w <= 20) {\n                price = 1400;\n            } else if (size <= 160 && w <= 25) {\n                price = 1600;\n            }\n            // If it exceeds F size, price remains 0 and won't be added\n            \n            total += price;\n        }\n        \n        printf(\"%d\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> ; //<extra_id_25>if if (n == 0) break; int  n; i++)  &x,  h; int price = 0; // Determine the category based on size and weight  = 600; } else if (size <= 80 && w <= 5) { price = 800; } else if (size <= 100 && w <= 10) { price = 1000; } else if (size  } else if (size <= 140 &&  (size <= 160 && w <= 25) { price = 1600; } // If it exceeds F size, price remains 0 and  return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int n,x,y,h,w,s,s1,s2,a,i;  else if(x+y+h> 80)s1=2; else if(x+y+h> 60)s1=1; else s1=0; if (w>25)s2=6; else if(w>20)s2=5; else if(w>15)s2=4; else if(w>10)s2=3; else if(w>5 )s2=2; else if(w>2 )s2=1; else s2=0; if(s1>s2)s=s1; else s=s2; a+=m[s]; } printf(\"%d\\n\",a); } return 0; }"], "original_ll": -0.6646760702133179, "sampled_ll": -0.6342175006866455, "all_perturbed_sampled_ll": [-2.343247175216675], "all_perturbed_original_ll": [-1.2887742519378662], "perturbed_sampled_ll": -2.343247175216675, "perturbed_original_ll": -1.2887742519378662, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Map.Entry;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\n/**\n * Delivery Fee\n */\npublic class Main {\n\n\tstatic P0160 main = new P0160();\n\tstatic TreeMap<Parcel, Integer> fee = new TreeMap<Parcel, Integer>() {\n\t\t{\n\t\t\tput(main.new Parcel(60, 2), 600);\n\t\t\tput(main.new Parcel(80, 5), 800);\n\t\t\tput(main.new Parcel(100, 10), 1000);\n\t\t\tput(main.new Parcel(120, 15), 1200);\n\t\t\tput(main.new Parcel(140, 20), 1400);\n\t\t\tput(main.new Parcel(160, 25), 1600);\n\t\t}\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n, sum = 0;\n\t\t\tn = Integer.parseInt(line);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tParcel p = main.new Parcel(br.readLine());\n\t\t\t\tEntry<Parcel, Integer> e;\n\t\t\t\tif ((e = fee.ceilingEntry(p)) != null) {\n\t\t\t\t\tsum += e.getValue();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tclass Parcel implements Comparable<Parcel> {\n\t\tint size, weight;\n\n\t\tParcel(int size, int weight) {\n\t\t\tthis.size = size;\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tParcel(int x, int y, int h, int w) {\n\t\t\tthis(x + y + h, w);\n\t\t}\n\n\t\tParcel(String info) {\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tint x, y, h, w;\n\t\t\tx = Integer.parseInt(st.nextToken());\n\t\t\ty = Integer.parseInt(st.nextToken());\n\t\t\th = Integer.parseInt(st.nextToken());\n\t\t\tw = Integer.parseInt(st.nextToken());\n\t\t\tsize = x + y + h;\n\t\t\tweight = w;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Parcel o) {\n\t\t\tint r1 = this.weight - o.weight;\n\t\t\tint r2 = this.size - o.size;\n\t\t\tif (r1 > 0 || r2 > 0) {\n\t\t\t\treturn 1;\n\t\t\t} else if (r1 == 0 && r2 == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int totalCost = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                int h = sc.nextInt();\n                int w = sc.nextInt();\n                \n                int size = x + y + h;\n                int cost = getPrice(size, w);\n                totalCost += cost;\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        sc.close();\n    }\n    \n    static int getPrice(int size, int weight) {\n        int[] sizeLimits = {60, 80, 100, 120, 140, 160};\n        int[] weightLimits = {2, 5, 10, 15, 20, 25};\n        int[] prices = {600, 800, 1000, 1200, 1400, 1600};\n        \n        for (int i = 0; i < 6; i++) {\n            if (size <= sizeLimits[i] && weight <= weightLimits[i]) {\n                return prices[i];\n            }\n        }\n        \n        return 0;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public   0;  int x = sc.nextInt(); int y = sc.nextInt(); int h = sc.nextInt(); int  h; int cost = getPrice(size, w); totalCost += cost; } System.out.println(totalCost); } sc.close(); } static int getPrice(int size, int weight) { int[] sizeLimits = {60, 80, 100, 120, 140, 160}; int[]  =  0; i < 6; i++) { if (size <= sizeLimits[i] && weight <= weightLimits[i]) { return prices[i]; } } return 0; } }"], "perturbed_original": ["import java.io.BufferedReader;  /** * Delivery Fee */  static TreeMap<Parcel, Integer> fee = new TreeMap<Parcel, Integer>() { { put(main.new Parcel(60, 2), 600); put(main.new Parcel(80, 5), 800); put(main.new Parcel(100, 10), 1000); put(main.new Parcel(120, 15), 1200); put(main.new Parcel(140, 20), 1400); put(main.new Parcel(160,  p = main.new Parcel(br.readLine()); Entry<Parcel, Integer> e; if ((e = fee.ceilingEntry(p))  }  int weight) { this.size = size; this.weight = weight; } Parcel(int x, int y, int h, int w) { this(x + y + h, w); } Parcel(String info) { StringTokenizer st = new StringTokenizer(info); int  h = Integer.parseInt(st.nextToken()); w = Integer.parseInt(st.nextToken()); size = x + y +  { int r1 = this.weight - o.weight; int r2 = this.size - o.size; if (r1 > 0 || r2 > 0) { return 1; } else if (r1  else { return -1; } } } }"], "original_ll": -0.5884672403335571, "sampled_ll": -0.5071066617965698, "all_perturbed_sampled_ll": [-1.7023091316223145], "all_perturbed_original_ll": [-1.5192049741744995], "perturbed_sampled_ll": -1.7023091316223145, "perturbed_original_ll": -1.5192049741744995, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "size = [60,80,100,120,140,160]        \nweight = [2,5,10,16,20,25]\nfee= [600,800,1000,1200,1400,1600]\nwhile True:\n    n = int(input())\n    if n==0:\n        break\n    total = 0\n    for _ in range(n):\n        [x,y,h,wt] = list(map(int, input().split()))\n        sz = x+y+h\n        if sz > size[-1] or wt > weight[-1]:\n            #print(\"NotAccept\")\n            continue\n        isz = len(list(filter(lambda x: x<sz,   size)))\n        iwt = len(list(filter(lambda x: x<wt, weight)))\n        f   = fee[max(isz,iwt)]\n        #print(\"%d %d %d %d %d\" % (x,y,h,wt,f))\n        total += f\n\n    print(total)", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    total = 0\n    for _ in range(n):\n        x, y, h, w = map(int, input().split())\n        size = x + y + h\n        \n        # Determine the category based on size and weight\n        if size <= 60 and w <= 2:\n            total += 600\n        elif size <= 80 and w <= 5:\n            total += 800\n        elif size <= 100 and w <= 10:\n            total += 1000\n        elif size <= 120 and w <= 15:\n            total += 1200\n        elif size <= 140 and w <= 20:\n            total += 1400\n        elif size <= 160 and w <= 25:\n            total += 1600\n        # If exceeds F size, don't add to total\n    \n    print(total)\n", "perturbed_sampled": ["while True:  0 for _ in range(n): x, y, h, w = map(int, input().split()) size = x + y + h # Determine the category based on size and weight if size <= 60 and w <= 2: total += 600 elif size <= 80 and  <= 120 and w  w <= 20: total += 1400 elif size <= 160 and w <= 25:  to total print(total)"], "perturbed_original": ["size = [60,80,100,120,140,160] weight = [2,5,10,16,20,25] fee= [600,800,1000,1200,1400,1600] while True: n = int(input()) if n==0: break total = 0  = len(list(filter(lambda x: x<wt, weight))) f = fee[max(isz,iwt)] #print(\"%d %d %d %d %d\" % (x,y,h,wt,f)) total += f print(total)"], "original_ll": -1.2436612844467163, "sampled_ll": -0.7777429819107056, "all_perturbed_sampled_ll": [-2.304553747177124], "all_perturbed_original_ll": [-1.6054491996765137], "perturbed_sampled_ll": -2.304553747177124, "perturbed_original_ll": -1.6054491996765137, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct\n{\n\tint c;\n\tint m[4];\n\tint s[4];\n} TEAM;\n\nint comparison(const void* a, const void* b);\n\nint main(void)\n{\n\tint n;\n\tTEAM* team;\n\t\n\twhile (scanf(\"%d\", &n) * n != 0){\n\t\tint i;\n\t\t\n\t\tteam = (TEAM*)calloc(n, sizeof(TEAM));\n\t\tfor (i = 0; i < n; i++){\n\t\t\tint j;\n\t\t\t\n\t\t\tscanf(\"%d\", &team[i].c);\n\t\t\tfor (j = 0; j < 4; j++){\n\t\t\t\tscanf(\"%d %d\", &team[i].m[j], &team[i].s[j]);\n\t\t\t}\n\t\t}\n\t\tqsort(team, n, sizeof(TEAM), comparison);\n\t\tprintf(\"%d\\n\", team[0].c);\n\t\tprintf(\"%d\\n\", team[1].c);\n\t\tprintf(\"%d\\n\", team[n - 2].c);\n\t\t\n\t\tfree(team);\n\t}\n\t\n\treturn 0;\n}\n\nint comparison(const void* a, const void* b)\n{\n\tint sum_a, sum_b;\n\tint i;\n\t\n\tsum_a = sum_b = 0;\n\tfor (i = 0; i < 4; i++){\n\t\tsum_a += ((TEAM*)a)->m[i] * 60 + ((TEAM*)a)->s[i];\n\t\tsum_b += ((TEAM*)b)->m[i] * 60 + ((TEAM*)b)->s[i];\n\t}\n\tif (sum_a > sum_b){\n\t\treturn 1;\n\t}\n\telse if (sum_a < sum_b){\n\t\treturn -1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int total_time;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    return ta->total_time - tb->total_time;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Team *teams = (Team *)malloc(n * sizeof(Team));\n        \n        for (int i = 0; i < n; i++) {\n            int id, m1, s1, m2, s2, m3, s3, m4, s4;\n            scanf(\"%d %d %d %d %d %d %d %d %d\", &id, &m1, &s1, &m2, &s2, &m3, &s3, &m4, &s4);\n            \n            teams[i].id = id;\n            teams[i].total_time = (m1 * 60 + s1) + (m2 * 60 + s2) + (m3 * 60 + s3) + (m4 * 60 + s4);\n        }\n        \n        qsort(teams, n, sizeof(Team), compare);\n        \n        printf(\"%d\\n\", teams[0].id);\n        printf(\"%d\\n\", teams[1].id);\n        printf(\"%d\\n\", teams[n-2].id);\n        \n        free(teams);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int id; int total_time; } Team; int compare(const void *a, const void *b) { Team *ta = (Team *)a; Team *tb = (Team *)b; return ta->total_time   = (Team *)malloc(n *  m4, s4; scanf(\"%d %d %d %d %d %d %d %d %d\", &id, &m1,  * 60 + s2) + (m3 * 60 + s3) +  printf(\"%d\\n\", teams[0].id); printf(\"%d\\n\", teams[1].id); printf(\"%d\\n\", teams[n-2].id); free(teams); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> typedef struct { int c; int m[4]; int s[4]; } TEAM; int comparison(const void* a, const void* b); int main(void) { int n; TEAM* team; while (scanf(\"%d\", &n) * n != 0){ int i;  } } qsort(team, n, sizeof(TEAM),  void* b) { int sum_a, sum_b;  0; i < 4; i++){ sum_a += ((TEAM*)a)->m[i] * 60 + ((TEAM*)a)->s[i]; sum_b += ((TEAM*)b)->m[i] * 60 + ((TEAM*)b)->s[i]; } if (sum_a > sum_b){ return 1; } else if  } }"], "original_ll": -0.5576724410057068, "sampled_ll": -0.3712632656097412, "all_perturbed_sampled_ll": [-1.7574307918548584], "all_perturbed_original_ll": [-1.5405210256576538], "perturbed_sampled_ll": -1.7574307918548584, "perturbed_original_ll": -1.5405210256576538, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main\n{\n    public static void main(String args[])\n    {\n\tScanner scan=new Scanner(System.in);\n\twhile(true)\n\t    {\n\t\tint n=scan.nextInt();\n\t\tif(n==0)break;\n\t\tint num[]=new int[n];\n\t\tint sum[]=new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\tnum[i]=scan.nextInt();\n\t\t\tfor(int j=0;j<8;j++)\n\t\t\t    {\n\t\t\t\tif(j%2==0)sum[i]+=60*(scan.nextInt());\n\t\t\t\telse sum[i]+=scan.nextInt();\n\t\t\t    }\n\t\t    }\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\tint min=sum[i],x=i;\n\t\t\tfor(int j=i;j<n;j++)\n\t\t\t    {\n\t\t\t\tif(min>sum[j])\n\t\t\t\t    {\n\t\t\t\t\tmin=sum[j];\n\t\t\t\t\tx=j;\n\t\t\t\t\t\n\t\t\t\t    }\n\t\t\t    }\n\t\t\tint tmp=num[i];\n\t\t\tnum[i]=num[x];\n\t\t\tnum[x]=tmp;\n\t\t\tint tmp2=sum[i];\n\t\t\tsum[i]=sum[x];\n\t\t\tsum[x]=tmp2;\n\t\t    }\n\t\t\n\t\tSystem.out.println(num[0]);\n\t\tSystem.out.println(num[1]);\n\t\tSystem.out.println(num[n-2]);\n\t    }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Team implements Comparable<Team> {\n        int id;\n        int totalSeconds;\n        \n        Team(int id, int totalSeconds) {\n            this.id = id;\n            this.totalSeconds = totalSeconds;\n        }\n        \n        @Override\n        public int compareTo(Team other) {\n            return this.totalSeconds - other.totalSeconds;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            Team[] teams = new Team[n];\n            \n            for (int i = 0; i < n; i++) {\n                int id = sc.nextInt();\n                int totalSeconds = 0;\n                \n                for (int j = 0; j < 4; j++) {\n                    int m = sc.nextInt();\n                    int s = sc.nextInt();\n                    totalSeconds += m * 60 + s;\n                }\n                \n                teams[i] = new Team(id, totalSeconds);\n            }\n            \n            Arrays.sort(teams);\n            \n            System.out.println(teams[0].id);\n            System.out.println(teams[1].id);\n            System.out.println(teams[n - 2].id);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Team implements Comparable<Team> { int id; int totalSeconds; Team(int id, int totalSeconds) { this.id = id;  return this.totalSeconds - other.totalSeconds; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; Team[] teams = new Team[n]; for   = sc.nextInt(); int s  System.out.println(teams[n - 2].id); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main  while(true) { int n=scan.nextInt(); if(n==0)break; int num[]=new int[n]; int sum[]=new int[n]; for(int i=0;i<n;i++) { num[i]=scan.nextInt();  {  } int tmp=num[i]; num[i]=num[x]; num[x]=tmp; int tmp2=sum[i]; sum[i]=sum[x]; sum[x]=tmp2; } System.out.println(num[0]); System.out.println(num[1]); System.out.println(num[n-2]); } } }"], "original_ll": -0.7492728233337402, "sampled_ll": -0.4107069671154022, "all_perturbed_sampled_ll": [-1.4534095525741577], "all_perturbed_original_ll": [-1.3002386093139648], "perturbed_sampled_ll": -1.4534095525741577, "perturbed_original_ll": -1.3002386093139648, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n=int(input())\n    if n==0:break\n    a={}\n    for _ in range(n):\n        b=list(map(int,input().split()))\n        a[b[0]]=sum(b[1:8:2])*60+sum(b[2:9:2])\n    a=sorted(a.items(),key=lambda x:x[1])\n    for i in [0,1,-2]:print(a[i][0])", "sampled": "import sys\n\ndef solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        teams = []\n        for _ in range(n):\n            parts = list(map(int, input().split()))\n            team_id = parts[0]\n            \n            # Calculate total time in seconds\n            total_seconds = 0\n            for i in range(1, 9, 2):\n                minutes = parts[i]\n                seconds = parts[i + 1]\n                total_seconds += minutes * 60 + seconds\n            \n            teams.append((total_seconds, team_id))\n        \n        # Sort by total time\n        teams.sort()\n        \n        # Winner: smallest time (index 0)\n        winner = teams[0][1]\n        # Runner-up: second smallest time (index 1)\n        runner_up = teams[1][1]\n        # Booby prize: second to last (index n-2)\n        booby = teams[n - 2][1]\n        \n        print(winner)\n        print(runner_up)\n        print(booby)\n\nsolve()\n", "perturbed_sampled": ["import sys def  = list(map(int, input().split())) team_id = parts[0] # Calculate total time in seconds total_seconds = 0 for i in range(1, 9, 2): minutes = parts[i] seconds = parts[i + 1] total_seconds += minutes * 60 + seconds  Booby prize: second to last (index n-2) booby = teams[n - 2][1] print(winner) print(runner_up) print(booby) solve()"], "perturbed_original": ["while 1: n=int(input()) if n==0:break a={} for _ in range(n): b=list(map(int,input().split())) a[b[0]]=sum(b[1:8:2])*60+sum(b[2:9:2]) a=sorted(a.items(),key=lambda x:x[1]) for i in [0,1,-2]:print(a[i][0])"], "original_ll": -1.0230110883712769, "sampled_ll": -0.9270316362380981, "all_perturbed_sampled_ll": [-2.489321231842041], "all_perturbed_original_ll": [-1.330299973487854], "perturbed_sampled_ll": -2.489321231842041, "perturbed_original_ll": -1.330299973487854, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[110][110];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j,a,b;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<110;i++){\n      for(j=0;j<110;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d){a=4;b=2;}\n      else {a=2;b=4;}\n\tfor(i=y;i<y+a;i++){\n\t  for(j=x;j<x+b;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n\n    }\n    c=boad[xs][ys];\n \n  \n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    /*for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\nprintf(\"%2d\",boad[i][j]);\n      printf(\"\\n\");\n      }*/\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  if(x<=0||x>w||y<=0||y>h||boad[x][y]!=c)return 0;\n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i)+abs(j)==1 && boad[x+i][y+j]!=-1)\n\tif(dfs(x+i,y+j))return 1;\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 1000000\n\nint hamming[100000];\nint hamming_count = 0;\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nvoid generate_hamming() {\n    hamming[hamming_count++] = 1;\n    \n    int i2 = 0, i3 = 0, i5 = 0;\n    int next_2 = 2, next_3 = 3, next_5 = 5;\n    \n    while (1) {\n        int next = next_2;\n        if (next_3 < next) next = next_3;\n        if (next_5 < next) next = next_5;\n        \n        if (next > MAX) break;\n        \n        hamming[hamming_count++] = next;\n        \n        if (next == next_2) {\n            i2++;\n            next_2 = hamming[i2] * 2;\n        }\n        if (next == next_3) {\n            i3++;\n            next_3 = hamming[i3] * 3;\n        }\n        if (next == next_5) {\n            i5++;\n            next_5 = hamming[i5] * 5;\n        }\n    }\n}\n\nint binary_search_lower(int val) {\n    int left = 0, right = hamming_count - 1;\n    int result = hamming_count;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (hamming[mid] >= val) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return result;\n}\n\nint binary_search_upper(int val) {\n    int left = 0, right = hamming_count - 1;\n    int result = -1;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (hamming[mid] <= val) {\n            result = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    generate_hamming();\n    \n    int m, n;\n    while (1) {\n        scanf(\"%d\", &m);\n        if (m == 0) break;\n        scanf(\"%d\", &n);\n        \n        int lower = binary_search_lower(m);\n        int upper = binary_search_upper(n);\n        \n        if (lower <= upper) {\n            printf(\"%d\\n\", upper - lower + 1);\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #define MAX 1000000 int hamming[100000]; int hamming_count = 0; int compare(const void *a,  generate_hamming() { hamming[hamming_count++] = 1; int i2 = 0, i3 = 0, i5 = 0; int next_2 =  int  if (next_5 < next) next = next_5; if (next  {  next_3) { i3++; next_3 = hamming[i3] * 3; } if (next == next_5) {  hamming_count - 1; int result = hamming_count; while (left <= right) { int mid = (left + right) / 2; if  - 1; } else {  int binary_search_upper(int val) {  mid = (left + right) / 2; if (hamming[mid] <= val) { result = mid; left = mid + 1; } else { right = mid - 1; } } return result; } int main() { generate_hamming(); int m, n;  binary_search_upper(n); if (lower <= upper) { printf(\"%d\\n\", upper - lower + 1); } else { printf(\"0\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h> int dfs(int,int); int boad[110][110]; int w,h,xs,ys,xg,yg,n,c,d; int main(void){ int x,y,i,j,a,b; while(1){ scanf(\"%d %d\",&w,&h);  %d\",&c,&d,&x,&y); if(d){a=4;b=2;}  else printf(\"NG\\n\"); /*for(i=0;i<15;i++){ for(j=0;j<15;j++) printf(\"%2d\",boad[i][j]); printf(\"\\n\"); }*/ } return 0; } int  1; boad[x][y]=-1; for(i=-1;i<2;i++){ for(j=-1;j<2;j++){ if(boad[x+i][y+j]==c && abs(i)+abs(j)==1 && boad[x+i][y+j]!=-1) if(dfs(x+i,y+j))return 1; } } return 0; }"], "original_ll": -0.8931204676628113, "sampled_ll": -0.32415035367012024, "all_perturbed_sampled_ll": [-1.4711030721664429], "all_perturbed_original_ll": [-1.5874518156051636], "perturbed_sampled_ll": -1.4711030721664429, "perturbed_original_ll": -1.5874518156051636, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint m, n;\n\t\tint a;\n\t\t\n\t\tint count;\n\t\t\n\t\twhile(true){\n\t\t\tm = scan.nextInt();\n\t\t\tn = scan.nextInt();\n\t\t\tif(m == 0)break;\n\t\t\t\n\t\t\tcount = 0;\n\t\t\tfor(int i = m;i <= n; i++){\n\t\t\t\ta = i;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(a == 1){\n\t\t\t\t\t\tcount++;;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(a % 2 != 0 && a % 3 != 0 && a % 5 != 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(a % 2 == 0)a /= 2;\n\t\t\t\t\telse if(a % 3 == 0)a /= 3;\n\t\t\t\t\telse if(a % 5 == 0)a /= 5;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Precompute all Hamming numbers up to 1000000\n        TreeSet<Long> hammingSet = new TreeSet<>();\n        long limit = 1000000;\n        \n        for (long i = 1; i <= limit; i *= 2) {\n            for (long j = i; j <= limit; j *= 3) {\n                for (long k = j; k <= limit; k *= 5) {\n                    hammingSet.add(k);\n                }\n            }\n        }\n        \n        List<Long> hamming = new ArrayList<>(hammingSet);\n        \n        while (true) {\n            int m = sc.nextInt();\n            if (m == 0) break;\n            int n = sc.nextInt();\n            \n            int count = 0;\n            for (long h : hamming) {\n                if (h >= m && h <= n) {\n                    count++;\n                } else if (h > n) {\n                    break;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); // Precompute all Hamming numbers up to 1000000  (long i = 1; i <= limit; i *=  j *= 3) { for (long k = j; k <= limit; k *= 5) { hammingSet.add(k); } } } List<Long> hamming = new ArrayList<>(hammingSet); while (true) {  > n) { break; } } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner;  = new Scanner(System.in);  = i; while(true){ if(a == 1){ count++;; break; } if(a % 2 != 0 && a % 3 != 0 && a % 5 != 0){ break; } if(a % 2 == 0)a /= 2; else if(a % 3  /= 5; } } System.out.println(count); } } }"], "original_ll": -0.6280300617218018, "sampled_ll": -0.5164499282836914, "all_perturbed_sampled_ll": [-1.9059940576553345], "all_perturbed_original_ll": [-1.8852505683898926], "perturbed_sampled_ll": -1.9059940576553345, "perturbed_original_ll": -1.8852505683898926, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\nwhile True:\n    try:\n        m, n = map(int, raw_input().split())\n\n        f2 = int(math.log(n, 2)) + 1\n        f3 = int(math.log(n, 3)) + 1\n        f5 = int(math.log(n, 5)) + 1\n\n        c = 0\n        for i in range(f2):\n            for j in range(f3):\n                for k in range(f5):\n                    if m <= (2 ** i) * (3 ** j) * (5 ** k) <= n:\n                        c += 1\n        print c\n\n    except ValueError:\n        break", "sampled": "import heapq\n\ndef generate_hamming_numbers(limit):\n    hamming = set([1])\n    heap = [1]\n    \n    while heap:\n        h = heapq.heappop(heap)\n        if h > limit:\n            break\n        \n        for factor in [2, 3, 5]:\n            new_num = h * factor\n            if new_num <= limit and new_num not in hamming:\n                hamming.add(new_num)\n                heapq.heappush(heap, new_num)\n    \n    return sorted(hamming)\n\n# Pre-generate all Hamming numbers up to 1000000\nhamming_numbers = generate_hamming_numbers(1000000)\n\nwhile True:\n    line = input().strip()\n    if line == \"0\":\n        break\n    \n    m, n = map(int, line.split())\n    \n    # Binary search for the range\n    count = 0\n    for h in hamming_numbers:\n        if h < m:\n            continue\n        if h > n:\n            break\n        count += 1\n    \n    print(count)\n", "perturbed_sampled": ["import heapq def generate_hamming_numbers(limit): hamming =  5]: new_num = h * factor if new_num <= limit and new_num not in hamming: hamming.add(new_num) heapq.heappush(heap, new_num) return sorted(hamming) # Pre-generate all Hamming numbers up to 1000000 hamming_numbers =  break m, n = map(int, line.split()) # Binary search for the  < m: continue if h > n: break count += 1 print(count)"], "perturbed_original": ["import math while True: try: m, n = map(int, raw_input().split()) f2 = int(math.log(n, 2)) + 1 f3 = int(math.log(n, 3)) + 1 f5 = int(math.log(n, 5)) + 1 c <extra_id_5>c for k in range(f5): <extra_id_6>)<extra_id_7>if _ [<extra_id_8>)<extra_id_9>(<extra_id_10>(<extra_id_11>)<extra_id_12>_<extra_id_13>c =<extra_id_14>return k<extra_id_15>c<extra_id_16>[ n<extra_id_15>print<extra_id_16>) ) print c except ValueError: break"], "original_ll": -0.7213451862335205, "sampled_ll": -0.7400742173194885, "all_perturbed_sampled_ll": [-2.331003427505493], "all_perturbed_original_ll": [-1.8768893480300903], "perturbed_sampled_ll": -2.331003427505493, "perturbed_original_ll": -1.8768893480300903, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  const int d[8][8]={\n    {0,0,  0,  0,  0,  0,   0,  0},\n    {0,0,300,500,600,700,1350,1650},\n    {0,0,  0,350,450,600,1150,1500},\n    {0,0,  0,  0,250,400,1000,1350},\n    {0,0,  0,  0,  0,250, 850,1300},\n    {0,0,  0,  0,  0,  0, 600,1150},\n    {0,1,  0,  0,  0,  0,   0, 500},\n    {0,1,  1,  1,  1,  1,   0,   0}\n  };\n  int n,m,ih,it,oh,ot;\n  int p=0;\n  while(1){\n    scanf(\"%d\",&n);\n    if(!n)break;\n    scanf(\"%d %d %d %d %d\",&ih,&it,&m,&oh,&ot);\n    if(n>m){\n      p=n;\n      n=m;\n      m=p;\n    }\n    p=d[n][m];\n    it+=60*ih;\n    ot+=60*oh;\n    if(d[m][n]==0&&\n       ((17*60+30<=it&&it<=19*60+30)||\n\t17*60+30<=ot&&ot<=19*60+30))p/=2;\n    if(p%50)p+=25;\n    printf(\"%d\\n\",p);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int price[8][8] = {\n        {0, 0, 0, 0, 0, 0, 0, 0},\n        {0, 0, 350, 450, 600, 750, 1050, 1300},\n        {0, 350, 0, 450, 500, 650, 900, 1150},\n        {0, 450, 450, 0, 400, 500, 750, 1050},\n        {0, 600, 500, 400, 0, 350, 600, 850},\n        {0, 750, 650, 500, 350, 0, 450, 700},\n        {0, 1050, 900, 750, 600, 450, 0, 500},\n        {0, 1300, 1150, 1050, 850, 700, 500, 0}\n    };\n    \n    int distance[8][8] = {\n        {0, 0, 0, 0, 0, 0, 0, 0},\n        {0, 0, 9, 12, 19, 25, 39, 58},\n        {0, 9, 0, 12, 16, 22, 36, 55},\n        {0, 12, 12, 0, 10, 16, 30, 49},\n        {0, 19, 16, 10, 0, 10, 24, 43},\n        {0, 25, 22, 16, 10, 0, 18, 37},\n        {0, 39, 36, 30, 24, 18, 0, 19},\n        {0, 58, 55, 49, 43, 37, 19, 0}\n    };\n    \n    int d;\n    while(scanf(\"%d\", &d) == 1 && d != 0) {\n        int hd, md, a, ha, ma;\n        scanf(\"%d %d\", &hd, &md);\n        scanf(\"%d\", &a);\n        scanf(\"%d %d\", &ha, &ma);\n        \n        int start_time = hd * 60 + md;\n        int end_time = ha * 60 + ma;\n        int discount_start = 17 * 60 + 30;\n        int discount_end = 19 * 60 + 30;\n        \n        int dist = distance[d][a];\n        int cost = price[d][a];\n        \n        int is_discount = 0;\n        if ((start_time >= discount_start && start_time <= discount_end) ||\n            (end_time >= discount_start && end_time <= discount_end)) {\n            if (dist <= 40) {\n                is_discount = 1;\n            }\n        }\n        \n        if (is_discount) {\n            int half = cost / 2;\n            if (cost % 2 != 0) {\n                half++;\n            }\n            int remainder = half % 50;\n            if (remainder != 0) {\n                half = half + (50 - remainder);\n            }\n            cost = half;\n        }\n        \n        printf(\"%d\\n\", cost);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  900, 1150}, {0, 450, 450, 0, 400, 500, 750, 1050}, {0, 600, 500, 400, 0, 350, 600, 850}, {0, 750, 650, 500, 350, 0, 450, 700}, {0, 1050, 900, 750,  0, 0,  39, 58}, {0, 9, 0, 12,  30, 49}, {0, 19,   0, 19}, {0, 58, 55, 49,  a, ha, ma; scanf(\"%d %d\", &hd, &md); scanf(\"%d\", &a); scanf(\"%d %d\", &ha, &ma); int start_time = hd * 60 + md; int end_time = ha * 60 + ma; int discount_start = 17 * 60 + 30; int discount_end = 19 * 60 + 30; int dist = distance[d][a]; int cost = price[d][a]; int is_discount = 0; if ((start_time >= discount_start && start_time <= discount_end) || (end_time >= discount_start && end_time <= discount_end)) { if (dist <= 40) { is_discount  { half++; } int remainder = half % 50; if (remainder != 0) { half = half + (50 - remainder);  }"], "perturbed_original": ["#include<stdio.h> int main(){ const int d[8][8]={ {0,0, 0, 0, 0, 0, 0, 0}, 0 }<extra_id_1>{ scanf(\"%d\",&ih,&it); if(n>4)break;<extra_id_2>} 850,1300}, {0,0, 0, 0, 0, 0, 600,1150}, {0,1, 0, 0, 0, 0, 0, 500}, {0,1, 1, <extra_id_3>; int a = 1<extra_id_4>! s &&<extra_id_5>1 ]<extra_id_6>3&&<extra_id_7>] !<extra_id_8>850,1100), { i=0; i<8}<extra_id_9>int i = 8<extra_id_10>d[n,p=p; if(isNaN(a)||i==4){<extra_id_11>1 while(1){ scanf(\"%d\",&n); if(!n)break; scanf(\"%d %d %d %d %d\",&ih,&it,&m,&oh,&ot); if(n>m){ p=n; n=m; m=p; }  0; }"], "original_ll": -0.9169138669967651, "sampled_ll": -0.42229679226875305, "all_perturbed_sampled_ll": [-1.4004746675491333], "all_perturbed_original_ll": [-2.2136332988739014], "perturbed_sampled_ll": -1.4004746675491333, "perturbed_original_ll": -2.2136332988739014, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static int[][] money = new int[][]\n\t\t\t{\n\t\t\t\t{\t0,\t300,\t500,\t600,\t700,\t1350,\t1650},\n\t\t\t\t{\t0,\t0,\t\t350,\t450,\t600,\t1150,\t1500},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t250,\t400,\t1000,\t1350},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t0,\t\t250,\t850,\t1300},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t0,\t\t0,\t\t600,\t1150},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t0,\t\t0,\t\t0,\t\t 500},\n\t\t\t};\n\t\n\tpublic static int[][] dist = new int[][]\n\t\t\t{\n\t\t\t\t{\t0,\t6,\t13,\t18,\t23,\t43,\t58},\n\t\t\t\t{\t0,\t0,\t7,\t12,\t17,\t37,\t52},\n\t\t\t\t{\t0,\t0,\t0,\t5,\t10,\t30,\t45},\n\t\t\t\t{\t0,\t0,\t0,\t0,\t5,\t25,\t40},\n\t\t\t\t{\t0,\t0,\t0,\t0,\t0,\t20,\t35},\n\t\t\t\t{\t0,\t0,\t0,\t0,\t0,\t0,\t15},\n\t\t\t};\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int start = sc.nextInt() - 1;\n\t\t\t\n\t\t\tif(start == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int start_h = sc.nextInt();\n\t\t\tfinal int start_m = sc.nextInt();\n\t\t\tfinal int start_t = start_h * 60 + start_m;\n\t\t\t\n\t\t\tfinal int end = sc.nextInt() - 1;\n\t\t\tfinal int end_h = sc.nextInt();\n\t\t\tfinal int end_m = sc.nextInt();\n\t\t\tfinal int end_t = end_h * 60 + end_m;\n\t\t\t\n\t\t\tint cost = 0;\n\t\t\tif(start_t <= (17 * 60 + 30) && end_t >= (17 * 60 + 30) && end_t <= (19 * 60 + 30) || start_t >= (17 * 60 + 30) && start_t <= (19 * 60 + 30) && end_t >= (19 * 60 + 30)){\n\t\t\t\tif(dist[start][end] <= 40){\n\t\t\t\t\tcost = (int) (Math.ceil((money[start][end] / (2.0 * 50)))) * 50;\n\t\t\t\t}else{\n\t\t\t\t\tcost = money[start][end];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcost = money[start][end];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cost);\n\t\t}\n\t\t\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Distance and price table\n        int[][] distance = new int[8][8];\n        int[][] price = new int[8][8];\n        \n        // Initialize distance table (symmetric)\n        int[][] distData = {\n            {0, 6, 12, 18, 32, 41, 58},\n            {6, 0, 6, 12, 26, 35, 52},\n            {12, 6, 0, 6, 20, 29, 46},\n            {18, 12, 6, 0, 14, 23, 40},\n            {32, 26, 20, 14, 0, 9, 26},\n            {41, 35, 29, 23, 9, 0, 17},\n            {58, 52, 46, 40, 26, 17, 0}\n        };\n        \n        int[][] priceData = {\n            {0, 350, 450, 600, 900, 1150, 1400},\n            {350, 0, 350, 450, 750, 900, 1200},\n            {450, 350, 0, 350, 600, 750, 1050},\n            {600, 450, 350, 0, 450, 600, 850},\n            {900, 750, 600, 450, 0, 350, 600},\n            {1150, 900, 750, 600, 350, 0, 350},\n            {1400, 1200, 1050, 850, 600, 350, 0}\n        };\n        \n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                distance[i+1][j+1] = distData[i][j];\n                price[i+1][j+1] = priceData[i][j];\n            }\n        }\n        \n        while (true) {\n            int d = sc.nextInt();\n            if (d == 0) break;\n            \n            int hd = sc.nextInt();\n            int md = sc.nextInt();\n            int a = sc.nextInt();\n            int ha = sc.nextInt();\n            int ma = sc.nextInt();\n            \n            int dist = distance[d][a];\n            int baseFare = price[d][a];\n            \n            // Check if discount applies\n            // 17:30 - 19:30 (1050 - 1170 minutes from midnight)\n            int departTime = hd * 60 + md;\n            int arriveTime = ha * 60 + ma;\n            \n            boolean discount = false;\n            if (dist <= 40) {\n                // Check if either departure or arrival is in discount time\n                if ((departTime >= 1050 && departTime <= 1170) || \n                    (arriveTime >= 1050 && arriveTime <= 1170)) {\n                    discount = true;\n                }\n            }\n            \n            int fare;\n            if (discount) {\n                // Half price, round up to nearest 50 yen\n                int halfFare = baseFare / 2;\n                fare = ((halfFare + 49) / 50) * 50;\n            } else {\n                fare = baseFare;\n            }\n            \n            System.out.println(fare);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  { Scanner sc = new Scanner(System.in); // Distance and price table  // Initialize distance table (symmetric) int[][] distData = { {0, 6, 12, 18, 32, 41, 58}, {6, 0, 6, 12, 26, 35, 52}, {12, 6, 0, 6, 20, 29, 46},  14, 0, 9, 26}, {41, 35, 29, 23, 9, 0, 17}, {58, 52, 46, 40, 26, 17, 0} }; int[][] priceData = { {0, 350, 450,  450, 350, 0, 450, 600, 850}, {900, 750, 600, 450, 0, 350, 600}, {1150, 900, 750, 600, 350, 0, 350}, {1400, 1200, 1050, 850, 600, 350, 0} }; for (int i = 0; i < 7; i++) { for  = distData[i][j]; price[i+1][j+1] = priceData[i][j];  (d ==  int  sc.nextInt(); int dist  from midnight) int departTime = hd * 60 + md; int arriveTime = ha * 60 + ma; boolean discount =  departure or arrival is  1170) || (arriveTime >= 1050 &&  fare; if  yen int halfFare = baseFare / 2; fare = ((halfFare + 49) / 50) *  sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class  { 0, 300, 500, 600, 700, 1350, 1650}, { 0, 0, 350, 450, 600, 1150, 1500}, { 0, 0, 0, 250, 400, 1000,  0, 0, 0, 0, 0, 600, 1150}, { 0, 0, 0,  43, 58}, { 0, 0, 7, 12, 17, 37, 52}, { 0, 0, 0, 5, 10, 30, 45}, {  0, 0, 0, 20, 35}, { 0, 0, 0, 0,  Scanner sc = new Scanner(System.in); while(true){ final int start = sc.nextInt() -  = start_h * 60 + start_m; final int end = sc.nextInt() - 1; final int end_h =  end_h * 60 + end_m; int cost = 0; if(start_t <= (17 * 60 + 30) && end_t >= (17 * 60 + 30) && end_t  * 60 +  end_t >= (19  (Math.ceil((money[start][end] / (2.0 * 50)))) * 50; }else{ cost =  }"], "original_ll": -0.5417076945304871, "sampled_ll": -0.5272404551506042, "all_perturbed_sampled_ll": [-1.6333587169647217], "all_perturbed_original_ll": [-1.401187539100647], "perturbed_sampled_ll": -1.6333587169647217, "perturbed_original_ll": -1.401187539100647, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "table=[[0,300,500,600,700,1350,1650],\n       [0,0,350,450,600,1150,1500],\n       [0,0,0,250,400,1000,1350],\n       [0,0,0,0,250,850,1300],\n       [0,0,0,0,0,600,1150],\n       [0,0,0,0,0,0,500]]\nfbd=[(1,6),(1,7),(2,7),(3,7)]\nwhile True:\n    init=input()\n    if init==0:break\n    h1,m1=map(int,raw_input().split())\n    fin=input()\n    h2,m2=map(int,raw_input().split())\n    if init>fin:\n        init,h1,m1,fin,h2,m2=fin,h2,m2,init,h1,m1\n    t1=h1*60+m1\n    t2=h2*60+m2\n    if 1050<=t1<=1170 or 1050<=t2<=1170 and (init,fin) not in fbd:\n        temp=table[init-1][fin-1]/2\n        if temp%100>0:\n            temp+=50-temp%50\n        print temp\n    else:\n        print table[init-1][fin-1]", "sampled": "import math\n\n# Distance and toll matrix\ndistance = [\n    [0, 6, 18, 25, 37, 48, 58],\n    [6, 0, 12, 19, 31, 42, 52],\n    [18, 12, 0, 7, 19, 30, 40],\n    [25, 19, 7, 0, 12, 23, 33],\n    [37, 31, 19, 12, 0, 11, 21],\n    [48, 42, 30, 23, 11, 0, 10],\n    [58, 52, 40, 33, 21, 10, 0]\n]\n\ntoll = [\n    [0, 200, 500, 650, 900, 1150, 1350],\n    [200, 0, 450, 600, 850, 1100, 1300],\n    [500, 450, 0, 250, 500, 750, 950],\n    [650, 600, 250, 0, 350, 600, 800],\n    [900, 850, 500, 350, 0, 300, 550],\n    [1150, 1100, 750, 600, 300, 0, 250],\n    [1350, 1300, 950, 800, 550, 250, 0]\n]\n\ndef in_discount_time(h, m):\n    time_minutes = h * 60 + m\n    start = 17 * 60 + 30  # 17:30\n    end = 19 * 60 + 30    # 19:30\n    return start <= time_minutes <= end\n\nwhile True:\n    d = int(input())\n    if d == 0:\n        break\n    \n    hd, md = map(int, input().split())\n    a = int(input())\n    ha, ma = map(int, input().split())\n    \n    # Convert to 0-indexed\n    d -= 1\n    a -= 1\n    \n    # Get base toll and distance\n    base_toll = toll[d][a]\n    dist = distance[d][a]\n    \n    # Check if discount applies\n    discount = False\n    if (in_discount_time(hd, md) or in_discount_time(ha, ma)) and dist <= 40:\n        discount = True\n    \n    if discount:\n        # Half price, rounded up to nearest 50\n        half_toll = base_toll / 2\n        final_toll = math.ceil(half_toll / 50) * 50\n    else:\n        final_toll = base_toll\n    \n    print(final_toll)\n", "perturbed_sampled": [" [0, 6, 18, 25, 37, 48, 58], [6, 0, 12, 19, 31, 42, 52], [18, 12, 0, 7, 19, 30, 40], [25, 19, 7, 0, 12, 23,  21, 10, 0] ] toll = [ [0, 200,  [650, 600, 250, 0, 350, 600, 800], [900, 850, 500, 350, 0, 300, 550], [1150, 1100, 750, 600, 300, 0, 250], [1350, 1300, 950, 800, 550, 250, 0]  m start = 17 * 60 + 30 # 17:30 end = 19 * 60 + 30 # 19:30 return start <=  ==  ha, ma = map(int, input().split()) # Convert to 0-indexed d -= 1 a -= 1 # Get base toll and distance  ma)) and dist  rounded  = math.ceil(half_toll / 50) * 50 else: final_toll = base_toll print(final_toll)"], "perturbed_original": ["table=[[0,300,500,600,700,1350,1650], [0,0,350,450,600,1150,1500], [0,0,0,250,400,1000,1350], [0,0,0,0,250,850,1300], [0,0,0,0,0,600,1150], [0,0,0,0,0,0,500]] fbd=[(1,6),(1,7),(2,7),(3,7)] while True: init=input() if init==0:break h1,m1=map(int,raw_input().split()) fin=input() h2,m2=map(int,raw_input().split()) if init>fin: init,h1,m1,fin,h2,m2=fin,h2,m2,init,h1,m1 t1=h1*60+m1 t2=h2*60+m2  if temp%100>0: temp+=50-temp%50 print temp else: print table[init-1][fin-1]"], "original_ll": -0.9805393218994141, "sampled_ll": -0.5267416834831238, "all_perturbed_sampled_ll": [-1.462888479232788], "all_perturbed_original_ll": [-1.2471987009048462], "perturbed_sampled_ll": -1.462888479232788, "perturbed_original_ll": -1.2471987009048462, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a[];main(f,l,i,n,S){for(;scanf(S=\"%d\\n\",&i)*i;){for(l=0;i--;)scanf(S,a+l++);for(n=32;n;f=!f)n-=f?~-n%5:a[++i%l],printf(S,n*=n>0);}}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int a[25];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        \n        int remaining = 32;\n        int jiro_index = 0;\n        int turn = 0; // 0 for Ichiro, 1 for Jiro\n        \n        while (remaining > 0) {\n            if (turn == 0) {\n                // Ichiro's turn\n                int take = (remaining - 1) % 5;\n                remaining -= take;\n                printf(\"%d\\n\", remaining);\n                turn = 1;\n            } else {\n                // Jiro's turn\n                int take = a[jiro_index];\n                if (take >= remaining) {\n                    take = remaining;\n                }\n                remaining -= take;\n                printf(\"%d\\n\", remaining);\n                jiro_index = (jiro_index + 1) % n;\n                turn = 0;\n            }\n        }\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while (scanf(\"%d\", &n) == 1 && n != 0) { int a[25]; for (int i = 0; i < n; i++) { scanf(\"%d\", &a[i]); } int remaining = 32; int jiro_index =  for Jiro while (remaining > 0) { if  remaining); turn  = a[jiro_index]; if (take  printf(\"%d\\n\", remaining); jiro_index =  } return 0; }"], "perturbed_original": ["a[];main(f,l,i,n,S){for(;scanf(S=\"%d\\n\",&i)*i;){for(l=0;i--;)scanf(S,a+l++);for(n=32;n;f=!f)n-=f?~-n%5:a[++i%l],printf(S,n*=n>0);}}"], "original_ll": -4.017247676849365, "sampled_ll": -0.7036850452423096, "all_perturbed_sampled_ll": [-2.1152544021606445], "all_perturbed_original_ll": [-4.017247676849365], "perturbed_sampled_ll": -2.1152544021606445, "perturbed_original_ll": -4.017247676849365, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import static java.util.Arrays.deepToString;\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = sc.nextInt();\n\t\t\t\n\t\t\tint st = 32;\n\t\t\tfor (int time = 0; st > 0; time++) {\n\t\t\t\tst -= (st - 1) % 5;\n\t\t\t\tSystem.out.println(st);\n\t\t\t\tint g = a[time%a.length];\n\t\t\t\tst -= g;\n\t\t\t\tif (st < 0) {\n\t\t\t\t\tst = 0;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(st);\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt();\n            }\n            \n            int remaining = 32;\n            int jiroIndex = 0;\n            \n            while (remaining > 0) {\n                // Ichiro's turn\n                int ichiroTake = (remaining - 1) % 5;\n                remaining -= ichiroTake;\n                System.out.println(remaining);\n                \n                if (remaining == 0) break;\n                \n                // Jiro's turn\n                int jiroTake = Math.min(a[jiroIndex], remaining);\n                remaining -= jiroTake;\n                System.out.println(remaining);\n                \n                jiroIndex = (jiroIndex + 1) % n;\n                \n                if (remaining == 0) break;\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[] a = new int[n]; for (int i = 0; i  = 32; int jiroIndex = 0; while (remaining  -  0)  -= jiroTake;  == 0) break; } } sc.close(); } }"], "perturbed_original": ["import static java.util.Arrays.deepToString; import java.util.Scanner; public  Main().run(); } void tr(Object... os) { System.err.println(deepToString(os)); } Scanner sc = new Scanner(System.in); public void run() { for (;sc.hasNext();) { int n = sc.nextInt(); if (n == 0) break; int[] a = new int[n]; for (int i =  =  int g =  = 0; } System.out.println(st); } } } }"], "original_ll": -1.0797868967056274, "sampled_ll": -0.7308400273323059, "all_perturbed_sampled_ll": [-1.7184433937072754], "all_perturbed_original_ll": [-2.1009230613708496], "perturbed_sampled_ll": -1.7184433937072754, "perturbed_original_ll": -2.1009230613708496, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n=int(input())\n    if n==0: break\n    a=list(map(int,input().split()))\n    i,s=0,32\n    while s>0:\n        s-=(s-1)%5\n        print(s)\n        s-=a[i%n]\n        i+=1\n        print(max(0,s))", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    sequence = list(map(int, input().split()))\n    \n    remaining = 32\n    jiro_index = 0\n    \n    while remaining > 0:\n        # Ichiro's turn\n        to_take = (remaining - 1) % 5\n        remaining -= to_take\n        print(remaining)\n        \n        if remaining == 0:\n            break\n        \n        # Jiro's turn\n        to_take = min(sequence[jiro_index], remaining)\n        remaining -= to_take\n        print(remaining)\n        \n        jiro_index = (jiro_index + 1) % n\n        \n        if remaining == 0:\n            break\n", "perturbed_sampled": ["while True: n = int(input()) jiro_index<extra_id_1>print(jiro_index)<extra_id_2>(jiro_index)<extra_id_3>remaining = jiro_index<extra_id_4>print(remaining)<extra_id_5>remaining=5 if jiro_index<extra_id_6>==<extra_id_7>jiro_index % n ==<extra_id_8>print(remaining) while True:<extra_id_9>[<extra_id_10>(jiro_index + 1) %<extra_id_11>jiro_index = (jiro_index+1) %<extra_id_12># # Ichiro's turn to_take = (remaining - 1) % 5 remaining -= to_take print(remaining) if remaining == 0: break # <extra_id_13>jiro_index - j jiro_index = (jiro_index + 1) % n if remaining == 0: break"], "perturbed_original": ["while 1: n=int(input()) if n==0: break a=list(map(int,input().split())) i,s=0,32 while s>0: s-=(s-1)%5 print(s) s-=a[i%n] i+=1 print(max(0,s))"], "original_ll": -1.5220500230789185, "sampled_ll": -1.1225066184997559, "all_perturbed_sampled_ll": [-2.0652353763580322], "all_perturbed_original_ll": [-2.0299417972564697], "perturbed_sampled_ll": -2.0652353763580322, "perturbed_original_ll": -2.0299417972564697, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\n#define MAX 10000000\n\nint pp[MAX + 1];\n\nint main(){\n  int n, p, m, i, j, prime, x, res, c;\n  pp[0] = pp[1] = 1;\n  for(i = 2; i < MAX / 2 ; ++i)\n    if(pp[i] != 1)\n      for(j = i * 2; j < MAX; j += i)\n\tpp[j] = 1;\n\n  while(scanf(\"%d\", &n) && n){\n    res = 0;\n    while(n--){\n      scanf(\"%d %d\", &p, &m);\n      c = 0;\n      for(i = ((p - m) < 0 ? 0 : p - m);i < ((p + m) > MAX ? MAX : p + m); ++i)\n\tif(pp[i] == 0) c++;\n      if(c > 0) c--;\n      res += c;\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MP 999983\n#define MAX_PRIMES 80000\n\nint is_prime[MP + 1];\nint primes[MAX_PRIMES];\nint prime_count = 0;\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i <= MP; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= MP; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n    \n    for (int i = 2; i <= MP; i++) {\n        if (is_prime[i]) {\n            primes[prime_count++] = i;\n        }\n    }\n}\n\nint binary_search_lower(int val) {\n    int left = 0, right = prime_count - 1;\n    int result = prime_count;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (primes[mid] >= val) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return result;\n}\n\nint binary_search_upper(int val) {\n    int left = 0, right = prime_count - 1;\n    int result = -1;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (primes[mid] <= val) {\n            result = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result;\n}\n\nint count_primes_in_range(int lower, int upper) {\n    if (lower > MP) return 0;\n    if (upper < 2) return 0;\n    \n    if (lower < 2) lower = 2;\n    if (upper > MP) upper = MP;\n    \n    int lower_idx = binary_search_lower(lower);\n    int upper_idx = binary_search_upper(upper);\n    \n    if (lower_idx > upper_idx || lower_idx >= prime_count || upper_idx < 0) {\n        return 0;\n    }\n    \n    return upper_idx - lower_idx + 1;\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long total = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int p, m;\n            scanf(\"%d %d\", &p, &m);\n            \n            int lower = p - m;\n            int upper = p + m;\n            \n            int X = count_primes_in_range(lower, upper);\n            \n            if (X > 1) {\n                total += (X - 1);\n            } else if (X == 0) {\n                total -= 1;\n            }\n        }\n        \n        if (total < 0) total = 0;\n        \n        printf(\"%lld\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  is_prime[MP + 1]; int primes[MAX_PRIMES]; int prime_count = 0; void sieve() { memset(is_prime, 1, sizeof(is_prime)); is_prime[0] = is_prime[1] = 0; for (int i = 2; i * i <= MP; i++) { if (is_prime[i]) { for (int j = i * i;  } } } for (int i =  = i; } } } int binary_search_lower(int val) { int left = 0, right = prime_count  { int mid = (left + right) / 2; if (primes[mid] >= val) { result = mid; right = mid -  } return result; } int binary_search_upper(int val)  mid + 1; } else { right = mid - 1; } } return result; } int  0; if (upper < 2) return 0; if (lower  = MP; int lower_idx = binary_search_lower(lower); int upper_idx = binary_search_upper(upper); if (lower_idx > upper_idx || lower_idx >= prime_count || upper_idx < 0) { return 0; }  sieve(); int n; while (scanf(\"%d\", &n) == 1 && n != 0) { long long total =  + m; int X = count_primes_in_range(lower,  -= 1; } } if (total < 0) total = 0; printf(\"%lld\\n\", total); } return 0; }"], "perturbed_original": ["#include <stdio.h>  n, p, m, i, j, prime, x, res, c; pp[0] = pp[1] = 1; for(i = 2; i < MAX / 2 ; ++i)  MAX; j += i) pp[j] =  - m) < 0 ? 0 : p - m);i < ((p + m) > MAX ? MAX : p  c--; res += c; } printf(\"%d\\n\", res); } return 0; }"], "original_ll": -0.8939827680587769, "sampled_ll": -0.36275139451026917, "all_perturbed_sampled_ll": [-1.4056336879730225], "all_perturbed_original_ll": [-2.5290908813476562], "perturbed_sampled_ll": -1.4056336879730225, "perturbed_original_ll": -2.5290908813476562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tlong[] m = new long[]{ 2, 7, 61 };\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> Ans = new ArrayList<Integer>();\n\t\tString line;\n\t\t\n\t\tint[] prime = new int[1000000];\n\t\t\n\t\twhile((line = in.readLine()) != null){\n\t\t\tint size = Integer.parseInt(line);\n\t\t\tif(size==0) break;\n\t\t\t\n\t\t\tint pay = 0;\n\t\t\tfor(int n=0; n<size; n++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tint center = Integer.parseInt(dst[0]);\n\t\t\t\tint range = Integer.parseInt(dst[1]);\n\t\t\t\t\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i=Math.max(2, center-range); i<=Math.min(center+range, 999983); i++){\n\t\t\t\t\tif(prime[i]==0){\n\t\t\t\t\t\tif(isPrime(i)){\n\t\t\t\t\t\t\tprime[i] = 1;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tprime[i] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(prime[i]==1){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpay += count - 1;\n\t\t\t}\n\t\t\t\n\t\t\tAns.add(Math.max(0, pay));\n\t\t}\n\t\t\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tSystem.out.println(Ans.get(n));\n\t\t}\t\t\n\t}\n\t\n\tpublic boolean isPrime(long x){\n\t\tif(x==2){\n\t\t\treturn true;\n\t\t}\n\t\telse if(x%2 == 0){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\tlong s = 0;\n\t\t\tlong d = x - 1;\n\t\t\twhile(d%2 == 0){\n\t\t\t\td = d / 2;\n\t\t\t\ts++;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<3; i++){\n\t\t\t\tlong a = m[i];\n\t\t\t\tif(a%x == 0) continue;\n\t\t\t\t\n\t\t\t\tlong pow = mod(a, d, x);\n\t\t\t\tif(pow == 1) continue;\n\t\t\t\tif(pow == x - 1) continue;\n\t\t\t\t\n\t\t\t\tboolean con2 = false;\n\t\t\t\tfor(int r=1; r<s; r++){\n\t\t\t\t\tpow = mod(pow, 2, x);\n\t\t\t\t\t//pow = mod(a, (long)(d * Math.pow(2.0, r)), x);\n\t\t\t\t\tif(pow ==  x - 1){\n\t\t\t\t\t\tcon2 = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!con2){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic long mod(long a, long d, long n){\n\t\tif(a==0 || n==0) return 0;\n\t\tif(d==0) return 1 % n;\n\t\t\n\t\tlong currentMod = a % n;\n\t\tlong currentValue = (d%2 == 1) ? currentMod : 1;\n\t\t\n\t\tfor(d>>=1; d>0; d>>=1){\n\t\t\tcurrentMod = (currentMod * currentMod) % n;\n\t\t\tif(d%2 == 1){\n\t\t\t\tcurrentValue = (currentValue * currentMod) % n;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn currentValue;\n\t\t\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MP = 999983;\n    static boolean[] isPrime;\n    static int[] primeCount;\n    \n    static void sieve() {\n        isPrime = new boolean[MP + 1];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i <= MP; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= MP; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        primeCount = new int[MP + 1];\n        int count = 0;\n        for (int i = 0; i <= MP; i++) {\n            if (isPrime[i]) count++;\n            primeCount[i] = count;\n        }\n    }\n    \n    static int countPrimes(int p, int m) {\n        int left = Math.max(0, p - m);\n        int right = Math.min(MP, p + m);\n        \n        int count = primeCount[right];\n        if (left > 0) {\n            count -= primeCount[left - 1];\n        }\n        \n        return count;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        \n        sieve();\n        \n        String line;\n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            long totalRequest = 0;\n            \n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                int p = Integer.parseInt(parts[0]);\n                int m = Integer.parseInt(parts[1]);\n                \n                int x = countPrimes(p, m);\n                \n                if (x == 0) {\n                    totalRequest -= 1;\n                } else {\n                    totalRequest += (x - 1);\n                }\n            }\n            \n            totalRequest = Math.max(0, totalRequest);\n            pw.println(totalRequest);\n        }\n        \n        pw.flush();\n        pw.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static final int MP = 999983; static boolean[] isPrime; static int[] primeCount; static void sieve() { isPrime = new boolean[MP + 1]; Arrays.fill(isPrime, true); isPrime[0] = isPrime[1] = false; for (int i = 2; i * i <=  i * i; j <= MP; j += i) { isPrime[j] = false;  <= MP; i++) { if (isPrime[i]) count++; primeCount[i] = count; } } static int countPrimes(int p, int m) { int left =  m); int count = primeCount[right]; if (left > 0) { count -= primeCount[left - 1]; } return  BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); PrintWriter pw =  null) { int n  } else { totalRequest += (x - 1); } } totalRequest = Math.max(0, totalRequest); pw.println(totalRequest); } pw.flush(); pw.close(); } }"], "perturbed_original": ["import java.io.*; import java.util.*;  new long[]{ 2, 7, 61 }; public Main() throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); List<Integer> Ans = new ArrayList<Integer>(); String  null){ int size = Integer.parseInt(line); if(size==0) break;  Integer.parseInt(dst[0]); int range = Integer.parseInt(dst[1]); int count = 0; for(int i=Math.max(2, center-range); i<=Math.min(center+range, 999983); i++){ if(prime[i]==0){ if(isPrime(i)){ prime[i] = 1;  } } } pay += count - 1; }  if(x%2 == 0){ return false; } else{ long s = 0; long d = x - 1; while(d%2 == 0){ d = d / 2; s++; } for(int i=0; i<3; i++){  = mod(a, d, x); if(pow == 1) continue; if(pow == x - 1) continue; boolean con2 = false; for(int r=1; r<s; r++){ pow = mod(pow, 2, x); //pow =  1){  } return true; } } public long mod(long  if(d==0) return 1 % n; long currentMod = a % n; long currentValue = (d%2 ==  (currentMod * currentMod) % n; if(d%2  } return currentValue; } }"], "original_ll": -0.7559167742729187, "sampled_ll": -0.45180654525756836, "all_perturbed_sampled_ll": [-1.60685133934021], "all_perturbed_original_ll": [-2.016390562057495], "perturbed_sampled_ll": -1.60685133934021, "perturbed_original_ll": -2.016390562057495, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nN=1000000\nprime=[1]*(N+1)\nprime[0]=0\nprime[1]=0\nfor i in range(2,int(math.sqrt(N))):\n    if prime[i]==1:\n        j=i\n        while i*j<=N:\n            prime[i*j]=0\n            j+=1\nprime=[i for i in range(N+1) if prime[i]==1]\n\nwhile True:\n    n=input()\n    if n==0:break\n    cnt=0\n    for i in range(n):\n        p,m=map(int,raw_input().split())\n        for j in range(len(prime)):\n            if p-m<=prime[j]<=p+m:\n                cnt+=1\n            if p+m<=prime[j]:\n                break\n    print cnt-n", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    primes = [i for i in range(limit + 1) if is_prime[i]]\n    return primes, is_prime\n\nMP = 999983\nprimes, is_prime = sieve_of_eratosthenes(MP)\n\ndef binary_search_left(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef binary_search_right(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef count_primes_in_range(low, high):\n    left_idx = binary_search_left(primes, low)\n    right_idx = binary_search_right(primes, high)\n    return right_idx - left_idx\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    total_cost = 0\n    for _ in range(n):\n        p, m = map(int, input().split())\n        low = max(0, p - m)\n        high = min(MP, p + m)\n        \n        X = count_primes_in_range(low, high)\n        \n        if X > 0:\n            total_cost += X - 1\n        else:\n            total_cost -= 1\n    \n    total_cost = max(0, total_cost)\n    print(total_cost)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(limit**0.5) + 1): if is_prime[i]: for j in range(i*i, limit + 1, i): is_prime[j] = False primes = [i for i in range(limit + 1) if is_prime[i]]  def binary_search_left(arr, target): left, right = 0, len(arr) while  if arr[mid] < target: left = mid + 1 else: right = mid return left def binary_search_right(arr, target): left, right = 0, len(arr) while left < right: mid = (left  mid + 1 else: right = mid return  0 for _ in range(n):  m) high = min(MP,  1 total_cost = max(0, total_cost) print(total_cost)"], "perturbed_original": ["import math N=1000000 prime=[1]*(N+1) prime[0]=0 prime[1]=0 for i in range(2,int(math.sqrt(N))): if prime[i]==1: j=i while i*j<=N: prime[i*j]=0 j+=1 prime=[i for i in range(N+1) if prime[i]==1] while True:  print cnt-n"], "original_ll": -0.924961268901825, "sampled_ll": -0.4281202256679535, "all_perturbed_sampled_ll": [-1.1604712009429932], "all_perturbed_original_ll": [-1.4793908596038818], "perturbed_sampled_ll": -1.1604712009429932, "perturbed_original_ll": -1.4793908596038818, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void) {\n  int n, data[100], j, tmp, i, count;\n  while(scanf(\"%d\",&n),n) {\n    count = 0;\n    for(i = 0; i < n; i++ ) {\n      scanf(\"%d\",&data[i]);\n    }\n    for(i = 0; i < n - 1; i++ ) {\n      for(j = 1; j < n - i; j++ ) {\n\tif(data[j] < data[j-1]) {\n\t  tmp = data[j];\n\t  data[j] = data[j-1];\n\t  data[j-1] = tmp;\n\t  count++;\n\t}\n      }\n    }\n    printf(\"%d\\n\",count);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int arr[100];\n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", &arr[i]);\n        }\n        \n        int swaps = 0;\n        for(int i = 0; i < n - 1; i++) {\n            for(int j = 0; j < n - 1 - i; j++) {\n                if(arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swaps++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", swaps);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() {  int arr[100]; for(int i = 0; i  0; for(int i =  = 0; j < n - 1 - i; j++) { if(arr[j] > arr[j + 1]) { int  1] = temp; swaps++; } } } printf(\"%d\\n\", swaps); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int  { scanf(\"%d\",&data[i]); } for(i =  = 1; j < n - i; j++ ) { if(data[j] < data[j-1]) { tmp = data[j]; data[j] = data[j-1]; data[j-1] = tmp; count++; } } } printf(\"%d\\n\",count); } return 0; }"], "original_ll": -0.6416163444519043, "sampled_ll": -0.325618714094162, "all_perturbed_sampled_ll": [-1.8148032426834106], "all_perturbed_original_ll": [-1.6349456310272217], "perturbed_sampled_ll": -1.8148032426834106, "perturbed_original_ll": -1.6349456310272217, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n\tScanner sc = new Scanner(System.in);\n\t\n\tprivate void doit(){\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint [] data = new int[n];\n\t\t\tfor(int i = 0; i  <n; i++){\n\t\t\t\tdata[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor(;;){\n\t\t\t\tboolean flg = false;\n\t\t\t\tfor(int j = 0; j < n-1; j++){\n\t\t\t\t\tif(data[j] > data[j + 1]){\n\t\t\t\t\t\tint temp = data[j];\n\t\t\t\t\t\tdata[j] = data[j+1];\n\t\t\t\t\t\tdata[j+1] = temp;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(! flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = sc.nextInt();\n            }\n            \n            int swapCount = bubbleSort(arr, n);\n            System.out.println(swapCount);\n        }\n        \n        sc.close();\n    }\n    \n    static int bubbleSort(int[] arr, int n) {\n        int count = 0;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - 1 - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void  { int n = sc.nextInt(); if (n == 0)  } static int bubbleSort(int[] arr, int n) { int count = 0; for (int i = 0; i < n - 1; i++) { for (int j = 0;  (arr[j] > arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j +  return count; } }"], "perturbed_original": ["import java.util.*; public class Main{ Scanner sc = new Scanner(System.in); private void  int [] data = new int[n]; for(int i = 0; i <n; i++){ data[i] = sc.nextInt(); } int count = 0; for(;;){ boolean flg = false; for(int j =  int temp = data[j]; data[j] = data[j+1]; data[j+1]  break; } } System.out.println(count); }  Arrays.deepToString(o));  }"], "original_ll": -0.7946022748947144, "sampled_ll": -0.24752920866012573, "all_perturbed_sampled_ll": [-1.4239826202392578], "all_perturbed_original_ll": [-1.882258415222168], "perturbed_sampled_ll": -1.4239826202392578, "perturbed_original_ll": -1.882258415222168, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    Num_lis = []\n    cou = 0\n    for i in range(n):\n        Num_lis.append(int(input()))\n    S_lis = sorted(Num_lis)\n    while Num_lis != S_lis:\n        \n        for j in range(n - 1):\n            if Num_lis[j] > Num_lis[j + 1]:\n                Num_lis[j],Num_lis[j + 1] = Num_lis[j + 1],Num_lis[j]\n                cou += 1\n    print(cou)", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    arr = []\n    for _ in range(n):\n        arr.append(int(input()))\n    \n    count = 0\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                count += 1\n    \n    print(count)\n", "perturbed_sampled": ["while True: n  for _ in range(n): arr.append(int(input())) count = 0 for i in range(n - 1): for j in range(n - 1 - i): if arr[j] > arr[j + 1]: arr[j], arr[j  print(count)"], "perturbed_original": ["while True: n = int(input()) if n == 0: break Num_lis = [] cou = 0 for i in range(n): Num_lis.append(int(input())) S_lis =   = Num_lis[j + 1],Num_lis[j] cou += 1 print(cou)"], "original_ll": -0.7544963955879211, "sampled_ll": -0.4865417778491974, "all_perturbed_sampled_ll": [-1.809408187866211], "all_perturbed_original_ll": [-2.076369047164917], "perturbed_sampled_ll": -1.809408187866211, "perturbed_original_ll": -2.076369047164917, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  int n, p[31] = {}, i, res;\n  p[0] = 1;\n  p[1] = 1;\n  p[2] = 2;\n\n\n  while(scanf(\"%d\", &n) && n){\n    for(i = 3; i <= n; i++) p[i] = p[i - 1] + p[i - 2] + p[i - 3];\n    res = p[n] / 10 / 365 + 1;\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    long long dp[31];\n    \n    // Calculate number of ways to climb stairs for each n\n    dp[0] = 1;\n    dp[1] = 1;\n    dp[2] = 2;\n    \n    for (int i = 3; i <= 30; i++) {\n        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\n    }\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long ways = dp[n];\n        long long days = (ways + 9) / 10;  // Round up division\n        long long years = (days + 364) / 365;  // Round up division\n        printf(\"%lld\\n\", years);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main()  1; dp[1] = 1; dp[2] = 2; for (int i = 3; i <= 30; i++) { dp[i] = dp[i-1] + dp[i-2] + dp[i-3];  { long long  / 10; // Round up division long long years = (days + 364) / 365; // Round up division printf(\"%lld\\n\", years); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ int n, p[31] = {}, i,   i++) p[i] = p[i - 1] + p[i - 2] + p[i - 3]; res = p[n] / 10 / 365 + 1; printf(\"%d\\n\", res); } return 0; }"], "original_ll": -0.9455469846725464, "sampled_ll": -0.684653639793396, "all_perturbed_sampled_ll": [-1.5506545305252075], "all_perturbed_original_ll": [-2.0092673301696777], "perturbed_sampled_ll": -1.5506545305252075, "perturbed_original_ll": -2.0092673301696777, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,i,j,a[];(n=s.nextInt())>0;System.out.println(a[n]/3650+1))for(a=new int[n+3],a[1]=a[2]=a[3]=1,i=0;i<n;++i)for(j=4;j-->1;)a[i+j]+=a[i];}}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        long[] ways = new long[31];\n        ways[0] = 1;\n        \n        for (int i = 1; i <= 30; i++) {\n            ways[i] = 0;\n            if (i >= 1) ways[i] += ways[i-1];\n            if (i >= 2) ways[i] += ways[i-2];\n            if (i >= 3) ways[i] += ways[i-3];\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            long totalWays = ways[n];\n            long days = (totalWays + 9) / 10;\n            long years = (days + 364) / 365;\n            \n            System.out.println(years);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  Scanner sc = new Scanner(System.in); long[] ways = new long[31]; ways[0] = 1; for (int i = 1; i <= 30; i++) { ways[i] = 0; if  ways[i-3]; }  0) break; long totalWays = ways[n]; long days = (totalWays + 9) / 10; long years = (days + 364) / 365; System.out.println(years); } sc.close(); } }"], "perturbed_original": ["import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,i,j,a[];(n=s.nextInt())>0;System.out.println(a[n]/3650+1))for(a=new int[n+3],a[1]=a[2]=a[3]=1,i=0;i<n;++i)for(j=4;j-->1;)a[i+j]+=a[i];}}"], "original_ll": -1.9242453575134277, "sampled_ll": -0.5291915535926819, "all_perturbed_sampled_ll": [-1.6799193620681763], "all_perturbed_original_ll": [-1.9242453575134277], "perturbed_sampled_ll": -1.6799193620681763, "perturbed_original_ll": -1.9242453575134277, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a = []\na[:4] = [0, 1, 2, 3]\ninList = []\nwhile True:\n    price = int(input())\n    if price == 0:\n        break\n    inList.append(int(input()))\nn = max(inList)\nfor i in range(4, n + 1):\n    a[i] = a[i-1] + a[i-2] + a[i-3]\nfor i in inList:\n    print((a[i] // 3650) + (a[i] % 3650 != 0))", "sampled": "import sys\n\ndef count_ways(n):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        dp[i] = dp[i-1]\n        if i >= 2:\n            dp[i] += dp[i-2]\n        if i >= 3:\n            dp[i] += dp[i-3]\n    \n    return dp[n]\n\ndef calculate_years(n):\n    ways = count_ways(n)\n    days = (ways + 9) // 10\n    years = (days + 364) // 365\n    return years\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    if n == 0:\n        break\n    print(calculate_years(n))\n", "perturbed_sampled": ["import sys def count_ways(n): if n == 0: return 1 if n <extra_id_2>- 1:<extra_id_3>if n == 0:<extra_id_4>] for i<extra_id_5>><extra_id_6>): fmt . show<extra_id_7>return fmt<extra_id_8>) sys<extra_id_9>. stderr . write<extra_id_10>\"<extra_id_11>if i<extra_id_12>] 1) dp[0] = 1  if i >= 2: dp[i] += dp[i-2] if i >= 3:  days = (ways + 9) // 10 years = (days + 364)  int(line.strip()) if n == 0: break print(calculate_years(n))"], "perturbed_original": ["a = [] a[:4]  price = int(input()) if price == 0: break inList.append(int(input())) n = max(inList) for i in range(4, n + 1): a[i] = a[i-1] + a[i-2] + a[i-3]  3650 != 0))"], "original_ll": -1.236865520477295, "sampled_ll": -0.5379208326339722, "all_perturbed_sampled_ll": [-2.522987127304077], "all_perturbed_original_ll": [-2.5256099700927734], "perturbed_sampled_ll": -2.522987127304077, "perturbed_original_ll": -2.5256099700927734, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint main(){\n  int i;\n  int c[128],m,n;\n  char s[256],*t;  \n  for(;;){\n    fgets(s,256,stdin);\n    s[strlen(s)-1]='\\0';\n    t=strtok(s,\" \");\n    c[0]=atoi(t)<10?atoi(t):10;\n    if(c[0]==0)\n      break;\n    for(n=1;(t=strtok(NULL,\" \"))!=NULL;n++)\n      c[n]=atoi(t)<10?atoi(t):10;\n    m=0;\n    for(i=0;i<n;i++)\n      m+=c[i];\n    for(i=0;i<n;i++){\n      if(m<12&&c[i]==1)\n\tm+=10;\n    }\n    if(m>21)\n      m=0;\n    printf(\"%d\\n\",m);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int card;\n    \n    while (1) {\n        scanf(\"%d\", &card);\n        if (card == 0) break;\n        \n        int sum = 0;\n        int aces = 0;\n        \n        do {\n            if (card == 1) {\n                sum += 1;\n                aces++;\n            } else if (card >= 2 && card <= 9) {\n                sum += card;\n            } else if (card >= 10 && card <= 13) {\n                sum += 10;\n            }\n            \n            int c = getchar();\n            if (c == '\\n' || c == EOF) break;\n            scanf(\"%d\", &card);\n        } while (1);\n        \n        // Try to maximize score by using 11 for aces\n        while (aces > 0 && sum + 10 <= 21) {\n            sum += 10;\n            aces--;\n        }\n        \n        if (sum > 21) {\n            sum = 0;\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  (card == 0) break; int sum = 0; int aces =  1; aces++; } else if (card >=  else if (card >= 10  c = getchar(); if (c == '\\n' || c == EOF) break; scanf(\"%d\",  using 11 for aces while (aces > 0 && sum + 10 <= 21) { sum  = 0; } printf(\"%d\\n\", sum); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<stdlib.h>  fgets(s,256,stdin); s[strlen(s)-1]='\\0'; t=strtok(s,\" \"); c[0]=atoi(t)<10?atoi(t):10; if(c[0]==0) break; for(n=1;(t=strtok(NULL,\" \"))!=NULL;n++) c[n]=atoi(t)<10?atoi(t):10; m=0; for(i=0;i<n;i++) m+=c[i]; for(i=0;i<n;i++){ if(m<12&&c[i]==1) m+=10; } if(m>21) m=0; printf(\"%d\\n\",m); } return 0; }"], "original_ll": -1.0835449695587158, "sampled_ll": -0.6606650948524475, "all_perturbed_sampled_ll": [-2.33520770072937], "all_perturbed_original_ll": [-1.3638705015182495], "perturbed_sampled_ll": -2.33520770072937, "perturbed_original_ll": -1.3638705015182495, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile(sc.hasNext()) {\n\t\t\tString[] text = sc.nextLine().split(\" \");\n\t\t\tint[] cards = new int[text.length];\n\t\t\tboolean one = false; //1????????????\n\t\t\tint sum = 0; //????\u00a8??????\u00b0\n\t\t\tboolean flag = false;\n\n\t\t\tfor(int $ = 0; $ < text.length; $++) {\n\t\t\t\tcards[$] = Integer.parseInt(text[$]);\n\t\t\t\tif(cards[0] == 0) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(cards[$] == 1) {\n\t\t\t\t\tone = true;\n\t\t\t\t\tsum++;\n\t\t\t\t} else if(cards[$] >= 10 && cards[$] <=13) {\n\t\t\t\t\tsum += 10;\n\t\t\t\t} else {\n\t\t\t\t\tsum += cards[$];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flag) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(one) {\n\t\t\t\tif(sum + 10 <= 21) {\n\t\t\t\t\tsum += 10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(sum > 21) {\n\t\t\t\tsum = 0;\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String line = sc.nextLine().trim();\n            if (line.equals(\"0\")) {\n                break;\n            }\n            \n            String[] tokens = line.split(\"\\\\s+\");\n            int[] cards = new int[tokens.length];\n            for (int i = 0; i < tokens.length; i++) {\n                cards[i] = Integer.parseInt(tokens[i]);\n            }\n            \n            int result = calculateScore(cards);\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n    \n    private static int calculateScore(int[] cards) {\n        int baseSum = 0;\n        int aceCount = 0;\n        \n        for (int card : cards) {\n            if (card == 1) {\n                aceCount++;\n                baseSum += 1;\n            } else if (card >= 10) {\n                baseSum += 10;\n            } else {\n                baseSum += card;\n            }\n        }\n        \n        // Try to maximize the score by using aces as 11\n        int maxScore = baseSum;\n        for (int i = 0; i <= aceCount; i++) {\n            int score = baseSum + i * 10; // Each ace used as 11 adds 10 more (since base is 1)\n            if (score <= 21) {\n                maxScore = Math.max(maxScore, score);\n            }\n        }\n        \n        if (maxScore > 21) {\n            return 0;\n        }\n        \n        return maxScore;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static  break; } String[] tokens = line.split(\"\\\\s+\"); int[] cards = new int[tokens.length]; for (int i = 0; i < tokens.length;  System.out.println(result); } sc.close(); }  int aceCount = 0; for (int card : cards) { if (card == 1) { aceCount++; baseSum += 1;  } else { baseSum += card; } } // Try to maximize the score by using  = baseSum + i * 10; // Each ace used as 11 adds 10  maxScore = Math.max(maxScore, score); } } if (maxScore > 21) { return 0; } return maxScore; } }"], "perturbed_original": ["import java.util.Scanner;  text = sc.nextLine().split(\" \"); int[]  sum = 0; //????\u00a8??????\u00b0 boolean flag = false; for(int $ = 0; $  { flag = true; break; } if(cards[$] == 1)  && cards[$] <=13)  } } if(flag) { break; } if(one) { if(sum + 10 <= 21) { sum += 10; } } if(sum > 21) { sum = 0; } System.out.println(sum); } } }"], "original_ll": -0.8465014696121216, "sampled_ll": -0.5413522720336914, "all_perturbed_sampled_ll": [-1.7110345363616943], "all_perturbed_original_ll": [-2.365297794342041], "perturbed_sampled_ll": -1.7110345363616943, "perturbed_original_ll": -2.365297794342041, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    h = map(int, raw_input().split())\n    if h[0] == 0:\n        break\n    t = 0\n    a = 0\n    for c in sorted(h, reverse=True):\n        if 2 <= c <= 9:\n            t += c\n        elif 10 <= c:\n            t += 10\n        elif c == 1:\n            a += 1\n            \n    t += a\n    if 21 < t:\n        print 0\n    else:\n        for i in range(a):\n            if 21 < t + 10:\n                print t\n                break\n            else:\n                t += 10\n        else:\n            print t", "sampled": "import sys\n\ndef calculate_hand_value(cards):\n    # Convert card values\n    converted = []\n    ace_count = 0\n    \n    for card in cards:\n        if card == 1:\n            ace_count += 1\n            converted.append(1)\n        elif card >= 10:\n            converted.append(10)\n        else:\n            converted.append(card)\n    \n    # Calculate base sum (all aces as 1)\n    base_sum = sum(converted)\n    \n    # Try to maximize by converting aces from 1 to 11\n    max_value = base_sum\n    \n    # We can convert at most one ace from 1 to 11 (adding 10 to the sum)\n    # because converting more than one would add 20+ which would likely bust\n    for i in range(ace_count + 1):\n        # i is the number of aces we treat as 11\n        current_sum = base_sum + (i * 10)\n        if current_sum <= 21:\n            max_value = max(max_value, current_sum)\n    \n    if max_value > 21:\n        return 0\n    return max_value\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line == '0':\n        break\n    \n    cards = list(map(int, line.split()))\n    result = calculate_hand_value(cards)\n    print(result)\n", "perturbed_sampled": ["import sys def calculate_hand_value(cards): # Convert card values converted = [] ace_count = 0 for card in cards: if card == 1: ace_count += 1  base sum (all aces as 1)  from 1 to  one ace from 1 to 11 (adding 10  add 20+ which would likely bust for i in range(ace_count + 1): # i is the number of aces we treat as 11 current_sum =  = max(max_value, current_sum) if   = list(map(int, line.split())) result = calculate_hand_value(cards) print(result)"], "perturbed_original": ["while True: h = map(int, raw_input().split()) if h[0] == 0: break t = 0 a = 0 for c in  c elif 10 <= c: t += 10  in range(a): if 21 < t + 10: print t break else: t += 10 else: print t"], "original_ll": -1.0598018169403076, "sampled_ll": -1.047750473022461, "all_perturbed_sampled_ll": [-3.045313596725464], "all_perturbed_original_ll": [-2.2787728309631348], "perturbed_sampled_ll": -3.045313596725464, "perturbed_original_ll": -2.2787728309631348, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\ntypedef struct i{char f[21];int s,w;} i;\ni g[10];\nint n,t[10],f[10]={0},ans[10],max=0;\n\nvoid rec(int d)\n{\n\tint i,w=0,G=0;\n\tif(d==n)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(w>g[t[i]].s)\n\t\t\t\treturn;\n\t\t\tw+=g[t[i]].w;\n\t\t\tG+=g[t[i]].w*(i+1);\n\t\t}\n\t\tif(max<G)\n\t\t{\n\t\t\tmax=G;\n\t\t\tmemcpy(ans,t,sizeof(t));\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(!f[i])\n\t\t\t{\n\t\t\t\tf[i]=1;\n\t\t\t\tt[d]=i;\n\t\t\t\trec(d+1);\n\t\t\t\tf[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i;\n\tfor(;;)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%s %d%d\",g[i].f,&g[i].w,&g[i].s);\n\t\trec(0);\n\t\twhile(--n>=0)\n\t\t\tputs(g[ans[n]].f);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[25];\n    int weight;\n    int strength;\n    int index;\n} Food;\n\nint n;\nFood foods[10];\nFood current[10];\nFood best[10];\nint visited[10];\ndouble best_center;\n\nint check_valid() {\n    for (int i = 0; i < n; i++) {\n        int weight_above = 0;\n        for (int j = i + 1; j < n; j++) {\n            weight_above += current[j].weight;\n        }\n        if (current[i].strength < weight_above) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ndouble calculate_center() {\n    int numerator = 0;\n    int denominator = 0;\n    for (int i = 0; i < n; i++) {\n        numerator += (i + 1) * current[i].weight;\n        denominator += current[i].weight;\n    }\n    return (double)numerator / denominator;\n}\n\nvoid solve(int depth) {\n    if (depth == n) {\n        if (check_valid()) {\n            double center = calculate_center();\n            if (center < best_center) {\n                best_center = center;\n                for (int i = 0; i < n; i++) {\n                    best[i] = current[i];\n                }\n            }\n        }\n        return;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            visited[i] = 1;\n            current[depth] = foods[i];\n            solve(depth + 1);\n            visited[i] = 0;\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s %d %d\", foods[i].name, &foods[i].weight, &foods[i].strength);\n            foods[i].index = i;\n        }\n        \n        best_center = 1e9;\n        memset(visited, 0, sizeof(visited));\n        \n        solve(0);\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%s\\n\", best[i].name);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef struct {  int n; Food foods[10]; Food current[10]; Food best[10]; int visited[10]; double best_center; int check_valid() { for (int i = 0; i  { weight_above += current[j].weight; } if (current[i].strength < weight_above) { return 0; } }  int denominator = 0; for (int  (i + 1) * current[i].weight;  (check_valid()) { double center = calculate_center(); if (center < best_center) { best_center = center; for (int i = 0; i < n;  for (int i = 0; i < n; i++) { if (!visited[i]) { visited[i] =  } } } int main() { while (1) { scanf(\"%d\", &n); if (n == 0) break; for (int i = 0; i < n; i++) { scanf(\"%s %d %d\", foods[i].name, &foods[i].weight, &foods[i].strength); foods[i].index = i; }  } } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h>  void rec(int d) { int i,w=0,G=0; if(d==n) { for(i=0;i<n;i++) { if(w>g[t[i]].s)  else { for(i=0;i<n;i++) { if(!f[i]) { f[i]=1; t[d]=i; rec(d+1); f[i]=0; }  scanf(\"%d\",&n); if(!n) return 0; for(i=0;i<n;i++) scanf(\"%s %d%d\",g[i].f,&g[i].w,&g[i].s); rec(0); while(--n>=0) puts(g[ans[n]].f); } return 0; }"], "original_ll": -0.90479576587677, "sampled_ll": -0.46306324005126953, "all_perturbed_sampled_ll": [-1.571433424949646], "all_perturbed_original_ll": [-1.8018298149108887], "perturbed_sampled_ll": -1.571433424949646, "perturbed_original_ll": -1.8018298149108887, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Food {\n\tString name;\n\tint w;\n\tint s;\n\n\tpublic Food(String name, int w, int s) {\n\t\tthis.name = name;\n\t\tthis.w = w;\n\t\tthis.s = s;\n\t}\n\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint max = 0;\n\t\t\tList<Food> list = new ArrayList<Food>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString l = scanner.next();\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tlist.add(new Food(l, a, b));\n\t\t\t\tmax += a;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint l = 0;\n\t\t\t\tint k = 0;\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\tint m = max - list.get(j).w;\n\t\t\t\t\tint ss = list.get(j).s;\n\t\t\t\t\tif (m <= ss) {\n\t\t\t\t\t\tif (list.get(j).w > k) {\n\t\t\t\t\t\t\tk = list.get(j).w;\n\t\t\t\t\t\t\tl = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax -= list.get(l).w;\n\t\t\t\tSystem.out.println(list.get(l).name);\n\t\t\t\tlist.get(l).s = -10;\n\t\t\t\tlist.get(l).w = 0;\n\t\t\t}\n\t\t}\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Food {\n        String name;\n        int weight;\n        int strength;\n        \n        Food(String name, int weight, int strength) {\n            this.name = name;\n            this.weight = weight;\n            this.strength = strength;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            Food[] foods = new Food[n];\n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                int weight = sc.nextInt();\n                int strength = sc.nextInt();\n                foods[i] = new Food(name, weight, strength);\n            }\n            \n            int[] bestPerm = null;\n            double minG = Double.MAX_VALUE;\n            \n            int[] perm = new int[n];\n            for (int i = 0; i < n; i++) {\n                perm[i] = i;\n            }\n            \n            do {\n                if (isValid(foods, perm)) {\n                    double g = calculateG(foods, perm);\n                    if (g < minG) {\n                        minG = g;\n                        bestPerm = perm.clone();\n                    }\n                }\n            } while (nextPermutation(perm));\n            \n            for (int i = 0; i < n; i++) {\n                System.out.println(foods[bestPerm[i]].name);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static boolean isValid(Food[] foods, int[] perm) {\n        int n = perm.length;\n        for (int i = 0; i < n; i++) {\n            int weightAbove = 0;\n            for (int j = i + 1; j < n; j++) {\n                weightAbove += foods[perm[j]].weight;\n            }\n            if (foods[perm[i]].strength < weightAbove) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    static double calculateG(Food[] foods, int[] perm) {\n        int n = perm.length;\n        double numerator = 0;\n        double denominator = 0;\n        for (int i = 0; i < n; i++) {\n            numerator += (i + 1) * foods[perm[i]].weight;\n            denominator += foods[perm[i]].weight;\n        }\n        return numerator / denominator;\n    }\n    \n    static boolean nextPermutation(int[] array) {\n        int i = array.length - 2;\n        while (i >= 0 && array[i] >= array[i + 1]) {\n            i--;\n        }\n        \n        if (i < 0) {\n            return false;\n        }\n        \n        int j = array.length - 1;\n        while (array[j] <= array[i]) {\n            j--;\n        }\n        \n        swap(array, i, j);\n        reverse(array, i + 1, array.length - 1);\n        return true;\n    }\n    \n    static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    \n    static void reverse(int[] array, int start, int end) {\n        while (start < end) {\n            swap(array, start, end);\n            start++;\n            end--;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Food { String name; int weight; int strength; Food(String name, int weight, int strength) { this.name = name; this.weight = weight; this.strength = strength; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if  (int i  sc.next(); int weight = sc.nextInt(); int strength = sc.nextInt(); foods[i] = new Food(name, weight, strength); } int[] bestPerm = null; double minG =  0; i < n; i++) { perm[i] = i; } do { if (isValid(foods, perm)) { double g = calculateG(foods, perm);  perm.clone(); }  < n; i++) { System.out.println(foods[bestPerm[i]].name); } } sc.close(); } static boolean isValid(Food[] foods, int[] perm) { int n =  { int weightAbove =  n; j++) { weightAbove += foods[perm[j]].weight; } if (foods[perm[i]].strength < weightAbove) { return false; } } return  n; i++) { numerator += (i + 1) * foods[perm[i]].weight; denominator += foods[perm[i]].weight; } return numerator / denominator; } static boolean nextPermutation(int[] array) { int i =  array[i + 1]) { i--;  j = array.length - 1; while  temp;  while (start < end) { swap(array, start, end); start++; end--; } } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.List; import java.util.Scanner; class Food { String name; int w; int  = name; this.w = w; this.s = s; } } public class Main { public  { int n =  for (int i = 0; i < n; i++) { String l = scanner.next(); int a = scanner.nextInt(); int b = scanner.nextInt(); list.add(new Food(l, a, b)); max += a; } for  l =  j < list.size(); j++) {  if (m <= ss) { if (list.get(j).w > k) { k = list.get(j).w; l  = -10; list.get(l).w = 0; } } } }"], "original_ll": -0.6728569865226746, "sampled_ll": -0.29792964458465576, "all_perturbed_sampled_ll": [-1.4901148080825806], "all_perturbed_original_ll": [-1.9747867584228516], "perturbed_sampled_ll": -1.4901148080825806, "perturbed_original_ll": -1.9747867584228516, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0170\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom collections import namedtuple\nfrom itertools import permutations\n\n\ndef solve(items):\n    total_weight = 0\n    for i in items:\n        total_weight += i.w\n\n    best_ans = []\n    best_gp = float('inf')\n    # ???????????????????????????????????????????????\u00b0?????????????????\u00a7????????????\n    for perm in permutations(items):\n        ans = []\n        squashed = False\n        cw = 0\n        gp = 0\n        n = len(items)\n\n        for p in perm:\n            if p.s < cw:\n                squashed = True\n                break\n            cw += p.w\n            ans.append(p.name)\n            gp += n * p.w\n            n -= 1\n        # ????????\u00b0???????????\u00a3?????\u00b4????????????????\u00a8???????????????????????????????????????\u00a3?????????????????\u00a7????????????\n        if not squashed:\n            gp /= total_weight\n            if gp < best_gp:\n                best_gp = gp\n                best_ans = ans[:]\n    # ????????????????????????????????\u00a3??????????????\u00a7?????????????\u00b1?????????????????????????????????????????????????\n    best_ans.reverse()\n    return best_ans\n\n\nitem = namedtuple('item', ['name', 'w', 's'])\ndef main(args):\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        items = []\n        for _ in range(n):\n            name, w, s = input().split()\n            items.append(item(name, int(w), int(s)))\n\n        result = solve(items)\n        print('\\n'.join(result))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])", "sampled": "from itertools import permutations\n\ndef is_valid(order, items):\n    # Check if the order is valid (no food is crushed)\n    # order is a list of indices\n    for i in range(len(order)):\n        weight_above = sum(items[order[j]][1] for j in range(i + 1, len(order)))\n        if items[order[i]][2] < weight_above:\n            return False\n    return True\n\ndef calculate_center_of_gravity(order, items):\n    # Calculate center of gravity\n    # Lower is better\n    numerator = sum((i + 1) * items[order[i]][1] for i in range(len(order)))\n    denominator = sum(items[order[i]][1] for i in range(len(order)))\n    return numerator / denominator\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    items = []\n    for _ in range(n):\n        parts = input().split()\n        name = parts[0]\n        weight = int(parts[1])\n        strength = int(parts[2])\n        items.append((name, weight, strength))\n    \n    best_order = None\n    best_cog = float('inf')\n    \n    # Try all permutations\n    for perm in permutations(range(n)):\n        if is_valid(perm, items):\n            cog = calculate_center_of_gravity(perm, items)\n            if cog < best_cog:\n                best_cog = cog\n                best_order = perm\n    \n    # Output the result\n    for idx in best_order:\n        print(items[idx][0])\n", "perturbed_sampled": ["from itertools  is valid (no food is crushed) # order is a list of indices for i in range(len(order)): weight_above = sum(items[order[j]][1] for j in range(i + 1, len(order)))   in range(len(order))) denominator = sum(items[order[i]][1] for i in range(len(order))) return numerator / denominator while True: n = int(input()) if n == 0: break items = [] for _ in range(n): parts = input().split() name = parts[0] weight =  best_cog = float('inf') # Try all permutations for perm in permutations(range(n)): if is_valid(perm, items): cog =  best_order: print(items[idx][0])"], "perturbed_original": ["# -*-  for i in items: total_weight += i.w  in permutations(items): ans = [] squashed = False cw = 0 gp = 0 n = len(items) for p in perm: if  ans.append(p.name) gp += n * p.w n -= 1 # ????????\u00b0???????????\u00a3?????\u00b4????????????????\u00a8???????????????????????????????????????\u00a3?????????????????\u00a7???????????? if not squashed: gp /= total_weight if gp < best_gp: best_gp = gp best_ans = ans[:] # ????????????????????????????????\u00a3??????????????\u00a7?????????????\u00b1????????????????????????????????????????????????? best_ans.reverse() return best_ans  = [] for _ in range(n): name, w, s = input().split() items.append(item(name, int(w), int(s))) result = solve(items) print('\\n'.join(result)) if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -1.0658231973648071, "sampled_ll": -0.8111487030982971, "all_perturbed_sampled_ll": [-2.500312089920044], "all_perturbed_original_ll": [-2.199810266494751], "perturbed_sampled_ll": -2.500312089920044, "perturbed_original_ll": -2.199810266494751, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void)\n{\n\tchar class[20];\n\tint i, am, pm;\n\t\n\tfor(i=0;i<9;i++)\n\t{\n\t\tscanf(\"%s %d %d\",class,&am,&pm);\n\t\tprintf(\"%s %d %d\\n\",class,am+pm,(200*am)+(300*pm));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    char name[16];\n    int morning, afternoon;\n    \n    for (int i = 0; i < 9; i++) {\n        scanf(\"%s %d %d\", name, &morning, &afternoon);\n        int total = morning + afternoon;\n        int revenue = morning * 200 + afternoon * 300;\n        printf(\"%s %d %d\\n\", name, total, revenue);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  = 0; i < 9; i++) { scanf(\"%s %d %d\", name, &morning, &afternoon); int total = morning + afternoon; int revenue = morning * 200 +  return 0; }"], "perturbed_original": [" for(i=0;i<9;i++) { scanf(\"%s %d %d\",class,&am,&pm); printf(\"%s %d %d\\n\",class,am+pm,(200*am)+(300*pm)); } return 0; }"], "original_ll": -1.4504997730255127, "sampled_ll": -0.9735742807388306, "all_perturbed_sampled_ll": [-2.5153565406799316], "all_perturbed_original_ll": [-1.8592573404312134], "perturbed_sampled_ll": -2.5153565406799316, "perturbed_original_ll": -1.8592573404312134, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/**\n * @author yuichirw\n *\n */\nimport java.util.*;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\tint a,b,rel,sum;\n\t\tString c;\n\n\t\tfor(int i = 0; i < 9; i++) {\n\t\t\tc = sc.next(); a = sc.nextInt(); b = sc.nextInt();\n\t\t\tsum = a + b;\n\t\t\trel = a * 200 + b * 300;\n\t\t\tSystem.out.println(c + \" \" + sum + \" \" + rel);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        for (int i = 0; i < 9; i++) {\n            String name = sc.next();\n            int morning = sc.nextInt();\n            int afternoon = sc.nextInt();\n            \n            int totalVisitors = morning + afternoon;\n            int totalRevenue = morning * 200 + afternoon * 300;\n            \n            System.out.println(name + \" \" + totalVisitors + \" \" + totalRevenue);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args)  int totalVisitors = morning + afternoon; int totalRevenue = morning * 200 + afternoon * 300; System.out.println(name + \" \" + totalVisitors + \" \" + totalRevenue); } sc.close(); } }"], "perturbed_original": ["/** * @author yuichirw * */ import java.util.*; public class Main { static Scanner sc = new  sc.nextInt(); sum = a + b; rel = a * 200 + b * 300; System.out.println(c + \" \" + sum + \" \" + rel); } } }"], "original_ll": -1.2364200353622437, "sampled_ll": -0.7104507684707642, "all_perturbed_sampled_ll": [-1.8685206174850464], "all_perturbed_original_ll": [-2.3674449920654297], "perturbed_sampled_ll": -1.8685206174850464, "perturbed_original_ll": -2.3674449920654297, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for i in range(9):\n    name,a,b=list(input().split())\n    print(name,int(a)+int(b),int(a)*200+int(b)*300)\n", "sampled": "for _ in range(9):\n    line = input().split()\n    name = line[0]\n    morning = int(line[1])\n    afternoon = int(line[2])\n    total = morning + afternoon\n    revenue = morning * 200 + afternoon * 300\n    print(name, total, revenue)\n", "perturbed_sampled": ["for _ in range(9): line = input().split() name = line[0] morning  revenue = morning * 200 + afternoon * 300 print(name, total, revenue)"], "perturbed_original": ["for i in range(9): name,a,b=list(input().split()) print(name,int(a)+int(b),int(a)*200+int(b)*300)"], "original_ll": -2.0616767406463623, "sampled_ll": -1.0973564386367798, "all_perturbed_sampled_ll": [-2.727607011795044], "all_perturbed_original_ll": [-2.4278290271759033], "perturbed_sampled_ll": -2.727607011795044, "perturbed_original_ll": -2.4278290271759033, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(a,b,c){for(a=b=0,getchar();(c=getchar())!='0';)if(c-'\\n')c=='A'?a++:b++;else{printf(\"%d %d\\n\",a>b?a+1:a,a<b?b+1:b),a=b=0;if(getchar()=='0')break;}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char record[101];\n    \n    while(1) {\n        if(scanf(\"%s\", record) != 1) break;\n        if(strcmp(record, \"0\") == 0) break;\n        \n        int len = strlen(record);\n        int scoreA = 0, scoreB = 0;\n        char lastServer = record[0];\n        \n        for(int i = 0; i < len; i++) {\n            if(record[i] != lastServer) {\n                // Server changed, so the previous server lost the point\n                if(lastServer == 'A') {\n                    scoreB++;\n                } else {\n                    scoreA++;\n                }\n                lastServer = record[i];\n            } else {\n                // Server stayed same, so server won the point\n                if(lastServer == 'A') {\n                    scoreA++;\n                } else {\n                    scoreB++;\n                }\n            }\n            \n            // Check if game ended\n            if(scoreA >= 11 || scoreB >= 11) {\n                if(scoreA >= 11 && scoreB >= 11) {\n                    if(scoreA - scoreB >= 2 || scoreB - scoreA >= 2) {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", scoreA, scoreB);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char  = 0, scoreB = 0; char lastServer = record[0]; for(int i = 0; i < len; i++) {  server lost the point if(lastServer == 'A') { scoreB++; } else { scoreA++; } lastServer =  won the point if(lastServer ==  Check if game ended if(scoreA >= 11 || scoreB >= 11) { if(scoreA >= 11 &&  scoreB - scoreA >= 2) { break; } } else {  0; }"], "perturbed_original": ["main(a,b,c){for(a=b=0,getchar();(c=getchar())!='0';)if(c-'\\n')c=='A'?a++:b++;else{printf(\"%d %d\\n\",a>b?a+1:a,a<b?b+1:b),a=b=0;if(getchar()=='0')break;}exit(0);}"], "original_ll": -2.0948312282562256, "sampled_ll": -0.7050204873085022, "all_perturbed_sampled_ll": [-2.063788414001465], "all_perturbed_original_ll": [-2.0948312282562256], "perturbed_sampled_ll": -2.063788414001465, "perturbed_original_ll": -2.0948312282562256, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main\n{\n    public static void main(String args[])\n    {\n\tScanner scan=new Scanner(System.in);\n\twhile(true)\n\t    {\n\t\tString str=scan.next();\n\t\tif(str.equals(\"0\"))break;\n\t\tint countA=0,countB=0;\n\t\tif(str.charAt(str.length()-1)=='A')\n\t\t    {\n\t\t\tcountA+=1;\n\t\t\t//countB-=1;\n\t\t    }\n\t\telse if(str.charAt(str.length()-1)=='B')\n\t\t    {\n\t\t    countB+=1;\n\t\t    //countA-=1;\n\t\t    }\n\t\tfor(int i=1;i<str.length();i++)\n\t\t    {\n\t\t\tif(str.charAt(i)=='A')countA+=1;\n\t\t\telse countB+=1;\n\t\t    }\n\t\tif(str.charAt(str.length()-1)=='B'&&(countB<countA))\n\t\t    {\n\t\t\tcountB-=1;\n\t\t\tcountA+=1;\n\t\t    }\n\t\telse if(str.charAt(str.length()-1)=='A'&&(countB>countA))\n\t\t    {\n\t\t\tcountA-=1;\n\t\t\tcountB+=1;\n\t\t    }\n\t\tSystem.out.println(countA+\" \"+countB);\n\t    }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String line = sc.nextLine();\n            if (line.equals(\"0\")) break;\n            \n            String game1 = line;\n            String game2 = sc.nextLine();\n            String game3 = sc.nextLine();\n            \n            System.out.println(processGame(game1));\n            System.out.println(processGame(game2));\n            System.out.println(processGame(game3));\n        }\n        \n        sc.close();\n    }\n    \n    static String processGame(String record) {\n        int scoreA = 0;\n        int scoreB = 0;\n        \n        for (int i = 0; i < record.length(); i++) {\n            char server = record.charAt(i);\n            \n            // The server who is recorded is the one who won the point\n            if (server == 'A') {\n                scoreA++;\n            } else {\n                scoreB++;\n            }\n            \n            // Check if game is over\n            if (scoreA >= 11 || scoreB >= 11) {\n                if (scoreA >= 10 && scoreB >= 10) {\n                    // Deuce situation - need 2 point difference\n                    if (Math.abs(scoreA - scoreB) >= 2) {\n                        break;\n                    }\n                } else {\n                    // Normal situation - first to 11\n                    if (scoreA >= 11 || scoreB >= 11) {\n                        break;\n                    }\n                }\n            }\n        }\n        \n        return scoreA + \" \" + scoreB;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc =  (line.equals(\"0\")) break; String game1 = line; String game2 = sc.nextLine(); String game3 = sc.nextLine(); System.out.println(processGame(game1)); System.out.println(processGame(game2)); System.out.println(processGame(game3));  = 0; int scoreB = 0; for (int i = 0; i < record.length(); i++) { char server = record.charAt(i); // The server who is recorded  'A') { scoreA++; } else { scoreB++; } // Check if game is over if (scoreA >= 11 || scoreB  10) { // Deuce   || scoreB >= 11) { break; } }  }"], "perturbed_original": ["import java.util.Scanner;  scan=new Scanner(System.in); while(true) { String str=scan.next();  { countB+=1; //countA-=1; } for(int i=1;i<str.length();i++) { if(str.charAt(i)=='A')countA+=1; else countB+=1; } if(str.charAt(str.length()-1)=='B'&&(countB<countA)) { countB-=1; countA+=1; } else if(str.charAt(str.length()-1)=='A'&&(countB>countA)) { countA-=1; countB+=1; } System.out.println(countA+\" \"+countB); } } }"], "original_ll": -0.6332377791404724, "sampled_ll": -0.7530702352523804, "all_perturbed_sampled_ll": [-1.883439064025879], "all_perturbed_original_ll": [-1.2549904584884644], "perturbed_sampled_ll": -1.883439064025879, "perturbed_original_ll": -1.2549904584884644, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    ten=input()\n    if ten=='0':\n        break\n    a=ten.count('A')\n    b=ten.count('B')\n    if ten[0]=='A':\n        a-=1\n    elif ten[0]=='B':\n        b-=1\n    if a>b:\n        a+=1\n    else:\n        b+=1\n    print(a,b)\n", "sampled": "import sys\n\ndef solve_game(record):\n    score_a = 0\n    score_b = 0\n    \n    i = 0\n    while i < len(record):\n        server = record[i]\n        \n        # Check if game is over\n        if score_a >= 11 or score_b >= 11:\n            if abs(score_a - score_b) >= 2:\n                break\n            elif score_a >= 11 and score_b >= 11:\n                if abs(score_a - score_b) >= 2:\n                    break\n        \n        # Determine who won the point\n        if i + 1 < len(record):\n            next_server = record[i + 1]\n            if next_server == server:\n                # Same server, so server won the point\n                if server == 'A':\n                    score_a += 1\n                else:\n                    score_b += 1\n            else:\n                # Different server, so server lost the point\n                if server == 'A':\n                    score_b += 1\n                else:\n                    score_a += 1\n        else:\n            # Last serve, determine winner based on current score\n            # The game must end after this serve\n            if score_a < 11 and score_b < 11:\n                # Someone needs to reach 11\n                if server == 'A':\n                    score_a += 1\n                else:\n                    score_b += 1\n            elif score_a >= 10 and score_b >= 10:\n                # In deuce, need 2 point difference\n                if server == 'A':\n                    if score_a == score_b or score_a == score_b + 1:\n                        score_a += 1\n                    else:\n                        score_b += 1\n                else:\n                    if score_b == score_a or score_b == score_a + 1:\n                        score_b += 1\n                    else:\n                        score_a += 1\n            else:\n                if server == 'A':\n                    score_a += 1\n                else:\n                    score_b += 1\n        \n        i += 1\n    \n    return score_a, score_b\n\nwhile True:\n    line = input().strip()\n    if line == \"0\":\n        break\n    \n    game1 = line\n    game2 = input().strip()\n    game3 = input().strip()\n    \n    score1 = solve_game(game1)\n    score2 = solve_game(game2)\n    score3 = solve_game(game3)\n    \n    print(f\"{score1[0]} {score1[1]}\")\n    print(f\"{score2[0]} {score2[1]}\")\n    print(f\"{score3[0]} {score3[1]}\")\n", "perturbed_sampled": ["import sys def solve_game(record): score_a =  len(record): server = record[i] # Check if game is over if score_a >= 11 or score_b >= 11: if abs(score_a -  >= 11: if abs(score_a - score_b) >= 2: break # Determine who won the point if i + 1 < len(record):  on current score # The  and score_b < 11: # Someone needs to reach 11 if server == 'A': score_a += 1 else:  10: # In deuce, need 2 point difference if server  + 1: score_a += 1 else: score_b += 1 else: if score_b  1 else: score_a += 1 else: if server  += 1 return score_a, score_b while True: line = input().strip() if line == \"0\": break game1 = line game2 = input().strip() game3 = input().strip() score1 = solve_game(game1) score2 = solve_game(game2) score3 = solve_game(game3) print(f\"{score1[0]} {score1[1]}\") print(f\"{score2[0]} {score2[1]}\") print(f\"{score3[0]} {score3[1]}\")"], "perturbed_original": ["while True: ten=input() if ten=='0': break  a+=1 else: b+=1 print(a,b)"], "original_ll": -1.0657331943511963, "sampled_ll": -0.6151260137557983, "all_perturbed_sampled_ll": [-1.790036916732788], "all_perturbed_original_ll": [-3.290694236755371], "perturbed_sampled_ll": -1.790036916732788, "perturbed_original_ll": -3.290694236755371, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\tint n,nbox[10000],temp,i,j,flg;\n\tscanf(\"%d\",&n);\n\twhile(n!=-1){\n\t\ttemp=0;\n\t\ti=0;\n\t\tflg=0;\n\t\twhile(n>=4){\n\t\t\tnbox[i]=n%4;\n\t\t\tn/=4;\n\t\t\ti++;\n\t\t}\n\t\tprintf(\"%d\",n);\n\t\tfor(j=i;j>=0;j--){\n\t\t\tif(flg==0){\n\t\t\t\tflg=1;\n\t\t\t}\n\t\t\telse if(flg==1){\n\t\t\t\tprintf(\"%d\",nbox[j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == -1) break;\n        \n        if(n == 0) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        char result[32];\n        int index = 0;\n        \n        while(n > 0) {\n            result[index++] = '0' + (n % 4);\n            n /= 4;\n        }\n        \n        for(int i = index - 1; i >= 0; i--) {\n            printf(\"%c\", result[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n;  0) { printf(\"0\\n\"); continue; } char result[32]; int index = 0; while(n > 0) { result[index++] = '0'  = index - 1;  return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int n,nbox[10000],temp,i,j,flg; scanf(\"%d\",&n); while(n!=-1){ temp=0; i=0; flg=0; while(n>=4){ nbox[i]=n%4; n/=4; i++; } printf(\"%d\",n); for(j=i;j>=0;j--){ if(flg==0){ flg=1; }  }"], "original_ll": -0.971454918384552, "sampled_ll": -0.5133338570594788, "all_perturbed_sampled_ll": [-2.0632877349853516], "all_perturbed_original_ll": [-1.6950057744979858], "perturbed_sampled_ll": -2.0632877349853516, "perturbed_original_ll": -1.6950057744979858, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n  public static void main (String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    while (scanner.hasNext()) {\n      int a = scanner.nextInt();\n      if (a < 0) {\n        break;\n      }\n      if (a == 0) {\n        System.out.println(0);\n        continue;\n      }\n      System.out.println(aaa(a));\n    }\n  }\n  public static String aaa (int a) {\n    if (a == 0) {\n      return \"\";\n    }\n    return aaa(a / 4) + a % 4;\n  }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == -1) break;\n            \n            if (n == 0) {\n                System.out.println(0);\n            } else {\n                StringBuilder result = new StringBuilder();\n                while (n > 0) {\n                    result.append(n % 4);\n                    n /= 4;\n                }\n                System.out.println(result.reverse().toString());\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc  { System.out.println(0); } else { StringBuilder result  4); n /= 4; } System.out.println(result.reverse().toString()); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main { public static  while (scanner.hasNext()) { int a = scanner.nextInt(); if (a < 0) { break; } if (a == 0) { System.out.println(0); continue; } System.out.println(aaa(a)); } } public static String  4; } }"], "original_ll": -0.7473354935646057, "sampled_ll": -0.5158214569091797, "all_perturbed_sampled_ll": [-2.334986448287964], "all_perturbed_original_ll": [-1.8297090530395508], "perturbed_sampled_ll": -2.334986448287964, "perturbed_original_ll": -1.8297090530395508, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from operator import add\nb2q = {\"00\":\"0\",\"01\":\"1\",\"10\":\"2\",\"11\":\"3\"}\nwhile True:\n    n = input()\n    if n == -1:\n        break\n    s = format(n,\"b\")\n    if len(s) % 2 == 1:\n        s = \"0\" + s\n    print \"\".join(map(b2q.get,map(add,s[::2],s[1::2])))", "sampled": "while True:\n    n = int(input())\n    if n == -1:\n        break\n    \n    if n == 0:\n        print(0)\n    else:\n        result = \"\"\n        while n > 0:\n            result = str(n % 4) + result\n            n //= 4\n        print(result)\n", "perturbed_sampled": ["while True: n = int(input()) if n == -1: break if n == 0: print(0) else: result = \"\" while n %4) result +=<extra_id_1>return result;<extra_id_2>else: print(n //= 4 print(result)"], "perturbed_original": ["from operator import add b2q = {\"00\":\"0\",\"01\":\"1\",\"10\":\"2\",\"11\":\"3\"} while True: n = input() if n == -1: break s = format(n,\"b\") if  print \"\".join(map(b2q.get,map(add,s[::2],s[1::2])))"], "original_ll": -1.2109355926513672, "sampled_ll": -0.8084076046943665, "all_perturbed_sampled_ll": [-3.069666624069214], "all_perturbed_original_ll": [-2.0599794387817383], "perturbed_sampled_ll": -3.069666624069214, "perturbed_original_ll": -2.0599794387817383, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,r,g,b,d,ans,best;\nchar col[8][15]={\"black\",\"blue\",\"lime\",\"aqua\",\"red\",\"fuchsia\",\"yellow\",\"white\"};\nchar code[24];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%s\",&code);\n\t\tif(code[0]=='0')break;\n\t\tsscanf(code,\"#%2x%2x%2x\",&r,&g,&b);\n\t\tbest=99999999;\n\t\tfor(i=0;i<8;i++){\n\t\t\td=(r-255*(i>3))*(r-255*(i>3))+(g-255*(i%4>1))*(g-255*(i%4>1))+(b-255*(i%2))*(b-255*(i%2));\n\t\t\tif(d<best){best=d;ans=i;}\n\t\t}\n\t\tprintf(\"%s\\n\",col[ans]);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char name[10];\n    int r, g, b;\n} Color;\n\nint main() {\n    Color colors[8] = {\n        {\"black\", 0x00, 0x00, 0x00},\n        {\"blue\", 0x00, 0x00, 0xff},\n        {\"lime\", 0x00, 0xff, 0x00},\n        {\"aqua\", 0x00, 0xff, 0xff},\n        {\"red\", 0xff, 0x00, 0x00},\n        {\"fuchsia\", 0xff, 0x00, 0xff},\n        {\"yellow\", 0xff, 0xff, 0x00},\n        {\"white\", 0xff, 0xff, 0xff}\n    };\n    \n    char input[10];\n    \n    while(1) {\n        scanf(\"%s\", input);\n        if(input[0] == '0') break;\n        \n        int r, g, b;\n        char rstr[3], gstr[3], bstr[3];\n        \n        rstr[0] = input[1];\n        rstr[1] = input[2];\n        rstr[2] = '\\0';\n        \n        gstr[0] = input[3];\n        gstr[1] = input[4];\n        gstr[2] = '\\0';\n        \n        bstr[0] = input[5];\n        bstr[1] = input[6];\n        bstr[2] = '\\0';\n        \n        r = strtol(rstr, NULL, 16);\n        g = strtol(gstr, NULL, 16);\n        b = strtol(bstr, NULL, 16);\n        \n        int minDist = -1;\n        int minIdx = 0;\n        \n        for(int i = 0; i < 8; i++) {\n            int dr = r - colors[i].r;\n            int dg = g - colors[i].g;\n            int db = b - colors[i].b;\n            int dist = dr*dr + dg*dg + db*db;\n            \n            if(minDist == -1 || dist < minDist) {\n                minDist = dist;\n                minIdx = i;\n            }\n        }\n        \n        printf(\"%s\\n\", colors[minIdx].name);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> typedef struct { char name[10]; int r, g, ; }<extra_id_5>if((0x00)>>i);<extra_id_6>}<extra_id_7>==<extra_id_8>else if<extra_id_9>==<extra_id_10>; char<extra_id_11>)<extra_id_12>// d1 ><extra_id_13>+<extra_id_14>+ ((i>>2) &<extra_id_15>) + (<extra_id_16>1))<extra_id_17>+ ((1 - (1<extra_id_18>-<extra_id_19>+ ( 1<extra_id_20>= i<extra_id_21>< d 0x00, 0xff, 0x00},  0x00,  break; int r, g, b; char rstr[3], gstr[3], bstr[3]; rstr[0] = input[1]; rstr[1] = input[2]; rstr[2] = '\\0'; gstr[0] = input[3]; gstr[1] = input[4]; gstr[2] =  r = strtol(rstr, NULL, 16); g = strtol(gstr, NULL, 16); b = strtol(bstr, NULL, 16); int minDist = -1; int minIdx = 0; for(int i = 0; i < 8; i++) {   = dr*dr + dg*dg + db*db; if(minDist == -1 || dist < minDist) {  } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int i,r,g,b,d,ans,best; char  for(i=0;i<8;i++){ d=(r-255*(i>3))*(r-255*(i>3))+(g-255*(i%4>1))*(g-255*(i%4>1))+(b-255*(i%2))*(b-255*(i%2)); if(d<best){best=d;ans=i;} } printf(\"%s\\n\",col[ans]); } return 0; }"], "original_ll": -0.9573379158973694, "sampled_ll": -0.32129162549972534, "all_perturbed_sampled_ll": [-1.6133394241333008], "all_perturbed_original_ll": [-1.334506869316101], "perturbed_sampled_ll": -1.6133394241333008, "perturbed_original_ll": -1.334506869316101, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nimport java.util.HashMap;\nimport java.util.Arrays;\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[\\n#]+\");\n\t\twhile (true)\n\t\t{\n\t\t\tString str = sc.next();\n\t\t\tif (str.equals(\"0\")) break;\n\t\t\tint rk = Integer.parseInt(str.substring(0, 2), 16);\n\t\t\tint gk = Integer.parseInt(str.substring(2, 4), 16);\n\t\t\tint bk = Integer.parseInt(str.substring(4, 6), 16);\n\t\t\tint d[] = new int[8];\n\t\t\tHashMap<Integer, String> map = new HashMap<Integer, String>();\n\t\t\td[0] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[0], \"black\");\n\t\t\td[1] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[1], \"blue\");\n\t\t\td[2] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[2], \"lime\");\n\t\t\td[3] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[3], \"aqua\");\n\t\t\td[4] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[4], \"red\");\n\t\t\td[5] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[5], \"fuchsia\");\n\t\t\td[6] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[6], \"yellow\");\n\t\t\td[7] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[7], \"white\");\n\t\t\tArrays.sort(d);\n\t\t\tSystem.out.println(map.get(d[0]));\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        String[] colorNames = {\"black\", \"blue\", \"lime\", \"aqua\", \"red\", \"fuchsia\", \"yellow\", \"white\"};\n        int[][] colorValues = {\n            {0x00, 0x00, 0x00},  // black\n            {0x00, 0x00, 0xff},  // blue\n            {0x00, 0xff, 0x00},  // lime\n            {0x00, 0xff, 0xff},  // aqua\n            {0xff, 0x00, 0x00},  // red\n            {0xff, 0x00, 0xff},  // fuchsia\n            {0xff, 0xff, 0x00},  // yellow\n            {0xff, 0xff, 0xff}   // white\n        };\n        \n        while (true) {\n            String input = sc.next();\n            if (input.equals(\"0\")) {\n                break;\n            }\n            \n            // Parse color code\n            String colorCode = input.substring(1); // Remove '#'\n            int r = Integer.parseInt(colorCode.substring(0, 2), 16);\n            int g = Integer.parseInt(colorCode.substring(2, 4), 16);\n            int b = Integer.parseInt(colorCode.substring(4, 6), 16);\n            \n            // Find closest color\n            int minDistance = Integer.MAX_VALUE;\n            String closestColor = \"\";\n            \n            for (int i = 0; i < colorNames.length; i++) {\n                int rk = colorValues[i][0];\n                int gk = colorValues[i][1];\n                int bk = colorValues[i][2];\n                \n                int distance = (r - rk) * (r - rk) + (g - gk) * (g - gk) + (b - bk) * (b - bk);\n                \n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestColor = colorNames[i];\n                }\n            }\n            \n            System.out.println(closestColor);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  =  \"fuchsia\", \"yellow\", \"white\"}; int[][] colorValues = { {0x00, 0x00, 0x00}, // black {0x00, 0x00, 0xff}, // blue {0x00, 0xff, 0x00}, // lime {0x00, 0xff, 0xff}, // aqua {0xff, 0x00, 0x00}, // red {0xff, 0x00, 0xff}, // fuchsia {0xff, 0xff, 0x00}, // yellow {0xff, 0xff, 0xff}  if (input.equals(\"0\")) { break; } // Parse color code String colorCode = input.substring(1); // Remove '#' int r = Integer.parseInt(colorCode.substring(0, 2), 16);  6), 16); // Find closest color int minDistance = Integer.MAX_VALUE; String closestColor = \"\"; for  rk = colorValues[i][0];  minDistance) { minDistance = distance; closestColor = colorNames[i]; } } System.out.println(closestColor); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; import java.util.HashMap;  { Scanner sc = new Scanner(System.in).useDelimiter(\"[\\n#]+\"); while (true)  = Integer.parseInt(str.substring(0, 2), 16); int gk = Integer.parseInt(str.substring(2, 4), 16); int bk = Integer.parseInt(str.substring(4, 6), 16); int d[] = new int[8]; HashMap<Integer, String> map = new HashMap<Integer, String>(); d[0] = (0x00 - rk) * (0x00 - rk) + (0x00  * (0x00 - bk); map.put(d[0], \"black\"); d[1] = (0x00 - rk) * (0x00 - rk) + (0x00 - gk) * (0x00 - gk) + (0xff - bk) * (0xff -  - rk) + (0xff - gk) * (0xff - gk)  d[3] = (0x00 - rk) * (0x00 - rk) + (0xff - gk)  * (0xff -  d[5] = (0xff - rk) * (0xff - rk) + (0x00  -  - bk); map.put(d[6], \"yellow\"); d[7] =  gk) * (0xff - gk) + (0xff - bk) * (0xff - bk); map.put(d[7], \"white\"); Arrays.sort(d); System.out.println(map.get(d[0])); } } }"], "original_ll": -0.302490234375, "sampled_ll": -0.32647931575775146, "all_perturbed_sampled_ll": [-1.2523562908172607], "all_perturbed_original_ll": [-1.1717898845672607], "perturbed_sampled_ll": -1.2523562908172607, "perturbed_original_ll": -1.1717898845672607, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nL=[\n(\"black\",00,00,00),\n(\"blue\",00,00,255),\n(\"lime\",00,255,00),\n(\"aqua\",00,255,255),\n(\"red\",255,00,00),\n(\"fuchsia\",255,00,255),\n(\"yellow\",255,255,00),\n(\"white\",255,255,255)]\nwhile True:\n    c=raw_input()\n    if c==\"0\":break\n    Rk,Gk,Bk=int(c[1:3],16),int(c[3:5],16),int(c[5:7],16)\n    m=10000\n    for cl,r,g,b in L:\n        t=math.sqrt(pow(r-Rk,2)+pow(g-Gk,2)+pow(b-Bk,2))\n        if t<m:\n            m=t\n            color=cl\n    print color", "sampled": "import sys\n\ncolors = [\n    (\"black\", 0x00, 0x00, 0x00),\n    (\"blue\", 0x00, 0x00, 0xff),\n    (\"lime\", 0x00, 0xff, 0x00),\n    (\"aqua\", 0x00, 0xff, 0xff),\n    (\"red\", 0xff, 0x00, 0x00),\n    (\"fuchsia\", 0xff, 0x00, 0xff),\n    (\"yellow\", 0xff, 0xff, 0x00),\n    (\"white\", 0xff, 0xff, 0xff)\n]\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line == \"0\":\n        break\n    \n    # Parse color code\n    color_code = line[1:]  # Remove #\n    R = int(color_code[0:2], 16)\n    G = int(color_code[2:4], 16)\n    B = int(color_code[4:6], 16)\n    \n    # Find closest color\n    min_distance = float('inf')\n    closest_color = \"\"\n    \n    for name, Rk, Gk, Bk in colors:\n        dk = (R - Rk) ** 2 + (G - Gk) ** 2 + (B - Bk) ** 2\n        if dk < min_distance:\n            min_distance = dk\n            closest_color = name\n    \n    print(closest_color)\n", "perturbed_sampled": ["import sys  0xff), (\"lime\", 0x00, 0xff, 0x00), (\"aqua\", 0x00, 0xff, 0xff), (\"red\", 0xff, 0x00, 0x00), (\"fuchsia\", 0xff, 0x00, 0xff), (\"yellow\", 0xff, 0xff, 0x00), (\"white\", 0xff, 0xff, 0xff) ] for line in sys.stdin: line =  16) G = int(color_code[2:4], 16) B = int(color_code[4:6], 16) # Find closest   2 + (G - Gk) ** 2 + (B - Bk) ** 2 if dk < min_distance: min_distance = dk closest_color = name print(closest_color)"], "perturbed_original": ["import math L=[ (\"black\",00,00,00), (\"blue\",00,00,255),  c==\"0\":break Rk,Gk,Bk=int(c[1:3],16),int(c[3:5],16),int(c[5:7],16) m=10000 for cl,r,g,b in L: t=math.sqrt(pow(r-Rk,2)+pow(g-Gk,2)+pow(b-Bk,2)) if t<m: m=t color=cl print color"], "original_ll": -0.8049091100692749, "sampled_ll": -0.45110130310058594, "all_perturbed_sampled_ll": [-1.2822633981704712], "all_perturbed_original_ll": [-1.764669418334961], "perturbed_sampled_ll": -1.2822633981704712, "perturbed_original_ll": -1.764669418334961, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n#define PI 3.141592653589793\n#define r 6378.1\nint main(void) {\n\twhile(1){\n\t\tdouble a,b,c,d;\n\t\tscanf(\"%lf %lf %lf %lf\\n\",&a,&b,&c,&d);\n\t\tif(a==(-1)&&b==(-1)&&c==(-1)&&d==(-1)) break;\n\t\tdouble a1,b1,c1,d1;\n\t\ta1=a*PI/180.0;\n\t\tb1=b*PI/180.0;\n\t\tc1=c*PI/180.0;\n\t\td1=d*PI/180.0;\n\t\tdouble e1,f;\n\t\te1=d1-b1;\n\t\tf=r*acos((sin(a1)*sin(c1))+(cos(a1)*cos(c1)*cos(e1)));\n\t\tprintf(\"%.0f\\n\",f);\n\t}\n\treturn 0;\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159265358979323846\n#define RADIUS 6378.1\n\nint main() {\n    double a, b, c, d;\n    \n    while (1) {\n        scanf(\"%lf %lf %lf %lf\", &a, &b, &c, &d);\n        \n        if (a == -1 && b == -1 && c == -1 && d == -1) {\n            break;\n        }\n        \n        double lat1 = a * PI / 180.0;\n        double lon1 = b * PI / 180.0;\n        double lat2 = c * PI / 180.0;\n        double lon2 = d * PI / 180.0;\n        \n        double x1 = RADIUS * cos(lat1) * cos(lon1);\n        double y1 = RADIUS * cos(lat1) * sin(lon1);\n        double z1 = RADIUS * sin(lat1);\n        \n        double x2 = RADIUS * cos(lat2) * cos(lon2);\n        double y2 = RADIUS * cos(lat2) * sin(lon2);\n        double z2 = RADIUS * sin(lat2);\n        \n        double chord = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1));\n        \n        double angle = 2.0 * asin(chord / (2.0 * RADIUS));\n        \n        double distance = RADIUS * angle;\n        \n        int result = (int)(distance + 0.5);\n        \n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #define PI 3.14159265358979323846 #define RADIUS 6378.1 int main() { double a, b, c, d;   } double lat1 = a * PI / 180.0; double lon1 = b * PI / 180.0; double lat2  * PI / 180.0;  = RADIUS * cos(lat1) * sin(lon1); double z1 = RADIUS * sin(lat1); double x2  * cos(lat2) * sin(lon2); double  (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1)); double angle = 2.0 * asin(chord / (2.0 * RADIUS)); double distance = RADIUS * angle;  0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> #define PI 3.141592653589793 #define r 6378.1 int main(void)  double a1,b1,c1,d1; a1=a*PI/180.0; b1=b*PI/180.0; c1=c*PI/180.0; d1=d*PI/180.0; double e1,f; e1=d1-b1; f=r*acos((sin(a1)*sin(c1))+(cos(a1)*cos(c1)*cos(e1))); printf(\"%.0f\\n\",f); } return 0; }"], "original_ll": -0.6682618856430054, "sampled_ll": -0.34773340821266174, "all_perturbed_sampled_ll": [-1.4459165334701538], "all_perturbed_original_ll": [-1.039674997329712], "perturbed_sampled_ll": -1.4459165334701538, "perturbed_original_ll": -1.039674997329712, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tdouble c = sc.nextDouble();\n\t\t\tdouble d = sc.nextDouble();\n\t\t\tif((a==-1)&&(b==-1)&&(c==-1)&&(d==-1)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdouble vz = Math.sin(Math.toRadians(a));\n\t\t\tdouble vx = Math.cos(Math.toRadians(a))*Math.cos(Math.toRadians(b));\n\t\t\tdouble vy = Math.cos(Math.toRadians(a))*Math.sin(Math.toRadians(b));\n\n\t\t\tdouble wz = Math.sin(Math.toRadians(c));\n\t\t\tdouble wx = Math.cos(Math.toRadians(c))*Math.cos(Math.toRadians(d));\n\t\t\tdouble wy = Math.cos(Math.toRadians(c))*Math.sin(Math.toRadians(d));\n\n\t\t\tdouble dot = vz*wz + vx*wx + vy * wy;\n\t\t\tdouble theta = Math.acos(dot);\n\t\t\tdouble R =6378.1;\n\t\t\tSystem.out.println((int)(R*theta+0.5));\n\t\t}\n\t\t\n\t}\n\tpublic static void main(String[] args){\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            double a = sc.nextDouble();\n            double b = sc.nextDouble();\n            double c = sc.nextDouble();\n            double d = sc.nextDouble();\n            \n            if (a == -1 && b == -1 && c == -1 && d == -1) {\n                break;\n            }\n            \n            double lat1 = Math.toRadians(a);\n            double lon1 = Math.toRadians(b);\n            double lat2 = Math.toRadians(c);\n            double lon2 = Math.toRadians(d);\n            \n            double radius = 6378.1;\n            \n            double centralAngle = Math.acos(\n                Math.sin(lat1) * Math.sin(lat2) + \n                Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1)\n            );\n            \n            double distance = radius * centralAngle;\n            \n            long result = Math.round(distance);\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { double  d == -1)  Math.toRadians(b); double lat2 = Math.toRadians(c); double  Math.acos( Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1) ); double distance = radius * centralAngle; long result = Math.round(distance); System.out.println(result); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.lang.*; import  void run(){ for(;;){ double a = sc.nextDouble(); double b = sc.nextDouble(); double c = sc.nextDouble(); double d = sc.nextDouble(); if((a==-1)&&(b==-1)&&(c==-1)&&(d==-1)){ break; }  Math.cos(Math.toRadians(c))*Math.cos(Math.toRadians(d)); double wy = Math.cos(Math.toRadians(c))*Math.sin(Math.toRadians(d)); double dot = vz*wz + vx*wx + vy * wy; double theta = Math.acos(dot); double R =6378.1; System.out.println((int)(R*theta+0.5));  new Main(); m.run(); } }"], "original_ll": -0.8178650736808777, "sampled_ll": -0.46055564284324646, "all_perturbed_sampled_ll": [-1.5359758138656616], "all_perturbed_original_ll": [-1.8981189727783203], "perturbed_sampled_ll": -1.5359758138656616, "perturbed_original_ll": -1.8981189727783203, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from math import acos,sin,cos,radians\nwhile 1:\n    a,b,c,d=map(float,input().split())\n    if a==b==c==d==-1:break\n    a,c=radians(a),radians(c)\n    print(int(6378.1*acos(sin(a)*sin(c) + cos(a)*cos(c)*cos(radians(d)-radians(b)))+0.5))", "sampled": "import math\n\nR = 6378.1\n\nwhile True:\n    line = input().split()\n    a, b, c, d = map(float, line)\n    \n    if a == -1 and b == -1 and c == -1 and d == -1:\n        break\n    \n    # Convert degrees to radians\n    lat1 = math.radians(a)\n    lon1 = math.radians(b)\n    lat2 = math.radians(c)\n    lon2 = math.radians(d)\n    \n    # Calculate great circle distance using spherical law of cosines\n    # or using haversine formula for better numerical stability\n    \n    # Using spherical law of cosines:\n    # d = R * arccos(sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2)*cos(lon2-lon1))\n    \n    cos_angle = math.sin(lat1) * math.sin(lat2) + math.cos(lat1) * math.cos(lat2) * math.cos(lon2 - lon1)\n    \n    # Clamp to [-1, 1] to avoid numerical errors\n    cos_angle = max(-1, min(1, cos_angle))\n    \n    angle = math.acos(cos_angle)\n    distance = R * angle\n    \n    print(round(distance))\n", "perturbed_sampled": ["import math R = 6378.1 while  line) if a == -1 and b == -1 and c == -1 and d == -1: break # Convert  = math.radians(c) lon2 =  stability # Using  + cos(lat1)*cos(lat2)*cos(lon2-lon1)) cos_angle = math.sin(lat1) * math.sin(lat2) + math.cos(lat1)  1] to avoid numerical errors cos_angle = max(-1, min(1, cos_angle)) angle = math.acos(cos_angle) distance = R * angle print(round(distance))"], "perturbed_original": ["from math import acos,sin,cos,radians while 1: a,b,c,d=map(float,input().split()) if a==b==c==d==-1:break a,c=radians(a),radians(c) print(int(6378.1*acos(sin(a)*sin(c) + cos(a)*cos(c)*cos(radians(d)-radians(b)))+0.5))"], "original_ll": -1.4473483562469482, "sampled_ll": -0.7234416604042053, "all_perturbed_sampled_ll": [-2.397862672805786], "all_perturbed_original_ll": [-1.6759307384490967], "perturbed_sampled_ll": -2.397862672805786, "perturbed_original_ll": -1.6759307384490967, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,d,p,q,m[9999],h;main(b){for(;~scanf(\"%d\",&n),n;d&&printf(\"%d\\n\",p)){for(memset(m,d=0,39996);n--;){scanf(\"%d%d%d\",&d,&p,&q);b=(d-2?~-(1<<p):1)<<q;for(h=9998;~h&&!(m[h]&b);h--)d-2?p=1:0;for(h++;p--;m[h]-62?h++:memmove(m+h,m+h+1,9998-h))m[h]|=b;}for(p=0,h=9999;h--;)for(b=m[h];q=-b&b;b-=q)p++;}}", "sampled": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_HEIGHT 10000\n#define WIDTH 5\n\nint grid[MAX_HEIGHT][WIDTH];\n\nint getHeight(int col) {\n    int h = 0;\n    for (int i = 0; i < MAX_HEIGHT; i++) {\n        if (grid[i][col] == 1) {\n            h = i + 1;\n        }\n    }\n    return h;\n}\n\nvoid dropBlock(int d, int p, int q) {\n    q--; // Convert to 0-indexed\n    \n    if (d == 1) { // Horizontal\n        // Find the highest point where the block can land\n        int maxHeight = 0;\n        for (int i = 0; i < p; i++) {\n            int h = getHeight(q + i);\n            if (h > maxHeight) {\n                maxHeight = h;\n            }\n        }\n        // Place the block\n        for (int i = 0; i < p; i++) {\n            grid[maxHeight][q + i] = 1;\n        }\n    } else { // Vertical (d == 2)\n        int h = getHeight(q);\n        // Place the block\n        for (int i = 0; i < p; i++) {\n            grid[h + i][q] = 1;\n        }\n    }\n}\n\nvoid removeFullRows() {\n    int removed = 0;\n    for (int row = 0; row < MAX_HEIGHT; row++) {\n        int full = 1;\n        for (int col = 0; col < WIDTH; col++) {\n            if (grid[row][col] == 0) {\n                full = 0;\n                break;\n            }\n        }\n        if (full) {\n            // Mark row for removal\n            for (int col = 0; col < WIDTH; col++) {\n                grid[row][col] = 0;\n            }\n            // Shift everything above down\n            for (int r = row; r < MAX_HEIGHT - 1; r++) {\n                for (int col = 0; col < WIDTH; col++) {\n                    grid[r][col] = grid[r + 1][col];\n                }\n            }\n            for (int col = 0; col < WIDTH; col++) {\n                grid[MAX_HEIGHT - 1][col] = 0;\n            }\n            row--; // Check this row again\n        }\n    }\n}\n\nint countBlocks() {\n    int count = 0;\n    for (int i = 0; i < MAX_HEIGHT; i++) {\n        for (int j = 0; j < WIDTH; j++) {\n            if (grid[i][j] == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        // Clear the grid\n        memset(grid, 0, sizeof(grid));\n        \n        for (int i = 0; i < n; i++) {\n            int d, p, q;\n            scanf(\"%d %d %d\", &d, &p, &q);\n            dropBlock(d, p, q);\n            removeFullRows();\n        }\n        \n        printf(\"%d\\n\", countBlocks());\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #define MAX_HEIGHT  int h = 0; for (int i = 0; i < MAX_HEIGHT; i++) { if (grid[i][col] == 1) { h = i + 1; } } return h; } void dropBlock(int  0-indexed if (d == 1) { // Horizontal // Find the highest point where the block can land int maxHeight = 0; for (int i  getHeight(q +  0;  } } else { // Vertical (d == 2) int h = getHeight(q); // Place the block for (int i =  1; } } } void removeFullRows() { int removed = 0; for (int row = 0; row < MAX_HEIGHT; row++) { int full = 1; for (int col = 0; col <  row for removal for (int col = 0; col < WIDTH; col++)  for (int r = row; r < MAX_HEIGHT - 1; r++) {  col = 0; col < WIDTH; col++) { grid[MAX_HEIGHT  again } } } int countBlocks() { int count  i++) { for (int j = 0; j < WIDTH; j++) { if (grid[i][j] == 1) { count++; } }  (scanf(\"%d\", &n) == 1 && n != 0) { // Clear   } printf(\"%d\\n\", countBlocks()); } return 0; }"], "perturbed_original": ["n,d,p,q,m[9999],h;main(b){for(;~scanf(\"%d\",&n),n;d&&printf(\"%d\\n\",p)){for(memset(m,d=0,39996);n--;){scanf(\"%d%d%d\",&d,&p,&q);b=(d-2?~-(1<<p):1)<<q;for(h=9998;~h&&!(m[h]&b);h--)d-2?p=1:0;for(h++;p--;m[h]-62?h++:memmove(m+h,m+h+1,9998-h))m[h]|=b;}for(p=0,h=9999;h--;)for(b=m[h];q=-b&b;b-=q)p++;}}"], "original_ll": -2.433109760284424, "sampled_ll": -0.4530812203884125, "all_perturbed_sampled_ll": [-1.8206957578659058], "all_perturbed_original_ll": [-2.433109760284424], "perturbed_sampled_ll": -1.8206957578659058, "perturbed_original_ll": -2.433109760284424, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n//TETORIS\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tboolean[][] m = new boolean[5000][5];\n\t\t\twhile(n--!=0){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt()-1;\n\t\t\t\tif(d==2){\n\t\t\t\t\tint k = 4999;\n\t\t\t\t\twhile(k>=0&&!m[k][q])k--;\n\t\t\t\t\tk++;\n\t\t\t\t\tfor(int i=k;i<k+p;i++)m[i][q]=true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint k = 4999;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tif(k>=0){\n\t\t\t\t\t\t\tfor(int j=q;j<q+p;j++){\n\t\t\t\t\t\t\t\tif(m[k][j])f = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f||k==-1){\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\tfor(int j=q;j<q+p;j++)m[k][j]=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean con = true;\n\t\t\t\tint k = 0;\n\t\t\t\twhile(k<5000&&con){\n\t\t\t\t\tcon = false;\n\t\t\t\t\tboolean t = true;\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tif(m[k][j])con = true;\n\t\t\t\t\t\telse t = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(t){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tint i = k;\n\t\t\t\t\t\twhile(i<5000&&f){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\t\tif(m[i][j])f = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\t\t\tm[i][j] = m[i+1][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse k++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint s = 0;\n\t\t\tfor(int i=0;i<5000;i++)for(int j=0;j<5;j++)s+=m[i][j]?1:0;\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[][] board = new int[10000][5];\n            int maxHeight = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt() - 1;\n                \n                if (d == 1) {\n                    int dropHeight = 0;\n                    for (int col = q; col < q + p; col++) {\n                        for (int row = 0; row < 10000; row++) {\n                            if (board[row][col] == 1) {\n                                dropHeight = Math.max(dropHeight, row + 1);\n                                break;\n                            }\n                        }\n                    }\n                    \n                    for (int col = q; col < q + p; col++) {\n                        board[dropHeight][col] = 1;\n                    }\n                    maxHeight = Math.max(maxHeight, dropHeight + 1);\n                } else {\n                    int dropHeight = 0;\n                    for (int row = 0; row < 10000; row++) {\n                        if (board[row][q] == 1) {\n                            dropHeight = row + 1;\n                            break;\n                        }\n                    }\n                    \n                    for (int row = dropHeight; row < dropHeight + p; row++) {\n                        board[row][q] = 1;\n                    }\n                    maxHeight = Math.max(maxHeight, dropHeight + p);\n                }\n                \n                boolean cleared = true;\n                while (cleared) {\n                    cleared = false;\n                    for (int row = 0; row < maxHeight; row++) {\n                        boolean full = true;\n                        for (int col = 0; col < 5; col++) {\n                            if (board[row][col] == 0) {\n                                full = false;\n                                break;\n                            }\n                        }\n                        \n                        if (full) {\n                            cleared = true;\n                            for (int r = row; r < maxHeight - 1; r++) {\n                                for (int col = 0; col < 5; col++) {\n                                    board[r][col] = board[r + 1][col];\n                                }\n                            }\n                            for (int col = 0; col < 5; col++) {\n                                board[maxHeight - 1][col] = 0;\n                            }\n                            maxHeight--;\n                            break;\n                        }\n                    }\n                }\n            }\n            \n            int count = 0;\n            for (int row = 0; row < maxHeight; row++) {\n                for (int col = 0; col < 5; col++) {\n                    if (board[row][col] == 1) {\n                        count++;\n                    }\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  d = sc.nextInt(); int  (d == 1) { int dropHeight =  p; col++) { for (int row  1) { dropHeight = Math.max(dropHeight, row + 1); break; } } } for (int col = q; col < q + p; col++) { board[dropHeight][col] = 1; } maxHeight = Math.max(maxHeight, dropHeight + 1); } else { int dropHeight = 0; for (int row   for (int row  = 1; } maxHeight = Math.max(maxHeight,  { cleared = false; for (int row = 0; row < maxHeight; row++) { boolean full = true; for (int col = 0; col < 5; col++) { if (board[row][col] == 0) { full = false; break; } } if (full) { cleared =  1; r++) { for (int col = 0; col  } for (int col = 0; col < 5; col++) { board[maxHeight - 1][col] = 0; } maxHeight--; break; } }   0; col < 5; col++) { if (board[row][col] == 1) { count++; } } } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; //TETORIS public class Main {  Scanner(System.in); while(true){ int n = sc.nextInt(); if(n==0)break; boolean[][] m = new boolean[5000][5]; while(n--!=0){  = sc.nextInt()-1; if(d==2){ int k = 4999; while(k>=0&&!m[k][q])k--; k++; for(int i=k;i<k+p;i++)m[i][q]=true; } else{ int k = 4999; while(true){ boolean  } boolean con = true; int k = 0; while(k<5000&&con){ con = false; boolean t = true; for(int j=0;j<5;j++){ if(m[k][j])con = true; else t = false; } if(t){ boolean f = true; int i  true; } if(f){ for(int j=0;j<5;j++){ m[i][j]  } } }"], "original_ll": -0.6547034382820129, "sampled_ll": -0.35905274748802185, "all_perturbed_sampled_ll": [-1.5777379274368286], "all_perturbed_original_ll": [-1.8017657995224], "perturbed_sampled_ll": -1.5777379274368286, "perturbed_original_ll": -1.8017657995224, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#!/usr/local/bin/python\nfrom itertools import islice\n\ndef init():\n    return [[None] * 5] * 5000\n\nN = 4\n\nwhile True:\n    #N = int(input())\n    if N == 0:\n        break\n    d, l, pos = [int(n) for n in raw_input().split()]\n    lst = init()\n    flwr = 0\n    for i in xrange(N):\n        print d, l, pos\n        # if d == 1:\n        #     for i in xrange(l):\n        #         lst[flwr][pos-1 + i] = 1\n        # else:\n        #     tmp = 0\n        #     for i in xrange(l):\n        #         lst[flwr + tmp][pos-1] = 1\n        #         tmp += 1\n        #print lst[flwr]\n        #print not None in lst[flwr]\n        if not None in lst[flwr]:\n            flwr += 1\n    ret = 0\n    for i in xrange(flwr):\n        ret += len([i for i in lst[i] if not None])\n    #print ret\n    N -= 1\n    break", "sampled": "def solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        # Board: 5 columns, use a list to store heights at each column\n        # We'll use a grid representation where grid[row][col] tells if there's a block\n        grid = []  # Will grow as needed, grid[0] is bottom\n        \n        for _ in range(n):\n            d, p, q = map(int, input().split())\n            q -= 1  # Convert to 0-indexed\n            \n            if d == 1:  # Horizontal block\n                # Find the maximum height among columns q to q+p-1\n                max_height = 0\n                for col in range(q, q + p):\n                    # Find height of column col\n                    h = 0\n                    for row in range(len(grid)):\n                        if grid[row][col]:\n                            h = row + 1\n                    max_height = max(max_height, h)\n                \n                # Place block at row max_height\n                while len(grid) <= max_height:\n                    grid.append([False] * 5)\n                \n                for col in range(q, q + p):\n                    grid[max_height][col] = True\n                    \n            else:  # Vertical block (d == 2)\n                # Find height of column q\n                height = 0\n                for row in range(len(grid)):\n                    if grid[row][q]:\n                        height = row + 1\n                \n                # Place block from row height to height+p-1\n                while len(grid) < height + p:\n                    grid.append([False] * 5)\n                \n                for row in range(height, height + p):\n                    grid[row][q] = True\n            \n            # Check for complete rows and remove them\n            rows_to_remove = []\n            for row_idx in range(len(grid)):\n                if all(grid[row_idx]):\n                    rows_to_remove.append(row_idx)\n            \n            # Remove complete rows (from top to bottom to maintain indices)\n            for row_idx in reversed(rows_to_remove):\n                grid.pop(row_idx)\n        \n        # Count remaining blocks\n        count = 0\n        for row in grid:\n            count += sum(row)\n        \n        print(count)\n\nsolve()\n", "perturbed_sampled": ["def solve(): while  Board: 5 columns, use a list to store heights at each column # We'll use a grid representation where grid[row][col] tells if  needed, grid[0] is bottom for _ in range(n): d, p,  0-indexed if d == 1: # Horizontal block # Find the  for col in range(q, q + p):  row max_height while len(grid) <= max_height: grid.append([False] *  Find height of column q height = 0 for row in range(len(grid)): if grid[row][q]: height = row + 1 # Place block from row height to height+p-1 while  in range(height, height + p): grid[row][q] = True # Check for complete rows and remove them rows_to_remove = [] for row_idx in range(len(grid)):  bottom to maintain indices) for  0 for row in grid: count += sum(row) print(count) solve()"], "perturbed_original": ["#!/usr/local/bin/python from itertools import islice def init(): return [[None] * 5] * 5000 N = 4 while  print d, l, pos # if d == 1: # for i  # tmp = 0 # for i in xrange(l): # lst[flwr + tmp][pos-1] = 1 # tmp += 1 #print lst[flwr] #print not None in lst[flwr] if not None in lst[flwr]: flwr +=  ret N -= 1 break"], "original_ll": -1.2951571941375732, "sampled_ll": -0.9075080752372742, "all_perturbed_sampled_ll": [-2.9455325603485107], "all_perturbed_original_ll": [-2.8188984394073486], "perturbed_sampled_ll": -2.9455325603485107, "perturbed_original_ll": -2.8188984394073486, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\nchar chk[MAX+10];\nint Q[MAX+10], *top, *end, *qmax = Q + MAX;\nint N, K, mask;\n\nint nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b, step;\n\tint i, k;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) | k;\n\t\t}\n\t\tmask = (1 << N) - 1, r = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;\n\t\ttop = end = Q;\n\t\t*end++ = s, *end++ = -1, chk[s] = 1, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = *top; if (++top >= qmax) top = Q;\n\t\t\tif (s < 0) { step++, *end = -1; if (++end >= qmax) end = Q; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); break; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2, k2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n\t\t\t\tif (!chk[s2]) { chk[s2] = 1, *end = s2; if (++end >= qmax) end = Q; }\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LEN 11\n#define MAX_QUEUE 100000\n\ntypedef struct {\n    char state[MAX_LEN];\n    int steps;\n} QueueItem;\n\ntypedef struct {\n    char state[MAX_LEN];\n} HashItem;\n\nHashItem visited[MAX_QUEUE];\nint visited_count;\n\nint hash_string(char* s) {\n    int h = 0;\n    for (int i = 0; s[i]; i++) {\n        h = h * 31 + s[i];\n    }\n    return abs(h) % MAX_QUEUE;\n}\n\nint is_visited(char* s) {\n    for (int i = 0; i < visited_count; i++) {\n        if (strcmp(visited[i].state, s) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add_visited(char* s) {\n    strcpy(visited[visited_count].state, s);\n    visited_count++;\n}\n\nint is_uniform(char* s) {\n    char first = s[0];\n    for (int i = 1; s[i]; i++) {\n        if (s[i] != first) return 0;\n    }\n    return 1;\n}\n\nchar get_third_color(char a, char b) {\n    if ((a == 'r' && b == 'g') || (a == 'g' && b == 'r')) return 'b';\n    if ((a == 'r' && b == 'b') || (a == 'b' && b == 'r')) return 'g';\n    if ((a == 'g' && b == 'b') || (a == 'b' && b == 'g')) return 'r';\n    return a;\n}\n\nint solve(char* initial) {\n    if (is_uniform(initial)) return 0;\n    \n    QueueItem queue[MAX_QUEUE];\n    int front = 0, rear = 0;\n    \n    visited_count = 0;\n    strcpy(queue[rear].state, initial);\n    queue[rear].steps = 0;\n    rear++;\n    add_visited(initial);\n    \n    while (front < rear) {\n        QueueItem current = queue[front++];\n        \n        int len = strlen(current.state);\n        \n        for (int i = 0; i < len - 1; i++) {\n            if (current.state[i] != current.state[i+1]) {\n                char new_state[MAX_LEN];\n                strcpy(new_state, current.state);\n                \n                char new_color = get_third_color(current.state[i], current.state[i+1]);\n                new_state[i] = new_color;\n                new_state[i+1] = new_color;\n                \n                if (is_uniform(new_state)) {\n                    return current.steps + 1;\n                }\n                \n                if (!is_visited(new_state) && rear < MAX_QUEUE) {\n                    strcpy(queue[rear].state, new_state);\n                    queue[rear].steps = current.steps + 1;\n                    rear++;\n                    add_visited(new_state);\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    char input[MAX_LEN];\n    \n    while (1) {\n        scanf(\"%s\", input);\n        if (strcmp(input, \"0\") == 0) break;\n        \n        int result = solve(input);\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include  char state[MAX_LEN]; } HashItem; HashItem visited[MAX_QUEUE]; int visited_count; int hash_string(char* s) { int h = 0; for (int i = 0; s[i]; i++)  abs(h) % MAX_QUEUE; } int is_visited(char* s) { for (int i = 0; i  return 1;  s); visited_count++; } int is_uniform(char* s) { char  { if (s[i] != first) return   (a == 'b' && b == 'r')) return  (a == 'b' && b == 'g')) return 'r'; return a; } int solve(char* initial) {  rear = 0; visited_count = 0; strcpy(queue[rear].state, initial); queue[rear].steps = 0; rear++; add_visited(initial); while (front < rear) { QueueItem  = 0; i < len - 1; i++) { if (current.state[i] !=  current.state[i+1]); new_state[i] = new_color; new_state[i+1] = new_color; if (is_uniform(new_state)) { return current.steps + 1; } if (!is_visited(new_state) && rear < MAX_QUEUE) { strcpy(queue[rear].state, new_state); queue[rear].steps = current.steps + 1; rear++; add_visited(new_state); } } } } return  scanf(\"%s\", input); if (strcmp(input, \"0\") == 0) break; int  else { printf(\"%d\\n\", result); } } return 0; }"], "perturbed_original": ["//  #include <string.h> #define MAX 0xaaaaa char chk[MAX+10]; int Q[MAX+10], *top, *end, *qmax = Q + MAX; int N, K, mask; int nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 }; int main()  = s = 0, bp = buf; *bp; bp++, N += 2) { if (*bp == 'r') k = 0; else if (*bp == 'g') k = 1; else k = 2; s  << N) - 1, r = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;  -1, chk[s]  qmax) top = Q; if (s < 0) { step++, *end = -1; if (++end >= qmax) end = Q; continue;   0xf; k2 = nxt[k]; if (k2 == k) continue; s2 = (s & ~(0xf << i)) |  = s2; if (++end >= qmax) end = Q; } } } if (top >= end) puts(\"NA\"); } return 0; }"], "original_ll": -1.208731770515442, "sampled_ll": -0.44065582752227783, "all_perturbed_sampled_ll": [-1.6770837306976318], "all_perturbed_original_ll": [-2.152899742126465], "perturbed_sampled_ll": -1.6770837306976318, "perturbed_original_ll": -2.152899742126465, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Point2D;\nimport java.util.*;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\n\t\tnew AOJ0179();\n\n\n\t}\n\n\tclass AOJ0179{\n\t\tpublic AOJ0179() {\n\t\t\twhile(true){\n\t\t\t\tString warm = in.next();\n\t\t\t\tif(warm.equals(\"0\"))break;\n\t\t\t\tint ans = get_warm(warm);\n\t\t\t\tSystem.out.println(ans==-1? \"NA\":ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint get_warm(String input){\n\t\t\tQueue<String> warm = new LinkedList<String>();\n\t\t\tQueue<Integer> cnt = new LinkedList<Integer>();\n\t\t\tHashMap<String, Boolean> memo = new HashMap<String, Boolean>();\n\t\t\tmemo.put(input,true);\n\t\t\twarm.add(input);\n\t\t\tcnt.add(0);\n\t\t\twhile(warm.size()>0){\n\t\t\t\tString a = warm.remove();\n\t\t\t\tint step = cnt.remove();\n//\t\t\t\tSystem.out.println(a+\" \"+step);//deba\n\t\t\t\tboolean sw = true;\n\t\t\t\tfor(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1))sw=false;\n\t\t\t\tif(sw)return step;\n\t\t\t\t//\u3053\u3053\u304b\u3089\n\t\t\t\tfor(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1)){\n\t\t\t\t\tString b = a.substring(0,i)+getColor(a.charAt(i),a.charAt(i+1))+a.substring(i+2,a.length());\n\t\t\t\t\tif(memo.containsKey(b))continue;\n\t\t\t\t\twarm.add(b);\n\t\t\t\t\tcnt.add(step+1);\n\t\t\t\t\tmemo.put(b, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tString getColor(char a, char b){\n\t\t\tif(a=='r'&&b=='b'||a=='b'&&b=='r')return \"gg\";\n\t\t\telse if(a=='r'&&b=='g'||a=='g'&&b=='r')return \"bb\";\n\t\t\telse return \"rr\";\n\t\t}\n\t\t\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class State {\n        String config;\n        int steps;\n        \n        State(String config, int steps) {\n            this.config = config;\n            this.steps = steps;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String input = sc.next();\n            if (input.equals(\"0\")) break;\n            \n            int result = solve(input);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        sc.close();\n    }\n    \n    static int solve(String initial) {\n        if (isUniform(initial)) {\n            return 0;\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        queue.offer(new State(initial, 0));\n        visited.add(initial);\n        \n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            String config = current.config;\n            int steps = current.steps;\n            \n            // Find all adjacent pairs with different colors\n            for (int i = 0; i < config.length() - 1; i++) {\n                if (config.charAt(i) != config.charAt(i + 1)) {\n                    // Change this pair to the third color\n                    char newColor = getThirdColor(config.charAt(i), config.charAt(i + 1));\n                    String newConfig = config.substring(0, i) + newColor + newColor + config.substring(i + 2);\n                    \n                    if (isUniform(newConfig)) {\n                        return steps + 1;\n                    }\n                    \n                    if (!visited.contains(newConfig)) {\n                        visited.add(newConfig);\n                        queue.offer(new State(newConfig, steps + 1));\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static boolean isUniform(String s) {\n        if (s.length() == 0) return true;\n        char first = s.charAt(0);\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) != first) return false;\n        }\n        return true;\n    }\n    \n    static char getThirdColor(char c1, char c2) {\n        if ((c1 == 'r' && c2 == 'g') || (c1 == 'g' && c2 == 'r')) return 'b';\n        if ((c1 == 'r' && c2 == 'b') || (c1 == 'b' && c2 == 'r')) return 'g';\n        if ((c1 == 'g' && c2 == 'b') || (c1 == 'b' && c2 == 'g')) return 'r';\n        return c1; // Should not happen\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class State { String config; int steps; State(String config, int steps) { this.config = config; this.steps = steps;  sc.next(); if  visited = new HashSet<>(); queue.offer(new State(initial, 0)); visited.add(initial); while (!queue.isEmpty()) { State current = queue.poll(); String config =  config.charAt(i + 1)) { // Change this pair to the third color char newColor = getThirdColor(config.charAt(i),  return steps + 1; } if (!visited.contains(newConfig)) { visited.add(newConfig); queue.offer(new State(newConfig, steps + 1)); } } } } return -1; } static boolean isUniform(String s) { if (s.length() == 0) return true; char first = s.charAt(0); for  (s.charAt(i) != first) return  c2) { if ((c1 == 'r' && c2 == 'g') || (c1 == 'g' && c2 == 'r')) return  (c1 == 'b' && c2 == 'r')) return 'g'; if ((c1 == 'g' && c2 == 'b') || (c1 == 'b' && c2 == 'g')) return 'r'; return c1; // Should not happen } }"], "perturbed_original": ["import java.awt.geom.Point2D; import java.util.*; public class Main { Scanner in = new Scanner(System.in); public static <extra_id_1>if(b==0&&b==b&&b!=0)return<extra_id_2>return Cod(val); if(!b&&b!=1&&b<7&&b<10&&g!=-2){<extra_id_3>(val) return<extra_id_4>; int step = cnt.remove();<extra_id_5>temp;)temp +=<extra_id_6>temp = temp<extra_id_7>(int<extra_id_8> new AOJ0179();  in.next(); if(warm.equals(\"0\"))break; int ans = get_warm(warm); System.out.println(ans==-1? \"NA\":ans); } } int get_warm(String input){ Queue<String> warm  memo = new HashMap<String, Boolean>(); memo.put(input,true); warm.add(input); cnt.add(0); while(warm.size()>0){ String a = warm.remove(); int  for(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1))sw=false;  warm.add(b); cnt.add(step+1); memo.put(b,  b){ if(a=='r'&&b=='b'||a=='b'&&b=='r')return \"gg\"; else if(a=='r'&&b=='g'||a=='g'&&b=='r')return \"bb\"; else return \"rr\"; } } }"], "original_ll": -0.9211252927780151, "sampled_ll": -0.383126825094223, "all_perturbed_sampled_ll": [-1.5041357278823853], "all_perturbed_original_ll": [-2.3147456645965576], "perturbed_sampled_ll": -1.5041357278823853, "perturbed_original_ll": -2.3147456645965576, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import deque\nused = [0]*(3**10)\n\n\nwhile True:\n\ts = raw_input()\n\tif s==\"0\":\n\t\tbreak\n\tn=len(s)\n\tt=0\n\tfor i in range(len(s)):\n\t\tt*=3\n\t\tif s[i]==\"r\":\n\t\t\tt+=0\n\t\tif s[i]==\"g\":\n\t\t\tt+=1\n\t\tif s[i]==\"b\":\n\t\t\tt+=2\n\tf=0\n\tfor i in range(3**n):\n\t\tused[i]=0\n\ttq=[t]\n\tq=deque(tq)\n\tused[t]=1\n\tans=-1\n\tcnt=0\n\twhile len(q)>0:\n\t\tqs=len(q)\n\t\tfor o in range(qs):\n\t\t\ttop=q.popleft()\n\t\t\tv=[0]\n\t\t\tv.pop()\n\t\t\tfor i in range(n):\n\t\t\t\tv.append(top%3)\n\t\t\t\ttop/=3\n\t\t\tok=1\n\t\t\ta=v[0]\n\t\t\tfor i in range(n):\n\t\t\t\tif v[i]!=a:\n\t\t\t\t\tok=0\n\t\t\tif ok==1:\n\t\t\t\tf=1\n\t\t\t\tans=cnt\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif v[i]!=v[i+1]:\n\t\t\t\t\tt1=v[i]\n\t\t\t\t\tt2=v[i+1]\n\t\t\t\t\tv[i]=3-t1-t2\n\t\t\t\t\tv[i+1]=3-t1-t2\n\t\t\t\t\ttmp=0\n\t\t\t\t\tfor j in range(n):\n\t\t\t\t\t\ttmp*=3\n\t\t\t\t\t\ttmp+=v[j]\n\t\t\t\t\tif used[tmp]==0:\n\t\t\t\t\t\tq.append(tmp)\n\t\t\t\t\t\tused[tmp]=1\n\t\t\t\t\tv[i]=t1\n\t\t\t\t\tv[i+1]=t2\n\t\tif f==1:\n\t\t\tbreak\n\t\telse:\n\t\t\tcnt+=1\n\tif ans==-1:\n\t\tprint \"NA\"\n\telse:\n\t\tprint ans", "sampled": "from collections import deque\n\ndef get_other_color(c1, c2):\n    colors = {'r', 'g', 'b'}\n    return list(colors - {c1, c2})[0]\n\ndef get_neighbors(state):\n    neighbors = []\n    for i in range(len(state) - 1):\n        if state[i] != state[i + 1]:\n            new_state = list(state)\n            new_color = get_other_color(state[i], state[i + 1])\n            new_state[i] = new_color\n            new_state[i + 1] = new_color\n            neighbors.append(''.join(new_state))\n    return neighbors\n\ndef solve(state):\n    if len(set(state)) == 1:\n        return 0\n    \n    visited = {state}\n    queue = deque([(state, 0)])\n    \n    while queue:\n        current, steps = queue.popleft()\n        \n        for neighbor in get_neighbors(current):\n            if len(set(neighbor)) == 1:\n                return steps + 1\n            \n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, steps + 1))\n    \n    return \"NA\"\n\nwhile True:\n    line = input().strip()\n    if line == \"0\":\n        break\n    print(solve(line))\n", "perturbed_sampled": ["from collections import deque def is \"0\": break<extra_id_14>e )<extra_id_15>queue[ii]<extra_id_16>= 0<extra_id_17>= visited[ii] #print(s-1) visited[ii]<extra_id_18>+<extra_id_19>break visited[i] = {c1, c2})[0] def get_neighbors(state): neighbors = [] for i in range(len(state) - 1): if state[i]  state[i + 1]) new_state[i] =  solve(state): if len(set(state)) == 1: return 0 visited = {state} queue = deque([(state, 0)]) while queue: current, steps = queue.popleft() for neighbor in get_neighbors(current): if len(set(neighbor)) == 1:  queue.append((neighbor, steps +  == \"0\": break print(solve(line))"], "perturbed_original": ["from collections import deque used = [0]*(3**10) while True:  in range(len(s)): t*=3 if s[i]==\"r\": t+=0 if s[i]==\"g\": t+=1 if s[i]==\"b\": t+=2 f=0 for  len(q)>0: qs=len(q)  range(n): v.append(top%3) top/=3 ok=1 a=v[0] for i in range(n):  in range(n-1): if v[i]!=v[i+1]: t1=v[i] t2=v[i+1] v[i]=3-t1-t2 v[i+1]=3-t1-t2 tmp=0 for j in range(n): tmp*=3 tmp+=v[j] if  if ans==-1: print \"NA\" else: print ans"], "original_ll": -0.9062351584434509, "sampled_ll": -0.6443706750869751, "all_perturbed_sampled_ll": [-2.5375826358795166], "all_perturbed_original_ll": [-2.251845359802246], "perturbed_sampled_ll": -2.5375826358795166, "perturbed_original_ll": -2.251845359802246, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0180: Demolition of Bridges\n// 2017.8.9\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x77777777\n#define MAX 100\n#define EMAX 500\nint n;\ntypedef struct { int b, c; } ND;\nND d[MAX + 2][MAX + 2];\nint w[MAX + 2];\nint visited[MAX];\n\nint qsize;\ntypedef struct { int a, b, c; } QUE;\nQUE que[EMAX + 1];\n\n#define PARENT(i) ((i)/2)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nstatic void min_heapify(int i)\n{\n\tint l, r, smallest;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].c < que[i].c) smallest = l; else smallest = i;\n\tif (r < qsize && que[r].c < que[smallest].c) smallest = r;\n\tif (smallest != i) {\n\t\tQUE t;\n\t\tmemcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + smallest, sizeof(QUE));\n\t\tmemcpy(que + smallest, &t, sizeof(QUE));\n\t\tmin_heapify(smallest);\n\t}\n}\n\nint deq(QUE *q)\n{\n\tif (qsize == 0) return -1;\n\tmemcpy(q, &que[0], sizeof(QUE));\n\tmemcpy(que, que + --qsize, sizeof(QUE));\n\tmin_heapify(0);\n\treturn 1;\n}\n\nvoid enq(QUE *q)\n{\n\tint i;\n\n\ti = qsize++;\n\tmemcpy(que + i, q, sizeof(QUE));\n\twhile (i > 0 && que[PARENT(i)].c > que[i].c) {\n\t\tQUE t;\n\t\tmemcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + PARENT(i), sizeof(QUE));\n\t\tmemcpy(que + PARENT(i), &t, sizeof(QUE));\n\t\ti = PARENT(i);\n\t}\n}\n\n\nint main()\n{\n\tint m, a, b, c;\n\tint i, k, ans;\n\tQUE q;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &n, &m); if (!n) return 0;\n\t\tmemset(w, 0, sizeof(w));\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\td[a][w[a]].b = b, d[a][w[a]++].c = c;\n\t\t\td[b][w[b]].b = a, d[b][w[b]++].c = c;\n\t\t}\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tans = 0, visited[0] = 1, k = 1, qsize = 0;\n\t\tfor (i = 0; i < w[0]; i++) q.a = 0, q.b = d[0][i].b, q.c = d[0][i].c, enq(&q);\n\t\twhile (k < n) {\n\t\t\tdo deq(&q);\n\t\t\twhile (visited[q.a] && visited[q.b]);\n\t\t\tk++;\n\t\t\ta = visited[q.a] ? q.b : q.a;\n\t\t\tvisited[a] = 1, ans += q.c;\n\t\t\tfor (i = 0; i < w[a]; i++) {\n\t\t\t\tb = d[a][i].b;\n\t\t\t\tif (!visited[b]) q.a = a, q.b = b, q.c = d[a][i].c, enq(&q);\n\t\t\t}\n\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int a, b, cost;\n} Edge;\n\nint parent[100];\n\nint find(int x) {\n    if (parent[x] == x) return x;\n    return parent[x] = find(parent[x]);\n}\n\nint unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return 0;\n    parent[x] = y;\n    return 1;\n}\n\nint compare(const void *a, const void *b) {\n    Edge *ea = (Edge *)a;\n    Edge *eb = (Edge *)b;\n    return ea->cost - eb->cost;\n}\n\nint main() {\n    int n, m;\n    \n    while (1) {\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0) break;\n        \n        Edge edges[500];\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &edges[i].a, &edges[i].b, &edges[i].cost);\n        }\n        \n        qsort(edges, m, sizeof(Edge), compare);\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        int total = 0;\n        int count = 0;\n        \n        for (int i = 0; i < m; i++) {\n            if (unite(edges[i].a, edges[i].b)) {\n                total += edges[i].cost;\n                count++;\n                if (count == n - 1) break;\n            }\n        }\n        \n        printf(\"%d\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int a,  find(parent[x]); } int unite(int x, int  == y) return 0;  const void *b) { Edge  ea->cost - eb->cost; } int main() { int n, m; while (1) { scanf(\"%d %d\", &n, &m);  edges[500]; for  %d %d\", &edges[i].a, &edges[i].b, &edges[i].cost); } qsort(edges, m, sizeof(Edge), compare); for (int i = 0; i < n; i++) { parent[i] = i; } int total  0; i < m; i++) { if (unite(edges[i].a, edges[i].b)) { total += edges[i].cost; count++; if (count == n - 1) break; } } printf(\"%d\\n\", total); } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0180: Demolition of   d[MAX + 2][MAX + 2]; int w[MAX + 2]; int  } QUE; QUE que[EMAX + 1]; #define PARENT(i) ((i)/2) #define LEFT(i) ((i)<<1) #define RIGHT(i) (((i)<<1)+1) static void min_heapify(int  que[i].c) smallest = l; else smallest = i; if (r < qsize && que[r].c < que[smallest].c) smallest = r;  i, sizeof(QUE)), memcpy(que + i, que + smallest, sizeof(QUE)); memcpy(que + smallest,  enq(QUE *q) { int i;  memcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + PARENT(i), sizeof(QUE)); memcpy(que + PARENT(i), &t, sizeof(QUE)); i = PARENT(i); } } int main() { int m, a, b, c; int i, k,  (!n) return 0; memset(w, 0, sizeof(w));  &a, &b, &c); d[a][w[a]].b = b, d[a][w[a]++].c = c; d[b][w[b]].b = a, d[b][w[b]++].c = c; } memset(visited, 0,  qsize = 0; for (i = 0; i < w[0]; i++) q.a = 0, q.b = d[0][i].b, q.c = d[0][i].c, enq(&q); while (k < n) { do deq(&q); while (visited[q.a] && visited[q.b]); k++; a = visited[q.a] ? q.b : q.a; visited[a] = 1, ans += q.c;  b, q.c = d[a][i].c, enq(&q); } } printf(\"%d\\n\", ans); } return 0; }"], "original_ll": -0.6967298984527588, "sampled_ll": -0.27706044912338257, "all_perturbed_sampled_ll": [-1.5640674829483032], "all_perturbed_original_ll": [-1.5578681230545044], "perturbed_sampled_ll": -1.5640674829483032, "perturbed_original_ll": -1.5578681230545044, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tstatic int n, m;\n\tstatic int[][] node;\n\n\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\n\t}\n\n\tstatic boolean read(){\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tif(n == 0 && m == 0)  return false;\n\n\t\tnode = new int[n][n];  //\u008b\u0097\u0097\u00a3\u008ds\u0097\u00f1\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(i==j) node[i][j] = 0;\n\t\t\t\telse     node[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint node1 = sc.nextInt();\n\t\t\tint node2 = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\n\t\t\tnode[node1][node2] = cost;\n\t\t\tnode[node2][node1] = cost;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\t//\u0083v\u0083\u008a\u0083\u0080\u0096@\n\tstatic void solve(){\n\t\tint sum =0;\n\t\tHashSet<Integer> X = new HashSet<Integer>();  //\u008c\u0088\u0092\u00e8\u008d\u00cf\u0082\u00dd\u008fW\u008d\u0087\n\t\tHashSet<Integer> Y = new HashSet<Integer>();  //\u0096\u00a2\u008c\u0088\u0092\u00e8\u008fW\u008d\u0087\n\n\t\t//\u008fW\u008d\u0087\u0082\u00cc\u008f\u0089\u008a\u00fa\u0089\u00bb\n\t\tX.add(0);\n\t\tfor(int i=1; i<n; i++){\n\t\t\tY.add(i);\n\t\t}\n\n\t\t//\u0096\u00a2\u008c\u0088\u0092\u00e8\u0082\u00cc\u008fW\u008d\u0087\u0082\u00aa\u008b\u00f3\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00dc\u0082\u00c5\n\t\twhile(!Y.isEmpty()){\n\n\t\t\t//\u008d\u00c5\u008f\u00ac\u0083R\u0083X\u0083g\u0082\u00cc\u0097\u00d7\u0090\u00da\u0083m\u0081[\u0083h\u0082\u00f0\u0092\u00b2\u0082\u00d7\u0082\u00e9\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint min_num = -1, min_num2 = -1;\n\n\t\t\tfor(Iterator<Integer> i1 = X.iterator(); i1.hasNext();){\n\t\t\t\tint n1 = i1.next();\n\t\t\t\tfor (Iterator<Integer> i2 = Y.iterator(); i2.hasNext();){\n\t\t\t\t\tint n2 = i2.next();\n\t\t\t\t\tif(node[n1][n2] == -1)  continue;\n\n\t\t\t\t\tif(min > node[n1][n2]){\n\t\t\t\t\t\tmin = node[n1][n2];\n\t\t\t\t\t\tmin_num = n1;\n\t\t\t\t\t\tmin_num2 = n2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsum += node[min_num][min_num2];\n\t\t\tY.remove(min_num2);\n\t\t\tX.add(min_num2);\n\t\t}\n\n\t\tSystem.out.println(sum);  //\u008fo\u0097\u00cd\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge implements Comparable<Edge> {\n        int u, v, cost;\n        \n        Edge(int u, int v, int cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(Edge other) {\n            return this.cost - other.cost;\n        }\n    }\n    \n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) {\n                return false;\n            }\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            \n            return true;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) {\n                break;\n            }\n            \n            List<Edge> edges = new ArrayList<>();\n            \n            for (int i = 0; i < m; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int cost = sc.nextInt();\n                edges.add(new Edge(a, b, cost));\n            }\n            \n            Collections.sort(edges);\n            \n            UnionFind uf = new UnionFind(n);\n            int totalCost = 0;\n            int edgeCount = 0;\n            \n            for (Edge edge : edges) {\n                if (uf.union(edge.u, edge.v)) {\n                    totalCost += edge.cost;\n                    edgeCount++;\n                    if (edgeCount == n - 1) {\n                        break;\n                    }\n                }\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Edge implements Comparable<Edge> { int  this.u = u; this.v = v; this.cost = cost; } @Override public int compareTo(Edge other) { return this.cost - other.cost; } } static class UnionFind { int[] parent; int[] rank; UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i < n; i++) { parent[i] = i; rank[i] = 0; } } int find(int x)  (rootX == rootY) { return false; } if (rank[rootX] < rank[rootY]) { parent[rootX] = rootY; } else if  public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true)  (n == 0 && m == 0) { break;  0;  b = sc.nextInt(); int cost = sc.nextInt(); edges.add(new  (Edge edge : edges) { if (uf.union(edge.u,  - 1) { break; } } } System.out.println(totalCost); } sc.close(); } }"], "perturbed_original": ["import java.util.HashSet; import java.util.Iterator; import java.util.Scanner; public class Main { static Scanner sc = new Scanner(System.in);  main(String[] args)  sc.nextInt(); m = sc.nextInt(); if(n == 0 && m  i=0; i<n; i++){ for(int j=0; j<n; j++){ if(i==j) node[i][j] = 0; else node[i][j] = -1; }  node2 = sc.nextInt(); int cost = sc.nextInt(); node[node1][node2] = cost; node[node2][node1]  int sum =0; HashSet<Integer> X = new HashSet<Integer>(); //\u008c\u0088\u0092\u00e8\u008d\u00cf\u0082\u00dd\u008fW\u008d\u0087 HashSet<Integer> Y = new HashSet<Integer>(); //\u0096\u00a2\u008c\u0088\u0092\u00e8\u008fW\u008d\u0087 //\u008fW\u008d\u0087\u0082\u00cc\u008f\u0089\u008a\u00fa\u0089\u00bb X.add(0); for(int i=1; i<n;  = X.iterator(); i1.hasNext();){ int n1 = i1.next(); for (Iterator<Integer> i2 = Y.iterator(); i2.hasNext();){ int n2 =  node[n1][n2]; min_num = n1; min_num2  } System.out.println(sum); //\u008fo\u0097\u00cd } }"], "original_ll": -1.0396578311920166, "sampled_ll": -0.16457748413085938, "all_perturbed_sampled_ll": [-1.3143913745880127], "all_perturbed_original_ll": [-1.9175941944122314], "perturbed_sampled_ll": -1.3143913745880127, "perturbed_original_ll": -1.9175941944122314, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f(s, cost, route, ans):\n    route.append(s)\n    ans += cost[s]\n    del cost[s]\n    for k, c in data.items():\n        if s in k:\n            a, b = k\n            if s == a:\n                if not b in route:\n                    if not b in cost or c < cost[b]:\n                        cost[b] = c\n                        del data[(a, b)]\n            elif s == b:\n                if not a in route:\n                    if not a in cost or c < cost[a]:\n                        cost[a] = c\n                        del data[(a, b)]\n    if cost:\n        s = sorted(cost.items(), key=lambda x: x[1])[0][0]\n        return f(s, cost, route, ans)\n    return ans\n\nwhile 1:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    data = {}\n    for i in range(m):\n        a, b, c = map(int, raw_input().split())\n        data[(a, b)] = c\n    print f(0, {0:0}, [], 0)", "sampled": "import sys\nfrom typing import List, Tuple\n\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x: int) -> int:\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x: int, y: int) -> bool:\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False\n        \n        if self.rank[root_x] < self.rank[root_y]:\n            self.parent[root_x] = root_y\n        elif self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        else:\n            self.parent[root_y] = root_x\n            self.rank[root_x] += 1\n        \n        return True\n\ndef kruskal(n: int, edges: List[Tuple[int, int, int]]) -> int:\n    edges.sort(key=lambda x: x[2])\n    uf = UnionFind(n)\n    total_cost = 0\n    edges_added = 0\n    \n    for a, b, cost in edges:\n        if uf.union(a, b):\n            total_cost += cost\n            edges_added += 1\n            if edges_added == n - 1:\n                break\n    \n    return total_cost\n\ndef main():\n    input_lines = sys.stdin.read().strip().split('\\n')\n    i = 0\n    \n    while i < len(input_lines):\n        line = input_lines[i].strip()\n        if not line:\n            i += 1\n            continue\n        \n        parts = line.split()\n        n, m = int(parts[0]), int(parts[1])\n        \n        if n == 0 and m == 0:\n            break\n        \n        i += 1\n        edges = []\n        \n        for j in range(m):\n            line = input_lines[i].strip()\n            parts = line.split()\n            a, b, cost = int(parts[0]), int(parts[1]), int(parts[2])\n            edges.append((a, b, cost))\n            i += 1\n        \n        result = kruskal(n, edges)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from typing import List, Tuple class UnionFind: def __init__(self, n: int): self.parent = list(range(n)) self.rank = [0] * n def find(self, x: int) -> int: if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x: int, y: int) -> bool: root_x = self.find(x) root_y =  return True def kruskal(n:  uf = UnionFind(n) total_cost = 0 edges_added = 0  += cost edges_added += 1 if edges_added == n - 1: break return total_cost def main(): input_lines = sys.stdin.read().strip().split('\\n') i  n, m = int(parts[0]),  i += 1 edges =  line.split() a, b, cost = int(parts[0]), int(parts[1]), int(parts[2]) edges.append((a,  if __name__ == \"__main__\": main()"], "perturbed_original": ["def f(s, cost, route, ans):  if s == a: if not  < cost[b]:  if not a in route: if not a in cost or c < cost[a]: cost[a] = c del data[(a, b)] if cost: s = sorted(cost.items(), key=lambda x: x[1])[0][0] return  = map(int, raw_input().split())  for i in range(m): a, b, c = map(int, raw_input().split()) data[(a, b)] = c print f(0, {0:0}, [], 0)"], "original_ll": -0.8625342845916748, "sampled_ll": -0.2534784972667694, "all_perturbed_sampled_ll": [-1.2886937856674194], "all_perturbed_original_ll": [-1.9915213584899902], "perturbed_sampled_ll": -1.2886937856674194, "perturbed_original_ll": -1.9915213584899902, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void){\n\tint m,n,q,r,a,i,j,t[100],s;\n\tfor(;scanf(\"%d%d\",&m,&n),m;printf(\"%d\\n\",q)){\n\t\tfor(s=i=q=0;i<n;i++){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tt[i]=a;\n\t\t\ts+=a;\n\t\t\tif(q<a)q=a;\n\t\t}\n\t\tr=s>1500000?1500000:s;\n\t\tfor(;q<r;){\n\t\t\tj=m;\n\t\t\ta=q+r>>1;\n\t\t\ts=0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\ts+=t[i];\n\t\t\t\tif(s>a){\n\t\t\t\t\tif(!--j)break;\n\t\t\t\t\ts=t[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==n){\tr=a;\t}\n\t\t\telse{\tq=a+1;\t}\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint m, n;\nint w[105];\nint dp[105][25];\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint solve(int pos, int shelves) {\n    if (pos == n) {\n        if (shelves == 0) return 0;\n        return 1e9;\n    }\n    if (shelves == 0) return 1e9;\n    \n    if (dp[pos][shelves] != -1) return dp[pos][shelves];\n    \n    int result = 1e9;\n    int sum = 0;\n    \n    for (int i = pos; i < n; i++) {\n        sum += w[i];\n        int remaining = solve(i + 1, shelves - 1);\n        if (remaining != 1e9) {\n            result = result < max(sum, remaining) ? result : max(sum, remaining);\n        }\n    }\n    \n    dp[pos][shelves] = result;\n    return result;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &m, &n);\n        if (m == 0 && n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &w[i]);\n        }\n        \n        memset(dp, -1, sizeof(dp));\n        printf(\"%d\\n\", solve(0, m));\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int m, n; int w[105]; int dp[105][25]; int max(int  if (pos == n) { if (shelves == 0) return 0; return 1e9; } if (shelves == 0) return 1e9; if (dp[pos][shelves] != -1) return dp[pos][shelves];  i = pos; i < n; i++)  shelves - 1); if (remaining != 1e9) { result = result < max(sum, remaining) ? result  0) break; for (int i = 0; i < n; i++) { scanf(\"%d\", &w[i]); } memset(dp, -1, sizeof(dp)); printf(\"%d\\n\", solve(0, m)); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void){ int m,n,q,r,a,i,j,t[100],s; for(;scanf(\"%d%d\",&m,&n),m;printf(\"%d\\n\",q)){ for(s=i=q=0;i<n;i++){ scanf(\"%d\",&a); t[i]=a; s+=a; if(q<a)q=a; } r=s>1500000?1500000:s; for(;q<r;){ j=m; a=q+r>>1; s=0; for(i=0;i<n;i++){ s+=t[i]; if(s>a){ if(!--j)break;  } return 0; }"], "original_ll": -1.2898679971694946, "sampled_ll": -0.4887351989746094, "all_perturbed_sampled_ll": [-1.5143227577209473], "all_perturbed_original_ll": [-1.730548620223999], "perturbed_sampled_ll": -1.5143227577209473, "perturbed_original_ll": -1.730548620223999, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m;\n\tstatic int book[];\n\n\tpublic static int binarySearch(int low, int high) {\n\t\tif (high - low <= 0) {\n\t\t\treturn high;\n\t\t}\n\t\tint mid = (low + high) / 2;\n\t\tint shellId = 0;\n\t\tint sumWidth = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (mid < sumWidth + book[i]) {\n\t\t\t\tshellId++;\n\t\t\t\tsumWidth = book[i];\n\t\t\t} else {\n\t\t\t\tsumWidth += book[i];\n\t\t\t}\n\t\t}\n\n\t\tif (n <= shellId) {\n\t\t\treturn binarySearch(mid + 1, high);\n\t\t} else {\n\t\t\treturn binarySearch(low, mid);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint max;\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();//tana\n\t\t\tm = sc.nextInt();//kann\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbook = new int[m];\n\t\t\tmax = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbook[i] = sc.nextInt();\n\t\t\t\tmax = Math.max(max, book[i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(binarySearch(max, 1500000));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            \n            if (m == 0 && n == 0) break;\n            \n            int[] w = new int[n];\n            for (int i = 0; i < n; i++) {\n                w[i] = sc.nextInt();\n            }\n            \n            // Binary search on the width\n            int left = 0;\n            int right = 1500000;\n            \n            // Find the minimum of maximum widths\n            for (int i = 0; i < n; i++) {\n                left = Math.max(left, w[i]);\n            }\n            \n            while (left < right) {\n                int mid = (left + right) / 2;\n                if (canFit(w, n, m, mid)) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            \n            System.out.println(left);\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean canFit(int[] w, int n, int m, int maxWidth) {\n        int shelves = 1;\n        int currentWidth = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (currentWidth + w[i] <= maxWidth) {\n                currentWidth += w[i];\n            } else {\n                shelves++;\n                currentWidth = w[i];\n                if (shelves > m) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": ["import  { Scanner sc = new Scanner(System.in); while (true) { int   int[n]; for (int i = 0; i < n; i++) { w[i] = sc.nextInt(); } // Binary search on the  Find the minimum of maximum widths for (int i = 0;  while (left < right) {  n, m, mid)) { right = mid; }  } sc.close(); } private static boolean canFit(int[] w,  1; int currentWidth = 0; for (int i = 0; i < n; i++)  w[i]; } else { shelves++; currentWidth = w[i]; if (shelves > m) { return false; } } } return true; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { static int n, m; static int book[]; public static int binarySearch(int low, int high) { if <extra_id_4>{ n =<extra_id_5>{ Math.min(book[i],<extra_id_6>1<extra_id_7>2 ; n<extra_id_8><=<extra_id_9>if(book[i] > 0)<extra_id_10>{ num ++ ; i<extra_id_11>i ; i<extra_id_12>i = m<extra_id_13>\" ; } }<extra_id_14>int n = 0<extra_id_15>; var i = 0<extra_id_16>(<extra_id_17>; for ( int mid = (low + high) / 2; int shellId =  { sumWidth += book[i]; } } if (n <= shellId) { return binarySearch(mid + 1, high); } else { return binarySearch(low, mid); } } public static  sc.nextInt();//kann if ((n | m) ==  0; for (int i = 0; i < m; i++) { book[i] = sc.nextInt(); max = Math.max(max, book[i]); } System.out.println(binarySearch(max, 1500000)); } } }"], "original_ll": -0.8218260407447815, "sampled_ll": -0.4436812698841095, "all_perturbed_sampled_ll": [-2.0943939685821533], "all_perturbed_original_ll": [-2.145047664642334], "perturbed_sampled_ll": -2.0943939685821533, "perturbed_original_ll": -2.145047664642334, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def hondan(w,m):\n    m_sum = b_lis[0]\n    num = 0\n    if w < max(b_lis):\n        return False\n    else:\n        for i in range(len(b_lis) - 1):\n            m_sum += b_lis[i + 1]\n            if m_sum > w:\n\n                m_sum = b_lis[i + 1]\n                num += 1\n\n        if num < m:\n            return True\n        else:\n            return False\n        \ndef nibutan(f_id,e_id,m):\n    \n    \n    m_id = int((f_id + e_id) / 2)\n    m_bo = hondan(m_id,m)\n\n\n    if (f_id > e_id):\n        return m_id + 1\n    else:\n        if m_bo:\n            return(nibutan(f_id,m_id -1,m))\n        elif not m_bo:\n            return(nibutan(m_id + 1,e_id,m))\n        else:\n            return m_id + 1\n\n\n\nwhile True:\n    global w_lis\n    b_lis = []\n    w_lis = []\n    dan_num = [0]\n\n    m,n = map(int,input().split())\n    if m == n == 0:\n        break\n    for i in range(n):\n        num = int(input())\n        b_lis.append(num)\n    s_num = int(sum(b_lis) /m)\n\n    print(nibutan(s_num,1500000,m) )", "sampled": "def can_fit(books, m, max_width):\n    shelves_used = 1\n    current_width = 0\n    \n    for book in books:\n        if book > max_width:\n            return False\n        if current_width + book > max_width:\n            shelves_used += 1\n            current_width = book\n            if shelves_used > m:\n                return False\n        else:\n            current_width += book\n    \n    return True\n\ndef solve(m, n, books):\n    left = max(books)\n    right = sum(books)\n    \n    result = right\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_fit(books, m, mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\nwhile True:\n    line = input().split()\n    m, n = int(line[0]), int(line[1])\n    \n    if m == 0 and n == 0:\n        break\n    \n    books = []\n    for _ in range(n):\n        books.append(int(input()))\n    \n    print(solve(m, n, books))\n", "perturbed_sampled": ["def can_fit(books, m, max_width): shelves_used = 1 current_width = 0 for book  book if shelves_used > m: return False else: current_width += book return True def solve(m, n, books): left = max(books) right = sum(books) result = right while left <= right: mid = (left +  + 1 return result while True:  == 0 and n == 0: break books = [] for _ in range(n): books.append(int(input())) print(solve(m, n, books))"], "perturbed_original": ["def hondan(w,m): m_sum = b_lis[0] num = 0 if w < max(b_lis): return False else: for i in range(len(b_lis) - 1): m_sum += b_lis[i + 1] if m_sum  def nibutan(f_id,e_id,m): m_id = int((f_id + e_id) / 2)  1 else:  else: return m_id +  [] dan_num = [0] m,n = map(int,input().split()) if m == n ==  s_num = int(sum(b_lis) /m) print(nibutan(s_num,1500000,m) )"], "original_ll": -1.4594098329544067, "sampled_ll": -0.5417465567588806, "all_perturbed_sampled_ll": [-2.05633282661438], "all_perturbed_original_ll": [-2.7894535064697266], "perturbed_sampled_ll": -2.05633282661438, "perturbed_original_ll": -2.7894535064697266, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\nint b[50]; // beaker status\nint d[50]; // used status\nint f[50]; // filled status\n\nint compare(const void *a, const void *b) {\n  return *(int *)b - *(int *)a;\n}\n\nint dcheck(int n) {\n  int i, r;\n  for (i = 0, r = 0; i < n; i++)\n    r += d[i];\n  if (r == n)\n    return 1;\n  else\n    return 0;\n}\n\nint beaker(int n, int m) {\n  int i, t;\n  f[m] = 0;\n  d[m] = 1;\n\n  if (n == 1) return 1;\n  for (i = m + 1, t = b[m]; i < n; i++) {\n    if (t >= b[i] && f[i] == 0) {\n      t -= b[i];\n      d[i] = f[i] = 1;\n    }\n    if (t == 0)\n      if (dcheck(n))\n        return 1;\n      else\n        beaker(n, m + 1);\n  }\n  return 0;\n}\n\nvoid init() {\n  int i;\n  for (i = 0; i < 50; i++)\n    b[i] = f[i] = d[i] = 0;\n  return;\n}\n\nint main() {\n  int i, n, m;\n\n  for (;;) {\n    scanf(\"%d\", &n);\n    if (n == 0)\n      return 0;\n    init();\n    for (i = 0; i < n; i++)\n      scanf(\"%d\", &b[i]);\n    qsort(b, n, sizeof(int), compare);\n    m = 0; // set max value posion\n    printf(\"%s\", beaker(n, m) ? \"YES\\n\" : \"NO\\n\");\n  }\n  return -1;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint canFill(int *beakers, int n) {\n    int *filled = (int*)calloc(n, sizeof(int));\n    int i, j;\n    \n    filled[0] = beakers[0];\n    \n    for (i = 0; i < n; i++) {\n        if (filled[i] == 0) continue;\n        \n        int water = filled[i];\n        \n        for (j = 0; j < n && water > 0; j++) {\n            if (filled[j] == 0) {\n                int toFill = beakers[j];\n                if (water >= toFill) {\n                    filled[j] = toFill;\n                    water -= toFill;\n                }\n            }\n        }\n        \n        if (water > 0) {\n            free(filled);\n            return 0;\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (filled[i] == 0) {\n            free(filled);\n            return 0;\n        }\n    }\n    \n    free(filled);\n    return 1;\n}\n\nint solve(int *beakers, int n, int index, long long water, int *used) {\n    if (water < 0) return 0;\n    \n    if (index == n) {\n        return (water == 0);\n    }\n    \n    if (used[index]) {\n        return solve(beakers, n, index + 1, water, used);\n    }\n    \n    if (water >= beakers[index]) {\n        used[index] = 1;\n        if (solve(beakers, n, 0, water - beakers[index], used)) {\n            used[index] = 0;\n            return 1;\n        }\n        used[index] = 0;\n    }\n    \n    return solve(beakers, n, index + 1, water, used);\n}\n\nint canFillRecursive(int *beakers, int n, int current, int *used) {\n    if (current == n) {\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) return 0;\n        }\n        return 1;\n    }\n    \n    if (!used[current]) return 0;\n    \n    long long water = beakers[current];\n    int *newUsed = (int*)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) newUsed[i] = used[i];\n    \n    if (solve(beakers, n, 0, water, newUsed)) {\n        if (canFillRecursive(beakers, n, current + 1, newUsed)) {\n            free(newUsed);\n            return 1;\n        }\n    }\n    \n    free(newUsed);\n    return 0;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int *beakers = (int*)malloc(n * sizeof(int));\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &beakers[i]);\n        }\n        \n        qsort(beakers, n, sizeof(int), compare);\n        \n        if (n == 1) {\n            printf(\"YES\\n\");\n            free(beakers);\n            continue;\n        }\n        \n        int *used = (int*)calloc(n, sizeof(int));\n        used[0] = 1;\n        \n        if (canFillRecursive(beakers, n, 0, used)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n        \n        free(used);\n        free(beakers);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int compare(const void  int canFill(int *beakers, int n) { int *filled = (int*)calloc(n, sizeof(int)); int i, j; filled[0] = beakers[0]; for (i = 0; i < n; i++) { if (filled[i] ==  if (filled[j] == 0) { int toFill = beakers[j]; if (water >= toFill) {  (water > 0) { free(filled); return 0; } } for (i  0)  0; if (index == n) { return (water == 0); } if (used[index]) {  (water >= beakers[index]) {  used)) { used[index] = 0; return 1; } used[index] = 0; } return solve(beakers, n, index + 1, water, used); } int canFillRecursive(int *beakers, int n, int current, int *used) { if (current ==  i++) { if (!used[i]) return 0; } return 1; } if (!used[current]) return 0; long long water = beakers[current]; int *newUsed = (int*)malloc(n * sizeof(int)); for (int i = 0;  return 0; } int main() { int n; while (scanf(\"%d\", &n) == 1 && n != 0) { int *beakers = (int*)malloc(n * sizeof(int)); for  &beakers[i]); } qsort(beakers, n, sizeof(int), compare); if (n == 1) {  } else { printf(\"NO\\n\"); } free(used); free(beakers); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> int b[50]; // beaker status int d[50]; // used status int f[50]; // filled status int compare(const 0;<extra_id_11>d [<extra_id_12>f[m+0]+i=n; if (m==n)<extra_id_13>1; // not used printf(\"%s\",<extra_id_14>)<extra_id_15>0, n-1, ( *(int *)a;  = 0, r = 0; i < n; i++) r += d[i]; if (r == n) return 1; else return 0; } int beaker(int   (i  0) { t -= b[i]; d[i] = f[i] = 1; } if (t == 0) if (dcheck(n)) return 1; else beaker(n, m +  = f[i] = d[i] = 0; return; } int main() { int i, n, m; for (;;) { scanf(\"%d\", &n); if (n == 0)  0; // set max value posion printf(\"%s\", beaker(n, m) ? \"YES\\n\" : \"NO\\n\"); } return -1; }"], "original_ll": -0.8494323492050171, "sampled_ll": -0.41889718174934387, "all_perturbed_sampled_ll": [-1.4755635261535645], "all_perturbed_original_ll": [-2.4175307750701904], "perturbed_sampled_ll": -1.4755635261535645, "perturbed_original_ll": -2.4175307750701904, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Beaker\npublic class Main{\n\n\tint n;\n\tint[] a;\n\tboolean[] have, t;\n\t\n\tboolean dfs(int k, int rest){\n\t\tif(rest==0){\n\t\t\tfor(int i=0;i<n;i++)t[i]=have[i];\n\t\t\treturn greedy();\n\t\t}\n\t\tif(rest < a[k])return false;\n\t\thave[k] = true;\n\t\tif(dfs(k+1, rest-a[k]))return true;\n\t\thave[k] = false;\n\t\treturn dfs(k+1, rest);\n\t}\n\t\n\tboolean choice(int k, int rest){\n\t\tif(rest==0)return true;\n\t\tif(k<0)return false;\n\t\tif(!t[k])return choice(k-1, rest);\n\t\tif(a[k]<=rest){\n\t\t\tt[k] = false;\n\t\t\tif(choice(k-1, rest-a[k]))return true;\n\t\t\tt[k] = true;\n\t\t}\n\t\treturn choice(k-1, rest);\n\t}\n\t\n\tboolean greedy(){\n\t\tfor(int i=0;i<n;i++)if(!t[i]){\n\t\t\tif(!choice(i-1, a[i]))return false;\n\t\t\tt[i] = true;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tt = new boolean[100];\n\t\thave = new boolean[100];\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\ta = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\tArrays.fill(have, false);\n\t\t\thave[0] = true;\n\t\t\tSystem.out.println(dfs(1, a[n-1]-a[0])?\"YES\":\"NO\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] beakers = new int[n];\n            for (int i = 0; i < n; i++) {\n                beakers[i] = sc.nextInt();\n            }\n            \n            if (canFillAll(beakers)) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static boolean canFillAll(int[] beakers) {\n        int n = beakers.length;\n        if (n == 1) return true;\n        \n        Arrays.sort(beakers);\n        int maxIdx = n - 1;\n        \n        return dfs(beakers, new boolean[n], maxIdx, beakers[maxIdx]);\n    }\n    \n    static boolean dfs(int[] beakers, boolean[] used, int currentIdx, int currentWater) {\n        used[currentIdx] = true;\n        \n        if (allUsed(used)) {\n            return true;\n        }\n        \n        return tryPour(beakers, used, currentWater, 0);\n    }\n    \n    static boolean tryPour(int[] beakers, boolean[] used, int water, int startIdx) {\n        if (water == 0) {\n            for (int i = beakers.length - 1; i >= 0; i--) {\n                if (!used[i]) {\n                    boolean[] newUsed = used.clone();\n                    if (dfs(beakers, newUsed, i, beakers[i])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        \n        for (int i = startIdx; i < beakers.length; i++) {\n            if (!used[i] && beakers[i] <= water) {\n                boolean[] newUsed = used.clone();\n                if (tryPour(beakers, newUsed, water - beakers[i], i + 1)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    static boolean allUsed(boolean[] used) {\n        for (boolean u : used) {\n            if (!u) return false;\n        }\n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) {  beakers   System.out.println(\"YES\"); } else {  int n = beakers.length; if (n == 1) return true; Arrays.sort(beakers); int  beakers[maxIdx]);  currentWater) { used[currentIdx] = true; if (allUsed(used)) { return true;  - 1; i >=  if (dfs(beakers, newUsed, i, beakers[i])) { return true; } } } return false; } for (int i = startIdx; i < beakers.length; i++) { if (!used[i] && beakers[i] <= water) { boolean[] newUsed = used.clone(); if (tryPour(beakers, newUsed, water - beakers[i], i  } static boolean allUsed(boolean[] used) { for (boolean u : used) { if (!u) return false; } return true; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; //Beaker public class Main{ int n; int[] a; boolean[] have,  greedy(); } if(rest < a[k])return false; have[k] = true; if(dfs(k+1, rest-a[k]))return true; have[k] =  = false; if(choice(k-1, rest-a[k]))return true; t[k] = true; } return choice(k-1, rest); } boolean greedy(){ for(int i=0;i<n;i++)if(!t[i]){ if(!choice(i-1, a[i]))return false; t[i] = true; } return true;  new boolean[100]; have =  int[n]; for(int i=0;i<n;i++){ a[i] = sc.nextInt(); } Arrays.sort(a); Arrays.fill(have, false); have[0]  args) { new Main().run(); } }"], "original_ll": -0.7220210433006287, "sampled_ll": -0.4778882563114166, "all_perturbed_sampled_ll": [-1.8261175155639648], "all_perturbed_original_ll": [-2.0340447425842285], "perturbed_sampled_ll": -1.8261175155639648, "perturbed_original_ll": -2.0340447425842285, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(input())\n    if n == 0: break\n    beakers = list(map(int, input().split()))\n    m = max(beakers)\n    beakers.remove(m)\n    beakers.sort()\n    if beakers:\n        beakersum = [beakers[0]]\n        del beakers[0]\n    else:\n        print(\"YES\")\n        continue\n\n    if sum(beakers) < m:\n        print(\"NO\")\n        continue\n    elif sum(beakers) == m:\n        print(\"YES\")\n        continue\n\n    for b in beakers:\n        tmp = [bks + b for bks in beakersum if bks + b <= m]\n        beakersum.extend(tmp)\n        if m in beakersum:\n            break\n    \n    if m in beakersum:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n            \n        ", "sampled": "def can_fill_all_beakers(beakers):\n    n = len(beakers)\n    if n == 1:\n        return True\n    \n    beakers_sorted = sorted(beakers, reverse=True)\n    max_beaker = beakers_sorted[0]\n    \n    # Try DFS to see if we can fill all beakers\n    def dfs(filled, current_water):\n        if len(filled) == n:\n            return current_water == 0\n        \n        if current_water == 0:\n            return False\n        \n        # Try to fill each unfilled beaker\n        for i in range(n):\n            if i not in filled:\n                beaker_capacity = beakers_sorted[i]\n                if beaker_capacity <= current_water:\n                    # Fill this beaker\n                    new_filled = filled | {i}\n                    new_water = current_water - beaker_capacity + beaker_capacity\n                    # After filling, we pour out this beaker's water\n                    if dfs(new_filled, new_water):\n                        return True\n        \n        return False\n    \n    # Different approach: simulate the process\n    # Start with largest beaker filled\n    def solve():\n        # Use bitmask DP or backtracking\n        # State: which beakers have been filled\n        from functools import lru_cache\n        \n        @lru_cache(maxsize=None)\n        def can_fill(filled_mask, available_water):\n            if filled_mask == (1 << n) - 1:\n                return available_water == 0\n            \n            if available_water == 0:\n                return False\n            \n            # Try filling each unfilled beaker\n            for i in range(n):\n                if not (filled_mask & (1 << i)):\n                    capacity = beakers_sorted[i]\n                    if capacity <= available_water:\n                        # Fill beaker i\n                        new_mask = filled_mask | (1 << i)\n                        new_water = available_water - capacity + capacity\n                        if can_fill(new_mask, new_water):\n                            return True\n            \n            return False\n        \n        # Start with the largest beaker (index 0) filled\n        initial_mask = 1\n        initial_water = max_beaker\n        return can_fill(initial_mask, initial_water)\n    \n    return solve()\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    beakers = list(map(int, input().split()))\n    \n    if can_fill_all_beakers(beakers):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["def can_fill_all_beakers(beakers): n = len(beakers) if n == 1: return True beakers_sorted = sorted(beakers, reverse=True) max_beaker =  all beakers def dfs(filled, current_water): if len(filled)  for i in range(n): if i not in  this beaker new_filled = filled | {i} new_water = current_water - beaker_capacity + beaker_capacity # After filling, we pour out this beaker's water if dfs(new_filled, new_water): return True return False # Different approach: simulate the process # Start with largest beaker filled def solve(): # Use bitmask  from functools import lru_cache @lru_cache(maxsize=None) def can_fill(filled_mask, available_water): if filled_mask == (1 << n) - 1: return available_water == 0 if available_water == 0: return False # Try filling each unfilled beaker for i in  new_mask = filled_mask  capacity if can_fill(new_mask, new_water): return True return False #  print(\"NO\")"], "perturbed_original": ["while True: n = int(input()) if n == 0: break beakers = list(map(int, input().split())) m = max(beakers) beakers.remove(m) beakers.sort() if beakers: beakersum = [beakers[0]] del beakers[0] else: print(\"YES\")  + b <= m] beakersum.extend(tmp) if m in beakersum: break if m in beakersum: print(\"YES\") else: print(\"NO\")"], "original_ll": -1.0833656787872314, "sampled_ll": -0.8243054747581482, "all_perturbed_sampled_ll": [-2.1999921798706055], "all_perturbed_original_ll": [-1.9616637229919434], "perturbed_sampled_ll": -2.1999921798706055, "perturbed_original_ll": -1.9616637229919434, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\n#include<stdio.h>\nint main(){\n  char c[9],i;\n  int d[]={0,1,2,3,4,5,6,7,8,0,3,6,1,4,7,2,5,8,0,4,8,2,4,6};\n  while(scanf(\" %c\",&c[0]),c[0]-'0'){\n    for(i=1;i<9;i++){\n      scanf(\" %c\",&c[i]);\n    }\n    for(i=0;i<8;i++){\n      if(c[d[i*3+0]]==c[d[i*3+1]]&&c[d[i*3+1]]==c[d[i*3+2]]&&c[d[i*3+0]]-'+'){\n\tprintf(\"%c\\n\",c[d[i*3]]);\n\tbreak;\n      }\n    }\n      if(i==8)printf(\"NA\\n\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint check_win(char board[3][4], char player) {\n    // Check rows\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {\n            return 1;\n        }\n    }\n    \n    // Check columns\n    for (int j = 0; j < 3; j++) {\n        if (board[0][j] == player && board[1][j] == player && board[2][j] == player) {\n            return 1;\n        }\n    }\n    \n    // Check diagonals\n    if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return 1;\n    }\n    if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return 1;\n    }\n    \n    return 0;\n}\n\nint main() {\n    char board[3][4];\n    \n    while (1) {\n        if (scanf(\"%s\", board[0]) != 1) break;\n        if (board[0][0] == '0') break;\n        \n        scanf(\"%s\", board[1]);\n        scanf(\"%s\", board[2]);\n        \n        if (check_win(board, 'b')) {\n            printf(\"b\\n\");\n        } else if (check_win(board, 'w')) {\n            printf(\"w\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  Check rows for (int i = 0; i < 3;   Check columns for (int j = 0; j < 3; j++) { if (board[0][j] == player && board[1][j] == player && board[2][j] == player) { return 1; } } // Check diagonals if  player) { return 1; } if (board[0][2] == player && board[1][1] ==  0; } int main() { char board[3][4]; while (1) {  break; scanf(\"%s\", board[1]); scanf(\"%s\", board[2]); if (check_win(board, 'b')) { printf(\"b\\n\");  printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": [" scanf(\" %c\",&c[i]); } for(i=0;i<8;i++){ if(c[d[i*3+0]]==c[d[i*3+1]]&&c[d[i*3+1]]==c[d[i*3+2]]&&c[d[i*3+0]]-'+'){ printf(\"%c\\n\",c[d[i*3]]); break; } } if(i==8)printf(\"NA\\n\"); } return 0; }"], "original_ll": -1.1931833028793335, "sampled_ll": -0.3796199560165405, "all_perturbed_sampled_ll": [-1.575632929801941], "all_perturbed_original_ll": [-1.2692253589630127], "perturbed_sampled_ll": -1.575632929801941, "perturbed_original_ll": -1.2692253589630127, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[][] board = new char[3][3];\n\t\n\tstatic boolean read() {\n\t\tString line = sc.next();\n\t\tif(line.equals(\"0\")) return false;\n\t\tboard[0][0] = line.charAt(0); board[0][1] = line.charAt(1); board[0][2] = line.charAt(2);\n\t\tfor(int i = 1; i < 3; i++) {\n\t\t\tline = sc.next();\n\t\t\tfor(int j = 0; j < 3; j++) board[i][j] = line.charAt(j);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic String solve() {\n\t\tchar stone;\n\t\tboolean win;\n\t\t\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\twin = true;\n\t\t\tstone = board[i][0];\n\t\t\tfor(int j = 1; j < 3; j++) {\n\t\t\t\tif(stone != board[i][j]) win = false;\n\t\t\t}\n\t\t\tif(win) return \"\" + stone;\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < 3; j++) {\n\t\t\twin = true;\n\t\t\tstone = board[0][j];\n\t\t\tfor(int i = 1; i < 3; i++) {\n\t\t\t\tif(stone != board[i][j]) win = false;\n\t\t\t}\n\t\t\tif(win) return \"\" + stone;\n\t\t}\n\t\t\n\t\tif(board[0][0] == board[1][1] && board[0][0] == board[2][2]) return \"\" + board[0][0];\n\t\t\n\t\tif(board[2][0] == board[1][1]  && board[1][1] == board[0][2]) return \"\" + board[2][0];\n\t\t\n\t\treturn \"NA\";\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String line = sc.nextLine();\n            if (line.equals(\"0\")) {\n                break;\n            }\n            \n            char[][] board = new char[3][3];\n            board[0] = line.toCharArray();\n            board[1] = sc.nextLine().toCharArray();\n            board[2] = sc.nextLine().toCharArray();\n            \n            boolean bWins = checkWin(board, 'b');\n            boolean wWins = checkWin(board, 'w');\n            \n            if (bWins) {\n                System.out.println(\"b\");\n            } else if (wWins) {\n                System.out.println(\"w\");\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean checkWin(char[][] board, char player) {\n        // Check rows\n        for (int i = 0; i < 3; i++) {\n            if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {\n                return true;\n            }\n        }\n        \n        // Check columns\n        for (int j = 0; j < 3; j++) {\n            if (board[0][j] == player && board[1][j] == player && board[2][j] == player) {\n                return true;\n            }\n        }\n        \n        // Check diagonals\n        if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n            return true;\n        }\n        if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { String line = sc.nextLine(); if (line.equals(\"0\")) { break; } char[][] board = new char[3][3]; board[0] = line.toCharArray();  'b'); boolean wWins = checkWin(board, 'w'); if (bWins) { System.out.println(\"b\"); } else if (wWins) { System.out.println(\"w\");  boolean checkWin(char[][] board, char  i < 3; i++) { if (board[i][0] == player && board[i][1] == player &&  columns for (int j = 0; j < 3;  && board[2][j] == player) { return true; } }  if (board[0][2] == player && board[1][1] == player  } }"], "perturbed_original": ["import java.util.*; public class Main  = new char[3][3]; static boolean read() { String line =  board[0][2] = line.charAt(2); for(int i = 1; i < 3; i++) { line = sc.next(); for(int j = 0; j < 3; j++)   < 3;  board[i][j])  for(int j = 0; j < 3; j++) { win = true; stone = board[0][j]; for(int i = 1; i  board[1][1] && board[0][0] == board[2][2]) return \"\" + board[0][0]; if(board[2][0] == board[1][1] && board[1][1] == board[0][2]) return \"\" + board[2][0]; return \"NA\"; } public static void main(String[] args) { while(read()) { System.out.println(solve()); } } }"], "original_ll": -0.4385029375553131, "sampled_ll": -0.26952099800109863, "all_perturbed_sampled_ll": [-1.429458737373352], "all_perturbed_original_ll": [-1.4669321775436401], "perturbed_sampled_ll": -1.429458737373352, "perturbed_original_ll": -1.4669321775436401, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        f = [list(raw_input()) for _ in xrange(3)]\n    except EOFError:\n        break\n    g = map(lambda x:\"\".join(x),f+zip(*f))\n    print \"b\" if \"b\"*3 in g else \"w\" if \"w\"*3 in g else \"NA\"", "sampled": "import sys\n\ndef check_winner(board):\n    # Check rows\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2] and board[i][0] != '+':\n            return board[i][0]\n    \n    # Check columns\n    for i in range(3):\n        if board[0][i] == board[1][i] == board[2][i] and board[0][i] != '+':\n            return board[0][i]\n    \n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] != '+':\n        return board[0][0]\n    \n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] != '+':\n        return board[0][2]\n    \n    return 'NA'\n\nwhile True:\n    line = input().strip()\n    if line == '0':\n        break\n    \n    board = [line]\n    board.append(input().strip())\n    board.append(input().strip())\n    \n    result = check_winner(board)\n    print(result)\n", "perturbed_sampled": ["import sys def check_winner(board): # Check rows  and board[i][0] != '+': return board[i][0] # Check columns for i in range(3):  return board[0][i] # Check diagonals if board[0][0] == board[1][1] == board[2][2] and board[0][0] != '+': return board[0][0] if board[0][2] == board[1][1] == board[2][0]  line = input().strip()  result = check_winner(board) print(result)"], "perturbed_original": ["while True: try: f = [list(raw_input()) for _ in xrange(3)] except EOFError: break g =  if \"w\"*3 in g else \"NA\""], "original_ll": -1.647559642791748, "sampled_ll": -0.3976525366306305, "all_perturbed_sampled_ll": [-1.3072917461395264], "all_perturbed_original_ll": [-3.195347547531128], "perturbed_sampled_ll": -1.3072917461395264, "perturbed_original_ll": -3.195347547531128, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n    int age0,age1,age2,age3,age4,age5,age6,n,i,x;\n    while(1){\n        age0=0;age1=0;age2=0;age3=0;age4=0;age5=0;age6=0;\n        scanf(\"%d\",&n);\n        if(n==0)break;\n        for(i=0;i<n;i++){\n            scanf(\"%d\",&x);\n            if(x>=60){\n                age6++;\n            }else if(x>=50){\n                age5++;\n            }else if(x>=40){\n                age4++;\n            }else if(x>=30){\n                age3++;\n            }else if(x>=20){\n                age2++;\n            }else if(x>=10){\n                age1++;\n            }else{\n                age0++;\n            }\n        }\n        printf(\"%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n\",age0,age1,age2,age3,age4,age5,age6);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int count[7] = {0};\n        \n        for(int i = 0; i < n; i++) {\n            int age;\n            scanf(\"%d\", &age);\n            \n            if(age < 10) {\n                count[0]++;\n            } else if(age < 20) {\n                count[1]++;\n            } else if(age < 30) {\n                count[2]++;\n            } else if(age < 40) {\n                count[3]++;\n            } else if(age < 50) {\n                count[4]++;\n            } else if(age < 60) {\n                count[5]++;\n            } else {\n                count[6]++;\n            }\n        }\n        \n        for(int i = 0; i < 7; i++) {\n            printf(\"%d\\n\", count[i]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(scanf(\"%d\", &n) == 1 && n != 0) { int count[7] = {0}; for(int  scanf(\"%d\", &age); if(age < 10) {  if(age < 30) { count[2]++; } else if(age < 40) { count[3]++; } else if(age < 50) { count[4]++;  count[6]++; } } for(int i = 0; i  }"], "perturbed_original": ["#include<stdio.h> int main(){ int age0,age1,age2,age3,age4,age5,age6,n,i,x; while(1){ age0=0;age1=0;age2=0;age3=0;age4=0;age5=0;age6=0; scanf(\"%d\",&n); if(n==0)break; for(i=0;i<n;i++){ scanf(\"%d\",&x); if(x>=60){ age6++; }else if(x>=50){ age5++; }else if(x>=40){ age4++; }else if(x>=30){ age3++; }else if(x>=20){ age2++; }else  }"], "original_ll": -0.42583775520324707, "sampled_ll": -0.3275562524795532, "all_perturbed_sampled_ll": [-1.556417465209961], "all_perturbed_original_ll": [-0.8510338068008423], "perturbed_sampled_ll": -1.556417465209961, "perturbed_original_ll": -0.8510338068008423, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main\n{\n    public static void main(String args[])\n    {\n\tScanner scan=new Scanner(System.in);\n\twhile(true)\n\t    {\n\t\t\n\t\tint n=scan.nextInt();\n\t\tif(n==0)break;\n\t\tint s[]=new int[7];\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\t\n\t\t\tint old=scan.nextInt();\n\t\t\tint x=old/10;\n\t\t\tif(x>=6)x=6;\n\t\t\ts[x]++;\n\t\t    }\n\t\tfor(int i=0;i<7;i++)\n\t\t    {\n\t\t\tSystem.out.println(s[i]);\n\t\t    }\n\t    }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] counts = new int[7];\n            \n            for (int i = 0; i < n; i++) {\n                int age = sc.nextInt();\n                \n                if (age < 10) {\n                    counts[0]++;\n                } else if (age < 20) {\n                    counts[1]++;\n                } else if (age < 30) {\n                    counts[2]++;\n                } else if (age < 40) {\n                    counts[3]++;\n                } else if (age < 50) {\n                    counts[4]++;\n                } else if (age < 60) {\n                    counts[5]++;\n                } else {\n                    counts[6]++;\n                }\n            }\n            \n            for (int i = 0; i < 7; i++) {\n                System.out.println(counts[i]);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[] counts =  counts[2]++; } else if (age < 40) { counts[3]++; } else if (age < 50) {  else { counts[6]++; } } for (int i = 0; i < 7; i++) { System.out.println(counts[i]); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String args[]) { Scanner scan=new Scanner(System.in);  { int old=scan.nextInt();  } } }"], "original_ll": -0.9916284680366516, "sampled_ll": -0.26637157797813416, "all_perturbed_sampled_ll": [-1.2952231168746948], "all_perturbed_original_ll": [-2.1060078144073486], "perturbed_sampled_ll": -1.2952231168746948, "perturbed_original_ll": -2.1060078144073486, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\nimport sys\n'import math'\nwhile 1:\n    n=int(input())\n    if n==0: sys.exit()\n    arr=[0]*7\n    while n:\n        a=int(input())\n        if a>60: a=61\n        arr[int(a/10)]+=1\n        n-=1\n    for i in range(len(arr)):\n        print(arr[i])", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    counts = [0] * 7\n    \n    for _ in range(n):\n        age = int(input())\n        if age < 10:\n            counts[0] += 1\n        elif age < 20:\n            counts[1] += 1\n        elif age < 30:\n            counts[2] += 1\n        elif age < 40:\n            counts[3] += 1\n        elif age < 50:\n            counts[4] += 1\n        elif age < 60:\n            counts[5] += 1\n        else:\n            counts[6] += 1\n    \n    for count in counts:\n        print(count)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0:  1 elif age < 20: counts[1] += 1 elif age <  1 elif age < 50: counts[4] += 1 elif age < 60: counts[5] += 1 else: counts[6] += 1 for count in counts: print(count)"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys 'import math' while 1:  a=61 arr[int(a/10)]+=1 n-=1 for i in range(len(arr)): print(arr[i])"], "original_ll": -1.4602009057998657, "sampled_ll": -0.35471677780151367, "all_perturbed_sampled_ll": [-1.774053931236267], "all_perturbed_original_ll": [-3.0904500484466553], "perturbed_sampled_ll": -1.774053931236267, "perturbed_original_ll": -3.0904500484466553, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "j,p[1<<20],n;\nmain(i)\n{\n\tfor(;++i<999;)\n\t\tif(!p[i])\n\t\t\tfor(j=i+i;j<1<<20;j+=i)\n\t\t\t\tp[j]=1;\n\tfor(;scanf(\"%d\",&n),j=0,n;printf(\"%d\\n\",j))\n\t\tfor(i=2;i<=n/2;i++)if(!p[i]&!p[n-i])j++;\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX 1000001\n\nint is_prime[MAX];\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int count = 0;\n        for (int p = 2; p <= n / 2; p++) {\n            if (is_prime[p] && is_prime[n - p]) {\n                count++;\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include  1, sizeof(is_prime)); is_prime[0]  * i < MAX; i++) { if (is_prime[i]) { for (int j = i * i;  } } } } int main() { sieve(); int n; while (scanf(\"%d\", &n) == 1 && n != 0) { int count = 0; for (int p  (is_prime[p] && is_prime[n -  }"], "perturbed_original": ["j,p[1<<20],n; main(i) { for(;++i<999;) if(!p[i]) for(j=i+i;j<1<<20;j+=i) p[j]=1; for(;scanf(\"%d\",&n),j=0,n;printf(\"%d\\n\",j)) for(i=2;i<=n/2;i++)if(!p[i]&!p[n-i])j++; return 0; }"], "original_ll": -1.725116491317749, "sampled_ll": -0.32806381583213806, "all_perturbed_sampled_ll": [-2.052419424057007], "all_perturbed_original_ll": [-1.828331470489502], "perturbed_sampled_ll": -2.052419424057007, "perturbed_original_ll": -1.828331470489502, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static boolean[] prime = new boolean[1000001];\n    static int n;\n    public static void main(String[] args) {\n        makePrime();\n        while(read()){\n            solve();\n        }\n\n    }\n\n    static void makePrime(){\n        Arrays.fill(prime, true);\n        prime[0] = false;\n        prime[1] = false;\n        for(int i = 2; i < prime.length; i++){\n            if(prime[i]){\n                for(int j = i*2; j < prime.length; j += i)prime[j] = false;\n            }\n        }\n    }\n\n    static boolean read(){\n        n = sc.nextInt();\n        if( n == 0 )return false;\n        return true;\n    }\n\n    static void solve(){\n        int res = 0;\n        for(int i = 2; i <= n/2; i++){\n            if(prime[n - i] && prime[i])res++;\n        }\n        System.out.println(res);\n    }\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static boolean[] sieve;\n    static int MAX = 1000001;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Sieve of Eratosthenes\n        sieve = new boolean[MAX];\n        Arrays.fill(sieve, true);\n        sieve[0] = sieve[1] = false;\n        \n        for (int i = 2; i * i < MAX; i++) {\n            if (sieve[i]) {\n                for (int j = i * i; j < MAX; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            for (int p = 2; p <= n / 2; p++) {\n                if (sieve[p] && sieve[n - p]) {\n                    count++;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  static  Sieve of Eratosthenes sieve = new boolean[MAX]; Arrays.fill(sieve, true); sieve[0] = sieve[1] = false; for (int i = 2; i * i < MAX; i++) { if (sieve[i]) { for (int j = i *  = sc.nextInt(); if (n == 0) break; int count = 0; for (int p =  && sieve[n - p]) { count++; } } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class <extra_id_8>public<extra_id_9>int c = 0 ;<extra_id_10>= 0;<extra_id_11>{<extra_id_12>case e .<extra_id_13>E .<extra_id_14>; return n ; case<extra_id_15>0 ; } case 9935<extra_id_16>//if<extra_id_17>// break<extra_id_18>(<extra_id_19>0 ;<extra_id_20>}<extra_id_21>//return true;<extra_id_22>//if(i == 0)i++; prime = new boolean[1000001]; static int n;  } static void makePrime(){ Arrays.fill(prime, true); prime[0] = false; prime[1] = false; for(int  false; } } } static boolean read(){ n = sc.nextInt(); if( n == 0 )return false; return true; } static void solve(){ int res = 0; for(int  && prime[i])res++; } System.out.println(res); } }"], "original_ll": -0.5724353790283203, "sampled_ll": -0.34922999143600464, "all_perturbed_sampled_ll": [-1.717288613319397], "all_perturbed_original_ll": [-2.126591682434082], "perturbed_sampled_ll": -1.717288613319397, "perturbed_original_ll": -2.126591682434082, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import compress\nMAXN = 1000001\np = [True]*MAXN\np[0] = p[1] = False\nfor i in xrange(int(MAXN**0.5)+1):\n    if p[i]:\n        for j in xrange(i+i,MAXN,i):\n            p[j] = False\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    print sum(1 for i in compress(xrange(n/2+1),p) if p[n-i])", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\n# Precompute primes up to 1000000\nMAX_N = 1000000\nis_prime = sieve_of_eratosthenes(MAX_N)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = 0\n    for p in range(2, n // 2 + 1):\n        if is_prime[p]:\n            q = n - p\n            if is_prime[q]:\n                count += 1\n    \n    print(count)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(limit**0.5)  1, i): is_prime[j] = False return is_prime # Precompute primes up to 1000000 MAX_N = 1000000 is_prime =  // 2  is_prime[q]: count += 1 print(count)"], "perturbed_original": ["from itertools import compress MAXN  for i in xrange(int(MAXN**0.5)+1): if p[i]: for j in xrange(i+i,MAXN,i): p[j] = False while True: n = input()  compress(xrange(n/2+1),p) if p[n-i])"], "original_ll": -0.9968967437744141, "sampled_ll": -0.46550697088241577, "all_perturbed_sampled_ll": [-1.586177110671997], "all_perturbed_original_ll": [-2.631413698196411], "perturbed_sampled_ll": -1.586177110671997, "perturbed_original_ll": -2.631413698196411, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint cross(int x1,int y1,int x2,int y2,\n\t\tint x3,int y3,int x4,int y4) {\n\tlong long b12x,b12y,b34x,b34y;\n\tlong long b24x,b24y;\n\tlong long b13x,b13y,b14x,b14y,b32x,b32y;\n\tlong long g1213,g1214,g3431,g3432;\n\tlong long n1213,n1214,n3431,n3432;\n\tlong long n2123,n2124,n4341,n4342;\n\n\tb12x=x2-x1;b12y=y2-y1;\n\tb34x=x4-x3;b34y=y4-y3;\n\tb13x=x3-x1;b13y=y3-y1;\n\tb14x=x4-x1;b14y=y4-y1;\n\tb32x=x2-x3;b32y=y2-y3;\n\tb24x=x4-x2;b24y=y4-y2;\n\n\tg1213=b12x*b13y-b13x*b12y;\n\tg1214=b12x*b14y-b14x*b12y;\n\tg3431=b34x*(-b13y)-(-b13x)*b34y;\n\tg3432=b34x*b32y-b32x*b34y;\n\n\tn1213=b12x*b13x+b12y*b13y;\n\tn1214=b12x*b14x+b12y*b14y;\n\tn3431=b34x*(-b13x)+b34y*(-b13y);\n\tn3432=b34x*b32x+b34y*b32y;\n\tn2123=(-b12x)*(-b32x)+(-b12y)*(-b32y);\n\tn2124=(-b12x)*b24x+(-b12y)*b24y;\n\tn4341=(-b34x)*(-b14x)+(-b34y)*(-b14y);\n\tn4342=(-b34x)*(-b24x)+(-b34y)*(-b24y);\n\n\tif(\n\t\t((g1213<0 && g1214>0) || (g1213>0 && g1214<0)) &&\n\t\t((g3431<0 && g3432>0) || (g3431>0 && g3432<0))\n\t) return 1;\n\tif(\n\t\t(g1213==0 && n1213>=0 && n2123>=0) ||\n\t\t(g1214==0 && n1214>=0 && n2124>=0) ||\n\t\t(g3431==0 && n3431>=0 && n4341>=0) ||\n\t\t(g3432==0 && n3432>=0 && n4342>=0)\n\t) return 1;\n\n\treturn 0;\n}\n\n/*\na1x+b1y=c1\na2x+b2y=c2\n*/\nint solve_houteisiki(double* x,double* y,\n\t\tint a1,int b1,int c1,\n\t\tint a2,int b2,int c2) {\n\tint d;\n\td=a1*b2-b1*a2;\n\tif(d==0)return 0;\n\t*x=(double)(b2*c1-b1*c2)/d;\n\t*y=(double)(-a2*c1+a1*c2)/d;\n\treturn 1;\n}\n\nint main(void) {\n\tint x[6],y[6];\n\tint no_triangle;\n\tint x1,y1,t1,x2,y2,t2,x3,y3,t3;\n\tdouble tx1,ty1,tx2,ty2,tx3,ty3;\n\tdouble s;\n\twhile(1) {\n\t\tscanf(\"%d%d%d%d\",&x[0],&y[0],&x[1],&y[1]);\n\t\tif((x[0]|y[0]|x[1]|y[1])==0)break;\n\t\tscanf(\"%d%d%d%d\",&x[2],&y[2],&x[3],&y[3]);\n\t\tscanf(\"%d%d%d%d\",&x[4],&y[4],&x[5],&y[5]);\n\t\tno_triangle=0;\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[0],y[0],x[1],y[1],x[2],y[2],x[3],y[3]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[2],y[2],x[3],y[3],x[4],y[4],x[5],y[5]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[4],y[4],x[5],y[5],x[0],y[0],x[1],y[1]);\n\t\tif(!no_triangle) {\n\t\t\tx1=y[1]-y[0];\n\t\t\ty1=-(x[1]-x[0]);\n\t\t\tt1=x[0]*(y[1]-y[0])-y[0]*(x[1]-x[0]);\n\t\t\tx2=y[3]-y[2];\n\t\t\ty2=-(x[3]-x[2]);\n\t\t\tt2=x[2]*(y[3]-y[2])-y[2]*(x[3]-x[2]);\n\t\t\tx3=y[5]-y[4];\n\t\t\ty3=-(x[5]-x[4]);\n\t\t\tt3=x[4]*(y[5]-y[4])-y[4]*(x[5]-x[4]);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx1,&ty1,\n\t\t\t\t\tx1,y1,t1,x2,y2,t2);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx2,&ty2,\n\t\t\t\t\tx2,y2,t2,x3,y3,t3);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx3,&ty3,\n\t\t\t\t\tx3,y3,t3,x1,y1,t1);\n\t\t}\n\t\tif(!no_triangle) {\n\t\t\ts=((tx2-tx1)*(ty3-ty1)-(tx3-tx1)*(ty2-ty1))/2;\n\t\t\tif(s<0)s=-s;\n\t\t\tif(s<1e-8)puts(\"kyo\");\n\t\t\telse if(s<100000+1e-8)puts(\"syo-kichi\");\n\t\t\telse if(s<1000000+1e-8)puts(\"kichi\");\n\t\t\telse if(s<1900000+1e-8)puts(\"chu-kichi\");\n\t\t\telse puts(\"dai-kichi\");\n\t\t} else puts(\"kyo\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point p1, p2;\n} Line;\n\nint getIntersection(Line l1, Line l2, Point *result) {\n    double x1 = l1.p1.x, y1 = l1.p1.y;\n    double x2 = l1.p2.x, y2 = l1.p2.y;\n    double x3 = l2.p1.x, y3 = l2.p1.y;\n    double x4 = l2.p2.x, y4 = l2.p2.y;\n    \n    double denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    \n    if (fabs(denom) < 1e-9) {\n        return 0;\n    }\n    \n    double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    \n    result->x = x1 + t * (x2 - x1);\n    result->y = y1 + t * (y2 - y1);\n    \n    return 1;\n}\n\ndouble triangleArea(Point p1, Point p2, Point p3) {\n    return fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0);\n}\n\nint areCollinear(Point p1, Point p2, Point p3) {\n    double area = fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)));\n    return area < 1e-6;\n}\n\nint main() {\n    Line lines[3];\n    \n    while (1) {\n        scanf(\"%lf %lf %lf %lf\", &lines[0].p1.x, &lines[0].p1.y, &lines[0].p2.x, &lines[0].p2.y);\n        \n        if (lines[0].p1.x == 0 && lines[0].p1.y == 0 && lines[0].p2.x == 0 && lines[0].p2.y == 0) {\n            break;\n        }\n        \n        scanf(\"%lf %lf %lf %lf\", &lines[1].p1.x, &lines[1].p1.y, &lines[1].p2.x, &lines[1].p2.y);\n        scanf(\"%lf %lf %lf %lf\", &lines[2].p1.x, &lines[2].p1.y, &lines[2].p2.x, &lines[2].p2.y);\n        \n        Point intersections[3];\n        \n        if (!getIntersection(lines[0], lines[1], &intersections[0]) ||\n            !getIntersection(lines[1], lines[2], &intersections[1]) ||\n            !getIntersection(lines[2], lines[0], &intersections[2])) {\n            printf(\"kyo\\n\");\n            continue;\n        }\n        \n        if (areCollinear(intersections[0], intersections[1], intersections[2])) {\n            printf(\"kyo\\n\");\n            continue;\n        }\n        \n        double area = triangleArea(intersections[0], intersections[1], intersections[2]);\n        \n        if (area < 1e-6) {\n            printf(\"kyo\\n\");\n        } else if (area >= 1900000) {\n            printf(\"dai-kichi\\n\");\n        } else if (area >= 1000000) {\n            printf(\"chu-kichi\\n\");\n        } else if (area >= 100000) {\n            printf(\"kichi\\n\");\n        } else {\n            printf(\"syo-kichi\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  = l1.p1.x, y1 = l1.p1.y; double x2 = l1.p2.x, y2 = l1.p2.y; double x3 = l2.p1.x, y3 = l2.p1.y;  (x1 -  0; } double t = ((x1 - x3) * (y3 - y4) -  = x1 + t * (x2  y1); return 1; } double triangleArea(Point p1, Point p2, Point p3) {   } int areCollinear(Point p1, Point p2, Point p3) { double area = fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y))); return area < 1e-6; } int main() { Line lines[3]; while (1) {  == 0 && lines[0].p1.y ==  break; } scanf(\"%lf %lf %lf %lf\", &lines[1].p1.x, &lines[1].p1.y, &lines[1].p2.x, &lines[1].p2.y); scanf(\"%lf %lf %lf %lf\", &lines[2].p1.x, &lines[2].p1.y, &lines[2].p2.x, &lines[2].p2.y); Point intersections[3]; if (!getIntersection(lines[0], lines[1],  continue; } double area = triangleArea(intersections[0], intersections[1], intersections[2]); if (area  { printf(\"dai-kichi\\n\"); } else if (area >= 1000000) { printf(\"chu-kichi\\n\"); } else if (area >= 100000) { printf(\"kichi\\n\"); } else { printf(\"syo-kichi\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int cross(int x1,int y1,int x2,int y2, int x3,int y3,int x4,int y4) { long  g1213,g1214,g3431,g3432; long  n2123=(-b12x)*(-b32x)+(-b12y)*(-b32y); n2124=(-b12x)*b24x+(-b12y)*b24y; n4341=(-b34x)*(-b14x)+(-b34y)*(-b14y); n4342=(-b34x)*(-b24x)+(-b34y)*(-b24y); if( ((g1213<0 &&  (g3431>0 && g3432<0)) ) return 1; if( (g1213==0 && n1213>=0 && n2123>=0) || (g1214==0 && n1214>=0 && n2124>=0) || (g3431==0 && n3431>=0 && n4341>=0) || (g3432==0 && n3432>=0 && n4342>=0) ) return 1;  y, int a1,int b1,int c1, int a2,int  no_triangle; int x1,y1,t1,x2,y2,t2,x3,y3,t3; double tx1,ty1,tx2,ty2,tx3,ty3; double s; while(1)  || !cross(x[2],y[2],x[3],y[3],x[4],y[4],x[5],y[5]); no_triangle=no_triangle || !cross(x[4],y[4],x[5],y[5],x[0],y[0],x[1],y[1]); if(!no_triangle) { x1=y[1]-y[0]; y1=-(x[1]-x[0]);  x1,y1,t1,x2,y2,t2); no_triangle=no_triangle || !solve_houteisiki(&tx2,&ty2, x2,y2,t2,x3,y3,t3); no_triangle=no_triangle || !solve_houteisiki(&tx3,&ty3, x3,y3,t3,x1,y1,t1); } if(!no_triangle) { s=((tx2-tx1)*(ty3-ty1)-(tx3-tx1)*(ty2-ty1))/2; if(s<0)s=-s; if(s<1e-8)puts(\"kyo\"); else if(s<100000+1e-8)puts(\"syo-kichi\"); else if(s<1000000+1e-8)puts(\"kichi\"); else if(s<1900000+1e-8)puts(\"chu-kichi\"); else puts(\"dai-kichi\"); } else puts(\"kyo\"); } return 0; }"], "original_ll": -0.4733075499534607, "sampled_ll": -0.31539300084114075, "all_perturbed_sampled_ll": [-1.220552682876587], "all_perturbed_original_ll": [-1.0986464023590088], "perturbed_sampled_ll": -1.220552682876587, "perturbed_original_ll": -1.0986464023590088, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=1e-4;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    static class Line {\n        Point p1, p2;\n        Line(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n    \n    static final double EPS = 1e-9;\n    \n    static Point getIntersection(Line l1, Line l2) {\n        double x1 = l1.p1.x, y1 = l1.p1.y;\n        double x2 = l1.p2.x, y2 = l1.p2.y;\n        double x3 = l2.p1.x, y3 = l2.p1.y;\n        double x4 = l2.p2.x, y4 = l2.p2.y;\n        \n        double denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        \n        if (Math.abs(denom) < EPS) {\n            return null; // parallel or coincident\n        }\n        \n        double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n        \n        double px = x1 + t * (x2 - x1);\n        double py = y1 + t * (y2 - y1);\n        \n        return new Point(px, py);\n    }\n    \n    static boolean isParallel(Line l1, Line l2) {\n        double dx1 = l1.p2.x - l1.p1.x;\n        double dy1 = l1.p2.y - l1.p1.y;\n        double dx2 = l2.p2.x - l2.p1.x;\n        double dy2 = l2.p2.y - l2.p1.y;\n        \n        return Math.abs(dx1 * dy2 - dy1 * dx2) < EPS;\n    }\n    \n    static double triangleArea(Point p1, Point p2, Point p3) {\n        return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)) / 2.0;\n    }\n    \n    static boolean areCollinear(Point p1, Point p2, Point p3) {\n        return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)) < EPS;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while (true) {\n            line = br.readLine();\n            String[] parts = line.split(\" \");\n            int x1 = Integer.parseInt(parts[0]);\n            int y1 = Integer.parseInt(parts[1]);\n            int x2 = Integer.parseInt(parts[2]);\n            int y2 = Integer.parseInt(parts[3]);\n            \n            if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;\n            \n            Line l1 = new Line(new Point(x1, y1), new Point(x2, y2));\n            \n            line = br.readLine();\n            parts = line.split(\" \");\n            x1 = Integer.parseInt(parts[0]);\n            y1 = Integer.parseInt(parts[1]);\n            x2 = Integer.parseInt(parts[2]);\n            y2 = Integer.parseInt(parts[3]);\n            Line l2 = new Line(new Point(x1, y1), new Point(x2, y2));\n            \n            line = br.readLine();\n            parts = line.split(\" \");\n            x1 = Integer.parseInt(parts[0]);\n            y1 = Integer.parseInt(parts[1]);\n            x2 = Integer.parseInt(parts[2]);\n            y2 = Integer.parseInt(parts[3]);\n            Line l3 = new Line(new Point(x1, y1), new Point(x2, y2));\n            \n            Point p12 = getIntersection(l1, l2);\n            Point p13 = getIntersection(l1, l3);\n            Point p23 = getIntersection(l2, l3);\n            \n            if (p12 == null || p13 == null || p23 == null) {\n                System.out.println(\"kyo\");\n                continue;\n            }\n            \n            if (areCollinear(p12, p13, p23)) {\n                System.out.println(\"kyo\");\n                continue;\n            }\n            \n            double area = triangleArea(p12, p13, p23);\n            \n            if (area < EPS) {\n                System.out.println(\"kyo\");\n            } else if (area < 100000) {\n                System.out.println(\"syo-kichi\");\n            } else if (area < 1000000) {\n                System.out.println(\"kichi\");\n            } else if (area < 1900000) {\n                System.out.println(\"chu-kichi\");\n            } else {\n                System.out.println(\"dai-kichi\");\n            }\n        }\n    }\n}\n", "perturbed_sampled": [" Point p2) { this.p1 = p1; this.p2 = p2; } } static final double EPS = 1e-9; static Point getIntersection(Line l1, Line l2) { double x1 = l1.p1.x, y1 = l1.p1.y; double x2 = l1.p2.x, y2 =  = l2.p2.x, y4  - y4) - (y1  { return   * (x3 - x4)) /  x1); double py  = l1.p2.y - l1.p1.y;  - l2.p1.y; return Math.abs(dx1 * dy2 - dy1 * dx2) < EPS; } static double triangleArea(Point p1, Point p2, Point p3) { return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y))  p1.y)  } public static void main(String[] args) throws IOException { BufferedReader br = new  String[] parts = line.split(\" \"); int x1 = Integer.parseInt(parts[0]); int y1 = Integer.parseInt(parts[1]); int x2 = Integer.parseInt(parts[2]); int y2 = Integer.parseInt(parts[3]); if (x1 == 0 && y1 == 0 && x2 == 0 && y2 ==  Point(x2, y2)); line = br.readLine(); parts = line.split(\" \"); x1 = Integer.parseInt(parts[0]);  line = br.readLine(); parts = line.split(\" \"); x1 = Integer.parseInt(parts[0]); y1 = Integer.parseInt(parts[1]); x2 = Integer.parseInt(parts[2]); y2 = Integer.parseInt(parts[3]); Line l3 = new Line(new Point(x1, y1), new Point(x2, y2)); Point p12 = getIntersection(l1, l2); Point p13 = getIntersection(l1, l3); Point p23 = getIntersection(l2, l3); if (p12 == null || p13 == null ||  p13, p23); if (area < EPS) { System.out.println(\"kyo\"); } else if (area < 100000) { System.out.println(\"syo-kichi\"); } else if (area < 1000000) { System.out.println(\"kichi\"); } else if (area < 1900000) { System.out.println(\"chu-kichi\"); } else { System.out.println(\"dai-kichi\"); } } } }"], "perturbed_original": [" if(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0) return; Point p3=new Point(in.nextDouble(), in.nextDouble()); Point p4=new Point(in.nextDouble(), in.nextDouble()); Point p5=new Point(in.nextDouble(), in.nextDouble()); Point p6=new Point(in.nextDouble(), in.nextDouble()); boolean judge=true; if(!lineCross(p1, p2, p3,  p2)) judge=false; if(judge) { double a1=slanting(p1, p2); double a2=slanting(p3, p4); double x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2); if(a1==-1.123) x1=p1.x; else if(a2==-1.123)  x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2); if(a1==-1.123) x2=p3.x;   if(a1==-1.123) y3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y; double a=x2-x1; double b=y2-y1; double c=x3-x1; double d=y3-y1; double S=Math.abs(a*d-b*c)/2; if(S<EPS) System.out.println(\"kyo\"); else if(S<100000) System.out.println(\"syo-kichi\"); else if(S<1000000) System.out.println(\"kichi\"); else if(S<1900000) System.out.println(\"chu-kichi\"); else System.out.println(\"dai-kichi\"); } else System.out.println(\"kyo\"); } }   } static double slanting(Point p1,Point p2) { if(Math.abs(p1.x-p2.x)<EPS) return -1.123; else return (p1.y-p2.y)/(p1.x-p2.x); } } class Point { double x; double y; Point(double x,double y) { this.x=x; this.y=y; } }"], "original_ll": -0.43642425537109375, "sampled_ll": -0.2557612657546997, "all_perturbed_sampled_ll": [-0.9919077754020691], "all_perturbed_original_ll": [-1.0323346853256226], "perturbed_sampled_ll": -0.9919077754020691, "perturbed_original_ll": -1.0323346853256226, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def cross3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)\ndef outer(x0, y0, x1, y1):\n    return x0*y1 - x1*y0\ndef is_intersection(P0, P1, Q0, Q1):\n    C0 = cross3(P0, P1, Q0)\n    C1 = cross3(P0, P1, Q1)\n    D0 = cross3(Q0, Q1, P0)\n    D1 = cross3(Q0, Q1, P1)\n    if C0 == C1 == 0:\n        return 0\n    return C0 * C1 <= 0 and D0 * D1 <= 0\ndef cross_point(P0, Q0, P1, Q1):\n    x0, y0 = P0; x1, y1 = Q0\n    x2, y2 = P1; x3, y3 = Q1\n    dx0 = x1 - x0\n    dy0 = y1 - y0\n    dx1 = x3 - x2\n    dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if s < 0:\n        s = -s\n        sm = -sm\n    if s == 0:\n        x = x0\n        y = y0\n    else:\n        x = x0 + s*dx0/sm\n        y = y0 + s*dy0/sm\n    return x, y\nwhile 1:\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == y1 == x2 == y2 == 0:\n        break\n    P1 = (x1, y1); Q1 = (x2, y2)\n    x3, y3, x4, y4 = map(int, input().split())\n    P2 = (x3, y3); Q2 = (x4, y4)\n    x5, y5, x6, y6 = map(int, input().split())\n    P3 = (x5, y5); Q3 = (x6, y6)\n    if (not is_intersection(P1, Q1, P2, Q2)\n            or not is_intersection(P2, Q2, P3, Q3)\n            or not is_intersection(P3, Q3, P1, Q1)):\n        print(\"kyo\")\n        continue\n    p1, q1 = cross_point(P1, Q1, P2, Q2)\n    p2, q2 = cross_point(P2, Q2, P3, Q3)\n    p3, q3 = cross_point(P3, Q3, P1, Q1)\n    S = abs(outer(p2-p1, q2-q1, p3-p1, q3-q1)) / 2.\n    if S < 1e-9:\n        print(\"kyo\")\n    elif S < 100000:\n        print(\"syo-kichi\")\n    elif S < 1000000:\n        print(\"kichi\")\n    elif S < 1900000:\n        print(\"chu-kichi\")\n    else:\n        print(\"dai-kichi\")\n", "sampled": "import sys\nfrom math import isclose\n\ndef line_intersection(x1, y1, x2, y2, x3, y3, x4, y4):\n    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if abs(denom) < 1e-9:\n        return None\n    \n    t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom\n    u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom\n    \n    px = x1 + t * (x2 - x1)\n    py = y1 + t * (y2 - y1)\n    \n    return (px, py)\n\ndef triangle_area(p1, p2, p3):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)\n    return area\n\ndef are_collinear(p1, p2, p3):\n    if p1 is None or p2 is None or p3 is None:\n        return True\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    return area < 1e-6\n\ndef solve(lines):\n    # Get intersection points\n    p1 = line_intersection(*lines[0], *lines[1])\n    p2 = line_intersection(*lines[0], *lines[2])\n    p3 = line_intersection(*lines[1], *lines[2])\n    \n    if p1 is None or p2 is None or p3 is None:\n        return \"kyo\"\n    \n    if are_collinear(p1, p2, p3):\n        return \"kyo\"\n    \n    area = triangle_area(p1, p2, p3)\n    \n    if area < 1e-9:\n        return \"kyo\"\n    elif area < 100000:\n        return \"syo-kichi\"\n    elif area < 1000000:\n        return \"kichi\"\n    elif area < 1900000:\n        return \"chu-kichi\"\n    else:\n        return \"dai-kichi\"\n\nwhile True:\n    line = input().split()\n    if line == ['0', '0', '0', '0']:\n        break\n    \n    lines = []\n    lines.append([int(x) for x in line])\n    for _ in range(2):\n        lines.append([int(x) for x in input().split()])\n    \n    result = solve(lines)\n    print(result)\n", "perturbed_sampled": ["import sys from math import isclose def line_intersection(x1, y1, x2, y2, x3, y3, x4, y4): denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4) if abs(denom) < 1e-9: return None  - (y1 - y2) * (x1 - x3)) / denom px = x1 + t * (x2 - x1) py = y1 + t * (y2 - y1) return (px, py) def triangle_area(p1, p2, p3): x1, y1 = p1 x2, y2 = p2 x3, y3 = p3 area = abs((x1  + x3 * (y1 - y2))   return True x1, y1 = p1 x2, y2 = p2 x3, y3  Get intersection  are_collinear(p1, p2, p3): return \"kyo\" area = triangle_area(p1, p2, p3) if area < 1e-9: return \"kyo\" elif area < 100000: return \"syo-kichi\" elif area < 1000000: return \"kichi\"  True: line = input().split() if line == ['0', '0', '0', '0']:  _ in range(2): lines.append([int(x) for x in input().split()]) result = solve(lines) print(result)"], "perturbed_original": ["def cross3(O, A,  by  - (bx - ox) * (ay - oy) def outer(x0, y0, x1, y1): return x0*y1 - x1*y0 def is_intersection(P0, P1, Q0, Q1): C0  if C0 == C1 == 0: return 0 return C0 * C1 <= 0 and D0 * D1 <= 0 def cross_point(P0, Q0, P1, Q1): x0, y0 = P0; x1, y1 = Q0 x2, y2 = P1; x3, y3 = Q1 dx0 = x1 - x0  (x0-x2)*dy1 sm = dx0*dy1 -  -sm if s == 0: x = x0 y = y0  s*dy0/sm return x, y while 1: x1, y1, x2, y2 = map(int, input().split()) if x1 == y1 ==  Q1 = (x2, y2) x3, y3, x4, y4 = map(int, input().split()) P2 = (x3, y3); Q2 =  = (x5, y5); Q3 = (x6, y6) if (not is_intersection(P1, Q1, P2, Q2) or not  print(\"kyo\") continue p1, q1  S = abs(outer(p2-p1, q2-q1, p3-p1, q3-q1)) / 2.  print(\"chu-kichi\") else: print(\"dai-kichi\")"], "original_ll": -0.5566016435623169, "sampled_ll": -0.4863891303539276, "all_perturbed_sampled_ll": [-1.2465354204177856], "all_perturbed_original_ll": [-1.7461919784545898], "perturbed_sampled_ll": -1.2465354204177856, "perturbed_original_ll": -1.7461919784545898, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#define _CRT_SECURE_NO_WARNINGS\n//#define _USE_MATH_DEFINES\n#include<stdio.h>\n//#include<stdlib.h>\n//#include<math.h>\n//#include<string.h>\n#define P(type,x) fprintf(stdout,\"%\"#type\"\\n\",x)\nint main() {\n\tint n, l, m, r, A[100] = {}, i,key,cnt;\n\twhile (~fscanf(stdin, \"%d\", &n), n) {\n\t\tl = cnt = 0, r = n - 1;\n\t\tfor (i = 0; i < n; i++) fscanf(stdin, \"%d\", &A[i]);\n\t\tfscanf(stdin, \"%d\", &key);\n\t\twhile (l <= r) {\n\t\t\tm = (l + r) / 2;\n\t\t\tcnt++;\n\t\t\tif (A[m] > key) r = m-1;\n\t\t\telse if (A[m] < key) l = m+1;\n\t\t\telse break;\n\t\t}\n\t\tP(d, cnt);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint binarySearch(int arr[], int n, int target) {\n    int left = 0;\n    int right = n - 1;\n    int count = 0;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        count++;\n        \n        if (arr[mid] == target) {\n            return count;\n        } else if (target < arr[mid]) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int arr[100];\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &arr[i]);\n        }\n        \n        int k;\n        scanf(\"%d\", &k);\n        \n        int result = binarySearch(arr, n, k);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int binarySearch(int arr[], int n, int target) { int left = 0; int right = n -   (target < arr[mid])  = mid + 1; } } return count; } int  n != 0) { int arr[100]; for (int i = 0; i < n; i++) { scanf(\"%d\", &arr[i]); } int k; scanf(\"%d\", &k); int result = binarySearch(arr, n, k); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#define _CRT_SECURE_NO_WARNINGS //#define _USE_MATH_DEFINES #include<stdio.h> //#include<stdlib.h> //#include<math.h> //#include<string.h> #define P(type,x) fprintf(stdout,\"%\"#type\"\\n\",x) int main() { int n, l, m, r, A[100] = {}, i,key,cnt; while (~fscanf(stdin, \"%d\", &n), n) { l = cnt =  i < n;  r)  (A[m] > key) r = m-1; else if  cnt); } return 0; }"], "original_ll": -0.9978989958763123, "sampled_ll": -0.4018988609313965, "all_perturbed_sampled_ll": [-1.3162956237792969], "all_perturbed_original_ll": [-2.249141216278076], "perturbed_sampled_ll": -1.3162956237792969, "perturbed_original_ll": -2.249141216278076, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n    Main(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(sc.hasNext()){\n\t    int r = sc.nextInt(), t, cnt=1, l=0;\n\t    if(r == 0) break;\n\t    int[] ary = new int[r+1];\n\t    \n\t    for(int i = 0; i < r; i++)\n\t\tary[i] = sc.nextInt();\n\t    t = sc.nextInt();\n\t    r--;\n\n\t    while(l <= r){\n\t\tint v = (l+r)/2;\n\n\t\tif(ary[v] == t || l >= r) break;\n\t\telse if(ary[v] < t) l = v+1;\n\t\telse r = v-1;\n\n\t\tcnt++;\n\t    }\n\n\t    System.out.println(Integer.toString(cnt));\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main();\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = sc.nextInt();\n            }\n            \n            int k = sc.nextInt();\n            \n            int count = 0;\n            int left = 0;\n            int right = n - 1;\n            \n            while (left <= right) {\n                int mid = (left + right) / 2;\n                count++;\n                \n                if (arr[mid] == k) {\n                    break;\n                } else if (k < arr[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public   = sc.nextInt(); int count = 0; int left = 0; int right = n - 1; while (left <= right) { int mid = (left + right) / 2; count++; if (arr[mid] == k) { break; } else if (k < arr[mid]) { right = mid - 1; } else { left = mid + 1; } } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public  0; i < r; i++) ary[i] = sc.nextInt(); t = sc.nextInt(); r--; while(l <= r){ int v = (l+r)/2; if(ary[v] == t ||  v+1; else r = v-1; cnt++; } System.out.println(Integer.toString(cnt)); } } public static void main(String[] args){ new Main(); } }"], "original_ll": -1.1038419008255005, "sampled_ll": -0.3695048689842224, "all_perturbed_sampled_ll": [-1.0748950242996216], "all_perturbed_original_ll": [-2.4135005474090576], "perturbed_sampled_ll": -1.0748950242996216, "perturbed_original_ll": -2.4135005474090576, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\ndef f(check, n, L, count):\n    count += 1\n    median = int(math.floor(float(n-1)/2))\n    if len(L) == 1:\n        return count\n    elif L[median] == check:\n        return count\n    elif L[median] < check:\n        L = L[median+1:]\n    elif check < L[median]:\n        L = L[:median]\n    n = len(L)\n    return f(check, n, L, count)\n\nwhile True:\n    n = int(raw_input())\n    if n == 0: break\n    L = [int(raw_input()) for i in range(n)]\n    check = int(raw_input())\n    print f(check, n, L, 0)", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    arr = []\n    for _ in range(n):\n        arr.append(int(input()))\n    \n    k = int(input())\n    \n    left = 0\n    right = n - 1\n    count = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        count += 1\n        \n        if arr[mid] == k:\n            break\n        elif k < arr[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    print(count)\n", "perturbed_sampled": ["while True: n =  0 right = n - 1 count = 0 while left <= right: mid = (left + right) // 2 count += 1 if arr[mid] == k: break elif k  mid + 1 print(count)"], "perturbed_original": ["import math def f(check, n,  == 1:  < check: L = L[median+1:] elif check < L[median]: L = L[:median] n = len(L) return f(check, n, L, count) while  = [int(raw_input()) for i in range(n)] check = int(raw_input()) print f(check, n, L, 0)"], "original_ll": -0.9170764684677124, "sampled_ll": -0.5428446531295776, "all_perturbed_sampled_ll": [-2.138988733291626], "all_perturbed_original_ll": [-2.313180685043335], "perturbed_sampled_ll": -2.138988733291626, "perturbed_original_ll": -2.313180685043335, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][0]=0;q[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){\n\t\t\t\tif(FR>0 && cd!=14)fprintf(stderr,\"%d?\\n\",cd);\n\t\t\t\tans=(int)cd+q[FR][13];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20 && ans<9999)fprintf(stderr,\"ans:%d?\\n\",ans);\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_DEPTH 20\n\ntypedef struct {\n    int board[13];\n    int zero1, zero2;\n} State;\n\nint goal[13] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0};\n\nint adj[13][5] = {\n    {1, -1, -1, -1, -1},     // 0\n    {0, 2, 3, -1, -1},       // 1\n    {1, 4, -1, -1, -1},      // 2\n    {1, 4, 5, -1, -1},       // 3\n    {2, 3, 6, 8, -1},        // 4\n    {3, 6, 9, -1, -1},       // 5\n    {4, 5, 7, 10, -1},       // 6\n    {6, 8, 11, -1, -1},      // 7\n    {4, 7, 11, -1, -1},      // 8\n    {5, 10, -1, -1, -1},     // 9\n    {6, 9, 11, -1, -1},      // 10\n    {7, 8, 10, 12, -1},      // 11\n    {11, -1, -1, -1, -1}     // 12\n};\n\nint isGoal(State *s) {\n    for (int i = 0; i < 13; i++) {\n        if (s->board[i] != goal[i]) return 0;\n    }\n    return 1;\n}\n\ntypedef struct {\n    State state;\n    int depth;\n} QueueItem;\n\nQueueItem queue[10000000];\nint qfront, qback;\n\nunsigned long long hash(State *s) {\n    unsigned long long h = 0;\n    for (int i = 0; i < 13; i++) {\n        h = h * 13 + s->board[i];\n    }\n    return h;\n}\n\nint visited[1 << 24];\n\nint getVisitedIndex(unsigned long long h) {\n    return (int)(h % (1 << 24));\n}\n\nint solve(State *init) {\n    if (isGoal(init)) return 0;\n    \n    memset(visited, 0, sizeof(visited));\n    qfront = qback = 0;\n    \n    queue[qback].state = *init;\n    queue[qback].depth = 0;\n    qback++;\n    \n    unsigned long long h = hash(init);\n    visited[getVisitedIndex(h)] = 1;\n    \n    while (qfront < qback) {\n        QueueItem cur = queue[qfront++];\n        \n        if (cur.depth >= MAX_DEPTH) continue;\n        \n        int zeros[2] = {cur.state.zero1, cur.state.zero2};\n        \n        for (int zi = 0; zi < 2; zi++) {\n            int zpos = zeros[zi];\n            \n            for (int i = 0; adj[zpos][i] != -1; i++) {\n                int npos = adj[zpos][i];\n                \n                State next = cur.state;\n                next.board[zpos] = next.board[npos];\n                next.board[npos] = 0;\n                \n                if (zi == 0) {\n                    next.zero1 = npos;\n                } else {\n                    next.zero2 = npos;\n                }\n                \n                if (next.zero1 > next.zero2) {\n                    int tmp = next.zero1;\n                    next.zero1 = next.zero2;\n                    next.zero2 = tmp;\n                }\n                \n                if (isGoal(&next)) {\n                    return cur.depth + 1;\n                }\n                \n                h = hash(&next);\n                int idx = getVisitedIndex(h);\n                if (!visited[idx]) {\n                    visited[idx] = 1;\n                    queue[qback].state = next;\n                    queue[qback].depth = cur.depth + 1;\n                    qback++;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int first;\n    while (scanf(\"%d\", &first) == 1 && first != -1) {\n        State init;\n        init.board[0] = first;\n        \n        for (int i = 1; i < 13; i++) {\n            scanf(\"%d\", &init.board[i]);\n        }\n        \n        init.zero1 = -1;\n        init.zero2 = -1;\n        for (int i = 0; i < 13; i++) {\n            if (init.board[i] == 0) {\n                if (init.zero1 == -1) init.zero1 = i;\n                else init.zero2 = i;\n            }\n        }\n        \n        int result = solve(&init);\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  int board[13]; int zero1, zero2; }  = { {1, -1, -1, -1, -1}, // 0 {0, 2, 3, -1, -1}, // 1 {1, 4,  // 3 {2, 3, 6, 8, -1}, // 4 {3, 6, 9, -1, -1}, // 5 {4, 5, 7, 10, -1}, // 6 {6, 8, 11, -1,    i < 13; i++)  } typedef struct { State state; int  long hash(State *s) { unsigned long long h = 0; for (int i = 0; i < 13; i++) { h = h  << 24]; int getVisitedIndex(unsigned long long h)  *init) { if (isGoal(init)) return 0; memset(visited, 0, sizeof(visited)); qfront = qback = 0; queue[qback].state = *init;  cur  {cur.state.zero1, cur.state.zero2}; for (int zi = 0; zi < 2; zi++) { int zpos = zeros[zi]; for (int i = 0; adj[zpos][i] != -1; i++) { int npos = adj[zpos][i]; State next = cur.state; next.board[zpos] = next.board[npos]; next.board[npos] = 0; if (zi == 0) { next.zero1 = npos; } else {  h = hash(&next); int idx = getVisitedIndex(h); if (!visited[idx]) { visited[idx] = 1;  } } } return -1; } int main() { int first; while (scanf(\"%d\", &first) == 1 && first != -1) { State init; init.board[0] = first; for (int i = 1; i < 13; i++) { scanf(\"%d\", &init.board[i]); } init.zero1 = -1; init.zero2 = -1; for (int  i; else init.zero2 = i; }  printf(\"NA\\n\"); } else { printf(\"%d\\n\", result); } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include  steps; } puzz; int q[10000000][14],size[30000],size2[30000]; long long int FR,TO,SW; puzz* hash[30000][100],hash2[30000][100]; void swap (int* x,int* y){ int z; z=*x; *x=*y; *y=z; } long long int convert(int a[]){ long long int ret=0; int i; for(i=0;i<13;i++)ret=ret*13+a[i]; return ret; } void hashadd(long long int code,int step){ int ccc=code%30000; puzz* ppp=(puzz*)malloc(sizeof(puzz)); ppp->code=code; ppp->steps=step; if(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;} hash[ccc][size[ccc]]=ppp; size[ccc]++;  for(i--;i>=0;i--){ if(hash[ccc][i]->code==code)return hash[ccc][i]->steps; } return -1; } void mark(int x,int  || hashsearch(cd)<0){ for(k=0;k<14;k++){q[TO][k]=q[FR][k];} q[TO][13]++; if(SW==0)hashadd(cd,q[TO][13]);  } int main(){ int i,ans; long long int  while(scanf(\"%d\",&q[0][0])*q[0][0]>=0){ for(i=1;i<13;i++)scanf(\"%d\",&q[0][i]); q[0][13]=0;FR=0;TO=1;SW=1;ans=9999; //for(i=0;i<30000;i++)size2[i]=0; while(FR<TO){  0; }"], "original_ll": -0.8479455709457397, "sampled_ll": -0.4077097475528717, "all_perturbed_sampled_ll": [-1.4015244245529175], "all_perturbed_original_ll": [-1.5813754796981812], "perturbed_sampled_ll": -1.4015244245529175, "perturbed_original_ll": -1.5813754796981812, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] adj = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };\n\t\tString g = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tint step = 1;\n\t\tdeque.offer(g);\n\t\tm.put(g, 0);\n\t\twhile (!deque.isEmpty() && step < 10) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int k = 0; k < size; k++) {\n\t\t\t\tString s = deque.pop();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (c[i] == '0') {\n\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\tc[i] = c[adj[i][j]];\n\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\tString n = String.valueOf(c);\n\t\t\t\t\t\t\tif (!m.containsKey(n)) {\n\t\t\t\t\t\t\t\tm.put(n, step);\n\t\t\t\t\t\t\t\tdeque.offer(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[adj[i][j]] = c[i];\n\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint p = scanner.nextInt();\n\t\t\tif (p == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cc = new char[13];\n\t\t\tcc[0] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tp = scanner.nextInt();\n\t\t\t\tcc[i] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\t}\n\t\t\tString st = String.valueOf(cc);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tdeque.clear();\n\t\t\tdeque.offer(st);\n\t\t\tstep = 0;\n\t\t\tboolean flag = false;\n\t\t\tString ans = \"\";\n\t\t\tloop: while (!deque.isEmpty() && step < 10) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tfor (int w = 0; w < size; w++) {\n\t\t\t\t\tString s = deque.pop();\n\t\t\t\t\tif (m.containsKey(s)) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tans = s;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] cs = s.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (cs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\t\tcs[i] = cs[adj[i][j]];\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = '0';\n\t\t\t\t\t\t\t\tString news = String.valueOf(cs);\n\t\t\t\t\t\t\t\tif (!set.contains(news)) {\n\t\t\t\t\t\t\t\t\tset.add(news);\n\t\t\t\t\t\t\t\t\tdeque.offer(news);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = cs[i];\n\t\t\t\t\t\t\t\tcs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? m.get(ans) : \"NA\");\n\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static final int[] GOAL = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0};\n    \n    static class State {\n        int[] board;\n        int steps;\n        \n        State(int[] board, int steps) {\n            this.board = board.clone();\n            this.steps = steps;\n        }\n        \n        String hash() {\n            return Arrays.toString(board);\n        }\n    }\n    \n    static int[] readInput(Scanner sc) {\n        int[] board = new int[13];\n        int idx = 0;\n        \n        // Row 1: 1 element\n        board[idx++] = sc.nextInt();\n        \n        // Row 2: 3 elements\n        for (int i = 0; i < 3; i++) {\n            board[idx++] = sc.nextInt();\n        }\n        \n        // Row 3: 5 elements\n        for (int i = 0; i < 5; i++) {\n            board[idx++] = sc.nextInt();\n        }\n        \n        // Row 4: 3 elements\n        for (int i = 0; i < 3; i++) {\n            board[idx++] = sc.nextInt();\n        }\n        \n        // Row 5: 1 element\n        board[idx++] = sc.nextInt();\n        \n        return board;\n    }\n    \n    static int[][] getNeighbors() {\n        int[][] neighbors = new int[13][];\n        neighbors[0] = new int[]{1};\n        neighbors[1] = new int[]{0, 2, 4};\n        neighbors[2] = new int[]{1, 3, 5};\n        neighbors[3] = new int[]{2, 6};\n        neighbors[4] = new int[]{1, 5, 7};\n        neighbors[5] = new int[]{2, 4, 6, 8};\n        neighbors[6] = new int[]{3, 5, 9};\n        neighbors[7] = new int[]{4, 8, 10};\n        neighbors[8] = new int[]{5, 7, 9, 11};\n        neighbors[9] = new int[]{6, 8, 12};\n        neighbors[10] = new int[]{7, 11};\n        neighbors[11] = new int[]{8, 10, 12};\n        neighbors[12] = new int[]{9, 11};\n        return neighbors;\n    }\n    \n    static int solve(int[] initial) {\n        if (Arrays.equals(initial, GOAL)) {\n            return 0;\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        State start = new State(initial, 0);\n        queue.offer(start);\n        visited.add(start.hash());\n        \n        int[][] neighbors = getNeighbors();\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.steps >= 20) {\n                continue;\n            }\n            \n            // Find empty spaces\n            List<Integer> empties = new ArrayList<>();\n            for (int i = 0; i < 13; i++) {\n                if (curr.board[i] == 0) {\n                    empties.add(i);\n                }\n            }\n            \n            // Try moving tiles into empty spaces\n            for (int emptyPos : empties) {\n                for (int neighbor : neighbors[emptyPos]) {\n                    if (curr.board[neighbor] != 0) {\n                        int[] newBoard = curr.board.clone();\n                        newBoard[emptyPos] = newBoard[neighbor];\n                        newBoard[neighbor] = 0;\n                        \n                        if (Arrays.equals(newBoard, GOAL)) {\n                            return curr.steps + 1;\n                        }\n                        \n                        String hash = Arrays.toString(newBoard);\n                        if (!visited.contains(hash)) {\n                            visited.add(hash);\n                            queue.offer(new State(newBoard, curr.steps + 1));\n                        }\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int first = sc.nextInt();\n            if (first == -1) break;\n            \n            int[] board = new int[13];\n            board[0] = first;\n            \n            for (int i = 1; i < 13; i++) {\n                board[i] = sc.nextInt();\n            }\n            \n            int result = solve(board);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static final int[] GOAL = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,  State(int[] board, int steps) { this.board = board.clone(); this.steps = steps;  readInput(Scanner sc) { int[] board  1 element board[idx++] = sc.nextInt(); // Row 2: 3 elements for (int i = 0; i < 3; i++) {  (int i = 0; i < 5; i++) { board[idx++] = sc.nextInt(); } // Row 4:  1 element board[idx++] = sc.nextInt(); return board; } static int[][] getNeighbors() { int[][] neighbors =  2, 4}; neighbors[2] = new int[]{1, 3, 5}; neighbors[3] = new  new int[]{2, 4, 6,  int[]{4, 8, 10}; neighbors[8] = new int[]{5, 7, 9, 11}; neighbors[9] = new int[]{6, 8, 12}; neighbors[10] = new int[]{7, 11}; neighbors[11] = new int[]{8, 10, 12};  solve(int[] initial) { if (Arrays.equals(initial, GOAL)) { return 0; } Queue<State> queue = new  State(initial, 0); queue.offer(start); visited.add(start.hash()); int[][] neighbors = getNeighbors(); while (!queue.isEmpty()) { State curr = queue.poll(); if (curr.steps >= 20) { continue; } // Find empty  0) { empties.add(i); } }  : empties) { for (int neighbor : neighbors[emptyPos]) { if (curr.board[neighbor] != 0) { int[] newBoard  GOAL)) { return curr.steps +  queue.offer(new State(newBoard, curr.steps + 1)); } } } } } return -1;  new Scanner(System.in);  -1) break; int[]  -1) { System.out.println(\"NA\"); } else { System.out.println(result); } } sc.close(); } }"], "perturbed_original": ["import java.util.ArrayDeque; import java.util.Deque; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Scanner; import java.util.Set; public  Main().run(); } private void run() { Scanner scanner = new  6, 9 }, { 2, 5,  7 }, { 5, 10 },  {  && step  = deque.pop(); char[] c = s.toCharArray(); for (int i = 0; i < 13; i++) { if (c[i] == '0') { for (int j = 0;   deque.offer(n); } c[adj[i][j]] = c[i]; c[i] = '0'; } } } } step++; } while  break; char[] cc = new char[13]; cc[0] = p == 0  p = scanner.nextInt(); cc[i] = p == 0 ? '0' : (char) (p - 1 + 'A'); } String st = String.valueOf(cc);  boolean flag = false; String ans = \"\"; loop: while (!deque.isEmpty() && step < 10) { int size = deque.size(); for (int w = 0; w < size; w++) { String s = deque.pop(); if (m.containsKey(s)) { flag = true; ans = s; break loop; } char[] cs = s.toCharArray(); for (int i = 0; i <  = cs[adj[i][j]]; cs[adj[i][j]] = '0'; String news = String.valueOf(cs); if (!set.contains(news)) { set.add(news); deque.offer(news); } cs[adj[i][j]] = cs[i]; cs[i] = '0'; } } } } step++; } System.out.println(flag ? m.get(ans) : \"NA\"); } } }"], "original_ll": -0.5659579038619995, "sampled_ll": -0.34490281343460083, "all_perturbed_sampled_ll": [-1.462007761001587], "all_perturbed_original_ll": [-1.5258662700653076], "perturbed_sampled_ll": -1.462007761001587, "perturbed_original_ll": -1.5258662700653076, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from math import factorial\nfrom Queue import PriorityQueue\n\nFACTORIAL=[factorial(i) for i in xrange(13)]\nLEFT,UP,RIGHT,DOWN=0,1,2,3\nMOVE=[[0] for u in xrange(13)]\nMOVE[0] =[-1,-1,-1, 2]\nMOVE[1] =[-1,-1, 2, 5]\nMOVE[2] =[ 1, 0, 3, 6]\nMOVE[3] =[ 2,-1,-1, 7] \nMOVE[4] =[-1,-1, 5,-1]\nMOVE[5] =[ 4, 1, 6, 9]\nMOVE[6] =[ 5, 2, 7,10]\nMOVE[7] =[ 6, 3, 8,11]\nMOVE[8] =[ 7,-1,-1,-1]\nMOVE[9] =[-1, 5,10,-1]\nMOVE[10]=[ 9, 6,11,12]\nMOVE[11]=[10, 7,-1,-1]\nMOVE[12]=[-1,10,-1,-1]\n\ndef hash(cell):\n    work = cell[:]\n    hash = 0\n    for i in xrange(12):\n        hash += work[i] * FACTORIAL[13-1-i]\n        for ii in xrange(i+1,13):\n            if work[ii]>work[i]:\n                work[ii]-=1\n    return hash\n\ndef dehash(key):\n    cell=[]\n    for i in xrange(13):\n        cell.append(key/FACTORIAL[13-1-i])\n        key %= FACTORIAL[13-1-i]\n    for i in xrange(13-1,-1,-1):\n        for ii in xrange(i+1,13):\n            if cell[i]<=cell[ii]:\n                cell[ii]+=1\n    return cell\n\ndef evaluate(cell):\n    point=[[0,2],\n           [1,1],[1,2],[1,3],\n           [2,0],[2,1],[2,2],[2,3],[2,4],\n           [3,1],[3,2],[3,3],\n           [4,2]]\n    eva=0\n    for i in xrange(0,13):\n        if not (cell[i]==0 or cell[i]==12):\n            eva+=abs(point[cell[i]][0]-point[i][0])\n            eva+=abs(point[cell[i]][1]-point[i][1])\n    return eva\n\nANS_HASH=[hash([0,1,2,3,4,5,6,7,8,9,10,11,12]),hash([12,1,2,3,4,5,6,7,8,9,10,11,0])]          \n\nwhile True:\n    p=[input()]\n    if p==[-1]:\n        break\n    for u in xrange(4):\n        for pp in map(int,raw_input().split()):\n            p.append(pp)\n    p[p.index(0)]=12\n    pq = PriorityQueue()\n    pq.put([evaluate(p),hash(p),0])\n    visited={}\n    visited[hash(p)]=True\n    ans=0 if hash(p) in ANS_HASH else \"NA\"\n    #cur=[eva,hashkey,step]\n    while not pq.empty():\n        eva,cur_hash,cur_step=pq.get()\n        cur_cell=dehash(cur_hash)\n        if not (eva<=20 and ans==\"NA\"):\n            break\n        for i in xrange(13):\n            if cur_cell[i]==0 or cur_cell[i]==12:\n                for ii in [LEFT,UP,RIGHT,DOWN]:\n                    if not MOVE[i][ii]==-1:\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n                        hashkey=hash(cur_cell)\n                        if not hashkey in visited:\n                            if hashkey in ANS_HASH:\n                                ans=cur_step+1\n                                break\n                            pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1])\n                            visited[hashkey]=True\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n    print ans", "sampled": "from collections import deque\n\ndef read_puzzle():\n    line = input().strip()\n    if line == '-1':\n        return None\n    \n    puzzle = []\n    puzzle.append(list(map(int, line.split())))\n    puzzle.append(list(map(int, input().split())))\n    puzzle.append(list(map(int, input().split())))\n    puzzle.append(list(map(int, input().split())))\n    input()  # empty line\n    \n    return puzzle\n\ndef puzzle_to_tuple(puzzle):\n    result = []\n    for row in puzzle:\n        result.extend(row)\n    return tuple(result)\n\ndef tuple_to_puzzle(t):\n    puzzle = []\n    puzzle.append(list(t[0:1]))\n    puzzle.append(list(t[1:4]))\n    puzzle.append(list(t[4:9]))\n    puzzle.append(list(t[9:12]))\n    return puzzle\n\ndef get_neighbors(puzzle):\n    neighbors = []\n    \n    # Find all zeros\n    zeros = []\n    for i in range(len(puzzle)):\n        for j in range(len(puzzle[i])):\n            if puzzle[i][j] == 0:\n                zeros.append((i, j))\n    \n    # For each zero, find adjacent numbers that can move\n    for zi, zj in zeros:\n        # Check all 4 directions\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        for di, dj in directions:\n            ni, nj = zi + di, zj + dj\n            if 0 <= ni < len(puzzle) and 0 <= nj < len(puzzle[ni]):\n                if puzzle[ni][nj] != 0:\n                    # Make a move\n                    new_puzzle = [row[:] for row in puzzle]\n                    new_puzzle[zi][zj] = new_puzzle[ni][nj]\n                    new_puzzle[ni][nj] = 0\n                    neighbors.append(new_puzzle)\n    \n    return neighbors\n\ndef solve_puzzle(start_puzzle):\n    goal = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0)\n    \n    start = puzzle_to_tuple(start_puzzle)\n    \n    if start == goal:\n        return 0\n    \n    queue = deque([(start_puzzle, 0)])\n    visited = {start}\n    \n    while queue:\n        current_puzzle, steps = queue.popleft()\n        \n        if steps >= 20:\n            continue\n        \n        for neighbor in get_neighbors(current_puzzle):\n            neighbor_tuple = puzzle_to_tuple(neighbor)\n            \n            if neighbor_tuple == goal:\n                return steps + 1\n            \n            if neighbor_tuple not in visited:\n                visited.add(neighbor_tuple)\n                queue.append((neighbor, steps + 1))\n    \n    return -1\n\nwhile True:\n    puzzle = read_puzzle()\n    if puzzle is None:\n        break\n    \n    result = solve_puzzle(puzzle)\n    if result == -1:\n        print(\"NA\")\n    else:\n        print(result)\n", "perturbed_sampled": ["from  == '-1': return None puzzle = [] puzzle.append(list(map(int,  line return puzzle def puzzle_to_tuple(puzzle): result = [] for row in puzzle: result.extend(row) return tuple(result) def tuple_to_puzzle(t): puzzle = [] puzzle.append(list(t[0:1])) puzzle.append(list(t[1:4])) puzzle.append(list(t[4:9])) puzzle.append(list(t[9:12])) return puzzle def get_neighbors(puzzle): neighbors = [] # Find all zeros zeros = [] for i in range(len(puzzle)): for j in range(len(puzzle[i])): if puzzle[i][j] == 0: zeros.append((i,  move for zi, zj  0), (1, 0),  nj  ni < len(puzzle) and 0 <= nj < len(puzzle[ni]): if  for row in puzzle] new_puzzle[zi][zj] = new_puzzle[ni][nj] new_puzzle[ni][nj] = 0 neighbors.append(new_puzzle) return neighbors def solve_puzzle(start_puzzle): goal = (1,  0, 0) start  = queue.popleft() if steps >= 20: continue for neighbor in get_neighbors(current_puzzle): neighbor_tuple =  neighbor_tuple not in visited: visited.add(neighbor_tuple) queue.append((neighbor, steps + 1)) return -1 while True: puzzle =  result == -1: print(\"NA\") else: print(result)"], "perturbed_original": ["from math import factorial from Queue import PriorityQueue FACTORIAL=[factorial(i) for i in xrange(13)] LEFT,UP,RIGHT,DOWN=0,1,2,3 MOVE=[[0] for u in xrange(13)] MOVE[0] =[-1,-1,-1, 2] MOVE[1] =[-1,-1, 2, 5] MOVE[2] =[ 1, 0, 3, 6] MOVE[3] =[ 2,-1,-1,  MOVE[6] =[ 5, 2, 7,10] MOVE[7] =[  9, 6,11,12] MOVE[11]=[10, 7,-1,-1] MOVE[12]=[-1,10,-1,-1] def hash(cell): work = cell[:]  * FACTORIAL[13-1-i] for ii in xrange(i+1,13): if  xrange(13): cell.append(key/FACTORIAL[13-1-i]) key %= FACTORIAL[13-1-i] for i in xrange(13-1,-1,-1): for ii in xrange(i+1,13): if cell[i]<=cell[ii]: cell[ii]+=1 return cell def evaluate(cell): point=[[0,2], [1,1],[1,2],[1,3], [2,0],[2,1],[2,2],[2,3],[2,4], [3,1],[3,2],[3,3], [4,2]] eva=0 for i in xrange(0,13): if not (cell[i]==0 or cell[i]==12):  pq.empty(): eva,cur_hash,cur_step=pq.get() cur_cell=dehash(cur_hash) if not (eva<=20 and ans==\"NA\"): break for i in xrange(13): if cur_cell[i]==0 or cur_cell[i]==12: for ii in  cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i] print ans"], "original_ll": -0.8712171316146851, "sampled_ll": -0.5256608128547668, "all_perturbed_sampled_ll": [-1.7370185852050781], "all_perturbed_original_ll": [-1.6304421424865723], "perturbed_sampled_ll": -1.7370185852050781, "perturbed_original_ll": -1.6304421424865723, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "double g[100][100],G[100],H[100],a;main(n,m,i,j){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%.2f\\n\",a)){for(i=n;i--;G[i]=1)for(j=n;j--;)scanf(\"%lf\",g[i]+j);for(;--m;memcpy(G,H,8*n))for(i=n;i--;)for(H[i]=0,j=n;j--;a>H[i]?H[i]=a:0)a=G[j]*g[j][i];for(a=0;n--;)G[n]>a?a=G[n]:0;}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, m;\n    double g[101][101];\n    double dp[101][101];\n    \n    while (scanf(\"%d %d\", &n, &m) == 2) {\n        if (n == 0 && m == 0) break;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                scanf(\"%lf\", &g[i][j]);\n            }\n        }\n        \n        memset(dp, 0, sizeof(dp));\n        \n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = 1.0;\n        }\n        \n        for (int step = 2; step <= m; step++) {\n            for (int curr = 1; curr <= n; curr++) {\n                dp[step][curr] = 0.0;\n                for (int prev = 1; prev <= n; prev++) {\n                    double val = dp[step-1][prev] * g[prev][curr];\n                    if (val > dp[step][curr]) {\n                        dp[step][curr] = val;\n                    }\n                }\n            }\n        }\n        \n        double max_size = 0.0;\n        for (int i = 1; i <= n; i++) {\n            if (dp[m][i] > max_size) {\n                max_size = dp[m][i];\n            }\n        }\n        \n        printf(\"%.2lf\\n\", max_size);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n, m; double g[101][101]; double dp[101][101]; while (scanf(\"%d %d\", &n, &m) == 2) { if (n  =  1; j <= n; j++) { scanf(\"%lf\", &g[i][j]); } } memset(dp, 0, sizeof(dp)); for (int i = 1; i <= n; i++) { dp[1][i] =  n;  prev <= n; prev++) { double val = dp[step-1][prev] * g[prev][curr]; if (val > dp[step][curr]) { dp[step][curr] = val; } } } }  max_size = dp[m][i]; } } printf(\"%.2lf\\n\", max_size); } return 0; }"], "perturbed_original": ["double g[100][100],G[100],H[100],a;main(n,m,i,j){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%.2f\\n\",a)){for(i=n;i--;G[i]=1)for(j=n;j--;)scanf(\"%lf\",g[i]+j);for(;--m;memcpy(G,H,8*n))for(i=n;i--;)for(H[i]=0,j=n;j--;a>H[i]?H[i]=a:0)a=G[j]*g[j][i];for(a=0;n--;)G[n]>a?a=G[n]:0;}exit(0);}"], "original_ll": -1.8046499490737915, "sampled_ll": -0.394748717546463, "all_perturbed_sampled_ll": [-1.3077597618103027], "all_perturbed_original_ll": [-1.8046499490737915], "perturbed_sampled_ll": -1.3077597618103027, "perturbed_original_ll": -1.8046499490737915, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static int n, m;\n    static double[][] dp, table;\n\n    public static void main(String[] args) {\n        while(read()){\n            solve();\n        }\n\n    }\n\n    static boolean read(){\n        if(!sc.hasNext())return false;\n        n = sc.nextInt();\n        m = sc.nextInt();\n        if(n == 0 || m == 0)return false;\n        dp = new double[m][n];\n        table = new double[m][n];\n\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                table[i][j] = sc.nextDouble();\n            }\n        }\n\n        for(int i = 0; i < 1; i++){\n            for(int j = 0; j < n; j++){\n                dp[i][j] = 1.0;\n            }\n        }\n\n        return true;\n    }\n\n    static void solve(){\n        int index = 0;\n        double value = 0.0, res = 0.0;\n        double[] array = new double[n];\n        for(int i = 0; i < m-1; i++){\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < n; k++){\n                    array[k] = table[j][k];\n                }\n                for(int k = 0; k < n; k++){\n                    if(value < array[k]){\n                        index = k;\n                        value = array[k];\n                    }\n                }\n                dp[i+1][index] = Math.max(dp[i+1][index], value*dp[i][j]);\n            }\n        }\n\n        for(int j = 0; j < n; j++){\n            res = Math.max(res, dp[m-1][j]);\n        }\n        System.out.printf(\"%.2f\\n\", res);\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) break;\n            \n            double[][] g = new double[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = sc.nextDouble();\n                }\n            }\n            \n            if (m == 1) {\n                System.out.println(\"1.00\");\n                continue;\n            }\n            \n            // dp[step][lastFertilizer] = maximum size after 'step' applications with last fertilizer being 'lastFertilizer'\n            double[][] dp = new double[m + 1][n];\n            \n            // Initialize: after 1 application, size is 1.0 for any fertilizer\n            for (int i = 0; i < n; i++) {\n                dp[1][i] = 1.0;\n            }\n            \n            // Fill DP table\n            for (int step = 2; step <= m; step++) {\n                for (int curr = 0; curr < n; curr++) {\n                    dp[step][curr] = 0.0;\n                    for (int prev = 0; prev < n; prev++) {\n                        if (dp[step - 1][prev] > 0) {\n                            dp[step][curr] = Math.max(dp[step][curr], dp[step - 1][prev] * g[prev][curr]);\n                        }\n                    }\n                }\n            }\n            \n            // Find maximum size after m applications\n            double maxSize = 0.0;\n            for (int i = 0; i < n; i++) {\n                maxSize = Math.max(maxSize, dp[m][i]);\n            }\n            \n            System.out.printf(\"%.2f\\n\", maxSize);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" args) { Scanner sc = new  0) break; double[][] g = new double[n][n]; for (int i = 0; i < n; i++) { for (int j = 0;  if (m == 1) { System.out.println(\"1.00\"); continue; } //  being 'lastFertilizer' double[][] dp = new double[m + 1][n]; // Initialize: after 1 application, size is 1.0 for any fertilizer for (int i = 0; i < n; i++) { dp[1][i] = 1.0; } // Fill DP  curr++) { dp[step][curr] = 0.0; for (int prev = 0; prev < n; prev++) {  dp[step - 1][prev] *  m applications double maxSize = 0.0; for (int i = 0; i < n; i++) {  }"], "perturbed_original": ["import java.util.*;  static int n, m; static double[][] dp, table; public static void main(String[] args) { while(read()){  sc.nextInt(); m = sc.nextInt(); if(n == 0 || m == 0)return false; dp  j < n; j++){ table[i][j] = sc.nextDouble(); } } for(int i = 0; i < 1; i++){ for(int j = 0; j < n; j++){ dp[i][j] = 1.0; } } return true;  double[n]; for(int i = 0; i < m-1; i++){ for(int j = 0; j < n; j++){ for(int k = 0; k < n; k++){ array[k] =  if(value < array[k]){ index = k; value = array[k]; } }  System.out.printf(\"%.2f\\n\", res); } }"], "original_ll": -0.54366135597229, "sampled_ll": -0.499393105506897, "all_perturbed_sampled_ll": [-1.8954240083694458], "all_perturbed_original_ll": [-1.5863687992095947], "perturbed_sampled_ll": -1.8954240083694458, "perturbed_original_ll": -1.5863687992095947, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n, m = map(int, raw_input().split())\n    if n==0:\n        exit(0)\n    mat = [map(float, raw_input().split()) for i in xrange(n)]\n    dp = [1.0] * n\n    for t in xrange(m-1):\n        dp2 = [-1.0] * n\n        for i in xrange(n):\n            mat_i = mat[i]; dp_i = dp[i]\n            for j in xrange(n):\n                dp2[j] = max(dp2[j], dp_i * mat_i[j])\n        dp = dp2\n    print \"%.02f\" % round(max(dp), 2)", "sampled": "import sys\n\ndef solve(n, m, growth):\n    if m == 1:\n        return 1.0\n    \n    # dp[step][fertilizer] = maximum growth after 'step' applications, ending with 'fertilizer'\n    dp = [[-1.0] * n for _ in range(m + 1)]\n    \n    # After first application, size is 1.0 for any fertilizer\n    for i in range(n):\n        dp[1][i] = 1.0\n    \n    # For each subsequent application\n    for step in range(2, m + 1):\n        for curr in range(n):\n            # Try all possible previous fertilizers\n            for prev in range(n):\n                if dp[step - 1][prev] > 0:\n                    # Apply fertilizer 'curr' after fertilizer 'prev'\n                    new_size = dp[step - 1][prev] * growth[prev][curr]\n                    dp[step][curr] = max(dp[step][curr], new_size)\n    \n    # Find maximum size after m applications\n    max_size = max(dp[m])\n    return max_size\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    if not line:\n        break\n    \n    parts = line.split()\n    n, m = int(parts[0]), int(parts[1])\n    \n    if n == 0 and m == 0:\n        break\n    \n    growth = []\n    for i in range(n):\n        row = list(map(float, sys.stdin.readline().split()))\n        growth.append(row)\n    \n    result = solve(n, m, growth)\n    print(f\"{result:.2f}\")\n", "perturbed_sampled": ["import sys def solve(n, m, growth): if m  n for _  1.0 for any fertilizer for i in range(n): dp[1][i] = 1.0 # For each subsequent application for step in range(2, m + 1): for curr in range(n): # Try all possible previous fertilizers for prev in range(n): if dp[step - 1][prev] > 0:  Find maximum size after m applications max_size = max(dp[m]) return max_size while True: line = sys.stdin.readline().strip() if not line:  n == 0 and m == 0: break growth = [] for i in  growth) print(f\"{result:.2f}\")"], "perturbed_original": ["while 1: n, m = map(int, raw_input().split()) if n==0: exit(0) mat = [map(float, raw_input().split())  t in xrange(m-1): dp2 = [-1.0] * n for  dp = dp2 print \"%.02f\" % round(max(dp), 2)"], "original_ll": -0.8603090643882751, "sampled_ll": -0.7850139737129211, "all_perturbed_sampled_ll": [-2.682393789291382], "all_perturbed_original_ll": [-2.1679670810699463], "perturbed_sampled_ll": -2.682393789291382, "perturbed_original_ll": -2.1679670810699463, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,T,C[10][2],c,d,O[10][2],t,s,u,v,h,*p;D(h){p=C[s]+h;*p&&T>=O[s][h]?*p=!printf(\"%d%c\",*p,d<n|--c?32:10):0;}main(m){for(;~scanf(\"%d%d\",&m,&n);)for(memset(C,T=c=d=0,80);d<n|c;T++){for(s=m;s--;C[s][1]||D(0))D(1);for(;T>=d*10&d<n&c<m*2;C[s=~u?u:v][h]=++d,O[s][h]=T+t,c++)for(h=scanf(\"%d\",&t),u=v=-1,s=m;h&&s--;)*C[s]?C[s][1]||(*O[s]<T+t?!~v||*O[s]>*O[v]?v=s:0:!~u||*O[s]<*O[u]?u=s:0):(u=s,h=0);}}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SPACES 10\n#define MAX_CARS 100\n\ntypedef struct {\n    int id;\n    int parking_time;\n    int arrival_time;\n    int exit_time;\n} Car;\n\ntypedef struct {\n    int lower_car;\n    int upper_car;\n} Space;\n\ntypedef struct {\n    int car_id;\n    int arrival_time;\n} WaitingCar;\n\nint main() {\n    int m, n;\n    \n    while (1) {\n        scanf(\"%d %d\", &m, &n);\n        if (m == 0 && n == 0) break;\n        \n        Car cars[MAX_CARS];\n        Space spaces[MAX_SPACES];\n        WaitingCar waiting[MAX_CARS];\n        int waiting_count = 0;\n        int output[MAX_CARS];\n        int output_count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &cars[i].parking_time);\n            cars[i].id = i + 1;\n            cars[i].arrival_time = i * 10;\n            cars[i].exit_time = -1;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            spaces[i].lower_car = -1;\n            spaces[i].upper_car = -1;\n        }\n        \n        int current_car = 0;\n        int time = 0;\n        \n        while (output_count < n) {\n            // Process exits\n            for (int s = 0; s < m; s++) {\n                if (spaces[s].lower_car != -1) {\n                    int lower_id = spaces[s].lower_car;\n                    if (cars[lower_id].exit_time == time) {\n                        output[output_count++] = cars[lower_id].id;\n                        spaces[s].lower_car = -1;\n                        \n                        if (spaces[s].upper_car != -1) {\n                            int upper_id = spaces[s].upper_car;\n                            output[output_count++] = cars[upper_id].id;\n                            spaces[s].upper_car = -1;\n                        }\n                    }\n                }\n            }\n            \n            // Add arriving cars to waiting list\n            while (current_car < n && cars[current_car].arrival_time == time) {\n                waiting[waiting_count].car_id = current_car;\n                waiting[waiting_count].arrival_time = time;\n                waiting_count++;\n                current_car++;\n            }\n            \n            // Park waiting cars\n            int parked_any = 1;\n            while (waiting_count > 0 && parked_any) {\n                parked_any = 0;\n                int car_id = waiting[0].car_id;\n                int park_time = cars[car_id].parking_time;\n                \n                int best_space = -1;\n                int best_type = -1; // 0: empty, 1: one car\n                int best_diff = 999999;\n                \n                for (int s = 0; s < m; s++) {\n                    if (spaces[s].lower_car == -1) {\n                        if (best_type == -1 || best_type > 0) {\n                            best_space = s;\n                            best_type = 0;\n                        }\n                    } else if (spaces[s].upper_car == -1) {\n                        int remaining = cars[spaces[s].lower_car].exit_time - time;\n                        int diff;\n                        if (remaining >= park_time) {\n                            diff = remaining - park_time;\n                            if (best_type == -1 || best_type > 1 || (best_type == 1 && diff < best_diff)) {\n                                best_space = s;\n                                best_type = 1;\n                                best_diff = diff;\n                            }\n                        } else {\n                            diff = park_time - remaining;\n                            if (best_type == -1 || (best_type == 2 && diff < best_diff)) {\n                                best_space = s;\n                                best_type = 2;\n                                best_diff = diff;\n                            }\n                        }\n                    }\n                }\n                \n                if (best_space != -1) {\n                    if (spaces[best_space].lower_car == -1) {\n                        spaces[best_space].lower_car = car_id;\n                    } else {\n                        spaces[best_space].upper_car = car_id;\n                    }\n                    cars[car_id].exit_time = time + park_time;\n                    \n                    for (int i = 0; i < waiting_count - 1; i++) {\n                        waiting[i] = waiting[i + 1];\n                    }\n                    waiting_count--;\n                    parked_any = 1;\n                } else {\n                    break;\n                }\n            }\n            \n            time++;\n        }\n        \n        for (int i = 0; i < output_count; i++) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", output[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> #define MAX_SPACES 10 #define MAX_CARS 100 typedef struct { int id; int parking_time; int arrival_time; int exit_time; } Car; typedef <extra_id_9>else { info_count ++<extra_id_10>output_count ;<extra_id_11>0;<extra_id_12>}<extra_id_13>s = 0<extra_id_14>== -1) { info_count ++<extra_id_15>--<extra_id_16>= 0 ;<extra_id_17>1; info_count =<extra_id_18>cars [ { int car_id; int arrival_time; } WaitingCar; int main() { int m,   i + 1;  (int  -1; spaces[i].upper_car = -1; } int current_car = 0; int time = 0; while (output_count < n) { // Process exits for (int s = 0;  int lower_id = spaces[s].lower_car; if (cars[lower_id].exit_time == time) { output[output_count++] = cars[lower_id].id; spaces[s].lower_car = -1; if (spaces[s].upper_car != -1)   time) { waiting[waiting_count].car_id = current_car;  parked_any) { parked_any = 0; int car_id = waiting[0].car_id; int  m; s++) { if (spaces[s].lower_car == -1) { if (best_type == -1 || best_type > 0) { best_space = s; best_type = 0; } } else if (spaces[s].upper_car == -1) { int remaining = cars[spaces[s].lower_car].exit_time - time; int diff;  (best_type == 1 && diff < best_diff)) { best_space = s; best_type = 1; best_diff = diff; } } else { diff = park_time - remaining; if (best_type == -1 || (best_type == 2 && diff < best_diff)) { best_space = s;  if (best_space != -1) { if (spaces[best_space].lower_car == -1) { spaces[best_space].lower_car = car_id; } else { spaces[best_space].upper_car = car_id; } cars[car_id].exit_time = time +  1; i++) { waiting[i] =  { break; } } time++; } for (int i = 0; i < output_count; i++) { if (i > 0) printf(\" \"); printf(\"%d\", output[i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["n,T,C[10][2],c,d,O[10][2],t,s,u,v,h,*p;D(h){p=C[s]+h;*p&&T>=O[s][h]?*p=!printf(\"%d%c\",*p,d<n|--c?32:10):0;}main(m){for(;~scanf(\"%d%d\",&m,&n);)for(memset(C,T=c=d=0,80);d<n|c;T++){for(s=m;s--;C[s][1]||D(0))D(1);for(;T>=d*10&d<n&c<m*2;C[s=~u?u:v][h]=++d,O[s][h]=T+t,c++)for(h=scanf(\"%d\",&t),u=v=-1,s=m;h&&s--;)*C[s]?C[s][1]||(*O[s]<T+t?!~v||*O[s]>*O[v]?v=s:0:!~u||*O[s]<*O[u]?u=s:0):(u=s,h=0);}}"], "original_ll": -2.764087677001953, "sampled_ll": -0.4700777530670166, "all_perturbed_sampled_ll": [-1.6501150131225586], "all_perturbed_original_ll": [-2.764087677001953], "perturbed_sampled_ll": -1.6501150131225586, "perturbed_original_ll": -2.764087677001953, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX_SIZE = 10;\n\tpublic static final int MAX_CAR = 100;\n\t\n\tpublic static final int M_INF = Integer.MIN_VALUE / 2 + 1;\n\t\n\tpublic static boolean try_fst(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] <= M_INF){\n\t\t\t\tspaces[i][0] = remain_time;\n\t\t\t\tnumbers[i][0] = car_number;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void add_time(int[][] spaces, final int m, final int time){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] <= M_INF){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tspaces[i][0] -= time;\n\t\t\tspaces[i][1] -= time;\n\t\t}\n\t}\n\t\n\tpublic static boolean is_finish(int[][] spaces, final int m){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] > M_INF){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean can_upper(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] >= remain_time && spaces[i][1] <= M_INF){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean try_snd(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){\n\t\tfinal boolean can_upper = can_upper(spaces, numbers, m, remain_time, car_number);\n\t\t\n\t\tint pos = -1;\n\t\tint attr = can_upper ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\t//System.out.println(can_upper + \" \" + (spaces[i][0]<= M_INF) + \" \" + (attr < spaces[i][0]));\n\t\t\t\n\t\t\tif(can_upper && spaces[i][1] <= M_INF && spaces[i][0] >= remain_time && attr > spaces[i][0]){\n\t\t\t\tattr = spaces[i][0];\n\t\t\t\tpos = i;\n\t\t\t}else if(!can_upper && spaces[i][1] <= M_INF && attr < spaces[i][0]){\n\t\t\t\tattr = spaces[i][0];\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(attr  + \" \" + pos + \" \" + can_upper);\n\t\t\n\t\tif(pos < 0){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tspaces[pos][1] = Math.max(spaces[pos][0], remain_time);\n\t\tnumbers[pos][1] = numbers[pos][0];\n\t\tspaces[pos][0] = remain_time;\n\t\tnumbers[pos][0] = car_number;\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static void print(int[][] spaces, int[][] numbers, final int m){\n\t\tSystem.out.println(\"-----------------------------------\");\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(spaces[i][0] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(spaces[i][1] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(numbers[i][0] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(numbers[i][1] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"-----------------------------------\");\n\t\t\n\t}\n\t\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[][] spaces = new int[MAX_SIZE][2];\n\t\tint[][] numbers = new int[MAX_SIZE][2];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(m == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tspaces[i][0] = spaces[i][1] = M_INF;\n\t\t\t\tnumbers[i][0] = numbers[i][1] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> remain_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> number_queue = new LinkedList<Integer>();\n\t\t\t//int time = 0;\n\t\t\t\n\t\t\tLinkedList<Integer> out_numbers = new LinkedList<Integer>();\n\t\t\tfor(int car = 0; ; car++){\n\t\t\t\t//\n\t\t\t\tif(car < n){\n\t\t\t\t\tremain_queue.add(sc.nextInt());\n\t\t\t\t\tnumber_queue.add(car + 1);\n\t\t\t\t}else if(remain_queue.isEmpty() && is_finish(spaces, m)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tadd_time(spaces, m, 10);\n\t\t\t\t//print(spaces, numbers, m);\n\t\t\t\t\n\t\t\t\twhile(true){\n\t\t\t\t\tint min = 1;\n\t\t\t\t\tint min_pos = -1;\n\t\t\t\t\tint min_car = -1;\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\t\t\tif(spaces[i][0] <= M_INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(spaces[i][0] < min){\n\t\t\t\t\t\t\tmin = spaces[i][0];\n\t\t\t\t\t\t\tmin_car = numbers[i][0];\n\t\t\t\t\t\t\tmin_pos = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(min_car == -1){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tspaces[min_pos][0] = spaces[min_pos][1];\n\t\t\t\t\tnumbers[min_pos][0] = numbers[min_pos][1];\n\t\t\t\t\tspaces[min_pos][1] = M_INF;\n\t\t\t\t\tnumbers[min_pos][1] = M_INF;\n\t\t\t\t\tout_numbers.add(min_car);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile(!remain_queue.isEmpty()){\n\t\t\t\t\tfinal int remain_time = remain_queue.poll();\n\t\t\t\t\tfinal int car_number  = number_queue.poll();\n\t\t\t\t\t\n\t\t\t\t\tif(try_fst(spaces, numbers, m, remain_time, car_number)){\n\t\t\t\t\t\t//ok\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(try_snd(spaces, numbers, m, remain_time, car_number)){\n\t\t\t\t\t\t//ok\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//System.out.println(\"fail \" + car_number);\n\t\t\t\t\t\tremain_queue.addFirst(remain_time);\n\t\t\t\t\t\tnumber_queue.addFirst(car_number);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean first = true;\n\t\t\tfor(int i : out_numbers){\n\t\t\t\tif(first){\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tSystem.out.print(i);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.print(\" \" + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\t//System.out.println(out_numbers);\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Car {\n        int id;\n        int arrivalTime;\n        int parkingDuration;\n        int departureTime;\n        \n        Car(int id, int arrivalTime, int parkingDuration) {\n            this.id = id;\n            this.arrivalTime = arrivalTime;\n            this.parkingDuration = parkingDuration;\n            this.departureTime = arrivalTime + parkingDuration;\n        }\n    }\n    \n    static class Space {\n        Car lower;\n        Car upper;\n        \n        boolean isEmpty() {\n            return lower == null && upper == null;\n        }\n        \n        boolean hasSpace() {\n            return lower == null || upper == null;\n        }\n        \n        int getRemainingTime(int currentTime) {\n            if (lower != null) {\n                return Math.max(0, lower.departureTime - currentTime);\n            }\n            return 0;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            \n            if (m == 0 && n == 0) break;\n            \n            List<Car> cars = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int duration = sc.nextInt();\n                cars.add(new Car(i + 1, i * 10, duration));\n            }\n            \n            Space[] spaces = new Space[m];\n            for (int i = 0; i < m; i++) {\n                spaces[i] = new Space();\n            }\n            \n            Queue<Car> waitingQueue = new LinkedList<>();\n            List<Integer> exitOrder = new ArrayList<>();\n            int carIndex = 0;\n            int currentTime = 0;\n            \n            while (exitOrder.size() < n) {\n                // Process departures\n                List<Car> departing = new ArrayList<>();\n                for (int i = 0; i < m; i++) {\n                    Space space = spaces[i];\n                    if (space.lower != null && space.lower.departureTime <= currentTime) {\n                        departing.add(space.lower);\n                        if (space.upper != null && space.upper.departureTime <= currentTime) {\n                            departing.add(space.upper);\n                        }\n                    }\n                }\n                \n                Collections.sort(departing, (a, b) -> {\n                    for (int i = 0; i < m; i++) {\n                        if (spaces[i].lower == a) return -1;\n                        if (spaces[i].lower == b) return 1;\n                    }\n                    return 0;\n                });\n                \n                for (Car car : departing) {\n                    exitOrder.add(car.id);\n                    for (int i = 0; i < m; i++) {\n                        if (spaces[i].lower == car) {\n                            spaces[i].lower = spaces[i].upper;\n                            spaces[i].upper = null;\n                            break;\n                        }\n                    }\n                }\n                \n                // Add arriving cars to queue\n                while (carIndex < n && cars.get(carIndex).arrivalTime <= currentTime) {\n                    waitingQueue.add(cars.get(carIndex));\n                    carIndex++;\n                }\n                \n                // Process parking\n                while (!waitingQueue.isEmpty()) {\n                    Car car = waitingQueue.peek();\n                    int bestSpace = findBestSpace(spaces, car, currentTime);\n                    \n                    if (bestSpace == -1) break;\n                    \n                    waitingQueue.poll();\n                    if (spaces[bestSpace].isEmpty()) {\n                        spaces[bestSpace].lower = car;\n                    } else {\n                        spaces[bestSpace].upper = car;\n                    }\n                }\n                \n                currentTime++;\n            }\n            \n            for (int i = 0; i < exitOrder.size(); i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(exitOrder.get(i));\n            }\n            System.out.println();\n        }\n    }\n    \n    static int findBestSpace(Space[] spaces, Car car, int currentTime) {\n        int bestSpace = -1;\n        int bestDiff = Integer.MAX_VALUE;\n        boolean foundEmpty = false;\n        \n        // First check for empty spaces\n        for (int i = 0; i < spaces.length; i++) {\n            if (spaces[i].isEmpty()) {\n                return i;\n            }\n        }\n        \n        // Check for spaces with one car\n        for (int i = 0; i < spaces.length; i++) {\n            if (spaces[i].hasSpace() && !spaces[i].isEmpty()) {\n                int remaining = spaces[i].getRemainingTime(currentTime);\n                int diff = Math.abs(remaining - car.parkingDuration);\n                \n                if (remaining >= car.parkingDuration) {\n                    if (bestSpace == -1 || diff < bestDiff || \n                        (diff == bestDiff && remaining >= car.parkingDuration)) {\n                        bestSpace = i;\n                        bestDiff = diff;\n                    }\n                } else {\n                    if (bestSpace == -1 || spaces[bestSpace].getRemainingTime(currentTime) >= car.parkingDuration || diff < bestDiff) {\n                        bestSpace = i;\n                        bestDiff = diff;\n                    }\n                }\n            }\n        }\n        \n        return bestSpace;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  arrivalTime; int parkingDuration; int departureTime; Car(int id,  arrivalTime; this.parkingDuration = parkingDuration; this.departureTime = arrivalTime + parkingDuration;  boolean isEmpty() { return lower == null && upper == null; } boolean hasSpace() { return lower ==  if (lower != null) { return Math.max(0, lower.departureTime - currentTime); } return 0;  sc.nextInt(); int n = sc.nextInt(); if (m == 0 && n == 0) break; List<Car> cars = new ArrayList<>(); for (int i = 0; i < n; i++) { int duration = sc.nextInt(); cars.add(new Car(i + 1,  { spaces[i] = new Space(); } Queue<Car> waitingQueue = new LinkedList<>(); List<Integer> exitOrder = new ArrayList<>(); int carIndex  {  i = 0; i < m; i++) { Space space = spaces[i]; if (space.lower != null && space.lower.departureTime <= currentTime) { departing.add(space.lower); if (space.upper != null && space.upper.departureTime <= currentTime) { departing.add(space.upper); } } } Collections.sort(departing, (a,  (int i = 0; i < m; i++) { if (spaces[i].lower == car) { spaces[i].lower = spaces[i].upper;  cars to queue while (carIndex < n && cars.get(carIndex).arrivalTime <= currentTime) { waitingQueue.add(cars.get(carIndex)); carIndex++; } // Process  = findBestSpace(spaces,  { spaces[bestSpace].lower = car; } else { spaces[bestSpace].upper = car; } } currentTime++; } for (int i = 0; i  System.out.print(exitOrder.get(i)); } System.out.println(); } } static int findBestSpace(Space[] spaces, Car car, int currentTime) { int bestSpace = -1; int bestDiff = Integer.MAX_VALUE; boolean foundEmpty = false; // First check for empty spaces for (int i = 0; i < spaces.length;  && !spaces[i].isEmpty()) { int  (remaining >= car.parkingDuration) { if (bestSpace == -1 || diff <  bestSpace = i; bestDiff = diff; }  car.parkingDuration ||  } } } } return bestSpace; } }"], "perturbed_original": ["import java.util.Arrays; import  int MAX_SIZE  1; public static boolean try_fst(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){ for(int i = 0; i < m; i++){ if(spaces[i][0] <= M_INF){ spaces[i][0] = remain_time; numbers[i][0] = car_number; return true; } } return false; } public static void add_time(int[][] spaces, final int m, final int  <= M_INF){ continue; } spaces[i][0] -= time; spaces[i][1] -= time; } } public  0;  } return true; } public  i < m; i++){ if(spaces[i][0] >= remain_time && spaces[i][1] <= M_INF){ return true; } }  final int m, final int remain_time, final int car_number){ final boolean can_upper = can_upper(spaces, numbers, m, remain_time,  Integer.MAX_VALUE : Integer.MIN_VALUE; for(int i = 0; i < m; i++){ //System.out.println(can_upper + \" \" +   > spaces[i][0]){ attr =  && attr <  + \" \" + pos + \" \" + can_upper); if(pos < 0){ return false; } spaces[pos][1] = Math.max(spaces[pos][0], remain_time); numbers[pos][1] = numbers[pos][0]; spaces[pos][0] = remain_time; numbers[pos][0] = car_number; return true; } public static void  =  0;  for(int i = 0; i < m; i++){ System.out.print(numbers[i][1] + \" \"); } System.out.println(); System.out.println(\"-----------------------------------\"); } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int[][] spaces = new int[MAX_SIZE][2]; int[][] numbers = new int[MAX_SIZE][2];  sc.nextInt(); if(m == 0 && n ==  = -1; } LinkedList<Integer> remain_queue = new LinkedList<Integer>(); LinkedList<Integer> number_queue = new LinkedList<Integer>(); //int time = 0; LinkedList<Integer> out_numbers = new LinkedList<Integer>(); for(int car = 0; ; car++){ // if(car < n){ remain_queue.add(sc.nextInt()); number_queue.add(car + 1); }else if(remain_queue.isEmpty() && is_finish(spaces, m)){ break;  = spaces[i][0]; min_car =  } spaces[min_pos][0]  M_INF; out_numbers.add(min_car); } while(!remain_queue.isEmpty()){ final int remain_time = remain_queue.poll(); final int car_number = number_queue.poll(); if(try_fst(spaces, numbers, m, remain_time, car_number)){ //ok continue; }else if(try_snd(spaces, numbers, m, remain_time, car_number)){ //ok continue; }else{ //System.out.println(\"fail \" + car_number); remain_queue.addFirst(remain_time); number_queue.addFirst(car_number); break; } } } boolean first  System.out.print(i); }else{ System.out.print(\" \" + i); } } System.out.println(); //System.out.println(out_numbers); } } }"], "original_ll": -0.5524575710296631, "sampled_ll": -0.5062803030014038, "all_perturbed_sampled_ll": [-1.5953319072723389], "all_perturbed_original_ll": [-1.5878773927688599], "perturbed_sampled_ll": -1.5953319072723389, "perturbed_original_ll": -1.5878773927688599, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import deque\n\ndef out(time, parking):\n  x = len(parking)\n  outs = []\n  for i in range(x):\n    for j in range(2):\n      if parking[i][j] != None:\n        parking[i][j][0] -= time\n  \n  for i in range(x):\n    c1 = parking[i][0]\n    c2 = parking[i][1]\n    if c1 != None and c2 != None:\n      if c1[0] <= 0 and c2[0] <= 0:\n        outs.append([c2[1], c1[1]])\n        parking[i][0] = None\n        parking[i][1] = None\n      elif c2[0] <= 0:\n        outs.append([c2[1]])\n        parking[i][1] = None\n    elif c1 != None:\n      if c1[0] <= 0:\n        outs.append([c1[1]])\n        parking[i][0] = None\n    elif c2 != None:\n      if c2[0] <= 0:\n        outs.append([c2[1]])\n        parking[i][1] = None\n  outs.sort()\n  lst = []\n  for l in outs:\n    lst += l\n  return lst\n\ndef into(num, time, parking):\n  x = len(parking)\n  times = []\n  for i in range(x):\n    if parking[i] == [None, None]:\n      parking[i][0] = [time, num]\n      return\n    if parking[i][0] == None:\n      times.append((parking[i][1][0], i))\n    elif parking[i][1] == None:\n      times.append((parking[i][0][0], i))\n  times.sort()\n  \n  for t, ind in times:\n    if t >= time:\n      if parking[ind][0] == None:\n        parking[ind][0] = [time, num]\n      else:\n        parking[ind][1] = [time, num]\n      return\n  else:\n    max_t = t\n\n  for t, ind in times:\n    if t == max_t:\n      if parking[ind][0] == None:\n        parking[ind][0] = [time, num]\n      else:\n        parking[ind][1] = [time, num]\n      return\n \nwhile True:\n  m, n = map(int, input().split())\n  if m == 0:\n    break\n  \n  parking = [[None] * 2 for _ in range(m)]\n  wait = deque()\n  space = m * 2\n  ans = []\n  \n  for t in range(120 * n):\n    o = out(1, parking)\n    if o:\n      space += len(o)\n      ans += o\n\n    if t % 10 == 0 and t <= 10 * (n - 1):\n      time = int(input())\n      wait.append((t // 10 + 1, time))\n\n    for i in range(min(space, len(wait))):\n      num, time = wait.popleft()\n      into(num, time, parking)\n      space -= 1\n  print(*ans)\n", "sampled": "import heapq\nfrom collections import deque\n\ndef solve(m, n, parking_times):\n    # spaces[i] = [lower_car, upper_car] where car = (car_id, end_time)\n    spaces = [[None, None] for _ in range(m)]\n    waiting_queue = deque()\n    events = []  # (time, event_type, data)\n    exit_order = []\n    \n    current_time = 0\n    \n    for car_id in range(1, n + 1):\n        arrival_time = (car_id - 1) * 10\n        parking_time = parking_times[car_id - 1]\n        heapq.heappush(events, (arrival_time, 0, car_id, parking_time))  # 0 = arrival\n    \n    while events or waiting_queue:\n        if not events:\n            break\n            \n        current_time, event_type, *data = heapq.heappop(events)\n        \n        if event_type == 0:  # arrival\n            car_id, parking_time = data\n            end_time = current_time + parking_time\n            \n            # Process all exits at current time first\n            exits_now = []\n            temp_events = []\n            while events and events[0][0] == current_time and events[0][1] == 1:\n                temp_events.append(heapq.heappop(events))\n            \n            for ev in temp_events:\n                exits_now.append(ev)\n            \n            # Process exits\n            for exit_event in sorted(exits_now, key=lambda x: x[2]):\n                space_id = x[2]\n                process_exit(spaces, space_id, exit_order)\n            \n            # Put events back\n            for ev in temp_events:\n                if ev not in exits_now:\n                    heapq.heappush(events, ev)\n            \n            # Try to park cars from waiting queue\n            while waiting_queue:\n                w_car_id, w_parking_time, w_arrival = waiting_queue[0]\n                w_end_time = w_arrival + w_parking_time\n                space_idx = find_space(spaces, w_parking_time, current_time)\n                if space_idx == -1:\n                    break\n                waiting_queue.popleft()\n                park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events)\n            \n            # Try to park current car\n            space_idx = find_space(spaces, parking_time, current_time)\n            if space_idx == -1:\n                waiting_queue.append((car_id, parking_time, current_time))\n            else:\n                park_car(spaces, space_idx, car_id, end_time, current_time, events)\n                \n        elif event_type == 1:  # exit\n            space_id = data[0]\n            process_exit(spaces, space_id, exit_order)\n            \n            # Try to park cars from waiting queue\n            while waiting_queue:\n                w_car_id, w_parking_time, w_arrival = waiting_queue[0]\n                w_end_time = current_time + w_parking_time\n                space_idx = find_space(spaces, w_parking_time, current_time)\n                if space_idx == -1:\n                    break\n                waiting_queue.popleft()\n                park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events)\n    \n    return exit_order\n\ndef find_space(spaces, parking_time, current_time):\n    empty_spaces = []\n    one_car_spaces = []\n    \n    for i, space in enumerate(spaces):\n        if space[0] is None:\n            empty_spaces.append(i)\n        elif space[1] is None:\n            remaining_time = space[0][1] - current_time\n            one_car_spaces.append((i, remaining_time))\n    \n    if empty_spaces:\n        return min(empty_spaces)\n    \n    if not one_car_spaces:\n        return -1\n    \n    # Find best space\n    ge_spaces = [(i, rt) for i, rt in one_car_spaces if rt >= parking_time]\n    lt_spaces = [(i, rt) for i, rt in one_car_spaces if rt < parking_time]\n    \n    if ge_spaces:\n        best = min(ge_spaces, key=lambda x: (x[1] - parking_time, x[0]))\n        return best[0]\n    else:\n        best = min(lt_spaces, key=lambda x: (parking_time - x[1], x[0]))\n        return best[0]\n\ndef park_car(spaces, space_idx, car_id, end_time, current_time, events):\n    if spaces[space_idx][0] is None:\n        spaces[space_idx][0] = (car_id, end_time)\n        heapq.heappush(events, (end_time, 1, space_idx))\n    else:\n        spaces[space_idx][1] = (car_id, end_time)\n\ndef process_exit(spaces, space_id, exit_order):\n    if spaces[space_id][1] is not None:\n        exit_order.append(spaces[space_id][0][0])\n        exit_order.append(spaces[space_id][1][0])\n        spaces[space_id][0] = None\n        spaces[space_id][1] = None\n    elif spaces[space_id][0] is not None:\n        exit_order.append(spaces[space_id][0][0])\n        spaces[space_id][0] = None\n\nwhile True:\n    line = input().split()\n    m, n = int(line[0]), int(line[1])\n    if m == 0 and n == 0:\n        break\n    \n    parking_times = []\n    for _ in range(n):\n        parking_times.append(int(input()))\n    \n    result = solve(m, n, parking_times)\n    print(' '.join(map(str, result)))\n", "perturbed_sampled": ["import heapq from collections import  where car = (car_id, end_time) spaces = [[None, None]  0 for car_id in range(1, n + 1): arrival_time  1] heapq.heappush(events,   heapq.heappop(events) if event_type == 0: #  = [] temp_events = [] while events and events[0][0] == current_time and events[0][1] == 1: temp_events.append(heapq.heappop(events)) for ev  key=lambda x: x[2]):  for ev in temp_events: if ev not in exits_now: heapq.heappush(events, ev) # Try to park cars from waiting queue  + w_parking_time space_idx = find_space(spaces, w_parking_time, current_time) if space_idx == -1: break waiting_queue.popleft() park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events) # Try to park current car space_idx =  else: park_car(spaces, space_idx, car_id, end_time, current_time, events) elif event_type == 1: # exit space_id = data[0] process_exit(spaces, space_id, exit_order) # Try to park cars from waiting queue while waiting_queue: w_car_id, w_parking_time, w_arrival = waiting_queue[0] w_end_time = current_time + w_parking_time space_idx = find_space(spaces, w_parking_time, current_time) if space_idx == -1: break waiting_queue.popleft() park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events) return exit_order def find_space(spaces, parking_time, current_time): empty_spaces = [] one_car_spaces = []  elif space[1]  empty_spaces: return min(empty_spaces) if not  one_car_spaces if rt < parking_time] if ge_spaces: best = min(ge_spaces, key=lambda  min(lt_spaces, key=lambda x:  end_time, current_time, events): if spaces[space_idx][0] is None: spaces[space_idx][0] = (car_id, end_time) heapq.heappush(events, (end_time, 1, space_idx)) else: spaces[space_idx][1] = (car_id, end_time) def process_exit(spaces, space_id, exit_order): if spaces[space_id][1] is not None: exit_order.append(spaces[space_id][0][0]) exit_order.append(spaces[space_id][1][0]) spaces[space_id][0] = None spaces[space_id][1] = None elif spaces[space_id][0] is not None: exit_order.append(spaces[space_id][0][0]) spaces[space_id][0] = None while True:   parking_times) print(' '.join(map(str, result)))"], "perturbed_original": ["from collections  [] for i in range(x): for j in range(2): if parking[i][j] != None: parking[i][j][0]  = parking[i][1] if c1 != None and c2 != None: if c1[0] <= 0  = None elif c2[0] <= 0: outs.append([c2[1]]) parking[i][1] = None  0: outs.append([c2[1]]) parking[i][1] = None outs.sort() lst = [] for l in outs: lst += l return lst def into(num, time, parking): x = len(parking) times = []  =  in times: if t >= time: if parking[ind][0] == None: parking[ind][0] = [time, num] else: parking[ind][1] = [time, num] return else:  == max_t: if parking[ind][0] == None: parking[ind][0]  True: m, n = map(int, input().split()) if  _ in range(m)] wait = deque() space =  += len(o) ans += o if t % 10 == 0 and t <= 10 * (n - 1): time = int(input()) wait.append((t // 10 + 1, time)) for i in  -= 1 print(*ans)"], "original_ll": -0.725325345993042, "sampled_ll": -0.6212821006774902, "all_perturbed_sampled_ll": [-1.6358269453048706], "all_perturbed_original_ll": [-2.2625515460968018], "perturbed_sampled_ll": -1.6358269453048706, "perturbed_original_ll": -2.2625515460968018, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0193: Convenience Store\n// 2017.8.25 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define abs(a) ((a)>=0?(a):(-(a)))\n//#define min(a,b) ((a)<=(b)?(a):(b))\n\ntypedef struct { int r, c, f; } T;\nT shop[25]; int n, S, N;\nint R, C;\n\nint hexDistance(int r1, int c1, int r2, int c2)\n{\n\tint dr, dc, c;\n\tdr = abs(r2 - r1), dc = abs(c2 - c1);\n\tif (r2 == r1) return dc;\n\tif (c2 == c1) return dr;\n\tif (r2 < r1) c = r2, r2 = r1, r1 = c, c = c2, c2 = c1, c1 = c;\n\tif (c2 >= c1) {\n\t\tc = c1 + (dr+1-(r1&1))/2;\n\t\tif (c2 >= c) dr += abs(c-c2);\n\t} else {\n\t\tc = c1 - (dr+(r1&1))/2;\n\t\tif (c2 <= c) dr += abs(c-c2);\n\t}\n\treturn dr;\n}\n\nint belong(int r, int c)\n{\n\tint i, d, k, min;\n\tfor (min = -1, d = -2, k = 0, i = 1; i <= n; i++) {\n\t\td = hexDistance(shop[i].r, shop[i].c, r, c);\n\t\tif (min < 0 || d < min) min = d, k = i;\n\t\telse if (d == min) k = 0;\n\t}\n\treturn k;\n}\n\nint main()\n{\n\tint i, r, c;\n\tint ans;\n\n\twhile (scanf(\"%d%d\", &C, &R) && C) {\n\t\tscanf(\"%d\", &S);\n\t\tfor (n = 1, i = 0; i < S; i++) {\n\t\t\tscanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0;\n\t\t}\n\t\tscanf(\"%d\", &N);\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0;\n\t\t}\n\t\tn--;\n\t\tfor (r = 1; r <= R; r++) for (c = 1; c <= C; c++)\n\t\t\tif ((i = belong(r, c)) > 0) shop[i].f++;\n\t\tfor (ans = -1, i = S+1; i <= n; i++) if (shop[i].f > ans) ans = shop[i].f;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint dx_odd[6] = {0, 1, 1, 0, -1, -1};\nint dy_odd[6] = {-1, -1, 0, 1, 0, -1};\nint dx_even[6] = {-1, 0, 1, 1, 1, 0};\nint dy_even[6] = {-1, -1, 0, 1, 0, -1};\n\ntypedef struct {\n    int x, y, dist;\n} Node;\n\nint dist[101][101];\nint queue[20000][2];\nint qfront, qrear;\n\nvoid bfs(int sx, int sy, int m, int n) {\n    int visited[101][101] = {0};\n    qfront = qrear = 0;\n    queue[qrear][0] = sx;\n    queue[qrear][1] = sy;\n    qrear++;\n    visited[sx][sy] = 1;\n    dist[sx][sy] = 0;\n    \n    while (qfront < qrear) {\n        int cx = queue[qfront][0];\n        int cy = queue[qfront][1];\n        qfront++;\n        \n        int *dx = (cy % 2 == 1) ? dx_odd : dx_even;\n        int *dy = (cy % 2 == 1) ? dy_odd : dy_even;\n        \n        for (int i = 0; i < 6; i++) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n            \n            if (nx >= 1 && nx <= m && ny >= 1 && ny <= n && !visited[nx][ny]) {\n                visited[nx][ny] = 1;\n                dist[nx][ny] = dist[cx][cy] + 1;\n                queue[qrear][0] = nx;\n                queue[qrear][1] = ny;\n                qrear++;\n            }\n        }\n    }\n}\n\nint main() {\n    int m, n;\n    \n    while (scanf(\"%d %d\", &m, &n) == 2) {\n        if (m == 0 && n == 0) break;\n        \n        int s;\n        scanf(\"%d\", &s);\n        Point stores[11];\n        for (int i = 0; i < s; i++) {\n            scanf(\"%d %d\", &stores[i].x, &stores[i].y);\n        }\n        \n        int t;\n        scanf(\"%d\", &t);\n        Point candidates[11];\n        for (int i = 0; i < t; i++) {\n            scanf(\"%d %d\", &candidates[i].x, &candidates[i].y);\n        }\n        \n        int max_coverage = 0;\n        \n        for (int cand = 0; cand < t; cand++) {\n            int coverage = 0;\n            \n            for (int x = 1; x <= m; x++) {\n                for (int y = 1; y <= n; y++) {\n                    int min_dist_cand = 1000000;\n                    int min_dist_store = 1000000;\n                    int count_min_store = 0;\n                    \n                    bfs(candidates[cand].x, candidates[cand].y, m, n);\n                    min_dist_cand = dist[x][y];\n                    \n                    for (int i = 0; i < s; i++) {\n                        bfs(stores[i].x, stores[i].y, m, n);\n                        int d = dist[x][y];\n                        if (d < min_dist_store) {\n                            min_dist_store = d;\n                            count_min_store = 1;\n                        } else if (d == min_dist_store) {\n                            count_min_store++;\n                        }\n                    }\n                    \n                    if (min_dist_cand < min_dist_store) {\n                        coverage++;\n                    } else if (min_dist_cand == min_dist_store && count_min_store == 0) {\n                        coverage++;\n                    }\n                }\n            }\n            \n            if (coverage > max_coverage) {\n                max_coverage = coverage;\n            }\n        }\n        \n        printf(\"%d\\n\", max_coverage);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int x, y; } Point; int dx_odd[6] = {0, 1, 1, 0, -1, -1}; int dy_odd[6]  {-1, 0, 1, 1, 1, 0}; int dy_even[6]  int x, y, dist; } Node; int dist[101][101]; int queue[20000][2]; int qfront, qrear; void bfs(int  = {0}; qfront = qrear = 0; queue[qrear][0] = sx; queue[qrear][1] = sy; qrear++; visited[sx][sy]  dx_odd : dx_even;  int ny = cy + dy[i]; if (nx >= 1 && nx <= m && ny >= 1  dist[nx][ny] = dist[cx][cy] + 1; queue[qrear][0] = nx; queue[qrear][1]  2) { if (m == 0 && n ==  %d\", &stores[i].x, &stores[i].y); } int t; scanf(\"%d\", &t); Point candidates[11]; for (int i = 0; i < t; i++) { scanf(\"%d %d\", &candidates[i].x, &candidates[i].y); } int max_coverage =  { int coverage = 0; for (int x = 1; x <= m; x++) { for (int y = 1; y <= n; y++) { int min_dist_cand = 1000000; int min_dist_store = 1000000; int count_min_store = 0; bfs(candidates[cand].x, candidates[cand].y,  int d = dist[x][y]; if (d < min_dist_store) { min_dist_store = d;  count_min_store++; } } if (min_dist_cand < min_dist_store) { coverage++; }  coverage++; } } } if (coverage > max_coverage) { max_coverage = coverage; } } printf(\"%d\\n\", max_coverage); } return 0; }"], "perturbed_original": [" typedef struct { int r, c, f; } T; T  r1, int c1, int r2, int c2) { int dr, dc, c; dr = abs(r2 - r1), dc = abs(c2 - c1); if (r2 == r1) return  r1) c = r2, r2 = r1, r1  + (dr+1-(r1&1))/2; if (c2 >= c) dr += abs(c-c2); } else { c = c1 - (dr+(r1&1))/2;  } int belong(int r, int c) { int i, d, k, min; for (min = -1, d = -2, k = 0, i = 1; i <= n; i++) { d = hexDistance(shop[i].r, shop[i].c, r, c); if (min < 0 || d <  == min) k = 0; } return k; } int main()  &R) &&  0; i <  scanf(\"%d\", &N); for (i = 0;  0; } n--; for (r = 1; r <= R; r++) for (c = 1; c <= C; c++) if ((i = belong(r, c)) > 0)  printf(\"%d\\n\", ans); } return 0; }"], "original_ll": -0.9315952062606812, "sampled_ll": -0.3970751464366913, "all_perturbed_sampled_ll": [-1.265102744102478], "all_perturbed_original_ll": [-1.913317322731018], "perturbed_sampled_ll": -1.265102744102478, "perturbed_original_ll": -1.913317322731018, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tfor(int m,n,x,a[][];(m=s.nextInt())>0;){\n\t\t\tn=s.nextInt();\n\t\t\tx=s.nextInt();\n\t\t\ta=new int[n][m];\n\t\t\tDeque<int[]>q=new ArrayDeque<int[]>();\n\t\t\tfor(int i=0;i<x;++i){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\ta[u][v]=1;\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t}\n\t\t\tint[][]dm={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}};\n\t\t\tint[][]dn={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}};\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[]t=q.poll();\n\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\tint u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i];\n\t\t\t\t\tif(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){\n\t\t\t\t\t\tq.add(new int[]{u,v,a[u][v]=t[2]+1});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=0;\n\t\t\tfor(x=s.nextInt();x-->0;){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\tif(a[u][v]>1){\n\t\t\t\t\tint[][] tmp = new int[n][];\n\t\t\t\t\tfor(int i=0;i<n;++i)\n\t\t\t\t\t\ttmp[i]=Arrays.copyOf(a[i],m);\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t\tint c=1;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint[]t=q.poll();\n\t\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\t\tint u1=t[0]+dn[t[0]%2][i],v1=t[1]+dm[t[0]%2][i];\n\t\t\t\t\t\tif(0<=u1&&u1<n&&0<=v1&&v1<m&&tmp[u1][v1]>t[2]+1){\n\t\t\t\t\t\t\t++c;\n\t\t\t\t\t\t\tq.add(new int[]{u1,v1,tmp[u1][v1]=t[2]+1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr=r>c?r:c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int m, n;\n    static int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, -1}, {-1, 1}};\n    \n    static int[][] getNeighbors(int x, int y) {\n        int[][] neighbors = new int[6][2];\n        if (y % 2 == 1) {\n            neighbors[0] = new int[]{x + 1, y};\n            neighbors[1] = new int[]{x - 1, y};\n            neighbors[2] = new int[]{x, y + 1};\n            neighbors[3] = new int[]{x, y - 1};\n            neighbors[4] = new int[]{x - 1, y + 1};\n            neighbors[5] = new int[]{x - 1, y - 1};\n        } else {\n            neighbors[0] = new int[]{x + 1, y};\n            neighbors[1] = new int[]{x - 1, y};\n            neighbors[2] = new int[]{x + 1, y + 1};\n            neighbors[3] = new int[]{x + 1, y - 1};\n            neighbors[4] = new int[]{x, y + 1};\n            neighbors[5] = new int[]{x, y - 1};\n        }\n        return neighbors;\n    }\n    \n    static int[][] computeDistances(int sx, int sy) {\n        int[][] dist = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            Arrays.fill(dist[i], -1);\n        }\n        \n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{sx, sy, 0});\n        dist[sx][sy] = 0;\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int x = curr[0];\n            int y = curr[1];\n            int d = curr[2];\n            \n            int[][] neighbors = getNeighbors(x, y);\n            for (int[] neighbor : neighbors) {\n                int nx = neighbor[0];\n                int ny = neighbor[1];\n                if (nx >= 1 && nx <= m && ny >= 1 && ny <= n && dist[nx][ny] == -1) {\n                    dist[nx][ny] = d + 1;\n                    queue.offer(new int[]{nx, ny, d + 1});\n                }\n            }\n        }\n        \n        return dist;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            m = sc.nextInt();\n            n = sc.nextInt();\n            if (m == 0 && n == 0) break;\n            \n            int s = sc.nextInt();\n            int[][] existing = new int[s][2];\n            for (int i = 0; i < s; i++) {\n                existing[i][0] = sc.nextInt();\n                existing[i][1] = sc.nextInt();\n            }\n            \n            int t = sc.nextInt();\n            int[][] candidates = new int[t][2];\n            for (int i = 0; i < t; i++) {\n                candidates[i][0] = sc.nextInt();\n                candidates[i][1] = sc.nextInt();\n            }\n            \n            int[][][] existingDist = new int[s][][];\n            for (int i = 0; i < s; i++) {\n                existingDist[i] = computeDistances(existing[i][0], existing[i][1]);\n            }\n            \n            int maxCoverage = 0;\n            \n            for (int c = 0; c < t; c++) {\n                int[][] newDist = computeDistances(candidates[c][0], candidates[c][1]);\n                int coverage = 0;\n                \n                for (int x = 1; x <= m; x++) {\n                    for (int y = 1; y <= n; y++) {\n                        boolean isExisting = false;\n                        for (int i = 0; i < s; i++) {\n                            if (existing[i][0] == x && existing[i][1] == y) {\n                                isExisting = true;\n                                break;\n                            }\n                        }\n                        if (isExisting) continue;\n                        \n                        if (candidates[c][0] == x && candidates[c][1] == y) continue;\n                        \n                        int minDist = newDist[x][y];\n                        if (minDist == -1) continue;\n                        \n                        boolean uniqueMin = true;\n                        for (int i = 0; i < s; i++) {\n                            int d = existingDist[i][x][y];\n                            if (d == -1) continue;\n                            if (d < minDist) {\n                                uniqueMin = false;\n                                break;\n                            } else if (d == minDist) {\n                                uniqueMin = false;\n                                break;\n                            }\n                        }\n                        \n                        if (uniqueMin) {\n                            coverage++;\n                        }\n                    }\n                }\n                \n                maxCoverage = Math.max(maxCoverage, coverage);\n            }\n            \n            System.out.println(maxCoverage);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int m, n; static int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, -1}, {-1, 1}}; static int[][] getNeighbors(int x, int y) { int[][] neighbors =  = new  int[]{x - 1, y - 1}; } else { neighbors[0] = new int[]{x + 1, y}; neighbors[1] =  1, y + 1}; neighbors[3] = new int[]{x + 1, y - 1}; neighbors[4] = new int[]{x, y + 1}; neighbors[5] = new int[]{x,  sx, int sy) { int[][] dist = new int[m + 1][n + 1]; for (int i = 0; i  new LinkedList<>(); queue.offer(new int[]{sx, sy, 0}); dist[sx][sy] = 0; while (!queue.isEmpty()) { int[] curr = queue.poll(); int x = curr[0]; int y = curr[1]; int d  m && ny >= 1 && ny <= n && dist[nx][ny] == -1) { dist[nx][ny] = d  } return dist; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { m = sc.nextInt();  } int t = sc.nextInt(); int[][] candidates = new int[t][2]; for (int i = 0; i < t; i++) { candidates[i][0] =   existingDist[i] = computeDistances(existing[i][0], existing[i][1]); } int maxCoverage = 0; for (int c = 0; c < t; c++) { int[][] newDist = computeDistances(candidates[c][0], candidates[c][1]); int coverage  x++) {  i < s; i++) { if (existing[i][0] == x && existing[i][1] == y) { isExisting = true; break; } } if (isExisting) continue; if (candidates[c][0] == x && candidates[c][1] == y) continue; int minDist = newDist[x][y]; if (minDist == -1) continue; boolean uniqueMin = true;  int d = existingDist[i][x][y]; if (d == -1) continue; if (d < minDist)   } System.out.println(maxCoverage); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[]  u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i]; if(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){ q.add(new int[]{u,v,a[u][v]=t[2]+1}); } } } int r=0; for(x=s.nextInt();x-->0;){ int v=s.nextInt()-1,u=s.nextInt()-1; if(a[u][v]>1){ int[][] tmp = new int[n][]; for(int i=0;i<n;++i) tmp[i]=Arrays.copyOf(a[i],m); q.add(new int[]{u,v,1}); int c=1; while(!q.isEmpty()){ int[]t=q.poll();  } r=r>c?r:c; } } System.out.println(r); } } }"], "original_ll": -0.7162664532661438, "sampled_ll": -0.3137032389640808, "all_perturbed_sampled_ll": [-1.1032127141952515], "all_perturbed_original_ll": [-1.7700400352478027], "perturbed_sampled_ll": -1.1032127141952515, "perturbed_original_ll": -1.7700400352478027, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#Deven-Eleven:\nimport re\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n\nwhile True:\n    data = raw_input().sprit()\n    if data == \"0 0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()", "sampled": "from collections import deque\n\ndef get_neighbors(x, y, m, n):\n    neighbors = []\n    if y % 2 == 1:  # odd row\n        # neighbors for odd row\n        candidates = [\n            (x-1, y-1), (x, y-1),    # upper left, upper right\n            (x-1, y), (x+1, y),       # left, right\n            (x-1, y+1), (x, y+1)      # lower left, lower right\n        ]\n    else:  # even row\n        # neighbors for even row\n        candidates = [\n            (x, y-1), (x+1, y-1),     # upper left, upper right\n            (x-1, y), (x+1, y),       # left, right\n            (x, y+1), (x+1, y+1)      # lower left, lower right\n        ]\n    \n    for nx, ny in candidates:\n        if 1 <= nx <= m and 1 <= ny <= n:\n            neighbors.append((nx, ny))\n    \n    return neighbors\n\ndef bfs_distances(start_x, start_y, m, n):\n    distances = {}\n    queue = deque([(start_x, start_y, 0)])\n    distances[(start_x, start_y)] = 0\n    \n    while queue:\n        x, y, dist = queue.popleft()\n        \n        for nx, ny in get_neighbors(x, y, m, n):\n            if (nx, ny) not in distances:\n                distances[(nx, ny)] = dist + 1\n                queue.append((nx, ny, dist + 1))\n    \n    return distances\n\ndef count_covered_blocks(stores, m, n):\n    # For each block, find the minimum distance to any store\n    min_distances = {}\n    \n    for i, (sx, sy) in enumerate(stores):\n        distances = bfs_distances(sx, sy, m, n)\n        for (x, y), dist in distances.items():\n            if (x, y) not in min_distances:\n                min_distances[(x, y)] = []\n            min_distances[(x, y)].append((dist, i))\n    \n    # Count blocks covered by each store\n    coverage = [0] * len(stores)\n    \n    for (x, y), dists in min_distances.items():\n        dists.sort()\n        if len(dists) > 0:\n            min_dist = dists[0][0]\n            stores_at_min_dist = [store_idx for dist, store_idx in dists if dist == min_dist]\n            \n            # Only count if exactly one store is closest\n            if len(stores_at_min_dist) == 1:\n                coverage[stores_at_min_dist[0]] += 1\n    \n    return coverage\n\nwhile True:\n    m, n = map(int, input().split())\n    if m == 0 and n == 0:\n        break\n    \n    s = int(input())\n    existing_stores = []\n    for _ in range(s):\n        x, y = map(int, input().split())\n        existing_stores.append((x, y))\n    \n    t = int(input())\n    candidates = []\n    for _ in range(t):\n        p, q = map(int, input().split())\n        candidates.append((p, q))\n    \n    max_coverage = 0\n    \n    for candidate in candidates:\n        # Create a list of all stores including the new one\n        all_stores = existing_stores + [candidate]\n        \n        # Count coverage for all stores\n        coverage = count_covered_blocks(all_stores, m, n)\n        \n        # The last store in the list is the new one\n        new_store_coverage = coverage[-1]\n        \n        max_coverage = max(max_coverage, new_store_coverage)\n    \n    print(max_coverage)\n", "perturbed_sampled": ["from collections import deque def get_neighbors(x, y, m, n): neighbors = [] if y % 2 == 1: # odd row # neighbors for odd row candidates = [ (x-1, y-1), (x, y-1), # upper left, upper right (x-1, y),  # neighbors for even row candidates = [ (x, y-1), (x+1, y-1), # upper left, upper right (x-1, y), (x+1, y), # left, right (x, y+1), (x+1, y+1) # lower left, lower right ] for nx, ny in candidates: if 1 <= nx <= m and 1 <= ny <= n: neighbors.append((nx, ny)) return neighbors  x, y, dist = queue.popleft() for nx, ny in get_neighbors(x, y, m, n): if (nx, ny) not in distances: distances[(nx, ny)] = dist + 1 queue.append((nx, ny,  For   distances.items(): if  y)].append((dist, i)) # Count blocks covered by each store coverage = [0] * len(stores) for (x, y), dists in min_distances.items(): dists.sort() if len(dists)  store_idx in dists if dist == min_dist] # Only count if  += 1 return coverage while True:  n == 0: break s =  = map(int, input().split()) existing_stores.append((x, y)) t  q = map(int, input().split()) candidates.append((p, q)) max_coverage  coverage = count_covered_blocks(all_stores, m,  new one new_store_coverage = coverage[-1] max_coverage = max(max_coverage, new_store_coverage) print(max_coverage)"], "perturbed_original": ["#Deven-Eleven: import re D = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)), ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0))) def func(y, x):  for _ in xrange(n)] while len(q) != 0:  <= nx < m: q.append((ny, nx, step + 1)) return cover def solve(): scover = [func(pos[1]  xrange(m)] for y in xrange(n)] def count(cover): ret = 0 for y in xrange(n): for x in xrange(m): if cover[y][x] < min_cover[y][x]: ret += 1 return ret return  while True: data = raw_input().sprit()  data.split()) s = input() spos = [map(int, raw_input().split()) for _  _ in xrange(t)] print solve()"], "original_ll": -0.9625340700149536, "sampled_ll": -0.5447258949279785, "all_perturbed_sampled_ll": [-1.8150556087493896], "all_perturbed_original_ll": [-2.2175488471984863], "perturbed_sampled_ll": -1.8150556087493896, "perturbed_original_ll": -2.2175488471984863, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "M,N,D;P[101][4][21][21];S[21][21];C[4][21][21];J[4][21][21];h1,h2;i,n,v1,v2,k;xs,ys,xg,yg,T;d,x,y,d1,t1,x1,y1;vx[]={1,0,-1,0},vy[]={0,1,0,-1};void set_road(int A[][21][21],int h1,int v1,int h2,int v2,int d){if(v1==v2){A[h1<h2?1:3][v1][h1-96]=d;A[h1<h2?3:1][v2][h2-96]=d;}else{A[v1<v2?0:2][v1][h1-96]=d;A[v1<v2?2:0][v2][h2-96]=d;}}main(){for(;scanf(\"%d%d%d%d\",&M,&N,&D,&n),M;){memset(P,0,sizeof(P));memset(S,0,sizeof(S));memset(C,0,sizeof(C));memset(J,0,sizeof(J));for(i=0;i<n;i++){scanf(\"\\n%c-%d%d\",&h1,&v1,&k);S[v1][h1-96]=k;}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);set_road(C,h1,v1,h2,v2,1);}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d%d\",&h1,&v1,&h2,&v2,&k);set_road(J,h1,v1,h2,v2,k);}scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);xs=v1;ys=h1-96;xg=v2;yg=h2-96;P[0][0][xs][ys]=1;for(T=0;;T++)for(d=0;d<4;d++){if(P[T][d][xg][yg]){printf(\"%d\\n\",T);goto E;}for(x=1;x<=N;x++)for(y=1;y<=M;y++)if(P[T][d][x][y]&&(!S[x][y]||T/S[x][y]%2!=d%2))for(d1=0;d1<4;d1++){t1=T+D+J[d1][x][y];x1=x+vx[d1];y1=y+vy[d1];if(d1!=(d^2)&&!C[d1][x][y]&&t1<=100&&x1>=1&&x1<=N&&y1>=1&&y1<=M)P[t1][d1][x1][y1]=1;}}E:;}return 0;}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_N 20\n#define INF 1000000\n\ntypedef struct {\n    int r, c, time, dir;\n} State;\n\nint M, N, D;\nint signal[MAX_N][MAX_N];\nint period[MAX_N][MAX_N];\nint construction[MAX_N][MAX_N][MAX_N][MAX_N];\nint traffic[MAX_N][MAX_N][MAX_N][MAX_N];\nint visited[MAX_N][MAX_N][101][4];\n\nState queue[1000000];\nint head, tail;\n\nint dr[] = {0, 0, -1, 1};\nint dc[] = {-1, 1, 0, 0};\n\nvoid parseIntersection(char *s, int *r, int *c) {\n    char h[10];\n    int v;\n    sscanf(s, \"%[^-]-%d\", h, &v);\n    *r = h[0] - 'a';\n    *c = v - 1;\n}\n\nint canPass(int r, int c, int time, int from_dir, int to_dir) {\n    if (signal[r][c] == 0) return 1;\n    \n    int k = period[r][c];\n    int cycle = time % (2 * k);\n    int is_ns_green = (cycle < k);\n    \n    if (to_dir == 2 || to_dir == 3) {\n        return is_ns_green;\n    } else {\n        return !is_ns_green;\n    }\n}\n\nint solve(int sr, int sc, int er, int ec) {\n    memset(visited, 0, sizeof(visited));\n    \n    head = tail = 0;\n    queue[tail].r = sr;\n    queue[tail].c = sc;\n    queue[tail].time = 0;\n    queue[tail].dir = 1;\n    tail++;\n    visited[sr][sc][0][1] = 1;\n    \n    while (head < tail) {\n        State cur = queue[head++];\n        \n        if (cur.r == er && cur.c == ec) {\n            return cur.time;\n        }\n        \n        if (cur.time >= 100) continue;\n        \n        for (int d = 0; d < 4; d++) {\n            if (d == (cur.dir ^ 1)) continue;\n            \n            int nr = cur.r + dr[d];\n            int nc = cur.c + dc[d];\n            \n            if (nr < 0 || nr >= M || nc < 0 || nc >= N) continue;\n            if (construction[cur.r][cur.c][nr][nc]) continue;\n            \n            if (!canPass(cur.r, cur.c, cur.time, cur.dir, d)) continue;\n            \n            int next_time = cur.time + D + traffic[cur.r][cur.c][nr][nc];\n            \n            if (next_time > 100) continue;\n            if (visited[nr][nc][next_time][d]) continue;\n            \n            visited[nr][nc][next_time][d] = 1;\n            queue[tail].r = nr;\n            queue[tail].c = nc;\n            queue[tail].time = next_time;\n            queue[tail].dir = d;\n            tail++;\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &M, &N);\n        if (M == 0 && N == 0) break;\n        \n        scanf(\"%d\", &D);\n        \n        memset(signal, 0, sizeof(signal));\n        memset(period, 0, sizeof(period));\n        memset(construction, 0, sizeof(construction));\n        memset(traffic, 0, sizeof(traffic));\n        \n        int ns;\n        scanf(\"%d\", &ns);\n        for (int i = 0; i < ns; i++) {\n            char s[20];\n            int k, r, c;\n            scanf(\"%s %d\", s, &k);\n            parseIntersection(s, &r, &c);\n            signal[r][c] = 1;\n            period[r][c] = k;\n        }\n        \n        int nc;\n        scanf(\"%d\", &nc);\n        for (int i = 0; i < nc; i++) {\n            char s1[20], s2[20];\n            int r1, c1, r2, c2;\n            scanf(\"%s %s\", s1, s2);\n            parseIntersection(s1, &r1, &c1);\n            parseIntersection(s2, &r2, &c2);\n            construction[r1][c1][r2][c2] = 1;\n            construction[r2][c2][r1][c1] = 1;\n        }\n        \n        int nj;\n        scanf(\"%d\", &nj);\n        for (int i = 0; i < nj; i++) {\n            char s1[20], s2[20];\n            int r1, c1, r2, c2, d;\n            scanf(\"%s %s %d\", s1, s2, &d);\n            parseIntersection(s1, &r1, &c1);\n            parseIntersection(s2, &r2, &c2);\n            traffic[r1][c1][r2][c2] = d;\n            traffic[r2][c2][r1][c1] = d;\n        }\n        \n        char start[20], end[20];\n        int sr, sc, er, ec;\n        scanf(\"%s %s\", start, end);\n        parseIntersection(start, &sr, &sc);\n        parseIntersection(end, &er, &ec);\n        \n        int result = solve(sr, sc, er, ec);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAX_N  time, dir; } State;  int traffic[MAX_N][MAX_N][MAX_N][MAX_N]; int visited[MAX_N][MAX_N][101][4]; State queue[1000000]; int head, tail; int dr[] =  0}; void parseIntersection(char *s, int *r, int *c) {  h[0] - 'a'; *c = v - 1; } int canPass(int r, int c, int time, int from_dir, int to_dir) { if (signal[r][c] == 0) return 1; int k = period[r][c]; int cycle = time  if (to_dir == 2 || to_dir == 3) { return is_ns_green; } else { return !is_ns_green; } } int solve(int sr, int sc, int er, int ec) { memset(visited, 0, sizeof(visited)); head = tail = 0; queue[tail].r = sr;  visited[sr][sc][0][1] = 1; while  == er && cur.c == ec) { return cur.time; } if (cur.time >= 100) continue; for (int d = 0; d < 4; d++) { if (d == (cur.dir ^ 1)) continue; int nr = cur.r + dr[d]; int nc = cur.c + dc[d]; if (nr <  nc >= N) continue; if (construction[cur.r][cur.c][nr][nc]) continue; if (!canPass(cur.r, cur.c, cur.time, cur.dir, d)) continue; int next_time = cur.time   } return -1; } int  sizeof(construction)); memset(traffic, 0, sizeof(traffic)); int ns; scanf(\"%d\", &ns); for (int i = 0; i < ns; i++) { char s[20]; int k, r, c; scanf(\"%s %d\", s,  } int nc; scanf(\"%d\", &nc); for (int i = 0; i  r2,  &c2);  &nj); for (int i = 0; i < nj; i++)  parseIntersection(s2, &r2, &c2); traffic[r1][c1][r2][c2] = d; traffic[r2][c2][r1][c1] =   } return 0; }"], "perturbed_original": ["M,N,D;P[101][4][21][21];S[21][21];C[4][21][21];J[4][21][21];h1,h2;i,n,v1,v2,k;xs,ys,xg,yg,T;d,x,y,d1,t1,x1,y1;vx[]={1,0,-1,0},vy[]={0,1,0,-1};void set_road(int A[][21][21],int h1,int v1,int h2,int v2,int d){if(v1==v2){A[h1<h2?1:3][v1][h1-96]=d;A[h1<h2?3:1][v2][h2-96]=d;}else{A[v1<v2?0:2][v1][h1-96]=d;A[v1<v2?2:0][v2][h2-96]=d;}}main(){for(;scanf(\"%d%d%d%d\",&M,&N,&D,&n),M;){memset(P,0,sizeof(P));memset(S,0,sizeof(S));memset(C,0,sizeof(C));memset(J,0,sizeof(J));for(i=0;i<n;i++){scanf(\"\\n%c-%d%d\",&h1,&v1,&k);S[v1][h1-96]=k;}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);set_road(C,h1,v1,h2,v2,1);}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d%d\",&h1,&v1,&h2,&v2,&k);set_road(J,h1,v1,h2,v2,k);}scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);xs=v1;ys=h1-96;xg=v2;yg=h2-96;P[0][0][xs][ys]=1;for(T=0;;T++)for(d=0;d<4;d++){if(P[T][d][xg][yg]){printf(\"%d\\n\",T);goto E;}for(x=1;x<=N;x++)for(y=1;y<=M;y++)if(P[T][d][x][y]&&(!S[x][y]||T/S[x][y]%2!=d%2))for(d1=0;d1<4;d1++){t1=T+D+J[d1][x][y];x1=x+vx[d1];y1=y+vy[d1];if(d1!=(d^2)&&!C[d1][x][y]&&t1<=100&&x1>=1&&x1<=N&&y1>=1&&y1<=M)P[t1][d1][x1][y1]=1;}}E:;}return 0;}"], "original_ll": -1.0215169191360474, "sampled_ll": -0.43885958194732666, "all_perturbed_sampled_ll": [-1.5100762844085693], "all_perturbed_original_ll": [-1.0215169191360474], "perturbed_sampled_ll": -1.5100762844085693, "perturbed_original_ll": -1.0215169191360474, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.awt.Point;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint dx[] = {0,1,0,-1};\n\t\tint dy[] = {-1,0,1,0};\n\t\tboolean pass[] = {true,false,true,false};\n\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tint d = sc.nextInt();\n\n\t\t\tHashMap<Point,Integer> node = new HashMap<Point,Integer>();\n\t\t\tint ns = sc.nextInt();\n\t\t\tfor(int i=0;i<ns;i++){\n\t\t\t\tnode.put(toPoint(sc.next()),sc.nextInt());\n\t\t\t}\n\n\t\t\tHashMap<Point,HashMap<Point,Integer>> edge = new HashMap<Point,HashMap<Point,Integer>>();\n\t\t\tint nc = sc.nextInt();\n\t\t\tfor(int i=0;i<nc;i++){\n\t\t\t\tPoint a = toPoint(sc.next());\n\t\t\t\tPoint b = toPoint(sc.next());\n\t\t\t\tif(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>());\n\t\t\t\tif(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>());\n\t\t\t\tedge.get(a).put(b,-1);\n\t\t\t\tedge.get(b).put(a,-1);\n\t\t\t}\n\n\t\t\tint nj = sc.nextInt();\n\t\t\tfor(int i=0;i<nj;i++){\n\t\t\t\tPoint a = toPoint(sc.next());\n\t\t\t\tPoint b = toPoint(sc.next());\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tif(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>());\n\t\t\t\tif(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>());\n\t\t\t\tedge.get(a).put(b,cost);\n\t\t\t\tedge.get(b).put(a,cost);\n\t\t\t}\n\n\t\t\tPoint start = toPoint(sc.next());\n\t\t\tPoint goal = toPoint(sc.next());\n\n\t\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\t\tHashSet<State> closed = new HashSet<State>();\n\t\t\topen.add(new State(start,1,0));\n\t\t\t//closed.add(new State(start,1,0));\n\t\t\tState ans = null;\n\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState st = open.poll();\n\n\t\t\t\tif(closed.contains(st)) continue;\n\t\t\t\tclosed.add(st);\n\n\t\t\t\tif(st.p.equals(goal)){\n\t\t\t\t\tans = st;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t//U\u0083^\u0081[\u0083\u0093\u0082\u00b5\u0082\u00c4\u0082\u00cd\u0082\u00a2\u0082\u00af\u0082\u00c8\u0082\u00a2\n\t\t\t\t\tif((st.d + 2) % 4 == i) continue;\n\n\t\t\t\t\tPoint np = new Point(st.p.x + dx[i], st.p.y + dy[i]);\n\n\t\t\t\t\tif(np.x>=0 && np.x<w && np.y>=0 && np.y<h){\n\t\t\t\t\t\tint val = 0;\n\t\t\t\t\t\t//st.p\u0082\u00a9\u0082\u00e7np\u0082\u00d6\u0082\u00cc\u0093\u00b9\u008f\u00ee\u0095\u00f1\u0082\u00f0\u008e\u00e6\u0082\u00e8\u008fo\u0082\u00b7\n\t\t\t\t\t\tif(edge.containsKey(st.p) &&\n\t\t\t\t\t\t\t edge.get(st.p).containsKey(np)) val = edge.get(st.p).get(np);\n\t\t\t\t\t\t//\u008dH\u008e\u0096\u0092\u0086\u0082\u00c8\u0082\u00e7\u0092\u00ca\u0082\u00ea\u0082\u00c8\u0082\u00a2\n\t\t\t\t\t\tif(val == -1) continue;\n\n\t\t\t\t\t\tint ncost = st.cost + d + val;\n\n\t\t\t\t\t\t//\u0090M\u008d\u0086\u0082\u00aa\u0082\u00a0\u0082\u00e9\u008f\u00ea\u008d\u0087\u0082\u00cc\u008f\u0088\u0097\u009d\n\t\t\t\t\t\tif(node.containsKey(np)){\n\t\t\t\t\t\t\tint k = node.get(np);\n\t\t\t\t\t\t\tboolean flg = pass[i]; //true:\u0090N\u0093\u00fc\u0089\u00c2\u0094\\\u0082\u00c5\u0082\u00a0\u0082\u00e9\n\t\t\t\t\t\t\tint div = ncost / k;\n\t\t\t\t\t\t\tif(div % 2 == 1) flg = !flg;\n\t\t\t\t\t\t\tif(!flg) continue;\n\t\t\t\t\t\t\t//if(!flg) ncost += k - ncost % k;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\topen.add(new State(np,i,ncost));\n\t\t\t\t\t\tState nst = new State(np,i,ncost);\n\t\t\t\t\t\t//if(closed.contains(nst)) continue;\n\t\t\t\t\t\t//closed.add(nst);\n\t\t\t\t\t\t//open.add(nst);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(ans.cost);\n\t\t}\n\t}\n\n\tprivate static Point toPoint(String s){\n\t\tString[] tmp = s.split(\"-\");\n\t\tint x = Integer.parseInt(tmp[1]) - 1;\n\t\tint y = tmp[0].charAt(0) - 'a';\n\t\treturn new Point(x,y);\n\t}\n}\n\nclass State implements Comparable<State>{\n\tPoint p;\n\tint d,cost;\n\n\tState(Point p,int d,int cost){\n\t\tthis.p = new Point(p.x,p.y);\n\t\tthis.d = d;\n\t\tthis.cost = cost;\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn this.cost - st.cost;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tState st = (State)o;\n\t\treturn p.equals(st.p) && d == st.d;\n\t}\n\n\tpublic int hashCode(){\n\t\treturn p.x + p.y * 100 + d * 10000;\n\t}\n\n\tpublic String toString(){\n\t\treturn String.format(\"[(%d,%d),%d,%d]\",p.x,p.y,d,cost);\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class State implements Comparable<State> {\n        int row, col, time, dir;\n        \n        public State(int row, int col, int time, int dir) {\n            this.row = row;\n            this.col = col;\n            this.time = time;\n            this.dir = dir;\n        }\n        \n        public int compareTo(State other) {\n            return this.time - other.time;\n        }\n    }\n    \n    static final int EAST = 0, WEST = 1, SOUTH = 2, NORTH = 3;\n    static final int[] DR = {0, 0, 1, -1};\n    static final int[] DC = {1, -1, 0, 0};\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] tokens = line.trim().split(\"\\\\s+\");\n            int M = Integer.parseInt(tokens[0]);\n            int N = Integer.parseInt(tokens[1]);\n            \n            if (M == 0 && N == 0) break;\n            \n            int D = Integer.parseInt(br.readLine().trim());\n            \n            int[][] signal = new int[M][N];\n            for (int i = 0; i < M; i++) {\n                Arrays.fill(signal[i], -1);\n            }\n            \n            int ns = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < ns; i++) {\n                tokens = br.readLine().trim().split(\"\\\\s+\");\n                String[] pos = tokens[0].split(\"-\");\n                int row = pos[0].charAt(0) - 'a';\n                int col = Integer.parseInt(pos[1]) - 1;\n                int k = Integer.parseInt(tokens[1]);\n                signal[row][col] = k;\n            }\n            \n            boolean[][][] blocked = new boolean[M][N][4];\n            int nc = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < nc; i++) {\n                tokens = br.readLine().trim().split(\"\\\\s+\");\n                String[] pos1 = tokens[0].split(\"-\");\n                String[] pos2 = tokens[1].split(\"-\");\n                int r1 = pos1[0].charAt(0) - 'a';\n                int c1 = Integer.parseInt(pos1[1]) - 1;\n                int r2 = pos2[0].charAt(0) - 'a';\n                int c2 = Integer.parseInt(pos2[1]) - 1;\n                \n                for (int d = 0; d < 4; d++) {\n                    if (r1 + DR[d] == r2 && c1 + DC[d] == c2) {\n                        blocked[r1][c1][d] = true;\n                        blocked[r2][c2][d ^ 1] = true;\n                    }\n                }\n            }\n            \n            int[][] congestion = new int[M][N];\n            for (int i = 0; i < M; i++) {\n                for (int j = 0; j < N; j++) {\n                    congestion[i][j] = D;\n                }\n            }\n            \n            int nj = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < nj; i++) {\n                tokens = br.readLine().trim().split(\"\\\\s+\");\n                String[] pos1 = tokens[0].split(\"-\");\n                String[] pos2 = tokens[1].split(\"-\");\n                int r1 = pos1[0].charAt(0) - 'a';\n                int c1 = Integer.parseInt(pos1[1]) - 1;\n                int r2 = pos2[0].charAt(0) - 'a';\n                int c2 = Integer.parseInt(pos2[1]) - 1;\n                int d = Integer.parseInt(tokens[2]);\n                \n                congestion[r1][c1] = Math.max(congestion[r1][c1], D + d);\n            }\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            String[] start = tokens[0].split(\"-\");\n            String[] end = tokens[1].split(\"-\");\n            int sr = start[0].charAt(0) - 'a';\n            int sc = Integer.parseInt(start[1]) - 1;\n            int er = end[0].charAt(0) - 'a';\n            int ec = Integer.parseInt(end[1]) - 1;\n            \n            int result = dijkstra(M, N, sr, sc, er, ec, signal, blocked, congestion);\n            System.out.println(result);\n        }\n    }\n    \n    static int dijkstra(int M, int N, int sr, int sc, int er, int ec, \n                        int[][] signal, boolean[][][] blocked, int[][] congestion) {\n        int[][][] dist = new int[M][N][4];\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                Arrays.fill(dist[i][j], Integer.MAX_VALUE);\n            }\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(sr, sc, 0, EAST));\n        dist[sr][sc][EAST] = 0;\n        \n        while (!pq.isEmpty()) {\n            State curr = pq.poll();\n            \n            if (curr.row == er && curr.col == ec) {\n                return curr.time;\n            }\n            \n            if (curr.time > dist[curr.row][curr.col][curr.dir]) continue;\n            \n            for (int d = 0; d < 4; d++) {\n                if (d == (curr.dir ^ 1)) continue;\n                \n                if (blocked[curr.row][curr.col][d]) continue;\n                \n                if (signal[curr.row][curr.col] != -1) {\n                    int k = signal[curr.row][curr.col];\n                    int cycle = curr.time / k;\n                    boolean isNSGreen = (cycle % 2 == 0);\n                    boolean isEWGreen = !isNSGreen;\n                    \n                    if ((d == EAST || d == WEST) && !isEWGreen) continue;\n                    if ((d == NORTH || d == SOUTH) && !isNSGreen) continue;\n                }\n                \n                int nr = curr.row + DR[d];\n                int nc = curr.col + DC[d];\n                \n                if (nr < 0 || nr >= M || nc < 0 || nc >= N) continue;\n                \n                int travelTime = congestion[curr.row][curr.col];\n                int newTime = curr.time + travelTime;\n                \n                if (newTime < dist[nr][nc][d]) {\n                    dist[nr][nc][d] = newTime;\n                    pq.offer(new State(nr, nc, newTime, d));\n                }\n            }\n        }\n        \n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class State implements Comparable<State> { int row, col, time, dir;  this.row = row; this.col = col; this.time = time; this.dir = dir; } public int compareTo(State other) { return this.time - other.time; } } static final int EAST = 0, WEST = 1, SOUTH = 2, NORTH = 3; static final int[] DR = {0, 0, 1,   br.readLine()) != null) { String[] tokens = line.trim().split(\"\\\\s+\"); int M = Integer.parseInt(tokens[0]); int N = Integer.parseInt(tokens[1]); if (M == 0 && N == 0) break; int D = Integer.parseInt(br.readLine().trim()); int[][] signal = new int[M][N];  Arrays.fill(signal[i], -1); } int ns = Integer.parseInt(br.readLine().trim()); for (int i = 0; i < ns; i++) {  pos[0].charAt(0) - 'a'; int col = Integer.parseInt(pos[1]) - 1; int k = Integer.parseInt(tokens[1]); signal[row][col] = k; } boolean[][][] blocked = new boolean[M][N][4]; int nc = Integer.parseInt(br.readLine().trim()); for (int i =  = pos1[0].charAt(0) - 'a'; int c1 = Integer.parseInt(pos1[1]) - 1; int r2 = pos2[0].charAt(0) - 'a'; int c2 = Integer.parseInt(pos2[1]) - 1; for  (r1 + DR[d] == r2 && c1 + DC[d] == c2) { blocked[r1][c1][d] =  i < M; i++) {  { tokens = br.readLine().trim().split(\"\\\\s+\"); String[] pos1 =  = pos2[0].charAt(0) - 'a'; int c2 = Integer.parseInt(pos2[1]) - 1; int d = Integer.parseInt(tokens[2]); congestion[r1][c1]  start = tokens[0].split(\"-\"); String[] end  = Integer.parseInt(start[1]) - 1; int er = end[0].charAt(0)  = dijkstra(M,  } static int   dist = new int[M][N][4];  for (int j = 0; j < N; j++) { Arrays.fill(dist[i][j], Integer.MAX_VALUE);  0, EAST)); dist[sr][sc][EAST] = 0; while (!pq.isEmpty()) { State curr = pq.poll(); if (curr.row == er && curr.col == ec) { return curr.time; } if (curr.time  4; d++) { if (d == (curr.dir ^ 1)) continue; if (blocked[curr.row][curr.col][d]) continue; if (signal[curr.row][curr.col] != -1) { int k = signal[curr.row][curr.col];  % 2 == 0); boolean isEWGreen = !isNSGreen; if ((d == EAST || d == WEST) && !isEWGreen) continue; if ((d == NORTH || d == SOUTH) && !isNSGreen) continue; } int nr = curr.row + DR[d]; int  = curr.time  -1; } }"], "perturbed_original": ["import java.util.*; import java.awt.Point; public  new Scanner(System.in); int dx[] = {0,1,0,-1}; int dy[] = {-1,0,1,0}; boolean pass[] = {true,false,true,false}; while(true){ int h = sc.nextInt(); int w = sc.nextInt(); if(w == 0 && h == 0) break; int d = sc.nextInt(); HashMap<Point,Integer> node = new HashMap<Point,Integer>(); int ns = sc.nextInt(); for(int i=0;i<ns;i++){ node.put(toPoint(sc.next()),sc.nextInt()); } HashMap<Point,HashMap<Point,Integer>> edge =  = toPoint(sc.next()); Point b = toPoint(sc.next()); if(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>()); if(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>()); edge.get(a).put(b,-1); edge.get(b).put(a,-1); } int nj = sc.nextInt(); for(int i=0;i<nj;i++){ Point a  closed = new HashSet<State>(); open.add(new  = open.poll(); if(closed.contains(st)) continue; closed.add(st); if(st.p.equals(goal)){ ans = st; break; } for(int i=0;i<4;i++){ //U\u0083^\u0081[\u0083\u0093\u0082\u00b5\u0082\u00c4\u0082\u00cd\u0082\u00a2\u0082\u00af\u0082\u00c8\u0082\u00a2 if((st.d + 2) % 4 == i) continue; Point np = new Point(st.p.x + dx[i], st.p.y + dy[i]); if(np.x>=0 &&  if(edge.containsKey(st.p) && edge.get(st.p).containsKey(np)) val = edge.get(st.p).get(np); //\u008dH\u008e\u0096\u0092\u0086\u0082\u00c8\u0082\u00e7\u0092\u00ca\u0082\u00ea\u0082\u00c8\u0082\u00a2 if(val == -1) continue; int ncost = st.cost + d + val;  pass[i]; //true:\u0090N\u0093\u00fc\u0089\u00c2\u0094\\\u0082\u00c5\u0082 \u0082\u00e9 int div =  !flg; if(!flg) continue; //if(!flg) ncost  nst = new State(np,i,ncost); //if(closed.contains(nst)) continue; //closed.add(nst); //open.add(nst); } } } System.out.println(ans.cost); } } private static Point toPoint(String s){ String[] tmp = s.split(\"-\");  cost){ this.p =  boolean equals(Object o){  } public int hashCode(){ return p.x + p.y * 100 +  }"], "original_ll": -0.9108591675758362, "sampled_ll": -0.35232213139533997, "all_perturbed_sampled_ll": [-1.2790218591690063], "all_perturbed_original_ll": [-1.7643027305603027], "perturbed_sampled_ll": -1.2790218591690063, "perturbed_original_ll": -1.7643027305603027, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#Byakko Delivery Company\nfrom heapq import heappop, heappush\nfrom string import ascii_lowercase as al\ndic = dict([(c,i) for i, c in enumerate(al)])\nf = lambda (h, v):(dic[h], int(v) - 1)\ng = lambda s:f(s.split(\"-\"))\n\ndef solve():\n    hq = [(0, start[0], start[1])]\n    while len(hq) != 0:\n        cost, cy, cx = heappop(hq)\n        #print \"cost = {}, pos = ({}, {})\".format(cost, cy, cx)\n        if (cy, cx) == goal:\n            return cost\n        for dy, dx in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            ny, nx = cy + dy, cx + dx\n            if 0 <= ny < M and 0 <= nx < N:\n                #print ny, nx, condition[ny][nx][cy][cx]\n                nc = condition[ny][nx][cy][cx] + D + cost\n                if field[ny][nx] == 0:\n                    heappush(hq, (nc, ny, nx))\n                else:\n                    if dy == 0:\n                        if (nc / field[ny][nx]) % 2 == 1:\n                            heappush(hq, (nc, ny, nx))\n                    else:\n                        if (nc / field[ny][nx]) % 2 == 0:\n                            heappush(hq, (nc, ny, nx))\nwhile True:\n    M, N = map(int, raw_input().split())\n    if M | N == 0:\n        break\n    D = input()\n    field = [[0] * N for _ in xrange(M)]\n    condition = [[[[0] * N for _ in xrange(M)] for _ in xrange(N)] for _ in xrange(M)]\n    for _ in xrange(input()):\n        p, k = raw_input().split()\n        h, v = g(p)\n        field[h][v] = int(k)\n\n    for _ in xrange(input()):    \n        (h1, v1), (h2, v2) = map(g, raw_input().split())\n        condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = 1 << 30\n\n    for _ in xrange(input()):\n        p1, p2, d = raw_input().split()\n        h1, v1 = g(p1)\n        h2, v2 = g(p2)\n        condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = int(d)\n\n    start, goal = map(g, raw_input().split())\n    print solve()", "sampled": "import heapq\nfrom collections import defaultdict\n\ndef parse_intersection(s):\n    parts = s.split('-')\n    h = ord(parts[0]) - ord('a')\n    v = int(parts[1]) - 1\n    return (h, v)\n\ndef solve():\n    while True:\n        line = input().split()\n        M, N = int(line[0]), int(line[1])\n        if M == 0 and N == 0:\n            break\n        \n        D = int(input())\n        \n        ns = int(input())\n        signals = {}\n        for _ in range(ns):\n            parts = input().split()\n            pos = parse_intersection(parts[0])\n            k = int(parts[1])\n            signals[pos] = k\n        \n        nc = int(input())\n        blocked = set()\n        for _ in range(nc):\n            parts = input().split()\n            pos1 = parse_intersection(parts[0])\n            pos2 = parse_intersection(parts[1])\n            blocked.add((min(pos1, pos2), max(pos1, pos2)))\n        \n        nj = int(input())\n        jams = {}\n        for _ in range(nj):\n            parts = input().split()\n            pos1 = parse_intersection(parts[0])\n            pos2 = parse_intersection(parts[1])\n            d = int(parts[2])\n            key = (min(pos1, pos2), max(pos1, pos2))\n            jams[key] = d\n        \n        parts = input().split()\n        start = parse_intersection(parts[0])\n        end = parse_intersection(parts[1])\n        \n        # Dijkstra with state (time, pos, direction)\n        # direction: 0=E, 1=W, 2=S, 3=N\n        pq = [(0, start, 0)]\n        visited = set()\n        \n        # Direction vectors: E, W, S, N\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        # EW: 0,1  NS: 2,3\n        \n        while pq:\n            time, pos, prev_dir = heapq.heappop(pq)\n            \n            if pos == end:\n                print(time)\n                break\n            \n            state = (pos, prev_dir)\n            if state in visited:\n                continue\n            visited.add(state)\n            \n            h, v = pos\n            \n            for d in range(4):\n                # No U-turn\n                if prev_dir == 0 and d == 1:\n                    continue\n                if prev_dir == 1 and d == 0:\n                    continue\n                if prev_dir == 2 and d == 3:\n                    continue\n                if prev_dir == 3 and d == 2:\n                    continue\n                \n                dh, dv = dirs[d]\n                nh, nv = h + dh, v + dv\n                \n                if nh < 0 or nh >= M or nv < 0 or nv >= N:\n                    continue\n                \n                new_pos = (nh, nv)\n                edge = (min(pos, new_pos), max(pos, new_pos))\n                \n                if edge in blocked:\n                    continue\n                \n                # Check signal at current position\n                if pos in signals:\n                    k = signals[pos]\n                    cycle_time = time % (2 * k)\n                    # At time 0, NS is green (d=2,3)\n                    # 0 to k-1: NS green (EW red)\n                    # k to 2k-1: EW green (NS red)\n                    \n                    if d in [0, 1]:  # EW direction\n                        if cycle_time < k:  # NS is green, EW is red\n                            continue\n                    else:  # NS direction\n                        if cycle_time >= k:  # EW is green, NS is red\n                            continue\n                \n                travel_time = D\n                if edge in jams:\n                    travel_time += jams[edge]\n                \n                new_time = time + travel_time\n                \n                if new_time <= 100:\n                    heapq.heappush(pq, (new_time, new_pos, d))\n\nsolve()\n", "perturbed_sampled": ["import heapq from collections import defaultdict def parse_intersection(s): parts = s.split('-') h = ord(parts[0]) -  solve(): while True: line = input().split() M, N  0: break D = int(input()) ns = int(input())  pos  int(input()) blocked = set() for _ in range(nc): parts = input().split() pos1 = parse_intersection(parts[0]) pos2 = parse_intersection(parts[1]) blocked.add((min(pos1, pos2), max(pos1, pos2))) nj = int(input()) jams = {} for _ in range(nj): parts = input().split() pos1 = parse_intersection(parts[0]) pos2 = parse_intersection(parts[1]) d = int(parts[2]) key = (min(pos1, pos2), max(pos1, pos2)) jams[key] = d  = set() # Direction vectors: E, W, S, N dirs = [(0, 1), (0, -1),  end: print(time) break state = (pos, prev_dir) if state in visited: continue visited.add(state) h, v = pos for d in range(4): # No U-turn if  == 1 and d == 0: continue if prev_dir == 2 and d == 3:  >= N: continue new_pos = (nh,  blocked: continue # Check signal at current position if pos in signals: k = signals[pos] cycle_time = time % (2 * k) # At time 0, NS is green  k to 2k-1: EW green (NS red)  continue else: # NS direction if cycle_time >= k: # EW is green, NS is red continue travel_time = D if edge in  new_time <= 100: heapq.heappush(pq, (new_time, new_pos, d)) solve()"], "perturbed_original": ["#Byakko Delivery Company from heapq import heappop,  for i, c in enumerate(al)]) f = lambda (h, v):(dic[h], int(v) - 1) g = lambda s:f(s.split(\"-\")) def solve(): hq = [(0, start[0], start[1])] while len(hq) != 0: cost, cy, cx = heappop(hq) #print \"cost = {}, pos = ({}, {})\".format(cost, cy, cx) if (cy, cx) == goal: return cost for dy, dx in ((0, 1), (0, -1), (1, 0), (-1, 0)): ny, nx = cy + dy, cx + dx if 0 <= ny < M and 0 <=  (nc /  (nc, ny, nx)) while True: M, N = map(int, raw_input().split()) if  _ in xrange(N)] for _ in xrange(M)] for _ in  = int(k) for _ in xrange(input()): (h1, v1), (h2, v2) = map(g, raw_input().split()) condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = 1 << 30 for _  g(p1) h2,  = map(g, raw_input().split()) print solve()"], "original_ll": -0.8300942778587341, "sampled_ll": -0.7739471197128296, "all_perturbed_sampled_ll": [-2.263505220413208], "all_perturbed_original_ll": [-1.9176855087280273], "perturbed_sampled_ll": -2.263505220413208, "perturbed_original_ll": -1.9176855087280273, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\t\n\tint i,sum,a,b,c;\n\tint top,topn;\n\t\n\ttop = 0;\n\t\n\twhile(1){\n\t\t\n\t\tscanf(\" %d %d\",&a,&b);\n\t\t\n\t\tif(a == 0 && b == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tc = a + b;\n\t\t\n\t\tif(top > c){\n\t\t\ttop = c;\n\t\t\ttopn = i;\n\t\t}\n\t\t\n\t\ti++;\n\t\t\n\t\tif(i==5){\n\t\t\tswitch(topn){\n\t\t\t\tcase 1:\n\t\t\t\t\tprintf(\"A \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tprintf(\"B \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tprintf(\"C \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tprintf(\"D \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tprintf(\"E \");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tprintf(\" %d\",top);\n\t\t}\n\t}\n\t\n\treturn(0);\n\t\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int s1, s2;\n    char stores[] = {'A', 'B', 'C', 'D', 'E'};\n    int totals[5];\n    \n    while(1) {\n        scanf(\"%d %d\", &s1, &s2);\n        if(s1 == 0 && s2 == 0) break;\n        \n        totals[0] = s1 + s2;\n        \n        for(int i = 1; i < 5; i++) {\n            scanf(\"%d %d\", &s1, &s2);\n            totals[i] = s1 + s2;\n        }\n        \n        int maxIndex = 0;\n        int maxTotal = totals[0];\n        \n        for(int i = 1; i < 5; i++) {\n            if(totals[i] > maxTotal) {\n                maxTotal = totals[i];\n                maxIndex = i;\n            }\n        }\n        \n        printf(\"%c %d\\n\", stores[maxIndex], maxTotal);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int =0; int 'C', 'D', 'E'}; int totals[5]; while(1) { scanf(\"%d =0;<extra_id_1>store<extra_id_2>maxMax; if(totals[i]<extra_id_3>{ if(totals[i]<extra_id_4>sum =<extra_id_5>> sum) { sum<extra_id_6>sum++; }<extra_id_7>%d\\n\",<extra_id_8>++i=0 ; i++) { continue;<extra_id_9>=<extra_id_10>i]);<extra_id_11>total); }<extra_id_12>=<extra_id_13>i<extra_id_14>=<extra_id_15>i<extra_id_22>] ; i = 0<extra_id_23>int i<extra_id_24>i<extra_id_25>++ 1; i < 5; i++) { scanf(\"%d %d\", &s1, &s2); totals[i] = s1 + s2; } int maxIndex = 0; int  i++) { if(totals[i] > maxTotal) { maxTotal = totals[i]; maxIndex = i; } } printf(\"%c %d\\n\", stores[maxIndex], maxTotal); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int i,sum,a,b,c; int top,topn; top = 0; while(1){ scanf(\" %d %d\",&a,&b); if(a == 0 \"); break; case 6: printf(\"E<extra_id_1>case 0: printf(\"F \");<extra_id_2>printf(\"C \"); break;<extra_id_3>case<extra_id_4>printf(\"F \"); break;<extra_id_5>printf(\"F\"); break; case 0: printf(\"F<extra_id_6>printf(\"E \") ; break;<extra_id_7>} }<extra_id_8>\" )<extra_id_9>case 6:<extra_id_10>}<extra_id_11>1; if(a == 0<extra_id_12>>=<extra_id_13>4){<extra_id_14>0 ; a =<extra_id_15>1 b; if(top > c){ top = c; topn = i; } i++; if(i==5){ switch(topn){ case 1: printf(\"A  \"); break; case 4: printf(\"D \"); break; case  }"], "original_ll": -0.8859415054321289, "sampled_ll": -0.48454317450523376, "all_perturbed_sampled_ll": [-2.0660643577575684], "all_perturbed_original_ll": [-2.094311237335205], "perturbed_sampled_ll": -2.0660643577575684, "perturbed_original_ll": -2.094311237335205, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tString[] k = new String[]{\"A\",\"B\",\"C\",\"D\",\"E\"};\n\t\twhile(true) {\n\t\t\tint number = 0;\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < 5; i++) {\n\t\t\t\tint tmp = stdIn.nextInt();\n\t\t\t\ttmp += stdIn.nextInt();\n\t\t\t\tif(tmp == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(tmp > max) {\n\t\t\t\t\tmax = tmp;\n\t\t\t\t\tnumber = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(k[number] + \" \" + max);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int s1A = sc.nextInt();\n            int s2A = sc.nextInt();\n            \n            if (s1A == 0 && s2A == 0) {\n                break;\n            }\n            \n            int s1B = sc.nextInt();\n            int s2B = sc.nextInt();\n            int s1C = sc.nextInt();\n            int s2C = sc.nextInt();\n            int s1D = sc.nextInt();\n            int s2D = sc.nextInt();\n            int s1E = sc.nextInt();\n            int s2E = sc.nextInt();\n            \n            int totalA = s1A + s2A;\n            int totalB = s1B + s2B;\n            int totalC = s1C + s2C;\n            int totalD = s1D + s2D;\n            int totalE = s1E + s2E;\n            \n            int max = totalA;\n            String store = \"A\";\n            \n            if (totalB > max) {\n                max = totalB;\n                store = \"B\";\n            }\n            if (totalC > max) {\n                max = totalC;\n                store = \"C\";\n            }\n            if (totalD > max) {\n                max = totalD;\n                store = \"D\";\n            }\n            if (totalE > max) {\n                max = totalE;\n                store = \"E\";\n            }\n            \n            System.out.println(store + \" \" + max);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner  sc.nextInt(); int s2A = sc.nextInt(); if (s1A == 0 && s2A == 0) { break; } int s1B = sc.nextInt(); int  sc.nextInt();  = sc.nextInt(); int s2E = sc.nextInt(); int totalA = s1A + s2A; int totalB = s1B + s2B;  + s2D; int totalE = s1E + s2E; int max = totalA; String store = \"A\"; if (totalB > max) {  = \"D\";  = \"E\"; } System.out.println(store + \" \" + max); } sc.close(); } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Scanner; public  stdIn = new Scanner(System.in); String[] k = new String[]{\"A\",\"B\",\"C\",\"D\",\"E\"}; while(true) { int number = 0; int max =  int  return; } if(tmp > max) { max = tmp; number = i; } } System.out.println(k[number] + \" \" + max); } } }"], "original_ll": -0.8315028548240662, "sampled_ll": -0.2955358922481537, "all_perturbed_sampled_ll": [-1.319684624671936], "all_perturbed_original_ll": [-1.9299860000610352], "perturbed_sampled_ll": -1.319684624671936, "perturbed_original_ll": -1.9299860000610352, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# Aizu Problem 0195: What is the Most Popular Shop in Tokaichi?\n#\nimport sys, math, os\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\nwhile True:\n    most = 0\n    shop = 'A'\n    a, b = [int(_) for _ in input().split()]\n    if a == b == 0:\n        break\n    most = a + b\n    for s in range(4):\n        a = sum([int(_) for _ in input().split()])\n        if a > most:\n            most = a\n            shop = chr(66 + s)\n    print(shop, most)\n            ", "sampled": "import sys\n\nfor line in sys.stdin:\n    s1_A, s2_A = map(int, line.split())\n    if s1_A == 0 and s2_A == 0:\n        break\n    \n    stores = []\n    stores.append(('A', s1_A + s2_A))\n    \n    for store_name in ['B', 'C', 'D', 'E']:\n        s1, s2 = map(int, input().split())\n        stores.append((store_name, s1 + s2))\n    \n    max_store = max(stores, key=lambda x: x[1])\n    print(max_store[0], max_store[1])\n", "perturbed_sampled": ["import sys for line in  and s2_A == 0: break stores =  'D', 'E']: s1, s2 = map(int, input().split()) stores.append((store_name, s1 + s2)) max_store = max(stores, key=lambda x: x[1]) print(max_store[0], max_store[1])"], "perturbed_original": ["# Aizu Problem 0195: What is  os # read input: PYDEV = os.environ.get('PYDEV') if PYDEV==\"True\": sys.stdin = open(\"sample-input.txt\", \"rt\") while True: most = 0 shop = 'A'  b  input().split()]) if a > most: most = a shop = chr(66 + s) print(shop, most)"], "original_ll": -1.7723212242126465, "sampled_ll": -0.963982105255127, "all_perturbed_sampled_ll": [-2.652130126953125], "all_perturbed_original_ll": [-3.243800401687622], "perturbed_sampled_ll": -2.652130126953125, "perturbed_original_ll": -3.243800401687622, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0196: Baseball Championship\n// 2017.8.3\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar *gets(char *);\nchar buf[500], *p;\n\nint getInt(void)\n{\n\tint n = 0;\n\twhile (isspace(*p)) p++;\n\treturn *p++ - '0';\n}\n\nchar getStr(void)\n{\n\twhile (isspace(*p)) p++;\n\treturn *p++;\n}\n\ntypedef struct { char a; int k, w, l; } T;\nT t[15];\n\nint main()\n{\n\tint i, j, k, n;\n\tT tmp, *tp, *tt;\n\n\twhile (1) {\n\t\tgets(buf);\n\t\tif (!(n = atoi(buf))) break;\n\t\tfor (i = 0, tp = t; i < n; i++, tp++) {\n\t\t\tgets(p = buf);\n\t\t\ttp->a = getStr(), tp->k = i, tp->w = tp->l = 0;\n\t\t\tfor (j = 1; j < n; j++) {\n\t\t\t\tk = getInt();\n\t\t\t\tif (k == 0) tp->w++;\n\t\t\t\telse if (k == 1) tp->l++;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < n; i++) {\n\t\t\ttp = t + i;\n\t\t\tfor (j = i+1, tt = tp+1; j < n; j++, tt++) {\n\t\t\t\tif (tt->w > tp->w) tp = tt;\n\t\t\t\telse if (tt->w == tp->w) {\n\t\t\t\t\tif (tt->l < tp->l) tp = tt;\n\t\t\t\t\telse if (tt->l == tp->l && tt->k < tp->k) tp = tt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tp != t + i) {\n\t\t\t\tmemcpy(&tmp, t+i, sizeof(tmp));\n\t\t\t\tmemcpy(t+i, tp, sizeof(tmp));\n\t\t\t\tmemcpy(tp, &tmp, sizeof(tmp));\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < n; i++) putchar(t[i].a), putchar('\\n');\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name;\n    int wins;\n    int losses;\n    int order;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    \n    if (ta->wins != tb->wins) {\n        return tb->wins - ta->wins;\n    }\n    if (ta->losses != tb->losses) {\n        return ta->losses - tb->losses;\n    }\n    return ta->order - tb->order;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Team teams[10];\n        \n        for (int i = 0; i < n; i++) {\n            char name;\n            scanf(\" %c\", &name);\n            \n            teams[i].name = name;\n            teams[i].wins = 0;\n            teams[i].losses = 0;\n            teams[i].order = i;\n            \n            for (int j = 0; j < n - 1; j++) {\n                int result;\n                scanf(\"%d\", &result);\n                \n                if (result == 0) {\n                    teams[i].wins++;\n                } else if (result == 1) {\n                    teams[i].losses++;\n                }\n            }\n        }\n        \n        qsort(teams, n, sizeof(Team), compare);\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%c\\n\", teams[i].name);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef struct { char name; int wins; int losses; int order; }  *ta = (Team *)a; Team *tb = (Team *)b; if (ta->wins != tb->wins) { return  ta->losses -  0; i < n; i++) { char name; scanf(\" %c\", &name); teams[i].name = name; teams[i].wins = 0; teams[i].losses = 0; teams[i].order = i; for (int j = 0; j < n - 1; j++) { int result; scanf(\"%d\",  (result == 1) { teams[i].losses++; }  0; i < n; i++) { printf(\"%c\\n\", teams[i].name); } } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0196: Baseball Championship //  *gets(char *); char buf[500], *p; int getInt(void) { int n = 0; while (isspace(*p)) p++; return *p++ - '0';  typedef struct { char  main() { int i, j, k, n; T tmp, *tp, *tt;  (i = 0, tp = t; i <  tp->k  1; j < n; j++) { k = getInt(); if (k ==  tp = t + i; for (j  { if (tt->w > tp->w) tp = tt; else if (tt->w == tp->w) { if (tt->l < tp->l) tp = tt; else if (tt->l == tp->l &&  != t + i) { memcpy(&tmp, t+i, sizeof(tmp)); memcpy(t+i, tp, sizeof(tmp)); memcpy(tp, &tmp, sizeof(tmp)); } }  } return 0; }"], "original_ll": -0.8585205674171448, "sampled_ll": -0.3739679753780365, "all_perturbed_sampled_ll": [-1.5794330835342407], "all_perturbed_original_ll": [-2.187304735183716], "perturbed_sampled_ll": -1.5794330835342407, "perturbed_original_ll": -2.187304735183716, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.*;\nimport java.util.*;\n\n\n// 2011/10/23\n\n// 0196 \u0096\u00ec\u008b\u0085\u0091\u00e5\u0089\u00ef\npublic class Main {\n\t\n\t\n\tclass Team implements Comparable<Team> {\n\t\tString name;\n\t\tint win;\n\t\tint lose;\n\t\tpublic Team(String name, int win, int lose) {\n\t\t\tthis.name = name;\n\t\t\tthis.win = win;\n\t\t\tthis.lose = lose;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Team o) {\n\t\t\tif (win != o.win) {\n\t\t\t\treturn -(win - o.win);\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn (lose - o.lose);\n\t\t}\n\t\t\n\t}\n\t\n\n\t// \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2\n\tboolean main() throws IOException {\n\n\t\tint n = readIntArray()[0];\n\t\tif (n == 0)\n\t\t\treturn false;\n\t\t\n\t\tList<Team> list = new ArrayList<Team>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tString s = reader.readLine();\n\t\t\tString[] sp = s.split(\" \");\n\t\t\t\n\t\t\tint win = 0;\n\t\t\tint lose = 0;\n\t\t\tfor(int j = 0; j < n - 1; j++) {\n\t\t\t\tString r = sp[j + 1];\n\t\t\t\tif (r.equals(\"0\")) {\n\t\t\t\t\twin++;\n\t\t\t\t}\n\t\t\t\telse if (r.equals(\"1\")) {\n\t\t\t\t\tlose++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist.add(new Team(sp[0], win, lose));\n\t\t}\t\n\t\t\n\t\tCollections.sort(list);\n\t\t\n\t\tfor(Team t: list) {\n\t\t\tSystem.out.printf(\"%s\\n\", t.name);\n\t\t}\n\t\t\n//\t\tSystem.out.printf(\"%d\\n\", sum / size);\n\t\t\n\t\treturn true; // \u0090\u00b3\u008f\u00ed\u008fI\u0097\u00b9 \u008e\u009f\u0082\u00d6\n\t}\n\t\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\t\t\t\n\t\t\tString inputStr = \"1:15:\";\n\n\t\t\tinputStr = inputStr.replace(\":\", \"\\n\");\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr)); \n\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // \u008f\u0091\u0082\u00ab\u008e\u00cc\u0082\u00c4\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // \u0083R\u0083\u0093\u0083\\\u0081[\u0083\u008b\u0082\u00a9\u0082\u00e7\n\t\t}\n\t\t\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t}\n\n\t\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\t\n\n\t// \u0095W\u008f\u0080\u0093\u00fc\u0097\u00cd\u0082\u00e6\u0082\u00e81\u008ds\u0095\u00aa\u0082\u00cc\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0095\u00b6\u008e\u009a\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0082\u00c5\u0082\u00cc\u0090\u00ae\u0090\u0094\u0092l\u0082\u00f0\u0093\u00c7\u0082\u00de\n\t// EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7\n\tprivate static int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = reader.readLine();\n//\t\t\tlog.printf(\"%s\\n\", s);\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // \u0081\u00a6\u0081\u00a6\u0081\u00a6\u0081@\u0082\u00c7\u0082\u00a4\u0082\u00e0\u0093\u00cb\u0091R\u008b\u00f3\u008ds\u0082\u00f0\u0093\u00c7\u0082\u00de\u0082\u00b1\u0082\u00c6\u0082\u00aa\u0082\u00a0\u0082\u00e9\u0081B\u0093\u00c7\u0082\u00dd\u0094\u00f2\u0082\u00ce\u0082\u00b7\u0082\u00c6\u0082\u00a4\u0082\u00dc\u0082\u00ad\u0082\u00a2\u0082\u00ad\u0082\u00e7\u0082\u00b5\u0082\u00a2\u0081B\u0081B\u0081B\u0081B\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tString[] sp = s.split(\"[ ,]\"); // \u008b\u00e6\u0090\u00d8\u0082\u00e8\u0095\u00b6\u008e\u009a\u0082\u00cd\u0083X\u0083y\u0081[\u0083X\u0082\u00a9\u0083J\u0083\u0093\u0083}\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\t\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Team {\n        String name;\n        int wins;\n        int losses;\n        int order;\n        \n        Team(String name, int wins, int losses, int order) {\n            this.name = name;\n            this.wins = wins;\n            this.losses = losses;\n            this.order = order;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            List<Team> teams = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                String teamName = sc.next();\n                int wins = 0;\n                int losses = 0;\n                \n                for (int j = 0; j < n - 1; j++) {\n                    int result = sc.nextInt();\n                    if (result == 0) {\n                        wins++;\n                    } else if (result == 1) {\n                        losses++;\n                    }\n                }\n                \n                teams.add(new Team(teamName, wins, losses, i));\n            }\n            \n            Collections.sort(teams, new Comparator<Team>() {\n                @Override\n                public int compare(Team t1, Team t2) {\n                    if (t1.wins != t2.wins) {\n                        return t2.wins - t1.wins;\n                    }\n                    if (t1.losses != t2.losses) {\n                        return t1.losses - t2.losses;\n                    }\n                    return t1.order - t2.order;\n                }\n            });\n            \n            for (Team team : teams) {\n                System.out.println(team.name);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  name; int wins; int losses; int order; Team(String name, int wins, int losses, int order) { this.name  order; } } public static void main(String[] args)  n  new ArrayList<>(); for (int i = 0; i < n; i++) { String teamName = sc.next(); int wins = 0; int losses =  1; j++) { int result =  (result == 1) { losses++; } } teams.add(new Team(teamName, wins,  { return t2.wins - t1.wins; } if (t1.losses != t2.losses) { return t1.losses - t2.losses; } return t1.order - t2.order; } }); for (Team team : teams) { System.out.println(team.name); } } sc.close(); } }"], "perturbed_original": ["import java.io.*; import java.util.*; // 2011/10/23 // 0196 \u0096\u00ec\u008b \u0091\u00e5\u0089\u00ef public class  win; int lose; public Team(String name, int win, int lose) {  @Override public int compareTo(Team o) { if (win != o.win) { return -(win - o.win); } else return (lose - o.lose); } } // \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2 boolean main()  0) return false; List<Team> list = new  int win = 0; int lose = 0; for(int j = 0; j < n - 1; j++) { String r = sp[j + 1]; if (r.equals(\"0\"))  list.add(new Team(sp[0], win, lose)); } Collections.sort(list); for(Team t: list) { System.out.printf(\"%s\\n\", t.name); } //  debug private final static boolean DEBUG = false; // release public static  \"\\n\"); reader = new BufferedReader(new StringReader(inputStr)); } else { log = new  //  = 0; i < N; i++) { boolean b = new Main().main();  BufferedReader reader; // \u0095W\u008f\u0080\u0093\u00fc\u0097\u00cd\u0082\u00e6\u0082\u00e81\u008ds\u0095\u00aa\u0082\u00cc\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0095\u00b6\u008e\u009a\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0082\u00c5\u0082\u00cc\u0090\u00ae\u0090\u0094\u0092l\u0082\u00f0\u0093\u00c7\u0082\u00de // EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7 private static int[] readIntArray() throws IOException { String s =  (s == null) return null; s = s.trim(); if (s.length()  for(int i = 0; i < sp.length; i++) { a[i] = Integer.parseInt(sp[i]); } return a; } }"], "original_ll": -1.4343832731246948, "sampled_ll": -0.28914400935173035, "all_perturbed_sampled_ll": [-1.637332797050476], "all_perturbed_original_ll": [-2.3276045322418213], "perturbed_sampled_ll": -1.637332797050476, "perturbed_original_ll": -2.3276045322418213, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(raw_input())\n    if n == 0: break\n    ans = [[0]*4 for i in range(n)]\n    for i in range(n):\n        line = raw_input().split()\n        ans[i][2] = -i\n        ans[i][3] = line[0]\n        for c in line[1:]:\n            if c == '0':\n                ans[i][0] += 1\n            elif c == '1':\n                ans[i][1] -= 1\n    for a in sorted(ans, key=lambda x: (x[0], x[1], x[2]), reverse=True):\n        print a[3]", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    teams = []\n    for i in range(n):\n        line = input().split()\n        name = line[0]\n        results = list(map(int, line[1:]))\n        \n        wins = results.count(0)\n        losses = results.count(1)\n        \n        teams.append((name, wins, losses, i))\n    \n    # Sort by wins (descending), then losses (ascending), then input order (ascending)\n    teams.sort(key=lambda x: (-x[1], x[2], x[3]))\n    \n    for team in teams:\n        print(team[0])\n", "perturbed_sampled": ["while True: n  for i in range(n): line = input().split() name = line[0] results = list(map(int, line[1:])) wins = results.count(0) losses = results.count(1) teams.append((name,  (ascending), then input order (ascending) teams.sort(key=lambda x: (-x[1], x[2], x[3])) for team in teams: print(team[0])"], "perturbed_original": ["while True: n = int(raw_input()) if n == 0: break ans  line = raw_input().split() ans[i][2] = -i ans[i][3] = line[0] for c in  == '1': ans[i][1] -= 1  print a[3]"], "original_ll": -0.8603041172027588, "sampled_ll": -0.7123130559921265, "all_perturbed_sampled_ll": [-2.3499326705932617], "all_perturbed_original_ll": [-2.509824514389038], "perturbed_sampled_ll": -2.3499326705932617, "perturbed_original_ll": -2.509824514389038, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void)\n{    \n    int a, b, r;\n    int count = 1;\n        \n    while(scanf(\"%d %d\", &a, &b) != EOF)\n    {     \n        if(a == 0 && b == 0)\n        {        \n            break;\n        }\n        \n        r = a % b;        \n        while(r!=0){            \n            a = b;            \n            b = r;            \n            r = a % b;            \n            count++;  \n            \n            \n        }\n        printf(\"%d %d\\n\",b,count);\n    }        \n      \n    return(0);\n    \n}\n", "sampled": "#include <stdio.h>\n\nint main() {\n    long long a, b;\n    \n    while (1) {\n        scanf(\"%lld %lld\", &a, &b);\n        \n        if (a == 0 && b == 0) {\n            break;\n        }\n        \n        long long x = a;\n        long long y = b;\n        int steps = 0;\n        long long temp;\n        \n        while (y != 0) {\n            temp = x % y;\n            x = y;\n            y = temp;\n            steps++;\n        }\n        \n        printf(\"%lld %d\\n\", x, steps);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { long long a, b; while (1) { scanf(\"%lld %lld\", &a, &b); if (a == 0 && b == 0) {  while (y != 0) { temp = x  printf(\"%lld %d\\n\", x, steps); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int a, b, r; int count = 1; while(scanf(\"%d %d\", &a, &b) != EOF) { if(a ==  r; r = a % b; count++; } printf(\"%d %d\\n\",b,count); } return(0); }"], "original_ll": -1.1831579208374023, "sampled_ll": -0.5289129614830017, "all_perturbed_sampled_ll": [-1.7422089576721191], "all_perturbed_original_ll": [-1.626142978668213], "perturbed_sampled_ll": -1.7422089576721191, "perturbed_original_ll": -1.626142978668213, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n \n         \n        public static void main(String[] args) throws java.io.IOException{\n            Scanner scan = new Scanner(System.in);\n            while(true){\n                int a =scan.nextInt();\n                int b = scan.nextInt();\n                if((a|b)==0)break;\n                if(b>a){\n                    a=a^b;\n                    b=a^b;\n                    a=a^b;\n                }\n                int c=0;\n                while(b!=0){\n                    a=a%b;\n                    a=a^b;\n                    b=a^b;\n                    a=a^b;\n                    c++;\n                }\n                System.out.println(a+\" \"+c);\n            }\n  \n        }\n   \n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long a = sc.nextLong();\n            long b = sc.nextLong();\n            \n            if (a == 0 && b == 0) {\n                break;\n            }\n            \n            long x = a;\n            long y = b;\n            int steps = 0;\n            \n            while (y != 0) {\n                long temp = x % y;\n                x = y;\n                y = temp;\n                steps++;\n            }\n            \n            System.out.println(x + \" \" + steps);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  { Scanner sc = new Scanner(System.in); while (true) { long a = sc.nextLong(); long b = sc.nextLong(); if (a == 0 && b == 0) { break; } long x = a;  != 0) { long   sc.close(); } }"], "perturbed_original": ["import java.util.*;  java.io.IOException{ Scanner scan = new Scanner(System.in); while(true){ int a =scan.nextInt(); int b = scan.nextInt(); if((a|b)==0)break; if(b>a){ a=a^b; b=a^b; a=a^b; } int c=0; while(b!=0){  }"], "original_ll": -1.0790175199508667, "sampled_ll": -0.44357624650001526, "all_perturbed_sampled_ll": [-1.8418371677398682], "all_perturbed_original_ll": [-1.6810882091522217], "perturbed_sampled_ll": -1.8418371677398682, "perturbed_original_ll": -1.6810882091522217, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\ndef f(d,x,y):\n    t = x % y\n    x = y\n    y = t\n    if y != 0:\n        return f(d+1,x,y)\n    else:\n        return (x,d+1)\n\nwhile 1:\n    y,x = sorted(list(map(int, input().split())))\n    if x == 0: break\n    ans = f(0,x,y)\n    print(ans[0],ans[1])\n\n\n", "sampled": "while True:\n    a, b = map(int, input().split())\n    if a == 0 and b == 0:\n        break\n    \n    x, y = a, b\n    steps = 0\n    \n    while y != 0:\n        remainder = x % y\n        x = remainder\n        x, y = y, x\n        steps += 1\n    \n    print(x, steps)\n", "perturbed_sampled": ["while True: a, b = map(int, input().split()) if a  remainder = x % y x = remainder x, y = y, x steps += 1 print(x, steps)"], "perturbed_original": ["import sys  y = t if y != 0: return f(d+1,x,y) else: return (x,d+1) while 1: y,x = sorted(list(map(int, input().split()))) if x == 0: break ans = f(0,x,y) print(ans[0],ans[1])"], "original_ll": -1.3495498895645142, "sampled_ll": -0.9652212858200073, "all_perturbed_sampled_ll": [-2.5559849739074707], "all_perturbed_original_ll": [-2.314390182495117], "perturbed_sampled_ll": -2.5559849739074707, "perturbed_original_ll": -2.314390182495117, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\tint n,i,j,z;\n\tchar c1[1001],c2[1001],c3[1001],c4[1001],c5[1001],c6[1001];\n\twhile(n!=0){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%s %s %s %s %s %s\",&c1[i],&c2[i],&c3[i],&c4[i],&c5[i],&c6[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tz=0;\n\t\tfor(j=0;j<n;j++){\n\t\tif(c1[i]==c1[j] && c2[i]==c2[j] && c3[i]==c3[j] && c4[i]==c4[j] && c5[i]==c5[j] && c6[i]==c6[j]){\n\t\t\tz=z+1;\n\t\t}\n\t\telse if(c4[i]==c4[j] && c1[i]==c1[j] && c3[i]==c3[j] && c6[i]==c6[j]){\n\t\t\tif(c5[i]==c5[j] && c2[i]==c2[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c4[i]==c6[j] && c1[i]==c3[j] && c3[i]==c1[j] && c6[i]==c4[j]){\n\t\t\tif(c5[i]==c2[j] && c2[i]==c5[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c6[j] && c3[i]==c3[j] && c1[i]==c1[j] && c4[i]==c4[j]){\n\t\t\tif(c5[i]==c5[j] && c2[i]==c2[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c4[j] && c3[i]==c1[j] && c1[i]==c3[j] && c4[i]==c6[j]){\n\t\t\tif(c2[i]==c5[j] && c5[i]==c2[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c2[i]==c2[j] && c1[i]==c1[j] && c5[i]==c5[j] && c6[i]==c6[j]){\n\t\t\tif(c4[i]==c4[j] && c3[i]==c3[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c2[i]==c6[j] && c1[i]==c5[j] && c5[i]==c1[j] && c6[i]==c2[j]){\n\t\t\tif(c4[i]==c3[j] && c3[i]==c4[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c6[j] && c5[i]==c5[j] && c1[i]==c1[j] && c2[i]==c2[j]){\n\t\t\tif(c3[i]==c3[j] && c4[i]==c4[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c2[j] && c5[i]==c1[j] && c1[i]==c5[j] && c2[i]==c6[j]){\n\t\t\tif(c3[i]==c4[j] && c4[i]==c3[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",n);\n\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char faces[6][10];\n} Cube;\n\nvoid rotateCube(Cube *c, Cube *result, int rotation) {\n    // 24 rotations of a cube\n    int rotations[24][6] = {\n        {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5},\n        {1,0,3,2,5,4}, {1,2,0,5,3,4}, {1,3,5,0,2,4}, {1,5,2,3,0,4},\n        {2,0,1,4,5,3}, {2,1,5,0,4,3}, {2,4,0,5,1,3}, {2,5,4,1,0,3},\n        {3,0,4,1,5,2}, {3,1,0,5,4,2}, {3,4,5,0,1,2}, {3,5,1,4,0,2},\n        {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1},\n        {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0}\n    };\n    \n    for (int i = 0; i < 6; i++) {\n        strcpy(result->faces[i], c->faces[rotations[rotation][i]]);\n    }\n}\n\nint compareCubes(Cube *c1, Cube *c2) {\n    for (int i = 0; i < 6; i++) {\n        int cmp = strcmp(c1->faces[i], c2->faces[i]);\n        if (cmp != 0) return cmp;\n    }\n    return 0;\n}\n\nint areSameCube(Cube *c1, Cube *c2) {\n    Cube rotated;\n    for (int r = 0; r < 24; r++) {\n        rotateCube(c1, &rotated, r);\n        if (compareCubes(&rotated, c2) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Cube cubes[30];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 6; j++) {\n                scanf(\"%s\", cubes[i].faces[j]);\n            }\n        }\n        \n        int unique[30];\n        int uniqueCount = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int isUnique = 1;\n            for (int j = 0; j < uniqueCount; j++) {\n                if (areSameCube(&cubes[i], &cubes[unique[j]])) {\n                    isUnique = 0;\n                    break;\n                }\n            }\n            if (isUnique) {\n                unique[uniqueCount++] = i;\n            }\n        }\n        \n        printf(\"%d\\n\", n - uniqueCount);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef struct { char faces[6][10]; } Cube; void rotateCube(Cube *c, Cube *result, int rotation) { // 24 rotations of a cube  {1,3,5,0,2,4}, {1,5,2,3,0,4}, {2,0,1,4,5,3},  } } int compareCubes(Cube *c1, Cube *c2) { for (int i = 0; i < 6; i++) { int cmp = strcmp(c1->faces[i], c2->faces[i]);  int areSameCube(Cube  0; r < 24; r++) { rotateCube(c1, &rotated, r); if (compareCubes(&rotated, c2) == 0) { return 1; } } return 0; } int main() { int n; while (scanf(\"%d\", &n) == 1 && n  0; j < 6; j++) { scanf(\"%s\", cubes[i].faces[j]); } } int unique[30]; int uniqueCount = 0; for (int i =   if (areSameCube(&cubes[i], &cubes[unique[j]])) { isUnique = 0; break; } } if (isUnique) { unique[uniqueCount++] =  }"], "perturbed_original": ["#include<stdio.h> int main(void) { int n,i,j,z; char c1[1001],c2[1001],c3[1001],c4[1001],c5[1001],c6[1001]; while(n!=0){ scanf(\"%d\",&n); for(i=0;i<n;i++){ scanf(\"%s %s %s %s  else if(c4[i]==c4[j] && c1[i]==c1[j] && c3[i]==c3[j] && c6[i]==c6[j]){ if(c5[i]==c5[j] && c2[i]==c2[j]){ z=z+1; } } else if(c4[i]==c6[j] && c1[i]==c3[j]  && c1[i]==c3[j] && c4[i]==c6[j]){ if(c2[i]==c5[j] && c5[i]==c2[j]){ z=z+1;  if(c4[i]==c4[j] && c3[i]==c3[j]){ z=z+1; } } else if(c2[i]==c6[j] && c1[i]==c5[j] && c5[i]==c1[j] && c6[i]==c2[j]){ if(c4[i]==c3[j] && c3[i]==c4[j]){ z=z+1; } } else if(c6[i]==c6[j] && c5[i]==c5[j] && c1[i]==c1[j] && c2[i]==c2[j]){ if(c3[i]==c3[j] && c4[i]==c4[j]){ z=z+1; } } else if(c6[i]==c2[j]  } } } } printf(\"%d\\n\",n); scanf(\"%d\",&n); } return 0; }"], "original_ll": -0.34443604946136475, "sampled_ll": -0.3874909281730652, "all_perturbed_sampled_ll": [-1.4448586702346802], "all_perturbed_original_ll": [-0.7958314418792725], "perturbed_sampled_ll": -1.4448586702346802, "perturbed_original_ll": -0.7958314418792725, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n\n    ArrayList<char[]> color,list;\n    ArrayList<String> clist;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        clist = new ArrayList<String>();\n        clist.add(\"Red\");\n        clist.add(\"Yellow\");\n        clist.add(\"Blue\");\n        clist.add(\"Magenta\");\n        clist.add(\"Green\");\n        clist.add(\"Cyan\");\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            color = new ArrayList<char[]>();\n            int cnt = 0;\n            for(int i=0; i<n; i++){\n                char[] c = new char[6];\n                for(int j=0; j<6; j++) c[j] = (char)clist.indexOf(sc.next());\n                if(same(c)) cnt++;\n                else color.add(c);\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    int[][] rotate = {{1,2,4,3},{0,4,5,1},{0,2,5,3}};\n\n    boolean same(char[] dice){\n        list = new ArrayList<char[]>();\n        for(int i=0; i<4; i++){\n            dice = rotate(dice,0);\n            for(int j=0; j<4; j++){\n                dice = rotate(dice,1);\n                for(int l=0; l<4; l++){\n                    dice = rotate(dice,2);\n                    list.add(dice);\n                }\n            }\n        }\n\n        for(int i=0; i<list.size(); i++){\n            char[] s1 = list.get(i);\n            for(int j=0; j<color.size(); j++){\n                boolean boo = false;\n                char[] s2 = color.get(j);\n                for(int k=0; k<6; k++){\n                    if(s1[k]!=s2[k]){\n                        boo = false;\n                        break;\n                    }\n                    boo = true;\n                }\n                if(boo) return true;\n            }\n        }\n        return false;\n    }\n\n    char[] rotate(char[] dice, int idx){\n        char[] res = new char[6];\n        for(int i=0; i<6; i++) res[i] = dice[i];\n\n        char tmp = res[rotate[idx][3]];\n        for(int i=3; i>0; i--) res[rotate[idx][i]] = res[rotate[idx][i-1]];\n        res[rotate[idx][0]] = tmp;\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Cube {\n        String[] faces = new String[6];\n        \n        Cube(String[] f) {\n            faces = f.clone();\n        }\n        \n        // Generate all 24 rotations of the cube\n        List<String> getAllRotations() {\n            Set<String> rotations = new HashSet<>();\n            \n            // All 24 orientations of a cube\n            int[][] orientations = {\n                {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5},\n                {1,0,3,2,5,4}, {1,2,0,5,3,4}, {1,3,5,0,2,4}, {1,5,2,3,0,4},\n                {2,0,1,4,5,3}, {2,1,5,0,4,3}, {2,4,0,5,1,3}, {2,5,4,1,0,3},\n                {3,0,4,1,5,2}, {3,1,0,5,4,2}, {3,4,5,0,1,2}, {3,5,1,4,0,2},\n                {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1},\n                {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0}\n            };\n            \n            for (int[] orient : orientations) {\n                StringBuilder sb = new StringBuilder();\n                for (int i = 0; i < 6; i++) {\n                    if (i > 0) sb.append(\" \");\n                    sb.append(faces[orient[i]]);\n                }\n                rotations.add(sb.toString());\n            }\n            \n            return new ArrayList<>(rotations);\n        }\n        \n        String getCanonical() {\n            List<String> rotations = getAllRotations();\n            Collections.sort(rotations);\n            return rotations.get(0);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            sc.nextLine();\n            \n            Set<String> uniqueCubes = new HashSet<>();\n            \n            for (int i = 0; i < n; i++) {\n                String[] colors = sc.nextLine().split(\" \");\n                Cube cube = new Cube(colors);\n                String canonical = cube.getCanonical();\n                uniqueCubes.add(canonical);\n            }\n            \n            int needed = n - uniqueCubes.size();\n            System.out.println(needed);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Cube { String[] faces = new String[6]; Cube(String[] f) { faces = f.clone(); } // Generate all 24 rotations of the cube List<String> getAllRotations() { Set<String> rotations = new HashSet<>(); // All 24 orientations of a cube  {3,5,1,4,0,2}, {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1}, {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0} }; for (int[] orient  i = 0; i < 6; i++) { if (i > 0) sb.append(\" \"); sb.append(faces[orient[i]]); }  rotations = getAllRotations(); Collections.sort(rotations); return rotations.get(0); } } public static void main(String[] args)  n  Cube cube = new Cube(colors);  - uniqueCubes.size(); System.out.println(needed); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public  = new Scanner(System.in); clist = new ArrayList<String>(); clist.add(\"Red\"); clist.add(\"Yellow\"); clist.add(\"Blue\"); clist.add(\"Magenta\"); clist.add(\"Green\"); clist.add(\"Cyan\"); while(true){ int n  = 0; for(int i=0; i<n; i++){ char[] c = new char[6]; for(int j=0; j<6; j++) c[j] = (char)clist.indexOf(sc.next()); if(same(c)) cnt++; else color.add(c); } System.out.println(cnt); }  for(int j=0;  = rotate(dice,2); list.add(dice); } } } for(int i=0; i<list.size(); i++){ char[] s1  char[]  false; break; } boo = true; } if(boo) return true; } } return false; } char[] rotate(char[]  for(int i=3; i>0; i--) res[rotate[idx][i]] = res[rotate[idx][i-1]]; res[rotate[idx][0]] = tmp; return res; } public static void main(String[] args){ new Main().solve(); } }"], "original_ll": -0.7026715874671936, "sampled_ll": -0.4533136785030365, "all_perturbed_sampled_ll": [-1.4879502058029175], "all_perturbed_original_ll": [-1.7514638900756836], "perturbed_sampled_ll": -1.4879502058029175, "perturbed_original_ll": -1.7514638900756836, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def equal(B):\n    temp=B[:]\n    S=set()\n    for i in range(4):\n        for j in range(4):\n            for k in range(4):\n                roll(0,2,5,3,temp)\n                S.add(tuple(temp))\n            roll(0,1,5,4,temp)\n        roll(1,2,4,3,temp)\n    return S\n\ndef roll(i,j,k,l,temp):\n    t=temp[i]\n    temp[i]=temp[j]\n    temp[j]=temp[k]\n    temp[k]=temp[l]\n    temp[l]=t\n\nwhile True:\n    n=input()\n    if n==0:break\n    L=[raw_input().split() for i in range(n)]\n    cnt=0\n    for i in range(n-1):\n        for j in range(i+1,n):\n            S=equal(L[j])\n            if tuple(L[i]) in S:\n                cnt+=1\n    print cnt", "sampled": "def normalize_cube(colors):\n    # Colors: [top, front, right, left, back, bottom]\n    # Indices:  0     1      2     3     4      5\n    \n    # Generate all 24 orientations of the cube\n    orientations = []\n    \n    # Original orientation\n    c = colors\n    \n    # All 24 rotations of a cube\n    # 4 rotations with each of the 6 faces as top\n    \n    def rotate_x(cube):\n        # Rotate around x-axis (right face axis) by 90 degrees\n        return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]]\n    \n    def rotate_y(cube):\n        # Rotate around y-axis (top face axis) by 90 degrees\n        return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]]\n    \n    def rotate_z(cube):\n        # Rotate around z-axis (front face axis) by 90 degrees\n        return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]]\n    \n    # Generate all 24 orientations\n    current = colors[:]\n    \n    for _ in range(4):\n        orientations.append(tuple(current))\n        for _ in range(3):\n            current = rotate_z(current)\n            orientations.append(tuple(current))\n        current = rotate_y(current)\n    \n    current = rotate_x(colors[:])\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.append(tuple(current))\n    \n    current = rotate_x(rotate_x(rotate_x(colors[:])))\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.append(tuple(current))\n    \n    # Return the lexicographically smallest orientation\n    return min(orientations)\n\ndef get_all_orientations(colors):\n    orientations = set()\n    \n    def rotate_x(cube):\n        return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]]\n    \n    def rotate_y(cube):\n        return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]]\n    \n    def rotate_z(cube):\n        return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]]\n    \n    current = colors[:]\n    for _ in range(4):\n        orientations.add(tuple(current))\n        for _ in range(3):\n            current = rotate_z(current)\n            orientations.add(tuple(current))\n        current = rotate_y(current)\n    \n    current = rotate_x(colors[:])\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.add(tuple(current))\n    \n    current = rotate_x(rotate_x(rotate_x(colors[:])))\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.add(tuple(current))\n    \n    return orientations\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    cubes = []\n    for _ in range(n):\n        colors = input().split()\n        cubes.append(colors)\n    \n    unique_cubes = set()\n    \n    for cube in cubes:\n        canonical = normalize_cube(cube)\n        unique_cubes.add(canonical)\n    \n    needed = n - len(unique_cubes)\n    print(needed)\n", "perturbed_sampled": ["def normalize_cube(colors): # Colors: [top, front, right, left, back, bottom]  # Original orientation c  4 rotations with each of the  (right face axis) by 90 degrees return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]] def rotate_y(cube): # Rotate around y-axis (top face axis) by 90 degrees return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]] def rotate_z(cube): # Rotate around z-axis (front face axis) by 90 degrees return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]] # Generate all 24 orientations current = colors[:] for _ in range(4): orientations.append(tuple(current)) for _ in range(3): current = rotate_z(current) orientations.append(tuple(current)) current = rotate_y(current) current = rotate_x(colors[:])  rotate_x(rotate_x(rotate_x(colors[:]))) for _ in range(3): current = rotate_z(current) orientations.append(tuple(current)) # Return the lexicographically smallest orientation  for _ in range(4): orientations.add(tuple(current)) for _ in range(3):  = rotate_x(rotate_x(rotate_x(colors[:])))  while True: n = int(input()) if n == 0: break cubes = [] for _ in range(n):  cubes: canonical = normalize_cube(cube) unique_cubes.add(canonical) needed = n - len(unique_cubes) print(needed)"], "perturbed_original": ["def equal(B): temp=B[:] S=set() for i in range(4): for j in range(4): for k in range(4): roll(0,2,5,3,temp) S.add(tuple(temp)) roll(0,1,5,4,temp)  while True: n=input() if n==0:break L=[raw_input().split() for i in range(n)] cnt=0 for  in S: cnt+=1 print cnt"], "original_ll": -1.0768722295761108, "sampled_ll": -0.6434895396232605, "all_perturbed_sampled_ll": [-1.5765831470489502], "all_perturbed_original_ll": [-2.3333699703216553], "perturbed_sampled_ll": -1.5765831470489502, "perturbed_original_ll": -2.3333699703216553, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,m,p;\nchar s[2],c[101];\nA(){\n\tfor(p=0;c[p]!='#';p++);\n}\nB(){\n\tfor(p=n-1;p>=0;p--)\n\t\tif(c[p]=='#'&&(p+1==n||c[p+1]!='A')&&(p-1<0||c[p-1]!='A'))\n\t\t\treturn;\n\tA();\n}\nC(){\n\tfor(p=0;p<n;p++){\n\t\tif(c[p]!='#'){\n\t\t\tif(p+1!=n&&c[p+1]=='#'){\n\t\t\t\tp++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(p-1>=0&&c[p-1]=='#'){\n\t\t\t\tp--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tp=n/2;\n}\nD(){\n\tint D[100],d=n,q;\n\tfor(p=-1;++p<n;){\n\t\td++;\n\t\tif(c[p]!='#')\n\t\t\td=0;\n\t\tD[p]=d;\n\t}\n\tfor(d=0;--p>=0;){\n\t\td++;\n\t\tif(c[p]!='#')\n\t\t\td=0;\n\t\tif(d<D[p])\n\t\t\tD[p]=d;\n\t}\n\tfor(p=q=0;q<n;q++)\n\t\tif(D[q]>D[p])\n\t\t\tp=q;\n}\nmain(){\n\tfor(;scanf(\"%d%d\",&n,&m),n;){\n\t\tmemset(c,'#',100);\n\t\tc[n]=0;\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s\",s);\n\t\t\tif(s[0]=='A')\n\t\t\t\tA();\n\t\t\tif(s[0]=='B')\n\t\t\t\tB();\n\t\t\tif(s[0]=='C')\n\t\t\t\tC();\n\t\t\tif(s[0]=='D')\n\t\t\t\tD();\n\t\t\tc[p]=s[0];\n\t\t}\n\t\tputs(c);\n\t}\n\texit(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, m;\n    \n    while(1) {\n        scanf(\"%d %d\", &n, &m);\n        if(n == 0 && m == 0) break;\n        \n        char seats[101];\n        for(int i = 0; i < n; i++) {\n            seats[i] = '#';\n        }\n        \n        for(int i = 0; i < m; i++) {\n            char type;\n            scanf(\" %c\", &type);\n            \n            if(type == 'A') {\n                // Left to right, first empty seat\n                for(int j = 0; j < n; j++) {\n                    if(seats[j] == '#') {\n                        seats[j] = 'A';\n                        break;\n                    }\n                }\n            }\n            else if(type == 'B') {\n                // Right to left, not next to A\n                int pos = -1;\n                for(int j = n-1; j >= 0; j--) {\n                    if(seats[j] == '#') {\n                        int nextToA = 0;\n                        if(j > 0 && seats[j-1] == 'A') nextToA = 1;\n                        if(j < n-1 && seats[j+1] == 'A') nextToA = 1;\n                        if(!nextToA) {\n                            pos = j;\n                            break;\n                        }\n                    }\n                }\n                if(pos == -1) {\n                    // All empty seats are next to A, take leftmost empty\n                    for(int j = 0; j < n; j++) {\n                        if(seats[j] == '#') {\n                            pos = j;\n                            break;\n                        }\n                    }\n                }\n                seats[pos] = 'B';\n            }\n            else if(type == 'C') {\n                // Next to someone, prefer right then left of leftmost person\n                int hasAnyone = 0;\n                for(int j = 0; j < n; j++) {\n                    if(seats[j] != '#') {\n                        hasAnyone = 1;\n                        break;\n                    }\n                }\n                \n                if(!hasAnyone) {\n                    // Sit in middle\n                    int mid = (n % 2 == 1) ? (n+1)/2 - 1 : n/2;\n                    seats[mid] = 'C';\n                } else {\n                    int pos = -1;\n                    for(int j = 0; j < n; j++) {\n                        if(seats[j] != '#') {\n                            if(j+1 < n && seats[j+1] == '#') {\n                                pos = j+1;\n                                break;\n                            } else if(j-1 >= 0 && seats[j-1] == '#') {\n                                pos = j-1;\n                                break;\n                            }\n                        }\n                    }\n                    seats[pos] = 'C';\n                }\n            }\n            else if(type == 'D') {\n                // Maximize minimum distance to nearest person\n                int hasAnyone = 0;\n                for(int j = 0; j < n; j++) {\n                    if(seats[j] != '#') {\n                        hasAnyone = 1;\n                        break;\n                    }\n                }\n                \n                if(!hasAnyone) {\n                    seats[0] = 'D';\n                } else {\n                    int bestPos = -1;\n                    int maxMinDist = -1;\n                    \n                    for(int j = 0; j < n; j++) {\n                        if(seats[j] == '#') {\n                            int minDist = n+1;\n                            for(int k = 0; k < n; k++) {\n                                if(seats[k] != '#') {\n                                    int dist = (j > k) ? (j - k) : (k - j);\n                                    if(dist < minDist) minDist = dist;\n                                }\n                            }\n                            if(minDist > maxMinDist) {\n                                maxMinDist = minDist;\n                                bestPos = j;\n                            }\n                        }\n                    }\n                    seats[bestPos] = 'D';\n                }\n            }\n        }\n        \n        for(int i = 0; i < n; i++) {\n            printf(\"%c\", seats[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int  &m); if(n == 0 && m == 0) break; char seats[101]; for(int i = 0; i < n;  i < m; i++) { char  j  'A'; break; } } } else if(type == 'B') { // Right to left, not next to A int pos = -1; for(int j = n-1; j >= 0; j--) { if(seats[j] == '#') { int nextToA = 0; if(j > 0 && seats[j-1] == 'A') nextToA = 1; if(j < n-1 && seats[j+1] == 'A') nextToA = 1;  == -1) { // All empty seats are next to A,  j++) { if(seats[j] == '#') { pos = j; break; } } } seats[pos] = 'B'; } else if(type ==  of leftmost person int hasAnyone =  if(seats[j] != '#') { hasAnyone =  else { int pos = -1; for(int j  pos = j+1; break; } else if(j-1 >= 0 && seats[j-1] == '#') { pos =  = 0; j  1; break; } } if(!hasAnyone) { seats[0] = 'D'; } else { int bestPos = -1; int maxMinDist =  if(seats[j] == '#') { int minDist = n+1; for(int k = 0; k < n; k++) {  ? (j - k) : (k - j); if(dist <  seats[bestPos] = 'D'; } } } for(int i = 0; i < n; i++) { printf(\"%c\", seats[i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["n,m,p; char s[2],c[101]; A(){ for(p=0;c[p]!='#';p++); }  p++; return; } if(p-1>=0&&c[p-1]=='#'){ p--; return; } } } p=n/2; } D(){ int D[100],d=n,q; for(p=-1;++p<n;){ d++; if(c[p]!='#') d=0; D[p]=d; } for(d=0;--p>=0;){ d++; if(c[p]!='#') d=0; if(d<D[p]) D[p]=d; } for(p=q=0;q<n;q++) if(D[q]>D[p])  } exit(0); }"], "original_ll": -1.0930947065353394, "sampled_ll": -0.455364465713501, "all_perturbed_sampled_ll": [-1.631544589996338], "all_perturbed_original_ll": [-2.0582797527313232], "perturbed_sampled_ll": -1.631544589996338, "perturbed_original_ll": -2.0582797527313232, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tchar[] a = new char[n+2];\n\t\t\tArrays.fill(a,'#');\n\t\t\ta[0] = 'X';\n\t\t\ta[n+1] = 'X';\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif(c=='A'){\n\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\tif(a[j]=='#'){\n\t\t\t\t\t\t\ta[j] = c;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(c=='B'){\n\t\t\t\t\tboolean flag = true;\n\t\t\t\t\tfor(int j=n;j>0;j--){\n\t\t\t\t\t\tif(a[j]=='#' && a[j-1]!='A' && a[j+1]!='A'){\n\t\t\t\t\t\t\ta[j] = c;\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==true){\n\t\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\t\tif(a[j]=='#'){\n\t\t\t\t\t\t\t\ta[j] = c;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(c=='C'){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tif(n%2==0) a[(n+1)/2] = c;\n\t\t\t\t\t\telse a[n/2+1] = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\t\tif(a[j]!='#'){\n\t\t\t\t\t\t\t\tif(a[j+1]=='#'){\n\t\t\t\t\t\t\t\t\ta[j+1] = c;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(a[j-1]=='#'){\n\t\t\t\t\t\t\t\t\ta[j-1] = c;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(c=='D'){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\ta[1] = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint max = -1;\n\t\t\t\t\t\tint p = -1;\n\t\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\t\tif(a[j]=='#'){\n\t\t\t\t\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\t\t\t\t\tfor(int k=j-1;k>=0;k--){\n\t\t\t\t\t\t\t\t\tif(k==0) break;\n\t\t\t\t\t\t\t\t\tif(a[k]!='#'){\n\t\t\t\t\t\t\t\t\t\tmin = Math.min(min, j-k+1);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j+1;k<=n+1;k++){\n\t\t\t\t\t\t\t\t\tif(k==n+1) break;\n\t\t\t\t\t\t\t\t\tif(a[k]!='#'){\n\t\t\t\t\t\t\t\t\t\tmin = Math.min(min, k-j+1);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min>max){\n\t\t\t\t\t\t\t\t\tmax = min;\n\t\t\t\t\t\t\t\t\tp = j;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[p] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++) System.out.print(a[i]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) break;\n            \n            char[] chairs = new char[n];\n            Arrays.fill(chairs, '#');\n            \n            for (int i = 0; i < m; i++) {\n                String nationality = sc.next();\n                char person = nationality.charAt(0);\n                \n                if (person == 'A') {\n                    // Left to right, first empty chair\n                    for (int j = 0; j < n; j++) {\n                        if (chairs[j] == '#') {\n                            chairs[j] = 'A';\n                            break;\n                        }\n                    }\n                } else if (person == 'B') {\n                    // Right to left, not next to A\n                    boolean found = false;\n                    for (int j = n - 1; j >= 0; j--) {\n                        if (chairs[j] == '#') {\n                            boolean nextToA = false;\n                            if (j > 0 && chairs[j - 1] == 'A') nextToA = true;\n                            if (j < n - 1 && chairs[j + 1] == 'A') nextToA = true;\n                            \n                            if (!nextToA) {\n                                chairs[j] = 'B';\n                                found = true;\n                                break;\n                            }\n                        }\n                    }\n                    \n                    if (!found) {\n                        // Must sit next to A, left to right\n                        for (int j = 0; j < n; j++) {\n                            if (chairs[j] == '#') {\n                                chairs[j] = 'B';\n                                break;\n                            }\n                        }\n                    }\n                } else if (person == 'C') {\n                    // Next to someone, prefer right then left\n                    boolean found = false;\n                    \n                    // Check if anyone is sitting\n                    boolean anyoneSeated = false;\n                    for (int j = 0; j < n; j++) {\n                        if (chairs[j] != '#') {\n                            anyoneSeated = true;\n                            break;\n                        }\n                    }\n                    \n                    if (!anyoneSeated) {\n                        // Sit in middle\n                        int middle = (n % 2 == 1) ? n / 2 : n / 2;\n                        chairs[middle] = 'C';\n                    } else {\n                        // Find leftmost person and try right, then left\n                        for (int j = 0; j < n; j++) {\n                            if (chairs[j] != '#') {\n                                // Try right\n                                if (j + 1 < n && chairs[j + 1] == '#') {\n                                    chairs[j + 1] = 'C';\n                                    found = true;\n                                    break;\n                                }\n                                // Try left\n                                if (j - 1 >= 0 && chairs[j - 1] == '#') {\n                                    chairs[j - 1] = 'C';\n                                    found = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                } else if (person == 'D') {\n                    // Maximize minimum distance\n                    boolean anyoneSeated = false;\n                    for (int j = 0; j < n; j++) {\n                        if (chairs[j] != '#') {\n                            anyoneSeated = true;\n                            break;\n                        }\n                    }\n                    \n                    if (!anyoneSeated) {\n                        chairs[0] = 'D';\n                    } else {\n                        int bestPos = -1;\n                        int maxMinDist = -1;\n                        \n                        for (int j = 0; j < n; j++) {\n                            if (chairs[j] == '#') {\n                                int minDist = Integer.MAX_VALUE;\n                                \n                                for (int k = 0; k < n; k++) {\n                                    if (chairs[k] != '#') {\n                                        minDist = Math.min(minDist, Math.abs(j - k));\n                                    }\n                                }\n                                \n                                if (minDist > maxMinDist) {\n                                    maxMinDist = minDist;\n                                    bestPos = j;\n                                }\n                            }\n                        }\n                        \n                        chairs[bestPos] = 'D';\n                    }\n                }\n            }\n            \n            System.out.println(new String(chairs));\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public  while (true) {  == 0 && m == 0) break; char[] chairs = new char[n]; Arrays.fill(chairs, '#'); for (int i = 0; i < m;  first empty chair for (int j =   (person ==  boolean found = false; for (int j = n - 1; j >= 0; j--) { if (chairs[j] == '#') { boolean nextToA  == 'A') nextToA  { chairs[j] = 'B'; found = true; break; } } } if (!found) { // Must  == '#') { chairs[j] = 'B'; break; } } } } else if (person == 'C') { // Next to someone, prefer right  = 0; j < n; j++)  } } if (!anyoneSeated) { // Sit in middle int  2 : n  leftmost person and try right, then left for (int j  < n && chairs[j + 1] == '#') { chairs[j + 1] = 'C'; found = true; break; } // Try left if (j - 1  } } } } else if  = false; for (int j = 0; j < n; j++) { if (chairs[j] != '#') { anyoneSeated = true; break; } } if (!anyoneSeated) { chairs[0] = 'D'; } else { int bestPos = -1; int maxMinDist  j++) { if (chairs[j] == '#') { int minDist = Integer.MAX_VALUE; for (int k = 0; k < n; k++) { if (chairs[k] != '#') { minDist = Math.min(minDist,  maxMinDist = minDist; bestPos = j; } } } chairs[bestPos] = 'D'; } } } System.out.println(new String(chairs)); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){ int n = sc.nextInt(); int m = sc.nextInt(); if(n==0 && m==0) break; char[] a = new char[n+2]; Arrays.fill(a,'#'); a[0] = 'X'; a[n+1] = 'X'; for(int i=0;i<m;i++){ char c = sc.next().charAt(0); if(c=='A'){ for(int j=1;j<=n;j++){ if(a[j]=='#'){ a[j] = c; break; }  if(n%2==0) a[(n+1)/2] = c; else a[n/2+1] = c; }else{ for(int j=1;j<=n;j++){  c; break; } } } } }else if(c=='D'){  p = -1; for(int j=1;j<=n;j++){ if(a[j]=='#'){ int min  j-k+1); break; } } for(int k=j+1;k<=n+1;k++){ if(k==n+1)  max =  } } } for(int i=1;i<=n;i++) System.out.print(a[i]); System.out.println(); } } }"], "original_ll": -0.438597172498703, "sampled_ll": -0.4190274775028229, "all_perturbed_sampled_ll": [-1.6356675624847412], "all_perturbed_original_ll": [-1.264359712600708], "perturbed_sampled_ll": -1.6356675624847412, "perturbed_original_ll": -1.264359712600708, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "INF = 10 ** 20\n\nwhile True:\n  n, m = map(int, input().split())\n  if not n:\n    break\n\n  chairs = list(\"#\" * n)\n\n  def sit(s):\n    if s == \"A\":\n      chairs[chairs.index(\"#\")] = \"A\"\n    elif s == \"B\":\n      for i in range(n - 1, -1, -1):\n        if chairs[i] == \"#\" and (i == 0 or chairs[i - 1] != \"A\") and (i == n - 1 or chairs[i + 1] != \"A\"):\n          chairs[i] = \"B\"\n          break\n      else:\n        chairs[chairs.index(\"#\")] = \"B\"\n\n    elif s == \"C\":\n      for i in range(1, n):\n        if chairs[i] == \"#\" and chairs[i - 1] != \"#\":\n          chairs[i] = \"C\"\n          break\n\n    else:\n      score = [INF for _ in range(n)]\n      dist = INF\n      for i in range(n):\n        if chairs[i] == \"#\":\n          dist += 1\n        else:\n          dist = 0\n        score[i] = dist\n\n      dist = INF\n      for i in range(n - 1, -1, -1):\n        if chairs[i] == \"#\":\n          dist += 1\n        else:\n          dist = 0\n        score[i] = min(score[i], dist)\n      high_score = max(score)\n      chairs[score.index(high_score)] = \"D\"\n  \n  first = input()\n  if first in [\"A\", \"D\"]:\n    chairs[0] = first\n  elif first == \"B\":\n    chairs[-1] = \"B\"\n  else:\n    chairs[n // 2] = \"C\"\n  for _ in range(m - 1):\n    sit(input())\n\n  print(\"\".join(chairs))\n\n", "sampled": "import sys\n\ndef solve(n, m, passengers):\n    seats = ['#'] * n  # 0-indexed\n    \n    for passenger in passengers:\n        if passenger == 'A':\n            # Left to right, first empty\n            for i in range(n):\n                if seats[i] == '#':\n                    seats[i] = 'A'\n                    break\n                    \n        elif passenger == 'B':\n            # Avoid A, right to left\n            # First try to find seat not adjacent to A\n            found = False\n            for i in range(n-1, -1, -1):\n                if seats[i] == '#':\n                    # Check if adjacent to A\n                    adjacent_to_a = False\n                    if i > 0 and seats[i-1] == 'A':\n                        adjacent_to_a = True\n                    if i < n-1 and seats[i+1] == 'A':\n                        adjacent_to_a = True\n                    \n                    if not adjacent_to_a:\n                        seats[i] = 'B'\n                        found = True\n                        break\n            \n            # If not found, sit left to right (adjacent to A is ok)\n            if not found:\n                for i in range(n):\n                    if seats[i] == '#':\n                        seats[i] = 'B'\n                        break\n                        \n        elif passenger == 'C':\n            # Sit next to someone\n            # Find leftmost person, try right then left\n            found = False\n            \n            # Check if anyone is seated\n            someone_seated = any(s != '#' for s in seats)\n            \n            if someone_seated:\n                for i in range(n):\n                    if seats[i] != '#':\n                        # Try right\n                        if i < n-1 and seats[i+1] == '#':\n                            seats[i+1] = 'C'\n                            found = True\n                            break\n                        # Try left\n                        elif i > 0 and seats[i-1] == '#':\n                            seats[i-1] = 'C'\n                            found = True\n                            break\n            \n            if not found:\n                # Sit in middle\n                if n % 2 == 1:\n                    mid = n // 2\n                else:\n                    mid = n // 2\n                seats[mid] = 'C'\n                \n        elif passenger == 'D':\n            # Maximize minimum distance\n            # If no one seated, sit at left end\n            someone_seated = any(s != '#' for s in seats)\n            \n            if not someone_seated:\n                seats[0] = 'D'\n            else:\n                # Find empty seat with max min distance\n                best_seat = -1\n                best_min_dist = -1\n                \n                for i in range(n):\n                    if seats[i] == '#':\n                        # Calculate min distance to any occupied seat\n                        min_dist = float('inf')\n                        for j in range(n):\n                            if seats[j] != '#':\n                                min_dist = min(min_dist, abs(i - j))\n                        \n                        if min_dist > best_min_dist:\n                            best_min_dist = min_dist\n                            best_seat = i\n                \n                seats[best_seat] = 'D'\n    \n    return ''.join(seats)\n\n# Read input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.strip())\n\ni = 0\nwhile i < len(lines):\n    parts = lines[i].split()\n    n, m = int(parts[0]), int(parts[1])\n    \n    if n == 0 and m == 0:\n        break\n    \n    i += 1\n    passengers = []\n    for j in range(m):\n        passengers.append(lines[i])\n        i += 1\n    \n    result = solve(n, m, passengers)\n    print(result)\n", "perturbed_sampled": ["import  # 0-indexed for passenger in passengers: if passenger == 'A': # Left to right, first empty for i in range(n): if  'B':  find seat not adjacent to A found = False for i in range(n-1, -1, -1): if seats[i] == '#': # Check if adjacent to A adjacent_to_a = False if i > 0 and seats[i-1] == 'A': adjacent_to_a = True if i < n-1  is  == '#': seats[i] = 'B' break elif   Check if anyone is seated  someone_seated: for i in range(n): if seats[i] != '#': # Try right if i <  True break # Try left elif i > 0 and seats[i-1] == '#': seats[i-1] = 'C' found = True break  2 ==  // 2 seats[mid] = 'C' elif  one seated, sit at left end someone_seated = any(s != '#' for s in  empty  -1 for i in  any occupied seat min_dist = float('inf') for j in range(n): if seats[j] != '#': min_dist = min(min_dist, abs(i - j)) if min_dist >  return ''.join(seats) # Read input lines = [] for line in sys.stdin: lines.append(line.strip()) i = 0 while i < len(lines): parts = lines[i].split() n, m = int(parts[0]), int(parts[1])  += 1 passengers = [] for j in range(m): passengers.append(lines[i]) i += 1 result = solve(n, m, passengers) print(result)"], "perturbed_original": ["INF = 10 ** 20 while True: n, m = map(int, input().split()) if not n: break chairs = list(\"#\" * n) def sit(s): if s ==  in range(n - 1, -1, -1): if chairs[i] == \"#\" and (i == 0 or chairs[i - 1]  in  != \"#\": chairs[i] = \"C\" break else: score = [INF for _ in range(n)] dist = INF for i in range(n): if chairs[i] == \"#\": dist += 1  for i in range(n - 1, -1,  = 0 score[i] = min(score[i], dist) high_score  in [\"A\", \"D\"]: chairs[0] = first elif first == \"B\": chairs[-1] = \"B\" else:  1): sit(input()) print(\"\".join(chairs))"], "original_ll": -0.7738449573516846, "sampled_ll": -0.6466282606124878, "all_perturbed_sampled_ll": [-2.071011781692505], "all_perturbed_original_ll": [-2.0364110469818115], "perturbed_sampled_ll": -2.071011781692505, "perturbed_original_ll": -2.0364110469818115, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int i,j,k,l,n,m;\n  int d[2][100][100]={0};\n  while(scanf(\"%d %d\",&m,&n),n||m){\n    for(i=0;i<100;i++){\n      for(j=0;j<100;j++)d[0][i][j]=d[1][i][j]=100000000;\n      d[0][i][i]=d[1][i][i]=0;\n    }\n    while(m--){\n      scanf(\"%d %d %d %d\",&i,&j,&k,&l);\n      d[0][i-1][j-1]=d[0][j-1][i-1]=k;\n      d[1][i-1][j-1]=d[1][j-1][i-1]=l;\n    }\n    for(l=0;l<n;l++){\n      //for(i=0;i<2;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++){\n\t  //for(l=0;l<n;l++){\n\t  for(i=0;i<2;i++){\n\t    if(d[i][j][k]>d[i][j][l]+d[i][l][k]){\n\t       d[i][j][k]=d[i][j][l]+d[i][l][k];\n\t    }\n\t  }\n\t}\n      }\n    }\n    scanf(\"%d\",&l);\n    while(l--){\n      scanf(\"%d %d %d\",&i,&j,&k);\n      printf(\"%d\\n\",d[k][i-1][j-1]);\n    }\n  }\n  return 0;\n}\n      ", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_M 105\n#define INF 1000000000\n\nint n, m, k;\nint cost_graph[MAX_M][MAX_M];\nint time_graph[MAX_M][MAX_M];\n\nint dijkstra(int graph[MAX_M][MAX_M], int start, int end) {\n    int dist[MAX_M];\n    int visited[MAX_M];\n    int i, j;\n    \n    for (i = 1; i <= m; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    \n    dist[start] = 0;\n    \n    for (i = 0; i < m; i++) {\n        int min_dist = INF;\n        int u = -1;\n        \n        for (j = 1; j <= m; j++) {\n            if (!visited[j] && dist[j] < min_dist) {\n                min_dist = dist[j];\n                u = j;\n            }\n        }\n        \n        if (u == -1) break;\n        \n        visited[u] = 1;\n        \n        for (j = 1; j <= m; j++) {\n            if (!visited[j] && graph[u][j] != INF) {\n                if (dist[u] + graph[u][j] < dist[j]) {\n                    dist[j] = dist[u] + graph[u][j];\n                }\n            }\n        }\n    }\n    \n    return dist[end];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0) break;\n        \n        int i, j;\n        \n        for (i = 1; i <= m; i++) {\n            for (j = 1; j <= m; j++) {\n                if (i == j) {\n                    cost_graph[i][j] = 0;\n                    time_graph[i][j] = 0;\n                } else {\n                    cost_graph[i][j] = INF;\n                    time_graph[i][j] = INF;\n                }\n            }\n        }\n        \n        for (i = 0; i < n; i++) {\n            int a, b, cost, time;\n            scanf(\"%d %d %d %d\", &a, &b, &cost, &time);\n            \n            if (cost < cost_graph[a][b]) {\n                cost_graph[a][b] = cost;\n                cost_graph[b][a] = cost;\n            }\n            \n            if (time < time_graph[a][b]) {\n                time_graph[a][b] = time;\n                time_graph[b][a] = time;\n            }\n        }\n        \n        scanf(\"%d\", &k);\n        \n        for (i = 0; i < k; i++) {\n            int p, q, r;\n            scanf(\"%d %d %d\", &p, &q, &r);\n            \n            if (r == 0) {\n                printf(\"%d\\n\", dijkstra(cost_graph, p, q));\n            } else {\n                printf(\"%d\\n\", dijkstra(time_graph, p, q));\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h> #define MAX_M  int time_graph[MAX_M][MAX_M]; int dijkstra(int graph[MAX_M][MAX_M], int start, int end) { int dist[MAX_M]; int  m;  = 0; for (i = 0; i < m;  for (j = 1; j <= m; j++) {  u  = 1; for (j =  != INF) { if (dist[u] + graph[u][j] < dist[j]) { dist[j] = dist[u] + graph[u][j]; } }  { scanf(\"%d %d\", &n,  int i, j; for (i = 1; i <= m; i++) { for (j = 1; j <= m; j++) { if (i == j) { cost_graph[i][j] = 0; time_graph[i][j] = 0; } else { cost_graph[i][j] = INF; time_graph[i][j] = INF; } } }  a, b,  if (cost < cost_graph[a][b]) { cost_graph[a][b] = cost; cost_graph[b][a] = cost; } if (time < time_graph[a][b]) { time_graph[a][b] = time;  r; scanf(\"%d %d %d\", &p, &q, &r);  else { printf(\"%d\\n\", dijkstra(time_graph, p, q)); } } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int i,j,k,l,n,m; int d[2][100][100]={0}; while(scanf(\"%d %d\",&m,&n),n||m){ for(i=0;i<100;i++){ for(j=0;j<100;j++)d[0][i][j]=d[1][i][j]=100000000; d[0][i][i]=d[1][i][i]=0; } while(m--){ scanf(\"%d %d %d %d\",&i,&j,&k,&l); d[0][i-1][j-1]=d[0][j-1][i-1]=k; d[1][i-1][j-1]=d[1][j-1][i-1]=l; } for(l=0;l<n;l++){ //for(i=0;i<2;i++){   0; }"], "original_ll": -0.6384304165840149, "sampled_ll": -0.26441705226898193, "all_perturbed_sampled_ll": [-1.1682769060134888], "all_perturbed_original_ll": [-0.9861758351325989], "perturbed_sampled_ll": -1.1682769060134888, "perturbed_original_ll": -0.9861758351325989, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic final int INF = 1000000000;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] cost = new int[m][m];\n\t\t\tint[][] time = new int[m][m];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t\t\ttime[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tcost[a][b] = sc.nextInt();\n\t\t\t\tcost[b][a] = cost[a][b];\n\t\t\t\ttime[a][b] = sc.nextInt();\n\t\t\t\ttime[b][a] = time[a][b];\n\t\t\t}\n\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\t\tfor(int j = i; j < m; j++){\n\t\t\t\t\t\tcost[i][j] = Math.min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t\t\tcost[j][i] = cost[i][j];\n\t\t\t\t\t\ttime[i][j] = Math.min(time[i][j], time[i][k] + time[k][j]);\n\t\t\t\t\t\ttime[j][i] = time[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint k = sc.nextInt();\n\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\tint p = sc.nextInt() - 1;\n\t\t\t\tint q = sc.nextInt() - 1;\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tif(r == 0){\n\t\t\t\t\tSystem.out.println(cost[p][q]);\n\t\t\t\t}else if(r == 1){\n\t\t\t\t\tSystem.out.println(time[p][q]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, cost, time;\n        Edge(int to, int cost, int time) {\n            this.to = to;\n            this.cost = cost;\n            this.time = time;\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        int node, value;\n        State(int node, int value) {\n            this.node = node;\n            this.value = value;\n        }\n        public int compareTo(State other) {\n            return this.value - other.value;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) break;\n            \n            List<Edge>[] graph = new ArrayList[m + 1];\n            for (int i = 0; i <= m; i++) {\n                graph[i] = new ArrayList<>();\n            }\n            \n            for (int i = 0; i < n; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int cost = sc.nextInt();\n                int time = sc.nextInt();\n                graph[a].add(new Edge(b, cost, time));\n                graph[b].add(new Edge(a, cost, time));\n            }\n            \n            int k = sc.nextInt();\n            for (int i = 0; i < k; i++) {\n                int p = sc.nextInt();\n                int q = sc.nextInt();\n                int r = sc.nextInt();\n                \n                if (r == 0) {\n                    System.out.println(dijkstra(graph, m, p, q, true));\n                } else {\n                    System.out.println(dijkstra(graph, m, p, q, false));\n                }\n            }\n        }\n        sc.close();\n    }\n    \n    static int dijkstra(List<Edge>[] graph, int m, int start, int end, boolean useCost) {\n        int[] dist = new int[m + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(start, 0));\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            int u = current.node;\n            int d = current.value;\n            \n            if (d > dist[u]) continue;\n            \n            for (Edge edge : graph[u]) {\n                int v = edge.to;\n                int weight = useCost ? edge.cost : edge.time;\n                \n                if (dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.offer(new State(v, dist[v]));\n                }\n            }\n        }\n        \n        return dist[end];\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Edge { int  void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); int m = sc.nextInt(); if (n == 0 && m == 0) break; List<Edge>[] graph = new ArrayList[m +  { graph[i] =  n; i++) { int a = sc.nextInt(); int b = sc.nextInt(); int cost = sc.nextInt(); int time = sc.nextInt(); graph[a].add(new Edge(b, cost, time)); graph[b].add(new Edge(a, cost,  sc.nextInt(); int q = sc.nextInt(); int r = sc.nextInt(); if (r == 0) { System.out.println(dijkstra(graph, m, p, q, true)); } else { System.out.println(dijkstra(graph,  int dijkstra(List<Edge>[] graph, int m, int start, int end, boolean useCost) { int[] dist = new int[m + 1]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; PriorityQueue<State> pq = new PriorityQueue<>(); pq.offer(new State(start, 0)); while   (Edge edge : graph[u]) { int v = edge.to; int weight = useCost ? edge.cost : edge.time; if (dist[u] +  State(v, dist[v])); } } } return dist[end]; } }"], "perturbed_original": ["import  INF =  n = sc.nextInt(); int m = sc.nextInt(); if(n == 0 && m == 0){ break; } int[][] cost = new int[m][m];   a = sc.nextInt() - 1; int b = sc.nextInt() - 1; cost[a][b] = sc.nextInt(); cost[b][a] = cost[a][b]; time[a][b] = sc.nextInt(); time[b][a] = time[a][b]; } for(int  0; i < m; i++){ for(int j = i; j < m; j++){ cost[i][j] = Math.min(cost[i][j], cost[i][k] + cost[k][j]);  = time[i][j]; } } } int k = sc.nextInt(); for(int i = 0; i < k; i++){ int p = sc.nextInt() - 1; int q = sc.nextInt() - 1; int r =  } } } sc.close(); } }"], "original_ll": -0.33844512701034546, "sampled_ll": -0.3199770152568817, "all_perturbed_sampled_ll": [-1.2608871459960938], "all_perturbed_original_ll": [-1.1996811628341675], "perturbed_sampled_ll": -1.2608871459960938, "perturbed_original_ll": -1.1996811628341675, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nfrom copy import deepcopy\nINF = 1000000000\ndef dj(s, e, r):\n  d = [INF] * 100\n  done = [0] * 100\n  d[s] = 0\n  while True:\n    v = -1\n    for i in VL:\n      if not done[i] and (v == -1 or d[i] < d[v]):\n        v = i\n    if v == e:\n      return d[e]\n    done[v] = True\n    for i in VL:\n      d[i] = min(d[i], d[v] + cost[v][i][r])\n\nL100 = range(100)\ncostPre = [[[INF for k in range(2)] for j in L100] for i in L100]\nwhile True:\n  E, V = map(int, raw_input().split())\n  cost = deepcopy(costPre)\n  VL = range(V)\n  if not E:\n    break\n  for i in range(E):\n    a, b, c, d = map(int, raw_input().split())\n    a -= 1\n    b -= 1\n    cost[a][b][0] = cost[b][a][0] = c\n    cost[a][b][1] = cost[b][a][1] = d\n  k = input()\n  for i in range(k):\n    p, q, r = map(int, raw_input().split())\n    p -= 1\n    q -= 1\n    print dj(p, q, r)", "sampled": "import heapq\nfrom collections import defaultdict\nimport sys\n\ndef dijkstra(graph, start, end, mode):\n    # mode: 0 for cost, 1 for time\n    pq = [(0, start)]\n    visited = set()\n    dist = defaultdict(lambda: float('inf'))\n    dist[start] = 0\n    \n    while pq:\n        current_dist, node = heapq.heappop(pq)\n        \n        if node in visited:\n            continue\n            \n        visited.add(node)\n        \n        if node == end:\n            return current_dist\n        \n        for neighbor, cost, time in graph[node]:\n            weight = cost if mode == 0 else time\n            new_dist = current_dist + weight\n            \n            if new_dist < dist[neighbor]:\n                dist[neighbor] = new_dist\n                heapq.heappush(pq, (new_dist, neighbor))\n    \n    return dist[end]\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    if not line:\n        break\n    n = int(line)\n    m = int(sys.stdin.readline().strip())\n    \n    if n == 0 and m == 0:\n        break\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n):\n        parts = list(map(int, sys.stdin.readline().strip().split()))\n        a, b, cost, time = parts[0], parts[1], parts[2], parts[3]\n        graph[a].append((b, cost, time))\n        graph[b].append((a, cost, time))\n    \n    k = int(sys.stdin.readline().strip())\n    \n    for _ in range(k):\n        parts = list(map(int, sys.stdin.readline().strip().split()))\n        p, q, r = parts[0], parts[1], parts[2]\n        result = dijkstra(graph, p, q, r)\n        print(result)\n", "perturbed_sampled": [" start, end, mode): # mode: 0 for cost, 1 for time pq = [(0, start)] visited = set() dist = defaultdict(lambda: float('inf')) dist[start]  new_dist heapq.heappush(pq, (new_dist, neighbor)) return dist[end] while True: line = sys.stdin.readline().strip() if not line: break n = int(line) m = int(sys.stdin.readline().strip()) if n == 0 and m  parts = list(map(int, sys.stdin.readline().strip().split())) a, b, cost, time = parts[0], parts[1], parts[2], parts[3] graph[a].append((b, cost, time)) graph[b].append((a, cost, time)) k = int(sys.stdin.readline().strip()) for _ in range(k): parts = list(map(int, sys.stdin.readline().strip().split())) p, q,  r) print(result)"], "perturbed_original": ["from copy import deepcopy INF  100 done = [0] * 100 d[s] = 0 while True: v = -1 for i in VL:  = min(d[i], d[v] + cost[v][i][r]) L100 = range(100) costPre = [[[INF for k in  True: E, V = map(int, raw_input().split()) cost = deepcopy(costPre) VL = range(V) if not E: break for i in range(E): a, b, c, d = map(int, raw_input().split()) a -= 1 b -= 1 cost[a][b][0] =  input() for i in  q -= 1 print dj(p, q, r)"], "original_ll": -0.7970202565193176, "sampled_ll": -0.4925762414932251, "all_perturbed_sampled_ll": [-1.3672021627426147], "all_perturbed_original_ll": [-2.3958590030670166], "perturbed_sampled_ll": -1.3672021627426147, "perturbed_original_ll": -2.3958590030670166, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-2 0201: Wrought Gold Master\n// 2017.8.17 bal4u@uu\n// ??\u00a2?????????????????????????????\\????????????????????\u00a3?????????\n\n#include <stdio.h>\n#include <string.h>\n\n#define HSIZ 499\ntypedef struct { char *w; int k; } HASH;\nHASH hash[HSIZ + 5];\n\nint lookup(char *w)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\tif (tp->w != NULL) {\n\t\tint inc = *w + (*(w + 1) << 1);\n\t\twhile (1) {\n\t\t\tif (!strcmp(tp->w, w)) return tp->k;\n\t\t\ti += inc; if (i >= HSIZ) i -= HSIZ;\n\t\t\ttp = hash + i;\n\t\t\tif (tp->w == NULL) break;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint insert(char *w, int k)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\tif (tp->w != NULL) {\n\t\tint inc = *w + (*(w + 1) << 1);\n\t\twhile (1) {\n\t\t\tif (!strcmp(tp->w, w)) return -1;\n\t\t\ti += inc; if (i >= HSIZ) i -= HSIZ;\n\t\t\ttp = hash + i;\n\t\t\tif (tp->w == NULL) break;\n\t\t}\n\t}\n\ttp->w = w, tp->k = k;\n\treturn 0;\n}\n\ntypedef struct { char a[102]; int m, k, i[102]; } MONO;\nMONO mono[205]; int no;\n\nint combi(int a)\n{\n\tint i, k, c = -1;\n\tk = mono[a].k;\n\tif (k > 0) for (c = i = 0; i < k; i++) c += combi(mono[a].i[i]);\n\tif (c < 0 || (mono[a].m >= 0 && mono[a].m < c)) c = mono[a].m;\n\treturn c;\n}\n\nint main()\n{\n\tint i, j, k, N, M;\n\tchar b[102];\n\n\twhile (scanf(\"%d\", &N) == 1 && N) {\n\t\tmemset(hash, 0, sizeof(hash)), no = 0;\n\t\twhile (N-- > 0) {\n\t\t\tscanf(\"%s%d\", mono[no].a, &(mono[no].m));\n\t\t\tmono[no].k = 0; insert(mono[no].a, no);\n\t\t\tno++;\n\t\t}\n\t\tscanf(\"%d\", &M);\n\t\twhile (M--) {\n\t\t\tscanf(\"%s%d\", mono[no].a, &k);\n\t\t\tif ((i = lookup(mono[no].a)) < 0) insert(mono[no].a, no), mono[no].m = -1, i = no++;\n\t\t\tmono[i].k = k;\n\t\t\tfor (j = 0; j < mono[i].k; j++) scanf(\"%s\", b), mono[i].i[j] = lookup(b);\n\t\t}\n\t\tscanf(\"%s\", b);\n\t\tprintf(\"%d\\n\", combi(lookup(b)));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_ITEMS 100\n#define MAX_NAME 101\n\ntypedef struct {\n    char name[MAX_NAME];\n    int price;\n    int has_recipe;\n    int num_ingredients;\n    int ingredients[MAX_ITEMS];\n} Item;\n\nItem items[MAX_ITEMS];\nint n, m;\nint memo[MAX_ITEMS];\nint computed[MAX_ITEMS];\n\nint find_item(char *name) {\n    for (int i = 0; i < n; i++) {\n        if (strcmp(items[i].name, name) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint min_cost(int idx) {\n    if (computed[idx]) {\n        return memo[idx];\n    }\n    \n    computed[idx] = 1;\n    int buy_cost = items[idx].price;\n    \n    if (!items[idx].has_recipe) {\n        memo[idx] = buy_cost;\n        return buy_cost;\n    }\n    \n    int craft_cost = 0;\n    for (int i = 0; i < items[idx].num_ingredients; i++) {\n        craft_cost += min_cost(items[idx].ingredients[i]);\n    }\n    \n    memo[idx] = (buy_cost < craft_cost) ? buy_cost : craft_cost;\n    return memo[idx];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s %d\", items[i].name, &items[i].price);\n            items[i].has_recipe = 0;\n            items[i].num_ingredients = 0;\n            computed[i] = 0;\n        }\n        \n        scanf(\"%d\", &m);\n        for (int i = 0; i < m; i++) {\n            char output[MAX_NAME];\n            int k;\n            scanf(\"%s %d\", output, &k);\n            \n            int out_idx = find_item(output);\n            items[out_idx].has_recipe = 1;\n            items[out_idx].num_ingredients = k;\n            \n            for (int j = 0; j < k; j++) {\n                char ingredient[MAX_NAME];\n                scanf(\"%s\", ingredient);\n                int ing_idx = find_item(ingredient);\n                items[out_idx].ingredients[j] = ing_idx;\n            }\n        }\n        \n        char target[MAX_NAME];\n        scanf(\"%s\", target);\n        int target_idx = find_item(target);\n        \n        printf(\"%d\\n\", min_cost(target_idx));\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  struct { char name[MAX_NAME]; int price; int has_recipe; int num_ingredients; int ingredients[MAX_ITEMS]; } Item; Item items[MAX_ITEMS]; int n, m; int memo[MAX_ITEMS]; int computed[MAX_ITEMS]; int find_item(char *name) { for (int i = 0; i <  i; } } return  memo[idx]; } computed[idx] = 1; int buy_cost = items[idx].price; if (!items[idx].has_recipe) { memo[idx] = buy_cost; return buy_cost; } int craft_cost = 0; for   : craft_cost; return memo[idx]; }  <  items[i].num_ingredients = 0; computed[i] = 0; } scanf(\"%d\", &m); for (int i = 0; i < m; i++) { char output[MAX_NAME]; int k;  1; items[out_idx].num_ingredients = k; for (int j = 0; j < k; j++) {  ing_idx;  printf(\"%d\\n\", min_cost(target_idx)); } return 0; }"], "perturbed_original": ["// Aizu Vol-2 0201:  #include <string.h> #define HSIZ 499 typedef struct { char *w; int k; } HASH; HASH hash[HSIZ + 5]; int lookup(char *w) { int i, l; HASH *tp; i = (101 *  1) + 107  (tp->w != NULL) { int inc = *w  (!strcmp(tp->w, w)) return tp->k; i += inc; if (i >= HSIZ) i -=  break; } } return -1; } int insert(char *w, int k) { int i, l; HASH *tp; i = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107  (tp->w  1) << 1); while (1) { if (!strcmp(tp->w, w)) return -1; i += inc; if (i >= HSIZ) i -= HSIZ; tp = hash + i; if (tp->w ==  m, k, i[102];  int  > 0) for (c = i = 0; i < k; i++) c += combi(mono[a].i[i]); if (c < 0 || (mono[a].m >= 0 && mono[a].m < c)) c = mono[a].m; return c; } int  0, sizeof(hash)), no = 0; while (N-- > 0) { scanf(\"%s%d\", mono[no].a, &(mono[no].m)); mono[no].k = 0; insert(mono[no].a, no); no++; } scanf(\"%d\", &M); while (M--) {  no),  return 0; }"], "original_ll": -0.9538273811340332, "sampled_ll": -0.5253757834434509, "all_perturbed_sampled_ll": [-2.0603601932525635], "all_perturbed_original_ll": [-1.9441224336624146], "perturbed_sampled_ll": -2.0603601932525635, "perturbed_original_ll": -1.9441224336624146, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tprice = new HashMap<String,Integer>();\n\t\t\twhile(n-- > 0){\n\t\t\t\tprice.put(sc.next(),sc.nextInt());\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\tmap = new HashMap<String,ArrayList<String>>();\n\t\t\twhile(n-- > 0){\n\t\t\t\tString s = sc.next();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tmap.put(s,new ArrayList<String>());\n\t\t\t\twhile(m-- > 0){\n\t\t\t\t\tmap.get(s).add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = new HashMap<String,Integer>();\n\t\t\tSystem.out.println(minCost(sc.next()));\n\t\t}\n\t}\n\n\tprivate static HashMap<String,Integer> price;\n\tprivate static HashMap<String,ArrayList<String>> map;\n\tprivate static HashMap<String,Integer> dp;\n\n\tprivate static int minCost(String s){\n\t\tif(map.get(s) == null) return price.get(s);\n\t\tif(dp.get(s) != null) return dp.get(s);\n\n\t\tint sum = 0;\n\n\t\tfor(String tmp : map.get(s)){\n\t\t\tsum += minCost(tmp);\n\t\t}\n\n\t\tdp.put(s, price.get(s) == null ? sum : Math.min(sum,price.get(s)));\n\n\t\treturn dp.get(s);\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static Map<String, Integer> itemPrice;\n    static Map<String, List<String>> recipes;\n    static Map<String, Integer> memo;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            itemPrice = new HashMap<>();\n            recipes = new HashMap<>();\n            memo = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                int price = sc.nextInt();\n                itemPrice.put(name, price);\n            }\n            \n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                String output = sc.next();\n                int k = sc.nextInt();\n                List<String> inputs = new ArrayList<>();\n                for (int j = 0; j < k; j++) {\n                    inputs.add(sc.next());\n                }\n                recipes.put(output, inputs);\n            }\n            \n            String target = sc.next();\n            System.out.println(getMinCost(target));\n        }\n        \n        sc.close();\n    }\n    \n    static int getMinCost(String item) {\n        if (memo.containsKey(item)) {\n            return memo.get(item);\n        }\n        \n        int buyPrice = itemPrice.get(item);\n        int minCost = buyPrice;\n        \n        if (recipes.containsKey(item)) {\n            List<String> ingredients = recipes.get(item);\n            int craftCost = 0;\n            for (String ingredient : ingredients) {\n                craftCost += getMinCost(ingredient);\n            }\n            minCost = Math.min(minCost, craftCost);\n        }\n        \n        memo.put(item, minCost);\n        return minCost;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static Map<String, Integer> itemPrice; static Map<String, List<String>> recipes; static Map<String, Integer> memo; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; itemPrice = new HashMap<>(); recipes = new HashMap<>(); memo = new HashMap<>(); for (int i = 0; i  for (int i = 0;  k = sc.nextInt(); List<String> inputs = new ArrayList<>(); for (int  { return memo.get(item); }  { List<String> ingredients = recipes.get(item); int craftCost = 0; for (String ingredient : ingredients)  memo.put(item, minCost); return minCost; } }"], "perturbed_original": ["import java.util.*; public class Main{ public static void main(String[] args){ Scanner sc  price.put(sc.next(),sc.nextInt()); } n = sc.nextInt(); map = new HashMap<String,ArrayList<String>>(); while(n-- > 0){ String s = sc.next(); int m = sc.nextInt(); map.put(s,new ArrayList<String>()); while(m-- > 0){ map.get(s).add(sc.next()); } } dp = new HashMap<String,Integer>(); System.out.println(minCost(sc.next())); } } private static HashMap<String,Integer> price; private static HashMap<String,ArrayList<String>> map;  == null) return price.get(s); if(dp.get(s) != null)  sum : Math.min(sum,price.get(s))); return dp.get(s); } }"], "original_ll": -0.6151684522628784, "sampled_ll": -0.4333738088607788, "all_perturbed_sampled_ll": [-1.3713265657424927], "all_perturbed_original_ll": [-1.7591413259506226], "perturbed_sampled_ll": -1.3713265657424927, "perturbed_original_ll": -1.7591413259506226, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n  count = int(input())\n  if count == 0: break \n  thing,money=[],[]\n  for i in range(count):\n    hoge = map(str,raw_input().split())\n    t = int(hoge[1])\n    thing.append(hoge[0])\n    money.append(t)\n  count = int(input())\n  if count == 0:\n    hoge = raw_input()\n    if hoge not in thing:\n      print 0\n      continue\n    t = thing.index(hoge)\n    print money[t]\n  else:\n    for i in range(count):\n      hoge = map(str,raw_input().split())\n      if hoge[0] not in thing:\n        print 0\n      t = int(hoge[1])\n      x,y = 2,0\n      for j in range(t):\n        r = thing.index(hoge[x])\n        y += money[r]\n        x+=1\n      e = thing.index(hoge[0])\n      money[e]= y\n    g = raw_input()\n    ans = thing.index(g)\n    print money[ans]", "sampled": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        # Read items and their prices\n        prices = {}\n        for _ in range(n):\n            line = input().split()\n            item_name = line[0]\n            price = int(line[1])\n            prices[item_name] = price\n        \n        # Read recipes\n        m = int(input())\n        recipes = {}\n        for _ in range(m):\n            line = input().split()\n            output_item = line[0]\n            k = int(line[1])\n            ingredients = line[2:2+k]\n            recipes[output_item] = ingredients\n        \n        # Read target item\n        target = input().strip()\n        \n        # Memoization for minimum cost\n        memo = {}\n        \n        def min_cost(item):\n            if item in memo:\n                return memo[item]\n            \n            # Option 1: Buy directly\n            buy_cost = prices[item]\n            \n            # Option 2: Craft using recipe (if available)\n            if item in recipes:\n                craft_cost = 0\n                for ingredient in recipes[item]:\n                    craft_cost += min_cost(ingredient)\n                result = min(buy_cost, craft_cost)\n            else:\n                result = buy_cost\n            \n            memo[item] = result\n            return result\n        \n        print(min_cost(target))\n\nsolve()\n", "perturbed_sampled": ["import sys from collections import defaultdict def  break # Read items and their prices prices = {} for _ in range(n): line = input().split() item_name = line[0] price = int(line[1]) prices[item_name]  {} for  = int(line[1]) ingredients = line[2:2+k] recipes[output_item] = ingredients # Read target item target = input().strip() # Memoization for minimum cost memo  # Option 1: Buy directly buy_cost = prices[item] # Option  craft_cost  = min(buy_cost, craft_cost) else: result = buy_cost memo[item] = result return result print(min_cost(target)) solve()"], "perturbed_original": ["while True: count = int(input()) if  = map(str,raw_input().split()) t = int(hoge[1]) thing.append(hoge[0]) money.append(t) count = int(input()) if count == 0:  in range(count): hoge = map(str,raw_input().split()) if hoge[0] not in  j in range(t): r = thing.index(hoge[x]) y += money[r] x+=1 e = thing.index(hoge[0]) money[e]= y g = raw_input() ans = thing.index(g) print money[ans]"], "original_ll": -1.1882965564727783, "sampled_ll": -0.7553865313529968, "all_perturbed_sampled_ll": [-2.8112237453460693], "all_perturbed_original_ll": [-2.4155213832855225], "perturbed_sampled_ll": -2.8112237453460693, "perturbed_original_ll": -2.4155213832855225, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_PRIME\t(1000000)\n#define IS_PRIME(n)\t(prime[j]==0?1:0)\n\nint prime[MAX_PRIME + 1];\nint fare[MAX_PRIME + 1];\nint fare_next[MAX_PRIME + 1];\n\n\nvoid make_prime(void)\n{\n    int i;\n    int j;\n    int n;\n    int c;\n    \n    for (i = 2; i * i <= MAX_PRIME; i++){\n        if (prime[i] == 0){\n            for (j = i * 2; j <= MAX_PRIME; j += i){\n\t\t\t\tprime[j] = 1;\n            }\n        }\n    }\n}\n\n\nint main(void)\n{\n\tint n, x;\n\tint price[30];\n\tint i, j, k;\n\t\n\tmake_prime();\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &n, &x);\n\t\tif (n == 0 && x == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &price[i]);\n\t\t}\n\t\t\n\t\tmemset(fare_next, 0, sizeof(fare_next));\n\t\tfare_next[0] = 1;\n\t\tfor (i = 0; i < n; i++){\n\n\t\t\tmemcpy(fare, fare_next, sizeof(fare_next));\n\t\t\tfor (j = price[i]; j <= x; j += price[i]){\n\t\t\t\tfor (k = 0; k <= x; k++){\n\t\t\t\t\tif (fare[k] != 0){\n\t\t\t\t\t\tif (k + j <= x){\n\t\t\t\t\t\t\tfare_next[k + j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemcpy(fare, fare_next, sizeof(fare_next));\n\t\t\n//for (i = 1; i <= x; i++){\n//\tprintf(\"[%d=%d]\", i, fare[i]);\n//}\n\n\t\tfor (i = x; i >= 1; i--){\n\t\t\tif (fare[i] != 0 && prime[i] == 0){\n\t\t\t\tprintf(\"%d\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == 0){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nbool isNotDivisibleByAny(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n, x;\n    \n    while (scanf(\"%d %d\", &n, &x) == 2) {\n        if (n == 0 && x == 0) break;\n        \n        int v[30];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &v[i]);\n        }\n        \n        bool *possible = (bool *)calloc(x + 1, sizeof(bool));\n        possible[0] = true;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = v[i]; j <= x; j++) {\n                if (possible[j - v[i]]) {\n                    possible[j] = true;\n                }\n            }\n        }\n        \n        int result = -1;\n        for (int i = x; i >= 1; i--) {\n            if (possible[i]) {\n                bool divisible = false;\n                for (int d = 2; d <= i; d++) {\n                    if (i % d == 0) {\n                        divisible = true;\n                        break;\n                    }\n                }\n                if (!divisible && i > 1) {\n                    result = i;\n                    break;\n                }\n            }\n        }\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n        \n        free(possible);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  (b != 0) { int temp = b; b = a % b; a = temp; } return a; }  for (int  if (num % i == 0) return false; } return true; } int main() { int n, x; while (scanf(\"%d %d\", &n, &x) == 2)  n; i++) { scanf(\"%d\", &v[i]); } bool *possible = (bool *)calloc(x + 1, sizeof(bool)); possible[0] = true; for (int i = 0; i < n; i++) { for (int j = v[i]; j <= x; j++) {  }  >= 1; i--) {  = 2; d  && i > 1) { result = i; break; }  { printf(\"%d\\n\", result); } free(possible); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #define MAX_PRIME (1000000) #define IS_PRIME(n) (prime[j]==0?1:0) int prime[MAX_PRIME + 1]; int fare[MAX_PRIME + 1]; int fare_next[MAX_PRIME + 1]; void make_prime(void) { int i; int j; int n; int c; for (i = 2; i  += i){ prime[j] = 1; } } } } int main(void) { int n, x; int price[30]; int i, j, k; make_prime(); while (1){ scanf(\"%d%d\", &n, &x); if (n == 0 && x == 0){ break; } for (i = 0;  0; k <= x; k++){ if (fare[k] != 0){ if  }  1; i <= x; i++){ // printf(\"[%d=%d]\", i, fare[i]); //} for (i = x; i  0){  } } return (0); }"], "original_ll": -0.7649291753768921, "sampled_ll": -0.42027607560157776, "all_perturbed_sampled_ll": [-1.6049696207046509], "all_perturbed_original_ll": [-1.6343673467636108], "perturbed_sampled_ll": -1.6049696207046509, "perturbed_original_ll": -1.6343673467636108, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint MAX = 1000000;\n\t\tboolean[] prime = new boolean[MAX + 1];\n\t\tfor (int i = 4; i <= MAX; i += 2) {\n\t\t\tprime[i] = true;\n\t\t}\n\t\tfor (int i = 3; i <= Math.sqrt(MAX); i += 2) {\n\t\t\tif (!prime[i]) {\n\t\t\t\tfor (int j = i * 3; j <= MAX; j += i * 2) {\n\t\t\t\t\tprime[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] a = new int[n];\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tboolean[] f = new boolean[m + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint s = scanner.nextInt();\n\t\t\t\tmin = Math.min(s, min);\n\t\t\t\ta[i] = s;\n\t\t\t\tfor (int j = s; j <= m; j += s) {\n\t\t\t\t\tf[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\tint max = 0;\n\t\t\tfor (int i = min; i <= m; i++) {\n\t\t\t\tif (!f[i])\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (i - a[j] >= 0 && f[i - a[j]]) {\n\t\t\t\t\t\t\tf[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif (f[i] && !prime[i])\n\t\t\t\t\tmax = i;\n\t\t\t}\n\t\t\tSystem.out.println(max == 0 ? \"NA\" : max);\n\n\t\t}\n\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (n == 0 && x == 0) break;\n            \n            int[] prices = new int[n];\n            for (int i = 0; i < n; i++) {\n                prices[i] = sc.nextInt();\n            }\n            \n            // Find all possible sums up to budget x\n            boolean[] possible = new boolean[x + 1];\n            possible[0] = true;\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = prices[i]; j <= x; j++) {\n                    if (possible[j - prices[i]]) {\n                        possible[j] = true;\n                    }\n                }\n            }\n            \n            // Find the maximum sum that is not divisible by any number from 2 to itself-1\n            int result = -1;\n            for (int sum = x; sum >= 2; sum--) {\n                if (possible[sum] && isPrime(sum)) {\n                    result = sum;\n                    break;\n                }\n            }\n            \n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean isPrime(int num) {\n        if (num < 2) return false;\n        if (num == 2) return true;\n        if (num % 2 == 0) return false;\n        \n        for (int i = 3; i * i <= num; i += 2) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public <extra_id_4>int = sc.nextInt(); if (n == 0 && x == 0) break; int[] prices = new [<extra_id_5>;<extra_id_6>for (int i =<extra_id_7>+ 1; i++)<extra_id_8>{ if (possible[i]<extra_id_9>j ]<extra_id_10>return<extra_id_11>== -1; } else<extra_id_12>+(i*i); } System.out.println(\"No solution found:\");<extra_id_13>public<extra_id_14>void checkSums (<extra_id_15>{<extra_id_16>int result<extra_id_17>=<extra_id_18>{ int result = sc.nextInt;<extra_id_19>.<extra_id_20>if ( result { prices[i] = sc.nextInt(); } // Find all possible sums up to budget x boolean[] possible = new boolean[x + 1]; possible[0] = true; for (int i = 0;  j <= x; j++) { if (possible[j -  the maximum sum that is not divisible by any number from 2 to itself-1 int  2; sum--) {  } if (result == -1) { System.out.println(\"NA\");  boolean isPrime(int num) { if (num < 2) return false; if (num  return false; for (int  2) { if (num % i == 0) return false; } return true; } }"], "perturbed_original": ["import java.io.IOException; import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String[] args) throws IOException { new Main().run(); } private void run() throws IOException {  prime =  } for (int i = 3;  for (int j = i * 3; j <= MAX; j += i * 2) { prime[j] = true; } } } while (true) { int n = scanner.nextInt(); int m = scanner.nextInt(); if ((n | m) == 0) break; int[] a = new int[n]; int min = Integer.MAX_VALUE; boolean[] f = new boolean[m + 1]; for (int i = 0;  = s; j <= m; j += s) { f[j] = true;  = min;  = 0; j < n; j++) { if (i   max); } } }"], "original_ll": -0.5391613841056824, "sampled_ll": -0.4738403558731079, "all_perturbed_sampled_ll": [-2.1854114532470703], "all_perturbed_original_ll": [-1.5394395589828491], "perturbed_sampled_ll": -2.1854114532470703, "perturbed_original_ll": -1.5394395589828491, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from array import array\nPRIME_MAX = 1000001\nisPrime = array('b', [1] * PRIME_MAX)\nisPrime[0] = 0\nisPrime[1] = 0\nfor i in xrange(2, PRIME_MAX):\n\tif not isPrime[i]: continue\n\tfor j in xrange(i << 1, PRIME_MAX, i):\n\t\tisPrime[j] = 0\nwhile True:\n\tn, x = map(int, raw_input().split())\n\tif n == x == 0: break\n\tmenu = [input() for i in xrange(n)]\n\tresult = 0\n\texists = set()\n\texists.add(0)\n\tfor i in xrange(x + 1):\n\t\tif i in exists:\n\t\t\texists.remove(i)\n\t\t\tfor v in menu:\n\t\t\t\texists.add(i + v)\n\t\t\tif isPrime[i]:\n\t\t\t\tresult = i\n\tif result:\n\t\tprint result\n\telse:\n\t\tprint \"NA\"", "sampled": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(n, budget, prices):\n    # Dynamic programming to find all possible sums\n    possible = [False] * (budget + 1)\n    possible[0] = True\n    \n    for price in prices:\n        for total in range(budget, price - 1, -1):\n            if possible[total - price]:\n                possible[total] = True\n    \n    # Find the largest sum that is not divisible by all numbers from 2 to sum\n    for total in range(budget, 0, -1):\n        if not possible[total]:\n            continue\n        \n        # Check if total is not divisible by any number from 2 to total-1\n        is_prime_like = True\n        for divisor in range(2, int(math.sqrt(total)) + 1):\n            if total % divisor == 0:\n                is_prime_like = False\n                break\n        \n        if is_prime_like and total > 1:\n            return total\n    \n    return \"NA\"\n\ndef is_not_divisible_by_any(num):\n    # A number is not divisible by any number except 1 and itself if it's prime\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef solve2(n, budget, prices):\n    # Dynamic programming to find all possible sums\n    possible = set([0])\n    \n    for price in prices:\n        new_possible = set()\n        for p in possible:\n            amount = p\n            while amount + price <= budget:\n                amount += price\n                new_possible.add(amount)\n        possible.update(new_possible)\n    \n    # Find the largest sum that is prime\n    for total in range(budget, 1, -1):\n        if total in possible and is_not_divisible_by_any(total):\n            return total\n    \n    return \"NA\"\n\nwhile True:\n    line = input().split()\n    n, x = int(line[0]), int(line[1])\n    \n    if n == 0 and x == 0:\n        break\n    \n    prices = []\n    for _ in range(n):\n        prices.append(int(input()))\n    \n    print(solve2(n, x, prices))\n", "perturbed_sampled": ["import math from functools import reduce def gcd(a, b): while b: a, b = b, a % b return a def solve(n, budget, prices): # Dynamic programming to find all  possible[total] = True # Find the largest sum that  for total in range(budget, 0, -1): if not possible[total]: continue # Check  to total-1 is_prime_like = True  divisor ==  return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(math.sqrt(num)) + 1, 2): if num % i == 0: return False return True def solve2(n, budget, prices): # Dynamic programming to find all possible sums possible = set([0]) for price in prices: new_possible = set() for p in possible: amount = p while amount + price <= budget: amount += price new_possible.add(amount) possible.update(new_possible) # Find the largest sum that is prime for total in range(budget, 1,  prices.append(int(input())) print(solve2(n, x, prices))"], "perturbed_original": ["from array import array PRIME_MAX =  isPrime[1] = 0 for i in  << 1, PRIME_MAX, i): isPrime[j] = 0 while True: n, x = map(int, raw_input().split()) if n == x == 0: break menu = [input() for i in xrange(n)] result = 0  exists.add(i + v) if isPrime[i]: result = i if result: print result else: print \"NA\""], "original_ll": -0.9631505608558655, "sampled_ll": -0.6624335050582886, "all_perturbed_sampled_ll": [-1.8793314695358276], "all_perturbed_original_ll": [-2.5132548809051514], "perturbed_sampled_ll": -1.8793314695358276, "perturbed_original_ll": -2.5132548809051514, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\tint w,h,xd[]={1,0,-1},p,u[20][20];\n\tvoid ret(int x,int y){\n\t\tint i,s=x;\n\t\tif(h-1<=y)\n\t\t\tp++;\n\t\telse if(u[y][x]==2)\n\t\t\tret(x,y+2);\n\t\telse if(u[y][x]==0){\n\t\t\ty++;\n\t\t\tfor(i=0;i<3;i++){\n\t\t\t\tx=s+xd[i];\n\t\t\t\tif(x>=0&&x<=w-1){\n\t\t\t\t\tif(u[y][x]==2&&i==1)\n\t\t\t\t\t\tret(x,y+2);\n\t\t\t\t\telse if(u[y][x]==0)\n\t\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint main(){\n\t\tint i,j,x,y;\n\t\twhile(scanf(\"%d %d\",&w,&h),w||h){\n\t\t\tp=0;\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w-1;j++)\n\t\t\t\tscanf(\"%d \",&u[i][j]);\n\t\t\t\tscanf(\"%d\",&u[i][w-1]);\n\t\t\t}\n\t\t\tfor(i=0;i<w;i++){\n\t\t\t\tif(u[0][i]==0){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=0;\n\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t\telse if(u[0][i]==2){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=2;\n\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",p);\n\t\t}\n\t\treturn 0;\n\t}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint X, Y;\nint course[16][16];\nlong long dp[16][16];\n\nlong long countPaths() {\n    memset(dp, 0, sizeof(dp));\n    \n    // Initialize first row (y=1)\n    for (int x = 1; x <= X; x++) {\n        if (course[x][1] != 1) {  // Not an obstacle\n            dp[x][1] = 1;\n        }\n    }\n    \n    // Fill the dp table\n    for (int y = 1; y < Y; y++) {\n        for (int x = 1; x <= X; x++) {\n            if (dp[x][y] == 0) continue;\n            \n            if (course[x][y] == 2) {  // Jump platform\n                // Jump to (x, y+2)\n                if (y + 2 <= Y) {\n                    if (course[x][y+2] != 1) {\n                        dp[x][y+2] += dp[x][y];\n                    }\n                } else {\n                    // Jump goes beyond Y, count as reaching goal\n                    dp[x][Y] += dp[x][y];\n                }\n            } else {  // Normal cell (0)\n                // Move to (x-1, y+1), (x, y+1), (x+1, y+1)\n                for (int dx = -1; dx <= 1; dx++) {\n                    int nx = x + dx;\n                    int ny = y + 1;\n                    \n                    if (nx < 1 || nx > X) continue;\n                    \n                    if (ny > Y) {\n                        // Reached goal\n                        dp[x][Y] += dp[x][y];\n                    } else {\n                        if (course[nx][ny] == 1) {  // Obstacle\n                            continue;\n                        }\n                        if (course[nx][ny] == 2) {  // Jump platform\n                            // Can only enter jump platform from directly above (dx == 0)\n                            if (dx == 0) {\n                                dp[nx][ny] += dp[x][y];\n                            }\n                        } else {  // Normal cell\n                            dp[nx][ny] += dp[x][y];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Sum all paths that reached Y\n    long long total = 0;\n    for (int x = 1; x <= X; x++) {\n        total += dp[x][Y];\n    }\n    \n    return total;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &X, &Y);\n        if (X == 0 && Y == 0) break;\n        \n        for (int y = 1; y <= Y; y++) {\n            for (int x = 1; x <= X; x++) {\n                scanf(\"%d\", &course[x][y]);\n            }\n        }\n        \n        printf(\"%lld\\n\", countPaths());\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  long countPaths() { memset(dp, 0, sizeof(dp)); // Initialize first row (y=1) for  (course[x][1] != 1) { // Not an obstacle dp[x][1]  (int y = 1; y < Y; y++) { for (int x = 1; x <= X; x++) { if (dp[x][y] == 0) continue; if (course[x][y] == 2) { // Jump platform // Jump to (x, y+2) if (y + 2 <= Y) { if (course[x][y+2] != 1) {  beyond Y,  -1; dx  int ny = y + 1; if (nx < 1 || nx > X) continue; if (ny > Y) { // Reached goal dp[x][Y] += dp[x][y]; } else  if  enter  == 0) { dp[nx][ny] += dp[x][y]; } } else { // Normal cell dp[nx][ny] += dp[x][y]; } } } } } } // Sum all paths that reached Y long  <= X; x++) { total += dp[x][Y]; } return total; } int main() { while (1)  Y == 0) break;  { scanf(\"%d\", &course[x][y]); } } printf(\"%lld\\n\", countPaths()); } return 0; }"], "perturbed_original": ["#include<stdio.h> int w,h,xd[]={1,0,-1},p,u[20][20]; void ret(int x,int y){ int i,s=x; if(h-1<=y) p++; else if(u[y][x]==2) ret(x,y+2); else if(u[y][x]==0){ y++;   for(j=0;j<w-1;j++) scanf(\"%d \",&u[i][j]); scanf(\"%d\",&u[i][w-1]); } for(i=0;i<w;i++){ if(u[0][i]==0){ x=i; y=0;  } return 0; }"], "original_ll": -0.9311797618865967, "sampled_ll": -0.5692476630210876, "all_perturbed_sampled_ll": [-1.9463634490966797], "all_perturbed_original_ll": [-2.1355834007263184], "perturbed_sampled_ll": -1.9463634490966797, "perturbed_original_ll": -2.1355834007263184, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int H,W;\n\tstatic int[][] field;\n\tstatic int[][] dp;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tW=cin.nextInt();\n\t\t\tH=cin.nextInt();\n\t\t\tif(W+H==0)break;\n\t\t\tfield=new int[H+2][W];\n\t\t\tdp=new int[H+2][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<W;i++){\n\t\t\t\tif(field[0][i]==0)dp[0][i]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]==0){\n\t\t\t\t\t\tif(i!=H-1){\n\t\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\t\tif(j+k<0||j+k>=W)continue;\n\t\t\t\t\t\t\t\tif(field[i+1][j+k]==1)continue;\n\t\t\t\t\t\t\t\tif(k!=0&&field[i+1][j+k]==2)continue;\n\t\t\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[i][j]==2){\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=H;i<H+2;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tans+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int X, Y;\n    static int[][] course;\n    static long[][] memo;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            X = sc.nextInt();\n            Y = sc.nextInt();\n            \n            if (X == 0 && Y == 0) break;\n            \n            course = new int[X + 1][Y + 1];\n            memo = new long[X + 1][Y + 1];\n            \n            for (int y = 1; y <= Y; y++) {\n                for (int x = 1; x <= X; x++) {\n                    course[x][y] = sc.nextInt();\n                    memo[x][y] = -1;\n                }\n            }\n            \n            long total = 0;\n            for (int x = 1; x <= X; x++) {\n                if (course[x][1] != 1) {\n                    total += dfs(x, 1);\n                }\n            }\n            \n            System.out.println(total);\n        }\n        \n        sc.close();\n    }\n    \n    static long dfs(int x, int y) {\n        if (y >= Y) {\n            return 1;\n        }\n        \n        if (memo[x][y] != -1) {\n            return memo[x][y];\n        }\n        \n        long count = 0;\n        \n        if (course[x][y] == 2) {\n            // Jump platform - skip to y+2\n            int nextY = y + 2;\n            if (nextY >= Y) {\n                count = 1;\n            } else if (course[x][nextY] != 1) {\n                if (course[x][nextY] == 2) {\n                    count = dfs(x, nextY);\n                } else {\n                    count = dfs(x, nextY);\n                }\n            }\n        } else {\n            // Normal movement to y+1\n            int nextY = y + 1;\n            \n            // Move to (x-1, y+1)\n            if (x - 1 >= 1 && course[x - 1][nextY] != 1) {\n                if (course[x - 1][nextY] == 2) {\n                    // Can't enter jump platform from diagonal\n                } else {\n                    count += dfs(x - 1, nextY);\n                }\n            }\n            \n            // Move to (x, y+1)\n            if (course[x][nextY] != 1) {\n                count += dfs(x, nextY);\n            }\n            \n            // Move to (x+1, y+1)\n            if (x + 1 <= X && course[x + 1][nextY] != 1) {\n                if (course[x + 1][nextY] == 2) {\n                    // Can't enter jump platform from diagonal\n                } else {\n                    count += dfs(x + 1, nextY);\n                }\n            }\n        }\n        \n        memo[x][y] = count;\n        return count;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int X, Y; static int[][] course; static long[][] memo; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { X = sc.nextInt(); Y  break; course = new int[X + 1][Y + 1]; memo = new  1; x <=  } long total = 0; for (int x = 1; x <= X; x++) { if (course[x][1] != 1) { total += dfs(x, 1); } } System.out.println(total);  platform - skip to y+2  { count = 1; } else if (course[x][nextY] != 1) { if (course[x][nextY] ==  =  Move to (x-1, y+1) if (x -  if (course[x - 1][nextY] == 2) { // Can't enter jump platform from diagonal } else { count += dfs(x - 1, nextY); } } // Move to (x, y+1) if (course[x][nextY] != 1) { count += dfs(x, nextY); } // Move to (x+1, y+1) if (x + 1 <= X && course[x + 1][nextY]  { count += dfs(x + 1, nextY); } } } memo[x][y] = count; return count; } }"], "perturbed_original": ["import java.util.Scanner;  static int[][] dp; public static void main(String[]  if(W+H==0)break; field=new int[H+2][W]; dp=new int[H+2][W]; for(int  if(field[i+1][j+k]==1)continue; if(k!=0&&field[i+1][j+k]==2)continue; dp[i+1][j+k]+=dp[i][j]; } } else{ dp[i+1][j]+=dp[i][j]; } } else if(field[i][j]==2){ dp[i+2][j]+=dp[i][j]; } } } int ans=0; for(int i=H;i<H+2;i++){ for(int j=0;j<W;j++){ ans+=dp[i][j]; } } System.out.println(ans); } } }"], "original_ll": -0.5766692757606506, "sampled_ll": -0.4504523277282715, "all_perturbed_sampled_ll": [-1.462198257446289], "all_perturbed_original_ll": [-1.4195390939712524], "perturbed_sampled_ll": -1.462198257446289, "perturbed_original_ll": -1.4195390939712524, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n\tX,Y = map(int,raw_input().split())\n\tif X == 0: break\n\tA = [[0]+map(int,raw_input().split())+[0] for i in range(Y)]\n\tS = [[0]*(X+2) for i in range(Y)]\n\tfor x in range(1,X+1): S[0][x] = 1 if A[0][x] != 1 else 0\n\tfor y in range(1,Y):\n\t\tfor x in range(1,X+1):\n\t\t\tif A[y][x] == 0:\n\t\t\t\tfor i in range(-1,2):\n\t\t\t\t\tS[y][x] += (S[y-1][x-i] if A[y-1][x-i] == 0 else 0)\n\t\t\tif A[y][x] == 2:\n\t\t\t\tS[y][x] += S[y-1][x-1]\n\t\t\t\tif y+2 < Y and A[y+2][x] != 1:\n\t\t\t\t\tS[y+2][x] = S[y][x]\n\tans = 0\n\tfor x in range(1,X+1):\n\t\tans += S[Y-1][x] + (S[Y-2][x] if A[Y-2][x] == 2 else 0)\n\tprint ans", "sampled": "import sys\n\ndef solve(X, Y, grid):\n    # dp[y][x] = number of ways to reach position (x, y)\n    dp = [[0] * X for _ in range(Y + 1)]\n    \n    # Initialize starting positions at y=0 (0-indexed, which is y=1 in problem)\n    for x in range(X):\n        if grid[0][x] != 1:  # not an obstacle\n            dp[0][x] = 1\n    \n    # Process each row\n    for y in range(Y):\n        for x in range(X):\n            if dp[y][x] == 0:\n                continue\n            \n            # Check if current position has a jump platform\n            if grid[y][x] == 2:\n                # Jump to (x, y+2)\n                target_y = y + 2\n                if target_y < Y:\n                    if grid[target_y][x] != 1:  # not an obstacle\n                        dp[target_y][x] += dp[y][x]\n                else:\n                    # Reached beyond Y, count as completion\n                    # We need to track completions separately\n                    pass\n            else:\n                # Normal movement to (x-1, y+1), (x, y+1), (x+1, y+1)\n                target_y = y + 1\n                if target_y < Y:\n                    # Move to (x-1, y+1)\n                    if x - 1 >= 0:\n                        if grid[target_y][x-1] == 2:\n                            # Can't enter jump platform from diagonal\n                            pass\n                        elif grid[target_y][x-1] != 1:\n                            dp[target_y][x-1] += dp[y][x]\n                    \n                    # Move to (x, y+1)\n                    if grid[target_y][x] != 1:\n                        dp[target_y][x] += dp[y][x]\n                    \n                    # Move to (x+1, y+1)\n                    if x + 1 < X:\n                        if grid[target_y][x+1] == 2:\n                            # Can't enter jump platform from diagonal\n                            pass\n                        elif grid[target_y][x+1] != 1:\n                            dp[target_y][x+1] += dp[y][x]\n    \n    # Count paths that reach y >= Y\n    total = 0\n    \n    # Add paths from y = Y-1\n    for x in range(X):\n        if dp[Y-1][x] > 0:\n            if grid[Y-1][x] == 2:\n                # Jump from Y-1 goes to Y+1, which is >= Y\n                total += dp[Y-1][x]\n            else:\n                # Normal movement from Y-1 goes to Y, which is >= Y\n                total += dp[Y-1][x]\n    \n    # Add paths from y = Y-2 that jump\n    if Y >= 2:\n        for x in range(X):\n            if dp[Y-2][x] > 0 and grid[Y-2][x] == 2:\n                # Jump from Y-2 goes to Y, which is >= Y\n                # But we need to check if this was already counted\n                # Actually, when we process Y-2, we add to dp[Y][x] if Y < Y, which is false\n                # So we need to handle this separately\n                pass\n    \n    return total\n\n# Read input\nwhile True:\n    line = input().split()\n    X, Y = int(line[0]), int(line[1])\n    \n    if X == 0 and Y == 0:\n        break\n    \n    grid = []\n    for y in range(Y):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Re-implement with better logic\n    dp = [[0] * X for _ in range(Y + 2)]\n    \n    # Initialize\n    for x in range(X):\n        if grid[0][x] != 1:\n            dp[0][x] = 1\n    \n    for y in range(Y + 1):\n        for x in range(X):\n            if dp[y][x] == 0:\n                continue\n            \n            if y >= Y:\n                continue\n            \n            if grid[y][x] == 2:\n                # Jump\n                target_y = y + 2\n                if target_y <= Y:\n                    dp[target_y][x] += dp[y][x]\n            else:\n                # Normal move\n                target_y = y + 1\n                if target_y <= Y:\n                    for dx in [-1, 0, 1]:\n                        nx = x + dx\n                        if 0 <= nx < X:\n                            if target_y < Y:\n                                if grid[target_y][nx] == 2 and dx != 0:\n                                    continue\n                                if grid[target_y][nx] != 1:\n                                    dp[target_y][nx] += dp[y][x]\n                            else:\n                                dp[target_y][nx] += dp[y][x]\n    \n    result = sum(dp[Y])\n    print(result)\n", "perturbed_sampled": ["import sys def solve(X,  position (x, y) dp = [[0] * X  x in range(X): if grid[0][x] != 1:  row for y in range(Y): for x in range(X): if dp[y][x]  (x, y+2) target_y = y + 2 if target_y < Y: if grid[target_y][x] != 1: # not an obstacle dp[target_y][x] += dp[y][x] else: # Reached beyond  (x, y+1), (x+1, y+1) target_y = y + 1 if target_y < Y: # Move to (x-1, y+1) if x - 1 >= 0: if grid[target_y][x-1] == 2: # Can't enter jump platform from diagonal pass elif grid[target_y][x-1] != 1: dp[target_y][x-1] += dp[y][x] # Move to (x, y+1) if grid[target_y][x]  if x + 1 < X: if grid[target_y][x+1] == 2: # Can't  dp[target_y][x+1] += dp[y][x] #  #  Jump from Y-1 goes to Y+1, which is >= Y total += dp[Y-1][x] else: # Normal movement  += dp[Y-1][x] # Add paths from y = Y-2 that jump if Y >= 2: for x in range(X): if dp[Y-2][x] > 0 and grid[Y-2][x]   Y-2, we add to dp[Y][x] if Y < Y, which is false # So we need to handle this separately pass return total # Read input while True: line = input().split() X, Y = int(line[0]), int(line[1]) if X ==  Re-implement with better logic  0: continue  Jump target_y = y + 2  move target_y = y + 1 if target_y <= Y: for dx in [-1, 0, 1]: nx = x + dx if 0 <= nx < X: if target_y < Y: if grid[target_y][nx] == 2 and dx != 0: continue if grid[target_y][nx] != 1: dp[target_y][nx] += dp[y][x] else: dp[target_y][nx] += dp[y][x] result = sum(dp[Y]) print(result)"], "perturbed_original": ["while 1: X,Y = map(int,raw_input().split()) if X == 0: break A = [[0]+map(int,raw_input().split())+[0] for i in range(Y)] S  S[0][x] = 1 if A[0][x]  in range(1,X+1): if A[y][x] == 0: for i in range(-1,2): S[y][x] += (S[y-1][x-i] if A[y-1][x-i] == 0  += S[Y-1][x] + (S[Y-2][x] if A[Y-2][x] == 2 else 0) print ans"], "original_ll": -0.7626677751541138, "sampled_ll": -0.689586877822876, "all_perturbed_sampled_ll": [-1.6970713138580322], "all_perturbed_original_ll": [-1.4842791557312012], "perturbed_sampled_ll": -1.6970713138580322, "perturbed_original_ll": -1.4842791557312012, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-8)\n\ntypedef struct {\n\tdouble x,y;\n\tdouble angle;\n\tint r;\n\tint v;\n\tint arrive;\n} ufo_t;\n\nint N;\nufo_t ufo[100];\nint R;\n\ndouble get_dist(double mx,double my,double x,double y) {\n\treturn fabs(my*x-mx*y)/sqrt(my*my+mx*mx);\n}\n\nint main(void) {\n\tint i;\n\tint target;\n\tdouble target_dist;\n\tint count;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&R,&N);\n\t\tif(R==0 && N==0)break;\n\t\tfor(i=0;i<N;i++) {\n\t\t\tscanf(\"%lf%lf%d%d\",\n\t\t\t\t&ufo[i].x,&ufo[i].y,&ufo[i].r,&ufo[i].v);\n\t\t\tufo[i].arrive=1;\n\t\t\tufo[i].angle=atan2(ufo[i].y,ufo[i].x);\n\t\t}\n\t\ttarget=0;\n\t\twhile(target>=0) {\n\t\t\tfor(i=0;i<N;i++) {\n\t\t\t\tif(R+EPS<sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y)) {\n\t\t\t\t\tdouble prev_x,prev_y;\n\t\t\t\t\tprev_x=ufo[i].x;\n\t\t\t\t\tprev_y=ufo[i].y;\n\t\t\t\t\tufo[i].x-=ufo[i].v*cos(ufo[i].angle);\n\t\t\t\t\tufo[i].y-=ufo[i].v*sin(ufo[i].angle);\n\t\t\t\t\tif(prev_x*ufo[i].x<0)ufo[i].x=0;\n\t\t\t\t\tif(prev_y*ufo[i].y<0)ufo[i].y=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget=-1;\n\t\t\ttarget_dist=1000*1000;\n\t\t\tfor(i=0;i<N;i++) {\n\t\t\t\tdouble dist;\n\t\t\t\tif(!ufo[i].arrive)continue;\n\t\t\t\tdist=sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y);\n\t\t\t\tif(dist<target_dist+EPS && R+EPS<dist) {\n\t\t\t\t\ttarget_dist=dist;\n\t\t\t\t\ttarget=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(target<0)break;\n\t\t\tfor(i=0;i<N;i++) {\n\t\t\t\tif(sqrt(ufo[i].x*ufo[i].x+\n\t\t\t\t\tufo[i].y*ufo[i].y)<R+EPS)continue;\n\t\t\t\tif(get_dist(ufo[target].x,ufo[target].y,\n\t\t\t\t\t\tufo[i].x,ufo[i].y)<ufo[i].r+EPS &&\n\t\t\t\t\t\tufo[target].x*ufo[i].x>=0 &&\n\t\t\t\t\t\tufo[target].y*ufo[i].y>=0) {\n\t\t\t\t\tufo[i].arrive=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount=0;\n\t\tfor(i=0;i<N;i++) {\n\t\t\tif(ufo[i].arrive)count++;\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n#define INF 1e9\n\ntypedef struct {\n    double x, y;\n    double r;\n    double v;\n    bool destroyed;\n    bool entered;\n} UFO;\n\ndouble distance(double x, double y) {\n    return sqrt(x * x + y * y);\n}\n\ndouble distancePointToLine(double px, double py, double lx, double ly) {\n    if (lx == 0 && ly == 0) return INF;\n    double dot = px * lx + py * ly;\n    if (dot < 0) return INF;\n    double len = sqrt(lx * lx + ly * ly);\n    return fabs(px * ly - py * lx) / len;\n}\n\nint main() {\n    int R, N;\n    \n    while (scanf(\"%d %d\", &R, &N) == 2) {\n        if (R == 0 && N == 0) break;\n        \n        UFO ufos[MAX_N];\n        for (int i = 0; i < N; i++) {\n            scanf(\"%lf %lf %lf %lf\", &ufos[i].x, &ufos[i].y, &ufos[i].r, &ufos[i].v);\n            ufos[i].destroyed = false;\n            ufos[i].entered = false;\n        }\n        \n        int time = 1;\n        while (true) {\n            bool any_outside = false;\n            for (int i = 0; i < N; i++) {\n                if (ufos[i].destroyed || ufos[i].entered) continue;\n                \n                double dx = -ufos[i].x;\n                double dy = -ufos[i].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double curr_x = ufos[i].x + dx * ufos[i].v * time;\n                double curr_y = ufos[i].y + dy * ufos[i].v * time;\n                double dist = distance(curr_x, curr_y);\n                \n                if (dist > R) {\n                    any_outside = true;\n                    break;\n                }\n            }\n            \n            if (!any_outside) break;\n            \n            int target = -1;\n            double min_dist = INF;\n            \n            for (int i = 0; i < N; i++) {\n                if (ufos[i].destroyed || ufos[i].entered) continue;\n                \n                double dx = -ufos[i].x;\n                double dy = -ufos[i].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double curr_x = ufos[i].x + dx * ufos[i].v * time;\n                double curr_y = ufos[i].y + dy * ufos[i].v * time;\n                double dist = distance(curr_x, curr_y);\n                \n                if (dist > R && dist < min_dist) {\n                    min_dist = dist;\n                    target = i;\n                }\n            }\n            \n            if (target != -1) {\n                double dx = -ufos[target].x;\n                double dy = -ufos[target].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double target_x = ufos[target].x + dx * ufos[target].v * time;\n                double target_y = ufos[target].y + dy * ufos[target].v * time;\n                \n                for (int i = 0; i < N; i++) {\n                    if (ufos[i].destroyed || ufos[i].entered) continue;\n                    \n                    double dx2 = -ufos[i].x;\n                    double dy2 = -ufos[i].y;\n                    double len2 = sqrt(dx2 * dx2 + dy2 * dy2);\n                    dx2 /= len2;\n                    dy2 /= len2;\n                    \n                    double curr_x = ufos[i].x + dx2 * ufos[i].v * time;\n                    double curr_y = ufos[i].y + dy2 * ufos[i].v * time;\n                    \n                    double dist_to_laser = distancePointToLine(curr_x, curr_y, target_x, target_y);\n                    \n                    if (dist_to_laser <= ufos[i].r) {\n                        ufos[i].destroyed = true;\n                    }\n                }\n            }\n            \n            for (int i = 0; i < N; i++) {\n                if (ufos[i].destroyed || ufos[i].entered) continue;\n                \n                double dx = -ufos[i].x;\n                double dy = -ufos[i].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double curr_x = ufos[i].x + dx * ufos[i].v * time;\n                double curr_y = ufos[i].y + dy * ufos[i].v * time;\n                double dist = distance(curr_x, curr_y);\n                \n                if (dist <= R) {\n                    ufos[i].entered = true;\n                }\n            }\n            \n            time++;\n        }\n        \n        int count = 0;\n        for (int i = 0; i < N; i++) {\n            if (ufos[i].entered) count++;\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #include <stdbool.h> #define MAX_N 100  r; double v; bool destroyed; bool entered; } UFO; double distance(double x,  y); } double distancePointToLine(double px, double py, double lx, double ly) { if (lx == 0 && ly == 0) return INF; double dot = px * lx + py * ly; if (dot   R, N; while  0 && N == 0) break; UFO ufos[MAX_N]; for (int i = 0; i < N; i++) { scanf(\"%lf %lf %lf %lf\", &ufos[i].x, &ufos[i].y, &ufos[i].r, &ufos[i].v); ufos[i].destroyed = false; ufos[i].entered = false;  = false; for (int i = 0; i < N; i++) { if (ufos[i].destroyed || ufos[i].entered) continue; double dx = -ufos[i].x; double dy =   ufos[i].x + dx * ufos[i].v * time; double curr_y = ufos[i].y  curr_y); if (dist  (!any_outside) break; int target = -1; double min_dist = INF; for (int i = 0; i < N; i++) { if  = -ufos[i].y; double len = sqrt(dx * dx + dy * dy); dx /= len; dy /= len; double curr_x = ufos[i].x + dx * ufos[i].v  * time; double dist  min_dist) { min_dist = dist;  len = sqrt(dx * dx  time; double target_y = ufos[target].y + dy  double dx2 = -ufos[i].x;  + dy2 * dy2); dx2 /= len2; dy2 /= len2; double curr_x = ufos[i].x + dx2 * ufos[i].v * time; double curr_y = ufos[i].y + dy2 * ufos[i].v * time;  ufos[i].r) { ufos[i].destroyed = true; } } } for (int i  ufos[i].entered) continue; double dx = -ufos[i].x; double dy  double curr_y = ufos[i].y + dy * ufos[i].v * time; double dist = distance(curr_x, curr_y); if (dist <= R) { ufos[i].entered = true; } } time++; } int count = 0; for (int i = 0;  count); } return 0; }"], "perturbed_original": ["#include  x,y; double angle; int r; int v; int arrive; } ufo_t; int N; ufo_t ufo[100]; int R; double get_dist(double mx,double my,double x,double y) { return fabs(my*x-mx*y)/sqrt(my*my+mx*mx); } int main(void) {  scanf(\"%d%d\",&R,&N); if(R==0 && N==0)break; for(i=0;i<N;i++) { scanf(\"%lf%lf%d%d\", &ufo[i].x,&ufo[i].y,&ufo[i].r,&ufo[i].v); ufo[i].arrive=1; ufo[i].angle=atan2(ufo[i].y,ufo[i].x); } target=0; while(target>=0) { for(i=0;i<N;i++) { if(R+EPS<sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y)) { double prev_x,prev_y; prev_x=ufo[i].x;  { double   { if(ufo[i].arrive)count++; } printf(\"%d\\n\",count); } return 0; }"], "original_ll": -0.6870587468147278, "sampled_ll": -0.29976174235343933, "all_perturbed_sampled_ll": [-1.3170580863952637], "all_perturbed_original_ll": [-1.5006762742996216], "perturbed_sampled_ll": -1.3170580863952637, "perturbed_original_ll": -1.5006762742996216, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint r, n;\n\t\twhile ((r = s.nextInt()) != 0 && (n = s.nextInt()) != 0) {\n\t\t\tdouble[][] ufo = new double[n][6];  // x, y, r, v(, dis, fin_step)\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tufo[i][j] = s.nextInt();\n\t\t\t\tufo[i][4] = Math.hypot(ufo[i][0], ufo[i][1]); // \u008b\u0097\u0097\u00a3\n\t\t\t\tufo[i][5] = Math.floor((Math.abs(ufo[i][4]) - r) / ufo[i][3]); // \u0090N\u0093\u00fc\u008e\u009e\u008a\u00d4\n\t\t\t}\n\n\t\t\tint[] st = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\tst[i] = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) { // step\t\t\t\t\n\t\t\t\t // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\u0082\u00f0\u0092T\u0082\u00b5\u0081A\u0093\u00af\u008e\u009e\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00b5\u0082\u00bdUFO\u0082\u00c9\u0083}\u0081[\u0083N\n\t\t\t\tint near = -1;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fcor\u008c\u0082\u0092\u00c4\n\t\t\t\t\tif (ufo[j][5] < i) st[j] = 1;  // \u0090N\u0093\u00fc\u0082\u00b5\u0082\u00bd\n\t\t\t\t\telse if (near == -1 || ufo[near][4] > ufo[j][4])\n\t\t\t\t\t\tnear = j; // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\n\t\t\t\t}\n\t\t\t\tif (near == -1) break;\n\t\t\t\tdouble x0 = ufo[near][0]; // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\n\t\t\t\tdouble y0 = ufo[near][1];\n\n\t\t\t\t// UFO\u0082\u00f0\u008c\u0082\u0092\u00c4\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00a9\u008c\u0082\u0092\u00c4\u008f\u00f3\u0091\u00d4\u0082\u00c8\u0082\u00e7\u0083X\u0083\u008b\u0081[\n\t\t\t\t\tdouble x1 = ufo[j][0];\n\t\t\t\t\tdouble y1 = ufo[j][1];\n\t\t\t\t\t\n\t\t\t\t\tif (y0 == 0) {\n\t\t\t\t\t\tif ((x0 >= 0 && x1 >= 0) || (x0 < 0 && x1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab\n\t\t\t\t\t\t\tif (Math.abs(y1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4\n\t\t\t\t\t} else if (x0 == 0) {\n\t\t\t\t\t\tif ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab\n\t\t\t\t\t\t\tif (Math.abs(x1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdouble a = y0 / x0; // \u008cX\u0082\u00ab\n\t\t\t\t\t\tif ((x0 >= 0 && x1 >= 0) || (x0 < 0 && x1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab\n\t\t\t\t\t\t\tif ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 < 0))\n\t\t\t\t\t\t\t\tif (Math.abs(y1 - a * x1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < n; j++) { // UFO\u0088\u00da\u0093\u00ae\n\t\t\t\t\tif (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00a9\u008c\u0082\u0092\u00c4\u008f\u00f3\u0091\u00d4\u0082\u00c8\u0082\u00e7\u0083X\u0083\u008b\u0081[\n\t\t\t\t\tufo[j][4] -= ufo[j][3];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (st[j] == 1) sum++;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class UFO {\n        double x, y;\n        double r;\n        double v;\n        boolean destroyed;\n        int id;\n        \n        UFO(double x, double y, double r, double v, int id) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n            this.v = v;\n            this.destroyed = false;\n            this.id = id;\n        }\n        \n        double distanceFromOrigin() {\n            return Math.sqrt(x * x + y * y);\n        }\n        \n        void moveTowardsOrigin(double time) {\n            if (destroyed) return;\n            double dist = distanceFromOrigin();\n            if (dist == 0) return;\n            double moveAmount = v * time;\n            if (moveAmount >= dist) {\n                x = 0;\n                y = 0;\n            } else {\n                double ratio = moveAmount / dist;\n                x -= x * ratio;\n                y -= y * ratio;\n            }\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            int R = Integer.parseInt(parts[0]);\n            int N = Integer.parseInt(parts[1]);\n            \n            if (R == 0 && N == 0) break;\n            \n            List<UFO> ufos = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                line = br.readLine();\n                parts = line.trim().split(\"\\\\s+\");\n                double x0 = Double.parseDouble(parts[0]);\n                double y0 = Double.parseDouble(parts[1]);\n                double r = Double.parseDouble(parts[2]);\n                double v = Double.parseDouble(parts[3]);\n                ufos.add(new UFO(x0, y0, r, v, i));\n            }\n            \n            int time = 1;\n            while (true) {\n                // Move all UFOs\n                for (UFO ufo : ufos) {\n                    ufo.moveTowardsOrigin(1);\n                }\n                \n                // Find closest UFO outside R\n                UFO target = null;\n                double minDist = Double.MAX_VALUE;\n                \n                for (UFO ufo : ufos) {\n                    if (!ufo.destroyed && ufo.distanceFromOrigin() > R) {\n                        double dist = ufo.distanceFromOrigin();\n                        if (dist < minDist) {\n                            minDist = dist;\n                            target = ufo;\n                        }\n                    }\n                }\n                \n                if (target == null) break;\n                \n                // Shoot laser through target\n                double tx = target.x;\n                double ty = target.y;\n                \n                for (UFO ufo : ufos) {\n                    if (!ufo.destroyed && ufo.distanceFromOrigin() > R) {\n                        if (laserHits(tx, ty, ufo)) {\n                            ufo.destroyed = true;\n                        }\n                    }\n                }\n                \n                time++;\n                if (time > 10000) break;\n            }\n            \n            int count = 0;\n            for (UFO ufo : ufos) {\n                if (!ufo.destroyed) {\n                    count++;\n                }\n            }\n            \n            System.out.println(count);\n        }\n    }\n    \n    static boolean laserHits(double lx, double ly, UFO ufo) {\n        // Laser goes from origin through (lx, ly)\n        // Check if it intersects circle at (ufo.x, ufo.y) with radius ufo.r\n        \n        double laserLen = Math.sqrt(lx * lx + ly * ly);\n        if (laserLen == 0) return false;\n        \n        // Normalize laser direction\n        double ldx = lx / laserLen;\n        double ldy = ly / laserLen;\n        \n        // Distance from ufo center to laser line\n        double dist = Math.abs(ldy * ufo.x - ldx * ufo.y);\n        \n        if (dist > ufo.r) return false;\n        \n        // Check if UFO is in the direction of the laser\n        double dot = ufo.x * ldx + ufo.y * ldy;\n        return dot > 0;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class  destroyed; int id; UFO(double x, double y, double r, double v, int id) { this.x = x; this.y = y; this.r = r; this.v = v; this.destroyed = false; this.id = id; } double distanceFromOrigin() {  moveTowardsOrigin(double time) { if (destroyed) return; double dist = distanceFromOrigin();  y = 0; } else { double ratio = moveAmount / dist; x -= x * ratio; y  BufferedReader(new InputStreamReader(System.in)); String line; while ((line  R = Integer.parseInt(parts[0]); int N = Integer.parseInt(parts[1]); if  = new ArrayList<>(); for (int i =  = line.trim().split(\"\\\\s+\");  = Double.parseDouble(parts[2]); double v = Double.parseDouble(parts[3]); ufos.add(new UFO(x0, y0, r, v, i)); } int time = 1; while (true) { // Move all UFOs for (UFO ufo : ufos) { ufo.moveTowardsOrigin(1); } // Find closest UFO outside R UFO target  double dist = ufo.distanceFromOrigin();  ufo; } } } if (target == null) break; // Shoot laser through target double tx = target.x; double ty = target.y; for (UFO ufo : ufos) { if (!ufo.destroyed && ufo.distanceFromOrigin() > R) { if (laserHits(tx, ty, ufo))   } System.out.println(count); } } static boolean laserHits(double lx, double ly, UFO ufo) { //  laser  ly / laserLen; // Distance from ufo center to laser line double dist = Math.abs(ldy * ufo.x - ldx  if UFO is in the direction of the laser double dot = ufo.x * ldx + ufo.y * ldy; return dot > 0; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner s = new Scanner(System.in); int r, n; while ((r = s.nextInt()) != 0 && (n = s.nextInt()) != 0) { double[][] ufo = new double[n][6]; // x, y, r, v(,  i++) { for (int j = 0; j < 4; j++)  = Math.floor((Math.abs(ufo[i][4])  new int[n]; for (int i = 0;  = 0; i < n; i++) {  j = 0; j < n; j++) { if (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fcor\u008c\u0082\u0092\u00c4 if (ufo[j][5] < i) st[j]  ufo[near][4]  == -1) break; double x0 = ufo[near][0]; // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO double y0 = ufo[near][1]; // UFO\u0082\u00f0\u008c\u0082\u0092\u00c4 for (int  double y1 = ufo[j][1]; if (y0  0) || (x0  <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4 } else if (x0 == 0) { if ((y0 >= 0 && y1 >= 0) ||  (Math.abs(x1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4  \u008cX\u0082\u00ab if ((x0 >= 0 && x1 >= 0) ||  ((y0 >= 0 && y1 >= 0)  - a * x1) <= r)  = 0; j < n; j++) { // UFO\u0088\u00da\u0093\u00ae if (st[j]  j < n; j++) if (st[j] == 1) sum++; System.out.println(sum); } } }"], "original_ll": -0.8751683831214905, "sampled_ll": -0.5033857226371765, "all_perturbed_sampled_ll": [-1.8151735067367554], "all_perturbed_original_ll": [-1.9197518825531006], "perturbed_sampled_ll": -1.8151735067367554, "perturbed_original_ll": -1.9197518825531006, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from math import sqrt\nwhile 1:\n    R, N = map(int, raw_input().split())\n    if R == N == 0:\n        break\n    P = []\n    for i in xrange(N):\n        x, y, r, v = map(int, raw_input().split())\n        P.append((sqrt(x**2+y**2), x**2+y**2, x, y, r, v, i))\n    kill = [0]*N\n    ans = 0\n    for t in xrange(1, N+1):\n        j = None; mi = 10**9\n        for l, ll, x, y, r, v, i in P:\n            if kill[i]:\n                continue\n            if ll < (R + t*v)**2:\n                kill[i] = 1\n                ans += 1\n\n            if not kill[i] and l - t*v < mi:\n                mi = l - t*v\n                j = i\n        if j is None:\n            break\n        l0, ll0, x0, y0, r0, v0, j = P[j]\n        for l, ll, x, y, r, v, i in P:\n            if kill[i]:\n                continue\n            if (l - t*v)*abs(x0*y - x*y0) < r*l*l0 + 1e-8:\n                kill[i] = 1\n    print ans", "sampled": "import math\n\ndef distance(x, y):\n    return math.sqrt(x*x + y*y)\n\ndef line_circle_intersection(x0, y0, r, px, py):\n    # Check if line from origin through (px, py) intersects circle at (x0, y0) with radius r\n    # Line can be parameterized as (t*px, t*py) for t >= 0\n    # Circle: (x-x0)^2 + (y-y0)^2 = r^2\n    # Substitute: (t*px - x0)^2 + (t*py - y0)^2 = r^2\n    \n    if px == 0 and py == 0:\n        return distance(x0, y0) <= r\n    \n    # Line direction vector (px, py)\n    # Distance from point (x0, y0) to line through origin with direction (px, py)\n    # d = |x0*py - y0*px| / sqrt(px^2 + py^2)\n    \n    d = abs(x0 * py - y0 * px) / math.sqrt(px*px + py*py)\n    \n    return d <= r\n\nwhile True:\n    line = input().split()\n    R = int(line[0])\n    N = int(line[1])\n    \n    if R == 0 and N == 0:\n        break\n    \n    ufos = []\n    for i in range(N):\n        parts = list(map(int, input().split()))\n        x0, y0, r, v = parts[0], parts[1], parts[2], parts[3]\n        ufos.append([x0, y0, r, v, True])  # True means not destroyed\n    \n    time = 1\n    invaded = 0\n    \n    while True:\n        # Move all UFOs\n        for i in range(N):\n            if ufos[i][4]:  # If not destroyed\n                x0, y0, r, v = ufos[i][0], ufos[i][1], ufos[i][2], ufos[i][3]\n                dist = distance(x0, y0)\n                if dist > 0:\n                    # Move towards origin\n                    dx = -x0 / dist\n                    dy = -y0 / dist\n                    ufos[i][0] += dx * v * time\n                    ufos[i][1] += dy * v * time\n        \n        # Check for invaded UFOs\n        for i in range(N):\n            if ufos[i][4]:\n                dist = distance(ufos[i][0], ufos[i][1])\n                if dist <= R:\n                    invaded += 1\n                    ufos[i][4] = False\n        \n        # Find closest UFO outside R\n        min_dist = float('inf')\n        target_idx = -1\n        for i in range(N):\n            if ufos[i][4]:\n                dist = distance(ufos[i][0], ufos[i][1])\n                if dist > R and dist < min_dist:\n                    min_dist = dist\n                    target_idx = i\n        \n        if target_idx == -1:\n            break\n        \n        # Fire laser at target\n        tx, ty = ufos[target_idx][0], ufos[target_idx][1]\n        \n        # Destroy all UFOs that intersect with this laser line\n        for i in range(N):\n            if ufos[i][4]:\n                dist = distance(ufos[i][0], ufos[i][1])\n                if dist > R:\n                    if line_circle_intersection(ufos[i][0], ufos[i][1], ufos[i][2], tx, ty):\n                        ufos[i][4] = False\n        \n        time = 1\n    \n    print(invaded)\n", "perturbed_sampled": ["import math def distance(x, y): return math.sqrt(x*x + y*y) def line_circle_intersection(x0, y0, r, px, py): # Check if line from origin through (px,  Line  # Circle: (x-x0)^2 + (y-y0)^2 = r^2  r^2 if px == 0 and py == 0: return distance(x0, y0) <= r # Line direction  line through origin with direction (px, py) # d = |x0*py -  - y0 * px) / math.sqrt(px*px + py*py)  = int(line[0]) N = int(line[1]) if R == 0 and  range(N): parts = list(map(int, input().split())) x0, y0, r, v = parts[0], parts[1], parts[2], parts[3] ufos.append([x0, y0,  1 invaded = 0 while True: #   0: # Move towards origin dx  += dx * v * time ufos[i][1]  UFOs for i  <= R: invaded += 1 ufos[i][4] = False # Find closest UFO outside R min_dist = float('inf') target_idx = -1 for i in range(N): if ufos[i][4]: dist = distance(ufos[i][0], ufos[i][1]) if  Fire laser at target tx, ty = ufos[target_idx][0], ufos[target_idx][1] # Destroy all UFOs that intersect with this laser line for i in range(N): if ufos[i][4]: dist = distance(ufos[i][0], ufos[i][1]) if dist >  time = 1 print(invaded)"], "perturbed_original": [" = [] for i in xrange(N):  y, r, v, i)) kill = [0]*N ans = 0 for t in xrange(1, N+1): j = None; mi = 10**9  if kill[i]: continue if ll < (R + t*v)**2: kill[i] = 1  < mi: mi =  break l0, ll0, x0, y0, r0, v0, j = P[j] for  kill[i]: continue if (l - t*v)*abs(x0*y - x*y0) < r*l*l0 + 1e-8: kill[i] = 1 print ans"], "original_ll": -1.0629624128341675, "sampled_ll": -0.6735007762908936, "all_perturbed_sampled_ll": [-2.065479278564453], "all_perturbed_original_ll": [-2.76149582862854], "perturbed_sampled_ll": -2.065479278564453, "perturbed_original_ll": -2.76149582862854, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n        int point[10][10]={0};\n        int person=0,endFlag=0,result=0,count,repeat,versusCount,myGTP,theyGTP;\n        printf(\"\u5165\u529b\\n\");\n        for(count=0; endFlag==0; count++){\n                for(person=0; person<5 && endFlag==0; person++){\n                        scanf(\"%d\",&point[count][person]);\n                        if(point[count][person]<0||point[count][person]>3){\n                        printf(\"\u30a8\u30e9\u30fc\u3001\u7d42\u4e86\u3057\u307e\u3059\u3002\");\n                        exit(1);\n                                }\n                        if(point[count][person]==0){\n                                endFlag=1;\n                                }\n                        }\n                }\n        repeat=count;\n        printf(\"\\n\u51fa\u529b\\n\");\n        for(count=0; count<repeat; count++){\n                for(person=0; point[count][person]!=0; person++){\n                        for(versusCount=0; point[count][versusCount]!=0; versusCount++){\n                        myGTP=point[count][person];\n                        theyGTP=point[count][versusCount];\n                        if(person!=versusCount){\n                        if(((myGTP+1==theyGTP)||(myGTP-2==theyGTP))&&(result!=1)&&(result!=3)){\n                                result+=1;\n                                }\n                        if(((myGTP+2==theyGTP)||(myGTP-1==theyGTP))&&(result!=2)&&(result!=3)){\n                                result+=2;\n                                }\n                        }\n                        }\n                if(result==0){\n                        result=3;\n                        }\n                                printf(\"\\n%d\",result);\n                                result=0;\n                                }\n                        }\n        return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int h[5];\n    \n    while(1) {\n        scanf(\"%d\", &h[0]);\n        if(h[0] == 0) break;\n        \n        for(int i = 1; i < 5; i++) {\n            scanf(\"%d\", &h[i]);\n        }\n        \n        int count[4] = {0};\n        for(int i = 0; i < 5; i++) {\n            count[h[i]]++;\n        }\n        \n        int types = 0;\n        for(int i = 1; i <= 3; i++) {\n            if(count[i] > 0) types++;\n        }\n        \n        if(types == 1 || types == 3) {\n            for(int i = 0; i < 5; i++) {\n                printf(\"3\\n\");\n            }\n        } else {\n            int winning_hand;\n            if(count[1] > 0 && count[2] > 0) {\n                winning_hand = 1;\n            } else if(count[2] > 0 && count[3] > 0) {\n                winning_hand = 2;\n            } else {\n                winning_hand = 3;\n            }\n            \n            for(int i = 0; i < 5; i++) {\n                if(h[i] == winning_hand) {\n                    printf(\"1\\n\");\n                } else {\n                    printf(\"2\\n\");\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  == 0) break; for(int i = 1; i < 5; i++) { scanf(\"%d\",  i < 5; i++) { count[h[i]]++; } int types = 0; for(int i = 1; i <= 3; i++) { if(count[i] > 0) types++; } if(types == 1 || types == 3) { for(int i = 0; i   =  3; } for(int i = 0; i < 5; i++)  } } } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int point[10][10]={0}; int person=0,endFlag=0,result=0,count,repeat,versusCount,myGTP,theyGTP; printf(\"\u5165\u529b\\n\"); for(count=0; endFlag==0; count++){ for(person=0; person<5 && endFlag==0; person++){ scanf(\"%d\",&point[count][person]); if(point[count][person]<0||point[count][person]>3){ printf(\"\u30a8\u30e9\u30fc\u3001\u7d42\u4e86\u3057\u307e\u3059\u3002\"); exit(1); } if(point[count][person]==0){  point[count][person]!=0; person++){ for(versusCount=0; point[count][versusCount]!=0; versusCount++){ myGTP=point[count][person]; theyGTP=point[count][versusCount]; if(person!=versusCount){ if(((myGTP+1==theyGTP)||(myGTP-2==theyGTP))&&(result!=1)&&(result!=3)){ result+=1; } if(((myGTP+2==theyGTP)||(myGTP-1==theyGTP))&&(result!=2)&&(result!=3)){ result+=2; }  0; }"], "original_ll": -1.1242338418960571, "sampled_ll": -0.48143863677978516, "all_perturbed_sampled_ll": [-1.7043225765228271], "all_perturbed_original_ll": [-1.4701467752456665], "perturbed_sampled_ll": -1.7043225765228271, "perturbed_original_ll": -1.4701467752456665, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "//Volume2-0205\nimport java.util.Scanner;\n\nclass Main {\n\n\tprivate static int[] cnt,\n             \t\t     player,\n\t\t                 result;\n\n\tpublic static void main(String[] args){\n\t\tint   victory,loss;\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tcnt    = new int[4];\n\t\t\tplayer = new int[5];\n\t\t\tresult = new int[5];\n\t\t\tplayer[0] = sc.nextInt();\n\t\t\tif(player[0] == 0){break;}\n\t\t\tcnt[player[0]]++;\n\t\t\tfor(int i=1;i<5;i++){\n\t\t\t\tplayer[i] = sc.nextInt();\n\t\t\t\tcnt[player[i]]++;\n\t\t\t}\n\t\t\tscape : {\n\t\t\t\tif(cnt[1] == 5 || cnt[2] == 5 || cnt[3] == 5 ||\n\t\t\t\t  (cnt[1] != 0 && cnt[2] != 0 && cnt[3] != 0    )){\n\t\t\t\t\tfor(int j=0;j<5;j++){result[j] = 3;}\n\t\t\t\t\tbreak scape;\n\t\t\t\t}\n\t\t\t\tvictory = 0; loss = 0;\n\t\t\t\tif       (cnt[1] != 0 && cnt[2] != 0){\n\t\t\t\t\tvictory = 1;\n\t\t\t\t\tloss    = 2;\n\t\t\t\t} else if(cnt[2] != 0 && cnt[3] != 0){\n\t\t\t\t\tvictory = 2;\n\t\t\t\t\tloss    = 3;\n\t\t\t\t} else if(cnt[1] != 0 && cnt[3] != 0){\n\t\t\t\t\tvictory = 3;\n\t\t\t\t\tloss    = 1;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\tif        (player[j] == victory){\n\t\t\t\t\t\tresult[j] = 1;\n\t\t\t\t\t} else if (player[j] == loss){\n\t\t\t\t\t\tresult[j] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i:result){System.out.println(i);}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int h1 = sc.nextInt();\n            if (h1 == 0) break;\n            \n            int h2 = sc.nextInt();\n            int h3 = sc.nextInt();\n            int h4 = sc.nextInt();\n            int h5 = sc.nextInt();\n            \n            int[] hands = {h1, h2, h3, h4, h5};\n            \n            boolean hasRock = false;\n            boolean hasScissors = false;\n            boolean hasPaper = false;\n            \n            for (int hand : hands) {\n                if (hand == 1) hasRock = true;\n                else if (hand == 2) hasScissors = true;\n                else if (hand == 3) hasPaper = true;\n            }\n            \n            int distinctCount = 0;\n            if (hasRock) distinctCount++;\n            if (hasScissors) distinctCount++;\n            if (hasPaper) distinctCount++;\n            \n            if (distinctCount == 1 || distinctCount == 3) {\n                for (int i = 0; i < 5; i++) {\n                    System.out.println(3);\n                }\n            } else {\n                int winningHand;\n                if (hasRock && hasScissors) {\n                    winningHand = 1;\n                } else if (hasScissors && hasPaper) {\n                    winningHand = 2;\n                } else {\n                    winningHand = 3;\n                }\n                \n                for (int hand : hands) {\n                    if (hand == winningHand) {\n                        System.out.println(1);\n                    } else {\n                        System.out.println(2);\n                    }\n                }\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int h1 = sc.nextInt(); if  = sc.nextInt(); int h4 = sc.nextInt(); int h5 = sc.nextInt(); int[] hands = {h1,   hands) { if (hand == 1) hasRock = true;  (hand == 3) hasPaper = true; } int distinctCount = 0; if (hasRock) distinctCount++; if (hasScissors) distinctCount++; if (hasPaper) distinctCount++;  System.out.println(3); } } else { int winningHand; if (hasRock && hasScissors) { winningHand  = 2; } else {  if (hand  } } sc.close(); } }"], "perturbed_original": ["//Volume2-0205  result; public static void main(String[] args){ int victory,loss; Scanner sc = new Scanner(System.in);  cnt[player[0]]++; for(int i=1;i<5;i++){ player[i]  || cnt[2] == 5 || cnt[3] == 5 || (cnt[1] != 0 && cnt[2] != 0 && cnt[3] != 0 )){ for(int j=0;j<5;j++){result[j]  != 0 && cnt[3] != 0){ victory = 2; loss = 3; } else if(cnt[1] != 0 && cnt[3] != 0){ victory = 3; loss = 1; } for(int j=0;j<5;j++){ if (player[j] == victory){ result[j] =  } } } for(int i:result){System.out.println(i);} } } }"], "original_ll": -0.8920938968658447, "sampled_ll": -0.40067756175994873, "all_perturbed_sampled_ll": [-1.712257742881775], "all_perturbed_original_ll": [-1.8444626331329346], "perturbed_sampled_ll": -1.712257742881775, "perturbed_original_ll": -1.8444626331329346, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#5\u500b\u306e\u3046\u30611\u756a\u76ee\u306e\u5165\u529b\u304c0\u306a\u3089\u51e6\u7406\u3092\u7d42\u308f\u308b\u3002\nwhile True:\n    line = []\n    line.append(int(input()))\n    if line[0] == 0:break\n\n    #\u6a19\u6e96\u5165\u529b\u3092\u3057\u30ea\u30b9\u30c8\u3092\u30bb\u30c3\u30c8\u306b\u3057\u305f\u3082\u306e\u3092\u4f5c\u308b\u3002\n    for _ in range(4):line.append(int(input()))\n    se = set(line)\n    \n    #\u5168\u54e1\u304c\u540c\u3058\u6570\u3092\u51fa\u3059\u304b3\u7a2e\u985e\u306e\u624b\u304c\u51fa\u305f\u30895\u3053\"3\"\u3092\u51fa\u529b\u3059\u308b\u3002\n    if len(se) == 1 or len(se) == 3:\n        for _ in range(5):print(\"3\")\n        \"\"\n    #\u3058\u3083\u3093\u3051\u3093\u306e\u52dd\u6557\u306b\u57fa\u3065\u304d\u52dd\u3061\u3060\u3063\u305f\u3089\"1\"\u8ca0\u3051\u3060\u3063\u305f\u3089\"2\"\u3092\u51fa\u529b\u3059\u308b\n    else:\n        if sum(se) == 3:\n            for i in line:\n                if i == 1:print(\"1\")\n                else:print(\"2\")\n        if sum(se) == 4:\n            for i in line:\n                if i == 3:print(\"1\")\n                else:print(\"2\")\n        if sum(se) == 5:\n            for i in line:\n                if i == 2:print(\"1\")\n                else:print(\"2\")\n", "sampled": "while True:\n    h1 = int(input())\n    if h1 == 0:\n        break\n    \n    hands = [h1]\n    for _ in range(4):\n        hands.append(int(input()))\n    \n    unique_hands = set(hands)\n    \n    # Check if it's a draw (all same or all three types)\n    if len(unique_hands) == 1 or len(unique_hands) == 3:\n        for _ in range(5):\n            print(3)\n    else:\n        # Two types of hands - determine winner\n        hand_list = list(unique_hands)\n        h_a, h_b = hand_list[0], hand_list[1]\n        \n        # Determine which hand wins\n        # 1 (rock) beats 2 (scissors)\n        # 2 (scissors) beats 3 (paper)\n        # 3 (paper) beats 1 (rock)\n        if (h_a == 1 and h_b == 2) or (h_a == 2 and h_b == 1):\n            winning_hand = 1\n        elif (h_a == 2 and h_b == 3) or (h_a == 3 and h_b == 2):\n            winning_hand = 2\n        else:  # (h_a == 3 and h_b == 1) or (h_a == 1 and h_b == 3)\n            winning_hand = 3\n        \n        for hand in hands:\n            if hand == winning_hand:\n                print(1)\n            else:\n                print(2)\n", "perturbed_sampled": ["while True: h1 = int(input()) if h1 == 0:  = set(hands) # Check if  len(unique_hands) == 1 or len(unique_hands) == 3: for  - determine winner hand_list = list(unique_hands) h_a, h_b = hand_list[0], hand_list[1] #  # 2 (scissors) beats 3 (paper) # 3 (paper) beats 1 (rock) if  (h_a == 2 and h_b  winning_hand = 2 else: # (h_a == 3 and h_b == 1) or (h_a == 1 and h_b == 3) winning_hand = 3 for hand in hands: if hand == winning_hand: print(1) else: print(2)"], "perturbed_original": ["#5\u500b\u306e\u3046\u30611\u756a\u76ee\u306e\u5165\u529b\u304c0\u306a\u3089\u51e6\u7406\u3092\u7d42\u308f\u308b\u3002 while True: line = [] line.append(int(input())) if line[0] == 0:break #\u6a19\u6e96\u5165\u529b\u3092\u3057\u30ea\u30b9\u30c8\u3092\u30bb\u30c3\u30c8\u306b\u3057\u305f\u3082\u306e\u3092\u4f5c\u308b\u3002  == 1 or len(se) == 3: for _ in range(5):print(\"3\") \"\" #\u3058\u3083\u3093\u3051\u3093\u306e\u52dd\u6557\u306b\u57fa\u3065\u304d\u52dd\u3061\u3060\u3063\u305f\u3089\"1\"\u8ca0\u3051\u3060\u3063\u305f\u3089\"2\"\u3092\u51fa\u529b\u3059\u308b else: if sum(se) == 3: for i in line: if i == 1:print(\"1\") else:print(\"2\") if sum(se)  if i == 2:print(\"1\") else:print(\"2\")"], "original_ll": -1.4847517013549805, "sampled_ll": -0.7928951978683472, "all_perturbed_sampled_ll": [-1.8396236896514893], "all_perturbed_original_ll": [-2.5380144119262695], "perturbed_sampled_ll": -1.8396236896514893, "perturbed_original_ll": -2.5380144119262695, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n\tint i=0,l,n,m,a[12],b;\n\twhile(1){\n\t\tb=0;\n\t\tscanf(\"%d\",&l);\n\t\tif(l==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i=0;i<12;i++){\n\t\t\tscanf(\"%d%d\",&m,&n);\n\t\t\ta[i]=m-n;\n\t\t}\n\t\tfor(i=0;i<12;i++){\n\t\t\tb=b+a[i];\n\t\t\tif(b>=l){\n\t\t\t\tprintf(\"%d\\n\",i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(b<l){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int L;\n    \n    while (scanf(\"%d\", &L) == 1 && L != 0) {\n        int savings = 0;\n        int month = 0;\n        int found = 0;\n        \n        for (int i = 1; i <= 12; i++) {\n            int M, N;\n            scanf(\"%d %d\", &M, &N);\n            \n            if (!found) {\n                savings += (M - N);\n                if (savings >= L) {\n                    month = i;\n                    found = 1;\n                }\n            }\n        }\n        \n        if (found) {\n            printf(\"%d\\n\", month);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int L; while (scanf(\"%d\", &L) ==  int month = 0;  &M, &N);  >= L) { month = i; found = 1; } } } if (found) { printf(\"%d\\n\", month); } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int i=0,l,n,m,a[12],b; while(1){ b=0; scanf(\"%d\",&l); if(l==0){ break;  } } if(b<l){ printf(\"NA\\n\"); } } }"], "original_ll": -0.9349135160446167, "sampled_ll": -0.7023061513900757, "all_perturbed_sampled_ll": [-2.1445977687835693], "all_perturbed_original_ll": [-2.4639875888824463], "perturbed_sampled_ll": -2.1445977687835693, "perturbed_original_ll": -2.4639875888824463, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main{\n\tstatic Scanner sc;\n\tstatic int L,M,N,T,mth;\n\t\n\tpublic static void main(String[]args){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tL=sc.nextInt();\n\t\t\tmth=0;\n\t\t\tT=0;M=0;N=0;\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tM=sc.nextInt();\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tT=T+M-N;\n\t\t\t\tif(T>=L && mth==0){\n\t\t\t\t\tmth=i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mth==0){System.out.println(\"NA\");}\n\t\t\telse{System.out.println(mth);}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int L = sc.nextInt();\n            if (L == 0) break;\n            \n            int savings = 0;\n            int month = 0;\n            boolean found = false;\n            \n            for (int i = 1; i <= 12; i++) {\n                int M = sc.nextInt();\n                int N = sc.nextInt();\n                savings += (M - N);\n                \n                if (!found && savings >= L) {\n                    month = i;\n                    found = true;\n                }\n            }\n            \n            if (found) {\n                System.out.println(month);\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int L =  int month = 0; boolean found = false; for (int i = 1; i <= 12; i++) { int M = sc.nextInt(); int N  { System.out.println(\"NA\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main{ static Scanner sc; static int L,M,N,T,mth; public static void main(String[]args){ sc=new  if(T>=L && mth==0){ mth=i+1; } } if(mth==0){System.out.println(\"NA\");} else{System.out.println(mth);} } } }"], "original_ll": -1.0667567253112793, "sampled_ll": -0.618364691734314, "all_perturbed_sampled_ll": [-1.687520980834961], "all_perturbed_original_ll": [-2.305506467819214], "perturbed_sampled_ll": -1.687520980834961, "perturbed_original_ll": -2.305506467819214, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    L = int(input())\n    if L == 0:\n        break\n    \n    flag = True\n    ans = -1\n    d = 0\n    for i in range(12):\n        M,N = [int(i) for i in input().split()]\n        d = d + M - N\n        if d >= L and flag:\n            ans = i+1\n            flag = False\n    \n    if ans >= 0:\n        print(ans)\n    else:\n        print(\"NA\")\n\n", "sampled": "while True:\n    L = int(input())\n    if L == 0:\n        break\n    \n    savings = 0\n    months = 0\n    found = False\n    \n    for month in range(1, 13):\n        M, N = map(int, input().split())\n        savings += (M - N)\n        if savings >= L and not found:\n            months = month\n            found = True\n    \n    if found:\n        print(months)\n    else:\n        print(\"NA\")\n", "perturbed_sampled": ["while True: L = int(input()) if L == 0:  for month in range(1, 13): M, N = map(int, input().split()) savings += (M - N) if  = True if found: print(months) else: print(\"NA\")"], "perturbed_original": ["while True: L = int(input())  -1 d = 0 for i in range(12): M,N = [int(i) for i in input().split()]  L and flag: ans = i+1 flag = False if ans >= 0: print(ans) else: print(\"NA\")"], "original_ll": -1.1602100133895874, "sampled_ll": -1.0161250829696655, "all_perturbed_sampled_ll": [-2.730764865875244], "all_perturbed_original_ll": [-2.4765641689300537], "perturbed_sampled_ll": -2.730764865875244, "perturbed_original_ll": -2.4765641689300537, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0207\nTitle Block\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n#include <setjmp.h>\n//Global data section\nint w,h;\nint xs,ys;\nint xg,yg;\nint n;\nint c[100];\nint d[100];\nint x[100],y[100];\nint bd[100][100];\njmp_buf env;\n\n//\nvoid init()\n{\n  int i,j;\n  for(i=0;i<h;i++)\n    for(j=0;j<w;j++)\n      bd[i][j]=0;\n  for(i=0;i<100;i++)\n    {\n      x[i]=y[i]=d[i]=c[i]=0;\n    }\n}\nint get_block(int px,int py)\n{\n  int i;\n  // printf(\"GB%d,%d\\n\",px,py);\n  for(i=0;i<n;i++)\n    if(d[i]==0)         // yokonaga\n\t{\n\t  if(px-x[i] >=0 && px-x[i] <=3 && \n\t     py-y[i] >=0 && py-y[i] <= 1)\n\t    return(i);\n\t}\n    else if(d[i]==1)         // tatenaga\n      {\n\tif(px-x[i] >=0 && px-x[i] <=1 && \n\t   py-y[i] >=0 && py-y[i] <=3)\n\t  return(i);\n      }\n  return(-1);\n}\nint show()\n{\n  int i,j;\n  for(i=1;i<=h;i++)\n    {\n      for(j=1;j<=w;j++)\n\tprintf(\"%d\",bd[i][j]);\n      printf(\"\\n\");\n    }\n  printf(\"\\n\");\n}\nvoid paint0(int px,int py,int col,int ww,int hh)\n{\n  int i,j;\n  //printf(\"P0 %d %d\\n\",px,py);\n\n    for(i=0;i<hh;i++)\n      for(j=0;j<ww;j++)\n\tbd[py+i][px+j]=col;\n}\nint paint(int px,int py,int col)\n{\n  int cc,blk,dir,bx,by,w0,h0,i,j;\n  //printf(\"xyc=%d %d %d\\n\",px,py,col);\n\n  if(px < 1 ||py < 1) //out of bound\n    return(0);\n  if(bd[py][px])  // already painted\n    return(0);\n  blk=get_block(px,py);  // get block no of this place\n  //printf(\"blk=%d\\n\",blk);\n  if(blk<0)\n    return(0);\n  cc=c[blk];\n  dir=d[blk];\n  if(cc != col)\n    return(0);             // different color\n\n  bx=x[blk];\n  by=y[blk];\n   if(dir==0)         // yokonaga\n     { w0=4;h0=2;}\n   else\n     { w0=2;h0=4;}\n\n  paint0(bx,by,col,w0,h0); // paint this block\n\n  if(xg >= bx && xg <= bx+w0 && \n     yg >= by && yg <= by+h0 )     // reach the goal\n    {\n      longjmp(env,1);\n    }\n\n   for(i=-1;i<w0+1;i++)\n     if(i==-1||i==w0)\n       for(j=0;j<h0;j++)\n\t paint(bx+i,by+j,col);\n     else\n       for(j=-1;j<h0+1;j++)\n\t paint(bx+i,by+j,col);\n\n   return(0);\n}\nmain()\n{\n  int i,bl,col,dir,ret;\n  while(EOF != scanf(\"%d %d\",&w,&h) && (w || h))\n    {\n      init();\n      scanf(\"%d %d\",&xs,&ys);\n      scanf(\"%d %d\",&xg,&yg);\n      scanf(\"%d\",&n);\n      for(i=0;i<n;i++)\n\tscanf(\"%d %d %d %d\",&(c[i]),&(d[i]),&(x[i]),&(y[i]));\n      \n      bl = get_block(xs,ys);\n      col=c[bl];\n      if(setjmp(env)==0)\n\t{\n\t  ret = paint(xs,ys,col);\n\t}\n      else\n\tret=-1;\n      \n      paint(1,1,2);\n      show();\n      printf(\"%s\\n\",ret?\"OK\":\"NG\");\n    }\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint w, h, xs, ys, xg, yg, n;\nint board[105][105];\nint visited[105][105];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint dfs(int x, int y, int color) {\n    if (x == xg && y == yg) {\n        return 1;\n    }\n    \n    visited[y][x] = 1;\n    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        \n        if (nx >= 1 && nx <= w && ny >= 1 && ny <= h) {\n            if (!visited[ny][nx] && board[ny][nx] == color) {\n                if (dfs(nx, ny, color)) {\n                    return 1;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &w, &h);\n        if (w == 0 && h == 0) break;\n        \n        scanf(\"%d %d\", &xs, &ys);\n        scanf(\"%d %d\", &xg, &yg);\n        scanf(\"%d\", &n);\n        \n        memset(board, 0, sizeof(board));\n        memset(visited, 0, sizeof(visited));\n        \n        for (int i = 0; i < n; i++) {\n            int c, d, x, y;\n            scanf(\"%d %d %d %d\", &c, &d, &x, &y);\n            \n            if (d == 0) {\n                // horizontal: 4 wide, 2 tall\n                for (int py = y; py < y + 2 && py <= h; py++) {\n                    for (int px = x; px < x + 4 && px <= w; px++) {\n                        board[py][px] = c;\n                    }\n                }\n            } else {\n                // vertical: 2 wide, 4 tall\n                for (int py = y; py < y + 4 && py <= h; py++) {\n                    for (int px = x; px < x + 2 && px <= w; px++) {\n                        board[py][px] = c;\n                    }\n                }\n            }\n        }\n        \n        int startColor = board[ys][xs];\n        \n        if (startColor == 0 || board[yg][xg] != startColor) {\n            printf(\"NG\\n\");\n        } else {\n            if (dfs(xs, ys, startColor)) {\n                printf(\"OK\\n\");\n            } else {\n                printf(\"NG\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int w, h, xs, ys, xg, yg, n; int board[105][105]; int visited[105][105]; int dx[] = {0, 0, 1, -1}; int dy[] = {1, -1, 0,  1; }  4; i++)  y + dy[i]; if  1 && ny <= h) { if (!visited[ny][nx] && board[ny][nx] == color) { if (dfs(nx, ny, color)) {  main() { while (1)  h == 0) break; scanf(\"%d %d\", &xs, &ys); scanf(\"%d %d\", &xg, &yg); scanf(\"%d\", &n); memset(board,  i < n; i++) { int c, d, x, y; scanf(\"%d %d %d %d\", &c, &d, &x, &y); if (d == 0) { // horizontal:  < y + 2 && py <= h; py++) { for  px <= w; px++) { board[py][px] = c; } } } else {  y; py < y + 4 && py <= h;  + 2 && px   board[yg][xg] != startColor) { printf(\"NG\\n\"); } else { if  } } return 0; }"], "perturbed_original": ["/* AizuOnline A0207 Title Block */ #include <stdio.h> // Select Below //#include <stdlib.h> //#include <string.h> //#include <float.h> //#include <math.h>  xs,ys; int xg,yg; int n; int  void init() { int i,j; for(i=0;i<h;i++) for(j=0;j<w;j++) bd[i][j]=0; for(i=0;i<100;i++)  i; // printf(\"GB%d,%d\\n\",px,py); for(i=0;i<n;i++)  py-y[i] >=0 && py-y[i] <=  return(i); } return(-1); } int show() { int i,j; for(i=1;i<=h;i++) { for(j=1;j<=w;j++) printf(\"%d\",bd[i][j]); printf(\"\\n\"); } printf(\"\\n\"); } void paint0(int px,int py,int col,int ww,int hh) { int i,j;  py,int col) { int  //out of bound return(0); if(bd[py][px]) // already painted return(0); blk=get_block(px,py); //  dir=d[blk]; if(cc != col) return(0); // different  w0=2;h0=4;} paint0(bx,by,col,w0,h0);  bx+w0 && yg >= by && yg <= by+h0 ) // reach the goal { longjmp(env,1); } for(i=-1;i<w0+1;i++) if(i==-1||i==w0) for(j=0;j<h0;j++) paint(bx+i,by+j,col); else for(j=-1;j<h0+1;j++) paint(bx+i,by+j,col); return(0); } main() { int i,bl,col,dir,ret; while(EOF  bl = get_block(xs,ys); col=c[bl]; if(setjmp(env)==0) { ret = paint(xs,ys,col); } else ret=-1; paint(1,1,2); show(); printf(\"%s\\n\",ret?\"OK\":\"NG\"); } return(0); }"], "original_ll": -1.0815677642822266, "sampled_ll": -0.3756895661354065, "all_perturbed_sampled_ll": [-1.7525241374969482], "all_perturbed_original_ll": [-2.013986110687256], "perturbed_sampled_ll": -1.7525241374969482, "perturbed_original_ll": -2.013986110687256, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 0, -1, 0};\n    int[] dirY = {0, 1, 0, -1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\t    makeRoute();\n\t    //show();\n\n\t    if(!route[ys][xs] || !route[yg][xg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\t    else System.out.println(search(xs, ys) ? \"OK\":\"NG\");\n\t}\n    }\n\n    /*\n      \u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2\u304c\u8fd1\u304f\u306a\u308b\u3088\u3046\u306b\u9053\u3092\u9078\u3076\n      (\u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u77ed\u7e2e\u3092\u898b\u3064\u3051\u3089\u308c\u306a\u3051\u308c\u3070)\u884c\u3051\u308b\u6240\u306b\u884c\u304f\n      \u3069\u3053\u306b\u3082\u884c\u3051\u306a\u3051\u308c\u3070\u307b\u3052\u3002\n    */\n    boolean search(int x, int y){\n\tint d = getD(x, y);\n\tboolean[] goodRoute = new boolean[4];\n\tboolean[] canRoute = new boolean[4];\n\tint gc = 0;\n\tint cc = 0;\n\tif(d==0) return true;\n\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<w && b>0 && b<h && route[b][a]){\n\t\tcanRoute[i] = true;\n\t\tcc++;\n\t\tif(getD(a, b)<d){\n\t\t    goodRoute[i] = true;\n\t\t    gc++;\n\t\t}\n\t    }\n\t}\n\t\n\tif(gc!=0){\n\t    for(int i=0; i<4; i++)\n\t\tif(goodRoute[i]) \n\t\t    if(search(x+dirX[i], y+dirY[i])) return true;\n\t}\n\telse if(cc!=0){\n\t    for(int i=0; i<4; i++)\n\t\tif(canRoute[i]) \n\t\t    if(search(x+dirX[i], y+dirY[i])) return true;\n\t}\n\t\t    \n\treturn false;\n    }\n\n    int getD(int x, int y){ return Math.abs(xg-x) + Math.abs(yg-y); }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"\u25a1\":\"\u25a0\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[h][w];\n\troute = new boolean[h][w];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[b][a] = c;    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[b][a] = c;\n\t}\n    }\n\n    void makeRoute(){\n\tint tcolor = block[ys][xs];\n\tfor(int i=0; i<w; i++)\n\t    for(int k=0; k<h; k++)\n\t\tif(block[k][i]==tcolor) route[k][i] = true;\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Block {\n        int color;\n        int dir;\n        int x;\n        int y;\n        \n        Block(int color, int dir, int x, int y) {\n            this.color = color;\n            this.dir = dir;\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            \n            if (w == 0 && h == 0) break;\n            \n            int xs = sc.nextInt();\n            int ys = sc.nextInt();\n            int xg = sc.nextInt();\n            int yg = sc.nextInt();\n            int n = sc.nextInt();\n            \n            int[][] board = new int[h + 1][w + 1];\n            \n            for (int i = 0; i < n; i++) {\n                int c = sc.nextInt();\n                int d = sc.nextInt();\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                \n                if (d == 0) { // horizontal (2 high, 4 wide)\n                    for (int dy = 0; dy < 2; dy++) {\n                        for (int dx = 0; dx < 4; dx++) {\n                            if (y + dy <= h && x + dx <= w) {\n                                board[y + dy][x + dx] = c;\n                            }\n                        }\n                    }\n                } else { // vertical (4 high, 2 wide)\n                    for (int dy = 0; dy < 4; dy++) {\n                        for (int dx = 0; dx < 2; dx++) {\n                            if (y + dy <= h && x + dx <= w) {\n                                board[y + dy][x + dx] = c;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            int startColor = board[ys][xs];\n            int goalColor = board[yg][xg];\n            \n            if (startColor == 0 || goalColor == 0 || startColor != goalColor) {\n                System.out.println(\"NG\");\n                continue;\n            }\n            \n            boolean[][] visited = new boolean[h + 1][w + 1];\n            Queue<int[]> queue = new LinkedList<>();\n            queue.offer(new int[]{xs, ys});\n            visited[ys][xs] = true;\n            \n            boolean found = false;\n            int[] dx = {0, 0, 1, -1};\n            int[] dy = {1, -1, 0, 0};\n            \n            while (!queue.isEmpty()) {\n                int[] curr = queue.poll();\n                int cx = curr[0];\n                int cy = curr[1];\n                \n                if (cx == xg && cy == yg) {\n                    found = true;\n                    break;\n                }\n                \n                for (int dir = 0; dir < 4; dir++) {\n                    int nx = cx + dx[dir];\n                    int ny = cy + dy[dir];\n                    \n                    if (nx >= 1 && nx <= w && ny >= 1 && ny <= h \n                        && !visited[ny][nx] \n                        && board[ny][nx] == startColor) {\n                        visited[ny][nx] = true;\n                        queue.offer(new int[]{nx, ny});\n                    }\n                }\n            }\n            \n            System.out.println(found ? \"OK\" : \"NG\");\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  int dir; int x; int y; Block(int color, int dir, int x, int   { int w = sc.nextInt(); int h = sc.nextInt(); if (w == 0 &&  = sc.nextInt(); int xg = sc.nextInt(); int yg = sc.nextInt(); int n = sc.nextInt(); int[][] board = new int[h + 1][w + 1]; for (int i = 0; i < n; i++) { int c = sc.nextInt(); int d = sc.nextInt(); int x = sc.nextInt(); int y = sc.nextInt();  wide) for (int dy =  0; dx <  x + dx <= w)  } } else { // vertical (4 high, 2 wide) for (int dy = 0; dy < 4; dy++) { for (int dx = 0; dx < 2; dx++) { if (y +  board[y + dy][x + dx] = c; } } } } } int startColor = board[ys][xs]; int goalColor = board[yg][xg]; if (startColor == 0 || goalColor == 0  = new  false; int[] dx = {0, 0, 1, -1}; int[] dy = {1, -1, 0, 0}; while (!queue.isEmpty()) { int[] curr  if (cx == xg && cy == yg) { found  >= 1 && nx <= w && ny >= 1 &&  System.out.println(found ? \"OK\" : \"NG\"); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ public static void main(String[] args){ new Main().run(); } Scanner sc = new Scanner(System.in); int w, h, xs, ys, xg, yg, n;   1, 0, -1}; void run(){ while(sc.hasNext()){ w = sc.nextInt()+1; h = sc.nextInt()+1; if(w==1 && h==1) break; put(); makeRoute(); //show(); if(!route[ys][xs]  x, int y){ int d = getD(x, y); boolean[] goodRoute = new boolean[4]; boolean[] canRoute = new  return true; for(int i=0; i<dirX.length; i++){ int a = x+dirX[i];  b<h && route[b][a]){ canRoute[i] = true; cc++; if(getD(a, b)<d){ goodRoute[i] = true; gc++; } } } if(gc!=0){ for(int i=0; i<4; i++) if(goodRoute[i]) if(search(x+dirX[i], y+dirY[i])) return true; } else if(cc!=0){ for(int i=0; i<4;  } void show(){ for(int i=1;  = sc.nextInt(); block = new int[h][w]; route = new boolean[h][w]; for(int i=0; i<n; i++){ c = sc.nextInt(); d = sc.nextInt(); x = sc.nextInt();  a++) for(int b=y; b<y+4; b++) block[b][a] = c; } }  for(int k=0; k<h; k++) if(block[k][i]==tcolor) route[k][i] = true; } }"], "original_ll": -0.8782771825790405, "sampled_ll": -0.3458445966243744, "all_perturbed_sampled_ll": [-1.6985368728637695], "all_perturbed_original_ll": [-1.637403964996338], "perturbed_sampled_ll": -1.6985368728637695, "perturbed_original_ll": -1.637403964996338, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "sys.setrecursionlimit(10000) \n\ndef tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal\n    [clx,cly]=cl\n    for i in range(clx-1,clx+2):\n        for j in range(cly-1,cly+2):\n            if [i,j] in nc:\n                nc.remove([i,j])\n                ok.append([i,j])\n                tansaku([i,j],nc,ok,goal)\n\n\nwhile(1):\n    [boardw,boardh]=[int(x) for x in raw_input().split()]\n    if boardw==0 and boardh==0:\n        break\n    else:\n        [startx,starty]=[int(x) for x in raw_input().split()]\n        [goalx,goaly]=[int(x) for x in raw_input().split()]\n        blockn=int(raw_input())\n        blist={1:[],2:[],3:[],4:[],5:[]}\n        startc=-1\n        goalc=-1\n        #mark location of block\n        for i in range(blockn):\n            [c,d,x,y]=[int(x) for x in raw_input().split()]\n            if d: #d=1,tatenaga\n                for xx in range(x,x+2):\n                    for yy in range(y,y+4):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n            else:\n                for xx in range(x,x+4):\n                    for yy in range(y,y+2):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n        if startc==-1 or goalc==-1:\n            print \"NG\"\n        elif startc != goalc:\n            print \"NG\"\n        else:\n            #check if connected\n            cl=[startx,starty]\n            nc=blist[c]\n            nc.remove(cl)\n            ok=[cl]\n            goal=[goalx,goaly]\n            tansaku(cl,nc,ok,goal)\n            if goal in ok:\n                print \"OK\"\n            else:\n                print \"NG\"", "sampled": "from collections import deque\n\ndef solve():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n        \n        xs, ys = map(int, input().split())\n        xg, yg = map(int, input().split())\n        n = int(input())\n        \n        # Create board to store color at each position\n        board = [[0] * (w + 1) for _ in range(h + 1)]\n        \n        for _ in range(n):\n            c, d, x, y = map(int, input().split())\n            if d == 0:  # horizontal (2 height, 4 width)\n                for dy in range(2):\n                    for dx in range(4):\n                        if 1 <= y + dy <= h and 1 <= x + dx <= w:\n                            board[y + dy][x + dx] = c\n            else:  # vertical (4 height, 2 width)\n                for dy in range(4):\n                    for dx in range(2):\n                        if 1 <= y + dy <= h and 1 <= x + dx <= w:\n                            board[y + dy][x + dx] = c\n        \n        # BFS from start to goal\n        start_color = board[ys][xs]\n        if start_color == 0 or board[yg][xg] != start_color:\n            print(\"NG\")\n            continue\n        \n        visited = [[False] * (w + 1) for _ in range(h + 1)]\n        queue = deque([(xs, ys)])\n        visited[ys][xs] = True\n        found = False\n        \n        while queue:\n            x, y = queue.popleft()\n            if x == xg and y == yg:\n                found = True\n                break\n            \n            # Check 4 adjacent cells\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 1 <= nx <= w and 1 <= ny <= h:\n                    if not visited[ny][nx] and board[ny][nx] == start_color:\n                        visited[ny][nx] = True\n                        queue.append((nx, ny))\n        \n        print(\"OK\" if found else \"NG\")\n\nsolve()\n", "perturbed_sampled": ["from collections import deque def solve(): while True: w, h  0: break xs, ys = map(int, input().split()) xg, yg = map(int, input().split()) n = int(input()) # Create board to store color at each position board = [[0] * (w + 1) for _ in range(h + 1)]  4 width)  if 1 <= y + dy <=  + dy][x + dx] = c # BFS from start to goal start_color = board[ys][xs] if  = [[False] * (w + 1) for _ in range(h + 1)] queue = deque([(xs, ys)]) visited[ys][xs] = True found =  # Check 4 adjacent cells for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]: nx, ny = x + dx, y + dy if 1 <= nx <= w and 1 <= ny <= h: if  ny)) print(\"OK\" if found else \"NG\") solve()"], "perturbed_original": ["sys.setrecursionlimit(10000) def tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal  [i,j] in nc: nc.remove([i,j]) ok.append([i,j]) tansaku([i,j],nc,ok,goal) while(1): [boardw,boardh]=[int(x) for x in raw_input().split()] if boardw==0 and boardh==0: break else: [startx,starty]=[int(x) for x in raw_input().split()] [goalx,goaly]=[int(x) for x in raw_input().split()] blockn=int(raw_input()) blist={1:[],2:[],3:[],4:[],5:[]} startc=-1 goalc=-1 #mark location of block for i in range(blockn): [c,d,x,y]=[int(x) for x in raw_input().split()] if d: #d=1,tatenaga for xx in range(x,x+2):  goalc=c else: for  startc=c if  print \"OK\" else: print \"NG\""], "original_ll": -0.8774564862251282, "sampled_ll": -0.5174987316131592, "all_perturbed_sampled_ll": [-1.7298636436462402], "all_perturbed_original_ll": [-1.9811972379684448], "perturbed_sampled_ll": -1.7298636436462402, "perturbed_original_ll": -1.9811972379684448, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "long long table[8]={0,1,2,3,5,7,8,9},r;main(n,i){for(;scanf(\"%d\",&n),n;printf(\"%lld\\n\",r))for(r=0,i=1;n;n/=8,i*=10)r+=table[n&7]*i;exit(0);}", "sampled": "#include <stdio.h>\n\nlong long convert(long long n) {\n    long long result = 0;\n    long long base = 1;\n    \n    while (n > 0) {\n        long long digit = n % 10;\n        n /= 10;\n        \n        if (digit >= 4) digit++;\n        if (digit >= 6) digit++;\n        \n        result = digit * base + result;\n        base *= 10;\n    }\n    \n    return result;\n}\n\nlong long solve(long long n) {\n    long long left = 1, right = 10000000000LL;\n    long long answer = 1;\n    \n    while (left <= right) {\n        long long mid = left + (right - left) / 2;\n        long long converted = convert(mid);\n        \n        if (converted == n) {\n            return n;\n        } else if (converted < n) {\n            answer = converted;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return answer;\n}\n\nlong long count_valid(long long n) {\n    if (n == 0) return 0;\n    \n    long long result = 0;\n    long long power = 1;\n    long long temp = n;\n    int digits = 0;\n    \n    while (temp > 0) {\n        digits++;\n        temp /= 10;\n    }\n    \n    for (int d = 1; d < digits; d++) {\n        long long count = 1;\n        for (int i = 0; i < d; i++) {\n            count *= 8;\n        }\n        result += count;\n    }\n    \n    temp = n;\n    long long prefix = 0;\n    for (int pos = digits; pos >= 1; pos--) {\n        long long divisor = 1;\n        for (int i = 1; i < pos; i++) {\n            divisor *= 10;\n        }\n        \n        long long digit = temp / divisor;\n        temp %= divisor;\n        \n        long long count_before = digit;\n        if (digit > 4) count_before--;\n        if (digit > 6) count_before--;\n        \n        long long suffix_count = 1;\n        for (int i = 1; i < pos; i++) {\n            suffix_count *= 8;\n        }\n        \n        result += count_before * suffix_count;\n        \n        if (digit == 4 || digit == 6) {\n            return result;\n        }\n    }\n    \n    result++;\n    return result;\n}\n\nlong long find_nth(long long n) {\n    long long left = 1, right = 10000000000LL;\n    long long answer = 1;\n    \n    while (left <= right) {\n        long long mid = left + (right - left) / 2;\n        long long count = count_valid(mid);\n        \n        if (count == n) {\n            while (mid % 10 == 4 || mid % 10 == 6) {\n                mid--;\n            }\n            long long temp = mid;\n            int has_4_or_6 = 0;\n            while (temp > 0) {\n                int d = temp % 10;\n                if (d == 4 || d == 6) {\n                    has_4_or_6 = 1;\n                    break;\n                }\n                temp /= 10;\n            }\n            if (!has_4_or_6) {\n                return mid;\n            }\n            right = mid - 1;\n        } else if (count < n) {\n            left = mid + 1;\n        } else {\n            answer = mid;\n            right = mid - 1;\n        }\n    }\n    \n    while (left <= 10000000000LL) {\n        long long count = count_valid(left);\n        if (count == n) {\n            long long temp = left;\n            int has_4_or_6 = 0;\n            while (temp > 0) {\n                int d = temp % 10;\n                if (d == 4 || d == 6) {\n                    has_4_or_6 = 1;\n                    break;\n                }\n                temp /= 10;\n            }\n            if (!has_4_or_6) {\n                return left;\n            }\n        }\n        left++;\n    }\n    \n    return answer;\n}\n\nint main() {\n    long long n;\n    while (scanf(\"%lld\", &n) == 1 && n != 0) {\n        printf(\"%lld\\n\", find_nth(n));\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> long long   *= 10; } return result; } long long solve(long long  { long long mid = left + (right  - 1; } } return  long long power = 1; long long temp = n; int digits = 0;  for (int d = 1; d < digits; d++) { long long count = 1; for (int i =  result += count; } temp = n; long long prefix = 0; for (int  divisor = 1; for (int i  %=  = 1; for (int i = 1; i < pos; i++) { suffix_count *= 8; }  digit == 6) { return result; } } result++; return result; } long long find_nth(long long n) { long long left = 1, right = 10000000000LL; long long answer = 1; while (left <= right) { long long mid = left + (right - left) / 2; long long count = count_valid(mid);  0; while (temp > 0) { int d = temp %  has_4_or_6 = 1; break; } temp /= 10; } if (!has_4_or_6) { return mid; } right = mid - 1; } else if (count < n) { left = mid + 1; } else { answer = mid; right = mid - 1; } } while (left <= 10000000000LL) { long long count = count_valid(left); if (count == n) { long long temp = left; int has_4_or_6 = 0; while (temp > 0) { int d = temp % 10; if (d == 4 || d  10; } if (!has_4_or_6) { return left; } } left++; } return answer; } int main() { long long n; while (scanf(\"%lld\", &n) == 1 && n != 0) { printf(\"%lld\\n\", find_nth(n)); } return 0; }"], "perturbed_original": ["long long table[8]={0,1,2,3,5,7,8,9},r;main(n,i){for(;scanf(\"%d\",&n),n;printf(\"%lld\\n\",r))for(r=0,i=1;n;n/=8,i*=10)r+=table[n&7]*i;exit(0);}"], "original_ll": -1.901314616203308, "sampled_ll": -0.42996740341186523, "all_perturbed_sampled_ll": [-1.3380376100540161], "all_perturbed_original_ll": [-1.901314616203308], "perturbed_sampled_ll": -1.3380376100540161, "perturbed_original_ll": -1.901314616203308, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nimport java.util.regex.Pattern;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tPattern pattern = Pattern.compile(\"^4|^6\");\n\t\tPattern pattern2 = Pattern.compile(\".*4.*|.*6.*\");\n\n\t\twhile(true){\n\t\t\tlong oldNumber = stdIn.nextLong();\n\t\t\tlong newNumber = 0;\n\n\t\t\tif(oldNumber == 0){break;}\n\n\t\t\tint count = 0;\n\t\t\twhile(count < oldNumber){\n\t\t\t\tnewNumber++;\n\t\t\t\tString stringNewNumber = Long.toString(newNumber);\n\t\t\t\tif(pattern.matcher(stringNewNumber).find()){\n\t\t\t\t\tnewNumber += Math.pow(10, stringNewNumber.length()-1);\n\t\t\t\t}else if(pattern2.matcher(stringNewNumber).find()){\n\t\t\t\t\twhile(pattern2.matcher(Long.toString(newNumber)).find()){\n\t\t\t\t\t\tnewNumber++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tSystem.out.println(newNumber);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long n = sc.nextLong();\n            if (n == 0) break;\n            \n            System.out.println(convertToNewRoomNumber(n));\n        }\n        \n        sc.close();\n    }\n    \n    static long convertToNewRoomNumber(long oldNumber) {\n        long result = 0;\n        long multiplier = 1;\n        long remaining = oldNumber;\n        \n        while (remaining > 0) {\n            long digit = remaining % 10;\n            remaining /= 10;\n            \n            // Map digit to new system (base 8 excluding 4 and 6)\n            // 0->0, 1->1, 2->2, 3->3, 4->5, 5->7, 6->8, 7->9\n            long mappedDigit;\n            if (digit <= 3) {\n                mappedDigit = digit;\n            } else if (digit == 4) {\n                mappedDigit = 5;\n            } else if (digit == 5) {\n                mappedDigit = 7;\n            } else if (digit == 6) {\n                mappedDigit = 8;\n            } else {\n                mappedDigit = 9;\n            }\n            \n            result += mappedDigit * multiplier;\n            multiplier *= 10;\n        }\n        \n        return result;\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  Scanner sc = new  == 0) break; System.out.println(convertToNewRoomNumber(n)); } sc.close(); } static long convertToNewRoomNumber(long oldNumber) { long result = 0; long multiplier = 1; long remaining = oldNumber;  10; remaining /=  5->7, 6->8, 7->9  } else if (digit == 4) { mappedDigit = 5; } else if (digit == 5) { mappedDigit = 7; } else if (digit == 6) { mappedDigit = 8; } else { mappedDigit = 9;  return result; } }"], "perturbed_original": ["import java.util.Scanner; import java.util.regex.Pattern; class Main{ public static void main(String[] args){ Scanner stdIn = new <extra_id_2>String long oldNumber = <extra_id_3>;<extra_id_4>=<extra_id_5>Int24Int<extra_id_6>int count = 0 ;<extra_id_7>{ long inp = 0<extra_id_8>; case \" \"<extra_id_9>\"<extra_id_10>\" \" : case<extra_id_11>\" \"<extra_id_12>\" \" : continue<extra_id_13>case \"<extra_id_14>\" \"<extra_id_15>\" \"<extra_id_16>, \" \"<extra_id_17>,<extra_id_18>\"<extra_id_19>) { //<extra_id_20>) ;<extra_id_21>, ) ; = 0; while(count < oldNumber){ newNumber++; String  while(pattern2.matcher(Long.toString(newNumber)).find()){ newNumber++; } } count++; } System.out.println(newNumber); } } }"], "original_ll": -0.9200530648231506, "sampled_ll": -0.595868706703186, "all_perturbed_sampled_ll": [-1.8650213479995728], "all_perturbed_original_ll": [-2.0973000526428223], "perturbed_sampled_ll": -1.8650213479995728, "perturbed_original_ll": -2.0973000526428223, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def testcase_ends():\n    n = int(input())\n    if n == 0:\n        return 1\n\n    n = oct(n)[2:]\n    n = n.replace('7', '9')\n    n = n.replace('6', '8')\n    n = n.replace('5', '7')\n    n = n.replace('4', '5')\n    print(n)\n    return 0\n\ndef main():\n    while not testcase_ends():\n        pass\n\nif __name__ == '__main__':\n    main()\n\n", "sampled": "def convert_to_new_room(n):\n    # Convert n to base-8 representation, treating digits 0-7 as valid\n    # Then map: 0->1, 1->2, 2->3, 3->5, 4->7, 5->8, 6->9, 7->10\n    # This is essentially converting to a number system without 4 and 6\n    \n    # First, convert n to base 8\n    if n == 0:\n        return 0\n    \n    result = 0\n    multiplier = 1\n    temp_n = n\n    \n    while temp_n > 0:\n        digit = temp_n % 8\n        temp_n //= 8\n        \n        # Map the digit (0-7 in base 8 concept) to actual digit without 4 and 6\n        # digit 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 5, 4 -> 7, 5 -> 8, 6 -> 9, 7 -> 10\n        if digit == 0:\n            mapped = 1\n        elif digit == 1:\n            mapped = 2\n        elif digit == 2:\n            mapped = 3\n        elif digit == 3:\n            mapped = 5\n        elif digit == 4:\n            mapped = 7\n        elif digit == 5:\n            mapped = 8\n        elif digit == 6:\n            mapped = 9\n        else:  # digit == 7\n            mapped = 10\n        \n        result += mapped * multiplier\n        multiplier *= 10\n    \n    return result\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(convert_to_new_room(n))\n", "perturbed_sampled": ["def convert_to_new_room(n): # Convert  system without 4 and 6 # First, convert n to base 8 if n == 0: return 0 result = 0 multiplier = 1 temp_n = n while temp_n > 0: digit = temp_n % 8 temp_n //=  to actual digit without 4 and 6 # digit 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 5, 4  10 if digit == 0: mapped = 1 elif digit == 1: mapped = 2 elif digit == 2:  == 5: mapped  # digit  multiplier *= 10 return result while True: n = int(input()) if n == 0: break print(convert_to_new_room(n))"], "perturbed_original": ["def testcase_ends(): n = int(input()) if 2:<extra_id_2>if n.replace('7', '9') n = n.replace('6', '8') 2<extra_id_3>[ \"your_app.start_testcase()\", \"souve_testcase().start/2\"],<extra_id_4>__main__<extra_id_5>__main__.__doc__:\"<extra_id_6>main() pass testcase_ends() pass<extra_id_7>testcase_ends() pass return 0 def main(): while not testcase_ends(): pass if __name__ == '__main__': main()"], "original_ll": -1.174167513847351, "sampled_ll": -0.745367705821991, "all_perturbed_sampled_ll": [-2.099090337753296], "all_perturbed_original_ll": [-3.193690061569214], "perturbed_sampled_ll": -2.099090337753296, "perturbed_original_ll": -3.193690061569214, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\n\ntypedef struct{\n  int x;\n  int y;\n  int ny;\n  int nx;\n  char dir;\n  int movable;\n}man;\ntypedef struct{\n  int x;\n  int y;\n}d;\n\nchar map[30][31];\nint w,h;\nman ms[900];\nint msize;\nd dir[4]={{1,0},{0,-1},{-1,0},{0,1}};\n//memo 0:east 1:north 2:west 3:south\nchar n2d(int d){\n  return d==0?'E':d==1?'N':d==2?'W':'S';\n}\nint d2n(char d){\n  return d=='E'?0:d=='N'?1:d=='W'?2:d=='S'?3:-1;\n}\nint main(){\n  int i,j,l,k,nx,ny;\n  do{\n    scanf(\"%d %d\",&w,&h);\n    if(w==0&&h==0) break;\n    msize=0;\n    for(i=0;i<h;i++){      \n      scanf(\"%s\",map+i);\n      for(j=0;j<w;j++){\n\tif(map[i][j]!='#'&&map[i][j]!='.'&&map[i][j]!='X'){\n\t  ms[msize].x=j;\n\t  ms[msize].y=i;\n\t  ms[msize].dir=d2n(map[i][j]);\n\t  msize++;\n\t}\n      }\n    }\n    for(i=1;i<181;i++){\n      /*            for(j=0;j<h;j++)\n\tprintf(\"%s\\n\",map+j);\n\tprintf(\"\\n\");*/\n      for(j=0;j<msize;j++){\n\tms[j].movable=0;\n\tfor(k=-1;k<3;k++){\n\t  ms[j].nx=ms[j].x+dir[(4+ms[j].dir+k)%4].x;\n\t  ms[j].ny=ms[j].y+dir[(4+ms[j].dir+k)%4].y;\n\t  if(map[ms[j].ny][ms[j].nx]=='X'){\n\t    ms[j].movable=1;\n\t    break;\t    \n\t  }else if(map[ms[j].ny][ms[j].nx]=='.'){\n\t    ms[j].dir=(4+ms[j].dir+k)%4;\n\t    ms[j].movable=1;\n\t    break;\n\t  }\t  \n\t}\n      }\n      for(j=0;j<msize;j++){\n\tif(map[ms[j].ny][ms[j].nx]!='X'&&ms[j].movable)\n\t  for(k=0;k<4;k++){\n\t    nx=ms[j].nx+dir[k].x;\n\t    ny=ms[j].ny+dir[k].y;\n\t    //\t    printf(\"(%d %d %c) \",ny,nx,map[ny][nx]);\n\t    if(isalpha(map[ny][nx])\n\t       &&map[ny][nx]!='X'\n\t       &&((d2n(map[ny][nx])+2)%4)==k){\n//\t      printf(\"%d %d %c\\n\",ny,nx,map[ny][nx]);\n\t      if(ms[j].x!=nx||ms[j].y!=ny){\n\t\tms[j].movable=0;\t\t\n\t      }\n\t      break;\n\t    }else if(ms[j].x==nx&&ms[j].y==ny){\n\t      map[ms[j].y][ms[j].x]=n2d(ms[j].dir);\n\t      break;\n\t    }\n\t  }\n\t//\tprintf(\"\\n\");\n      }\n      for(j=0;j<msize;j++){\n\tif(map[ms[j].ny][ms[j].nx]=='X'){\n\t  map[ms[j].y][ms[j].x]='.';\n\t  for(l=j;l<msize;l++){\n\t    ms[l]=ms[l+1];\n\t  }\t    \n\t  j--;\n\t  msize--;\n\t}else if(ms[j].movable){\n\t  map[ms[j].y][ms[j].x]='.';\n\t  map[ms[j].ny][ms[j].nx]=n2d(ms[j].dir);\n\t  ms[j].x=ms[j].nx;\n\t  ms[j].y=ms[j].ny;\n\t}\n      }\n      if(msize==0){\n\tprintf(\"%d\\n\",i);\n\tbreak;\n      }\n    }\n    if(i==181)\n      printf(\"NA\\n\");\n  }while(1);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 30\n\ntypedef struct {\n    int x, y;\n    char dir;\n} Person;\n\nchar grid[MAX][MAX];\nint W, H;\nPerson people[MAX*MAX];\nint num_people;\n\nint dx[] = {1, 0, -1, 0}; // E, N, W, S\nint dy[] = {0, -1, 0, 1};\nchar dirs[] = \"ENWS\";\n\nint get_dir_idx(char d) {\n    for(int i = 0; i < 4; i++) {\n        if(dirs[i] == d) return i;\n    }\n    return 0;\n}\n\nint is_passable(int x, int y) {\n    if(x < 0 || x >= W || y < 0 || y >= H) return 0;\n    return grid[y][x] == '.' || grid[y][x] == 'X';\n}\n\nvoid simulate() {\n    int time = 0;\n    \n    while(num_people > 0 && time <= 180) {\n        time++;\n        \n        // Step 1: Change direction\n        for(int i = 0; i < num_people; i++) {\n            int dir_idx = get_dir_idx(people[i].dir);\n            int found = 0;\n            \n            // Check right, front, left, back\n            int order[] = {(dir_idx + 3) % 4, dir_idx, (dir_idx + 1) % 4, (dir_idx + 2) % 4};\n            \n            for(int j = 0; j < 4; j++) {\n                int d = order[j];\n                int nx = people[i].x + dx[d];\n                int ny = people[i].y + dy[d];\n                \n                if(is_passable(nx, ny)) {\n                    people[i].dir = dirs[d];\n                    found = 1;\n                    break;\n                }\n            }\n        }\n        \n        // Step 2: Move\n        int target_count[MAX][MAX];\n        int target_who[MAX][MAX][4];\n        memset(target_count, 0, sizeof(target_count));\n        \n        for(int i = 0; i < num_people; i++) {\n            int dir_idx = get_dir_idx(people[i].dir);\n            int nx = people[i].x + dx[dir_idx];\n            int ny = people[i].y + dy[dir_idx];\n            \n            if(is_passable(nx, ny)) {\n                target_who[ny][nx][target_count[ny][nx]++] = i;\n            }\n        }\n        \n        int moved[MAX*MAX];\n        memset(moved, 0, sizeof(moved));\n        \n        for(int y = 0; y < H; y++) {\n            for(int x = 0; x < W; x++) {\n                if(target_count[y][x] > 1) {\n                    // Multiple people want this spot\n                    // Priority: E, N, W, S of the target\n                    int priority_order[] = {0, 1, 2, 3}; // E, N, W, S\n                    int selected = -1;\n                    \n                    for(int p = 0; p < 4; p++) {\n                        int check_x = x - dx[priority_order[p]];\n                        int check_y = y - dy[priority_order[p]];\n                        \n                        for(int k = 0; k < target_count[y][x]; k++) {\n                            int who = target_who[y][x][k];\n                            if(people[who].x == check_x && people[who].y == check_y) {\n                                selected = who;\n                                break;\n                            }\n                        }\n                        if(selected != -1) break;\n                    }\n                    \n                    if(selected != -1) {\n                        moved[selected] = 1;\n                    }\n                } else if(target_count[y][x] == 1) {\n                    moved[target_who[y][x][0]] = 1;\n                }\n            }\n        }\n        \n        // Apply moves\n        for(int i = 0; i < num_people; i++) {\n            if(moved[i]) {\n                int dir_idx = get_dir_idx(people[i].dir);\n                people[i].x += dx[dir_idx];\n                people[i].y += dy[dir_idx];\n            }\n        }\n        \n        // Remove people at exits\n        int new_num = 0;\n        for(int i = 0; i < num_people; i++) {\n            if(grid[people[i].y][people[i].x] != 'X') {\n                people[new_num++] = people[i];\n            }\n        }\n        num_people = new_num;\n    }\n    \n    if(num_people == 0) {\n        printf(\"%d\\n\", time);\n    } else {\n        printf(\"NA\\n\");\n    }\n}\n\nint main() {\n    while(1) {\n        scanf(\"%d %d\", &W, &H);\n        if(W == 0 && H == 0) break;\n        \n        num_people = 0;\n        for(int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n            for(int j = 0; j < W; j++) {\n                if(grid[i][j] == 'E' || grid[i][j] == 'N' || \n                   grid[i][j] == 'W' || grid[i][j] == 'S') {\n                    people[num_people].x = j;\n                    people[num_people].y = i;\n                    people[num_people].dir = grid[i][j];\n                    num_people++;\n                    grid[i][j] = '.';\n                }\n            }\n        }\n        \n        simulate();\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #define MAX 30 typedef struct {  W, H; Person people[MAX*MAX]; int num_people; int dx[] = {1, 0,  get_dir_idx(char d) {  == d) return i; }  0 || y >=  'X'; } void simulate() { int time = 0; while(num_people > 0 && time <= 180) { time++; // Step 1: Change direction for(int i = 0; i < num_people; i++) { int dir_idx = get_dir_idx(people[i].dir);  (dir_idx +  ny = people[i].y + dy[d]; if(is_passable(nx, ny)) {  0, sizeof(target_count)); for(int i  get_dir_idx(people[i].dir); int nx =  ny)) { target_who[ny][nx][target_count[ny][nx]++] = i; } } int moved[MAX*MAX]; memset(moved, 0, sizeof(moved)); for(int y = 0; y < H; y++) { for(int x = 0;  Multiple people want this spot // Priority: E, N, W, S of the target int priority_order[] = {0, 1, 2, 3}; // E, N, W, S int selected  { int check_x = x - dx[priority_order[p]]; int check_y = y  { int who = target_who[y][x][k]; if(people[who].x == check_x && people[who].y  = 1; } } else if(target_count[y][x] == 1) { moved[target_who[y][x][0]] = 1;  i < num_people; i++) {  += dy[dir_idx]; } } // Remove people at exits int new_num = 0; for(int i = 0;  = people[i]; } } num_people = new_num; } if(num_people == 0) { printf(\"%d\\n\", time); } else { printf(\"NA\\n\"); } } int main() { while(1) { scanf(\"%d %d\", &W, &H); if(W == 0 && H == 0) break; num_people = 0; for(int i = 0; i < H; i++) { scanf(\"%s\", grid[i]); for(int j = 0; j < W; j++)  j; people[num_people].y = i; people[num_people].dir = grid[i][j]; num_people++; grid[i][j] = '.'; } } } simulate(); } return 0; }"], "perturbed_original": ["#include<stdio.h> typedef struct{ int  char map[30][31]; int w,h; man ms[900]; int msize; d dir[4]={{1,0},{0,-1},{-1,0},{0,1}}; //memo 0:east 1:north 2:west 3:south char n2d(int d){ return d==0?'E':d==1?'N':d==2?'W':'S'; } int d2n(char d){ return d=='E'?0:d=='N'?1:d=='W'?2:d=='S'?3:-1; } int main(){ int  if(map[i][j]!='#'&&map[i][j]!='.'&&map[i][j]!='X'){ ms[msize].x=j; ms[msize].y=i; ms[msize].dir=d2n(map[i][j]); msize++; } } }  if(map[ms[j].ny][ms[j].nx]=='X'){ ms[j].movable=1;  if(map[ms[j].ny][ms[j].nx]!='X'&&ms[j].movable) for(k=0;k<4;k++){ nx=ms[j].nx+dir[k].x; ny=ms[j].ny+dir[k].y; // printf(\"(%d %d %c) \",ny,nx,map[ny][nx]); if(isalpha(map[ny][nx]) &&map[ny][nx]!='X' &&((d2n(map[ny][nx])+2)%4)==k){ // printf(\"%d %d %c\\n\",ny,nx,map[ny][nx]); if(ms[j].x!=nx||ms[j].y!=ny){ ms[j].movable=0; }  for(j=0;j<msize;j++){ if(map[ms[j].ny][ms[j].nx]=='X'){ map[ms[j].y][ms[j].x]='.'; for(l=j;l<msize;l++){ ms[l]=ms[l+1]; } j--; msize--; }else if(ms[j].movable){  } if(i==181) printf(\"NA\\n\"); }while(1); return 0; }"], "original_ll": -0.7496730089187622, "sampled_ll": -0.48740828037261963, "all_perturbed_sampled_ll": [-1.7305057048797607], "all_perturbed_original_ll": [-1.265844464302063], "perturbed_sampled_ll": -1.7305057048797607, "perturbed_original_ll": -1.265844464302063, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n\tint [] vx = {1,0,-1,0};\n\tint [] vy = {0,-1,0,1};\n\tboolean [] isgoal;\n\t\n\tclass C{\n\t\tint x,y,dir;\n\t\tpublic C(int x, int y, int dir) {\n\t\t\tthis.x = x;this.y = y;\n\t\t\tif(dir == 'E')\n\t\t\t\tdir = 0;\n\t\t\telse if(dir == 'N')\n\t\t\t\tdir = 1;\n\t\t\telse if(dir == 'S')\n\t\t\t\tdir = 3;\n\t\t\telse if(dir == 'W')\n\t\t\t\tdir = 2;\n\t\t\telse{\n\t\t\t\t\n\t\t\t}\n\t\t\tthis.dir = dir;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", dir=\" + dir + \"]\";\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tchar [][] map = new char[h][w];\n\t\t\tArrayList<C> humlist = new ArrayList<C>();\n\t\t\tfor(int i=0; i < h;i++){\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=0; j < w;j++){\n\t\t\t\t\tchar c = line.charAt(j);\n\t\t\t\t\tif(c == 'E' || c == 'N' || c == 'W' || c == 'S'){\n\t\t\t\t\t\thumlist.add(new C(j,i,(int)c));\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[i][j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//debug\n//\t\t\tfor(int i=0; i < h; i++){\n//\t\t\t\tfor(int j = 0; j < w; j++){\n//\t\t\t\t\tSystem.out.print(map[i][j]);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\tSystem.out.println(\"list= \" + humlist.toString());\n\t\t\tint step = 0;\n\t\t\tLinkedList<Integer> open = new LinkedList<Integer>();\n\t\t\topen.add(step);\n\t\t\tint len = humlist.size();\n\t\t\tisgoal = new boolean[len];\n\t\t\tboolean isachieve = true;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tstep = open.removeFirst();\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(humlist.toString());\n\t\t\t\t//change dir\n\t\t\t\tfor(int i = 0; i < len;i++){\n\t\t\t\t\tif(isgoal[i])continue;\n\t\t\t\t\tC nowhum = humlist.get(i);\n\t\t\t\t\tint nowdir = nowhum.dir;\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tnowdir = (j + 4 + nowhum.dir - 1) % 4;\n\t\t\t\t\t\tint xx = nowhum.x + vx[nowdir];\n\t\t\t\t\t\tint yy = nowhum.y + vy[nowdir];\n\t\t\t\t\t\tif(map[yy][xx] == '#') continue;\n\t\t\t\t\t\tif((map[yy][xx] == 'X' || map[yy][xx] == '.') && ! isin(xx,yy,humlist)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnowhum.dir = nowdir;\n\t\t\t\t\thumlist.set(i, nowhum);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//move\n\t\t\t\tArrayList<C> humlistrecord = valueC(humlist);\n\t\t\t\tfor(int i=0; i < len; i++){\n\t\t\t\t\tif(isgoal[i]) continue;\n\t\t\t\t\tC nowhum = humlist.get(i);\n\t\t\t\t\tint xx = nowhum.x + vx[nowhum.dir];\n\t\t\t\t\tint yy = nowhum.y + vy[nowhum.dir];\n\t\t\t\t\tif(map[yy][xx] == '#' || isin(xx,yy,humlist)) continue;\n\t\t\t\t\tint movehum = getmove(xx,yy,humlistrecord);\n\t\t\t\t\tif(movehum == i){\n\t\t\t\t\t\tnowhum.x = xx;\n\t\t\t\t\t\tnowhum.y = yy;\n\t\t\t\t\t\thumlist.set(i, nowhum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//escape\n\t\t\t\tfor(int i = 0; i < len;i++){\n\t\t\t\t\tC nowhum = humlist.get(i);\n\t\t\t\t\tint humx = nowhum.x,humy = nowhum.y;\n\t\t\t\t\tif(map[humy][humx] == 'X'){\n\t\t\t\t\t\tisgoal[i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//fin\n\t\t\t\tif(isAllGoal()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(step + 1 > 180){\n\t\t\t\t\tisachieve = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\topen.add(step + 1);\n\t\t\t}\n\t\t\tif(isachieve){\n\t\t\t\tif(humlist.size() == 0){\n\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(step + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean isAllGoal(){\n\t\tfor(int i=0; i < isgoal.length;i++){\n\t\t\tif(! isgoal[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate int getmove(int x, int y, ArrayList<C> list){\n\t\tfor(int i=0; i < 4;i++){\n\t\t\tint xx = x + vx[i];\n\t\t\tint yy = y + vy[i];\n\t\t\tfor(int j=0; j < list.size(); j++){\n\t\t\t\tif(isgoal[j])continue;\n\t\t\t\tC now = list.get(j);\n\t\t\t\tboolean cond1 = (xx == now.x && yy == now.y);\n\t\t\t\tboolean cond2 = ((now.x + vx[now.dir]) == x && (now.y + vy[now.dir]) == y);\n\t\t\t\tif(cond1 && cond2){\n\t\t\t\t\treturn j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprivate ArrayList<C> valueC(ArrayList<C> list){\n\t\tArrayList<C> res =  new ArrayList<C>();\n\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\tC now = list.get(i);\n\t\t\tres.add(new C(now.x, now.y, now.dir));\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tprivate boolean isin(int x, int y,ArrayList<C> list){\n\t\tfor(int i=0; i < list.size();i++){\n\t\t\tif(isgoal[i])continue;\n\t\t\tC now = list.get(i);\n\t\t\tif(now.x == x && now.y == y){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Person {\n        int x, y;\n        char dir;\n        \n        Person(int x, int y, char dir) {\n            this.x = x;\n            this.y = y;\n            this.dir = dir;\n        }\n    }\n    \n    static int[] dx = {1, 0, -1, 0}; // E, N, W, S\n    static int[] dy = {0, -1, 0, 1};\n    static Map<Character, Integer> dirMap = new HashMap<>();\n    \n    static {\n        dirMap.put('E', 0);\n        dirMap.put('N', 1);\n        dirMap.put('W', 2);\n        dirMap.put('S', 3);\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\" \");\n            int W = Integer.parseInt(parts[0]);\n            int H = Integer.parseInt(parts[1]);\n            \n            if (W == 0 && H == 0) break;\n            \n            char[][] grid = new char[H][W];\n            List<Person> people = new ArrayList<>();\n            \n            for (int i = 0; i < H; i++) {\n                String str = br.readLine();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = str.charAt(j);\n                    if (dirMap.containsKey(grid[i][j])) {\n                        people.add(new Person(j, i, grid[i][j]));\n                        grid[i][j] = '.';\n                    }\n                }\n            }\n            \n            int result = simulate(grid, people, W, H);\n            if (result > 180) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n    }\n    \n    static int simulate(char[][] grid, List<Person> people, int W, int H) {\n        int time = 0;\n        \n        while (!people.isEmpty() && time <= 180) {\n            time++;\n            \n            // Step 1: Update directions\n            for (Person p : people) {\n                int currentDir = dirMap.get(p.dir);\n                int[] checkOrder = {(currentDir + 3) % 4, currentDir, (currentDir + 1) % 4, (currentDir + 2) % 4};\n                \n                for (int d : checkOrder) {\n                    int nx = p.x + dx[d];\n                    int ny = p.y + dy[d];\n                    \n                    if (nx >= 0 && nx < W && ny >= 0 && ny < H && \n                        (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) {\n                        p.dir = getDir(d);\n                        break;\n                    }\n                }\n            }\n            \n            // Step 2: Determine moves\n            Map<String, List<Person>> targetMap = new HashMap<>();\n            \n            for (Person p : people) {\n                int d = dirMap.get(p.dir);\n                int nx = p.x + dx[d];\n                int ny = p.y + dy[d];\n                \n                if (nx >= 0 && nx < W && ny >= 0 && ny < H && \n                    (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) {\n                    String key = nx + \",\" + ny;\n                    targetMap.putIfAbsent(key, new ArrayList<>());\n                    targetMap.get(key).add(p);\n                }\n            }\n            \n            // Step 3: Move people\n            Set<Person> toRemove = new HashSet<>();\n            \n            for (String key : targetMap.keySet()) {\n                List<Person> candidates = targetMap.get(key);\n                \n                if (candidates.size() == 1) {\n                    Person p = candidates.get(0);\n                    String[] coords = key.split(\",\");\n                    p.x = Integer.parseInt(coords[0]);\n                    p.y = Integer.parseInt(coords[1]);\n                    \n                    if (grid[p.y][p.x] == 'X') {\n                        toRemove.add(p);\n                    }\n                } else {\n                    // Priority: E, N, W, S (by position of source)\n                    Person selected = null;\n                    int[] priority = {0, 1, 2, 3}; // E, N, W, S\n                    \n                    for (int pri : priority) {\n                        for (Person p : candidates) {\n                            int d = dirMap.get(p.dir);\n                            if (d == pri) {\n                                selected = p;\n                                break;\n                            }\n                        }\n                        if (selected != null) break;\n                    }\n                    \n                    if (selected != null) {\n                        String[] coords = key.split(\",\");\n                        selected.x = Integer.parseInt(coords[0]);\n                        selected.y = Integer.parseInt(coords[1]);\n                        \n                        if (grid[selected.y][selected.x] == 'X') {\n                            toRemove.add(selected);\n                        }\n                    }\n                }\n            }\n            \n            people.removeAll(toRemove);\n        }\n        \n        return time;\n    }\n    \n    static char getDir(int d) {\n        switch (d) {\n            case 0: return 'E';\n            case 1: return 'N';\n            case 2: return 'W';\n            case 3: return 'S';\n        }\n        return 'E';\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import  x, y; char dir; Person(int x, int y, char dir) { this.x =  int[] dx = {1, 0, -1, 0}; // E, N, W, S static int[] dy = {0, -1, 0, 1}; static Map<Character, Integer> dirMap = new HashMap<>(); static { dirMap.put('E', 0); dirMap.put('N', 1); dirMap.put('W', 2); dirMap.put('S', 3);  br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] parts = line.trim().split(\" \"); int W = Integer.parseInt(parts[0]); int H = Integer.parseInt(parts[1]); if (W == 0 && H == 0) break; char[][] grid = new char[H][W]; List<Person> people  grid[i][j] = '.'; } }  > 180) { System.out.println(\"NA\"); } else  people, int W, int H) { int time = 0; while (!people.isEmpty() && time <= 180) { time++; // Step 1: Update directions for (Person p : people) { int currentDir = dirMap.get(p.dir);  + 1)  :  < H && (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) {  Determine moves Map<String, List<Person>> targetMap = new HashMap<>(); for (Person p : people) { int d  = p.y + dy[d]; if (nx >=  ny < H &&  = nx + \",\" + ny; targetMap.putIfAbsent(key,  targetMap.keySet()) { List<Person> candidates = targetMap.get(key); if (candidates.size() == 1) { Person p = candidates.get(0); String[] coords =  'X') { toRemove.add(p); } } else { //  selected = null; int[] priority = {0, 1, 2, 3};  = dirMap.get(p.dir); if (d == pri) { selected = p; break; } } if (selected != null) break; } if (selected != null) { String[] coords = key.split(\",\"); selected.x = Integer.parseInt(coords[0]); selected.y = Integer.parseInt(coords[1]); if (grid[selected.y][selected.x] == 'X') { toRemove.add(selected); } } } } people.removeAll(toRemove); } return time;  0: return 'E';  return 'S'; } return 'E'; } }"], "perturbed_original": ["import java.util.*; public class Main { int  int y, int dir) { this.x = x;this.y = y; if(dir == 'E') dir = 0; else if(dir == 'N') dir = 1; else if(dir == 'S') dir = 3; else if(dir == 'W')  \", y=\"  } private void doit(){ Scanner sc=new Scanner(System.in); while(true){ int w = sc.nextInt(), h = sc.nextInt(); if((w|h) == 0) break; char [][] map = new char[h][w]; ArrayList<C> humlist = new ArrayList<C>(); for(int i=0; i < h;i++){ String line = sc.next(); for(int j=0; j < w;j++){ char c = line.charAt(j); if(c == 'E' || c == 'N' || c == 'W' || c == 'S'){ humlist.add(new  h; i++){ // for(int   + humlist.toString()); int step = 0; LinkedList<Integer> open = new LinkedList<Integer>();  isachieve = true; while(! open.isEmpty()){ step = open.removeFirst(); //debug //System.out.println(humlist.toString()); //change dir for(int i = 0; i < len;i++){  'X' || map[yy][xx] ==  humlist.set(i, nowhum); } //move ArrayList<C> humlistrecord = valueC(humlist); for(int i=0; i < len;  nowhum.x + vx[nowhum.dir]; int  = xx; nowhum.y = yy; humlist.set(i, nowhum); } } //escape for(int i = 0; i  = nowhum.y; if(map[humy][humx] == 'X'){ isgoal[i] = true; } } //fin if(isAllGoal()){ break; } if(step + 1 > 180){ isachieve = false; break;  } else{ System.out.println(step + 1); } } else{ System.out.println(\"NA\"); }  if(! isgoal[i]) return false; } return true; } private int getmove(int x, int y, ArrayList<C> list){ for(int  int yy = y + vy[i]; for(int j=0; j < list.size(); j++){ if(isgoal[j])continue; C now = list.get(j); boolean cond1 = (xx == now.x && yy == now.y); boolean cond2 = ((now.x + vx[now.dir]) == x && (now.y + vy[now.dir]) == y); if(cond1 && cond2){ return j; } } } return -1; } private ArrayList<C> valueC(ArrayList<C> list){ ArrayList<C> res =  C now = list.get(i); res.add(new C(now.x, now.y, now.dir)); } return res; }  <  now.y  Main(); obj.doit(); } }"], "original_ll": -0.6564801335334778, "sampled_ll": -0.4019593298435211, "all_perturbed_sampled_ll": [-1.5506367683410645], "all_perturbed_original_ll": [-1.8244476318359375], "perturbed_sampled_ll": -1.5506367683410645, "perturbed_original_ll": -1.8244476318359375, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\ndirection = {'N' : 0, 'E' : 1, 'S' : 2, 'W' : 3}\nstep = [( -1, 0 ), ( 0, 1 ), ( 1, 0 ), ( 0, -1 )]\nvv = []\n\nwhile True:\n    W, H = map( int, sys.stdin.readline().rstrip().split() )\n    if W == 0 and H == 0: break\n    m = [ list( sys.stdin.readline().strip() ) for i in xrange( H ) ]\n    people = [ ( i, j, direction[ m[i][j] ] ) for i in xrange( H ) for j in range( W )\n               if m[i][j] in \"NESW\" ]\n    time = 0\n    while any( people ):\n        time += 1\n        if time > 180:\n            time = -1\n            break\n        sched = []\n        for n in xrange( len( people ) ):\n            if people[n] is None: continue\n            x, y, d = people[n]\n            for i in range(1, -3, -1):\n                    dx, dy = step[(d + i) % 4]\n                    if 0 <= x+dx < H and 0 <= y+dy < W and m[x+dx][y+dy] in \"X.\":\n                        people[n][2] = (d + i) % 4\n                        beat = True\n                        for k in range( len( sched ) ):\n                            xx, yy, dd = sched[k][1:]\n                            if ( x+dx, y+dy ) == ( xx, yy ):\n                                if dd < (d + i) % 4:\n                                    sched[k] = ( n, x+dx, y+dy, (d + i) % 4 )\n                                    beat = False\n                                    break\n                                else:\n                                    beat = False\n                                    break\n                        if beat:\n                            sched.append( ( n, x+dx, y+dy, (d + i) % 4 ) )\n\t\t\tbreak\n        for ( k, x, y, d ) in sched:\n            m[ people[k][0] ][ people[k][1] ] = '.'\n            if m[x][y] == 'X':\n                people[k] = None\n            else:\n                m[x][y] = 'H'\n                people[k] = x, y, d\n    if time >= 0:\n        vv.append(time)\n    else:\n        vv.append('NA')\n\nfor v in vv:\n    print v", "sampled": "from collections import deque\n\ndef solve():\n    while True:\n        W, H = map(int, input().split())\n        if W == 0 and H == 0:\n            break\n        \n        grid = []\n        people = []\n        \n        for i in range(H):\n            row = input().strip()\n            grid.append(list(row))\n            for j in range(len(row)):\n                if row[j] in 'ENSW':\n                    people.append([i, j, row[j]])\n                    grid[i][j] = '.'\n        \n        # Direction mappings\n        dir_map = {\n            'E': (0, 1),\n            'W': (0, -1),\n            'N': (-1, 0),\n            'S': (1, 0)\n        }\n        \n        dir_names = ['E', 'W', 'N', 'S']\n        \n        # Right, front, left, back relative to current direction\n        turn_order = {\n            'E': ['S', 'E', 'N', 'W'],\n            'W': ['N', 'W', 'S', 'E'],\n            'N': ['E', 'N', 'W', 'S'],\n            'S': ['W', 'S', 'E', 'N']\n        }\n        \n        time = 0\n        \n        while people and time <= 180:\n            # Step 1: Update directions\n            new_people = []\n            for person in people:\n                r, c, facing = person\n                \n                # Check right, front, left, back\n                found_dir = None\n                for check_dir in turn_order[facing]:\n                    dr, dc = dir_map[check_dir]\n                    nr, nc = r + dr, c + dc\n                    \n                    if 0 <= nr < H and 0 <= nc < W:\n                        cell = grid[nr][nc]\n                        if cell == '.' or cell == 'X':\n                            # Check if occupied by another person\n                            occupied = False\n                            for other in people:\n                                if other[0] == nr and other[1] == nc:\n                                    occupied = True\n                                    break\n                            \n                            if not occupied:\n                                found_dir = check_dir\n                                break\n                \n                if found_dir:\n                    new_people.append([r, c, found_dir])\n                else:\n                    new_people.append([r, c, facing])\n            \n            people = new_people\n            \n            # Step 2: Move people\n            # Calculate target positions for each person\n            targets = {}\n            for idx, person in enumerate(people):\n                r, c, facing = person\n                dr, dc = dir_map[facing]\n                nr, nc = r + dr, c + dc\n                \n                if 0 <= nr < H and 0 <= nc < W:\n                    cell = grid[nr][nc]\n                    if cell == '.' or cell == 'X':\n                        if (nr, nc) not in targets:\n                            targets[(nr, nc)] = []\n                        targets[(nr, nc)].append((idx, r, c))\n            \n            # Resolve conflicts\n            moved = set()\n            new_people = []\n            \n            for target, candidates in targets.items():\n                if len(candidates) == 1:\n                    idx, r, c = candidates[0]\n                    moved.add(idx)\n                else:\n                    # Priority: E, N, W, S\n                    priority_order = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n                    tr, tc = target\n                    \n                    selected = None\n                    for dr, dc in priority_order:\n                        sr, sc = tr - dr, tc - dc\n                        for idx, r, c in candidates:\n                            if r == sr and c == sc:\n                                selected = idx\n                                break\n                        if selected is not None:\n                            break\n                    \n                    if selected is not None:\n                        moved.add(selected)\n            \n            # Update people positions\n            final_people = []\n            for idx, person in enumerate(people):\n                r, c, facing = person\n                if idx in moved:\n                    dr, dc = dir_map[facing]\n                    nr, nc = r + dr, c + dc\n                    \n                    # Check if it's an exit\n                    if grid[nr][nc] == 'X':\n                        # Person escapes\n                        continue\n                    else:\n                        final_people.append([nr, nc, facing])\n                else:\n                    final_people.append([r, c, facing])\n            \n            people = final_people\n            time += 1\n        \n        if people:\n            print(\"NA\")\n        else:\n            print(time)\n\nsolve()\n", "perturbed_sampled": ["from collections import deque def solve(): while True: W, H = map(int, input().split()) if W == 0 and H == 0: break grid = [] people = [] for i in range(H): row = input().strip() grid.append(list(row))  row[j]])  (1, 0) } dir_names = ['E', 'W', 'N', 'S'] # Right,  'E': ['S', 'E', 'N', 'W'], 'W': ['N', 'W', 'S', 'E'], 'N': ['E', 'N', 'W', 'S'], 'S': ['W', 'S', 'E', 'N'] } time = 0 while people and time <= 180: # Step 1: Update  facing = person # Check right, front, left, back found_dir = None for  r + dr, c +  nc < W: cell = grid[nr][nc] if cell == '.' or cell == 'X': # Check if occupied by another person occupied = False for other in people: if other[0] == nr and other[1] == nc: occupied =  found_dir: new_people.append([r, c, found_dir]) else: new_people.append([r, c, facing]) people = new_people # Step 2: Move  = person dr, dc = dir_map[facing] nr, nc = r + dr, c + dc if 0 <= nr < H and 0 <= nc <   = [] targets[(nr, nc)].append((idx, r, c)) # Resolve conflicts moved = set() new_people = [] for target, candidates in targets.items(): if len(candidates) == 1: idx, r, c = candidates[0] moved.add(idx) else: # Priority: E, N, W, S priority_order =   for idx,  == sc: selected =  is  nr, nc  it's an exit  time += 1 if people: print(\"NA\") else: print(time) solve()"], "perturbed_original": ["import sys direction = {'N' : 0, 'E' : 1, 'S' : 2, 'W' : 3}  ( 1, 0 ), (   = [ ( i, j, direction[  j in range( W ) if m[i][j] in \"NESW\"  1 if time > 180: time  len( people ) ): if people[n] is None: continue x, y, d = people[n] for i in range(1, -3,  0 <=  sched  y+dy ) == ( xx, yy ): if dd < (d + i) % 4: sched[k] = ( n, x+dx, y+dy, (d +  = False break if beat: sched.append( ( n, x+dx, y+dy, (d + i) % 4 ) ) break for ( k, x, y, d ) in sched: m[ people[k][0] ][ people[k][1] ] = '.' if m[x][y] == 'X': people[k] = None else: m[x][y] = 'H' people[k] = x, y, d if time >= 0: vv.append(time) else: vv.append('NA') for v in vv: print v"], "original_ll": -0.8710459470748901, "sampled_ll": -0.6236153244972229, "all_perturbed_sampled_ll": [-1.8784328699111938], "all_perturbed_original_ll": [-2.1697654724121094], "perturbed_sampled_ll": -1.8784328699111938, "perturbed_original_ll": -2.1697654724121094, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#define N 10\ntypedef unsigned long long int INT;\nINT GCD(INT a, INT b){\n\tif( b == 0 ) return a;\n\telse return GCD(b,a%b);\n}\nINT LCM(INT a, INT b){\n\treturn (a/GCD(a,b))*b;\n}\nint main(){\n\twhile(1){\n\t\tint i,n;\n\t\tINT d[N];\n\t\tINT v[N];\n\t\tINT Rates[N];\n\t\tINT lcmV = 1;\n\t\tINT gcdRates = 1;\n\t\tINT lcmRates = 1;\n\n\t\tscanf(\"%d\",&n);\n\t\tif(0==n)break;\n\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tint td, tv;\n\t\t\tint gcd;\n\t\t\tscanf(\"%d%d\",&td,&tv);\n\t\t\tgcd = GCD(td,tv);\n\t\t\td[i] = (INT)td/gcd;\n\t\t\tv[i] = (INT)tv/gcd;\n\t\t}\n\t\t\n\t\tlcmV = LCM( v[0], v[1] );\n\t\tfor(i = 2; i < n; ++i){\n\t\t\tlcmV = LCM( lcmV, v[i] );\n\t\t}\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tRates[i] = (lcmV / v[i])*d[i];\n\t\t}\n\t\tgcdRates = GCD( Rates[0], Rates[1] );\n\t\tfor(i = 2; i < n; ++i){\n\t\t\tgcdRates = GCD( gcdRates, Rates[i] );\n\t\t}\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tRates[i] /= gcdRates;\n\t\t}\n\t\tlcmRates = LCM( Rates[0], Rates[1] );\n\t\tfor(i = 2; i < n; ++i){\n\t\t\tlcmRates = LCM( lcmRates, Rates[i] );\n\t\t}\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tprintf(\"%u\\n\", (unsigned int)(lcmRates / Rates[i]));\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long lcm(long long a, long long b) {\n    return (a / gcd(a, b)) * b;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long times[10];\n        long long d, v;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%lld %lld\", &d, &v);\n            long long g = gcd(d, v);\n            d /= g;\n            v /= g;\n            times[i] = d;\n        }\n        \n        long long lcm_time = times[0];\n        for (int i = 1; i < n; i++) {\n            lcm_time = lcm(lcm_time, times[i]);\n        }\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%lld\\n\", lcm_time / times[i]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> long long gcd(long long a, long long b) { while (b != 0) { long long temp =  return a; } long long lcm(long long a, long long b) { return  != 0) { long long times[10]; long long d, v; for (int i = 0; i < n; i++) { scanf(\"%lld %lld\", &d, &v); long long g = gcd(d,  } long long lcm_time =   0; i <  0; }"], "perturbed_original": ["#include<stdio.h> #define   else return GCD(b,a%b); }  while(1){ int i,n; INT d[N]; INT v[N]; INT Rates[N]; INT  1; scanf(\"%d\",&n); if(0==n)break; for(i = 0; i < n; ++i){  = (INT)td/gcd; v[i] = (INT)tv/gcd; }  <  = 0; i < n; ++i){ Rates[i] = (lcmV  = 2; i < n; ++i){ gcdRates = GCD( gcdRates, Rates[i] ); } for(i  lcmRates = LCM( Rates[0], Rates[1] ); for(i = 2; i < n; ++i){ lcmRates = LCM( lcmRates, Rates[i] ); } for(i = 0; i < n; ++i){ printf(\"%u\\n\", (unsigned int)(lcmRates / Rates[i])); } } return 0; }"], "original_ll": -0.6895124316215515, "sampled_ll": -0.41011619567871094, "all_perturbed_sampled_ll": [-2.004382610321045], "all_perturbed_original_ll": [-2.0102651119232178], "perturbed_sampled_ll": -2.004382610321045, "perturbed_original_ll": -2.0102651119232178, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.Scanner;\nimport java.math.BigInteger;\n\npublic class Main\n{\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner cin = new Scanner(System.in);\n\t\t\n\t\tint n;\n\t\twhile(true)\n\t\t{\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\n\t\t\tBigInteger   p = new BigInteger(\"1\"); \n\t\t\tBigInteger[] s = new BigInteger[10];\n\t\t\tBigInteger[] t = new BigInteger[10];\n\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\ts[i] = new BigInteger(cin.next());\n\t\t\t\tt[i] = new BigInteger(cin.next());\n\t\t\t\t\n\t\t\t\tp = t[i].multiply( p.divide( p.gcd(t[i]) ));\n\t\t\t}\n\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\ts[i] = s[i].multiply( p.divide(t[i]) );\n\t\t\t}\n\t\t\t\n\t\t\tp = new BigInteger(\"1\");\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tp = s[i].multiply( p.divide( p.gcd(s[i]) ));\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tSystem.out.println(p.divide(s[i]));\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            long[] d = new long[n];\n            long[] v = new long[n];\n            \n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                d[i] = Long.parseLong(parts[0]);\n                v[i] = Long.parseLong(parts[1]);\n            }\n            \n            // Calculate time for each student to complete one lap\n            // time = distance / speed = d / v\n            // We need to find LCM of all times\n            // time_i = d_i / v_i\n            // To avoid floating point, we work with fractions\n            \n            // Reduce each fraction d_i / v_i\n            long[] numerators = new long[n];\n            long[] denominators = new long[n];\n            \n            for (int i = 0; i < n; i++) {\n                long g = gcd(d[i], v[i]);\n                numerators[i] = d[i] / g;\n                denominators[i] = v[i] / g;\n            }\n            \n            // Find LCM of fractions: LCM(a/b, c/d) = LCM(a,c) / GCD(b,d)\n            long lcmNum = numerators[0];\n            long lcmDen = denominators[0];\n            \n            for (int i = 1; i < n; i++) {\n                lcmNum = lcm(lcmNum, numerators[i]);\n                lcmDen = gcd(lcmDen, denominators[i]);\n            }\n            \n            // The total time when all meet is lcmNum / lcmDen\n            // Number of laps for student i = (lcmNum / lcmDen) / (numerators[i] / denominators[i])\n            //                               = (lcmNum / lcmDen) * (denominators[i] / numerators[i])\n            //                               = (lcmNum * denominators[i]) / (lcmDen * numerators[i])\n            \n            for (int i = 0; i < n; i++) {\n                long laps = (lcmNum * denominators[i]) / (lcmDen * numerators[i]);\n                System.out.println(laps);\n            }\n        }\n    }\n    \n    static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n    \n    static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public  {   long[] v =  i++) { String[]  // Calculate time for each student to complete one lap // time = distance / speed = d / v // We  d_i / v_i // To avoid floating point, we work with fractions // Reduce each fraction d_i /  long[n]; for (int i = 0; i < n; i++) { long g = gcd(d[i], v[i]); numerators[i] = d[i] / g; denominators[i] = v[i] / g; } // Find LCM of fractions: LCM(a/b, c/d) = LCM(a,c) / GCD(b,d) long lcmNum = numerators[0]; long lcmDen = denominators[0]; for (int i = 1; i < n; i++)  // The total time when all meet is lcmNum / lcmDen // Number of laps  denominators[i]) // = (lcmNum / lcmDen) * (denominators[i] / numerators[i]) // = (lcmNum * denominators[i]) / (lcmDen * numerators[i]) for (int i = 0; i < n; i++)  temp = b; b = a % b; a = temp;  }"], "perturbed_original": ["import java.io.*; new BigInteger(\"1\");<extra_id_10>= s[i].multiply int n; while(true) { n = cin.nextInt(); if(n==0) break; BigInteger p = new BigInteger(\"1\");  for(int  new BigInteger(cin.next()); p = t[i].multiply( p.divide( p.gcd(t[i]) )); } for(int i=0; i<n;  new BigInteger(\"1\"); for(int i=0; i<n; i++) { p = s[i].multiply( p.divide( p.gcd(s[i]) )); } for(int i=0; i<n; i++) { System.out.println(p.divide(s[i])); } } } }"], "original_ll": -0.7431703209877014, "sampled_ll": -0.5624958276748657, "all_perturbed_sampled_ll": [-1.7953828573226929], "all_perturbed_original_ll": [-2.252506971359253], "perturbed_sampled_ll": -1.7953828573226929, "perturbed_original_ll": -2.252506971359253, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\"\"\" Created by Jieyi on 10/4/16. \"\"\"\nimport io\nimport sys\n\nif len(sys.argv) > 1:\n    filename = sys.argv[1]\n    inp = ''.join(open(filename, \"r\").readlines())\n    sys.stdin = io.StringIO(inp)\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n\n    return x\n\n\ndef lcm(x, y):\n    l_lcm = (x * y) // gcd(x, y)\n    return l_lcm\n\n\ndef mul_lcm(array):\n    l = lcm(array[0], array[1])\n    if len(array) > 3:\n        for i in range(2, len(array)):\n            l = lcm(array[i], l)\n    return l\n\n\ndef algorithm(students):\n    denominator_lcm = mul_lcm([y for _, y in students])\n    for i in range(len(students)):\n        students[i][0] *= int(denominator_lcm / students[i][1])\n    molecular_lcm = mul_lcm([x for x, _ in students])\n\n    return [int(molecular_lcm / students[i][0]) for i in range(len(students))]\n\n\ndef input_sample():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n\n        students = []\n        for _ in range(n):\n            students.append(list(map(int, input().split())))\n        answer_list = algorithm(students)\n        for ans in answer_list:\n            print(ans)\n\n\ndef main():\n    input_sample()\n\n\nif __name__ == '__main__':\n    main()", "sampled": "from math import gcd\nfrom fractions import Fraction\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef lcm_multiple(numbers):\n    result = numbers[0]\n    for num in numbers[1:]:\n        result = lcm(result, num)\n    return result\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    students = []\n    for _ in range(n):\n        d, v = map(int, input().split())\n        students.append((d, v))\n    \n    # Calculate time for one lap for each student as a fraction\n    times = []\n    for d, v in students:\n        times.append(Fraction(d, v))\n    \n    # Find LCM of all times\n    # LCM of fractions a/b and c/d is LCM(a,c)/GCD(b,d)\n    numerators = [t.numerator for t in times]\n    denominators = [t.denominator for t in times]\n    \n    lcm_num = lcm_multiple(numerators)\n    gcd_den = denominators[0]\n    for den in denominators[1:]:\n        gcd_den = gcd(gcd_den, den)\n    \n    meeting_time = Fraction(lcm_num, gcd_den)\n    \n    # Calculate laps for each student\n    for time in times:\n        laps = meeting_time / time\n        print(int(laps))\n", "perturbed_sampled": ["from math  a * b // gcd(a, b) def lcm_multiple(numbers): result = numbers[0] for num in numbers[1:]: result = lcm(result, num) return  v = map(int,  d, v in students: times.append(Fraction(d, v)) # Find LCM  is LCM(a,c)/GCD(b,d) numerators = [t.numerator for t in times] denominators = [t.denominator for t in times] lcm_num = lcm_multiple(numerators) gcd_den = denominators[0] for den in denominators[1:]: gcd_den = gcd(gcd_den, den) meeting_time = Fraction(lcm_num, gcd_den) # Calculate laps for each  print(int(laps))"], "perturbed_original": ["\"\"\" Created by Jieyi on 10/4/16. \"\"\" import io import sys if len(sys.argv) > 1: filename = sys.argv[1] inp =  def lcm(x, y): l_lcm = (x * y) // gcd(x, y) return l_lcm def mul_lcm(array): l = lcm(array[0], array[1]) if len(array) > 3: for i in range(2, len(array)): l = lcm(array[i], l) return  students]) for i in  i in range(len(students))] def  input().split()))) answer_list = algorithm(students) for ans in answer_list: print(ans) def main(): input_sample() if __name__ == '__main__': main()"], "original_ll": -0.9410833716392517, "sampled_ll": -0.7795513272285461, "all_perturbed_sampled_ll": [-2.147517204284668], "all_perturbed_original_ll": [-2.051137924194336], "perturbed_sampled_ll": -2.147517204284668, "perturbed_original_ll": -2.051137924194336, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\n#define INF 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[11][101];\n\nint W[101][101];\nint c, V, n, s, d;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nvoid dijkstra(int start) {\n    int i, x, p, step;\n    for (i = 0; i <= c; i++) {\n\tfor (x = 1; x <= n; x++) {\n\t    vertex[i][x].distance = INF; vertex[i][x].state = 0;\n\t}\n\tvertex[i][start].distance = 0; \n    }\n    for (i = 0; i <= c; i++) {\n\tfor (step = 1; step <= n; step++) {\n\t    int minimum = INF;\n\t    for (x = 1; x <= n; x++)\n\t\tif (vertex[i][x].state == 0 && vertex[i][x].distance < minimum) {\n\t\t    p = x; minimum = vertex[i][x].distance;\n\t\t}\n\t    vertex[i][p].state = 1;\n\t    for (x = 1 ; x <= n; x++)\n\t\tif (vertex[i][x].state == 0) {\n\t\t    if (i == 0)\n\t\t\tvertex[i][x].distance = min(vertex[i][x].distance, \n\t\t\t\t\t\t    vertex[i][p].distance+W[p][x]);\n\t\t    else\n\t\t\tvertex[i][x].distance = min(vertex[i][x].distance, \n\t\t\t\t\t\t    min(vertex[i][p].distance+W[p][x],\n\t\t\t\t\t\t\tvertex[i-1][p].distance+W[p][x]/2));\n\t\t}\n\t}\n    }\n}\n\nint main(void) {\n    int i, j;\n    int from, to, m;\n     \n    while (1) {\n\tscanf(\"%d%d%d%d%d\", &c, &V, &n, &s, &d);\n        if (c + V + n + s + d == 0) break;\n         \n        for (i = 0; i <= V; i++)\n            for (j = 0; j <= V; j++)\n                W[i][j] = INF;\n         \n\tfor (i = 0; i < n; i++) {\n            scanf(\"%d%d%d\", &from, &to, &m);\n            W[from][to] = m;\n\t    W[to][from] = m;\n        }\n         \n        dijkstra(s);\n\tprintf(\"%d\\n\", vertex[c][d].distance);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 101\n#define MAX_M 501\n#define INF INT_MAX\n\ntypedef struct {\n    int to;\n    int cost;\n} Edge;\n\nEdge edges[MAX_M * 2];\nint head[MAX_N];\nint next_edge[MAX_M * 2];\nint edge_count;\n\nvoid add_edge(int from, int to, int cost) {\n    edges[edge_count].to = to;\n    edges[edge_count].cost = cost;\n    next_edge[edge_count] = head[from];\n    head[from] = edge_count;\n    edge_count++;\n}\n\ntypedef struct {\n    int node;\n    int tickets_used;\n    int cost;\n} State;\n\nState queue[MAX_N * 12];\nint queue_start, queue_end;\n\nvoid enqueue(int node, int tickets, int cost) {\n    queue[queue_end].node = node;\n    queue[queue_end].tickets_used = tickets;\n    queue[queue_end].cost = cost;\n    queue_end++;\n}\n\nState dequeue() {\n    return queue[queue_start++];\n}\n\nint min_cost[MAX_N][12];\n\nint dijkstra(int n, int s, int d, int c) {\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= c; j++) {\n            min_cost[i][j] = INF;\n        }\n    }\n    \n    queue_start = 0;\n    queue_end = 0;\n    enqueue(s, 0, 0);\n    min_cost[s][0] = 0;\n    \n    while (queue_start < queue_end) {\n        State current = dequeue();\n        int u = current.node;\n        int tickets = current.tickets_used;\n        int curr_cost = current.cost;\n        \n        if (curr_cost > min_cost[u][tickets]) {\n            continue;\n        }\n        \n        for (int e = head[u]; e != -1; e = next_edge[e]) {\n            int v = edges[e].to;\n            int edge_cost = edges[e].cost;\n            \n            // Without using discount\n            int new_cost = curr_cost + edge_cost;\n            if (new_cost < min_cost[v][tickets]) {\n                min_cost[v][tickets] = new_cost;\n                enqueue(v, tickets, new_cost);\n            }\n            \n            // With discount\n            if (tickets < c) {\n                int discounted_cost = curr_cost + edge_cost / 2;\n                if (discounted_cost < min_cost[v][tickets + 1]) {\n                    min_cost[v][tickets + 1] = discounted_cost;\n                    enqueue(v, tickets + 1, discounted_cost);\n                }\n            }\n        }\n    }\n    \n    int result = INF;\n    for (int i = 0; i <= c; i++) {\n        if (min_cost[d][i] < result) {\n            result = min_cost[d][i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    int c, n, m, s, d;\n    \n    while (1) {\n        scanf(\"%d %d %d %d %d\", &c, &n, &m, &s, &d);\n        if (c == 0 && n == 0 && m == 0 && s == 0 && d == 0) {\n            break;\n        }\n        \n        edge_count = 0;\n        for (int i = 0; i <= n; i++) {\n            head[i] = -1;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int a, b, f;\n            scanf(\"%d %d %d\", &a, &b, &f);\n            add_edge(a, b, f);\n            add_edge(b, a, f);\n        }\n        \n        int result = dijkstra(n, s, d, c);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h> #define MAX_N 101 #define MAX_M 501 #define INF INT_MAX typedef struct { int to; int cost; } Edge; Edge edges[MAX_M * 2]; int head[MAX_N]; int next_edge[MAX_M * 2]; int edge_count; void add_edge(int from, int to, int cost) { edges[edge_count].to  edge_count; edge_count++; } typedef struct { int node; int tickets_used; int cost; } State; State queue[MAX_N * 12]; int queue_start, queue_end; void enqueue(int  { return queue[queue_start++]; } int min_cost[MAX_N][12]; int dijkstra(int  min_cost[i][j] = INF; } } queue_start = 0; queue_end = 0; enqueue(s, 0, 0); min_cost[s][0] = 0; while (queue_start <  int tickets =  continue; } for (int e = head[u]; e != -1; e = next_edge[e]) { int v = edges[e].to; int edge_cost = edges[e].cost; //  1] =  i <= c; i++) { if (min_cost[d][i] < result) { result = min_cost[d][i]; } } return result; } int main() { int c, n, m, s, d; while (1) { scanf(\"%d %d %d %d %d\", &c, &n, &m, &s, &d); if (c == 0  == 0 && d ==  = 0; i <= n;  0; i  %d\", &a, &b, &f); add_edge(a, b, f); add_edge(b, a, f); } int result = dijkstra(n, s, d, c); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> #define INF 100000000 struct NODE {  } void dijkstra(int start) { int i, x, p, step; for (i = 0; i <= c; i++) { for (x = 1; x <= n; x++) { vertex[i][x].distance =   = 1; step <= n; step++) {  n; x++) if (vertex[i][x].state == 0 && vertex[i][x].distance < minimum) { p = x; minimum = vertex[i][x].distance; } vertex[i][p].state = 1; for (x = 1 ;  (i == 0) vertex[i][x].distance = min(vertex[i][x].distance, vertex[i][p].distance+W[p][x]); else vertex[i][x].distance = min(vertex[i][x].distance, min(vertex[i][p].distance+W[p][x], vertex[i-1][p].distance+W[p][x]/2)); } } } } int  (1) { scanf(\"%d%d%d%d%d\", &c,  + s + d == 0) break; for (i = 0; i <= V; i++) for (j =  &to, &m); W[from][to] = m; W[to][from] = m; } dijkstra(s); printf(\"%d\\n\", vertex[c][d].distance); } return 0; }"], "original_ll": -0.6391676068305969, "sampled_ll": -0.3601705729961395, "all_perturbed_sampled_ll": [-1.4032313823699951], "all_perturbed_original_ll": [-1.5536680221557617], "perturbed_sampled_ll": -1.4032313823699951, "perturbed_original_ll": -1.5536680221557617, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String arg[])\n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=1000001;\n\t\tfor(;;)\n\t\t{\n\t\t\tint c=in.nextInt();//\u30c1\u30b1\u30c3\u30c8\u306e\u6570\n\t\t\tint n=in.nextInt(),m=in.nextInt();//\u30d0\u30b9\u505c\u306e\u6570,\u9053\u306e\u6570\n\t\t\tint s=in.nextInt(),d=in.nextInt();//\u30b9\u30bf\u30fc\u30c8&\u30b4\u30fc\u30eb\n\t\t\tif((c|n|m|s|d)==0)\n\t\t\t\treturn;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tfor(int q[]: cost) {\n\t\t\t\tArrays.fill(q, M);\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint a=in.nextInt();\n\t\t\t\tint b=in.nextInt();\n\t\t\t\tint f=in.nextInt();\n\t\t\t\tcost[a][b]=f;\n\t\t\t\tcost[b][a]=f;\n\t\t\t}\n\t\t\tint p=0,w=0;\n\t\t\tint v[][] = new int[n+1][c+1];// decision flag\n\t\t\tint leng[][]=new int[n+1][c+1];// minimum distance\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int k=0;k<=c;k++)\n\t\t\t\t{\n\t\t\t\t\tleng[i][k]=M;\n\t\t\t\t\tv[i][k]=0;\n\t\t\t\t}\n\t\t\tleng[s][c]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tint min=M;//\u6700\u5c0f\u306e\u7bc0\u70b9\u3092\u63a2\u3059\n\t\t\t\tfor(int l=1;l<=n;l++)\n\t\t\t\t\tfor(int k=1;k<=c;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(v[l][k]==0&&leng[l][k]<min)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp=l;\n\t\t\t\t\t\t\tw=k;\n\t\t\t\t\t\t\tmin=leng[l][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(min==M)\n\t\t\t\t\tbreak;\n\t\t\t\tv[p][w]=1;//\u78ba\u5b9a\u30d5\u30e9\u30b0\n\t\t\t\tfor(int l=1;l<=n;l++) //p\u3092\u7d4c\u7531\u3057\u3066l\u306b\u81f3\u308b\u9577\u3055\u304c\u305d\u308c\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\u3088\u308a\u5c0f\u3055\u3051\u308c\u3070\u66f4\u65b0\n\t\t\t\t{\n\t\t\t\t\tleng[l][w]=Math.min(leng[l][w], leng[p][w]+cost[p][l]);\n\t\t\t\t\tif (w>0)\n\t\t\t\t\t\tleng[l][w-1]=Math.min(leng[l][w-1], leng[p][w]+cost[p][l]/2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(leng[d][0]);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, cost;\n        Edge(int to, int cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        int node, couponsUsed, cost;\n        \n        State(int node, int couponsUsed, int cost) {\n            this.node = node;\n            this.couponsUsed = couponsUsed;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int c = sc.nextInt();\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            int d = sc.nextInt();\n            \n            if (c == 0 && n == 0 && m == 0 && s == 0 && d == 0) {\n                break;\n            }\n            \n            List<List<Edge>> graph = new ArrayList<>();\n            for (int i = 0; i <= n; i++) {\n                graph.add(new ArrayList<>());\n            }\n            \n            for (int i = 0; i < m; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int f = sc.nextInt();\n                graph.get(a).add(new Edge(b, f));\n                graph.get(b).add(new Edge(a, f));\n            }\n            \n            int result = dijkstra(graph, n, c, s, d);\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n    \n    static int dijkstra(List<List<Edge>> graph, int n, int c, int s, int d) {\n        int[][] dist = new int[n + 1][c + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(dist[i], Integer.MAX_VALUE);\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(s, 0, 0));\n        dist[s][0] = 0;\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            if (current.node == d) {\n                return current.cost;\n            }\n            \n            if (current.cost > dist[current.node][current.couponsUsed]) {\n                continue;\n            }\n            \n            for (Edge edge : graph.get(current.node)) {\n                // Without using coupon\n                int newCost = current.cost + edge.cost;\n                if (newCost < dist[edge.to][current.couponsUsed]) {\n                    dist[edge.to][current.couponsUsed] = newCost;\n                    pq.offer(new State(edge.to, current.couponsUsed, newCost));\n                }\n                \n                // With using coupon\n                if (current.couponsUsed < c) {\n                    int discountedCost = current.cost + edge.cost / 2;\n                    if (discountedCost < dist[edge.to][current.couponsUsed + 1]) {\n                        dist[edge.to][current.couponsUsed + 1] = discountedCost;\n                        pq.offer(new State(edge.to, current.couponsUsed + 1, discountedCost));\n                    }\n                }\n            }\n        }\n        \n        int minCost = Integer.MAX_VALUE;\n        for (int i = 0; i <= c; i++) {\n            minCost = Math.min(minCost, dist[d][i]);\n        }\n        \n        return minCost;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Edge { int to, cost; Edge(int to, int cost) { this.to = to; this.cost   { this.node = node; this.couponsUsed = couponsUsed; this.cost = cost; } @Override public int compareTo(State other) {  { Scanner sc = new Scanner(System.in); while (true) {  = sc.nextInt(); int s = sc.nextInt();  0 && d == 0) { break; } List<List<Edge>> graph  n;  i < m; i++) {  = sc.nextInt(); graph.get(a).add(new Edge(b, f)); graph.get(b).add(new Edge(a, f)); } int result = dijkstra(graph, n, c, s, d); System.out.println(result); } sc.close(); } static int dijkstra(List<List<Edge>> graph, int n, int c, int s, int d) { int[][] dist =  0; i <= n;  { return current.cost; } if (current.cost > dist[current.node][current.couponsUsed]) {  using coupon  { dist[edge.to][current.couponsUsed] = newCost; pq.offer(new State(edge.to, current.couponsUsed, newCost)); } // With using coupon if (current.couponsUsed < c) { int discountedCost = current.cost + edge.cost / 2; if (discountedCost < dist[edge.to][current.couponsUsed + 1]) {  discountedCost)); } } } } int minCost = Integer.MAX_VALUE; for (int  Math.min(minCost, dist[d][i]); } return minCost; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { public static  { int c=in.nextInt();//\u30c1\u30b1\u30c3\u30c8\u306e\u6570 int n=in.nextInt(),m=in.nextInt();//\u30d0\u30b9\u505c\u306e\u6570,\u9053\u306e\u6570 int s=in.nextInt(),d=in.nextInt();//\u30b9\u30bf\u30fc\u30c8&\u30b4\u30fc\u30eb if((c|n|m|s|d)==0) return; int cost[][]=new int[n+1][n+1];  int b=in.nextInt(); int f=in.nextInt(); cost[a][b]=f; cost[b][a]=f; } int p=0,w=0; int v[][] = new int[n+1][c+1];//  k=0;k<=c;k++) { leng[i][k]=M; v[i][k]=0; } leng[s][c]=0; for(;;) { int min=M;//\u6700\u5c0f\u306e\u7bc0\u70b9\u3092\u63a2\u3059 for(int l=1;l<=n;l++) for(int k=1;k<=c;k++) { if(v[l][k]==0&&leng[l][k]<min) {  //p\u3092\u7d4c\u7531\u3057\u3066l\u306b\u81f3\u308b\u9577\u3055\u304c\u305d\u308c\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\u3088\u308a\u5c0f\u3055\u3051\u308c\u3070\u66f4\u65b0 { leng[l][w]=Math.min(leng[l][w], leng[p][w]+cost[p][l]); if (w>0) leng[l][w-1]=Math.min(leng[l][w-1], leng[p][w]+cost[p][l]/2); } } System.out.println(leng[d][0]); } } }"], "original_ll": -0.9020626544952393, "sampled_ll": -0.2897029221057892, "all_perturbed_sampled_ll": [-1.5405110120773315], "all_perturbed_original_ll": [-1.8208976984024048], "perturbed_sampled_ll": -1.5405110120773315, "perturbed_original_ll": -1.8208976984024048, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from sys import stdin\nreadline = stdin.readline\n\n\n\nfrom collections import namedtuple\nRunner = namedtuple('Runner', 'd v')\n\ndef main():\n    while True:\n        ticket, vertex, edge, start, destination = map(int, readline().split())\n        if ticket == 0:\n            break\n\n        start -= 1\n        destination -= 1\n        g = defaultdict(list)\n        for i in range(edge):\n            s, t, length = map(int, readline().split())\n            s -= 1\n            t -= 1\n            g[s].append((length, t))\n            g[t].append((length, s))\n        \n        d = ex_dijkstra(g, vertex, start, ticket)\n        print(min(d[destination]))\n\n\n\nfrom heapq import heappush, heappop\nfrom collections import defaultdict\ndef ex_dijkstra(g, size, start, ticket):\n    d = [[float('inf')] * (ticket + 1) for i in range(size)]\n    d[start][ticket] = 0\n    heap = [(d[start][ticket], start, ticket)]\n    while heap:\n        du, u, ticket = heappop(heap)\n        for length, v in g[u]:\n            if d[v][ticket] > du + length:\n                d[v][ticket] = du + length\n                heappush(heap,(d[v][ticket], v, ticket))\n            if ticket and d[v][ticket - 1] > du + length // 2:\n                d[v][ticket - 1] = du + length // 2\n                heappush(heap,(d[v][ticket - 1], v, ticket - 1))\n\n    return d\n\nmain()", "sampled": "import heapq\nfrom sys import stdin\n\ndef solve(c, n, m, s, d, edges):\n    # Build adjacency list\n    graph = [[] for _ in range(n + 1)]\n    for a, b, f in edges:\n        graph[a].append((b, f))\n        graph[b].append((a, f))\n    \n    # Dijkstra with state (cost, node, discounts_used)\n    # We need to track how many discounts we've used\n    dist = {}  # (node, discounts_used) -> min_cost\n    pq = [(0, s, 0)]  # (cost, node, discounts_used)\n    dist[(s, 0)] = 0\n    \n    while pq:\n        cost, node, discounts_used = heapq.heappop(pq)\n        \n        if node == d:\n            continue\n        \n        if (node, discounts_used) in dist and dist[(node, discounts_used)] < cost:\n            continue\n        \n        for next_node, fare in graph[node]:\n            # Option 1: Don't use discount\n            new_cost = cost + fare\n            if (next_node, discounts_used) not in dist or dist[(next_node, discounts_used)] > new_cost:\n                dist[(next_node, discounts_used)] = new_cost\n                heapq.heappush(pq, (new_cost, next_node, discounts_used))\n            \n            # Option 2: Use discount if available\n            if discounts_used < c:\n                new_cost = cost + fare // 2\n                if (next_node, discounts_used + 1) not in dist or dist[(next_node, discounts_used + 1)] > new_cost:\n                    dist[(next_node, discounts_used + 1)] = new_cost\n                    heapq.heappush(pq, (new_cost, next_node, discounts_used + 1))\n    \n    # Find minimum cost to reach destination with any number of discounts used\n    min_cost = float('inf')\n    for i in range(c + 1):\n        if (d, i) in dist:\n            min_cost = min(min_cost, dist[(d, i)])\n    \n    return min_cost\n\n# Read input\nlines = []\nfor line in stdin:\n    lines.append(line.strip())\n\ni = 0\nwhile i < len(lines):\n    parts = lines[i].split()\n    c, n, m, s, d = map(int, parts)\n    if c == 0 and n == 0 and m == 0 and s == 0 and d == 0:\n        break\n    \n    edges = []\n    for j in range(m):\n        i += 1\n        a, b, f = map(int, lines[i].split())\n        edges.append((a, b, f))\n    \n    result = solve(c, n, m, s, d, edges)\n    print(result)\n    \n    i += 1\n", "perturbed_sampled": ["import heapq from sys import stdin def solve(c, n,  [[] for _ in range(n + 1)] for a, b, f in edges: graph[a].append((b, f)) graph[b].append((a, f)) # Dijkstra with state (cost, node, discounts_used) # We need to track how many discounts we've used dist = {} # (node, discounts_used) -> min_cost pq = [(0, s, 0)] # (cost, node, discounts_used) dist[(s, 0)]  in graph[node]: # Option 1: Don't use discount new_cost = cost + fare if (next_node, discounts_used)  = new_cost heapq.heappush(pq, (new_cost, next_node, discounts_used)) # Option 2: Use discount if  // 2 if (next_node, discounts_used  to reach  for i in range(c + 1): if (d, i) in dist: min_cost = min(min_cost, dist[(d, i)]) return min_cost # Read input lines = [] for line in  = lines[i].split() c, n, m, s, d = map(int, parts) if c == 0 and n == 0 and m == 0 and  b, f  m, s, d, edges) print(result) i += 1"], "perturbed_original": ["from sys import stdin readline = stdin.readline from collections import namedtuple Runner = namedtuple('Runner', 'd v') def main(): while True: ticket, vertex, edge, start, destination  in range(edge): s, t, length = map(int, readline().split()) s -= 1 t -= 1 g[s].append((length,  def ex_dijkstra(g, size, start, ticket): d = [[float('inf')] * (ticket +  [(d[start][ticket], start, ticket)] while heap: du, u, ticket = heappop(heap) for length, v in g[u]: if d[v][ticket] >  ticket)) if ticket and d[v][ticket  1] = du + length // 2 heappush(heap,(d[v][ticket - 1], v, ticket - 1)) return d main()"], "original_ll": -0.7874248623847961, "sampled_ll": -0.49975448846817017, "all_perturbed_sampled_ll": [-2.0808217525482178], "all_perturbed_original_ll": [-2.4862754344940186], "perturbed_sampled_ll": -2.0808217525482178, "perturbed_original_ll": -2.4862754344940186, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu 0213: Subdivide The Land\n// 2017.9.24 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { int id, x, y, k; } T;\nT tbl[16]; \nint X, Y, n;\nchar map[10][10];\nchar ans[10][10], cnt;\nint pair[101][13][2], plen[101];\n\nint cmp(T *a, T *b) { if (a->y - b->y) return a->y - b->y; return a->x - b->x; }\n\nvoid mark(int c, int x, int y, int w, int h)\n{\n\tint yy;\n\tfor (yy = 0; yy < h; yy++) memset(map[y+yy]+x, c, w);\n}\n\nint check(int c, int x, int y, int w, int h)\n{\n\tint xx, yy;\n\tfor (yy = 0; yy < h; yy++) for (xx = 0; xx < w; xx++) \n\t\tif (map[y+yy][x+xx] > 0 && map[y+yy][x+xx] != c) return 0;\n\treturn 1;\n}\n\nint combi(int i)\n{\n\tint x, y, x0, y0, id, x1, y1, h, w, j, k;\n\n\tif (i == n+1) {\n\t\tif (cnt) return 0;\n\t\tcnt = 1, memcpy(ans, map, sizeof(map));\n\t\treturn 1;\n\t}\n\tk = tbl[i].k;\n\tif (k == 1) return combi(i+1);\n\tx0 = tbl[i].x, y0 = tbl[i].y, id = tbl[i].id;\n\n\tfor (j = 0; j < plen[k]; j++) {\n\t\tw = pair[k][j][0], h = pair[k][j][1];\n\t\tx1 = x0 - w + 1, y1 = y0 - h + 1;\n\t\tif (x1 < 0) x1 = 0; if (y1 < 0) y1 = 0;\n\t\tfor (y = y1; y <= y0; y++) for (x = x1; x <= x0; x++) {\n\t\t\tif (x + w > X || y + h > Y) goto Next;\n\t\t\tif (!check(id, x, y, w, h)) continue;\n\t\t\tmark(id, x, y, w, h);\n\t\t\tif (!combi(i+1)) return 0;\n\t\t\tmark(0, x, y, w, h);\n\t\t}\nNext:;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n    int i, b, t, s, x, y;\n\n\tfor (x = 1; x <= 100; x++) for (y = 1; y <= 100; y++)\n\t\tif ((t = x * y) <= 100) pair[t][plen[t]][0] = x, pair[t][plen[t]++][1] = y;\n\n\twhile (scanf(\"%d%d%d\", &X, &Y, &n) && n > 0) {\n\t\tfor (s = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &b, &t);\n\t\t\ttbl[b].k = t, tbl[b].id = b;\n\t\t\ts += t;\n\t\t}\n\t\tfor (y = 0; y < Y; y++) for (x = 0; x < X; x++) {\n\t\t\tscanf(\"%d\", &b), map[y][x] = b;\n\t\t\tif (b > 0) tbl[b].x = x, tbl[b].y = y;\n\t\t}\n\t\tif (s != X*Y) { puts(\"NA\"); continue; }\n\t\tqsort(tbl+1, n, sizeof(T), cmp);\n\n\t\tcnt = 0;\n\t\tif (!combi(1)) puts(\"NA\");\n\t\telse for (y = 0; y < Y; y++) {\n\t\t\tprintf(\"%d\", ans[y][0]);\n\t\t\tfor (x = 1; x < X; x++) printf(\" %d\", ans[y][x]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint X, Y, n;\nint b[16], k[16];\nint s[11][11];\nint grid[11][11];\nint solutions;\n\nint isValidRectangle(int buyer, int x1, int y1, int x2, int y2) {\n    int count = 0;\n    int hasSign = 0;\n    \n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            if (grid[i][j] != 0) return 0;\n            count++;\n            if (s[i][j] == buyer) hasSign = 1;\n        }\n    }\n    \n    if (count != k[buyer] || !hasSign) return 0;\n    return 1;\n}\n\nvoid fillRectangle(int x1, int y1, int x2, int y2, int buyer) {\n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            grid[i][j] = buyer;\n        }\n    }\n}\n\nvoid clearRectangle(int x1, int y1, int x2, int y2) {\n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            grid[i][j] = 0;\n        }\n    }\n}\n\nvoid solve(int buyer) {\n    if (solutions > 1) return;\n    \n    if (buyer > n) {\n        solutions++;\n        return;\n    }\n    \n    for (int x1 = 1; x1 <= X; x1++) {\n        for (int y1 = 1; y1 <= Y; y1++) {\n            for (int x2 = x1; x2 <= X; x2++) {\n                for (int y2 = y1; y2 <= Y; y2++) {\n                    if (isValidRectangle(buyer, x1, y1, x2, y2)) {\n                        fillRectangle(x1, y1, x2, y2, buyer);\n                        solve(buyer + 1);\n                        if (solutions > 1) {\n                            clearRectangle(x1, y1, x2, y2);\n                            return;\n                        }\n                        clearRectangle(x1, y1, x2, y2);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d\", &X, &Y, &n);\n        if (X == 0 && Y == 0 && n == 0) break;\n        \n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d %d\", &b[i], &k[i]);\n        }\n        \n        for (int j = 1; j <= Y; j++) {\n            for (int i = 1; i <= X; i++) {\n                scanf(\"%d\", &s[i][j]);\n            }\n        }\n        \n        memset(grid, 0, sizeof(grid));\n        solutions = 0;\n        solve(1);\n        \n        if (solutions == 1) {\n            for (int j = 1; j <= Y; j++) {\n                for (int i = 1; i <= X; i++) {\n                    if (i > 1) printf(\" \");\n                    printf(\"%d\", grid[i][j]);\n                }\n                printf(\"\\n\");\n            }\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int X, Y, n; int b[16], k[16]; int s[11][11]; int  int hasSign = 0; for (int i = x1; i <= x2; i++)   == buyer) hasSign  y1, int x2, int y2, int buyer) { for (int i  = y1; j <= y2; j++) { grid[i][j] = buyer; } } } void clearRectangle(int x1, int y1, int x2, int y2) { for (int i =  y1; j <= y2; j++) { grid[i][j] = 0; } } } void solve(int buyer) { if (solutions > 1) return; if  = 1; x1 <=  <= X; x2++) { for (int y2 = y1; y2 <= Y; y2++) { if  buyer);  x2, y2); return; } clearRectangle(x1, y1, x2, y2); } } } } } } int main() { while (1) { scanf(\"%d %d %d\", &X, &Y,  n == 0) break; for (int i = 1; i <=  j = 1; j <= Y; j++) { for (int i = 1; i <= X; i++) { scanf(\"%d\", &s[i][j]); } } memset(grid, 0, sizeof(grid)); solutions =  = 1; j  <= X; i++) { if (i > 1) printf(\" \"); printf(\"%d\",  return 0; }"], "perturbed_original": ["// Aizu 0213: Subdivide The Land // 2017.9.24 bal4u@uu #include <stdio.h> #include <stdlib.h> #include <string.h> typedef struct { int id,  n;  mark(int c, int x, int y, int w, int h) { int yy; for (yy =  check(int c, int x, int y, int w, int h) { int xx, yy; for (yy = 0; yy < h; yy++) for (xx  &&  i) { int x, y, x0, y0, id, x1,    j++) { w    y1 = 0; for (y = y1; y <= y0; y++) for (x = x1; x <= x0; x++) { if (x + w > X || y + h > Y) goto  y, w,  } Next:; } return 1; } int main() { int i, b, t, s, x,  (y = 1; y <= 100; y++) if ((t = x * y) <= 100) pair[t][plen[t]][0] = x, pair[t][plen[t]++][1] = y; while (scanf(\"%d%d%d\", &X, &Y, &n) && n > 0) { for  scanf(\"%d%d\", &b, &t); tbl[b].k = t, tbl[b].id = b; s += t; } for  0; x < X; x++) { scanf(\"%d\", &b), map[y][x] = b; if (b > 0) tbl[b].x = x,  continue; } qsort(tbl+1, n, sizeof(T), cmp); cnt = 0; if (!combi(1)) puts(\"NA\"); else for (y = 0; y < Y; y++) { printf(\"%d\", ans[y][0]); for (x = 1; x < X; x++) printf(\" %d\", ans[y][x]); printf(\"\\n\"); } } return 0; }"], "original_ll": -0.8258897066116333, "sampled_ll": -0.4083781838417053, "all_perturbed_sampled_ll": [-1.5826894044876099], "all_perturbed_original_ll": [-1.8178613185882568], "perturbed_sampled_ll": -1.5826894044876099, "perturbed_original_ll": -1.8178613185882568, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport scala.languageFeature.postfixOps;\nimport sun.tools.jar.resources.jar;\nimport lombok.Data;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((w | h | n) == 0)\n\t\t\t\tbreak;\n\t\t\tsize = new int[n + 1];\n\t\t\tpos = new int[n + 1][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tsize[b] = k;\n\t\t\t}\n\t\t\tm = new int[h][w];\n\t\t\t\n\t\t\tfor (int[] a : m)\n\t\t\t\tArrays.fill(a, -1);\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tm[i][j] = x;\n\t\t\t\t\tif (x > 0) {\n\t\t\t\t\t\tpos[x][0] = i;\n\t\t\t\t\t\tpos[x][1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassign = new int[n + 1][4];\n\t\t\tc = 0;\n\t\t\tans = new int[h][w];\n\t\t\tf(1);\n\t\t\tif (c == 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate void f(int k) {\n\t\tif (k == n + 1) {\n\t\t\tc++;\n\t\t\tif (c == 2)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint a = m[i][j];\n\t\t\t\t\tans[i][j] = a >= 100 ? a / 100 : a;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = size[k];\n\t\tfor (int x = 1; x <= s; x++) {\n\t\t\tif (s % x != 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int lj = pos[k][1] + 1 - x; lj <= pos[k][1]; lj++) {\n\t\t\t\tif (lj < 0 || lj > w)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int li = pos[k][0] + 1 - s / x; li <= pos[k][0]; li++) {\n\t\t\t\t\tif (li < 0 || li > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint rj = lj + x;\n\t\t\t\t\tint ri = li + s / x;\n\t\t\t\t\tif (rj > w)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (ri > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != 0 && m[i][j] != k)\n\t\t\t\t\t\t\t\tcontinue loop;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = k * 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf(k + 1);\n\t\t\t\t\tif (c == 2)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tint[][] m;\n\tint[] size;\n\tint[][] pos;\n\tint[][] assign;\n\tint w, h, n, c;\n\tint[][] ans;\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int X, Y, n;\n    static int[] buyers;\n    static int[] counts;\n    static int[][] signs;\n    static List<int[][]> validSolutions;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            X = sc.nextInt();\n            Y = sc.nextInt();\n            n = sc.nextInt();\n            \n            if (X == 0 && Y == 0 && n == 0) break;\n            \n            buyers = new int[n];\n            counts = new int[n];\n            \n            for (int i = 0; i < n; i++) {\n                buyers[i] = sc.nextInt();\n                counts[i] = sc.nextInt();\n            }\n            \n            signs = new int[Y][X];\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    signs[i][j] = sc.nextInt();\n                }\n            }\n            \n            validSolutions = new ArrayList<>();\n            int[][] grid = new int[Y][X];\n            boolean[] used = new boolean[n];\n            \n            backtrack(grid, used, 0);\n            \n            if (validSolutions.size() == 0) {\n                System.out.println(\"NA\");\n            } else if (validSolutions.size() > 1) {\n                System.out.println(\"NA\");\n            } else {\n                int[][] sol = validSolutions.get(0);\n                for (int i = 0; i < Y; i++) {\n                    for (int j = 0; j < X; j++) {\n                        if (j > 0) System.out.print(\" \");\n                        System.out.print(sol[i][j]);\n                    }\n                    System.out.println();\n                }\n            }\n        }\n    }\n    \n    static void backtrack(int[][] grid, boolean[] used, int buyerIdx) {\n        if (buyerIdx == n) {\n            if (isValidComplete(grid)) {\n                int[][] copy = new int[Y][X];\n                for (int i = 0; i < Y; i++) {\n                    for (int j = 0; j < X; j++) {\n                        copy[i][j] = grid[i][j];\n                    }\n                }\n                validSolutions.add(copy);\n            }\n            return;\n        }\n        \n        if (validSolutions.size() > 1) return;\n        \n        int buyer = -1;\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                buyer = i;\n                break;\n            }\n        }\n        \n        if (buyer == -1) return;\n        \n        int buyerNum = buyers[buyer];\n        int count = counts[buyer];\n        \n        for (int y1 = 0; y1 < Y; y1++) {\n            for (int x1 = 0; x1 < X; x1++) {\n                for (int y2 = y1; y2 < Y; y2++) {\n                    for (int x2 = x1; x2 < X; x2++) {\n                        int w = x2 - x1 + 1;\n                        int h = y2 - y1 + 1;\n                        if (w * h != count) continue;\n                        \n                        if (canPlace(grid, x1, y1, x2, y2, buyerNum)) {\n                            place(grid, x1, y1, x2, y2, buyerNum);\n                            used[buyer] = true;\n                            backtrack(grid, used, buyerIdx + 1);\n                            used[buyer] = false;\n                            place(grid, x1, y1, x2, y2, 0);\n                            \n                            if (validSolutions.size() > 1) return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    static boolean canPlace(int[][] grid, int x1, int y1, int x2, int y2, int buyerNum) {\n        boolean hasSign = false;\n        for (int y = y1; y <= y2; y++) {\n            for (int x = x1; x <= x2; x++) {\n                if (grid[y][x] != 0) return false;\n                if (signs[y][x] != 0) {\n                    if (signs[y][x] != buyerNum) return false;\n                    hasSign = true;\n                }\n            }\n        }\n        return hasSign;\n    }\n    \n    static void place(int[][] grid, int x1, int y1, int x2, int y2, int buyerNum) {\n        for (int y = y1; y <= y2; y++) {\n            for (int x = x1; x <= x2; x++) {\n                grid[y][x] = buyerNum;\n            }\n        }\n    }\n    \n    static boolean isValidComplete(int[][] grid) {\n        for (int i = 0; i < Y; i++) {\n            for (int j = 0; j < X; j++) {\n                if (grid[i][j] == 0) return false;\n            }\n        }\n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int X, Y, n; static int[] buyers; static int[] counts; static int[][] signs; static List<int[][]> validSolutions; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { X = sc.nextInt(); Y = sc.nextInt(); n = sc.nextInt(); if (X == 0 && Y == 0 && n    < X; j++) { signs[i][j] = sc.nextInt(); } } validSolutions = new  boolean[n]; backtrack(grid, used,  (validSolutions.size() > 1) { System.out.println(\"NA\"); } else { int[][] sol = validSolutions.get(0); for (int i = 0; i < Y; i++) { for (int j = 0; j < X; j++) { if (j >  static void backtrack(int[][] grid, boolean[] used, int buyerIdx) { if (buyerIdx  i++) { for (int j = 0; j <  return; } if (validSolutions.size() >  0; i < n;  } if (buyer == -1)  { for (int y2 = y1; y2 < Y; y2++) { for  w = x2 - x1 + 1; int h = y2 - y1 + 1; if  buyerNum); used[buyer] = true; backtrack(grid, used, buyerIdx  0); if (validSolutions.size() > 1) return; } } } } }  x2, int y2, int buyerNum) { boolean hasSign = false; for (int y = y1; y <= y2;  x++) { if (grid[y][x] != 0) return false; if (signs[y][x] != 0) { if (signs[y][x] != buyerNum) return false; hasSign = true; } } } return hasSign; } static  y2, int buyerNum) { for (int y = y1; y <= y2; y++) { for (int x = x1; x <= x2; x++) { grid[y][x] = buyerNum; } }  0; i < Y; i++) { for  } }"], "perturbed_original": ["import java.io.IOException; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.PriorityQueue;  { new Main().run(); } private void run() throws IOException { Scanner scanner = new Scanner(System.in); while (true) { w = scanner.nextInt(); h = scanner.nextInt(); n = scanner.nextInt(); if ((w | h | n) == 0) break; size = new int[n + 1];  m = new int[h][w]; for (int[]  i < h; i++)  { int x =  = new int[n + 1][4]; c = 0;   for (int j = 0; j < w; j++) { if (j > 0) System.out.print(\" \"); System.out.print(ans[i][j]); } System.out.println(); } } else { System.out.println(\"NA\"); } } } private void f(int k) { if (k == n + 1) { c++; if (c == 2) return; for (int i = 0; i < h; i++) { for (int j = 0; j < w; j++) { int a = m[i][j]; ans[i][j] =  }  1; x <= s; x++) { if (s %  1 - x; lj <= pos[k][1]; lj++) { if (lj < 0 || lj > w) continue; loop: for (int li = pos[k][0] + 1 - s /  || li > h) continue; int rj =  x; if (rj > w) continue; if (ri  < rj; j++) { if (m[i][j] != 0 && m[i][j] != k) continue loop; } }  100; } } f(k + 1); if (c == 2) return; for (int i = li; i < ri; i++) { for (int j = lj; j < rj; j++) { if  assign; int w, h, n, c; int[][] ans; }"], "original_ll": -0.5864824652671814, "sampled_ll": -0.3100259304046631, "all_perturbed_sampled_ll": [-1.3718657493591309], "all_perturbed_original_ll": [-1.606202483177185], "perturbed_sampled_ll": -1.3718657493591309, "perturbed_original_ll": -1.606202483177185, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import copy\n\ndef main(land, b):\n    for h in range(H):\n        for w in range(W):\n            if land[h][w] == b:\n                if f1(land, h, w, b, data[land[h][w]]):\n                    return\n            \ndef f1(land, h, w, b, k):\n    for q in range(1, k+1):\n        if k%q == 0:\n            if f2(land, h, w, q, k/q, b):\n                return True\n    else:\n        return\n        \ndef f2(land, h, w, r, c, b):\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h-_h and 0 <= w-_w:\n                if f3(land, h-_h, w-_w, r, c, b):\n                    return True\n    else:\n        return\n                \ndef f3(land, h, w, r, c, b):\n    _land = copy.deepcopy(land)\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h+_h <= H-1 and 0 <= w+_w <= W-1:\n                if _land[h+_h][w+_w] == 0 or _land[h+_h][w+_w] == b:\n                    _land[h+_h][w+_w] = b\n                else:\n                    return\n            else:\n                return\n    else:\n        if b < n:\n            return main(_land, b+1)\n        else:\n            for line in _land:\n                print ' '.join(map(str, line))\n            return True\n\nwhile True:\n    W, H, n = map(int, raw_input().split())\n    if H == W == n == 0: break\n    data = {}\n    for i in range(n):\n        b, k = map(int, raw_input().split())\n        data[b] = k\n    land = [map(int, raw_input().split()) for i in range(H)]\n    main(land, 1)", "sampled": "import sys\nfrom itertools import product\n\ndef read_input():\n    datasets = []\n    lines = sys.stdin.read().strip().split('\\n')\n    i = 0\n    while i < len(lines):\n        parts = lines[i].split()\n        X, Y, n = int(parts[0]), int(parts[1]), int(parts[2])\n        if X == 0 and Y == 0 and n == 0:\n            break\n        \n        i += 1\n        memo = []\n        for _ in range(n):\n            b, k = map(int, lines[i].split())\n            memo.append((b, k))\n            i += 1\n        \n        signs = []\n        for _ in range(Y):\n            row = list(map(int, lines[i].split()))\n            signs.append(row)\n            i += 1\n        \n        datasets.append((X, Y, n, memo, signs))\n    \n    return datasets\n\ndef get_all_rectangles(X, Y):\n    rectangles = []\n    for x1 in range(X):\n        for y1 in range(Y):\n            for x2 in range(x1, X):\n                for y2 in range(y1, Y):\n                    rectangles.append((x1, y1, x2, y2))\n    return rectangles\n\ndef solve(X, Y, n, memo, signs):\n    rectangles = get_all_rectangles(X, Y)\n    \n    # Group rectangles by size\n    size_to_rects = {}\n    for rect in rectangles:\n        x1, y1, x2, y2 = rect\n        size = (x2 - x1 + 1) * (y2 - y1 + 1)\n        if size not in size_to_rects:\n            size_to_rects[size] = []\n        size_to_rects[size].append(rect)\n    \n    # For each buyer, get possible rectangles\n    buyer_rects = {}\n    for b, k in memo:\n        if k in size_to_rects:\n            buyer_rects[b] = size_to_rects[k]\n        else:\n            return \"NA\"\n    \n    # Try all combinations\n    def check_assignment(assignment):\n        grid = [[0] * Y for _ in range(X)]\n        \n        for buyer, rect in assignment.items():\n            x1, y1, x2, y2 = rect\n            for x in range(x1, x2 + 1):\n                for y in range(y1, y2 + 1):\n                    if grid[x][y] != 0:\n                        return None\n                    grid[x][y] = buyer\n        \n        # Check if signs match\n        for x in range(X):\n            for y in range(Y):\n                if signs[y][x] != 0:\n                    if grid[x][y] != signs[y][x]:\n                        return None\n        \n        return grid\n    \n    valid_grids = []\n    \n    def backtrack(buyers, assignment):\n        if not buyers:\n            grid = check_assignment(assignment)\n            if grid:\n                valid_grids.append(grid)\n            return\n        \n        buyer = buyers[0]\n        for rect in buyer_rects[buyer]:\n            assignment[buyer] = rect\n            backtrack(buyers[1:], assignment)\n            del assignment[buyer]\n    \n    buyers = [b for b, k in memo]\n    backtrack(buyers, {})\n    \n    if len(valid_grids) == 0:\n        return \"NA\"\n    elif len(valid_grids) == 1:\n        grid = valid_grids[0]\n        result = []\n        for y in range(Y):\n            row = []\n            for x in range(X):\n                row.append(str(grid[x][y]))\n            result.append(' '.join(row))\n        return '\\n'.join(result)\n    else:\n        return \"NA\"\n\ndatasets = read_input()\nfor X, Y, n, memo, signs in datasets:\n    result = solve(X, Y, n, memo, signs)\n    print(result)\n", "perturbed_sampled": ["import sys from <extra_id_1>x1 + 1, y1<extra_id_2>y2 +<extra_id_3>+<extra_id_4>( rows<extra_id_5>y1 ] = [<extra_id_6>row = [ ]<extra_id_7>(i<extra_id_8>0 datasets[i] = datasets[i]<extra_id_9>= get_all_rectangles(X,<extra_id_10>'None<extra_id_11>row) #<extra_id_12>for<extra_id_13>range(y) row . append<extra_id_14>y2<extra_id_15>for i in<extra_id_16>i<extra_id_17>i += sys.stdin.read().strip().split('\\n') i = 0 while i < len(lines): parts = lines[i].split() X, Y, n = int(parts[0]), int(parts[1]), int(parts[2]) if X == 0 and Y == 0 and n == 0: break i += 1 memo = [] for _ in range(n): b, k = map(int, lines[i].split())  in range(Y): row = list(map(int, lines[i].split())) signs.append(row) i += 1 datasets.append((X, Y, n, memo, signs)) return datasets def get_all_rectangles(X, Y): rectangles = [] for x1 in range(X): for y1 in range(Y): for x2 in range(x1, X): for y2 in range(y1,  n, memo, signs): rectangles = get_all_rectangles(X, Y) # Group rectangles by size size_to_rects  = rect  y1 + 1) if size not in size_to_rects: size_to_rects[size] = [] size_to_rects[size].append(rect) # For each buyer,  memo: if k in size_to_rects: buyer_rects[b] = size_to_rects[k] else: return \"NA\" # Try all combinations def check_assignment(assignment):  buyer, rect in assignment.items(): x1, y1, x2, y2 = rect for x in range(x1, x2 + 1): for y in range(y1, y2 + 1): if grid[x][y] != 0: return None   [] for y in range(Y): row = [] for x in range(X): row.append(str(grid[x][y])) result.append('  X, Y, n, memo, signs in datasets: result = solve(X, Y, n, memo, signs) print(result)"], "perturbed_original": ["import copy def main(land, b):  == b: if  b, k): for q in range(1,  k/q, b):  return def f3(land, h, w, r, c, b): _land = copy.deepcopy(land) for _h in range(r): for _w in range(c): if 0 <= h+_h <= H-1 and 0 <= w+_w <= W-1: if _land[h+_h][w+_w] == 0 or _land[h+_h][w+_w] == b: _land[h+_h][w+_w] = b else: return else: return else: if b < n: return main(_land, b+1) else: for line in _land: print '  map(int, raw_input().split()) if H == W == n  b, k = map(int, raw_input().split()) data[b] = k land = [map(int, raw_input().split()) for i in range(H)] main(land, 1)"], "original_ll": -0.7474166750907898, "sampled_ll": -0.5178781747817993, "all_perturbed_sampled_ll": [-1.895161747932434], "all_perturbed_original_ll": [-1.8544549942016602], "perturbed_sampled_ll": -1.895161747932434, "perturbed_original_ll": -1.8544549942016602, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nlong z(long a,long b,long c,long d,long e,long f){\n    return (c-a)*(f-b)-(e-a)*(d-b);\n}\nint x(int (*a)[8],int (*b)[8]){\n    int i,j;\n    for(i=0;i<4;i++){\n        for(j=0;j<4;j++){\n            if(z((*a)[j*2],(*a)[j*2+1],(*a)[(j*2+2)%8],(*a)[(j*2+2)%8+1],(*b)[i*2],(*b)[i*2+1])>0)break;\n        }\n        if(j==4)return 1;\n    }\n    return 0;\n}\n\nint main(){\n    int n,m;\n    int a[100],l[100][8],b[100];\n    int i,j,k;\n    int min,ii,jj,kk;\n    while(scanf(\"%d\",&n)&&n){\n        while(n--){\n            scanf(\"%d\",&m);\n            for(i=0;i<m;i++){\n                a[i]=i;\n                for(j=0;j<8;j++)scanf(\"%d\",&l[i][j]);\n            }\n            for(i=0;i<m;i++){\n                for(j=i+1;j<m;j++){\n                    if(x(&l[i],&l[j])){\n                        k=0;\n                        ii=i;\n                        while((b[k++]=ii),a[ii]!=ii)ii=a[ii];\n                        jj=j;\n                        while((b[k++]=jj),a[jj]!=jj)jj=a[jj];\n                        min=ii<jj?ii:jj;\n                        for(kk=0;kk<k;kk++)a[b[kk]]=min;\n                    }\n                }\n            }\n            for(i=0;i<m;i++){\n                j=i;\n                while(a[j]!=j)j=a[j];\n                a[i]=j;\n            }\n            k=0;\n            for(i=0;i<m;i++){\n                for(j=0;j<i;j++){\n                    if(a[i]==a[j])break;\n                }\n                if(j==i)k++;\n            }\n            printf(\"%d\\n\",k);\n        }\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point vertices[4];\n} Rectangle;\n\nbool segmentsIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int d1 = (q1.x - p1.x) * (p2.y - p1.y) - (q1.y - p1.y) * (p2.x - p1.x);\n    int d2 = (q1.x - p1.x) * (q2.y - p1.y) - (q1.y - p1.y) * (q2.x - p1.x);\n    int d3 = (q2.x - p2.x) * (p1.y - p2.y) - (q2.y - p2.y) * (p1.x - p2.x);\n    int d4 = (q2.x - p2.x) * (q1.y - p2.y) - (q2.y - p2.y) * (q1.x - p2.x);\n    \n    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool pointOnSegment(Point p, Point q, Point r) {\n    if (q.x <= (p.x > r.x ? p.x : r.x) && q.x >= (p.x < r.x ? p.x : r.x) &&\n        q.y <= (p.y > r.y ? p.y : r.y) && q.y >= (p.y < r.y ? p.y : r.y))\n        return true;\n    return false;\n}\n\nbool segmentsTouchOrIntersect(Point p1, Point q1, Point p2, Point q2) {\n    long long d1 = (long long)(q1.x - p1.x) * (p2.y - p1.y) - (long long)(q1.y - p1.y) * (p2.x - p1.x);\n    long long d2 = (long long)(q1.x - p1.x) * (q2.y - p1.y) - (long long)(q1.y - p1.y) * (q2.x - p1.x);\n    long long d3 = (long long)(q2.x - p2.x) * (p1.y - p2.y) - (long long)(q2.y - p2.y) * (p1.x - p2.x);\n    long long d4 = (long long)(q2.x - p2.x) * (q1.y - p2.y) - (long long)(q2.y - p2.y) * (q1.x - p2.x);\n    \n    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n        return true;\n    }\n    \n    if (d1 == 0 && pointOnSegment(p1, p2, q1)) return true;\n    if (d2 == 0 && pointOnSegment(p1, q2, q1)) return true;\n    if (d3 == 0 && pointOnSegment(p2, p1, q2)) return true;\n    if (d4 == 0 && pointOnSegment(p2, q1, q2)) return true;\n    \n    return false;\n}\n\nbool pointInRectangle(Point p, Rectangle r) {\n    int crossings = 0;\n    for (int i = 0; i < 4; i++) {\n        Point p1 = r.vertices[i];\n        Point p2 = r.vertices[(i + 1) % 4];\n        \n        if ((p1.y <= p.y && p2.y > p.y) || (p1.y > p.y && p2.y <= p.y)) {\n            double vt = (double)(p.y - p1.y) / (p2.y - p1.y);\n            if (p.x < p1.x + vt * (p2.x - p1.x)) {\n                crossings++;\n            }\n        }\n    }\n    return (crossings % 2) == 1;\n}\n\nbool rectanglesTouchOrOverlap(Rectangle r1, Rectangle r2) {\n    for (int i = 0; i < 4; i++) {\n        if (pointInRectangle(r1.vertices[i], r2)) return true;\n        if (pointInRectangle(r2.vertices[i], r1)) return true;\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            if (segmentsTouchOrIntersect(r1.vertices[i], r1.vertices[(i+1)%4],\n                                        r2.vertices[j], r2.vertices[(j+1)%4])) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nint find(int parent[], int i) {\n    if (parent[i] != i)\n        parent[i] = find(parent, parent[i]);\n    return parent[i];\n}\n\nvoid unionSet(int parent[], int rank[], int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n    \n    if (rank[xroot] < rank[yroot])\n        parent[xroot] = yroot;\n    else if (rank[xroot] > rank[yroot])\n        parent[yroot] = xroot;\n    else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\nint main() {\n    int N;\n    \n    while (scanf(\"%d\", &N) && N != 0) {\n        for (int i = 0; i < N; i++) {\n            int M;\n            scanf(\"%d\", &M);\n            \n            Rectangle rectangles[100];\n            for (int j = 0; j < M; j++) {\n                for (int k = 0; k < 4; k++) {\n                    scanf(\"%d %d\", &rectangles[j].vertices[k].x, &rectangles[j].vertices[k].y);\n                }\n            }\n            \n            int parent[100], rank[100];\n            for (int j = 0; j < M; j++) {\n                parent[j] = j;\n                rank[j] = 0;\n            }\n            \n            for (int j = 0; j < M; j++) {\n                for (int k = j + 1; k < M; k++) {\n                    if (rectanglesTouchOrOverlap(rectangles[j], rectangles[k])) {\n                        unionSet(parent, rank, j, k);\n                    }\n                }\n            }\n            \n            int count = 0;\n            for (int j = 0; j < M; j++) {\n                if (find(parent, j) == j) {\n                    count++;\n                }\n            }\n            \n            printf(\"%d\\n\", count);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <stdbool.h> typedef struct { int x, y; } Point; typedef struct { Point vertices[4]; } Rectangle; bool segmentsIntersect(Point p1, Point q1,  * (p2.x - p1.x); int d2 = (q1.x - p1.x)  - p1.x); int d3 = (q2.x - p2.x) * (p1.y - p2.y) -  (q2.x - p2.x) * (q1.y - p2.y) - (q2.y - p2.y)  < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) { return true; } return false; } bool  >= (p.x < r.x ? p.x : r.x) && q.y  >= (p.y < r.y ? p.y : r.y)) return true; return false; } bool segmentsTouchOrIntersect(Point p1,  = (long long)(q1.x - p1.x) * (p2.y - p1.y) - (long long)(q1.y - p1.y) * (p2.x - p1.x); long long d2 = (long  -  long)(q2.y - p2.y) * (p1.x -   && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4  0 && pointOnSegment(p1, q2, q1)) return true; if (d3 == 0 && pointOnSegment(p2, p1, q2)) return true; if (d4 == 0 &&  p, Rectangle r) { int crossings  i++) { Point p1 = r.vertices[i]; Point  p.y && p2.y > p.y) ||  = (double)(p.y - p1.y) / (p2.y - p1.y); if (p.x < p1.x + vt * (p2.x  2) == 1; } bool rectanglesTouchOrOverlap(Rectangle r1, Rectangle r2) { for (int i = 0; i < 4; i++) { if (pointInRectangle(r1.vertices[i], r2)) return  = 0;  j < 4; j++) { if (segmentsTouchOrIntersect(r1.vertices[i], r1.vertices[(i+1)%4], r2.vertices[j], r2.vertices[(j+1)%4])) { return true; } } } return false; } int find(int parent[], int i) { if (parent[i] != i) parent[i] = find(parent, parent[i]); return parent[i]; } void unionSet(int parent[], int rank[], int x, int y) { int xroot = find(parent, x); int  yroot;  parent[yroot] = xroot; rank[xroot]++;  && N != 0) { for (int i = 0; i  for (int j  = 0; k < 4; k++) { scanf(\"%d %d\", &rectangles[j].vertices[k].x, &rectangles[j].vertices[k].y); } } int  j++) { parent[j] = j; rank[j] = 0; } for (int j   0; j < M; j++) { if (find(parent, j) == j) { count++; } } printf(\"%d\\n\", count); } } return 0; }"], "perturbed_original": ["#include <stdio.h> long z(long a,long b,long c,long d,long e,long f){ return (c-a)*(f-b)-(e-a)*(d-b); } int x(int (*a)[8],int (*b)[8]){ int i,j; for(i=0;i<4;i++){ for(j=0;j<4;j++){ if(z((*a)[j*2],(*a)[j*2+1],(*a)[(j*2+2)%8],(*a)[(j*2+2)%8+1],(*b)[i*2],(*b)[i*2+1])>0)break; } if(j==4)return 1; } return 0;   } } for(i=0;i<m;i++){ j=i; while(a[j]!=j)j=a[j]; a[i]=j; } k=0; for(i=0;i<m;i++){ for(j=0;j<i;j++){ if(a[i]==a[j])break; } if(j==i)k++; } printf(\"%d\\n\",k); } } return 0; }"], "original_ll": -0.8058727383613586, "sampled_ll": -0.22475393116474152, "all_perturbed_sampled_ll": [-1.2197518348693848], "all_perturbed_original_ll": [-1.0971553325653076], "perturbed_sampled_ll": -1.2197518348693848, "perturbed_original_ll": -1.0971553325653076, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Autumnal Illumination\npublic class Main{\n\n\tint n;\n\tint[][][] p;\n\t\n\tint cross(int[] s, int[] t, int[] r){\n\t\tint x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];\n\t\treturn x1*y2-x2*y1;\n\t}\n\tboolean online(int[] s, int[] t, int[] r){\n\t\tif(cross(s, t, r)!=0)return false;\n\t\tint minx = Math.min(s[0], t[0]), maxx = Math.max(s[0], t[0]);\n\t\tint miny = Math.min(s[1], t[1]), maxy = Math.max(s[1], t[1]);\n\t\treturn minx<=r[0]&&r[0]<=maxx&&miny<=r[1]&&r[1]<=maxy;\n\t}\n\tboolean isCross(int[] a, int[] b, int[] s, int[] t){\n\t\tif(cross(a, b, s)*cross(a, b, t)>=0)return false;\n\t\treturn cross(b, a, s)*cross(b, a, t)<0;\n\t}\n\t\n\tboolean col(int a, int b){\n\t\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++){\n\t\t\tif(online(p[a][i], p[a][(i+1)%4], p[b][j]))return true;\n\t\t\tif(online(p[b][i], p[b][(i+1)%4], p[a][j]))return true;\n\t\t\tif(isCross(p[a][i], p[a][(i+1)%4], p[b][j], p[b][(j+1)%4]))return true;\n\t\t}\n\t\tfor(int j=0;j<4;j++){\n\t\t\tboolean in = true;\n\t\t\tfor(int i=0;i<4;i++)if(cross(p[a][i], p[a][(i+1)%4], p[b][j])>=0)in = false;\n\t\t\tif(in)return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint m = sc.nextInt();\n\t\t\tif(m==0)break;\n\t\t\twhile(m--!=0){\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tp = new int[n][4][2];\n\t\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<4;j++)for(int k=0;k<2;k++)p[i][j][k]=sc.nextInt();\n\t\t\t\tUnionFind u = new UnionFind(n);\n\t\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\t\tif(u.find(i, j))continue;\n\t\t\t\t\tif(col(i, j))u.union(i, j);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(u.num);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass UnionFind {\n\t\tfinal int[] tree;\n\t\tint num;\n\t\tpublic UnionFind(int n) {\n\t\t\tthis.tree = new int[n];\n\t\t\tArrays.fill(tree, -1);\n\t\t\tnum=n;\n\t\t}\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif(x != y) {\n\t\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t\t}\n\t\t\t\ttree[x] += tree[y];\n\t\t\t\ttree[y] = x;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tboolean find(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\t\tint root(int x) {\n\t\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t\t}\n\t\tint size(int x) {\n\t\t\treturn -tree[root(x)];\n\t\t}\n\t\tint getNum() {\n\t\t\treturn num;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    static class Quad {\n        Point[] points;\n        Quad(Point[] points) {\n            this.points = points;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            for (int i = 0; i < n; i++) {\n                int m = Integer.parseInt(br.readLine().trim());\n                Quad[] quads = new Quad[m];\n                \n                for (int j = 0; j < m; j++) {\n                    String[] tokens = br.readLine().trim().split(\"\\\\s+\");\n                    Point[] points = new Point[4];\n                    for (int k = 0; k < 4; k++) {\n                        points[k] = new Point(\n                            Double.parseDouble(tokens[k * 2]),\n                            Double.parseDouble(tokens[k * 2 + 1])\n                        );\n                    }\n                    quads[j] = new Quad(points);\n                }\n                \n                int components = countComponents(quads);\n                System.out.println(components);\n            }\n        }\n    }\n    \n    static int countComponents(Quad[] quads) {\n        int n = quads.length;\n        boolean[] visited = new boolean[n];\n        int count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, quads, visited);\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    static void dfs(int idx, Quad[] quads, boolean[] visited) {\n        visited[idx] = true;\n        \n        for (int i = 0; i < quads.length; i++) {\n            if (!visited[i] && intersectsOrTouches(quads[idx], quads[i])) {\n                dfs(i, quads, visited);\n            }\n        }\n    }\n    \n    static boolean intersectsOrTouches(Quad q1, Quad q2) {\n        // Check if q1 and q2 overlap or touch\n        if (polygonsIntersect(q1.points, q2.points)) return true;\n        if (polygonContainsPolygon(q1.points, q2.points)) return true;\n        if (polygonContainsPolygon(q2.points, q1.points)) return true;\n        return false;\n    }\n    \n    static boolean polygonsIntersect(Point[] p1, Point[] p2) {\n        // Check edge intersections or touching\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                if (segmentsIntersectOrTouch(p1[i], p1[(i+1)%4], p2[j], p2[(j+1)%4])) {\n                    return true;\n                }\n            }\n        }\n        \n        // Check if any vertex of one is inside the other\n        for (int i = 0; i < 4; i++) {\n            if (pointInOrOnPolygon(p1[i], p2)) return true;\n            if (pointInOrOnPolygon(p2[i], p1)) return true;\n        }\n        \n        return false;\n    }\n    \n    static boolean polygonContainsPolygon(Point[] p1, Point[] p2) {\n        for (int i = 0; i < 4; i++) {\n            if (pointInPolygon(p2[i], p1)) return true;\n        }\n        return false;\n    }\n    \n    static boolean segmentsIntersectOrTouch(Point p1, Point p2, Point p3, Point p4) {\n        double d1 = direction(p3, p4, p1);\n        double d2 = direction(p3, p4, p2);\n        double d3 = direction(p1, p2, p3);\n        double d4 = direction(p1, p2, p4);\n        \n        if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n            ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n            return true;\n        }\n        \n        if (Math.abs(d1) < 1e-9 && onSegment(p3, p4, p1)) return true;\n        if (Math.abs(d2) < 1e-9 && onSegment(p3, p4, p2)) return true;\n        if (Math.abs(d3) < 1e-9 && onSegment(p1, p2, p3)) return true;\n        if (Math.abs(d4) < 1e-9 && onSegment(p1, p2, p4)) return true;\n        \n        return false;\n    }\n    \n    static double direction(Point p1, Point p2, Point p3) {\n        return (p3.x - p1.x) * (p2.y - p1.y) - (p2.x - p1.x) * (p3.y - p1.y);\n    }\n    \n    static boolean onSegment(Point p1, Point p2, Point p) {\n        return Math.min(p1.x, p2.x) <= p.x + 1e-9 && p.x <= Math.max(p1.x, p2.x) + 1e-9 &&\n               Math.min(p1.y, p2.y) <= p.y + 1e-9 && p.y <= Math.max(p1.y, p2.y) + 1e-9;\n    }\n    \n    static boolean pointInOrOnPolygon(Point p, Point[] poly) {\n        return pointInPolygon(p, poly) || pointOnPolygonBoundary(p, poly);\n    }\n    \n    static boolean pointInPolygon(Point p, Point[] poly) {\n        int n = poly.length;\n        boolean inside = false;\n        for (int i = 0, j = n - 1; i < n; j = i++) {\n            if ((poly[i].y > p.y) != (poly[j].y > p.y) &&\n                p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) {\n                inside = !inside;\n            }\n        }\n        return inside;\n    }\n    \n    static boolean pointOnPolygonBoundary(Point p, Point[] poly) {\n        int n = poly.length;\n        for (int i = 0; i < n; i++) {\n            if (Math.abs(direction(poly[i], poly[(i+1)%n], p)) < 1e-9 &&\n                onSegment(poly[i], poly[(i+1)%n], p)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class Point {  { Point[] points; Quad(Point[] points) { this.points = points; } } public static void main(String[] args) throws IOException { BufferedReader br   0) break; for  (int  = br.readLine().trim().split(\"\\\\s+\"); Point[] points = new Point[4]; for (int k = 0; k < 4; k++) { points[k] = new Point( Double.parseDouble(tokens[k * 2]), Double.parseDouble(tokens[k *  int components = countComponents(quads); System.out.println(components); } } } static int countComponents(Quad[] quads) { int n = quads.length; boolean[] visited = new boolean[n]; int count =  } return count; } static void dfs(int idx, Quad[] quads, boolean[] visited) { visited[idx] = true; for  (!visited[i]  static boolean intersectsOrTouches(Quad q1, Quad q2) { // Check if   p2) { // Check edge intersections or touching for (int i = 0; i < 4; i++)  { if (segmentsIntersectOrTouch(p1[i], p1[(i+1)%4], p2[j], p2[(j+1)%4]))  vertex of one is inside the other for (int i = 0; i  (pointInOrOnPolygon(p2[i], p1)) return true; } return false; }  = 0; i < 4; i++) { if (pointInPolygon(p2[i], p1)) return true; } return false; } static boolean segmentsIntersectOrTouch(Point p1, Point p2, Point p3, Point p4) { double d1 = direction(p3, p4, p1); double d2 = direction(p3, p4, p2); double d3 = direction(p1, p2, p3); double d4 = direction(p1, p2, p4); if (((d1 > 0 && d2 < 0) || (d1 <  1e-9 &&  onSegment(p3, p4, p2)) return true; if (Math.abs(d3) < 1e-9 && onSegment(p1, p2, p3)) return true; if (Math.abs(d4) < 1e-9 && onSegment(p1, p2, p4))  p2, Point p3) { return (p3.x - p1.x) * (p2.y - p1.y)  boolean onSegment(Point p1, Point  1e-9 && p.x <=  1e-9 && p.y <= Math.max(p1.y, p2.y) + 1e-9; } static boolean pointInOrOnPolygon(Point p, Point[] poly) { return pointInPolygon(p, poly) || pointOnPolygonBoundary(p, poly); } static boolean pointInPolygon(Point p, Point[] poly) { int n = poly.length; boolean inside = false; for (int i = 0,   && p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) { inside = !inside;  poly) { int n = poly.length; for (int i = 0; i <  false; } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; //Autumnal Illumination public class Main{ int  r[0]-s[0], y2 = r[1]-s[1]; return x1*y2-x2*y1; } boolean    } boolean isCross(int[] a, int[] b, int[] s, int[] t){ if(cross(a, b, s)*cross(a, b, t)>=0)return false; return cross(b, a, s)*cross(b, a, t)<0; } boolean col(int a, int b){ for(int i=0;i<4;i++)for(int j=0;j<4;j++){ if(online(p[a][i], p[a][(i+1)%4], p[b][j]))return true; if(online(p[b][i], p[b][(i+1)%4], p[a][j]))return true; if(isCross(p[a][i], p[a][(i+1)%4], p[b][j], p[b][(j+1)%4]))return true; } for(int j=0;j<4;j++){ boolean in = true; for(int i=0;i<4;i++)if(cross(p[a][i], p[a][(i+1)%4], p[b][j])>=0)in = false; if(in)return true; } return false; } void run(){ Scanner  i=0;i<n;i++)for(int j=0;j<4;j++)for(int k=0;k<2;k++)p[i][j][k]=sc.nextInt(); UnionFind u = new UnionFind(n); for(int i=0;i<n;i++)for(int j=0;j<n;j++){ if(u.find(i,  UnionFind { final int[] tree; int num; public UnionFind(int n) { this.tree = new int[n]; Arrays.fill(tree, -1); num=n; } void union(int x, int y)  { if(tree[x]  y; } tree[x] += tree[y]; tree[y] = x;  root(x) == root(y); } int root(int  } int getNum() { return  Main().run(); } }"], "original_ll": -0.5799993276596069, "sampled_ll": -0.2735598087310791, "all_perturbed_sampled_ll": [-1.1930975914001465], "all_perturbed_original_ll": [-1.490497350692749], "perturbed_sampled_ll": -1.1930975914001465, "perturbed_original_ll": -1.490497350692749, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from sys import stdin\nfrom itertools import product\n\ndef chk_in_rect(xy1,xy2):\n    chk = True\n    for i in range(4):\n        for j in range(4):\n            a = (xy1[(2*i+2)&7]-xy1[(2*i  )&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+1)&7])\n            b = (xy1[(2*i+3)&7]-xy1[(2*i+1)&7]) * (xy2[(2*j  )&7]-xy1[(2*i  )&7])\n            if a > b: chk = False; break\n    if chk: return True\n    else: return False\n\ndef chk_intersect(xy1,xy2):\n    for i,j in product(range(4),repeat=2):\n        a = (xy1[(2*i  )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+3)&7])\n        a+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i  )&7]-xy1[(2*j  )&7])\n        b = (xy1[(2*i  )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+3)&7]-xy1[(2*i+3)&7])\n        b+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i  )&7]-xy1[(2*j+2)&7])\n        if a*b < 0 : return True\n    else:\n        return False\n\nwhile(True):\n    try:\n        n = int(stdin.readline())\n        if not n: break\n    except:\n        break\n    for _ in range(n):\n        m = int(stdin.readline())\n        p = list(range(m))\n        xys = [ list(map(int, stdin.readline().split())) for i in range(m) ]\n        # print(n,m,xys)\n        for i in range(m):\n            if len(set(p)) == 1: print(1); break\n            for j in range(i+1,m):\n                if p[i] == p[j]:\n                    continue\n                if chk_in_rect(xys[i],xys[j]):\n                    # print(\"in_rect\")\n                    p = [i if e==j else e for e in p]\n                    continue\n                if chk_intersect(xys[i],xys[j]):\n                    # print(\"intersect\")\n                    p = [i if e==j else e for e in p]\n                    continue\n        else: print(len(set(p)))\n\n\n\n\n", "sampled": "def rectangles_overlap_or_touch(rect1, rect2):\n    # Check if two rectangles overlap or touch (including edges)\n    # rect is list of 4 points [(x1,y1), (x2,y2), (x3,y3), (x4,y4)]\n    \n    # Check if rectangles are separated (no overlap or touch)\n    # Use Separating Axis Theorem (SAT)\n    \n    def get_edges(rect):\n        edges = []\n        for i in range(4):\n            p1 = rect[i]\n            p2 = rect[(i+1)%4]\n            edges.append((p2[0]-p1[0], p2[1]-p1[1]))\n        return edges\n    \n    def get_normals(edges):\n        normals = []\n        for edge in edges:\n            normals.append((-edge[1], edge[0]))\n        return normals\n    \n    def project(rect, axis):\n        dots = []\n        for point in rect:\n            dots.append(point[0]*axis[0] + point[1]*axis[1])\n        return min(dots), max(dots)\n    \n    def overlap(proj1, proj2):\n        return proj1[1] >= proj2[0] and proj2[1] >= proj1[0]\n    \n    edges1 = get_edges(rect1)\n    edges2 = get_edges(rect2)\n    normals = get_normals(edges1) + get_normals(edges2)\n    \n    for normal in normals:\n        proj1 = project(rect1, normal)\n        proj2 = project(rect2, normal)\n        if not overlap(proj1, proj2):\n            return False\n    \n    return True\n\ndef find_connected_components(rectangles):\n    n = len(rectangles)\n    if n == 0:\n        return 0\n    \n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if rectangles_overlap_or_touch(rectangles[i], rectangles[j]):\n                adj[i].append(j)\n                adj[j].append(i)\n    \n    # DFS to count connected components\n    visited = [False] * n\n    components = 0\n    \n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            components += 1\n    \n    return components\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    for _ in range(n):\n        m = int(input())\n        rectangles = []\n        for _ in range(m):\n            coords = list(map(int, input().split()))\n            rect = [(coords[i], coords[i+1]) for i in range(0, 8, 2)]\n            rectangles.append(rect)\n        \n        result = find_connected_components(rectangles)\n        print(result)\n", "perturbed_sampled": ["def rectangles_overlap_or_touch(rect1, rect2): # Check if two rectangles overlap  points [(x1,y1), (x2,y2), (x3,y3), (x4,y4)] # Check if rectangles are separated (no overlap or touch) # Use Separating Axis Theorem (SAT) def get_edges(rect): edges = [] for i in range(4): p1 = rect[i] p2 = rect[(i+1)%4] edges.append((p2[0]-p1[0],  dots = [] for point in rect: dots.append(point[0]*axis[0] + point[1]*axis[1])  get_edges(rect2) normals = get_normals(edges1) + get_normals(edges2) for normal in normals: proj1 = project(rect1, normal) proj2 = project(rect2, normal) if not  len(rectangles) if n ==  for _ in range(n)] for i in range(n): for j in range(i+1, n): if rectangles_overlap_or_touch(rectangles[i],  = [False] * n components = 0  not visited[neighbor]: dfs(neighbor) for i in range(n):   _ in range(n): m = int(input()) rectangles = [] for _  for i in range(0, 8, 2)] rectangles.append(rect) result = find_connected_components(rectangles) print(result)"], "perturbed_original": ["from sys import stdin from itertools import product def chk_in_rect(xy1,xy2): chk   def chk_intersect(xy1,xy2): for i,j in product(range(4),repeat=2): a = (xy1[(2*i )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+3)&7]) a+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i )&7]-xy1[(2*j )&7]) b = (xy1[(2*i )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+3)&7]-xy1[(2*i+3)&7])  return True else: return False while(True): try: n = int(stdin.readline()) if not n: break except: break for _ in range(n): m = int(stdin.readline()) p = list(range(m)) xys = [ list(map(int, stdin.readline().split())) for i in range(m)  1:  continue if  for e in p] continue if chk_intersect(xys[i],xys[j]): # print(\"intersect\") p = [i if e==j else e for e in p] continue else: print(len(set(p)))"], "original_ll": -0.7595723271369934, "sampled_ll": -0.5037705302238464, "all_perturbed_sampled_ll": [-1.8500772714614868], "all_perturbed_original_ll": [-1.471261739730835], "perturbed_sampled_ll": -1.8500772714614868, "perturbed_original_ll": -1.471261739730835, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "mx,my;pn[7];px[7][1000],py[7][1000];M[5][7][1000];a0;Calc(a1,a2){int n1,n2,m,mm;for(n2=0;n2<pn[a2];n2++){mm=1e9;for(n1=0;n1<pn[a1];n1++){m=M[a0][a1][n1]+abs(px[a1][n1]-px[a2][n2])+abs(py[a1][n1]-py[a2][n2]);if(m<mm)mm=m;}M[a0][a2][n2]=mm;}}main(){int x,y,c,a,am;for(;scanf(\"%d%d\\n\",&mx,&my),mx;){memset(pn,0,sizeof(pn));for(y=0;y<my;y++){for(x=0;x<=mx;x++){c=getchar();if(c>='1'){if(c<='5')a=c-'0';else if(c=='S')a=0;else if(c=='G')a=6;px[a][pn[a]]=x;py[a][pn[a]++]=y;}}}am=0;for(a0=0;a0<5;a0++){M[a0][0][0]=0;Calc(0,1+(a0+1)%5);for(a=0;a<3;a++)Calc(1+(a0+a+1)%5,1+(a0+a+2)%5);Calc(1+(a0+4)%5,6);if(M[a0][6][0]<M[am][6][0])am=a0;}printf(M[am][6][0]!=1e9?\"%d %d\\n\":\"NA\\n\",1+am,M[am][6][0]);}{int n;for(n=1000000;n--;)getchar();}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX 1000\n#define INF 1000000000\n\ntypedef struct {\n    int x, y, mask;\n} State;\n\ntypedef struct {\n    int x, y;\n} Point;\n\nchar map[MAX][MAX];\nint W, H;\nPoint start, goal;\nPoint creatures[5][MAX];\nint creature_count[5];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\ntypedef struct {\n    State data[MAX * MAX * 32];\n    int front, rear;\n} Queue;\n\nvoid init_queue(Queue *q) {\n    q->front = 0;\n    q->rear = 0;\n}\n\nvoid enqueue(Queue *q, State s) {\n    q->data[q->rear++] = s;\n}\n\nState dequeue(Queue *q) {\n    return q->data[q->front++];\n}\n\nint is_empty(Queue *q) {\n    return q->front == q->rear;\n}\n\nint bfs(int start_attr) {\n    int dist[MAX][MAX][32];\n    int i, j, k;\n    \n    for (i = 0; i < H; i++) {\n        for (j = 0; j < W; j++) {\n            for (k = 0; k < 32; k++) {\n                dist[i][j][k] = INF;\n            }\n        }\n    }\n    \n    Queue q;\n    init_queue(&q);\n    \n    State s;\n    s.x = start.x;\n    s.y = start.y;\n    s.mask = (1 << start_attr);\n    dist[s.x][s.y][s.mask] = 0;\n    enqueue(&q, s);\n    \n    while (!is_empty(&q)) {\n        State cur = dequeue(&q);\n        int cx = cur.x;\n        int cy = cur.y;\n        int cmask = cur.mask;\n        \n        if (cx == goal.x && cy == goal.y && cmask == 31) {\n            return dist[cx][cy][cmask];\n        }\n        \n        for (i = 0; i < 4; i++) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n            \n            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            \n            int nmask = cmask;\n            \n            if (map[nx][ny] >= '1' && map[nx][ny] <= '5') {\n                int attr = map[nx][ny] - '1';\n                int can_catch = 0;\n                \n                for (j = 0; j < 5; j++) {\n                    if (cmask & (1 << j)) {\n                        int catchable = (j + 1) % 5;\n                        if (catchable == attr) {\n                            can_catch = 1;\n                            break;\n                        }\n                    }\n                }\n                \n                if (can_catch) {\n                    nmask |= (1 << attr);\n                }\n            }\n            \n            if (dist[nx][ny][nmask] > dist[cx][cy][cmask] + 1) {\n                dist[nx][ny][nmask] = dist[cx][cy][cmask] + 1;\n                State ns;\n                ns.x = nx;\n                ns.y = ny;\n                ns.mask = nmask;\n                enqueue(&q, ns);\n            }\n        }\n    }\n    \n    return INF;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &W, &H);\n        if (W == 0 && H == 0) break;\n        \n        int i, j;\n        for (i = 0; i < 5; i++) {\n            creature_count[i] = 0;\n        }\n        \n        for (i = 0; i < H; i++) {\n            scanf(\"%s\", map[i]);\n            for (j = 0; j < W; j++) {\n                if (map[i][j] == 'S') {\n                    start.x = i;\n                    start.y = j;\n                } else if (map[i][j] == 'G') {\n                    goal.x = i;\n                    goal.y = j;\n                } else if (map[i][j] >= '1' && map[i][j] <= '5') {\n                    int attr = map[i][j] - '1';\n                    creatures[attr][creature_count[attr]].x = i;\n                    creatures[attr][creature_count[attr]].y = j;\n                    creature_count[attr]++;\n                }\n            }\n        }\n        \n        int min_dist = INF;\n        int best_attr = -1;\n        \n        for (i = 0; i < 5; i++) {\n            int d = bfs(i);\n            if (d < min_dist) {\n                min_dist = d;\n                best_attr = i;\n            }\n        }\n        \n        if (min_dist == INF) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d %d\\n\", best_attr + 1, min_dist);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" } State; typedef struct { int x,   1,  { State data[MAX *  void enqueue(Queue *q, State s) { q->data[q->rear++] = s; } State dequeue(Queue *q) { return q->data[q->front++]; } int is_empty(Queue *q) { return  int i, j, k; for (i = 0; i < H; i++) { for (j = 0; j < W; j++) { for (k = 0; k <  q; init_queue(&q); State s; s.x = start.x; s.y = start.y; s.mask = (1 << start_attr); dist[s.x][s.y][s.mask] = 0; enqueue(&q, s); while (!is_empty(&q)) { State cur = dequeue(&q); int cx = cur.x; int cy = cur.y; int cmask = cur.mask; if (cx == goal.x  dist[cx][cy][cmask]; } for (i = 0; i < 4; i++)  cy + dy[i]; if  0 || ny >= W) continue; int nmask  { int attr = map[nx][ny] - '1'; int can_catch = 0; for  & (1 << j)) {  dist[nx][ny][nmask] =  ny; ns.mask = nmask; enqueue(&q, ns); } } } return  &W, &H); if (W == 0 && H == 0) break; int i, j; for (i  } for (i = 0; i < H; i++) { scanf(\"%s\", map[i]); for (j = 0; j < W;  start.y = j; } else if (map[i][j] ==  int attr = map[i][j] - '1'; creatures[attr][creature_count[attr]].x = i; creatures[attr][creature_count[attr]].y = j; creature_count[attr]++; } } } int min_dist = INF; int best_attr = -1; for (i = 0; i < 5; i++) { int d  best_attr = i; } } if (min_dist == INF) { printf(\"NA\\n\"); } else { printf(\"%d %d\\n\", best_attr + 1, min_dist); } } return 0; }"], "perturbed_original": ["mx,my;pn[7];px[7][1000],py[7][1000];M[5][7][1000];a0;Calc(a1,a2){int n1,n2,m,mm;for(n2=0;n2<pn[a2];n2++){mm=1e9;for(n1=0;n1<pn[a1];n1++){m=M[a0][a1][n1]+abs(px[a1][n1]-px[a2][n2])+abs(py[a1][n1]-py[a2][n2]);if(m<mm)mm=m;}M[a0][a2][n2]=mm;}}main(){int x,y,c,a,am;for(;scanf(\"%d%d\\n\",&mx,&my),mx;){memset(pn,0,sizeof(pn));for(y=0;y<my;y++){for(x=0;x<=mx;x++){c=getchar();if(c>='1'){if(c<='5')a=c-'0';else if(c=='S')a=0;else if(c=='G')a=6;px[a][pn[a]]=x;py[a][pn[a]++]=y;}}}am=0;for(a0=0;a0<5;a0++){M[a0][0][0]=0;Calc(0,1+(a0+1)%5);for(a=0;a<3;a++)Calc(1+(a0+a+1)%5,1+(a0+a+2)%5);Calc(1+(a0+4)%5,6);if(M[a0][6][0]<M[am][6][0])am=a0;}printf(M[am][6][0]!=1e9?\"%d %d\\n\":\"NA\\n\",1+am,M[am][6][0]);}{int n;for(n=1000000;n--;)getchar();}exit(0);}"], "original_ll": -1.2062004804611206, "sampled_ll": -0.3254285156726837, "all_perturbed_sampled_ll": [-1.5225257873535156], "all_perturbed_original_ll": [-1.2062004804611206], "perturbed_sampled_ll": -1.5225257873535156, "perturbed_original_ll": -1.2062004804611206, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\t/** ????\u00a7??????? */\n\tstatic final String WHITE_SPACE = \" \";\n\n\t/** ??????????????????_X */\n\tstatic int mapSizeX = 0;\n\n\t/** ??????????????????_Y */\n\tstatic int mapSizeY = 0;\n\n\t/** ??????????????\u00b0 */\n\tstatic int maxNode = 0;\n\n\t/** ????????\u00a2??????????????? */\n\tstatic List<Point> pachimonList = new ArrayList<Point>();\n\n\t/** ?????????????\u00a8??????????????????????????\u00b4??????? */\n\tstatic boolean[] visited = new boolean[5003];\n\n\t/** ??????????????????????????? */\n\tstatic int[] cost = new int[5003];\n\n\t/** ?????????????????? */\n\tstatic int startIdx = 0;\n\n\t/** ??\u00b4???????????? */\n\tstatic int goalIdx = 0;\n\n\t/**\n\t * @param args\n\t * @throws IOException\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\tString[] mapSizeLine = new String[2];\n\t\tPoint output = createPos(0, Integer.MAX_VALUE);\n\t\twhile (true) {\n\t\t\tmapSizeLine = br.readLine().split(WHITE_SPACE);\n\t\t\tmapSizeX = Integer.parseInt(mapSizeLine[0]);\n\t\t\tmapSizeY = Integer.parseInt(mapSizeLine[1]);\n\t\t\tif (mapSizeX == 0 && mapSizeY == 0)\n\t\t\t\tbreak;\n\n\t\t\treadMap(br);\n\t\t\toutput.x = 0;\n\t\t\toutput.y = Integer.MAX_VALUE;\n\t\t\tif (maxNode > 5) {\n\t\t\t\tfor (int type = 1; type <= 5; type++) {\n\t\t\t\t\t// ??????????????????????????\u00a2??????????????????????????????????????????????\u00b4\u00a2\n\t\t\t\t\tint cost = searchRoute(type);\n\t\t\t\t\tif (cost < output.y && cost > 0) {\n\t\t\t\t\t\toutput.x = type;\n\t\t\t\t\t\toutput.y = cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ???????????????\n\t\t\tif (output.y == Integer.MAX_VALUE) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(output.x + WHITE_SPACE + output.y);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * ?????????????????????????????????\n\t * @param scanner ????????\u00a3??????\n\t * @throws IOException\n\t */\n\tprivate static void readMap(BufferedReader br) throws IOException {\n\t\t// ??????????????\u00b1????????????\n\t\tpachimonList.removeAll(pachimonList);\n\t\tmaxNode = 0;\n\t\tstartIdx = 0;\n\n\t\tfor (int i = 0; i < mapSizeY; i++) {\n\t\t\tfor (int j = 0; j < mapSizeX; j++) {\n\t\t\t\tint val = convertInt(br.read());\n\t\t\t\tif (val < 9) {\n\t\t\t\t\t// ???????????\u00a2????????\u00b0????\u00a8????\n\t\t\t\t\tif (val == 0)\n\t\t\t\t\t\tstartIdx = pachimonList.size();\n\t\t\t\t\tif (val == 6)\n\t\t\t\t\t\tgoalIdx = pachimonList.size();\n\t\t\t\t\tpachimonList.add(createPos(val, calcIndex(j, i)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????????????\u00a3???\u00b0???\n\t\t\tbr.readLine();\n\t\t}\n\t\tmaxNode = pachimonList.size();\n\t}\n\n\t/**\n\t * ??\u00a2????????????????????????int??????????????????\n\t * @param target ????\u00b1??????????\n\t * @return ???????????????\n\t */\n\tprivate static int convertInt(int target) {\n\t\tif (target == 83)\n\t\t\treturn 0;\n\t\tif (target == 71)\n\t\t\treturn 6;\n\t\tif (target >= 49 && target <= 53)\n\t\t\treturn target - 48;\n\t\treturn 9;\n\t}\n\n\t/**\n\t * X????????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7????\u00a8????<br>\n\t * ????????????:0?????\u00b4??????:6???????????\u00a2???????\u00b1???\u00a7:1???5<br>\n\t * Y????????????????????????????????????????\u00b4?\n\t * @param type ?????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7\n\t * @param index ??????????????????????????????\n\t * @return\n\t */\n\tprivate static Point createPos(int type, int index) {\n\t\treturn new Point(type, index);\n\t}\n\n\t/**\n\t * ?????\u00a8????????\u00a2???????????????????????????????????????????????\u00a2???????\u00b1???\u00a7?????????\n\t * @param currentType ??????????????????????????\u00a2???????\u00b1???\u00a7\n\t * @return ?????????????????????????????\u00a2???????\u00b1???\u00a7\n\t */\n\tprivate static int getNextType(int currentType) {\n\t\tif (currentType == 5)\n\t\t\treturn 1;\n\t\treturn currentType + 1;\n\t}\n\n\t/**\n\t * ??????????????????????????\u00a2?????????????????????????????????????????\u00a2???????\u00b1???\u00a7?????????\n\t * @param firstType ??????????????????????????\u00a2???????\u00b1???\u00a7\n\t * @return ?????????????????????????????\u00a2???????\u00b1???\u00a7\n\t */\n\tprivate static int getEndType(int firstType) {\n\t\tif (firstType == 1)\n\t\t\treturn 5;\n\t\treturn firstType - 1;\n\t}\n\n\t/**\n\t * ??\u00a3??\\??????????\u00a8?????????????????????????????????\u00b4???????????\u00a7???<br>\n\t * ????????????????????????????\u00b1???????\n\t * @param adjacent ??\u00a3??\\??????\n\t * @return ????????????????????????\n\t */\n\tprivate static int searchRoute(int firstType) {\n\n\t\tfor (int i = 0; i < maxNode; i++) {\n\t\t\tcost[i] = Integer.MAX_VALUE;\n\t\t\tvisited[i] = false;\n\t\t}\n\n\t\t// ??????????????\u00b0????????\u00a7???????????????0\n\t\tcost[startIdx] = 0;\n\n\t\twhile (true) {\n\t\t\t// ?\u00a8?????????????????????????????????\u00a7?????????????????????????\u00b1???????\n\t\t\tint node = minIndex(cost, visited);\n\t\t\tif (node < 0) {\n\t\t\t\treturn cost[goalIdx];\n\t\t\t}\n\t\t\t// ??\u00a2?\u00b4\u00a2???????????????????????????????????\u00b0????????????\n\t\t\tvisited[node] = true;\n\t\t\tfor (int j = 0; j < maxNode; j++) {\n\t\t\t\tif (isLinked(node, j, firstType) && !visited[j]) {\n\t\t\t\t\tint nextNodeCost = cost[node] + clucCost(pachimonList.get(node), pachimonList.get(j));\n\t\t\t\t\t// ????????\u00a7????????\u00a2??????????\u00b0????????????\u00b0???????????\u00a2??\u00a8???????\u00a8???\u00b6\n\t\t\t\t\tif (nextNodeCost < cost[j]) {\n\t\t\t\t\t\tcost[j] = nextNodeCost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * ?????\u00a8??????????????\u00a8????\u00b1??????????????????\\?\u00b6?????????????????????????????????\\\n\t * @param node ?????\u00a8????????????\n\t * @param target ????\u00b1?????????????\n\t * @return ?????\\??????\n\t */\n\tprivate static boolean isLinked(int node, int target, int firstType) {\n\t\tint currentType = pachimonList.get(node).x;\n\t\tint targetType = pachimonList.get(target).x;\n\t\t// ??????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????????????????????????????????????????\\?\u00b6????????????????\n\t\tif (currentType == firstType)\n\t\t\treturn false;\n\t\t// ????\u00b1??????????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????\u00b4????????\\?\u00b6????????????????\n\t\tif (targetType == firstType)\n\t\t\treturn false;\n\t\t// ??????????????\u00b4???????????\u00b4????????\\?\u00b6??????????????????????????????????\n\t\tif (currentType == maxNode)\n\t\t\treturn false;\n\n\t\t// ????????????????????????(\"0\")?????\u00b4??????????\u00b1???????????????????????????\u00a2???????\u00b1???\u00a7????\u00ac?????????\\?\u00b6????????????????\n\t\tif (currentType == 0)\n\t\t\treturn targetType == getNextType(firstType);\n\n\t\t// ?????\u00a8????????????????\u00b1???\u00a7????????????????????????????????\u00a2????????\u00b4????????\u00b4??????????????\\?\u00b6?\n\t\tif (currentType == getEndType(firstType))\n\t\t\treturn targetType == 6;\n\n\t\treturn getNextType(currentType) == targetType;\n\t}\n\n\t/**\n\t * ?\u00a8???????????????????????????????????????????????????????????????????????????????????\u00b1???????\n\t * @param cost ???????????????????????????\n\t * @param visited ?????????????\u00a8??????????????????????????\u00b4???????\n\t * @return ??????????????????\n\t */\n\tprivate static int minIndex(int[] cost, boolean[] visited) {\n\t\tint index = 0;\n\t\tfor (; index < maxNode; index++) {\n\t\t\tif (!visited[index])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (index == maxNode)\n\t\t\treturn -1;\n\t\tfor (int i = index + 1; i < maxNode; i++) {\n\t\t\tif (!visited[i] && cost[i] < cost[index])\n\t\t\t\tindex = i;\n\t\t}\n\t\treturn index;\n\t}\n\n\t/**\n\t * ????????????????????????????????\u00b4???????????\u00a7????????????????\u00a8?????????????\n\t * @param sx ???????????????X??\u00a7?\u00a8?\n\t * @param sy ???????????????Y??\u00a7?\u00a8?\n\t * @param gx ??\u00b4?????????X??\u00a7?\u00a8?\n\t * @param gy ??\u00b4?????????Y??\u00a7?\u00a8?\n\t * @param nextType ?\u00ac????????????????????????\u00a2????\u00b1???\u00a7\n\t */\n\tprivate static int clucCost(Point from, Point to) {\n\t\tint fx = from.y / mapSizeY;\n\t\tint fy = from.y % mapSizeY;\n\t\tint tx = to.y / mapSizeY;\n\t\tint ty = to.y % mapSizeY;\n\t\treturn Math.abs(tx - fx) + Math.abs(ty - fy);\n\t}\n\n\t/**\n\t * X??\u00a7?\u00a8???\u00a8Y??\u00a7?\u00a8???????????????\u00a3?????????????????????????????????????????\u00b4?????????\n\t *\n\t * @param x X??\u00a7?\u00a8?\n\t * @param y Y??\u00a7?\u00a8?\n\t * @return\n\t */\n\tprivate static int calcIndex(int x, int y) {\n\t\treturn x * mapSizeY + y;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] tokens = line.trim().split(\"\\\\s+\");\n            int W = Integer.parseInt(tokens[0]);\n            int H = Integer.parseInt(tokens[1]);\n            \n            if (W == 0 && H == 0) break;\n            \n            char[][] map = new char[H][W];\n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            \n            for (int i = 0; i < H; i++) {\n                String row = br.readLine();\n                for (int j = 0; j < W; j++) {\n                    map[i][j] = row.charAt(j);\n                    if (map[i][j] == 'S') {\n                        sx = i;\n                        sy = j;\n                    } else if (map[i][j] == 'G') {\n                        gx = i;\n                        gy = j;\n                    }\n                }\n            }\n            \n            int minDist = Integer.MAX_VALUE;\n            int bestAttr = -1;\n            \n            for (int startAttr = 1; startAttr <= 5; startAttr++) {\n                int dist = solve(map, H, W, sx, sy, gx, gy, startAttr);\n                if (dist != -1 && dist < minDist) {\n                    minDist = dist;\n                    bestAttr = startAttr;\n                }\n            }\n            \n            if (bestAttr == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(bestAttr + \" \" + minDist);\n            }\n        }\n    }\n    \n    static int solve(char[][] map, int H, int W, int sx, int sy, int gx, int gy, int startAttr) {\n        int targetMask = 0;\n        for (int i = 1; i <= 5; i++) {\n            if (i != startAttr) {\n                targetMask |= (1 << i);\n            }\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Map<String, Integer> visited = new HashMap<>();\n        \n        int initialMask = (1 << startAttr);\n        State start = new State(sx, sy, initialMask, 0);\n        queue.offer(start);\n        visited.put(sx + \",\" + sy + \",\" + initialMask, 0);\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.x == gx && curr.y == gy && (curr.mask & targetMask) == targetMask) {\n                return curr.dist;\n            }\n            \n            for (int d = 0; d < 4; d++) {\n                int nx = curr.x + dx[d];\n                int ny = curr.y + dy[d];\n                \n                if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                \n                int newMask = curr.mask;\n                char cell = map[nx][ny];\n                \n                if (cell >= '1' && cell <= '5') {\n                    int attr = cell - '0';\n                    if (canCatch(curr.mask, attr)) {\n                        newMask |= (1 << attr);\n                    }\n                }\n                \n                String key = nx + \",\" + ny + \",\" + newMask;\n                if (!visited.containsKey(key) || visited.get(key) > curr.dist + 1) {\n                    visited.put(key, curr.dist + 1);\n                    queue.offer(new State(nx, ny, newMask, curr.dist + 1));\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static boolean canCatch(int mask, int target) {\n        int[] catchMap = {0, 2, 3, 4, 5, 1}; // 1->2, 2->3, 3->4, 4->5, 5->1\n        for (int i = 1; i <= 5; i++) {\n            if ((mask & (1 << i)) != 0 && catchMap[i] == target) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    static class State {\n        int x, y, mask, dist;\n        \n        State(int x, int y, int mask, int dist) {\n            this.x = x;\n            this.y = y;\n            this.mask = mask;\n            this.dist = dist;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static int[] dx = {0, 0, 1, -1}; static int[] dy = {1, -1, 0, 0}; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] tokens = line.trim().split(\"\\\\s+\"); int W = Integer.parseInt(tokens[0]); int H = Integer.parseInt(tokens[1]);  map = new char[H][W]; int sx = -1, sy = -1, gx = -1, gy = -1; for (int i = 0; i < H; i++) { String row =  { map[i][j] = row.charAt(j); if (map[i][j] == 'S') { sx =  for (int startAttr = 1; startAttr <= 5; startAttr++) { int dist = solve(map, H, W, sx, sy, gx, gy, startAttr);  = dist; bestAttr = startAttr; } } if (bestAttr == -1) { System.out.println(\"NA\"); } else { System.out.println(bestAttr + \" \" +   i = 1; i <= 5; i++) { if (i != startAttr) { targetMask |= (1 << i); } } Queue<State> queue = new LinkedList<>(); Map<String, Integer> visited = new HashMap<>(); int initialMask = (1 << startAttr); State  \",\" + sy + \",\" + initialMask, 0); while (!queue.isEmpty()) { State  4; d++) { int nx = curr.x + dx[d]; int ny = curr.y + dy[d]; if (nx  ||  '5') {  newMask |= (1 <<  ny +  1) { visited.put(key, curr.dist + 1); queue.offer(new State(nx, ny, newMask, curr.dist + 1)); } } } return  catchMap = {0, 2,  for (int i  (1 <<  } } return  dist; State(int x, int y, int mask, int  mask; this.dist = dist; } } }"], "perturbed_original": ["import java.awt.Point; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.List; public class Main  \"; /** ??????????????????_X */ static  = 0; /** ??????????????\u00b0 */ static int maxNode = 0; /** ????????\u00a2??????????????? */ static List<Point> pachimonList = new ArrayList<Point>(); /** ?????????????\u00a8??????????????????????????\u00b4??????? */ static boolean[] visited = new boolean[5003]; /** ??????????????????????????? */ static int[] cost = new int[5003];  */ static  IOException  String[]  (true) { mapSizeLine = br.readLine().split(WHITE_SPACE); mapSizeX = Integer.parseInt(mapSizeLine[0]); mapSizeY =  readMap(br); output.x =  (int type =  = searchRoute(type); if (cost < output.y  cost; } } } // ??????????????? if (output.y == Integer.MAX_VALUE) { System.out.println(\"NA\"); } else   private  maxNode = 0; startIdx = 0; for (int i = 0;  j < mapSizeX; j++) { int val = convertInt(br.read()); if (val <  calcIndex(j, i))); } } //  * @param  target) {  return 6; if (target >= 49 && target <= 53) return target - 48; return 9; } /** * X????????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7????\u00a8????<br> * ????????????:0?????\u00b4??????:6???????????\u00a2???????\u00b1???\u00a7:1???5<br> * Y????????????????????????????????????????\u00b4? *  private  index); } /** * ?????\u00a8????????\u00a2???????????????????????????????????????????????\u00a2???????\u00b1???\u00a7????????? * @param currentType ??????????????????????????\u00a2???????\u00b1???\u00a7 * @return ?????????????????????????????\u00a2???????\u00b1???\u00a7 */ private static int getNextType(int currentType) { if (currentType == 5) return 1; return currentType +  @return ?????????????????????????????\u00a2???????\u00b1???\u00a7 */ private static int getEndType(int firstType) { if (firstType == 1) return 5; return firstType - 1; } /** * ??\u00a3??\\??????????\u00a8?????????????????????????????????\u00b4???????????\u00a7???<br> * ????????????????????????????\u00b1??????? * @param adjacent  { for (int i = 0; i < maxNode; i++) {  = minIndex(cost, visited); if (node < 0) { return cost[goalIdx]; } // ??\u00a2?\u00b4\u00a2???????????????????????????????????\u00b0???????????? visited[node] = true; for (int j = 0;  !visited[j]) { int  < cost[j]) { cost[j] = nextNodeCost; } } }  currentType = pachimonList.get(node).x; int targetType = pachimonList.get(target).x; // ??????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????????????????????????????????????????\\?\u00b6???????????????? if (currentType == firstType) return false; // ????\u00b1??????????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????\u00b4????????\\?\u00b6???????????????? if (targetType == firstType) return false; // ??????????????\u00b4???????????\u00b4????????\\?\u00b6?????????????????????????????????? if (currentType == maxNode) return false; // ????????????????????????(\"0\")?????\u00b4??????????\u00b1???????????????????????????\u00a2???????\u00b1???\u00a7????\u00ac?????????\\?\u00b6???????????????? if  (currentType == getEndType(firstType)) return targetType == 6; return getNextType(currentType) == targetType; } /** * ?\u00a8???????????????????????????????????????????????????????????????????????????????????\u00b1??????? * @param cost ??????????????????????????? * @param visited ?????????????\u00a8??????????????????????????\u00b4??????? * @return ?????????????????? */ private static int minIndex(int[] cost, boolean[] visited) { int index = 0; for (; index < maxNode; index++) { if (!visited[index]) break; } if (index ==  < cost[index]) index = i; } return index; } /**  * @param gx ??\u00b4?????????X??\u00a7?\u00a8? * @param gy  from, Point to) { int fx = from.y / mapSizeY; int fy  int ty = to.y % mapSizeY; return Math.abs(tx - fx)  @param x X??\u00a7?\u00a8? * @param y Y??\u00a7?\u00a8? * @return */  * mapSizeY + y; } }"], "original_ll": -0.9313032627105713, "sampled_ll": -0.34275561571121216, "all_perturbed_sampled_ll": [-1.4400160312652588], "all_perturbed_original_ll": [-1.9081376791000366], "perturbed_sampled_ll": -1.4400160312652588, "perturbed_original_ll": -1.9081376791000366, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import product\n# from line_profiler import LineProfiler\ndef main():\n    while(True):\n        W, H = map(int,input().split())\n        if not W: break\n        # ma = [[-1]*(W+2) for _ in range(H+2)]\n        ps = [[] for _ in range(5)]\n        ans = 10**10\n        for i in range(H):\n            for j,a in enumerate(input()):\n                if a == \"S\": ss = [[i,j]]\n                elif a == \"G\": gg = [[i,j]]\n                elif a != \".\": ps[int(a)-1].append([i,j])\n        # if [1 for i in range(5) if len(ps[i])==0]:\n        #     print(\"NA\"); continue\n        # print(ps)\n        B = float(\"inf\")\n        Bi = -1\n        for mon1 in range(5):\n            dp = [[float(\"inf\")]*1000 for _ in range(5)]\n            cand = [[0,ss[0][0],ss[0][1]]]\n            for mon2 in range(5):\n                dpCacheNow = dp[mon2]\n                dpCacheNxt = dp[(mon1+mon2+1)%5]\n                dpCacheNow[0] = 0\n                nxt = ps[(mon1+mon2+1)%5] if mon2<4 else gg\n                # print(nxt)\n                # print(cand)\n                tmp = []\n                for i,[ty,tx] in enumerate(nxt):\n                    # if dpCacheNow[i] >= B:\n                    #     continue\n                    tc = float(\"inf\")\n                    # for cc,cy,cx in cand:\n                    for cc,cy,cx in cand:\n                        if cc > B:\n                            # print(\"a\",end=\"\")\n                            tc = float(\"inf\")\n                            break\n                        else:\n                            tc = min(tc,abs(ty-cy)+abs(tx-cx)+cc)\n                    tmp.append([tc,ty,tx])\n                    dpCacheNxt[i] = min(dpCacheNxt[i],tc)\n                cand = tmp\n            if cand[0][0] < B:\n                B = cand[0][0]\n                Bi = mon1\n        if(Bi == -1):\n            print(\"NA\")\n        else:\n            print(\"%d %d\"%(Bi+1,B))\n        # for mon1 in range(5):\n        #     mon2 = (mon1+1)%5\n        #     dp = [[10**10]*1000 for _ in range(5)]\n        #     for i,yx in enumerate(ps[mon2]):\n        #         dp[mon2][i] = abs(ss[0]-yx[0])+abs(ss[1]-yx[1])\n        #     mon3 = mon2\n        #     for mon3 in range(mon2,mon2+3):\n        #         mon3 = mon3%5\n        #         mon4 = (mon3+1)%5\n        #         for [i,yx],[j,nyx] in product(enumerate(ps[mon3]),enumerate(ps[mon4])):\n        #             dp[mon4][j] = min(dp[mon4][j],dp[mon3][i]+abs(yx[0]-nyx[0])+abs(yx[1]-nyx[1]))\n        #     mon5 = (mon1-1)%5\n        #     for i,yx in enumerate(ps[mon5]):\n        #         d = dp[mon5][i] + abs(gg[0]-yx[0])+abs(gg[1]-yx[1])\n        #         if ans > d:\n        #             ans,ansi = d,mon1\n        # print(ansi+1,ans)\n\nif __name__ == \"__main__\":\n    # prf = LineProfiler()\n    # prf.add_function(main)\n    # prf.runcall(main)\n    # prf.print_stats()\n    main()\n", "sampled": "from collections import deque\nimport sys\n\ndef bfs(grid, start, H, W):\n    \"\"\"BFS to find shortest distances from start to all positions\"\"\"\n    dist = [[-1] * W for _ in range(H)]\n    queue = deque([start])\n    dist[start[0]][start[1]] = 0\n    \n    while queue:\n        r, c = queue.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and dist[nr][nc] == -1:\n                dist[nr][nc] = dist[r][c] + 1\n                queue.append((nr, nc))\n    \n    return dist\n\ndef solve(W, H, grid):\n    # Find S and G positions\n    start = goal = None\n    creatures = {1: [], 2: [], 3: [], 4: [], 5: []}\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n            elif grid[i][j] in '12345':\n                creatures[int(grid[i][j])].append((i, j))\n    \n    # can_catch[attr] gives which attribute attr can catch\n    can_catch = {1: 2, 2: 3, 3: 4, 4: 5, 5: 1}\n    \n    # Compute distances from start and goal\n    dist_from_start = bfs(grid, start, H, W)\n    dist_from_goal = bfs(grid, goal, H, W)\n    \n    # For each creature position, compute distance from start and to goal\n    creature_dists = {}\n    for attr in range(1, 6):\n        creature_dists[attr] = []\n        for pos in creatures[attr]:\n            ds = dist_from_start[pos[0]][pos[1]]\n            dg = dist_from_goal[pos[0]][pos[1]]\n            if ds != -1 and dg != -1:\n                creature_dists[attr].append((ds, dg, pos))\n    \n    best_attr = None\n    best_dist = float('inf')\n    \n    # Try each starting attribute\n    for start_attr in range(1, 6):\n        # Need to catch the other 4 attributes\n        to_catch = [attr for attr in range(1, 6) if attr != start_attr]\n        \n        # Check if we can catch all required attributes\n        can_solve = True\n        for attr in to_catch:\n            if not creature_dists[attr]:\n                can_solve = False\n                break\n        \n        if not can_solve:\n            continue\n        \n        # State: (current_attr, caught_set) where caught_set is a frozenset of caught attributes\n        # We want to find minimum distance to reach goal with all attributes caught\n        \n        # Use Dijkstra-like approach with states\n        from heapq import heappush, heappop\n        \n        initial_state = (start_attr, frozenset([start_attr]))\n        # dist_state[(attr, caught)] = minimum distance to have attr and caught set\n        dist_state = {}\n        dist_state[initial_state] = 0\n        pq = [(0, start_attr, frozenset([start_attr]))]\n        \n        min_dist_to_goal = float('inf')\n        \n        while pq:\n            d, curr_attr, caught = heappop(pq)\n            \n            if d > dist_state.get((curr_attr, caught), float('inf')):\n                continue\n            \n            # Check if we have all attributes and can go to goal\n            if len(caught) == 5:\n                min_dist_to_goal = min(min_dist_to_goal, d + dist_from_goal[start[0]][start[1]])\n                continue\n            \n            # Try to catch next creature\n            next_attr = can_catch[curr_attr]\n            if next_attr not in caught and creature_dists[next_attr]:\n                # Find closest creature of next_attr from current position\n                # We need to track position too...\n                \n                for ds, dg, pos in creature_dists[next_attr]:\n                    new_caught = caught | {next_attr}\n                    new_dist = ds  # Distance from start to this creature\n                    new_state = (next_attr, new_caught)\n                    \n                    if new_dist < dist_state.get(new_state, float('inf')):\n                        dist_state[new_state] = new_dist\n                        heappush(pq, (new_dist, next_attr, new_caught))\n        \n        # This approach is getting complex. Let me try simpler state space.\n        # State: frozenset of caught attributes\n        # For each state, track minimum distance and where we are\n        \n        # Actually, let's use different approach\n        # Try all permutations of catching order and compute minimum\n        \n        from itertools import permutations\n        \n        for order in permutations(to_catch):\n            # Check if this order is valid (can catch in sequence)\n            current_attr = start_attr\n            valid = True\n            for attr in order:\n                if can_catch[current_attr] != attr:\n                    valid = False\n                    break\n                current_attr = attr\n            \n            if not valid:\n                continue\n            \n            # Compute minimum distance for this order\n            total_dist = 0\n            prev_pos = start\n            valid_path = True\n            \n            for attr in order:\n                # Find closest creature of this attribute from prev_pos\n                min_d = float('inf')\n                next_pos = None\n                \n                for pos in creatures[attr]:\n                    # BFS from prev_pos to pos\n                    d = dist_from_start[pos[0]][pos[1]]  # This is wrong, need distance from prev_pos\n                    \n                # This is getting complicated. Need to precompute all distances\n                \n        # Let me use a simpler DP approach with memoization\n        \n    # Simpler approach: try all orderings using DP\n    # Actually the constraints make this feasible\n    \n    # For each starting attribute, do BFS on state space\n    for start_attr in range(1, 6):\n        # BFS on (position, caught_set)\n        initial = (start, frozenset([start_attr]), start_attr)\n        queue = deque([initial])\n        visited = {(start, frozenset([start_attr]), start_attr): 0}\n        \n        while queue:\n            pos, caught, curr_attr = queue.popleft()\n            dist = visited[(pos, caught, curr_attr)]\n            \n            # If we have all 5 attributes and at goal\n            if len(caught) == 5 and pos == goal:\n                if dist < best_dist or (dist == best_dist and start_attr < best_attr):\n                    best_dist = dist\n                    best_attr = start_attr\n                continue\n            \n            # Try moving to adjacent cells\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = pos[0] + dr, pos[1] + dc\n                if 0 <= nr < H and 0 <= nc < W:\n                    new_pos = (nr, nc)\n                    new_caught = caught\n                    new_attr = curr_attr\n                    \n                    # Check if we catch a creature here\n                    cell = grid[nr][nc]\n                    if cell in '12345':\n                        creature_attr = int(cell)\n                        if can_catch[curr_attr] == creature_attr:\n                            new_caught = caught | {creature_attr}\n                            new_attr = creature_attr\n                    \n                    new_state = (new_pos, new_caught, new_attr)\n                    if new_state not in visited or visited[new_state] > dist + 1:\n                        visited[new_state] = dist + 1\n                        queue.append(new_state)\n    \n    if best_attr is None:\n        return \"NA\"\n    else:\n        return f\"{best_attr} {best_dist}\"\n\nwhile True:\n    line = input().split()\n    W, H = int(line[0]), int(line[1])\n    if W == 0 and H == 0:\n        break\n    \n    grid = []\n    for _ in range(H):\n        grid.append(input().strip())\n    \n    print(solve(W, H, grid))\n", "perturbed_sampled": ["from collections import deque import sys def bfs(grid, start, H, W): \"\"\"BFS to find shortest distances from start to all positions\"\"\" dist = [[-1] * W for _ in range(H)] queue = deque([start]) dist[start[0]][start[1]] = 0 while queue: r, c = queue.popleft() for  = dist[r][c] + 1 queue.append((nr, nc)) return dist def solve(W, H, grid): # Find S and G positions start = goal = None creatures  []} for i in range(H): for j in range(W): if grid[i][j] == 'S': start = (i, j) elif  '12345': creatures[int(grid[i][j])].append((i, j)) # can_catch[attr] gives which attribute attr can catch can_catch = {1: 2, 2: 3, 3: 4, 4: 5, 5: 1} # Compute distances from start and goal dist_from_start = bfs(grid, start, H, W) dist_from_goal = bfs(grid, goal, H, W) # For each creature position, compute distance from start and  dist_from_start[pos[0]][pos[1]] dg  to_catch =  # Check if we can  to_catch: if not creature_dists[attr]: can_solve = False  caught_set is a frozenset  to reach goal with all attributes caught # Use Dijkstra-like approach with states from heapq import heappush, heappop initial_state = (start_attr, frozenset([start_attr])) # dist_state[(attr, caught)] = minimum distance to have attr and caught set dist_state = {} dist_state[initial_state]  continue # Try to catch next creature next_attr = can_catch[curr_attr] if next_attr not in caught  position # We need to track position too... for ds, dg,  ds # Distance from  < dist_state.get(new_state, float('inf')): dist_state[new_state] = new_dist heappush(pq, (new_dist, next_attr, new_caught)) # This  state, track minimum distance  # Try all permutations of catching order and compute minimum from itertools import permutations  valid (can catch in sequence) current_attr = start_attr valid = True  False break current_attr = attr if not valid: continue # Compute minimum distance for this order total_dist = 0 prev_pos = start valid_path = True for attr in order: # Find closest creature of this attribute from prev_pos min_d = float('inf') next_pos = None for pos in creatures[attr]: # BFS from prev_pos to pos d = dist_from_start[pos[0]][pos[1]] # This is wrong, need distance from prev_pos  memoization # Simpler approach: try all orderings using DP # Actually the constraints make this feasible # For  in range(1, 6): # BFS on (position, caught_set) initial = (start, frozenset([start_attr]), start_attr) queue = deque([initial]) visited = {(start, frozenset([start_attr]), start_attr):  visited[(pos, caught, curr_attr)] # If we have all  pos == goal: if dist < best_dist or (dist == best_dist and start_attr < best_attr): best_dist = dist best_attr = start_attr continue # Try moving to adjacent cells for dr, dc  nc = pos[0] + dr, pos[1] + dc if 0 <= nr <   we catch a creature here cell = grid[nr][nc] if cell in   new_attr) if new_state not in visited   f\"{best_attr} {best_dist}\" while True: line = input().split() W, H = int(line[0]),  H, grid))"], "perturbed_original": ["from itertools import product # from line_profiler import LineProfiler def main(): while(True): W, H = map(int,input().split()) if not W: break # ma = [[-1]*(W+2) for _ in range(H+2)] ps = [[] for _ in  in enumerate(input()): if a  = [[i,j]] elif a != \".\": ps[int(a)-1].append([i,j]) #  continue # print(ps) B = float(\"inf\") Bi = -1 for mon1 in range(5): dp = [[float(\"inf\")]*1000 for _ in range(5)] cand  = dp[(mon1+mon2+1)%5] dpCacheNow[0] = 0 nxt = ps[(mon1+mon2+1)%5]  [] for i,[ty,tx] in  float(\"inf\") # for cc,cy,cx in cand: for cc,cy,cx in cand: if  tc = min(tc,abs(ty-cy)+abs(tx-cx)+cc) tmp.append([tc,ty,tx]) dpCacheNxt[i] = min(dpCacheNxt[i],tc)  Bi = mon1 if(Bi == -1): print(\"NA\")  = (mon1+1)%5 # dp = [[10**10]*1000 for _ in range(5)] # for i,yx  # mon4 = (mon3+1)%5  d = dp[mon5][i] + abs(gg[0]-yx[0])+abs(gg[1]-yx[1]) # if ans > d: # ans,ansi = d,mon1 # print(ansi+1,ans)  # prf.runcall(main) # prf.print_stats() main()"], "original_ll": -1.0055713653564453, "sampled_ll": -0.8013255000114441, "all_perturbed_sampled_ll": [-2.2289950847625732], "all_perturbed_original_ll": [-2.2837977409362793], "perturbed_sampled_ll": -2.2289950847625732, "perturbed_original_ll": -2.2837977409362793, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\t\tint n,t,i,k,j,g,s,r,a,w,z,o;\n\twhile(1)\t{\n\t\tscanf(\"%d\",&t);\n\t\tif(t==-1)\tbreak;\n\t\tif(10>=t){\n\t\t\tprintf(\"3130\\n\");\n\t\t\t}\n\t\tif(t>10&&t<20){\n\t\t\tn=t-10;\n\t\t\ti=4280-(n*125+1150);\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\t}\n\t\tif(t>20&&t<30){\n\t\t\tk=t-20;\n\t\t\tj=4280-((k*140)+2400);\n\t\t\tprintf(\"%d\\n\",j);\n\t\t}\n\t\tif(t>30){\n\t\t\ts=t-30;\n\t\t\tg=4280-((s*160)+3800);\n\t\t\tprintf(\"%d\\n\",g);\n\t\t}\t\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint calculate_bill(int w) {\n    int bill = 1150; // base charge\n    \n    if (w <= 10) {\n        return bill;\n    }\n    \n    if (w <= 20) {\n        bill += (w - 10) * 125;\n        return bill;\n    }\n    \n    bill += 10 * 125;\n    \n    if (w <= 30) {\n        bill += (w - 20) * 140;\n        return bill;\n    }\n    \n    bill += 10 * 140;\n    bill += (w - 30) * 160;\n    \n    return bill;\n}\n\nint main() {\n    int w;\n    int last_month = 4280;\n    \n    while (1) {\n        scanf(\"%d\", &w);\n        if (w == -1) break;\n        \n        int current_bill = calculate_bill(w);\n        int savings = last_month - current_bill;\n        \n        printf(\"%d\\n\", savings);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int calculate_bill(int w) { int bill = 1150; // base charge if (w <=  bill += (w - 10) * 125; return bill; } bill += 10 * 125; if (w <= 30) { bill += (w - 20) * 140; return bill;  int w; int last_month = 4280; while (1)  savings); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int n,t,i,k,j,g,s,r,a,w,z,o; while(1) { scanf(\"%d\",&t); if(t==-1) break;  j=4280-((k*140)+2400); printf(\"%d\\n\",j); } if(t>30){ s=t-30; g=4280-((s*160)+3800); printf(\"%d\\n\",g); } } return 0; }"], "original_ll": -1.2633799314498901, "sampled_ll": -0.774692177772522, "all_perturbed_sampled_ll": [-2.4346468448638916], "all_perturbed_original_ll": [-2.0758886337280273], "perturbed_sampled_ll": -2.4346468448638916, "perturbed_original_ll": -2.0758886337280273, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\twhile(kbd.hasNext()) {\n\t    int w = kbd.nextInt();\n\t    if(w!=-1){\n\t\tSystem.out.println(4280-solve(w));\n\t    }\n\t}\n    }\n\n    static int solve(int w) {\n\tint r = 0;\n\tint bill = 0;\n\twhile(w>=0){\n\t    bill += cost(w, r);\n\t    w -= 10;\n\t    r ++;\n\t    //System.out.println(\"p\");\n\t}\n\treturn bill;\n    }\n\n    static int cost(int w, int r){\n\tif(r==0){ return 1150; }\n\telse if(r==1){ \n\t    if(w>=10) return 125*10;\n\t    else return 125*w;\n\t}\n\telse if(r==2){\n\t    if(w>=10) return 140*10;\n\t    else return 140*w;\n\t}\n\telse if(r>2){\n\t    if(w>=10) return 160*10;\n\t    else return 160*w;\n\t}\n\telse return 0;\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int w = sc.nextInt();\n            if (w == -1) break;\n            \n            int currentBill = calculateBill(w);\n            int difference = 4280 - currentBill;\n            System.out.println(difference);\n        }\n        \n        sc.close();\n    }\n    \n    static int calculateBill(int w) {\n        int bill = 1150; // Base charge\n        \n        if (w <= 10) {\n            return bill;\n        }\n        \n        // Second tier: 10 < w <= 20\n        if (w <= 20) {\n            bill += (w - 10) * 125;\n            return bill;\n        }\n        \n        bill += 10 * 125; // Full second tier\n        \n        // Third tier: 20 < w <= 30\n        if (w <= 30) {\n            bill += (w - 20) * 140;\n            return bill;\n        }\n        \n        bill += 10 * 140; // Full third tier\n        \n        // Fourth tier: w > 30\n        bill += (w - 30) * 160;\n        \n        return bill;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  = new Scanner(System.in); while  break; int currentBill = calculateBill(w); int  Base charge if (w <=  += (w - 10) * 125; return bill; } bill += 10 * 125; // Full second tier // Third tier: 20  += (w - 20) * 140; return bill; } bill += 10 * 140; // Full third tier // Fourth tier: w > 30 bill += (w - 30) * 160; return bill; } }"], "perturbed_original": ["import java.util.*; public class Main  main(String[]  = 0; int bill = 0; while(w>=0){ bill += cost(w, r); w -= 10; r ++; //System.out.println(\"p\"); } return bill; } static int  if(w>=10) return 125*10; else return 125*w; } else if(r==2){ if(w>=10) return 140*10; else return 140*w; } else if(r>2){ if(w>=10) return 160*10; else return 160*w; } else return 0; } }"], "original_ll": -1.0164531469345093, "sampled_ll": -0.663398802280426, "all_perturbed_sampled_ll": [-2.0595240592956543], "all_perturbed_original_ll": [-1.7931596040725708], "perturbed_sampled_ll": -2.0595240592956543, "perturbed_original_ll": -1.7931596040725708, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def fee(w):\n    if w>30:\n        return (w-30)*160+10*140+10*125+1150\n    if w>20:\n        return (w-20)*140+10*125+1150\n    if w>10:\n        return (w-10)*125+1150\n    return 1150\n\nprev_m=4280\nwhile True:\n    W=int(input())\n    if W==-1:\n        break\n    print(prev_m-fee(W))\n    # prev_m=fee(W)\n\n", "sampled": "def calculate_water_bill(w):\n    if w <= 10:\n        return 1150\n    elif w <= 20:\n        return 1150 + (w - 10) * 125\n    elif w <= 30:\n        return 1150 + 10 * 125 + (w - 20) * 140\n    else:\n        return 1150 + 10 * 125 + 10 * 140 + (w - 30) * 160\n\nlast_month_bill = 4280\n\nwhile True:\n    w = int(input())\n    if w == -1:\n        break\n    \n    current_bill = calculate_water_bill(w)\n    savings = last_month_bill - current_bill\n    print(savings)\n", "perturbed_sampled": ["def calculate_water_bill(w): if w <= 10: return 1150 elif w  elif w <= 30: return 1150 + 10 * 125 +  *  160 last_month_bill = 4280 while True: w = int(input()) if w == -1: break current_bill = calculate_water_bill(w) savings = last_month_bill - current_bill print(savings)"], "perturbed_original": ["def fee(w): if w>30:  return 1150 prev_m=4280 while True: W=int(input()) if W==-1: break print(prev_m-fee(W)) # prev_m=fee(W)"], "original_ll": -1.1446994543075562, "sampled_ll": -0.802867591381073, "all_perturbed_sampled_ll": [-2.2834978103637695], "all_perturbed_original_ll": [-3.026731491088867], "perturbed_sampled_ll": -2.2834978103637695, "perturbed_original_ll": -3.026731491088867, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main()\n{\n\tint i,a,b,c,d,max=0,s=0;\n\tscanf(\"%d\",&a);\n\twhile(a!=0){\n\t\ts=0;\nmax=0;\n\tfor(i=0;i<a;i++){\n\t\tscanf(\"%d %d %d\",&b,&c,&d);\n\t\tc=c+d;\n\t\tif(max<c){\n\t\t\tmax=c;\n\t\t\ts=b;\n\t\t}\n\t}\n\t\n\tprintf(\"%d %d\\n\",s,max);\n\tscanf(\"%d\",&a);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int max_id = 0;\n        int max_distance = -1;\n        \n        for(int i = 0; i < n; i++) {\n            int p, d1, d2;\n            scanf(\"%d %d %d\", &p, &d1, &d2);\n            int total = d1 + d2;\n            \n            if(total > max_distance) {\n                max_distance = total;\n                max_id = p;\n            }\n        }\n        \n        printf(\"%d %d\\n\", max_id, max_distance);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) { scanf(\"%d\", &n); if(n == 0) break; int max_id =  < n; i++) { int  total = d1 + d2; if(total > max_distance) { max_distance = total;  return 0; }"], "perturbed_original": ["#include<stdio.h> int main() { int i,a,b,c,d,max=0,s=0; scanf(\"%d\",&a); while(a!=0){ s=0; max=0;  printf(\"%d %d\\n\",s,max); scanf(\"%d\",&a); } return 0; }"], "original_ll": -1.1264793872833252, "sampled_ll": -0.5757142305374146, "all_perturbed_sampled_ll": [-2.269909143447876], "all_perturbed_original_ll": [-1.8752501010894775], "perturbed_sampled_ll": -2.269909143447876, "perturbed_original_ll": -1.8752501010894775, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\n\n\npublic class Main {\n\n\tprivate BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1);\n\n\tprivate String inputData = null;\n\n\tpublic String[] data = null;\n\n\tpublic int num = 0;\n\n\tpublic int count = 0;\n\n\tpublic HashMap<Integer, Integer> humanData = new HashMap<Integer, Integer>();\n\n\tpublic ArrayList<Integer> topId = new ArrayList<Integer>();\n\n\tpublic ArrayList<Integer> topLength = new ArrayList<Integer>();\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().start();\n\t\tSystem.exit(0);\n\t}\n\n\tpublic void start() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\tif (this.data.length == 1) {\n\t\t\t\tif (this.data[0].equals(\"0\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.num = Integer.parseInt(this.data[0]);\n\t\t\t}\n\n\t\t\tthis.humanData.clear();\n\n\t\t\tfor (int i = 0; i < this.num; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\t\tthis.humanData.put(Integer.parseInt(data[0]),\n\t\t\t\t\t\tInteger.parseInt(data[1]) + Integer.parseInt(data[2]));\n\n\t\t\t}\n\n\t\t\tIterator<Integer> itId = this.humanData.keySet().iterator();\n\t\t\tint numCount = 0;\n\t\t\twhile (itId.hasNext()) {\n\t\t\t\tint id = itId.next();\n\t\t\t\tif (numCount == 0) {\n\t\t\t\t\tthis.topId.add(id);\n\t\t\t\t\tthis.topLength.add(this.humanData.get(id));\n\t\t\t\t} else {\n\t\t\t\t\tif (this.topLength.get(count) <= this.humanData.get(id)) {\n\t\t\t\t\t\tthis.topId.set(this.count, id);\n\t\t\t\t\t\tthis.topLength.set(this.count, this.humanData.get(id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnumCount++;\n\t\t\t}\n\n\t\t\tthis.count++;\n\n\t\t}\n\n\t\tfor (int i = 0; i < this.topId.size(); i++) {\n\t\t\tSystem.out.println(this.topId.get(i) + \" \" + this.topLength.get(i));\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int maxPatient = 0;\n            int maxDistance = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int p = sc.nextInt();\n                int d1 = sc.nextInt();\n                int d2 = sc.nextInt();\n                int total = d1 + d2;\n                \n                if (total > maxDistance) {\n                    maxDistance = total;\n                    maxPatient = p;\n                }\n            }\n            \n            System.out.println(maxPatient + \" \" + maxDistance);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main  new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int maxPatient = 0; int maxDistance  i++) { int p = sc.nextInt(); int d1  + d2; if (total > maxDistance) { maxDistance = total; maxPatient = p;  } }"], "perturbed_original": ["import  java.util.Iterator; public class Main { private BufferedReader reader = new BufferedReader(new InputStreamReader(System.in),  null; public int num = 0; public  HashMap<Integer, Integer>(); public ArrayList<Integer> topId = new ArrayList<Integer>(); public ArrayList<Integer> topLength = new ArrayList<Integer>(); public  this.data = this.inputData.split(\" \"); if (this.data.length == 1) { if (this.data[0].equals(\"0\")) { break; } this.num = Integer.parseInt(this.data[0]); } this.humanData.clear(); for (int i = 0; i < this.num; i++) { try { this.inputData = reader.readLine(); } catch (IOException e) { e.printStackTrace(); } this.data = this.inputData.split(\" \"); this.humanData.put(Integer.parseInt(data[0]), Integer.parseInt(data[1]) + Integer.parseInt(data[2])); } Iterator<Integer> itId = this.humanData.keySet().iterator(); int numCount = 0; while  this.humanData.get(id))  } for  + \" \" + this.topLength.get(i)); } } }"], "original_ll": -0.5777104496955872, "sampled_ll": -0.5270640254020691, "all_perturbed_sampled_ll": [-1.9785089492797852], "all_perturbed_original_ll": [-1.561225175857544], "perturbed_sampled_ll": -1.9785089492797852, "perturbed_original_ll": -1.561225175857544, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(input())\n    if n == 0:\n        break\n\n    patients = []\n    for _ in range(n):\n        p, d1, d2 = map(int, input().split())\n        patients.append((p, d1+d2))\n    print(*max(patients, key=lambda x: x[1]))", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    max_distance = -1\n    max_patient = -1\n    \n    for _ in range(n):\n        data = list(map(int, input().split()))\n        patient_id = data[0]\n        d1 = data[1]\n        d2 = data[2]\n        total_distance = d1 + d2\n        \n        if total_distance > max_distance:\n            max_distance = total_distance\n            max_patient = patient_id\n    \n    print(max_patient, max_distance)\n", "perturbed_sampled": ["while True: n = int(input()) if n ==  d1 = data[1] d2 = data[2] total_distance = d1 + d2 if total_distance > max_distance: max_distance = total_distance max_patient = patient_id print(max_patient, max_distance)"], "perturbed_original": ["while True: n =  _ in range(n): p, d1, d2 = map(int, input().split()) patients.append((p, d1+d2)) print(*max(patients, key=lambda x: x[1]))"], "original_ll": -1.0328561067581177, "sampled_ll": -0.7540817260742188, "all_perturbed_sampled_ll": [-2.141268014907837], "all_perturbed_original_ll": [-2.3266446590423584], "perturbed_sampled_ll": -2.141268014907837, "perturbed_original_ll": -2.3266446590423584, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "m,e,j,s;main(n){for(;scanf(\"%d\",&n)*n;)for(;n--;puts(m>99|e>99|j>99|m+e>179|s>239?\"A\":s>209||s>149&&m>79|e>79?\"B\":\"C\"))scanf(\"%d%d%d\",&m,&e,&j),s=m+e+j;}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        for(int i = 0; i < n; i++) {\n            int pm, pe, pj;\n            scanf(\"%d %d %d\", &pm, &pe, &pj);\n            \n            char cls = 'C';\n            \n            // Check conditions for A class\n            if(pm == 100 || pe == 100 || pj == 100) {\n                cls = 'A';\n            }\n            else if((pm + pe) / 2.0 >= 90) {\n                cls = 'A';\n            }\n            else if((pm + pe + pj) / 3.0 >= 80) {\n                cls = 'A';\n            }\n            // Check conditions for B class\n            else if((pm + pe + pj) / 3.0 >= 70) {\n                cls = 'B';\n            }\n            else if((pm + pe + pj) / 3.0 >= 50 && (pm >= 80 || pe >= 80)) {\n                cls = 'B';\n            }\n            \n            printf(\"%c\\n\", cls);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(1) pj products).sort();<extra_id_6>]<extra_id_7>) ) { n<extra_id_8>} for<extra_id_9>, 99)<extra_id_10>pj in<extra_id_11>pe*3.0 :<extra_id_12>+ pj*3.0; print(\"%c\\n\"); }<extra_id_13>pj = 'A'; if<extra_id_14>+<extra_id_15>pj;<extra_id_16>pj; pj; scanf(\"%d %d  conditions for A class if(pm == 100 || pe == 100 || pj  pe) / 2.0 >= 90) { cls = 'A'; } else if((pm + pe + pj) / 3.0 >= 80) { cls =  + pe + pj) / 3.0 >=  + pj) / 3.0 >= 50 && (pm >= 80 || pe >= 80)) { cls = 'B'; } printf(\"%c\\n\", cls); } } return 0; }"], "perturbed_original": ["m,e,j,s;main(n){for(;scanf(\"%d\",&n)*n;)for(;n--;puts(m>99|e>99|j>99|m+e>179|s>239?\"A\":s>209||s>149&&m>79|e>79?\"B\":\"C\"))scanf(\"%d%d%d\",&m,&e,&j),s=m+e+j;}"], "original_ll": -2.1598589420318604, "sampled_ll": -0.6371092200279236, "all_perturbed_sampled_ll": [-2.4500958919525146], "all_perturbed_original_ll": [-2.1598589420318604], "perturbed_sampled_ll": -2.4500958919525146, "perturbed_original_ll": -2.1598589420318604, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tchar c[]=new char[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint pm=sc.nextInt();\n\t\t\t\tint pe=sc.nextInt();\n\t\t\t\tint pj=sc.nextInt();\n\t\t\t\tif(pm==100||pe==100||pj==100)c[i]='A';\n\t\t\t\telse if((pm+pe)/2>=90)c[i]='A';\n\t\t\t\telse if((pm+pe+pj)/3>=80)c[i]='A';\n\t\t\t\telse if((pm+pe+pj)/3>=70)c[i]='B';\n\t\t\t\telse if((pm+pe+pj)/3>=50&&(pm>=80||pe>=80))c[i]='B';\n\t\t\t\telse c[i]='C';\n\t\t\t\tSystem.out.println(c[i]);\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            for (int i = 0; i < n; i++) {\n                int pm = sc.nextInt();\n                int pe = sc.nextInt();\n                int pj = sc.nextInt();\n                \n                String cls = getClass(pm, pe, pj);\n                System.out.println(cls);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static String getClass(int pm, int pe, int pj) {\n        // Check for class A conditions\n        if (pm == 100 || pe == 100 || pj == 100) {\n            return \"A\";\n        }\n        \n        double mathEngAvg = (pm + pe) / 2.0;\n        if (mathEngAvg >= 90) {\n            return \"A\";\n        }\n        \n        double threeAvg = (pm + pe + pj) / 3.0;\n        if (threeAvg >= 80) {\n            return \"A\";\n        }\n        \n        // Check for class B conditions\n        if (threeAvg >= 70) {\n            return \"B\";\n        }\n        \n        if (threeAvg >= 50 && (pm >= 80 || pe >= 80)) {\n            return \"B\";\n        }\n        \n        // Otherwise class C\n        return \"C\";\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  = 0; i < n; i++) { int  sc.nextInt(); String cls = getClass(pm,  pm, int pe, int pj) { // Check for class A conditions if (pm ==  return \"A\"; } double mathEngAvg = (pm +  } double threeAvg = (pm + pe  \"A\"; } // Check for class B conditions if (threeAvg >= 70) { return \"B\"; } if (threeAvg >= 50 && (pm >= 80 || pe >= 80)) { return \"B\"; } // Otherwise class C return \"C\"; } }"], "perturbed_original": ["import java.util.*; public class Main { public static void  char c[]=new char[n];  if((pm+pe)/2>=90)c[i]='A'; else if((pm+pe+pj)/3>=80)c[i]='A'; else if((pm+pe+pj)/3>=70)c[i]='B'; else if((pm+pe+pj)/3>=50&&(pm>=80||pe>=80))c[i]='B'; else c[i]='C'; System.out.println(c[i]); } } } }"], "original_ll": -0.7470335364341736, "sampled_ll": -0.6726406216621399, "all_perturbed_sampled_ll": [-2.644252061843872], "all_perturbed_original_ll": [-1.819464087486267], "perturbed_sampled_ll": -2.644252061843872, "perturbed_original_ll": -1.819464087486267, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n = int(input())\n    if n == 0: break\n    i = 0\n    while True:\n        if i == n: break\n        m, e, j = map(int, input().split())\n        sum = m + e + j\n        if m==100 or e==100 or j==100:\n            print(\"A\")\n        elif (m+e)/2 >= 90:\n            print(\"A\")\n        elif sum/3 >= 80:\n            print(\"A\")\n        elif sum/3 >= 70:\n            print(\"B\")\n        elif sum/3 >= 50 and m >= 80 or e >= 80:\n            print(\"B\")\n        else:\n            print(\"C\")\n        i += 1\n    \n", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    for _ in range(n):\n        pm, pe, pj = map(int, input().split())\n        \n        # Check conditions for class A\n        if pm == 100 or pe == 100 or pj == 100:\n            print(\"A\")\n            continue\n        \n        if (pm + pe) / 2 >= 90:\n            print(\"A\")\n            continue\n        \n        if (pm + pe + pj) / 3 >= 80:\n            print(\"A\")\n            continue\n        \n        # Check conditions for class B\n        if (pm + pe + pj) / 3 >= 70:\n            print(\"B\")\n            continue\n        \n        if (pm + pe + pj) / 3 >= 50 and (pm >= 80 or pe >= 80):\n            print(\"B\")\n            continue\n        \n        # Otherwise class C\n        print(\"C\")\n", "perturbed_sampled": [" for _ in range(n): pm, pe, pj  pm == 100 or pe == 100  / 2 >= 90: print(\"A\") continue if (pm + pe + pj) / 3 >=  (pm + pe  + pe + pj) / 3 >= 50 and (pm >= 80 or pe >= 80): print(\"B\") continue # Otherwise class C print(\"C\")"], "perturbed_original": ["while 1: n = int(input()) if n == 0: break i = 0 while True: if i == n: break m, e, j = map(int,  print(\"A\") elif sum/3 >= 80: print(\"A\") elif sum/3 >= 70: print(\"B\")  >= 80: print(\"B\") else: print(\"C\") i += 1"], "original_ll": -0.8289682269096375, "sampled_ll": -0.7510015964508057, "all_perturbed_sampled_ll": [-2.4110536575317383], "all_perturbed_original_ll": [-1.705552577972412], "perturbed_sampled_ll": -2.4110536575317383, "perturbed_original_ll": -1.705552577972412, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main()\n{\n    int n;\n    int c;\n\n    while (scanf(\"%d\", &n), n != 0) {\n        int cnt[10] = {};\n\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &c);\n\n            cnt[c]++;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            if (cnt[i] == 0) {\n                putchar('-');\n            }\n            else {\n                for (int j = 0; j < cnt[i]; j++) {\n                    putchar('*');\n                }\n            }\n\n            putchar('\\n');\n        }\n    }\n\n    return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int count[10] = {0};\n        \n        for(int i = 0; i < n; i++) {\n            int c;\n            scanf(\"%d\", &c);\n            count[c]++;\n        }\n        \n        for(int i = 0; i < 10; i++) {\n            if(count[i] == 0) {\n                printf(\"-\\n\");\n            } else {\n                for(int j = 0; j < count[i]; j++) {\n                    printf(\"*\");\n                }\n                printf(\"\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int >=<extra_id_1>{ int count[10] = {0}; for(int i = 0; i < n; i++) { int c; scanf(\"%d\", &c); count[c]++; } for(int i = 0; i < 10; i++) { +=<extra_id_2>++<extra_id_3>int j = count[j];<extra_id_4>. println<extra_id_5>count<extra_id_6>10); } = 0; j < count[i];  }"], "perturbed_original": ["#include <stdio.h>  n !=  0; i < n; i++) { scanf(\"%d\", &c); cnt[c]++; } for (int i = 0; i < 10; i++) { if (cnt[i] == 0) {  < cnt[i]; j++) { putchar('*'); } } putchar('\\n'); } } return 0; }"], "original_ll": -0.6378297805786133, "sampled_ll": -0.46559852361679077, "all_perturbed_sampled_ll": [-2.160862684249878], "all_perturbed_original_ll": [-1.788947582244873], "perturbed_sampled_ll": -2.160862684249878, "perturbed_original_ll": -1.788947582244873, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] num = new int[10];\n\t\t\twhile(n-->0){\n\t\t\t\tnum[scanner.nextInt()]++;\n\t\t\t}\n\t\t\tfor(int a:num){\n\t\t\t\tif(a==0)\n\t\t\t\t\tSystem.out.println('-');\n\t\t\t\telse{\n\t\t\t\t\tchar[] c = new char[a];\n\t\t\t\t\tArrays.fill(c, '*');\n\t\t\t\t\tSystem.out.println(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] count = new int[10];\n            \n            for (int i = 0; i < n; i++) {\n                int c = sc.nextInt();\n                count[c]++;\n            }\n            \n            for (int i = 0; i < 10; i++) {\n                if (count[i] == 0) {\n                    System.out.println(\"-\");\n                } else {\n                    for (int j = 0; j < count[i]; j++) {\n                        System.out.print(\"*\");\n                    }\n                    System.out.println();\n                }\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static  (true) { int n = sc.nextInt(); if  (int i = 0; i < n; i++) { int c = sc.nextInt(); count[c]++; } for (int i  0) {  < count[i]; j++) { System.out.print(\"*\"); } System.out.println(); } } } sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String[] args) throws IOException { new Main().run(); } private void run()  break; int[] num = new int[10];  = new char[a]; Arrays.fill(c, '*'); System.out.println(c); } } } } }"], "original_ll": -0.7898843884468079, "sampled_ll": -0.423195481300354, "all_perturbed_sampled_ll": [-1.9808963537216187], "all_perturbed_original_ll": [-1.904402494430542], "perturbed_sampled_ll": -1.9808963537216187, "perturbed_original_ll": -1.904402494430542, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    q={}\n    a=input()\n    if a==0:break\n    for i in range(10): q[i]=0\n    for i in range(a): q[input()]+=1\n    for i in range(10):  print \"*\"*q[i] if q[i] != 0 else \"-\"", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = [0] * 10\n    for _ in range(n):\n        c = int(input())\n        count[c] += 1\n    \n    for i in range(10):\n        if count[i] == 0:\n            print('-')\n        else:\n            print('*' * count[i])\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break count = [0] * 10 for _ in range(n): c = int(input())  0: print('-') else: print('*' * count[i])"], "perturbed_original": ["while True: q={} a=input() if a==0:break for i in range(10): q[i]=0 for i in range(a): q[input()]+=1  else \"-\""], "original_ll": -1.6992006301879883, "sampled_ll": -0.7539748549461365, "all_perturbed_sampled_ll": [-2.159559488296509], "all_perturbed_original_ll": [-2.9793057441711426], "perturbed_sampled_ll": -2.159559488296509, "perturbed_original_ll": -2.9793057441711426, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  double n;\n  char a[12];\n  int m,i;\n  while(1){\n    scanf(\"%lf\",&n);\n    if(n<0)break;\n    n*=16;\n    m=n;\n    if(m-n){\n      printf(\"NA\\n\");\n      continue;\n    }\n    for(i=12;i;i--){\n      a[i-1]=m%2+'0';\n      m/=2;\n    }\n    if(m){\n      printf(\"NA\\n\");\n      continue;\n    }\n    for(i=0;i<12;i++){\n      if(i==8)printf(\".\");\n      printf(\"%c\",a[i]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\nint main() {\n    double n;\n    \n    while (scanf(\"%lf\", &n) == 1) {\n        if (n < 0) break;\n        \n        // Extract integer and fractional parts\n        int int_part = (int)n;\n        double frac_part = n - int_part;\n        \n        // Check if integer part fits in 8 bits\n        if (int_part > 255) {\n            printf(\"NA\\n\");\n            continue;\n        }\n        \n        // Convert integer part to binary (8 bits)\n        char int_binary[9];\n        for (int i = 7; i >= 0; i--) {\n            int_binary[i] = (int_part % 2) + '0';\n            int_part /= 2;\n        }\n        int_binary[8] = '\\0';\n        \n        // Convert fractional part to binary (4 bits)\n        char frac_binary[5];\n        int valid = 1;\n        double temp_frac = frac_part;\n        \n        for (int i = 0; i < 4; i++) {\n            temp_frac *= 2;\n            if (temp_frac >= 1) {\n                frac_binary[i] = '1';\n                temp_frac -= 1;\n            } else {\n                frac_binary[i] = '0';\n            }\n        }\n        frac_binary[4] = '\\0';\n        \n        // Check if there's remaining fractional part\n        temp_frac *= 2;\n        if (temp_frac > 0.0001) {  // Allow small floating point error\n            valid = 0;\n        }\n        \n        // Alternative check: reconstruct the number and compare\n        double reconstructed = 0;\n        int int_val = 0;\n        for (int i = 0; i < 8; i++) {\n            int_val = int_val * 2 + (int_binary[i] - '0');\n        }\n        reconstructed = int_val;\n        \n        double frac_val = 0;\n        for (int i = 0; i < 4; i++) {\n            frac_val = frac_val + (frac_binary[i] - '0') * pow(0.5, i + 1);\n        }\n        reconstructed += frac_val;\n        \n        if (fabs(reconstructed - n) > 0.0001) {\n            valid = 0;\n        }\n        \n        if (valid) {\n            printf(\"%s.%s\\n\", int_binary, frac_binary);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <math.h> int main() { double n; while (scanf(\"%lf\",  Extract integer and  8  for (int i = 7; i >= 0; i--) { int_binary[i] = (int_part % 2) + '0'; int_part /= 2; } int_binary[8] = '\\0'; // Convert fractional part  i <  { frac_binary[i] = '1'; temp_frac -= 1; } else { frac_binary[i] = '0'; } } frac_binary[4] =  2;  error valid = 0; } // Alternative check: reconstruct the number and compare double reconstructed = 0; int int_val = 0; for (int i = 0; i < 8;  '0'); } reconstructed = int_val; double frac_val = 0; for (int i = 0; i < 4; i++) { frac_val = frac_val + (frac_binary[i] - '0') * pow(0.5, i  { printf(\"%s.%s\\n\", int_binary, frac_binary); } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ double n; char a[12]; int m,i; while(1){ scanf(\"%lf\",&n); if(n<0)break; n*=16; m=n; if(m-n){ printf(\"NA\\n\"); continue; } for(i=12;i;i--){ a[i-1]=m%2+'0';  printf(\"\\n\"); } return 0; }"], "original_ll": -1.075714111328125, "sampled_ll": -0.5452044010162354, "all_perturbed_sampled_ll": [-1.761557698249817], "all_perturbed_original_ll": [-2.0523672103881836], "perturbed_sampled_ll": -1.761557698249817, "perturbed_original_ll": -2.0523672103881836, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/**\n * Problem E: Binary Digit A Doctor Loved\n */\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tif (line.charAt(0) == '-') {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint ni;\n\t\t\tdouble nd;\n\t\t\tni = Integer.parseInt(line.substring(0, line.indexOf('.')));\n\t\t\tif (line.indexOf('.') != -1) {\n\t\t\t\tnd = Double.parseDouble(\"0\"\n\t\t\t\t\t\t+ (line.substring(line.indexOf('.')))) * 16;\n\t\t\t} else {\n\t\t\t\tnd = 0.0;\n\t\t\t}\n\t\t\tif (ni > 255 || nd % 1.0 > 0.0) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else {\n\t\t\t\tchar[] si, sd;\n\t\t\t\tsi = new char[8];\n\t\t\t\tsd = new char[4];\n\n\t\t\t\tfor (int i = 7; i >= 0; i--) {\n\t\t\t\t\tif ((ni & (int) (Math.pow(2, i))) != 0) {\n\t\t\t\t\t\tsi[7 - i] = '1';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsi[7 - i] = '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 3; i >= 0; i--) {\n\t\t\t\t\tif (((int) nd & (int) (Math.pow(2, i))) != 0) {\n\t\t\t\t\t\tsd[3 - i] = '1';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsd[3 - i] = '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(new String(si) + \".\" + new String(sd));\n\t\t\t}\n\t\t}\n\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double n = sc.nextDouble();\n            if (n < 0) break;\n            \n            // Split into integer and fractional parts\n            int intPart = (int) n;\n            double fracPart = n - intPart;\n            \n            // Check if integer part fits in 8 bits\n            if (intPart > 255) {\n                System.out.println(\"NA\");\n                continue;\n            }\n            \n            // Convert integer part to binary (8 digits)\n            String intBinary = String.format(\"%8s\", Integer.toBinaryString(intPart)).replace(' ', '0');\n            \n            // Convert fractional part to binary (4 digits)\n            StringBuilder fracBinary = new StringBuilder();\n            boolean valid = true;\n            double temp = fracPart;\n            \n            for (int i = 0; i < 4; i++) {\n                temp *= 2;\n                if (temp >= 1) {\n                    fracBinary.append('1');\n                    temp -= 1;\n                } else {\n                    fracBinary.append('0');\n                }\n            }\n            \n            // Check if there's remaining fractional part\n            if (temp > 1e-9) {\n                valid = false;\n            }\n            \n            if (valid) {\n                System.out.println(intBinary + \".\" + fracBinary.toString());\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main  new Scanner(System.in); while (sc.hasNext()) { double n  integer and fractional parts int intPart = (int) n; double fracPart = n - intPart; // Check if integer part fits in 8 bits if (intPart > 255) { System.out.println(\"NA\");  new StringBuilder(); boolean valid = true; double temp = fracPart; for (int i = 0; i < 4;  fracBinary.append('1'); temp -=  valid = false; } if (valid) { System.out.println(intBinary + \".\" + fracBinary.toString()); } else { System.out.println(\"NA\"); } } sc.close(); } }"], "perturbed_original": ["/** *  import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String  int ni; double nd; ni = Integer.parseInt(line.substring(0, line.indexOf('.'))); if (line.indexOf('.') != -1) { nd = Double.parseDouble(\"0\" + (line.substring(line.indexOf('.')))) * 16; } else { nd = 0.0; } if (ni > 255 || nd % 1.0 > 0.0) { System.out.println(\"NA\"); } else { char[] si, sd; si = new char[8]; sd =  0) { si[7 - i] = '1'; } else { si[7 - i] = '0'; } } for  \".\" + new String(sd)); } } } }"], "original_ll": -0.7916605472564697, "sampled_ll": -0.5752732157707214, "all_perturbed_sampled_ll": [-1.9808486700057983], "all_perturbed_original_ll": [-1.6680715084075928], "perturbed_sampled_ll": -1.9808486700057983, "perturbed_original_ll": -1.6680715084075928, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# Aizu Problem 0220: Binary Digit A Doctor Loved\n\nimport sys, math, os, struct\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\n\nwhile True:\n    n = float(input())\n    if n < 0:\n        break\n    pre = int(n)\n    post = n - int(n)\n    res = bin(pre)[2:].zfill(8) + '.'\n    for k in range(4):\n        post *= 2\n        res += str(int(post))\n        post -= int(post)\n    if pre > 255 or post > 0:\n        print(\"NA\")\n    else:\n        print(res)\n    #m = int(n * 16)\n    #if n == m / 16. and m < 4096:\n    #    res = \"\"\n    #    for k in range(12):\n    #        res += str(m % 2)\n    #        m //= 2\n    #        if k == 7:\n    #            res += '.'\n    #    print(res)\n    #else:\n    #    print(\"NA\")", "sampled": "import sys\n\ndef decimal_to_binary(n):\n    if n < 0:\n        return None\n    \n    # Split into integer and fractional parts\n    integer_part = int(n)\n    fractional_part = n - integer_part\n    \n    # Check if integer part fits in 8 bits\n    if integer_part >= 256:  # 2^8\n        return \"NA\"\n    \n    # Convert integer part to binary\n    int_binary = bin(integer_part)[2:].zfill(8)\n    \n    # Convert fractional part to binary (up to 4 digits)\n    frac_binary = \"\"\n    for _ in range(4):\n        fractional_part *= 2\n        bit = int(fractional_part)\n        frac_binary += str(bit)\n        fractional_part -= bit\n    \n    # Check if there's remaining fractional part (can't be represented exactly)\n    if fractional_part > 1e-9:  # small epsilon for floating point errors\n        return \"NA\"\n    \n    return int_binary + \".\" + frac_binary\n\nfor line in sys.stdin:\n    n = float(line.strip())\n    if n < 0:\n        break\n    result = decimal_to_binary(n)\n    print(result)\n", "perturbed_sampled": ["import  # 2^8 return \"NA\" # Convert integer part to binary int_binary = bin(integer_part)[2:].zfill(8) # Convert fractional part to binary (up to 4  bit # Check if there's remaining fractional part (can't be represented exactly) if fractional_part > 1e-9: # small epsilon for floating point errors return \"NA\" return int_binary + \".\" + frac_binary for line in sys.stdin: n = float(line.strip()) if n < 0: break result = decimal_to_binary(n) print(result)"], "perturbed_original": ["# Aizu Problem 0220: Binary Digit A Doctor Loved import  if PYDEV==\"True\": sys.stdin = open(\"sample-input.txt\", \"rt\") while True: n = float(input()) if n < 0: break   res  * 16) #if n == m  # for k in range(12): # res += str(m % 2) # m //= 2 # if k == 7: # res += '.' # print(res) #else: # print(\"NA\")"], "original_ll": -1.4388587474822998, "sampled_ll": -0.9024179577827454, "all_perturbed_sampled_ll": [-2.521531820297241], "all_perturbed_original_ll": [-3.018425941467285], "perturbed_sampled_ll": -2.521531820297241, "perturbed_original_ll": -3.018425941467285, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\nint main(){\n  int n,m,t;\n  int i,c;\n  char s[12];\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0)break;\n    scanf(\"\\n\");\n    t=1;\n    c=n;\n    int p[1001]={0};\n    p[n+1]=-1;\n    for(i=1;i<=m;i++){\n      if(t==c+1)t=1;\n      for(;p[t]==-1;t++);\n      if(t==c+1)t=1;\n      for(;p[t]==-1;t++);\n      fgets(s,10,stdin);\n      if(n!=1){\n\tif(i%3==0){\n\t  if(i%5==0){\n\t    if(strcmp(s,\"FizzBuzz\\n\\0\")!=0)p[t]=-1;\n\t  }\n\t  else{\n\t    if(strcmp(s,\"Fizz\\n\\0\")!=0)p[t]=-1;\n\t  }\n\t}\n\telse{\n\t  if(i%5==0){\n\t    if(strcmp(s,\"Buzz\\n\\0\")!=0)p[t]=-1;\n\t  }\n\t  else{\n\t    if(!(s[0]==i+'0'&&s[1]==10))p[t]=-1;\n\t  }\n\t}\n\tif(p[t]==-1)n--;\n      }\n      t++;\n    }\n    n=0;\n    for(i=1;i<=c;i++){\n      if(p[i]==0){\n\tif(n==1)printf(\" \");\n\tprintf(\"%d\",i);\n\tn=1;\n      }\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int m, n;\n    \n    while(1) {\n        scanf(\"%d %d\", &m, &n);\n        if(m == 0 && n == 0) break;\n        \n        int active[1001];\n        for(int i = 1; i <= m; i++) {\n            active[i] = 1;\n        }\n        \n        int current_player = 1;\n        int current_number = 1;\n        int remaining_players = m;\n        \n        for(int i = 0; i < n; i++) {\n            char statement[10];\n            scanf(\"%s\", statement);\n            \n            if(remaining_players == 1) {\n                continue;\n            }\n            \n            // Find next active player\n            while(active[current_player] == 0) {\n                current_player++;\n                if(current_player > m) current_player = 1;\n            }\n            \n            // Check if statement is correct\n            int correct = 0;\n            \n            if(current_number % 15 == 0) {\n                if(strcmp(statement, \"FizzBuzz\") == 0) correct = 1;\n            }\n            else if(current_number % 3 == 0) {\n                if(strcmp(statement, \"Fizz\") == 0) correct = 1;\n            }\n            else if(current_number % 5 == 0) {\n                if(strcmp(statement, \"Buzz\") == 0) correct = 1;\n            }\n            else {\n                int num;\n                if(sscanf(statement, \"%d\", &num) == 1 && num == current_number) {\n                    correct = 1;\n                }\n            }\n            \n            if(!correct) {\n                active[current_player] = 0;\n                remaining_players--;\n            }\n            \n            current_number++;\n            \n            // Move to next player\n            current_player++;\n            if(current_player > m) current_player = 1;\n        }\n        \n        int first = 1;\n        for(int i = 1; i <= m; i++) {\n            if(active[i]) {\n                if(!first) printf(\" \");\n                printf(\"%d\", i);\n                first = 0;\n            }\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int m, n; while(1) { scanf(\"%d %d\", &m, &n); if(m == 0 && n == 0) break; int active[1001]; for(int i = 1; i  = 1; int current_number = 1; int remaining_players = m; for(int i = 0; i < n; i++) { char statement[10]; scanf(\"%s\",  active player while(active[current_player] == 0)  Check if statement  \"Fizz\")  == 0) { if(strcmp(statement, \"Buzz\") == 0) correct = 1; } else { int num; if(sscanf(statement, \"%d\", &num) == 1 && num == current_number) { correct = 1; } } if(!correct) { active[current_player] = 0; remaining_players--; }  i = 1; i <= m;  = 0; } } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> int main(){ int n,m,t; int i,c; char  p[n+1]=-1; for(i=1;i<=m;i++){ if(t==c+1)t=1;  if(strcmp(s,\"Fizz\\n\\0\")!=0)p[t]=-1; } } else{ if(i%5==0){ if(strcmp(s,\"Buzz\\n\\0\")!=0)p[t]=-1; } else{ if(!(s[0]==i+'0'&&s[1]==10))p[t]=-1; } } if(p[t]==-1)n--; } t++;  printf(\"\\n\"); } return 0; }"], "original_ll": -1.0291650295257568, "sampled_ll": -0.5509333610534668, "all_perturbed_sampled_ll": [-1.7569918632507324], "all_perturbed_original_ll": [-2.0916006565093994], "perturbed_sampled_ll": -1.7569918632507324, "perturbed_original_ll": -2.0916006565093994, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m,n;\n\t\tFizzBuzz fb;\n\t\tfor(;;) {\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(m==0 && n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfb = new FizzBuzz(m);\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tif(!fb.sayNextStatement(sc.next())) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfb.showPlayer();\n\t\t}\n\t}\n}\n\nclass FizzBuzz {\n\tprivate int current,currentPlayer;\n\tprivate int m;\n\tprivate int[] player;\n\t\n\tpublic FizzBuzz(int m) {\n\t\tcurrent = 0;\n\t\tcurrentPlayer = 0;\n\t\tthis.m = m;\n\t\tplayer = new int[m];\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tplayer[i] = i+1;\n\t\t}\n\t}\n\t\n\tpublic void showPlayer() {\n\t\tfor(int pl:player){\n\t\t\tif(pl != -1){\n\t\t\t\tSystem.out.println(pl);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic boolean sayNextStatement(String statement) {\n\t\ttry {\n\t\t\tint num = Integer.valueOf(statement);\n\t\t\tif(!checkFizzBuzz(num)) {\n\t\t\t\tplayer[currentPlayer] = -1;\n\t\t\t}\n\t\t} catch(NumberFormatException e) {\n\t\t\tif(!checkFizzBuzz(statement)) {\n\t\t\t\tplayer[currentPlayer] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!setCurrentPlayer()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate boolean setCurrentPlayer() {\n\t\tint prev = currentPlayer;\n\t\t\n\t\tif(currentPlayer+1 == m) {\n\t\t\tcurrentPlayer = 0;\n\t\t} else {\n\t\t\tcurrentPlayer ++;\n\t\t}\n\t\t\n\t\twhile(player[currentPlayer] == -1) {\n\t\t\tif(currentPlayer+1 == m) {\n\t\t\t\tcurrentPlayer = 0;\n\t\t\t} else {\n\t\t\t\tcurrentPlayer ++;\n\t\t\t}\n\t\t\t\n\t\t\tif(prev == currentPlayer) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate boolean checkFizzBuzz(int statement) {\n\t\tcurrent ++;\n\t\t\n\t\tif((current % 3 == 0) || (current % 5 == 0)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif(current == statement) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean checkFizzBuzz(String statement) {\n\t\tcurrent ++;\n\t\tif((current % 3 == 0) && (current % 5 == 0)) {\n\t\t\tif(statement.equals(\"FizzBuzz\")) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(current % 3 == 0) {\n\t\t\tif(statement.equals(\"Fizz\")) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(current % 5 == 0) {\n\t\t\tif(statement.equals(\"Buzz\")) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            \n            if (m == 0 && n == 0) break;\n            \n            boolean[] active = new boolean[m + 1];\n            for (int i = 1; i <= m; i++) {\n                active[i] = true;\n            }\n            \n            int currentNumber = 1;\n            int currentPlayer = 1;\n            int activePlayers = m;\n            \n            for (int i = 0; i < n; i++) {\n                String statement = sc.next();\n                \n                if (activePlayers == 1) {\n                    continue;\n                }\n                \n                while (!active[currentPlayer]) {\n                    currentPlayer++;\n                    if (currentPlayer > m) currentPlayer = 1;\n                }\n                \n                String correct = getCorrectStatement(currentNumber);\n                \n                if (!statement.equals(correct)) {\n                    active[currentPlayer] = false;\n                    activePlayers--;\n                } else {\n                    currentNumber++;\n                }\n                \n                if (activePlayers > 1) {\n                    currentPlayer++;\n                    if (currentPlayer > m) currentPlayer = 1;\n                }\n            }\n            \n            List<Integer> result = new ArrayList<>();\n            for (int i = 1; i <= m; i++) {\n                if (active[i]) {\n                    result.add(i);\n                }\n            }\n            \n            for (int i = 0; i < result.size(); i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(result.get(i));\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n    \n    static String getCorrectStatement(int num) {\n        if (num % 15 == 0) {\n            return \"FizzBuzz\";\n        } else if (num % 3 == 0) {\n            return \"Fizz\";\n        } else if (num % 5 == 0) {\n            return \"Buzz\";\n        } else {\n            return String.valueOf(num);\n        }\n    }\n}\n", "perturbed_sampled": [" boolean[] active = new boolean[m + 1]; for  = true; } int currentNumber = 1; int currentPlayer = 1; int activePlayers = m; for (int i = 0; i < n; i++) { String  while (!active[currentPlayer]) { currentPlayer++; if (currentPlayer > m)  { active[currentPlayer] = false; activePlayers--; } else { currentNumber++; } if (activePlayers > 1) { currentPlayer++; if (currentPlayer > m) currentPlayer = 1; } } List<Integer> result = new ArrayList<>(); for (int i = 1; i <= m; i++) {  0; i < result.size(); i++) { if (i > 0) System.out.print(\" \");  { if (num  (num  (num % 5 == 0) { return \"Buzz\"; } else { return String.valueOf(num); } } }"], "perturbed_original": ["import java.util.*; class Main {  new Scanner(System.in); int m,n; FizzBuzz  && n==0)  i++) { if(!fb.sayNextStatement(sc.next())) { break; } } fb.showPlayer(); } } } class FizzBuzz { private int current,currentPlayer; private int m; private int[] player; public FizzBuzz(int  m; player = new int[m]; for(int i=0; i<m; i++) { player[i] =  != -1){ System.out.println(pl); } } } public boolean sayNextStatement(String statement) { try { int num = Integer.valueOf(statement); if(!checkFizzBuzz(num))  { player[currentPlayer] = -1;  == m) { currentPlayer = 0; } else { currentPlayer ++; } while(player[currentPlayer] == -1) { if(currentPlayer+1 == m) {   3 == 0) || (current % 5 == 0)) { return false;  else { return false; } } }  == 0) && (current % 5 == 0)) { if(statement.equals(\"FizzBuzz\")) { return true; } else { return false;  { return true; } else { return false; } }  true; } else { return false; } } else { return false; } } }"], "original_ll": -0.5714502930641174, "sampled_ll": -0.4894731640815735, "all_perturbed_sampled_ll": [-1.626338005065918], "all_perturbed_original_ll": [-1.8572396039962769], "perturbed_sampled_ll": -1.626338005065918, "perturbed_original_ll": -1.8572396039962769, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# Aizu Problem 0221: Fizz Buzz\n\nimport sys, math, os, struct\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\ndef valid(k, a):\n    if k % 3 == 0 and k % 5 == 0:\n        return a == \"FizzBuzz\"\n    elif k % 3 == 0:\n        return a == \"Fizz\"\n    elif k % 5 == 0:\n        return a == \"Buzz\"\n    else:\n        return int(a) == k\n\n    \ndef fizz_buzz(m, n, A):\n    players = list(range(1, m + 1))\n    p = 0\n    k = 0\n    while len(A) > 0:\n        k += 1\n        a = A.pop(0)\n        if valid(k, a):\n            p = (p + 1) % m\n        else:\n            if len(players) == 0:\n                print()\n                return\n            players.pop(p)\n            if len(players) == 1:\n                break\n            m -= 1\n            if p == m:\n                p = 0\n    print(' '.join([str(p) for p in players]))\n    \n    \nwhile True:\n    m, n = [int(_) for _ in input().split()]\n    if m == 0:\n        break\n    A = [input().strip() for _ in range(n)]\n    fizz_buzz(m, n, A)", "sampled": "def get_expected(num):\n    if num % 15 == 0:\n        return \"FizzBuzz\"\n    elif num % 3 == 0:\n        return \"Fizz\"\n    elif num % 5 == 0:\n        return \"Buzz\"\n    else:\n        return str(num)\n\nwhile True:\n    line = input().split()\n    m, n = int(line[0]), int(line[1])\n    \n    if m == 0 and n == 0:\n        break\n    \n    players = set(range(1, m + 1))\n    current_num = 1\n    current_player = 1\n    \n    for _ in range(n):\n        statement = input().strip()\n        \n        if len(players) == 1:\n            continue\n        \n        while current_player not in players:\n            current_player += 1\n            if current_player > m:\n                current_player = 1\n        \n        expected = get_expected(current_num)\n        \n        if statement != expected:\n            players.discard(current_player)\n        \n        current_num += 1\n        current_player += 1\n        if current_player > m:\n            current_player = 1\n    \n    result = sorted(list(players))\n    print(' '.join(map(str, result)))\n", "perturbed_sampled": ["def get_expected(num): if num % 15 == 0: return \"FizzBuzz\" elif num % 3 == 0: return \"Fizz\" elif num % 5 == 0: return \"Buzz\" else: return str(num) while True: line  0 and n == 0: break players = set(range(1, m + 1)) current_num = 1 current_player = 1 for   current_player > m: current_player  current_num += 1 current_player  = sorted(list(players)) print(' '.join(map(str, result)))"], "perturbed_original": ["# Aizu Problem 0221: Fizz Buzz import sys, math, os, struct # read  def valid(k, a): if k % 3 == 0 and k % 5 == 0: return a == \"FizzBuzz\" elif k % 3  m + 1)) p = 0 k = 0 while len(A)  a): p = (p + 1) % m else: if len(players) == 0: print() return players.pop(p) if len(players) == 1: break m -= 1 if p == m: p  m, n = [int(_) for _ in input().split()] if m  fizz_buzz(m, n, A)"], "original_ll": -1.054895043373108, "sampled_ll": -0.7580963969230652, "all_perturbed_sampled_ll": [-2.052824020385742], "all_perturbed_original_ll": [-2.3846874237060547], "perturbed_sampled_ll": -2.052824020385742, "perturbed_original_ll": -2.3846874237060547, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "c[1<<23],*p,n=1e7;main(a,b){for(;a+=2,a<n;)for(b=a/2;(b+=a)<n;)c[b]=1;for(;scanf(\"%d\",&n)*n;printf(\"%d\\n\",n))for(;p=c+n/2-4,~n&1|p[4]|p[3]|p[1]|*p;n--);}", "sampled": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX 10000010\n\nbool is_prime[MAX];\nint quadruplets[MAX];\n\nvoid sieve() {\n    memset(is_prime, true, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n}\n\nvoid find_quadruplets() {\n    memset(quadruplets, 0, sizeof(quadruplets));\n    \n    for (int a = 2; a + 8 < MAX; a++) {\n        if (is_prime[a] && is_prime[a+2] && is_prime[a+6] && is_prime[a+8]) {\n            int size = a + 8;\n            quadruplets[size] = size;\n        }\n    }\n    \n    int max_so_far = 0;\n    for (int i = 0; i < MAX; i++) {\n        if (quadruplets[i] > 0) {\n            max_so_far = quadruplets[i];\n        }\n        quadruplets[i] = max_so_far;\n    }\n}\n\nint main() {\n    sieve();\n    find_quadruplets();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        printf(\"%d\\n\", quadruplets[n]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdbool.h> #include <string.h> #define MAX 10000010 bool is_prime[MAX]; int quadruplets[MAX]; void sieve() { memset(is_prime, true,  2;  for (int j = i * i; j < MAX; j += i) { is_prime[j] = false; } } } } void find_quadruplets() { memset(quadruplets, 0, sizeof(quadruplets)); for (int a = 2; a + 8 < MAX; a++) { if (is_prime[a]  max_so_far = 0; for (int  > 0) { max_so_far = quadruplets[i];  n != 0) { printf(\"%d\\n\", quadruplets[n]); } return 0; }"], "perturbed_original": ["c[1<<23],*p,n=1e7;main(a,b){for(;a+=2,a<n;)for(b=a/2;(b+=a)<n;)c[b]=1;for(;scanf(\"%d\",&n)*n;printf(\"%d\\n\",n))for(;p=c+n/2-4,~n&1|p[4]|p[3]|p[1]|*p;n--);}"], "original_ll": -2.653404951095581, "sampled_ll": -0.45914971828460693, "all_perturbed_sampled_ll": [-1.5519320964813232], "all_perturbed_original_ll": [-2.653404951095581], "perturbed_sampled_ll": -1.5519320964813232, "perturbed_original_ll": -2.653404951095581, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tfinal int MAX = 10000000;\n\n\tboolean[] prime = new boolean[MAX + 10];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tArrays.fill(prime, true);\n\n\t\t//\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\n\t\tprime[0] = prime[1] = false;\n\t\tfor (int i = 2; i * i < MAX + 10; i++) {\n\t\t\tif (prime[i]) {\n\t\t\t\tfor (int j = i + i; j < MAX + 10; j += i) {\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint max = 0;\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = n; i >= 8; i--) {\n\t\t\t\tif (prime[i] && prime[i - 2] && prime[i - 6] && prime[i - 8]) {\n\t\t\t\t\tmax = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int MAX = 10000000;\n        boolean[] isPrime = new boolean[MAX + 10];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i <= MAX + 8; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= MAX + 8; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        List<Integer> quadPrimes = new ArrayList<>();\n        for (int a = 2; a <= MAX; a++) {\n            if (isPrime[a] && isPrime[a + 2] && isPrime[a + 6] && isPrime[a + 8]) {\n                quadPrimes.add(a + 8);\n            }\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int result = 0;\n            for (int size : quadPrimes) {\n                if (size <= n) {\n                    result = size;\n                } else {\n                    break;\n                }\n            }\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  { Scanner sc = new Scanner(System.in); int MAX  true); isPrime[0] = isPrime[1] = false; for (int i = 2; i * i <= MAX + 8; i++) { if (isPrime[i]) { for (int j = i *  isPrime[j] = false; } } } List<Integer> quadPrimes =  + 8);  (n == 0) break; int result = 0; for (int size : quadPrimes) { if (size <= n) { result = size; } else { break; } } System.out.println(result); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { final int MAX -<extra_id_8>1; if<extra_id_9>n ==<extra_id_10>+ n]; run() { Scanner sc = new Scanner(System.in); Arrays.fill(prime, true); //\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9 prime[0] = prime[1] = false; for (int i = 2; i * i < MAX + 10; i++) { if max=MAX;<extra_id_11>i + i<extra_id_12>i<extra_id_13>} } } < MAX + 10;  while (true) { int n = sc.nextInt(); int max =  (prime[i] && prime[i - 2] && prime[i - 6] && prime[i - 8]) {  static void main(String[] args) { new Main().run(); } }"], "original_ll": -0.576786994934082, "sampled_ll": -0.49576953053474426, "all_perturbed_sampled_ll": [-1.9113928079605103], "all_perturbed_original_ll": [-2.16359281539917], "perturbed_sampled_ll": -1.9113928079605103, "perturbed_original_ll": -2.16359281539917, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def get_quad(n, p):\n    for ni in range(n,0,-1):\n        if p[ni] and p[ni - 2] and p[ni - 6] and p[ni - 8]:\n            return ni\n        \ndef sieve():\n    n = 10000001\n    p = [1] * n\n    p[0] = p[1] = 0\n    \n    for i in range(int(n ** 0.5)):\n        if p[i]:\n            for j in range(2 * i, len(p), i):\n                p[j] = 0\n    return p\nimport sys\nf = sys.stdin\n\nprime = sieve()\nwhile True:\n    n = f.readline()\n    if not n.isnumeric():\n        continue\n    n = int(n)\n    if n == 0:\n        break\n    print(get_quad(ni, prime))", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\ndef find_quadruplet_primes(limit):\n    is_prime = sieve_of_eratosthenes(limit)\n    quadruplets = []\n    \n    for a in range(2, limit - 7):\n        if is_prime[a] and is_prime[a+2] and is_prime[a+6] and is_prime[a+8]:\n            quadruplets.append(a + 8)\n    \n    return quadruplets\n\n# Precompute all quadruplet primes up to 10,000,000\nMAX_LIMIT = 10000000\nquadruplet_sizes = find_quadruplet_primes(MAX_LIMIT)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    # Binary search for the largest quadruplet size <= n\n    result = 0\n    for size in quadruplet_sizes:\n        if size <= n:\n            result = size\n        else:\n            break\n    \n    print(result)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in range(2,  + 1, i): is_prime[j] = False return is_prime def find_quadruplet_primes(limit): is_prime = sieve_of_eratosthenes(limit) quadruplets = [] for a in range(2, limit - 7): if is_prime[a] and is_prime[a+2] and is_prime[a+6]  == 0: break # Binary search for the largest quadruplet size  size <= n: result = size else: break print(result)"], "perturbed_original": ["def get_quad(n, p): for ni in range(n,0,-1):  = 10000001 p = [1] * n p[0] = p[1] = 0 for i in  sys f = sys.stdin prime = sieve() while True: n = f.readline() if not n.isnumeric(): continue n = int(n) if n == 0: break print(get_quad(ni, prime))"], "original_ll": -1.112264633178711, "sampled_ll": -0.6371775269508362, "all_perturbed_sampled_ll": [-1.6368913650512695], "all_perturbed_original_ll": [-2.6298439502716064], "perturbed_sampled_ll": -1.6368913650512695, "perturbed_original_ll": -2.6298439502716064, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\n#include<stdbool.h>\n\n#define MIN(x,y) (((x)<(y))?(x):(y))\n#define INFTY (1<<21)\n\n\nint m, n, k, d, C[7], G[110][110], N, D[110][64];\n\nint getID(char *str);\nint isC(int x);\nint bellman(void);\n\nint main(void){\n  char source[16], target[16];\n  int cost,s,t;\n  int i,j;\n  while(scanf(\"%d%*c%d%*c%d%*c%d%*c\",&m,&n,&k,&d) && m ){\n    N = 2 + n + m;\n    for(i=1;i<m+1;i++) scanf(\"%d%*c\",&C[i]);\n    for(i=0;i<N;i++) for(j=0;j<N;j++) G[i][j] = INFTY;\n    for(i=0;i<d;i++){\n      scanf(\"%s%*c%s%*c%d%*c\",source,target,&cost);\n      s = getID(source);\n      t = getID(target);\n      G[t][s] = G[s][t] = MIN(G[s][t], cost * k);\n    }\n    printf(\"%d\\n\",bellman());\n  }\n  return 0;\n}\n\nint getID(char *str){\n  char num[16];\n  if ( str[0] == 'H' ) return 0;\n  if ( str[0] == 'D' ) return N - 1;\n  strcpy(num,str+1);\n  if ( str[0] == 'C' ) return atoi(num);\n  return atoi(num) + m;\n}\n\nint isC(int x){\n  return 1 <= x && x <= m;\n}\nint bellman(void){\n  bool change=0;\n  int minv;\n  int i,o,u,v,b,j;\n\n  for(i=0;i<N;i++) for(j=0;j<(1<<m);j++) D[i][j] = INFTY;\n  D[0][0] = 0;\n  for(o=0;o<N*(1<<m);o++){\n    for(u=0;u<N;u++){\n      for(v=0;v<N;v++){\n\tif ( u == v || G[u][v] == INFTY ) continue;\n\tfor(b=0;b<(1<<m);b++){\n\t  if (isC(v) && (b&(1<<(v-1))) != 0 ) continue;\n\t  if ( isC(v) ) {\n\t    if ( D[u][b] + G[u][v] - C[v] < D[v][b|(1<<(v-1))] ) {\n\t      D[v][b|(1<<(v-1))] = D[u][b] + G[u][v] - C[v];\n\t      change = true;\n\t    }\n\t  } else {\n\t    if ( D[u][b] + G[u][v] < D[v][b] ){\n\t      D[v][b] = D[u][b] + G[u][v];\n\t      change = true;\n\t    }\n\t  }\n\t}\n      }\n    }\n    if ( !change ) break;\n  }\n  minv = INFTY;\n  for(i=0;i<(1<<m);i++) minv = MIN(minv, D[N-1][i]);\n  return minv;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define INF 1000000000\n#define MAX_NODES 110\n\nint m, n, k, d;\nint calories[10];\nint dist[MAX_NODES][MAX_NODES];\nint H_idx, D_idx;\nint C_idx[10];\nint L_idx[110];\n\nint parse_node(char *s) {\n    if (s[0] == 'H') return H_idx;\n    if (s[0] == 'D') return D_idx;\n    if (s[0] == 'C') {\n        int num;\n        sscanf(s + 1, \"%d\", &num);\n        return C_idx[num - 1];\n    }\n    if (s[0] == 'L') {\n        int num;\n        sscanf(s + 1, \"%d\", &num);\n        return L_idx[num - 1];\n    }\n    return -1;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid floyd_warshall(int nodes) {\n    for (int k = 0; k < nodes; k++) {\n        for (int i = 0; i < nodes; i++) {\n            for (int j = 0; j < nodes; j++) {\n                if (dist[i][k] != INF && dist[k][j] != INF) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d %d\", &m, &n, &k, &d);\n        if (m == 0 && n == 0 && k == 0 && d == 0) break;\n\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d\", &calories[i]);\n        }\n\n        int nodes = 2 + m + n;\n        H_idx = 0;\n        D_idx = 1;\n        for (int i = 0; i < m; i++) C_idx[i] = 2 + i;\n        for (int i = 0; i < n; i++) L_idx[i] = 2 + m + i;\n\n        for (int i = 0; i < nodes; i++) {\n            for (int j = 0; j < nodes; j++) {\n                if (i == j) dist[i][j] = 0;\n                else dist[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < d; i++) {\n            char s[10], t[10];\n            int e;\n            scanf(\"%s %s %d\", s, t, &e);\n            int u = parse_node(s);\n            int v = parse_node(t);\n            dist[u][v] = min(dist[u][v], e);\n            dist[v][u] = min(dist[v][u], e);\n        }\n\n        floyd_warshall(nodes);\n\n        int min_cost = INF;\n        for (int mask = 0; mask < (1 << m); mask++) {\n            int perm[10];\n            int cnt = 0;\n            for (int i = 0; i < m; i++) {\n                if (mask & (1 << i)) {\n                    perm[cnt++] = i;\n                }\n            }\n\n            if (cnt == 0) {\n                int total_dist = dist[H_idx][D_idx];\n                int cost = total_dist * k;\n                min_cost = min(min_cost, cost);\n            } else {\n                int fact = 1;\n                for (int i = 1; i <= cnt; i++) fact *= i;\n                \n                for (int p = 0; p < fact; p++) {\n                    int temp_perm[10];\n                    for (int i = 0; i < cnt; i++) temp_perm[i] = perm[i];\n                    \n                    int temp = p;\n                    for (int i = 0; i < cnt; i++) {\n                        int j = i + temp % (cnt - i);\n                        temp /= (cnt - i);\n                        int t = temp_perm[i];\n                        temp_perm[i] = temp_perm[j];\n                        temp_perm[j] = t;\n                    }\n\n                    int total_dist = dist[H_idx][C_idx[temp_perm[0]]];\n                    int total_cal = calories[temp_perm[0]];\n                    for (int i = 1; i < cnt; i++) {\n                        total_dist += dist[C_idx[temp_perm[i - 1]]][C_idx[temp_perm[i]]];\n                        total_cal += calories[temp_perm[i]];\n                    }\n                    total_dist += dist[C_idx[temp_perm[cnt - 1]]][D_idx];\n\n                    int cost = total_dist * k - total_cal;\n                    min_cost = min(min_cost, cost);\n                }\n            }\n        }\n\n        printf(\"%d\\n\", min_cost);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h> #define INF 1000000000 #define MAX_NODES 110 int  D_idx; int C_idx[10]; int L_idx[110];  if (s[0] == 'D') return D_idx; if (s[0] ==  int num; sscanf(s  -1; } int min(int a, int b) { return a < b ?  k = 0; k < nodes; k++) { for (int i = 0; i < nodes;  } } } } int main() { while (1) { scanf(\"%d %d %d %d\", &m, &n, &k, &d); if (m == 0 &&  0)  { scanf(\"%d\", &calories[i]); } int nodes = 2 + m + n; H_idx = 0; D_idx = 1; for (int i = 0; i < m; i++) C_idx[i] = 2 + i; for (int i = 0; i < n; i++) L_idx[i] =  0; j < nodes; j++) { if (i == j) dist[i][j] = 0; else dist[i][j] =  %s %d\", s, t, &e); int u = parse_node(s); int v = parse_node(t); dist[u][v] = min(dist[u][v], e); dist[v][u] = min(dist[v][u], e); } floyd_warshall(nodes); int min_cost = INF; for (int mask = 0; mask < (1 << m); mask++) { int perm[10]; int cnt = 0; for (int i = 0; i < m; i++) { if  } if (cnt ==  * k; min_cost = min(min_cost, cost); }  (int p = 0; p < fact; p++) { int temp_perm[10]; for (int i = 0; i < cnt; i++) temp_perm[i] = perm[i]; int temp = p; for (int i = 0; i < cnt;  - i); temp /= (cnt  = t; } int total_dist = dist[H_idx][C_idx[temp_perm[0]]]; int  cnt;  } total_dist  printf(\"%d\\n\", min_cost); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> #include<stdbool.h> #define MIN(x,y) (((x)<(y))?(x):(y)) #define INFTY (1<<21) int m, n, k, d, C[7], G[110][110], N, D[110][64]; int getID(char *str); int isC(int x); int bellman(void); int main(void){ char source[16], target[16]; int cost,s,t; int i,j; while(scanf(\"%d%*c%d%*c%d%*c%d%*c\",&m,&n,&k,&d) && m  for(i=0;i<N;i++) for(j=0;j<N;j++) G[i][j] = INFTY; for(i=0;i<d;i++){ scanf(\"%s%*c%s%*c%d%*c\",source,target,&cost); s  cost * k); } printf(\"%d\\n\",bellman()); } return 0;  'H' ) return 0; if ( str[0] == 'D' ) return N  return 1 <= x && x <=  for(i=0;i<N;i++) for(j=0;j<(1<<m);j++) D[i][j] = INFTY; D[0][0] = 0; for(o=0;o<N*(1<<m);o++){ for(u=0;u<N;u++){ for(v=0;v<N;v++){ if ( u == v  (b&(1<<(v-1))) != 0 ) continue; if ( isC(v) ) { if ( D[u][b] + G[u][v] - C[v] < D[v][b|(1<<(v-1))] ) { D[v][b|(1<<(v-1))] =  ){ D[v][b] =  INFTY; for(i=0;i<(1<<m);i++) minv = MIN(minv, D[N-1][i]); return minv; }"], "original_ll": -0.8313256502151489, "sampled_ll": -0.39361000061035156, "all_perturbed_sampled_ll": [-1.4959813356399536], "all_perturbed_original_ll": [-1.452850103378296], "perturbed_sampled_ll": -1.4959813356399536, "perturbed_original_ll": -1.452850103378296, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tstatic int m;\n\tstatic int n;\n\tstatic int k;\n\tstatic int d;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tk = sc.nextInt();\n\t\t\td = sc.nextInt();\n\t\t\tif(m == 0 && n == 0 && k == 0 && d == 0) break;\n\t\t\tint[] c = new int[m];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] node = new Node[m + n + 2];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tnode[i] = new Node();\n\t\t\t\tnode[i].type = 2;\n\t\t\t}\n\t\t\tfor(int i = m; i < m + n; i++) {\n\t\t\t\tnode[i] = new Node();\n\t\t\t\tnode[i].type = 3;\n\t\t\t}\n\t\t\tnode[m + n    ] = new Node();\n\t\t\tnode[m + n    ].type = 0;\n\t\t\tnode[m + n + 1] = new Node();\n\t\t\tnode[m + n + 1].type = 1;\n\t\t\t\n\t\t\tfor(int i = 0; i < d; i++) {\n\t\t\t\tString a = sc.next();\n\t\t\t\tString b = sc.next();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tint idA = -100;\n\t\t\t\tint idB = -100;\n\t\t\t\tif(a.length() == 1) {\n\t\t\t\t\tif(a.equals(\"H\")) idA = m + n;\n\t\t\t\t\telse \t\t\t  idA = m + n + 1;\n\t\t\t\t}\n\t\t\t\tif(b.length() == 1) {\n\t\t\t\t\tif(b.equals(\"H\")) idB = m + n;\n\t\t\t\t\telse\t\t\t  idB = m + n + 1;\n\t\t\t\t}\n\t\t\t\tif(idA == -100) {\n\t\t\t\t\tif(a.charAt(0) == 'C') {\n\t\t\t\t\t\tidA = Integer.parseInt(a.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tidA = m + Integer.parseInt(a.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(idB == -100) {\n\t\t\t\t\tif(b.charAt(0) == 'C') {\n\t\t\t\t\t\tidB = Integer.parseInt(b.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tidB = m + Integer.parseInt(b.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode[idA].edge_to.add(idB);\n\t\t\t\tnode[idA].edge_cost.add(cost);\n\t\t\t\tnode[idB].edge_to.add(idA);\n\t\t\t\tnode[idB].edge_cost.add(cost);\n\t\t\t}\n\t\t\tint[][] dp = new int[n + m + 2][1 << m];\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tfor(int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\tdp[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Data> queue = new PriorityQueue<Data>();\n\t\t\tqueue.add(new Data(m + n,new boolean[m],0));\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tData tmp = queue.poll();\n\t\t\t\tint V = 0;\n\t\t\t\tfor(int i = 0; i < tmp.v.length; i++) {\n\t\t\t\t\tif(tmp.v[i]) {\n\t\t\t\t\t\tV |= 1 << i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dp[tmp.now][V] <= tmp.cost) continue;\n\t\t\t\tdp[tmp.now][V] = tmp.cost;\n\t\t\t\tNode now = node[tmp.now];\n\t\t\t\tfor(int i = 0; i < now.edge_to.size(); i++) {\n\t\t\t\t\tif(node[now.edge_to.get(i)].type == 2 && tmp.v[now.edge_to.get(i)]) continue;\n\t\t\t\t\tif(node[now.edge_to.get(i)].type == 2) {\n\t\t\t\t\t\tboolean[] copy = Arrays.copyOf(tmp.v, tmp.v.length);\n\t\t\t\t\t\tcopy[now.edge_to.get(i)] = true; \n\t\t\t\t\t\tqueue.add(new Data(now.edge_to.get(i),copy, tmp.cost - c[now.edge_to.get(i)] + now.edge_cost.get(i) * k));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tqueue.add(new Data(now.edge_to.get(i),tmp.v, tmp.cost + now.edge_cost.get(i) * k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint MIN = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < dp[m + n + 1].length; i++) {\n\t\t\t\tMIN = Math.min(MIN, dp[m + n + 1][i]);\n\t\t\t}\n\t\t\tSystem.out.println(MIN);\n\t\t}\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint cost;\n\t\tboolean[] v;\n\t\tint now;\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t\tData(int c, boolean[] b, int a) {\n\t\t\tcost = a;\n\t\t\tv    = b;\n\t\t\tnow  = c;\n\t\t}\n\t}\n\tstatic class Node {\n\t\tint type; // 0 H, 1 D, 2 C, 3 L\n\t\tboolean c;\n\t\tArrayList<Integer> edge_to = new ArrayList<Integer>();\n\t\tArrayList<Integer> edge_cost = new ArrayList<Integer>();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Edge {\n        String to;\n        int dist;\n        Edge(String to, int dist) {\n            this.to = to;\n            this.dist = dist;\n        }\n    }\n    \n    static Map<String, List<Edge>> graph;\n    static int[] cakeCals;\n    static int m, n, k, d;\n    static Map<String, Integer> nodeToIdx;\n    static String[] idxToNode;\n    static int numNodes;\n    static int[][] dist;\n    static final int INF = 1000000000;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            m = Integer.parseInt(parts[0]);\n            n = Integer.parseInt(parts[1]);\n            k = Integer.parseInt(parts[2]);\n            d = Integer.parseInt(parts[3]);\n            \n            if (m == 0 && n == 0 && k == 0 && d == 0) break;\n            \n            cakeCals = new int[m + 1];\n            parts = br.readLine().trim().split(\"\\\\s+\");\n            for (int i = 1; i <= m; i++) {\n                cakeCals[i] = Integer.parseInt(parts[i - 1]);\n            }\n            \n            graph = new HashMap<>();\n            Set<String> nodes = new HashSet<>();\n            \n            for (int i = 0; i < d; i++) {\n                parts = br.readLine().trim().split(\"\\\\s+\");\n                String s = parts[0];\n                String t = parts[1];\n                int e = Integer.parseInt(parts[2]);\n                \n                nodes.add(s);\n                nodes.add(t);\n                \n                graph.putIfAbsent(s, new ArrayList<>());\n                graph.putIfAbsent(t, new ArrayList<>());\n                graph.get(s).add(new Edge(t, e));\n                graph.get(t).add(new Edge(s, e));\n            }\n            \n            nodeToIdx = new HashMap<>();\n            idxToNode = new String[nodes.size()];\n            int idx = 0;\n            for (String node : nodes) {\n                nodeToIdx.put(node, idx);\n                idxToNode[idx] = node;\n                idx++;\n            }\n            numNodes = nodes.size();\n            \n            // Floyd-Warshall\n            dist = new int[numNodes][numNodes];\n            for (int i = 0; i < numNodes; i++) {\n                Arrays.fill(dist[i], INF);\n                dist[i][i] = 0;\n            }\n            \n            for (String from : graph.keySet()) {\n                int fromIdx = nodeToIdx.get(from);\n                for (Edge e : graph.get(from)) {\n                    int toIdx = nodeToIdx.get(e.to);\n                    dist[fromIdx][toIdx] = Math.min(dist[fromIdx][toIdx], e.dist);\n                }\n            }\n            \n            for (int kk = 0; kk < numNodes; kk++) {\n                for (int i = 0; i < numNodes; i++) {\n                    for (int j = 0; j < numNodes; j++) {\n                        if (dist[i][kk] != INF && dist[kk][j] != INF) {\n                            dist[i][j] = Math.min(dist[i][j], dist[i][kk] + dist[kk][j]);\n                        }\n                    }\n                }\n            }\n            \n            int minCal = INF;\n            \n            // Try all permutations of visiting cake shops\n            for (int mask = 0; mask < (1 << m); mask++) {\n                List<Integer> cakeShops = new ArrayList<>();\n                for (int i = 0; i < m; i++) {\n                    if ((mask & (1 << i)) != 0) {\n                        cakeShops.add(i + 1);\n                    }\n                }\n                \n                if (cakeShops.isEmpty()) {\n                    int hIdx = nodeToIdx.get(\"H\");\n                    int dIdx = nodeToIdx.get(\"D\");\n                    int totalDist = dist[hIdx][dIdx];\n                    int cal = totalDist * k;\n                    minCal = Math.min(minCal, cal);\n                } else {\n                    int[] perm = new int[cakeShops.size()];\n                    for (int i = 0; i < cakeShops.size(); i++) {\n                        perm[i] = cakeShops.get(i);\n                    }\n                    \n                    permute(perm, 0, minCal);\n                }\n            }\n            \n            System.out.println(minCal);\n        }\n    }\n    \n    static int minCal;\n    \n    static void permute(int[] arr, int start, int currentMin) {\n        if (start == arr.length) {\n            int hIdx = nodeToIdx.get(\"H\");\n            int dIdx = nodeToIdx.get(\"D\");\n            \n            int totalDist = dist[hIdx][nodeToIdx.get(\"C\" + arr[0])];\n            int totalCakeCal = cakeCals[arr[0]];\n            \n            for (int i = 1; i < arr.length; i++) {\n                totalDist += dist[nodeToIdx.get(\"C\" + arr[i - 1])][nodeToIdx.get(\"C\" + arr[i])];\n                totalCakeCal += cakeCals[arr[i]];\n            }\n            \n            totalDist += dist[nodeToIdx.get(\"C\" + arr[arr.length - 1])][dIdx];\n            \n            int cal = totalDist * k - totalCakeCal;\n            minCal = Math.min(minCal, cal);\n            return;\n        }\n        \n        for (int i = start; i < arr.length; i++) {\n            swap(arr, i, start);\n            permute(arr, start + 1, currentMin);\n            swap(arr, i, start);\n        }\n    }\n    \n    static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class  = dist; } }  n, k, d; static Map<String, Integer> nodeToIdx; static String[] idxToNode; static int numNodes; static int[][] dist; static  throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] parts = line.trim().split(\"\\\\s+\"); m = Integer.parseInt(parts[0]); n = Integer.parseInt(parts[1]); k = Integer.parseInt(parts[2]); d = Integer.parseInt(parts[3]); if (m == 0 && n == 0 && k == 0 && d == 0) break; cakeCals = new int[m + 1]; parts = br.readLine().trim().split(\"\\\\s+\");  cakeCals[i]  nodes = new HashSet<>(); for (int i = 0; i < d; i++)  = parts[1]; int e = Integer.parseInt(parts[2]); nodes.add(s); nodes.add(t); graph.putIfAbsent(s, new ArrayList<>()); graph.putIfAbsent(t, new ArrayList<>()); graph.get(s).add(new Edge(t, e)); graph.get(t).add(new Edge(s, e)); } nodeToIdx = new HashMap<>(); idxToNode = new String[nodes.size()];  nodeToIdx.put(node, idx); idxToNode[idx]  < numNodes; i++) { Arrays.fill(dist[i], INF); dist[i][i] = 0; } for (String  e : graph.get(from)) { int toIdx = nodeToIdx.get(e.to); dist[fromIdx][toIdx] = Math.min(dist[fromIdx][toIdx], e.dist); } } for (int kk = 0; kk < numNodes; kk++) { for (int i = 0;  INF; // Try all permutations of visiting cake shops for  = 0; i < m; i++) { if ((mask & (1  = nodeToIdx.get(\"D\"); int totalDist = dist[hIdx][dIdx]; int cal = totalDist * k; minCal = Math.min(minCal, cal); } else  } permute(perm, 0, minCal); } } System.out.println(minCal);  start, int currentMin) { if (start == arr.length) {  = dist[hIdx][nodeToIdx.get(\"C\" + arr[0])];  < arr.length; i++) { totalDist += dist[nodeToIdx.get(\"C\" + arr[i - 1])][nodeToIdx.get(\"C\" + arr[i])]; totalCakeCal += cakeCals[arr[i]]; } totalDist += dist[nodeToIdx.get(\"C\" + arr[arr.length - 1])][dIdx]; int cal = totalDist * k - totalCakeCal;  } static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } }"], "perturbed_original": [" = 2 <<  Scanner sc = new Scanner(System.in); while(true) {  && k == 0 && d == 0) break; int[] c  i++) { c[i] = sc.nextInt(); } Node[] node = new Node[m + n + 2]; for(int i = 0; i < m; i++) { node[i] = new Node(); node[i].type = 2; } for(int i = m; i <   node[m +  new Node(); node[m + n + 1].type = 1; for(int  if(a.length() == 1) { if(a.equals(\"H\")) idA = m + n; else idA = m + n +  + n; else idB = m + n + 1; } if(idA == -100) { if(a.charAt(0) == 'C') { idA = Integer.parseInt(a.substring(1)) - 1; } else { idA = m + Integer.parseInt(a.substring(1)) - 1; } } if(idB == -100) { if(b.charAt(0) == 'C') { idB = Integer.parseInt(b.substring(1)) - 1; } else { idB = m + Integer.parseInt(b.substring(1)) - 1; } } node[idA].edge_to.add(idB); node[idA].edge_cost.add(cost); node[idB].edge_to.add(idA);   { Data tmp = queue.poll(); int V = 0; for(int i =  1 << i; } } if(dp[tmp.now][V] <= tmp.cost) continue; dp[tmp.now][V] = tmp.cost; Node now = node[tmp.now]; for(int i =  tmp.v[now.edge_to.get(i)]) continue; if(node[now.edge_to.get(i)].type == 2) { boolean[] copy = Arrays.copyOf(tmp.v, tmp.v.length); copy[now.edge_to.get(i)] = true; queue.add(new Data(now.edge_to.get(i),copy, tmp.cost - c[now.edge_to.get(i)] + now.edge_cost.get(i) * k)); } else { queue.add(new Data(now.edge_to.get(i),tmp.v, tmp.cost + now.edge_cost.get(i) * k)); } } } int MIN = Integer.MAX_VALUE; for(int i = 0; i < dp[m  + n + 1][i]); } System.out.println(MIN); } } static class Data implements Comparable<Data>{  boolean[] b, int a) { cost = a; v = b; now = c; } } static  new ArrayList<Integer>(); ArrayList<Integer> edge_cost = new ArrayList<Integer>(); } }"], "original_ll": -0.5291683673858643, "sampled_ll": -0.368179053068161, "all_perturbed_sampled_ll": [-1.3328227996826172], "all_perturbed_original_ll": [-1.3883817195892334], "perturbed_sampled_ll": -1.3328227996826172, "perturbed_original_ll": -1.3883817195892334, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import combinations\nfrom heapq import heappop, heappush\nimport sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef convert(s, m, n):\n  if s == \"H\":\n    return 0\n  if s == \"D\":\n    return 1\n  if s[0] == \"C\":\n    return int(s[1]) + 1\n  if s[0] == \"L\":\n    return int(s[1]) + m + 1\n\ndef get_cost(start, m, n, edges):\n  cost = [INF] * (m + n + 2)\n  cost[start] = 0\n  que = []\n  heappush(que, (0, start))\n  while que:\n    total, node = heappop(que)\n    for dist, to in edges[node]:\n      if cost[to] > total + dist:\n        cost[to] = total + dist\n        if not (2 <= to <= m + 1):\n          heappush(que, (total + dist, to))\n  return cost\n\n\ndef shortest_path(start, goal, rest, cakes_dist, dic):\n  if not rest:\n    return cakes_dist[start][goal]\n  if (start, rest) in dic:\n    return dic[(now, rest)]\n  \n  ret = INF\n  for to in rest:\n    ret = min(ret, shortest_path(to, goal, tuple((i for i in rest if i != to)), cakes_dist, dic) + cakes_dist[start][to])\n  dic[(start, rest)] = ret\n  return ret\n\nwhile True:\n  m, n, k, d = map(int, input().split())\n  if m == 0:\n    break\n  clst = list(map(int, input().split()))\n  \"\"\"\n  Home ... 0\n  D ... 1\n  Cake ... 2, 3, ... m + 1\n  Land ... m + 2, m + 3, ... m + n + 1\n  \"\"\"\n  edges = [[] for _ in range(m + n + 2)]\n  for _ in range(d):\n    s, t, e = input().split()\n    e = int(e)\n    s = convert(s, m, n)\n    t = convert(t, m, n)\n    edges[s].append((e, t))\n    edges[t].append((e, s))\n  \n  cakes_dist = [[INF] * (m + 2) for _ in range(m + 2)]\n  for start in range(m + 2):\n    cost = get_cost(start, m, n, edges)\n    for to in range(m + 2):\n      if to != start:\n        cakes_dist[start][to] = cost[to]\n\n", "sampled": "import sys\nfrom itertools import permutations\nfrom collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start, end, avoid_set):\n    \"\"\"Find shortest path avoiding nodes in avoid_set\"\"\"\n    dist = defaultdict(lambda: float('inf'))\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        if u == end:\n            return d\n        for v, w in graph[u]:\n            if v in avoid_set:\n                continue\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    \n    return float('inf')\n\ndef solve(m, n, k, d, calories, edges):\n    # Build graph\n    graph = defaultdict(list)\n    for s, t, e in edges:\n        graph[s].append((t, e))\n        graph[t].append((s, e))\n    \n    # Get all cake shops\n    cake_shops = [f'C{i+1}' for i in range(m)]\n    \n    min_cost = float('inf')\n    \n    # Try all subsets of cake shops (including empty set)\n    for r in range(m + 1):\n        for perm in permutations(cake_shops, r):\n            # For this permutation, calculate the cost\n            # We need to go from H to each shop in order, then to D\n            # avoiding already visited shops\n            \n            visited_shops = set()\n            current = 'H'\n            total_distance = 0\n            total_calories = 0\n            valid = True\n            \n            for shop in perm:\n                # Find shortest path from current to shop, avoiding visited shops\n                dist = dijkstra(graph, current, shop, visited_shops)\n                if dist == float('inf'):\n                    valid = False\n                    break\n                total_distance += dist\n                visited_shops.add(shop)\n                # Eat cake at this shop\n                shop_idx = int(shop[1:]) - 1\n                total_calories += calories[shop_idx]\n                current = shop\n            \n            if not valid:\n                continue\n            \n            # Go from current to D, avoiding visited shops\n            dist = dijkstra(graph, current, 'D', visited_shops)\n            if dist == float('inf'):\n                continue\n            total_distance += dist\n            \n            # Calculate net calorie consumption\n            net_calories = total_distance * k - total_calories\n            min_cost = min(min_cost, net_calories)\n    \n    return min_cost\n\ndef main():\n    while True:\n        line = sys.stdin.readline().strip()\n        if not line:\n            break\n        m, n, k, d = map(int, line.split())\n        if m == 0 and n == 0 and k == 0 and d == 0:\n            break\n        \n        calories = list(map(int, sys.stdin.readline().split()))\n        \n        edges = []\n        for _ in range(d):\n            parts = sys.stdin.readline().split()\n            s, t, e = parts[0], parts[1], int(parts[2])\n            edges.append((s, t, e))\n        \n        result = solve(m, n, k, d, calories, edges)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from itertools import permutations from collections import defaultdict import heapq def dijkstra(graph,  dist = defaultdict(lambda: float('inf')) dist[start] = 0 pq =   + w heapq.heappush(pq, (dist[v], v)) return float('inf') def solve(m, n, k, d, calories, edges): # Build graph graph = defaultdict(list) for s, t, e in edges: graph[s].append((t, e)) graph[t].append((s, e)) # Get all  = float('inf') # Try  in range(m + 1): for perm in permutations(cake_shops,  order, then to D # avoiding already visited shops visited_shops = set() current = 'H' total_distance = 0 total_calories = 0 valid = True for shop   dist visited_shops.add(shop) # Eat cake at this shop shop_idx = int(shop[1:]) - 1  dist = dijkstra(graph, current, 'D', visited_shops) if dist == float('inf'): continue total_distance += dist # Calculate net calorie consumption net_calories = total_distance * k - total_calories min_cost = min(min_cost, net_calories) return min_cost def main(): while True: line = sys.stdin.readline().strip() if not line: break m, n, k, d = map(int, line.split()) if m  and d ==  _ in range(d): parts = sys.stdin.readline().split() s, t, e = parts[0], parts[1], int(parts[2]) edges.append((s, t, e)) result =  \"__main__\": main()"], "perturbed_original": ["from itertools import combinations from heapq import heappop, heappush import sys sys.setrecursionlimit(1000000) INF = 10 ** 20 def convert(s, m, n): if s == \"H\": return  \"C\": return int(s[1]) +   = []  dist, to in edges[node]: if cost[to] > total + dist: cost[to] = total + dist if not (2 <= to <= m + 1): heappush(que, (total + dist, to)) return cost def shortest_path(start, goal, rest, cakes_dist, dic): if not rest: return cakes_dist[start][goal] if (start, rest) in dic: return dic[(now, rest)] ret  goal, tuple((i for i in rest if i != to)), cakes_dist,  True: m, n, k,  Land ... m  + n + 2)] for _ in  = convert(s, m, n) t = convert(t, m, n) edges[s].append((e, t)) edges[t].append((e, s)) cakes_dist = [[INF] * (m + 2) for _ in range(m + 2)] for start in range(m + 2): cost = get_cost(start, m, n, edges) for  = cost[to]"], "original_ll": -0.8364154100418091, "sampled_ll": -0.6717803478240967, "all_perturbed_sampled_ll": [-1.869536280632019], "all_perturbed_original_ll": [-2.2084274291992188], "perturbed_sampled_ll": -1.869536280632019, "perturbed_original_ll": -2.2084274291992188, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0225\nTitle\n@kankichi573\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint n;\nint dir[26];     // in +1 out -1\nint alpha[26];   // tunagatte iruka\nchar buf[33];\nchar con[26][26];  //char a->b connection\nchar con_flag[26]; \n//\nint count_char()\n{\n        int i,cnt=0;\n\n        for(i=0;i<26;i++)\n        {\n                if (alpha[i])\n                {\n                        cnt ++;\n                        //printf(\"CH %c\\n\",'a'+i);\n                }\n        }\n        return(cnt);\n}\nint find_first()\n{\n        int i,cnt=0;\n\n        for(i=0;i<26;i++)\n                if(alpha[i]>0)\n                        return(i);\n        return(-1);\n}\n\nint connected()\n{\n        int from;\n\n        from=find_first();\n        //printf(\"FF=%c\\n\",'a'+from);\n        con_flag[from]=1;\n        return(connected2(from));\n}\nint connected2(int node)\n{\n        int i;\n        int cnt=1;\n        //printf(\"CN2=%c\\n\",'a'+node);\n\n        for(i=0;i<26;i++)\n        {\n                if(i==node)\n                        continue;\n                if(con[node][i] && !con_flag[i])\n                {\n                        //printf(\"CN2_2=%c\\n\",'a'+i);\n\n                        con_flag[i]=1;\n                        cnt += connected2(i);\n                        con_flag[i]=0;\n                }\n        }\n        return(cnt);\n}\nmain()\n{\n        int i,j;\n        int stt,end,ret,ret1;\n        while(EOF!=scanf(\"%d\",&n) && n)\n        {\n                for(i=0;i<26;i++)\n                {\n                        alpha[i]=0;\n                        dir[i]=0;\n                        con_flag[i]=0;\n                        for(j=0;j<26;j++)\n                                con[i][j]=0;\n                }\n                for(i=0;i<n;i++)\n                {\n                        scanf(\"%s\",buf);\n                        stt=buf[0]-'a';\n                        end=buf[strlen(buf)-1]-'a';\n                        dir[stt]++;\n                        dir[end]--;\n                        alpha[stt]=alpha[end]=1;\n                        con[stt][end]=1;\n                }\n\n                ret=connected();   // saisho ni toujou suru\n                                   //node to tunagatte iru suu\n                ret1=count_char(); // node no kazu\n\n                //printf(\"r=%d %d\\n\",ret,ret1);\n\n                if(ret != ret1)   // subeteno node ga tunagaruka\n                {\n                        printf(\"NG\\n\");\n                        continue;\n                }\n\n                for(i=0;i<26;i++) //zenbu guuten ka siraberu\n                        if(dir[i])\n                        {\n                                printf(\"NG\\n\");\n                                goto NEXT;\n                        }\n                printf(\"OK\\n\");\n        NEXT:\n                ;\n        }\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        char words[10000][33];\n        int first[10000], last[10000];\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", words[i]);\n            first[i] = words[i][0] - 'a';\n            last[i] = words[i][strlen(words[i]) - 1] - 'a';\n        }\n        \n        int in_degree[26] = {0};\n        int out_degree[26] = {0};\n        int char_used[26] = {0};\n        \n        for (int i = 0; i < n; i++) {\n            out_degree[first[i]]++;\n            in_degree[last[i]]++;\n            char_used[first[i]] = 1;\n            char_used[last[i]] = 1;\n        }\n        \n        int start_count = 0;\n        int end_count = 0;\n        int ok = 1;\n        \n        for (int i = 0; i < 26; i++) {\n            if (out_degree[i] - in_degree[i] == 1) {\n                start_count++;\n            } else if (in_degree[i] - out_degree[i] == 1) {\n                end_count++;\n            } else if (in_degree[i] != out_degree[i]) {\n                ok = 0;\n                break;\n            }\n        }\n        \n        if (ok) {\n            if (!((start_count == 0 && end_count == 0) || (start_count == 1 && end_count == 1))) {\n                ok = 0;\n            }\n        }\n        \n        if (ok) {\n            int adj[26][26] = {0};\n            for (int i = 0; i < n; i++) {\n                adj[first[i]][last[i]] = 1;\n            }\n            \n            int visited[26] = {0};\n            int start_node = -1;\n            for (int i = 0; i < 26; i++) {\n                if (char_used[i]) {\n                    start_node = i;\n                    break;\n                }\n            }\n            \n            int stack[26];\n            int top = 0;\n            stack[top++] = start_node;\n            visited[start_node] = 1;\n            \n            while (top > 0) {\n                int node = stack[--top];\n                for (int i = 0; i < 26; i++) {\n                    if ((adj[node][i] || adj[i][node]) && !visited[i]) {\n                        visited[i] = 1;\n                        stack[top++] = i;\n                    }\n                }\n            }\n            \n            for (int i = 0; i < 26; i++) {\n                if (char_used[i] && !visited[i]) {\n                    ok = 0;\n                    break;\n                }\n            }\n        }\n        \n        printf(\"%s\\n\", ok ? \"OK\" : \"NG\");\n    }\n    return 0;\n}\n", "perturbed_sampled": [" char  < n; i++) { scanf(\"%s\", words[i]); first[i] = words[i][0] - 'a'; last[i] = words[i][strlen(words[i]) - 1] - 'a'; } int in_degree[26] = {0}; int out_degree[26] = {0}; int char_used[26] = {0}; for (int i = 0; i < n; i++) { out_degree[first[i]]++; in_degree[last[i]]++; char_used[first[i]] = 1; char_used[last[i]] = 1; } int start_count = 0;  i = 0;  1) { start_count++; } else if (in_degree[i] - out_degree[i]  { ok = 0; break; } } if  ||  0; } } if (ok)  i < n; i++)  i; break; } } int stack[26]; int top = 0; stack[top++] = start_node; visited[start_node] = 1; while (top > 0) { int node = stack[--top]; for (int i  i; } } } for (int i = 0; i < 26; i++) { if (char_used[i] && !visited[i]) { ok = 0; break; } } } printf(\"%s\\n\", ok ? \"OK\" : \"NG\"); } return 0; }"], "perturbed_original": ["/* AizuOnline A0225 Title @kankichi573 */  <float.h>  dir[26]; // in +1 out -1 int alpha[26]; // tunagatte iruka char buf[33];  { int i,cnt=0; for(i=0;i<26;i++) { if (alpha[i]) { cnt ++; //printf(\"CH %c\\n\",'a'+i); }  return(i); return(-1); } int connected() { int from; from=find_first(); //printf(\"FF=%c\\n\",'a'+from); con_flag[from]=1; return(connected2(from)); } int connected2(int node) { int i; int cnt=1; //printf(\"CN2=%c\\n\",'a'+node); for(i=0;i<26;i++) { if(i==node) continue; if(con[node][i] && !con_flag[i])  } main() { int i,j; int stt,end,ret,ret1; while(EOF!=scanf(\"%d\",&n) && n) { for(i=0;i<26;i++)  stt=buf[0]-'a'; end=buf[strlen(buf)-1]-'a'; dir[stt]++; dir[end]--; alpha[stt]=alpha[end]=1; con[stt][end]=1;  iru suu ret1=count_char(); // node no kazu //printf(\"r=%d %d\\n\",ret,ret1); if(ret != ret1) // subeteno node ga   return(0); }"], "original_ll": -1.4612845182418823, "sampled_ll": -0.3549233376979828, "all_perturbed_sampled_ll": [-1.1823562383651733], "all_perturbed_original_ll": [-2.383213996887207], "perturbed_sampled_ll": -1.1823562383651733, "perturbed_original_ll": -2.383213996887207, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tvoid run() {\n\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true) {\n\n\t\t\tint N = Integer.parseInt(in.next());\n\t\t\t\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tList<String> wordList = new ArrayList<String>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tString word = in.next();\n\t\t\t\twordList.add(word.substring(0, 1));\n\t\t\t\twordList.add(word.substring(word.length() - 1, word.length()));\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(wordList);\n\t\t\t\n\t\t\tif(check(wordList)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean check(List<String> wordList) {\n\t\t\n\t\tint count = 1;\n\t\tString word1 = wordList.get(0);\n\t\tfor(int i = 1; i < wordList.size(); i++) {\n\t\t\tString word2 = wordList.get(i);\n\t\t\tif(word1.equals(word2)) { \n\t\t\t\tcount++; \n\t\t\t} else {\n\t\t\t\tif(count % 2 != 0) return false;\n\t\t\t\tword1 = word2;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t\tif(count % 2 != 0) { \n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static Map<Character, List<String>> startMap;\n    static Map<Character, List<String>> endMap;\n    static Set<String> used;\n    static List<String> words;\n    static int n;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            n = sc.nextInt();\n            if (n == 0) break;\n            \n            words = new ArrayList<>();\n            startMap = new HashMap<>();\n            endMap = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                String word = sc.next();\n                words.add(word);\n                \n                char start = word.charAt(0);\n                char end = word.charAt(word.length() - 1);\n                \n                startMap.putIfAbsent(start, new ArrayList<>());\n                startMap.get(start).add(word);\n                \n                endMap.putIfAbsent(end, new ArrayList<>());\n                endMap.get(end).add(word);\n            }\n            \n            boolean found = false;\n            for (String firstWord : words) {\n                used = new HashSet<>();\n                used.add(firstWord);\n                char startChar = firstWord.charAt(0);\n                char endChar = firstWord.charAt(firstWord.length() - 1);\n                \n                if (dfs(endChar, startChar, 1)) {\n                    found = true;\n                    break;\n                }\n            }\n            \n            System.out.println(found ? \"OK\" : \"NG\");\n        }\n        \n        sc.close();\n    }\n    \n    static boolean dfs(char currentEnd, char targetStart, int count) {\n        if (count == n) {\n            return currentEnd == targetStart;\n        }\n        \n        if (!startMap.containsKey(currentEnd)) {\n            return false;\n        }\n        \n        for (String word : startMap.get(currentEnd)) {\n            if (!used.contains(word)) {\n                used.add(word);\n                char nextEnd = word.charAt(word.length() - 1);\n                if (dfs(nextEnd, targetStart, count + 1)) {\n                    return true;\n                }\n                used.remove(word);\n            }\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {   main(String[] args)  = sc.nextInt(); if (n == 0) break; words = new ArrayList<>(); startMap = new HashMap<>(); endMap = new HashMap<>(); for (int i = 0; i < n;  word.charAt(0); char end = word.charAt(word.length() - 1); startMap.putIfAbsent(start, new ArrayList<>()); startMap.get(start).add(word); endMap.putIfAbsent(end, new ArrayList<>()); endMap.get(end).add(word); } boolean  endChar  = true; break; } } System.out.println(found ? \"OK\" : \"NG\"); } sc.close(); } static boolean dfs(char currentEnd, char targetStart, int count) { if (count == n) { return currentEnd == targetStart; } if (!startMap.containsKey(currentEnd)) { return false; } for (String word : startMap.get(currentEnd)) {  } used.remove(word); } } return false; } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Collections; import  Scanner in = new Scanner(System.in); while(true) { int N = Integer.parseInt(in.next()); if (N == 0) break; List<String> wordList  i++) { String word = in.next(); wordList.add(word.substring(0, 1)); wordList.add(word.substring(word.length() - 1, word.length())); } Collections.sort(wordList); if(check(wordList)) { System.out.println(\"OK\"); } else { System.out.println(\"NG\"); } } } boolean check(List<String> wordList) { int count = 1;  wordList.size(); i++) { String  % 2 != 0) return false; word1 = word2; count  public static void main(String[] args) { new Main().run(); } }"], "original_ll": -0.5638260841369629, "sampled_ll": -0.3976239264011383, "all_perturbed_sampled_ll": [-1.5209053754806519], "all_perturbed_original_ll": [-1.5654020309448242], "perturbed_sampled_ll": -1.5209053754806519, "perturbed_original_ll": -1.5654020309448242, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import defaultdict\nwhile True:\n    try:\n        n=input()\n    except SyntaxError:\n        pass\n    if n==0:break\n    dic=defaultdict(int)\n    for i in range(n):\n        w=raw_input()\n        dic[w[0]]+=1\n        dic[w[-1]]+=1\n    if len(set(dic.values()))==1:\n        print \"OK\"\n    else:\n        print \"NG\"", "sampled": "import sys\nfrom collections import defaultdict, deque\n\ndef can_form_shiritori(words):\n    if len(words) == 1:\n        return words[0][0] == words[0][-1]\n    \n    # Build graph of first and last characters\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    out_degree = defaultdict(int)\n    \n    for word in words:\n        first = word[0]\n        last = word[-1]\n        graph[first].append(last)\n        out_degree[first] += 1\n        in_degree[last] += 1\n    \n    # Get all vertices\n    vertices = set(in_degree.keys()) | set(out_degree.keys())\n    \n    # Check if Eulerian circuit exists\n    # For Eulerian circuit: in_degree == out_degree for all vertices\n    for v in vertices:\n        if in_degree[v] != out_degree[v]:\n            return False\n    \n    # Check if graph is connected (considering it as undirected for connectivity)\n    # We need to check if all edges form one connected component\n    if not vertices:\n        return True\n    \n    # Build undirected graph for connectivity check\n    undirected = defaultdict(set)\n    for word in words:\n        first = word[0]\n        last = word[-1]\n        undirected[first].add(last)\n        undirected[last].add(first)\n    \n    # BFS to check connectivity\n    start = next(iter(vertices))\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in undirected[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    # Check if all vertices with non-zero degree are visited\n    return len(visited) == len(vertices)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    words = []\n    for _ in range(n):\n        words.append(input().strip())\n    \n    if can_form_shiritori(words):\n        print(\"OK\")\n    else:\n        print(\"NG\")\n", "perturbed_sampled": ["import sys from collections import defaultdict, deque def can_form_shiritori(words): if len(words) == 1: return words[0][0] == words[0][-1] # Build graph of first and last characters graph = defaultdict(list) in_degree = defaultdict(int) out_degree = defaultdict(int)  if Eulerian circuit exists # For Eulerian circuit: in_degree ==  !=   if all edges form one connected component if not vertices: return  defaultdict(set) for word in words: first = word[0] last = word[-1] undirected[first].add(last) undirected[last].add(first) # BFS to check connectivity start = next(iter(vertices)) visited = set() queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in undirected[node]: if neighbor not  non-zero degree are  _ in range(n): words.append(input().strip()) if can_form_shiritori(words): print(\"OK\") else: print(\"NG\")"], "perturbed_original": ["from  if n==0:break dic=defaultdict(int) for i in range(n): w=raw_input() dic[w[0]]+=1 dic[w[-1]]+=1 if len(set(dic.values()))==1: print \"OK\" else: print \"NG\""], "original_ll": -1.2126497030258179, "sampled_ll": -0.755643367767334, "all_perturbed_sampled_ll": [-2.047420024871826], "all_perturbed_original_ll": [-1.8976424932479858], "perturbed_sampled_ll": -2.047420024871826, "perturbed_original_ll": -1.8976424932479858, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<string.h>\n#include<stdio.h>\nint main()\n{\n\tint h,b,i,j;\n\tchar r[5],a[5];\n\twhile(1){\n\t\tscanf(\"%s %s\",r,a);\n\t\tif(strcmp(r,\"0\")==0&&strcmp(a,\"0\")==0){\n\t\t\tbreak;\n\t\t}\n\t\th=0;\n\t\tb=0;\n\t\tfor(i=0;i<4;i++){\n\t\t\tif(r[i]==a[i]){\n\t\t\t\th++;\n\t\t\t\tr[i]='r';\n\t\t\t\ta[i]='a';\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<4;i++){\n\t\t\tfor(j=0;j<4;j++){\n\t\t\t\tif(r[i]==a[j]){\n\t\t\t\t\tb++;\n\t\t\t\t\tr[i]='r';\n\t\t\t\t\ta[j]='a';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",h,b);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char r[5], a[5];\n    \n    while (1) {\n        scanf(\"%s %s\", r, a);\n        \n        if (strcmp(r, \"0\") == 0 && strcmp(a, \"0\") == 0) {\n            break;\n        }\n        \n        int hit = 0, blow = 0;\n        \n        // Count hits\n        for (int i = 0; i < 4; i++) {\n            if (r[i] == a[i]) {\n                hit++;\n            }\n        }\n        \n        // Count blows\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                if (i != j && r[i] == a[j]) {\n                    blow++;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", hit, blow);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char r[5], a[5]; while (1) {  = 0, blow = 0;  4; i++) { if (r[i] == a[i]) { hit++; } } // Count blows for (int i = 0; i < 4; i++) { for (int j = 0; j  hit, blow); } return 0; }"], "perturbed_original": ["#include<string.h> #include<stdio.h> int main() { int h,b,i,j; char r[5],a[5]; while(1){ scanf(\"%s %s\",r,a); if(strcmp(r,\"0\")==0&&strcmp(a,\"0\")==0){ break; } h=0; b=0; for(i=0;i<4;i++){ if(r[i]==a[i]){  a[j]='a'; } } } printf(\"%d %d\\n\",h,b); } return 0; }"], "original_ll": -0.6297264099121094, "sampled_ll": -0.4211735427379608, "all_perturbed_sampled_ll": [-1.969157338142395], "all_perturbed_original_ll": [-1.4240838289260864], "perturbed_sampled_ll": -1.969157338142395, "perturbed_original_ll": -1.4240838289260864, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\tScanner s=new Scanner (System.in);\n\t\twhile(true){\n\t\t\tString a=s.next();\n\t\t\tString b=s.next();\n\t\t\tif(a.length()==1)System.exit(0);\n\t\t\tint hit=0;\n\t\t\tfor(int i=0;i<4;i++)if(a.charAt(i)==b.charAt(i))hit++;\n\t\t\tint blow=0;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\tif(a.charAt(i)==b.charAt(j)&&i!=j)blow++;\n\t\t\tSystem.out.println(hit+\" \"+blow);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String r = sc.next();\n            String a = sc.next();\n            \n            if (r.equals(\"0\") && a.equals(\"0\")) {\n                break;\n            }\n            \n            int hits = 0;\n            int blows = 0;\n            \n            // Count hits\n            for (int i = 0; i < 4; i++) {\n                if (r.charAt(i) == a.charAt(i)) {\n                    hits++;\n                }\n            }\n            \n            // Count blows\n            for (int i = 0; i < 4; i++) {\n                for (int j = 0; j < 4; j++) {\n                    if (i != j && r.charAt(i) == a.charAt(j)) {\n                        blows++;\n                    }\n                }\n            }\n            \n            System.out.println(hits + \" \" + blows);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { String r = sc.next(); String a  hits for (int i = 0; i < 4; i++) { if (r.charAt(i) == a.charAt(i)) { hits++; } } // Count blows for (int i = 0; i < 4;  j++) { if  sc.close(); } }"], "perturbed_original": ["import  Scanner (System.in); while(true){ String a=s.next(); String b=s.next(); if(a.length()==1)System.exit(0); int hit=0; for(int i=0;i<4;i++)if(a.charAt(i)==b.charAt(i))hit++; int blow=0; for(int i=0;i<4;i++) for(int j=0;j<4;j++) if(a.charAt(i)==b.charAt(j)&&i!=j)blow++; System.out.println(hit+\" \"+blow); } } }"], "original_ll": -0.8224539756774902, "sampled_ll": -0.39437612891197205, "all_perturbed_sampled_ll": [-1.6550215482711792], "all_perturbed_original_ll": [-1.379254698753357], "perturbed_sampled_ll": -1.6550215482711792, "perturbed_original_ll": -1.379254698753357, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    a,b=raw_input().split()\n    if a==b==\"0\":break\n    hit,blow=0,0\n    for i,j in zip(a,b):\n        if i==j:\n            hit+=1\n    for i in a:\n        if i in b:\n            blow+=1\n    print hit,blow-hit", "sampled": "import sys\n\nfor line in sys.stdin:\n    parts = line.strip().split()\n    if len(parts) < 2:\n        continue\n    r, a = parts[0], parts[1]\n    if r == '0' and a == '0':\n        break\n    \n    hits = 0\n    blows = 0\n    \n    for i in range(4):\n        if r[i] == a[i]:\n            hits += 1\n    \n    for i in range(4):\n        if r[i] != a[i]:\n            for j in range(4):\n                if i != j and r[i] == a[j] and r[j] != a[j]:\n                    blows += 1\n                    break\n    \n    print(hits, blows)\n", "perturbed_sampled": ["import sys for line in sys.stdin: parts = line.strip().split() if len(parts) < 2: continue r, a = parts[0], parts[1] if r  blows = 0 for i in range(4): if r[i]  r[i] != a[i]: for j  and r[j] != a[j]: blows += 1 break print(hits, blows)"], "perturbed_original": ["while True: a,b=raw_input().split() if a==b==\"0\":break hit,blow=0,0 for i,j in zip(a,b):  b: blow+=1 print hit,blow-hit"], "original_ll": -1.224846363067627, "sampled_ll": -0.8260875940322876, "all_perturbed_sampled_ll": [-2.0034120082855225], "all_perturbed_original_ll": [-2.848585605621338], "perturbed_sampled_ll": -2.0034120082855225, "perturbed_original_ll": -2.848585605621338, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,m,i,p[1000],P;\n//M(int*a){return*1[&a]-*a;}\nM(int*a,int*b){return*b-*a;}\nmain(){\n\tfor(;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",p+i);\n\t\t}\n\t\tqsort(p,n,4,M);\n\t\tP=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(i%m!=m-1)\n\t\t\t\tP+=p[i];\n\t\t}\n\t\tprintf(\"%d\\n\",P);\n\t}\n\texit(0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int n, m;\n    \n    while(1) {\n        scanf(\"%d %d\", &n, &m);\n        if(n == 0 && m == 0) break;\n        \n        int prices[1000];\n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", &prices[i]);\n        }\n        \n        qsort(prices, n, sizeof(int), compare);\n        \n        int total = 0;\n        int count = 0;\n        \n        for(int i = 0; i < n; i++) {\n            count++;\n            if(count == m) {\n                count = 0;\n            } else {\n                total += prices[i];\n            }\n        }\n        \n        printf(\"%d\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int compare(const void *a, const void *b) { return <extra_id_5>- i<extra_id_6>; else<extra_id_7>-= m;<extra_id_8>{ while (++i<extra_id_9>{ count<extra_id_10>++<extra_id_11>i < fprices[i]; i.i<extra_id_12>p [ 0 ]<extra_id_13>-= fprices[i];<extra_id_14>m ;<extra_id_15>ppl < n;<extra_id_16>ppl<extra_id_17>*=<extra_id_18>+<extra_id_19>. j ; if (<extra_id_20>)  m == 0) break; int  scanf(\"%d\", &prices[i]); } qsort(prices, n, sizeof(int), compare); int total = 0; int count = 0; for(int i = 0; i < n; i++) { count++; if(count == m) { count = 0; } else  0; }"], "perturbed_original": ["n,m,i,p[1000],P; //M(int*a){return*1[&a]-*a;} M(int*a,int*b){return*b-*a;} main(){ for(;scanf(\"%d%d\",&n,&m),n;){ for(i=0;i<n;i++){ scanf(\"%d\",p+i); } qsort(p,n,4,M); P=0; for(i=0;i<n;i++){ if(i%m!=m-1) P+=p[i]; } printf(\"%d\\n\",P); } exit(0); }"], "original_ll": -1.7095175981521606, "sampled_ll": -0.47488319873809814, "all_perturbed_sampled_ll": [-2.155035972595215], "all_perturbed_original_ll": [-1.955579161643982], "perturbed_sampled_ll": -2.155035972595215, "perturbed_original_ll": -1.955579161643982, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] num = new int[n];\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tnum[i] = scanner.nextInt();\n\t\t\t\tsum += num[i];\n\t\t\t}\n\t\t\tint mod = n % m;\n\t\t\tArrays.sort(num);\n\n\t\t\tfor (int i = mod; i < n; i += m) {\n\t\t\t\tsum -= num[i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) {\n                break;\n            }\n            \n            Integer[] prices = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                prices[i] = sc.nextInt();\n            }\n            \n            // Sort in descending order to maximize discount\n            Arrays.sort(prices, Collections.reverseOrder());\n            \n            int totalCost = 0;\n            \n            // Process full bags of m items\n            for (int i = 0; i < n; i++) {\n                // Every m-th item (0-indexed: m-1, 2m-1, 3m-1, ...) is free\n                if ((i + 1) % m == 0) {\n                    // This item is free (cheapest in its bag)\n                    continue;\n                }\n                totalCost += prices[i];\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); int m = sc.nextInt(); if (n == 0 && m ==  prices[i]  discount Arrays.sort(prices, Collections.reverseOrder()); int totalCost = 0; // Process full bags of m items for (int i =  (0-indexed:  %  in its bag) continue; } totalCost += prices[i]; } System.out.println(totalCost); } sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.util.Arrays; import java.util.Scanner; public class <extra_id_15>.<extra_id_16>; public<extra_id_17>] num ; i ++<extra_id_18>Math . floor<extra_id_19>return<extra_id_20>= num [ i ]<extra_id_21>++<extra_id_22>] num<extra_id_23>\"<extra_id_24>( num<extra_id_25>i ) { n = scanner.nextInt(); int m =  =  0; i < n; i++) { num[i] = scanner.nextInt(); sum += num[i]; } int mod = n % m; Arrays.sort(num); for (int i = mod; i < n; i += m) { sum -= num[i]; } System.out.println(sum); } } }"], "original_ll": -0.6229953765869141, "sampled_ll": -0.7621711492538452, "all_perturbed_sampled_ll": [-2.169206142425537], "all_perturbed_original_ll": [-2.0234813690185547], "perturbed_sampled_ll": -2.169206142425537, "perturbed_original_ll": -2.0234813690185547, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    a = raw_input()\n    print 'a'", "sampled": "import sys\n\ndef solve(n, m, prices):\n    # Sort prices in descending order\n    prices.sort(reverse=True)\n    \n    total = 0\n    i = 0\n    \n    while i < n:\n        # Take up to m items for this bag\n        bag_size = min(m, n - i)\n        \n        if bag_size == m:\n            # Full bag - the cheapest (last) item is free\n            for j in range(bag_size - 1):\n                total += prices[i + j]\n            # prices[i + bag_size - 1] is free (the cheapest in this bag)\n        else:\n            # Incomplete bag - no discount\n            for j in range(bag_size):\n                total += prices[i + j]\n        \n        i += bag_size\n    \n    return total\n\n# Read input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.strip())\n\ni = 0\nwhile i < len(lines):\n    parts = lines[i].split()\n    n, m = int(parts[0]), int(parts[1])\n    \n    if n == 0 and m == 0:\n        break\n    \n    i += 1\n    prices = list(map(int, lines[i].split()))\n    i += 1\n    \n    result = solve(n, m, prices)\n    print(result)\n", "perturbed_sampled": ["import sys  prices.sort(reverse=True) total = 0 i =  items for this bag bag_size = min(m, n - i) if  total += prices[i + j] # prices[i + bag_size - 1] is free (the  discount for j in range(bag_size): total += prices[i + j] i += bag_size return total # Read input lines = [] for line in sys.stdin: lines.append(line.strip()) i = 0 while i < len(lines): parts = lines[i].split() n, m = int(parts[0]), int(parts[1]) if n ==  =  print(result)"], "perturbed_original": ["while True: a = raw_input() print 'a'"], "original_ll": -3.00580096244812, "sampled_ll": -0.9069462418556213, "all_perturbed_sampled_ll": [-2.592508554458618], "all_perturbed_original_ll": [-3.9289016723632812], "perturbed_sampled_ll": -2.592508554458618, "perturbed_original_ll": -3.9289016723632812, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  int i,j,n,num,prev;\n  char segment[]=\"0000000\";\n  char nums[][8]={\"0111111\",\"0000110\",\"1011011\",\"1001111\",\n\t\t  \"1100110\",\"1101101\",\"1111101\",\"0100111\",\n\t\t  \"1111111\",\"1101111\",\"0000000\"};\n  do{\n    scanf(\"%d\",&n);\n    if(n==-1) break;\n    for(prev=10,i=0;i<n;i++,prev=num){\n      scanf(\"%d\",&num);\n      for(j=0;j<7;j++){\n\tif(nums[prev][j]==nums[num][j]){\n\t  segment[j]='0';\n\t}else{\n\t  segment[j]='1';\n\t}\n      }\n      printf(\"%s\\n\",segment);\n    }\n  }while(1);\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int segments[10] = {\n        0b0111111,  // 0\n        0b0000110,  // 1\n        0b1011011,  // 2\n        0b1001111,  // 3\n        0b1100110,  // 4\n        0b1101101,  // 5\n        0b1111101,  // 6\n        0b0000111,  // 7\n        0b1111111,  // 8\n        0b1101111   // 9\n    };\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != -1) {\n        int current = 0;  // Initial state: all segments off\n        \n        for (int i = 0; i < n; i++) {\n            int digit;\n            scanf(\"%d\", &digit);\n            \n            int target = segments[digit];\n            int signal = current ^ target;  // XOR to get the toggle bits\n            \n            // Print signal in binary (7 bits, from bit 6 to bit 0)\n            for (int j = 6; j >= 0; j--) {\n                printf(\"%d\", (signal >> j) & 1);\n            }\n            printf(\"\\n\");\n            \n            current = target;  // Update current state\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int segments[10] = { 0b0111111, // 0  int n; while (scanf(\"%d\", &n) == 1 && n != -1) { int current = 0; // Initial state: all segments off for (int i = 0; i < n; i++) { int digit; scanf(\"%d\", &digit); int target = segments[digit]; int signal = current ^ target; //  binary   >> j) & 1); } printf(\"\\n\"); current = target; // Update current state } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int i,j,n,num,prev; char segment[]=\"0000000\"; char nums[][8]={\"0111111\",\"0000110\",\"1011011\",\"1001111\",  segment[j]='0'; }else{ segment[j]='1'; } } printf(\"%s\\n\",segment); } }while(1); return 0; }"], "original_ll": -1.0468730926513672, "sampled_ll": -0.5656563639640808, "all_perturbed_sampled_ll": [-1.8921486139297485], "all_perturbed_original_ll": [-1.8829890489578247], "perturbed_sampled_ll": -1.8921486139297485, "perturbed_original_ll": -1.8829890489578247, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tString [] digit = {\"0111111\",\"0000110\",\"1011011\",\"1001111\",\"1100110\",\n\t\t\t\"1101101\",\"1111101\", \"0100111\",\"1111111\",\"1101111\"};\n\t\n\tprivate void doit() {\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1) break;\n\t\t\tStringBuilder nowstate = new StringBuilder(\"0000000\");\n\t\t\twhile(n-- > 0){\n\t\t\t\tint num = sc.nextInt();\n\t\t\t\tString numstr = digit[num];\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(int i = 0; i < numstr.length(); i++){\n\t\t\t\t\tif(numstr.charAt(i) == nowstate.charAt(i)){\n\t\t\t\t\t\tsb.append(0);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tsb.append(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sb.toString());\n\t\t\t\tnowstate = new StringBuilder(numstr);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Define 7-segment patterns for digits 0-9\n        // Pattern is in order: abcdefg (bits 0-6)\n        int[] patterns = {\n            0b0111111, // 0\n            0b0000110, // 1\n            0b1011011, // 2\n            0b1001111, // 3\n            0b1100110, // 4\n            0b1101101, // 5\n            0b1111101, // 6\n            0b0000111, // 7\n            0b1111111, // 8\n            0b1101111  // 9\n        };\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == -1) break;\n            \n            int currentState = 0; // Initially all segments are off\n            \n            for (int i = 0; i < n; i++) {\n                int digit = sc.nextInt();\n                int targetState = patterns[digit];\n                \n                // Calculate XOR to get the signal needed\n                int signal = currentState ^ targetState;\n                \n                // Output the signal in reverse bit order (gfedcba)\n                StringBuilder sb = new StringBuilder();\n                for (int bit = 6; bit >= 0; bit--) {\n                    sb.append((signal >> bit) & 1);\n                }\n                System.out.println(sb.toString());\n                \n                // Update current state\n                currentState = targetState;\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["targetState<extra_id_2>s = new<extra_id_3>0x0d0000ccf; for (int<extra_id_4>0b111011111;<extra_id_5>11) break; //<extra_id_6>) ; }<extra_id_7>+ e); sb.append( ((targetState args) { Scanner sc = new Scanner(System.in); // Define 7-segment patterns for digits 0-9 // Pattern is in order: abcdefg (bits targetState<extra_id_8>sb.append(((currentState<extra_id_9>if (targetState<extra_id_10>0b111011011)<extra_id_11>+<extra_id_12>10;<extra_id_13>} 1 0b1011011, // 2 0b1001111, // 3 0b1100110, // 4 0b1101101, // 5 0b1111101, //  (n == -1) break; int currentState  i = 0; i < n; i++) {  XOR to get the signal needed int signal = currentState ^ targetState; // Output the signal in  (int bit = 6; bit >= 0; bit--) { sb.append((signal  currentState = targetState; } } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main { Scanner sc = new Scanner(System.in); String [] digit = {\"0111111\",\"0000110\",\"1011011\",\"1001111\",\"1100110\", \"1101101\",\"1111101\",  = sc.nextInt(); if(n == -1) break; StringBuilder nowstate = new StringBuilder(\"0000000\"); while(n-- > 0){  } } System.out.println(sb.toString()); nowstate = new StringBuilder(numstr); } } } private void debug(Object... o) {  args) { new Main().doit(); } }"], "original_ll": -0.9870535731315613, "sampled_ll": -0.5418260097503662, "all_perturbed_sampled_ll": [-2.3460042476654053], "all_perturbed_original_ll": [-2.0770809650421143], "perturbed_sampled_ll": -2.3460042476654053, "perturbed_original_ll": -2.0770809650421143, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# AOJ 0228: Seven Segments\n# Python3 2018.6.25 bal4u\n \np = [[1,1,1,1,1,1,0], [0,1,1,0,0,0,0], [1,1,0,1,1,0,1], [1,1,1,1,0,0,1], [0,1,1,0,0,1,1], \\\n     [1,0,1,1,0,1,1], [1,0,1,1,1,1,1], [1,1,1,0,0,1,0], [1,1,1,1,1,1,1], [1,1,1,1,0,1,1]]\n \nwhile True:\n    n = int(input())\n    if n < 0: break\n    a = [0]*7\n    for i in range(n):\n        d = int(input())\n        ans = ''\n        for j in range(6,-1,-1):\n            k = (a[j] ^ p[d][j]) & 1\n            ans += '1' if k else '0'\n            if k: a[j] = 1-a[j]\n        print(ans)\n", "sampled": "def get_segments(digit):\n    segments = {\n        0: \"0111111\",\n        1: \"0000110\",\n        2: \"1011011\",\n        3: \"1001111\",\n        4: \"1100110\",\n        5: \"1101101\",\n        6: \"1111101\",\n        7: \"0000111\",\n        8: \"1111111\",\n        9: \"1101111\"\n    }\n    return segments[digit]\n\ndef xor_bits(a, b):\n    result = \"\"\n    for i in range(7):\n        if a[i] != b[i]:\n            result += \"1\"\n        else:\n            result += \"0\"\n    return result\n\nwhile True:\n    n = int(input())\n    if n == -1:\n        break\n    \n    current_state = \"0000000\"\n    \n    for _ in range(n):\n        digit = int(input())\n        target_state = get_segments(digit)\n        signal = xor_bits(current_state, target_state)\n        print(signal)\n        current_state = target_state\n", "perturbed_sampled": ["def get_segments(digit): segments = { 0: \"0111111\", 1: \"0000110\", 2: \"1011011\", 3: \"1001111\", 4: \"1100110\", 5: \"1101101\", 6: \"1111101\", 7:  b): result = \"\" for i in  if n == -1: break current_state = \"0000000\" for _ in range(n): digit  current_state = target_state"], "perturbed_original": [" = [[1,1,1,1,1,1,0], [0,1,1,0,0,0,0], [1,1,0,1,1,0,1], [1,1,1,1,0,0,1], [0,1,1,0,0,1,1], \\ [1,0,1,1,0,1,1], [1,0,1,1,1,1,1], [1,1,1,0,0,1,0],  0: break a = [0]*7 for i in range(n): d = int(input()) ans = '' for j in range(6,-1,-1): k = (a[j] ^ p[d][j]) &  a[j] = 1-a[j] print(ans)"], "original_ll": -0.9040422439575195, "sampled_ll": -0.516766369342804, "all_perturbed_sampled_ll": [-1.5054442882537842], "all_perturbed_original_ll": [-1.3503614664077759], "perturbed_sampled_ll": -1.5054442882537842, "perturbed_original_ll": -1.3503614664077759, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(b,r,g,c,s,t){for(;~scanf(\"%d%d%d%d%d%d\",&b,&r,&g,&c,&s,&t)&&t;printf(\"%d\\n\",b*95+r*63+g*7+c*2+s*3-t*3+100));}", "sampled": "#include <stdio.h>\n\nint main() {\n    int b, r, g, c, s, t;\n    \n    while (1) {\n        scanf(\"%d %d %d %d %d %d\", &b, &r, &g, &c, &s, &t);\n        \n        if (b == 0 && r == 0 && g == 0 && c == 0 && s == 0 && t == 0) {\n            break;\n        }\n        \n        int medals = 100;\n        \n        // Big bonus games: 5 games each, 2 medals in, 15 medals out per game\n        int big_bonus_games = b * 5;\n        medals += big_bonus_games * (15 - 2);\n        \n        // Regular bonus games: 3 games each, 2 medals in, 15 medals out per game\n        int regular_bonus_games = r * 3;\n        medals += regular_bonus_games * (15 - 2);\n        \n        // Total bonus games\n        int bonus_games = big_bonus_games + regular_bonus_games;\n        \n        // Normal games\n        int normal_games = t - bonus_games;\n        \n        // For normal games, we need to account for:\n        // - Games that triggered bonuses (b + r games, cost 3 medals each, no payout from trigger itself)\n        // - Games with grapes (g games, cost 3 medals, get 15 medals)\n        // - Games with cherries (c games, cost 3 medals, get 3 medals)\n        // - Games with stars (s games, cost 3 medals first time, get 0 medals but next game is free)\n        // - Games that got nothing\n        \n        // Star games: first star costs 3, gets 0, then next game is free (costs 0)\n        // So s stars means s games cost 3 medals and s games cost 0 medals\n        // But we need to be careful about counting\n        \n        // Actually, let's think differently:\n        // - b games triggered big bonus: cost 3, no payout\n        // - r games triggered regular bonus: cost 3, no payout\n        // - g games got grapes: cost 3, payout 15\n        // - c games got cherries: cost 3, payout 3\n        // - s games got stars: cost 3, payout 0, but next game is free\n        // - remaining games got nothing: cost 3, payout 0\n        \n        // Total normal games played\n        // Some of these are free (after stars)\n        // Games that cost medals: normal_games - s (since s games following a star are free)\n        \n        medals -= (normal_games - s) * 3;  // Cost of normal games (excluding free games after stars)\n        medals += b * 0;  // Big bonus triggers give no payout\n        medals += r * 0;  // Regular bonus triggers give no payout\n        medals += g * 15; // Grape payouts in normal games\n        medals += c * 3;  // Cherry payouts in normal games\n        medals += s * 0;  // Star payouts (none)\n        \n        printf(\"%d\\n\", medals);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int b, r, g, c, s, t; while (1) { scanf(\"%d %d %d  medals = 100; // Big bonus games: 5 games each, 2 medals in, 15 medals out per game int big_bonus_games = b  Regular bonus games: 3 games each, 2  r * 3; medals += regular_bonus_games * (15 - 2); // Total bonus  int normal_games = t -  // - Games that triggered bonuses (b +  3 medals, get 15 medals) // -  medals) // - Games with stars (s games, cost 3 medals first time, get 0 medals but next game is free) // - Games that  0, then next game is free (costs 0) // So s stars means s games cost 3  need to be careful about counting // Actually, let's think differently: // - b games triggered big bonus: cost 3, no payout // - r games triggered regular bonus: cost 3,  payout 15 //  but next game is free // - remaining games got nothing: cost 3, payout 0  free (after stars) // Games that cost medals: normal_games - s (since s games following a star are free) medals -=   payout medals += g * 15; // Grape payouts in normal games medals += c * 3; // Cherry payouts in normal games medals += s * 0; // Star payouts (none) printf(\"%d\\n\", medals); } return 0; }"], "perturbed_original": ["main(b,r,g,c,s,t){for(;~scanf(\"%d%d%d%d%d%d\",&b,&r,&g,&c,&s,&t)&&t;printf(\"%d\\n\",b*95+r*63+g*7+c*2+s*3-t*3+100));}"], "original_ll": -2.098954439163208, "sampled_ll": -1.202185034751892, "all_perturbed_sampled_ll": [-2.8210272789001465], "all_perturbed_original_ll": [-2.098954439163208], "perturbed_sampled_ll": -2.8210272789001465, "perturbed_original_ll": -2.098954439163208, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        for(;;) {\n         int b=sc.nextInt()*5,r=sc.nextInt()*3,g=sc.nextInt(),c=sc.nextInt(),s=sc.nextInt(),t=sc.nextInt();\n         if((b|r|g|c|s|t)==0) {\n             break;\n         }\n         System.out.println(100+b+b*18+r+r*20+g*7+c*2-(t-s)*3);\n        }\n    }\n}\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int b = sc.nextInt();\n            int r = sc.nextInt();\n            int g = sc.nextInt();\n            int c = sc.nextInt();\n            int s = sc.nextInt();\n            int t = sc.nextInt();\n            \n            if (b == 0 && r == 0 && g == 0 && c == 0 && s == 0 && t == 0) {\n                break;\n            }\n            \n            int medals = 100;\n            \n            // Big bonus games: 5 games each, spend 2 medals, get 15 medals\n            int bigBonusGames = b * 5;\n            medals += bigBonusGames * (15 - 2);\n            \n            // Regular bonus games: 3 games each, spend 2 medals, get 15 medals\n            int regularBonusGames = r * 3;\n            medals += regularBonusGames * (15 - 2);\n            \n            // Total bonus games\n            int totalBonusGames = bigBonusGames + regularBonusGames;\n            \n            // Normal games\n            int normalGames = t - totalBonusGames;\n            \n            // Calculate medals from normal games\n            // Grape in normal game: spend 3, get 15, net +12\n            medals += g * (15 - 3);\n            \n            // Cherry in normal game: spend 3, get 8, net +5\n            medals += c * (8 - 3);\n            \n            // Star in normal game: spend 3, get 0, but next game is free\n            // Net effect: -3 for star game, +3 for free game = 0\n            // But we need to count that star games are part of normal games\n            \n            // Games that cost 3 medals (normal games minus free games from stars)\n            int paidNormalGames = normalGames - s;\n            \n            // Games where nothing special happened\n            int noWinGames = paidNormalGames - g - c - s;\n            \n            // These games cost 3 medals with no return\n            medals -= noWinGames * 3;\n            \n            System.out.println(medals);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main {  Scanner(System.in); while (true) { int b = sc.nextInt();  = sc.nextInt(); int s = sc.nextInt(); int t = sc.nextInt(); if (b == 0 && r == 0 && g  && t == 0)  games: 5 games  2 medals, get 15 medals int regularBonusGames = r * 3; medals += regularBonusGames * (15 - 2); // Total bonus games int totalBonusGames = bigBonusGames + regularBonusGames; // Normal  from normal games // Grape in normal game: spend 3, get 15, net +12 medals += g * (15 - 3);  +5 medals += c * (8 - 3); // Star in normal game: spend 3, get 0, but next game is free // Net effect: -3 for  we need  //  Games where  c - s; // These games cost 3 medals with no return medals -= noWinGames * 3; System.out.println(medals); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args)  if((b|r|g|c|s|t)==0) { break; } System.out.println(100+b+b*18+r+r*20+g*7+c*2-(t-s)*3); } } }"], "original_ll": -1.6344847679138184, "sampled_ll": -1.0583350658416748, "all_perturbed_sampled_ll": [-2.813514232635498], "all_perturbed_original_ll": [-2.6467244625091553], "perturbed_sampled_ll": -2.813514232635498, "perturbed_original_ll": -2.6467244625091553, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    b,r,g,c,s,t=map(int,input().split())\n    if [b,r,g,c,s,t].count(0)==6:break\n    print(100+(b+r)*15+g*7+c*2+(b*5+r*3)*13-(t-(s+b*5+r*3))*3)", "sampled": "while True:\n    line = input().split()\n    b, r, g, c, s, t = map(int, line)\n    \n    if b == 0 and r == 0 and g == 0 and c == 0 and s == 0 and t == 0:\n        break\n    \n    medals = 100\n    \n    # Big bonus games: 5 games each\n    big_bonus_games = b * 5\n    # Regular bonus games: 3 games each\n    regular_bonus_games = r * 3\n    # Total bonus games\n    bonus_games = big_bonus_games + regular_bonus_games\n    # Normal games\n    normal_games = t - bonus_games\n    \n    # Bonus games: spend 2, get 15 (net +13 per game)\n    medals += bonus_games * (15 - 2)\n    \n    # Normal games cost 3 medals each\n    medals -= normal_games * 3\n    \n    # Grape in normal games: get 15\n    medals += g * 15\n    \n    # Cherry in normal games: get 8\n    medals += c * 8\n    \n    # Star games are free (refund 3 medals)\n    medals += s * 3\n    \n    print(medals)\n", "perturbed_sampled": ["while True: line = input().split() b, r, g,  and r == 0 and g == 0 and c == 0 and s == 0 and t ==  games each  games each regular_bonus_games  big_bonus_games + regular_bonus_games # Normal games normal_games = t  -= normal_games * 3 # Grape in normal games: get 15 medals += g * 15 # Cherry in normal games: get 8 medals += c * 8 # Star games are free (refund 3 medals) medals += s * 3 print(medals)"], "perturbed_original": ["while 1: b,r,g,c,s,t=map(int,input().split()) if [b,r,g,c,s,t].count(0)==6:break print(100+(b+r)*15+g*7+c*2+(b*5+r*3)*13-(t-(s+b*5+r*3))*3)"], "original_ll": -1.8500282764434814, "sampled_ll": -1.3422671556472778, "all_perturbed_sampled_ll": [-3.141164779663086], "all_perturbed_original_ll": [-2.102109670639038], "perturbed_sampled_ll": -3.141164779663086, "perturbed_original_ll": -2.102109670639038, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "short*p,v[][99];main(c,n,m,i,y){for(;m=scanf(\"%d %[^\\n] %[^\\n]\",&n,v,v+1)*n;printf(m>n?\"NA\\n\":\"%d\\n\",m))for(i=2;i--;m=c)for(c=0,y=n;y>1&c<m;y+=y==n|*p&2?2:*p&p[-1]&1?0:!++c-1)p=--y+v[c+i&1];}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 101\n#define INF 999999\n\nint n;\nint a[MAX_N], b[MAX_N];\nint ladder_top[2][MAX_N];\nint dist[2][MAX_N];\n\nint process_position(int building, int floor) {\n    if (floor > n) return floor;\n    \n    if (a[floor] == 0 || b[floor] == 0) {\n        int wall = (building == 0) ? a[floor] : b[floor];\n        if (wall == 0) return floor;\n        else if (wall == 1) return ladder_top[building][floor];\n        else return floor;\n    }\n    \n    int wall = (building == 0) ? a[floor] : b[floor];\n    \n    if (wall == 0) {\n        return floor;\n    } else if (wall == 1) {\n        return ladder_top[building][floor];\n    } else {\n        for (int f = floor - 1; f >= 1; f--) {\n            int w = (building == 0) ? a[f] : b[f];\n            if (w == 0) return f;\n            if (w == 1) return ladder_top[building][f];\n        }\n        return 1;\n    }\n}\n\nint main() {\n    while (scanf(\"%d\", &n) && n != 0) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &b[i]);\n        }\n        \n        for (int building = 0; building < 2; building++) {\n            for (int i = 1; i <= n; i++) {\n                int wall = (building == 0) ? a[i] : b[i];\n                if (wall == 1) {\n                    int top = i;\n                    while (top < n) {\n                        int next_wall = (building == 0) ? a[top + 1] : b[top + 1];\n                        if (next_wall == 1) top++;\n                        else break;\n                    }\n                    ladder_top[building][i] = top;\n                } else {\n                    ladder_top[building][i] = i;\n                }\n            }\n        }\n        \n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j <= n; j++) {\n                dist[i][j] = INF;\n            }\n        }\n        \n        int queue[MAX_N * 2][2];\n        int front = 0, rear = 0;\n        \n        int pos0 = process_position(0, 1);\n        int pos1 = process_position(1, 1);\n        \n        dist[0][pos0] = 1;\n        queue[rear][0] = 0;\n        queue[rear][1] = pos0;\n        rear++;\n        \n        dist[1][pos1] = 1;\n        queue[rear][0] = 1;\n        queue[rear][1] = pos1;\n        rear++;\n        \n        while (front < rear) {\n            int cur_building = queue[front][0];\n            int cur_floor = queue[front][1];\n            front++;\n            \n            int other_building = 1 - cur_building;\n            \n            for (int delta = 0; delta <= 2; delta++) {\n                int next_floor = cur_floor + delta;\n                int final_floor = process_position(other_building, next_floor);\n                \n                if (final_floor >= 1 && final_floor <= n) {\n                    if (dist[other_building][final_floor] > dist[cur_building][cur_floor] + 1) {\n                        dist[other_building][final_floor] = dist[cur_building][cur_floor] + 1;\n                        queue[rear][0] = other_building;\n                        queue[rear][1] = final_floor;\n                        rear++;\n                    }\n                }\n            }\n        }\n        \n        int result = INF;\n        if (dist[0][n] < result) result = dist[0][n];\n        if (dist[1][n] < result) result = dist[1][n];\n        \n        if (result == INF) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  return floor; if (a[floor] == 0 || b[floor] == 0) { int wall = (building == 0) ? a[floor] : b[floor]; if (wall == 0) return floor; else if (wall == 1)  == 0) ? a[floor] : b[floor]; if (wall == 0) { return floor; } else if (wall == 1) { return ladder_top[building][floor]; } else  1; f--) { int w = (building == 0) ? a[f] : b[f]; if (w  } return 1; }   i++) { scanf(\"%d\", &a[i]); } for (int i = 1; i <= n; i++) { scanf(\"%d\", &b[i]); } for (int  wall = (building == 0) ? a[i] : b[i]; if (wall == 1)  int next_wall = (building == 0) ? a[top + 1] : b[top + 1]; if (next_wall == 1) top++; else break; } ladder_top[building][i] =  j++) { dist[i][j] = INF; }   queue[rear][1] =  queue[front][0]; int cur_floor = queue[front][1]; front++; int  delta <= 2; delta++) { int next_floor = cur_floor + delta; int final_floor = process_position(other_building, next_floor); if (final_floor >= 1 && final_floor <= n) { if (dist[other_building][final_floor] > dist[cur_building][cur_floor] + 1) { dist[other_building][final_floor] = dist[cur_building][cur_floor] + 1; queue[rear][0] = other_building; queue[rear][1] = final_floor; rear++; } } } } int result = INF; if (dist[0][n] < result) result = dist[0][n]; if (dist[1][n] < result) result = dist[1][n]; if (result == INF) {  }"], "perturbed_original": ["short*p,v[][99];main(c,n,m,i,y){for(;m=scanf(\"%d %[^\\n] %[^\\n]\",&n,v,v+1)*n;printf(m>n?\"NA\\n\":\"%d\\n\",m))for(i=2;i--;m=c)for(c=0,y=n;y>1&c<m;y+=y==n|*p&2?2:*p&p[-1]&1?0:!++c-1)p=--y+v[c+i&1];}"], "original_ll": -3.373260974884033, "sampled_ll": -0.4251067638397217, "all_perturbed_sampled_ll": [-1.3634589910507202], "all_perturbed_original_ll": [-3.373260974884033], "perturbed_sampled_ll": -1.3634589910507202, "perturbed_original_ll": -3.373260974884033, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    void run() {\n        for (;;) {\n            // 1 \u884c\u76ee \u30d3\u30eb\u306e\u968e\u6570 n(\u6574\u6570)\n            // 2 \u884c\u76ee 1 \u3064\u76ee\u306e\u30d3\u30eb a \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 a1 a2 ... an(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a)\n            // \u5404 ai \u306f\u3001i \u968e\u76ee\u306e\u58c1\u306e\u60c5\u5831\u3092\u8868\u3057\u3001\u610f\u5473\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3067\u3059\u3002\n            // 0:\u666e\u901a\u306e\u58c1\n            // 1:\u306f\u3057\u3054(i \u968e\u3068 i+1 \u968e\u306b\u307e\u305f\u304c\u308b)\n            // 2:\u3059\u3079\u308b\u58c1\n            // 3 \u884c\u76ee 2 \u3064\u76ee\u306e\u30d3\u30eb b \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 b1 b2 ... bn(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a)\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int fs[][] = new int[2][n];\n            for (int i = 0; i < n; i++) {\n                fs[0][i] = sc.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                fs[1][i] = sc.nextInt();\n            }\n            Queue<Data> q = new LinkedList<Data>();\n            int sfa = 0;\n            int sfb = 0;\n            if (fs[0][0] == 1)\n                while (sfa + 1 < n && fs[0][sfa + 1] == 1)\n                    sfa++;\n            if (fs[1][0] == 1)\n                while (sfb + 1 < n && fs[1][sfb + 1] == 1)\n                    sfb++;\n            q.add(new Data(0, sfa, 0));\n            q.add(new Data(1, sfb, 0));\n            Set<String> set = new HashSet<String>();\n            boolean na = true;\n            while (!q.isEmpty()) {\n                Data d = q.poll();\n                int b = d.b;\n                int f = d.f;\n                if (set.contains(b + \" \" + f))\n                    continue;\n                set.add(b + \" \" + f);\n                int t = d.t;\n                if (f == n - 1 && fs[b][n - 1] != 2) {\n                    System.out.println(t);\n                    na = false;\n                    break;\n                }\n                int nb = b ^ 1;\n                for (int i = 0; i < 3; i++) {\n                    // \u5411\u304b\u3044\u5074\u306e\u30d3\u30eb\u3078\u30b8\u30e3\u30f3\u30d7\u3059\u308b\u3068\u304d\u306b\u306f\u3001\n                    // \u540c\u3058\u968e\u30fb1\u3064\u4e0a\u306e\u968e\u30fb2 \u3064\u4e0a\u306e\u968e\u306e\u3001\u3044\u305a\u308c\u304b\u306b\u98db\u3073\u79fb\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n                    if (i + f >= n)\n                        continue;\n                    int nf = f + i;\n                    switch (fs[nb][i + f]) {\n                    case 0:\n                        q.add(new Data(nb, nf, t + 1));\n                        break;\n                    case 1:\n                        while (nf + 1 < n && fs[nb][nf + 1] == 1)\n                            nf++;\n                        q.add(new Data(nb, nf, t + 1));\n                        break;\n                    case 2:\n                        while (fs[nb][nf] == 2)\n                            nf--;\n                        q.add(new Data(nb, nf, t + 1));\n                        break;\n                    }\n                }\n\n            }\n            if (na)\n                System.out.println(\"NA\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n\nclass Data {\n    int b;\n    int f;\n    int t;\n\n    Data(int b, int f, int t) {\n        this.b = b;\n        this.f = f;\n        this.t = t;\n    }\n\n    public String toString() {\n        return b + \" \" + f + \" \" + t;\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class State {\n        int building; // 0 or 1\n        int floor;\n        int jumps;\n        \n        State(int building, int floor, int jumps) {\n            this.building = building;\n            this.floor = floor;\n            this.jumps = jumps;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] a = new int[n + 1];\n            int[] b = new int[n + 1];\n            \n            for (int i = 1; i <= n; i++) {\n                a[i] = sc.nextInt();\n            }\n            for (int i = 1; i <= n; i++) {\n                b[i] = sc.nextInt();\n            }\n            \n            int result = solve(n, a, b);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        sc.close();\n    }\n    \n    static int solve(int n, int[] a, int[] b) {\n        int[][] walls = {a, b};\n        boolean[][] visited = new boolean[2][n + 1];\n        Queue<State> queue = new LinkedList<>();\n        \n        // Start from floor 1 of either building\n        int floor0 = processFloor(0, 1, walls, n);\n        int floor1 = processFloor(1, 1, walls, n);\n        \n        if (floor0 != -1) {\n            queue.add(new State(0, floor0, 0));\n            visited[0][floor0] = true;\n        }\n        if (floor1 != -1) {\n            queue.add(new State(1, floor1, 0));\n            visited[1][floor1] = true;\n        }\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.floor == n) {\n                return curr.jumps;\n            }\n            \n            int otherBuilding = 1 - curr.building;\n            \n            // Jump to same floor, +1, or +2\n            for (int delta = 0; delta <= 2; delta++) {\n                int targetFloor = curr.floor + delta;\n                if (targetFloor > n) continue;\n                \n                int finalFloor = processFloor(otherBuilding, targetFloor, walls, n);\n                \n                if (finalFloor != -1 && !visited[otherBuilding][finalFloor]) {\n                    visited[otherBuilding][finalFloor] = true;\n                    queue.add(new State(otherBuilding, finalFloor, curr.jumps + 1));\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static int processFloor(int building, int floor, int[][] walls, int n) {\n        int[] wall = walls[building];\n        \n        if (wall[floor] == 0) {\n            return floor;\n        } else if (wall[floor] == 1) {\n            // Climb ladder to the top\n            int top = floor;\n            while (top < n && wall[top] == 1) {\n                top++;\n            }\n            return top;\n        } else { // wall[floor] == 2\n            // Slide down\n            int slideFloor = floor;\n            while (slideFloor > 1) {\n                slideFloor--;\n                if (wall[slideFloor] == 0) {\n                    return slideFloor;\n                } else if (wall[slideFloor] == 1) {\n                    // Find top of ladder\n                    int top = slideFloor;\n                    while (top < n && wall[top] == 1) {\n                        top++;\n                    }\n                    return top;\n                }\n                // If wall[slideFloor] == 2, continue sliding\n            }\n            // Slid all the way to floor 1 or below, cannot start here\n            return -1;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class State { int building; // 0 or 1 int floor; int jumps; State(int building, int floor, int jumps) { this.building = building;  void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; int[] a = new int[n + 1]; int[] b = new int[n + 1]; for (int i = 1; i <=   } int result = solve(n, a, b); if  visited = new boolean[2][n + 1]; Queue<State>  int floor1 = processFloor(1, 1, walls, n);  State(1, floor1, 0)); visited[1][floor1] = true; } while (!queue.isEmpty()) { State curr = queue.poll(); if (curr.floor == n)  // Jump to same floor, +1, or +2 for (int delta = 0; delta <= 2; delta++) { int targetFloor   && !visited[otherBuilding][finalFloor]) { visited[otherBuilding][finalFloor] = true; queue.add(new State(otherBuilding,   { return  ladder to the top int top = floor; while (top < n && wall[top] == 1) { top++; } return top; } else { // wall[floor] == 2  1) { slideFloor--; if (wall[slideFloor] == 0) { return slideFloor; } else if (wall[slideFloor] == 1) { // Find top of ladder int top = slideFloor; while (top < n &&  If wall[slideFloor] == 2, continue sliding } // Slid all the way to  } }"], "perturbed_original": ["import  class Main { Scanner sc = new Scanner(System.in); void run() { for (;;) { // 1 \u884c\u76ee \u30d3\u30eb\u306e\u968e\u6570 n(\u6574\u6570) // 2 \u884c\u76ee 1 \u3064\u76ee\u306e\u30d3\u30eb a \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 a1 a2 ... an(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a) // \u5404 ai \u306f\u3001i \u968e\u76ee\u306e\u58c1\u306e\u60c5\u5831\u3092\u8868\u3057\u3001\u610f\u5473\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3067\u3059\u3002 // 0:\u666e\u901a\u306e\u58c1 // 1:\u306f\u3057\u3054(i \u968e\u3068 i+1 \u968e\u306b\u307e\u305f\u304c\u308b) // 2:\u3059\u3079\u308b\u58c1 // 3 \u884c\u76ee 2 \u3064\u76ee\u306e\u30d3\u30eb b \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 b1 b2 ... bn(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a) int n = sc.nextInt(); if (n == 0) break; int fs[][] =  i++) { fs[0][i] = sc.nextInt(); } for (int i = 0; i < n;  LinkedList<Data>(); int sfa = 0; int sfb = 0; if (fs[0][0] ==  1] == 1) sfa++; if (fs[1][0] == 1) while (sfb + 1 < n  0)); q.add(new Data(1, sfb, 0)); Set<String>  { Data d = q.poll(); int b = d.b; int f =  + \" \" + f);  && fs[b][n - 1] != 2) { System.out.println(t); na = false; break; } int nb =  3; i++) { // \u5411\u304b\u3044\u5074\u306e\u30d3\u30eb\u3078\u30b8\u30e3\u30f3\u30d7\u3059\u308b\u3068\u304d\u306b\u306f\u3001 // \u540c\u3058\u968e\u30fb1\u3064\u4e0a\u306e\u968e\u30fb2 \u3064\u4e0a\u306e\u968e\u306e\u3001\u3044\u305a\u308c\u304b\u306b\u98db\u3073\u79fb\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002 if  q.add(new Data(nb,  1   break; } } } if (na) System.out.println(\"NA\"); } } public static void main(String[] args) { new Main().run(); } } class Data { int b;  \" \" + f + \" \" + t; } }"], "original_ll": -0.8344951868057251, "sampled_ll": -0.5269590020179749, "all_perturbed_sampled_ll": [-1.7448091506958008], "all_perturbed_original_ll": [-1.9570536613464355], "perturbed_sampled_ll": -1.7448091506958008, "perturbed_original_ll": -1.9570536613464355, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import Queue\nwhile True:\n    n = input()\n    if n==0:\n        break\n    a = []\n    nxt = [range(n) for i in xrange(2)]\n    for i in xrange(2):\n        a.append(map(int, raw_input().split()))\n    for i in xrange(2):\n        back = 0\n        for j in xrange(n):\n            if a[i][j]==2:\n                nxt[i][j] = back\n            else:\n                back = j\n        forw = n-1\n        for j in xrange(n-1,-1,-1):\n            if a[i][j]==1:\n                nxt[i][j] = forw\n            else:\n                forw = j-1\n    cost = [[10**9] * n for i in xrange(2)]\n    que = Queue.PriorityQueue()\n    que.put((0, 0, 0))\n    que.put((0, 1, 0))\n    ans = -1\n    while not que.empty():\n        co, sd, st = que.get()\n        if st==n-1:\n            ans = co\n            break\n        if cost[sd][st] < co:\n            continue\n        for i in xrange(3 if st+2<n else 2):\n            step = nxt[sd^1][st+i]\n            if co+1 < cost[sd^1][step]:\n                cost[sd^1][step] = co+1\n                que.put((co+1, sd^1, step))\n    print \"NA\" if ans==-1 else ans", "sampled": "from collections import deque\n\ndef solve(n, a, b):\n    # Preprocess ladders - find top of each ladder\n    def find_ladder_top(walls):\n        tops = list(range(n))\n        i = 0\n        while i < n:\n            if walls[i] == 1:\n                j = i\n                while j < n and walls[j] == 1:\n                    j += 1\n                for k in range(i, j):\n                    tops[k] = j - 1\n                i = j\n            else:\n                i += 1\n        return tops\n    \n    ladder_tops_a = find_ladder_top(a)\n    ladder_tops_b = find_ladder_top(b)\n    \n    # Function to find where we end up after landing on floor i of building side\n    def land_on(floor, side):\n        if side == 0:\n            walls = a\n            ladder_tops = ladder_tops_a\n        else:\n            walls = b\n            ladder_tops = ladder_tops_b\n        \n        if walls[floor] == 0:  # Normal wall\n            return floor\n        elif walls[floor] == 1:  # Ladder\n            return ladder_tops[floor]\n        else:  # walls[floor] == 2, sliding wall\n            # Slide down to normal wall or top of ladder\n            for f in range(floor - 1, -1, -1):\n                if walls[f] == 0:\n                    return f\n                elif walls[f] == 1:\n                    return ladder_tops[f]\n            return -1  # Should not happen as floor 0 is not sliding\n    \n    # BFS\n    queue = deque()\n    visited = set()\n    \n    # Start from floor 0 of either building\n    start_a = land_on(0, 0)\n    start_b = land_on(0, 1)\n    \n    if start_a >= 0:\n        queue.append((0, start_a, 0))  # (side, floor, jumps)\n        visited.add((0, start_a))\n    if start_b >= 0:\n        queue.append((1, start_b, 0))\n        visited.add((1, start_b))\n    \n    while queue:\n        side, floor, jumps = queue.popleft()\n        \n        # Check if we can reach rooftop\n        if floor == n - 1:\n            return jumps\n        \n        # Try jumping to other building\n        other_side = 1 - side\n        for delta in [0, 1, 2]:\n            next_floor = floor + delta\n            if next_floor < n:\n                final_floor = land_on(next_floor, other_side)\n                if final_floor >= 0 and (other_side, final_floor) not in visited:\n                    visited.add((other_side, final_floor))\n                    queue.append((other_side, final_floor, jumps + 1))\n    \n    return \"NA\"\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    result = solve(n, a, b)\n    print(result)\n", "perturbed_sampled": ["from collections import deque def solve(n, a, b): # Preprocess ladders - find top of each ladder def find_ladder_top(walls): tops = list(range(n)) i = 0 while i < n: if walls[i] == 1:  i += 1 return tops ladder_tops_a = find_ladder_top(a) ladder_tops_b = find_ladder_top(b) # Function to find where we end up after landing on floor i of building side def land_on(floor, side): if side == 0: walls = a ladder_tops = ladder_tops_a else:  # Normal wall return floor elif walls[floor] == 1: # Ladder return  f in  f elif walls[f] == 1: return ladder_tops[f] return -1 # Should   0 of either  start_a >= 0: queue.append((0, start_a, 0)) # (side, floor, jumps)  start_b)) while queue: side, floor, jumps = queue.popleft() # Check if we can reach rooftop if floor == n - 1: return jumps # Try jumping to other building other_side = 1 - side  delta if next_floor < n: final_floor = land_on(next_floor, other_side) if final_floor >= 0 and (other_side, final_floor)   input().split())) result = solve(n, a, b) print(result)"], "perturbed_original": ["import Queue else queue.put((0,<extra_id_6>0,<extra_id_7>0, 0,<extra_id_8>n<extra_id_9>==-1 else ans<extra_id_10>co) fo(st+i<extra_id_11>} else : que.put((0,<extra_id_12>1, 0)) os.setsize(os.getsize(os.getsize(os.get [] nxt = [range(n) for i in xrange(2)]  back = 0 for j in xrange(n): if a[i][j]==2: nxt[i][j] = back else: back = j forw = n-1 for j in xrange(n-1,-1,-1): if a[i][j]==1: nxt[i][j]  n  que.put((0, 1, 0)) ans = -1 while not  co break if cost[sd][st] < co: continue for i in xrange(3 if st+2<n else 2): step = nxt[sd^1][st+i] if co+1  if ans==-1 else ans"], "original_ll": -0.9225606322288513, "sampled_ll": -0.7288434505462646, "all_perturbed_sampled_ll": [-2.292618989944458], "all_perturbed_original_ll": [-2.7603609561920166], "perturbed_sampled_ll": -2.292618989944458, "perturbed_original_ll": -2.7603609561920166, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "m[100],a[100],b[100],i,j,M,B;main(n){for(;scanf(\"%d\",&n)*n;puts(B?\"NG\":\"OK\")){for(i=n;i--;B=0)scanf(\"%d%d%d\",m+i,a+i,b+i);for(i=n;i--;B|=M>150)for(M=0,j=n;j--;)M+=a[i]>=a[j]&&a[i]<b[j]?m[j]:0;}}\nm[100],a[100],b[100],i,j,M,B;", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int time;\n    int weight;\n    int type; // 0 for start, 1 for end\n} Event;\n\nint compare(const void *a, const void *b) {\n    Event *ea = (Event *)a;\n    Event *eb = (Event *)b;\n    if (ea->time != eb->time) {\n        return ea->time - eb->time;\n    }\n    // If times are equal, process end events before start events\n    return ea->type - eb->type;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Event events[200];\n        int eventCount = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int m, a, b;\n            scanf(\"%d %d %d\", &m, &a, &b);\n            \n            events[eventCount].time = a;\n            events[eventCount].weight = m;\n            events[eventCount].type = 0;\n            eventCount++;\n            \n            events[eventCount].time = b;\n            events[eventCount].weight = m;\n            events[eventCount].type = 1;\n            eventCount++;\n        }\n        \n        qsort(events, eventCount, sizeof(Event), compare);\n        \n        int currentWeight = 0;\n        int broken = 0;\n        \n        for (int i = 0; i < eventCount; i++) {\n            if (events[i].type == 0) {\n                // Person starts crossing\n                currentWeight += events[i].weight;\n                if (currentWeight > 150) {\n                    broken = 1;\n                    break;\n                }\n            } else {\n                // Person finishes crossing\n                currentWeight -= events[i].weight;\n            }\n        }\n        \n        if (broken) {\n            printf(\"NG\\n\");\n        } else {\n            printf(\"OK\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef  for start, 1 for end } Event; int compare(const void  Event *eb = (Event  before start events return ea->type - eb->type; } int main() { int n; while (scanf(\"%d\", &n) == 1 && n != 0) { Event events[200]; int eventCount = 0; for (int i = 0; i < n;  = 0; eventCount++; events[eventCount].time = b; events[eventCount].weight = m; events[eventCount].type = 1; eventCount++; } qsort(events, eventCount, sizeof(Event), compare);  i = 0; i < eventCount; i++) { if  break; } } else { // Person finishes crossing currentWeight -= events[i].weight; } } if (broken) { printf(\"NG\\n\"); } else { printf(\"OK\\n\"); } } return 0; }"], "perturbed_original": ["m[100],a[100],b[100],i,j,M,B;main(n){for(;scanf(\"%d\",&n)*n;puts(B?\"NG\":\"OK\")){for(i=n;i--;B=0)scanf(\"%d%d%d\",m+i,a+i,b+i);for(i=n;i--;B|=M>150)for(M=0,j=n;j--;)M+=a[i]>=a[j]&&a[i]<b[j]?m[j]:0;}} m[100],a[100],b[100],i,j,M,B;"], "original_ll": -1.7404495477676392, "sampled_ll": -0.4474373757839203, "all_perturbed_sampled_ll": [-2.011793851852417], "all_perturbed_original_ll": [-1.7369858026504517], "perturbed_sampled_ll": -2.011793851852417, "perturbed_original_ll": -1.7369858026504517, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n//Dangerous Bridge\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tboolean[][] map = new boolean[n*2][250];\n\t\t\tint[] w = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tfor(int j=a;j<b;j++)map[i][j] = true;\n\t\t\t}\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<231;i++){\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(map[j][i])sum+=w[j];\n\t\t\t\t}\n\t\t\t\tif(sum>150){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(f?\"OK\":\"NG\");\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            List<Event> events = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                int m = sc.nextInt();\n                long a = sc.nextLong();\n                long b = sc.nextLong();\n                \n                events.add(new Event(a, m, true));\n                events.add(new Event(b, m, false));\n            }\n            \n            Collections.sort(events);\n            \n            int currentWeight = 0;\n            boolean broken = false;\n            \n            for (Event e : events) {\n                if (e.isEnter) {\n                    currentWeight += e.weight;\n                    if (currentWeight > 150) {\n                        broken = true;\n                        break;\n                    }\n                } else {\n                    currentWeight -= e.weight;\n                }\n            }\n            \n            System.out.println(broken ? \"NG\" : \"OK\");\n        }\n        \n        sc.close();\n    }\n    \n    static class Event implements Comparable<Event> {\n        long time;\n        int weight;\n        boolean isEnter;\n        \n        Event(long time, int weight, boolean isEnter) {\n            this.time = time;\n            this.weight = weight;\n            this.isEnter = isEnter;\n        }\n        \n        @Override\n        public int compareTo(Event other) {\n            if (this.time != other.time) {\n                return Long.compare(this.time, other.time);\n            }\n            // Exit events should come before enter events at the same time\n            if (this.isEnter != other.isEnter) {\n                return this.isEnter ? 1 : -1;\n            }\n            return 0;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n ==  = 0; i < n; i++)  b = sc.nextLong(); events.add(new Event(a, m, true)); events.add(new Event(b,  =  currentWeight  break; } } else { currentWeight -= e.weight; } } System.out.println(broken ? \"NG\" : \"OK\"); } sc.close(); } static class Event implements Comparable<Event> { long time; int weight; boolean isEnter; Event(long time, int weight, boolean isEnter) { this.time = time; this.weight = weight; this.isEnter =  time  -1; } return 0; } } }"], "perturbed_original": ["import java.util.Scanner; //Dangerous Bridge public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in);  boolean[n*2][250]; int[] w = new int[n]; for(int i=0;i<n;i++){ w[i] = sc.nextInt(); int a = sc.nextInt(); int  = true; for(int i=0;i<231;i++){ int sum = 0; for(int j=0;j<n;j++){  } } }"], "original_ll": -0.8024237155914307, "sampled_ll": -0.4381779134273529, "all_perturbed_sampled_ll": [-1.8327069282531738], "all_perturbed_original_ll": [-1.935559630393982], "perturbed_sampled_ll": -1.8327069282531738, "perturbed_original_ll": -1.935559630393982, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n=input()\n    if n==0: break\n    d=[map(int,raw_input().split()) for i in range(n)]\n    w=max([sum([d2[0] for d2 in d if d2[1]<=d1[1]<d2[2]]) for d1 in d])\n    print \"OK\" if w<151 else \"NG\"", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    people = []\n    for _ in range(n):\n        m, a, b = map(int, input().split())\n        people.append((m, a, b))\n    \n    # Collect all time points\n    times = set()\n    for m, a, b in people:\n        times.add(a)\n        times.add(b)\n    \n    times = sorted(times)\n    \n    broken = False\n    for t in times:\n        total_weight = 0\n        for m, a, b in people:\n            if a <= t < b:\n                total_weight += m\n        if total_weight > 150:\n            broken = True\n            break\n    \n    if broken:\n        print(\"NG\")\n    else:\n        print(\"OK\")\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break people = [] for _ in range(n):  Collect all time points times = set() for m, a, b in people: times.add(a)   if a <= t < b: total_weight  if broken: print(\"NG\") else: print(\"OK\")"], "perturbed_original": ["while 1: n=input()  d2 in d if d2[1]<=d1[1]<d2[2]]) for d1 in d]) print \"OK\" if w<151 else \"NG\""], "original_ll": -1.3409409523010254, "sampled_ll": -0.7262316942214966, "all_perturbed_sampled_ll": [-3.011213541030884], "all_perturbed_original_ll": [-2.8962185382843018], "perturbed_sampled_ll": -3.011213541030884, "perturbed_original_ll": -2.8962185382843018, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "char z[];n,a;main(r){for(;scanf(\"%d\",&a)*a;puts(z+n))for(n=30;a;a=(r-a)/10)r=a%10,z[--n]=r+48;}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    long long n;\n    \n    while(scanf(\"%lld\", &n) == 1 && n != 0) {\n        if(n == 0) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        char result[100];\n        int idx = 0;\n        \n        long long num = n;\n        while(num != 0) {\n            long long remainder = num % (-10);\n            num = num / (-10);\n            \n            if(remainder < 0) {\n                remainder += 10;\n                num += 1;\n            }\n            \n            result[idx++] = '0' + remainder;\n        }\n        \n        for(int i = idx - 1; i >= 0; i--) {\n            printf(\"%c\", result[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main()  } char result[100]; int idx = 0; long long num =  % (-10); num = num  += 1; } result[idx++] = '0' + remainder; } for(int i = idx - 1; i >= 0; i--) { printf(\"%c\", result[i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["char z[];n,a;main(r){for(;scanf(\"%d\",&a)*a;puts(z+n))for(n=30;a;a=(r-a)/10)r=a%10,z[--n]=r+48;}"], "original_ll": -2.924003839492798, "sampled_ll": -0.5489943623542786, "all_perturbed_sampled_ll": [-1.747428297996521], "all_perturbed_original_ll": [-2.924003839492798], "perturbed_sampled_ll": -1.747428297996521, "perturbed_original_ll": -2.924003839492798, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint ss = sc.nextInt();\n\t\t\tif(ss == 0) break;\n\t\t\tboolean minus = false;\n\t\t\tif(ss < 0) minus = true;\n\t\t\tchar[] in = String.valueOf(ss).toCharArray();\n\t\t\tint[] ar0 = new int[32];\n\t\t\tint[] ar1 = new int[32];\n\t\t\tfor(int i = 0; i < in.length; i++) {\n\t\t\t\tif(in[in.length - i - 1] == '-') continue;\n\t\t\t\tar0[i] = in[in.length -1 - i] - '0';\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tif(!minus)\n\t\t\tfor(int i = 0; i < 32; i++) {\n\t\t\t\tif(ar0[i] == 0) continue;\n\t\t\t\tmax = i;\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\tar1[i] += ar0[i];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tar0[i+1] += ar0[i]/10;\n\t\t\t\t\t\tar1[i] += ar0[i] % 10;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tar0[i+1] += ar0[i] / 10;\n\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\tif(ar0[i] % 10 != 0)\n\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < 32; i++) {\n\t\t\t\t\tif(ar0[i] == 0) continue;\n\t\t\t\t\tif(i % 2 != 0) {\n\t\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\t\tar1[i] += ar0[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tar0[i+1] += ar0[i]/10;\n\t\t\t\t\t\t\tar1[i] += ar0[i] % 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tar0[i+1] += ar0[i] / 10;\n\t\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\t\tif(ar0[i] % 10 != 0)\n\t\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint check = 0;\n\t\t\tfor(int i = 0; i < 32; i++) {\n\t\t\t\tif(ar1[i] != 0) {\n\t\t\t\t\tcheck = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = check; i >= 0; i--) {\n\t\t\t\tSystem.out.print(ar1[i]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long A = sc.nextLong();\n            if (A == 0) break;\n            \n            if (A == 0) {\n                System.out.println(\"0\");\n                continue;\n            }\n            \n            StringBuilder result = new StringBuilder();\n            long num = A;\n            \n            while (num != 0) {\n                long remainder = num % (-10);\n                num = num / (-10);\n                \n                if (remainder < 0) {\n                    remainder += 10;\n                    num += 1;\n                }\n                \n                result.append(remainder);\n            }\n            \n            System.out.println(result.reverse().toString());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main  new Scanner(System.in); while (true) { long A = sc.nextLong(); if (A == 0) break; if (A == 0)  num = A; while (num != 0) { long remainder = num % (-10); num = num   }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.HashMap; import java.util.Scanner; import java.util.*; import java.math.*; import java.io.*; public class Main { public static void main(String[] args) { Scanner sc  == 0) break; boolean minus = false; if(ss < 0) minus = true; char[] in = String.valueOf(ss).toCharArray(); int[] ar0 = new int[32]; int[] ar1 = new int[32]; for(int i = 0; i < in.length; i++) { if(in[in.length - i -  i = 0;  = i; if(i % 2  % 10; } } else {  10; ar0[i+1] += 1; } else { ar0[i+1] += ar0[i] / 10; ar1[i] += 10 - ar0[i] % 10; if(ar0[i] % 10  for(int i = 0;  ar1[i] += ar0[i]; } else { ar0[i+1] += ar0[i]/10; ar1[i]  10) { ar1[i] += 10 - ar0[i] % 10; ar0[i+1]  ar1[i] += 10 - ar0[i] % 10; if(ar0[i] %  int check =  if(ar1[i] != 0) { check = i; } } for(int i  } } }"], "original_ll": -0.4426286816596985, "sampled_ll": -0.5797029733657837, "all_perturbed_sampled_ll": [-2.168696165084839], "all_perturbed_original_ll": [-1.4456008672714233], "perturbed_sampled_ll": -2.168696165084839, "perturbed_original_ll": -1.4456008672714233, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n\tn = raw_input()[::-1]\n\tif n == \"0\": break\n\tans = \"\"\n\tm = 1 if n[-1] == \"-\" else 0\n\tfor i in range(0, len(n) - m, 2):\n\t\tif int(n[i]) > 0:\n\t\t\tif i < len(n) - 1 - m:\n\t\t\t\tans += str(10 - int(n[i])) + str(int(n[i + 1]) + 1)\n\t\t\telse:\n\t\t\t\tans += str(10 - int(n[i])) + \"1\"\n\t\telse:\n\t\t\tans += \"0\" + n[i + 1]\n\tif len(n) == 1 or (m == 0 and n[0] == \"0\"):\n\t\tans = int(\"2\"+\"0\"*len(n)) - int(ans[::-1]) \n\telse:\n\t\tans = int(ans[::-1])\n\tprint ans", "sampled": "import sys\n\ndef to_negadecimal(n):\n    if n == 0:\n        return \"0\"\n    \n    result = []\n    while n != 0:\n        if n > 0:\n            remainder = n % (-10)\n            n = n // (-10)\n            if remainder < 0:\n                remainder += 10\n                n += 1\n        else:\n            remainder = n % (-10)\n            n = n // (-10)\n            if remainder < 0:\n                remainder += 10\n                n += 1\n        result.append(str(remainder))\n    \n    return ''.join(reversed(result))\n\nfor line in sys.stdin:\n    a = int(line.strip())\n    if a == 0 and line.strip() == \"0\":\n        # Check if this is the last zero (terminator)\n        break\n    print(to_negadecimal(a))\n```\n\nWait, let me reconsider the termination condition:\n\n```python\nimport sys\n\ndef to_negadecimal(n):\n    if n == 0:\n        return \"0\"\n    \n    result = []\n    while n != 0:\n        remainder = n % (-10)\n        n = n // (-10)\n        if remainder < 0:\n            remainder += 10\n            n += 1\n        result.append(str(remainder))\n    \n    return ''.join(reversed(result))\n\nfor line in sys.stdin:\n    a = int(line.strip())\n    if a == 0:\n        break\n    print(to_negadecimal(a))\n", "perturbed_sampled": ["import sys def  = n % (-10) n = n // (-10) if remainder < 0: remainder += 10 n +=   += 1 result.append(str(remainder)) return ''.join(reversed(result)) for line in sys.stdin: a = int(line.strip()) if a == 0 and line.strip() == \"0\": #  ``` Wait, let  if n == 0: return \"0\" result = [] while n != 0:  if remainder < 0: remainder += 10 n += 1 result.append(str(remainder)) return ''.join(reversed(result)) for line in sys.stdin: a = int(line.strip()) if a == 0: break print(to_negadecimal(a))"], "perturbed_original": ["while 1: n = raw_input()[::-1] if n == \"0\": break ans = \"\"  i in range(0, len(n) - m, 2): if int(n[i]) > 0: if i < len(n) - 1 - m: ans  ans += \"0\" + n[i + 1] if len(n) == 1 or (m  int(ans[::-1]) else: ans = int(ans[::-1]) print ans"], "original_ll": -1.0079280138015747, "sampled_ll": -0.6850851774215698, "all_perturbed_sampled_ll": [-1.9155913591384888], "all_perturbed_original_ll": [-1.999832034111023], "perturbed_sampled_ll": -1.9155913591384888, "perturbed_original_ll": -1.999832034111023, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "W,H,m,c[10][10];\nDP[10][10][10][10][51];//\u008ec\u008b\u00e0[y\u008d\u00c0\u0095W][x\u008d\u00c0\u0095W][\u008d\u00b6\u0092[][\u0089E\u0092[][\u008e_\u0091f\u008ec\u0097\u00ca]\n#define Update(d,v) ((v)>(d)?d=(v):0)\nCalcO(o,x,y){//\u008e_\u0091f\u008ec\u0097\u00ca\u0082\u00cc\u008cv\u008eZ\n\tif(c[x][y]>0){\n\t\to+=c[x][y];\n\t\tif(o>m)\n\t\t\to=m;\n\t}\n\treturn o;\n}\nCalcF(f,x,y){//\u008ec\u008b\u00e0\u0082\u00cc\u008cv\u008eZ\n\tif(c[x][y]<0)\n\t\tf+=c[x][y];\n\treturn f;\n}\nmain(){\n\tint x,y,range,d,dx,f,o,xl,xr,fn,on,f0;\n\tfor(;scanf(\"%d%d%d%d%d\",&W,&H,&f0,&m,&o),W;){\n\t\tfor(y=0;y<H;y++)\n\t\t\tfor(x=0;x<W;x++)\n\t\t\t\tscanf(\"%d\",&c[x][y]);\n\t\tf0++;//\u008ec\u008b\u00e00\u0082\u00c5\u0082\u00e0DP\u0082\u00cd1\u0082\u00c6\u0082\u00b5\u0082\u00c4\u0081ANA\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00cc\u0082\u00f0\u0096h\u0082\u00ae\n\t\tfor(y=0,x=0;x<W;x++)\n\t\t\tDP[y][x][x][x][CalcO(o-1,x,y)]=CalcF(f0,x,y);\n\t\tfor(y=0;y<H-1;y++){\n\t\t\tfor(range=0;range<W;range++){//\u008d\u00b6\u0089E\u0082\u00c9\u008c@\u0082\u00e9\u008dL\u0082\u00b3\n\t\t\t\tfor(d=0;d<2;d++){//\u008c\u00bb\u008d\u00dd\u0088\u00ca\u0092ux\u0082\u00f0\u0089\u009d\u0095\u009c\u0082\u00b3\u0082\u00b9\u0082\u00e9\n\t\t\t\t\tfor(xl=0;xl<W-range;xl++){//\u008d\u00b6\u0092[\n\t\t\t\t\t\tfor(dx=0;dx<=range;dx++){//x\u0095\u00cf\u0088\u00ca\n\t\t\t\t\t\t\txr=xl+range;\n\t\t\t\t\t\t\tx=d?xr-dx:xl+dx;\n\t\t\t\t\t\t\t//printf(\"range=%d, d=%d, xl=%d, dx=%d, xr=%d, x=%d\\n\",range,d,xl,dx,xr,x);\n\t\t\t\t\t\t\tfor(o=m;o>0;o--){\n\t\t\t\t\t\t\t\tif(f=DP[y][x][xl][xr][o]){\n\t\t\t\t\t\t\t\t\tif(x>0){\n\t\t\t\t\t\t\t\t\t\tif(x==xl){//\u008d\u00b6\u0082\u00d6\u008c@\u0082\u00e9\n\t\t\t\t\t\t\t\t\t\t\tfn=CalcF(f,x-1,y);\n\t\t\t\t\t\t\t\t\t\t\ton=CalcO(o-1,x-1,y);\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x-1][x-1][xr][on],fn);\n\t\t\t\t\t\t\t\t\t\t}else{//\u008d\u00b6\u0082\u00d6\u0090i\u0082\u00de\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x-1][xl][xr][o-1],f);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(x<W-1){\n\t\t\t\t\t\t\t\t\t\tif(x==xr){//\u0089E\u0082\u00d6\u008c@\u0082\u00e9\n\t\t\t\t\t\t\t\t\t\t\tfn=CalcF(f,x+1,y);\n\t\t\t\t\t\t\t\t\t\t\ton=CalcO(o-1,x+1,y);\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x+1][xl][x+1][on],fn);\n\t\t\t\t\t\t\t\t\t\t}else{//\u0089E\u0082\u00d6\u0090i\u0082\u00de\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x+1][xl][xr][o-1],f);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//\u0089\u00ba\u0082\u00d6\u008c@\u0082\u00e9\n\t\t\t\t\t\t\t\t\tfn=CalcF(f,x,y+1);\n\t\t\t\t\t\t\t\t\ton=CalcO(o-1,x,y+1);\n\t\t\t\t\t\t\t\t\tUpdate(DP[y+1][x][x][x][on],fn);\n\t\t\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}//o\n\t\t\t\t\t\t}//dx\n\t\t\t\t\t}//xl\n\t\t\t\t}//d\n\t\t\t}//range\n\t\t}//y\n#if 0\n\t\tfor(y=0;y<H;y++){\n\t\t\tfor(x=0;x<W;x++){\n\t\t\t\tfor(o=m;o>0;o--){\n\t\t\t\t\tif(f=DP[y][x][x][x][o]){\n\t\t\t\t\t\tprintf(\"%4d \",f-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(o==0)\n\t\t\t\t\tprintf(\"---- \");\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n#endif\n\t\tfn=0;\n\t\tfor(x=0;x<W;x++){\n\t\t\tfor(o=m;o>0;o--){\n\t\t\t\tf=DP[H-1][x][x][x][o];\n\t\t\t\tif(f>fn)\n\t\t\t\t\tfn=f;\n\t\t\t}\n\t\t}\n\t\tprintf(fn?\"%d\\n\":\"NA\\n\",f0-fn);\n\t\tmemset(DP,0,sizeof(DP));\n\t}\n\tputs(\"\");\n\texit(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_W 10\n#define MAX_H 10\n#define MAX_O 50\n\nint W, H, f, m, o;\nint grid[MAX_W + 1][MAX_H + 1];\nint visited[MAX_W + 1][MAX_H + 1][MAX_O + 1];\nint cost[MAX_W + 1][MAX_H + 1][MAX_O + 1];\n\ntypedef struct {\n    int x, y, oxygen, c;\n} State;\n\nState queue[1000000];\nint front, rear;\n\nvoid enqueue(int x, int y, int oxygen, int c) {\n    queue[rear].x = x;\n    queue[rear].y = y;\n    queue[rear].oxygen = oxygen;\n    queue[rear].c = c;\n    rear++;\n}\n\nState dequeue() {\n    return queue[front++];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &W, &H);\n        if (W == 0 && H == 0) break;\n        \n        scanf(\"%d %d %d\", &f, &m, &o);\n        \n        for (int j = 1; j <= H; j++) {\n            for (int i = 1; i <= W; i++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        \n        memset(visited, 0, sizeof(visited));\n        for (int i = 0; i <= W; i++) {\n            for (int j = 0; j <= H; j++) {\n                for (int k = 0; k <= m; k++) {\n                    cost[i][j][k] = INT_MAX;\n                }\n            }\n        }\n        \n        front = 0;\n        rear = 0;\n        \n        for (int i = 1; i <= W; i++) {\n            if (grid[i][1] > 0) {\n                int new_o = o - 1 + grid[i][1];\n                if (new_o > m) new_o = m;\n                if (new_o > 0) {\n                    enqueue(i, 1, new_o, 0);\n                    cost[i][1][new_o] = 0;\n                }\n            } else {\n                int dig_cost = -grid[i][1];\n                if (o > 1) {\n                    enqueue(i, 1, o - 1, dig_cost);\n                    cost[i][1][o - 1] = dig_cost;\n                }\n            }\n        }\n        \n        int min_cost = INT_MAX;\n        \n        while (front < rear) {\n            State s = dequeue();\n            int x = s.x;\n            int y = s.y;\n            int oxy = s.oxygen;\n            int c = s.c;\n            \n            if (visited[x][y][oxy]) continue;\n            visited[x][y][oxy] = 1;\n            \n            if (y == H) {\n                if (c < min_cost) {\n                    min_cost = c;\n                }\n                continue;\n            }\n            \n            int dx[] = {-1, 1, 0};\n            int dy[] = {0, 0, 1};\n            \n            for (int d = 0; d < 3; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                \n                if (nx < 1 || nx > W || ny < 1 || ny > H) continue;\n                \n                if (grid[nx][ny] > 0) {\n                    int new_oxy = oxy - 1 + grid[nx][ny];\n                    if (new_oxy > m) new_oxy = m;\n                    if (new_oxy > 0 && !visited[nx][ny][new_oxy]) {\n                        if (cost[nx][ny][new_oxy] > c) {\n                            cost[nx][ny][new_oxy] = c;\n                            enqueue(nx, ny, new_oxy, c);\n                        }\n                    }\n                } else {\n                    int dig_cost = -grid[nx][ny];\n                    int new_cost = c + dig_cost;\n                    int new_oxy = oxy - 1;\n                    if (new_oxy > 0 && !visited[nx][ny][new_oxy]) {\n                        if (cost[nx][ny][new_oxy] > new_cost) {\n                            cost[nx][ny][new_oxy] = new_cost;\n                            enqueue(nx, ny, new_oxy, new_cost);\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (min_cost == INT_MAX || min_cost > f) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", min_cost);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>   + 1][MAX_O + 1]; int cost[MAX_W + 1][MAX_H + 1][MAX_O + 1]; typedef struct { int x, y, oxygen, c; } State; State queue[1000000]; int front, rear; void enqueue(int x, int y, int oxygen, int c) { queue[rear].x = x; queue[rear].y  State dequeue() { return queue[front++]; } int main() { while (1) { scanf(\"%d %d\", &W, &H); if (W == 0 && H ==  j = 1; j <= H; j++) { for (int i = 1; i <= W; i++) { scanf(\"%d\",  0;  } } } front = 0; rear = 0; for (int i = 1; i <= W; i++) { if  + grid[i][1]; if (new_o  enqueue(i, 1, new_o, 0); cost[i][1][new_o] = 0; } }  1] = dig_cost; } } } int min_cost = INT_MAX; while (front < rear) { State s = dequeue(); int x = s.x; int y = s.y; int oxy = s.oxygen; int c = s.c; if (visited[x][y][oxy]) continue; visited[x][y][oxy] = 1; if (y == H)  continue; } int dx[] = {-1, 1, 0}; int dy[] = {0, 0, 1}; for (int d = 0; d <  ny = y + dy[d]; if (nx < 1 ||  = oxy - 1 + grid[nx][ny]; if (new_oxy  !visited[nx][ny][new_oxy]) { if  c); } } } else { int dig_cost = -grid[nx][ny]; int new_cost =  (new_oxy > 0 && !visited[nx][ny][new_oxy]) { if (cost[nx][ny][new_oxy] >  } } } } if (min_cost == INT_MAX || min_cost >  return 0; }"], "perturbed_original": ["W,H,m,c[10][10]; DP[10][10][10][10][51];//\u008ec\u008b\u00e0[y\u008d\u00c0\u0095W][x\u008d\u00c0\u0095W][\u008d\u00b6\u0092[][\u0089E\u0092[][\u008e_\u0091f\u008ec\u0097\u00ca] #define Update(d,v) ((v)>(d)?d=(v):0) CalcO(o,x,y){//\u008e_\u0091f\u008ec\u0097\u00ca\u0082\u00cc\u008cv\u008eZ if(c[x][y]>0){ o+=c[x][y]; if(o>m) o=m;  DP[y][x][x][x][CalcO(o-1,x,y)]=CalcF(f0,x,y); for(y=0;y<H-1;y++){ for(range=0;range<W;range++){//\u008d\u00b6\u0089E\u0082\u00c9\u008c@\u0082\u00e9\u008dL\u0082\u00b3 for(d=0;d<2;d++){//\u008c\u00bb\u008d\u00dd\u0088\u00ca\u0092ux\u0082\u00f0\u0089\u009d\u0095\u009c\u0082\u00b3\u0082\u00b9\u0082\u00e9 for(xl=0;xl<W-range;xl++){//\u008d\u00b6\u0092[ for(dx=0;dx<=range;dx++){//x\u0095\u00cf\u0088\u00ca xr=xl+range; x=d?xr-dx:xl+dx; //printf(\"range=%d, d=%d, xl=%d, dx=%d, xr=%d, x=%d\\n\",range,d,xl,dx,xr,x); for(o=m;o>0;o--){ if(f=DP[y][x][xl][xr][o]){ if(x>0){ if(x==xl){//\u008d\u00b6\u0082\u00d6\u008c@\u0082\u00e9 fn=CalcF(f,x-1,y); on=CalcO(o-1,x-1,y); Update(DP[y][x-1][x-1][xr][on],fn); }else{//\u008d\u00b6\u0082\u00d6\u0090i\u0082\u00de Update(DP[y][x-1][xl][xr][o-1],f); } } if(x<W-1){ if(x==xr){//\u0089E\u0082\u00d6\u008c@\u0082\u00e9 fn=CalcF(f,x+1,y);  //break; } }//o }//dx }//xl }//d }//range }//y #if 0 for(y=0;y<H;y++){ for(x=0;x<W;x++){ for(o=m;o>0;o--){ if(f=DP[y][x][x][x][o]){ printf(\"%4d \",f-1);  memset(DP,0,sizeof(DP)); } puts(\"\"); exit(0); }"], "original_ll": -1.3000727891921997, "sampled_ll": -0.4011501371860504, "all_perturbed_sampled_ll": [-1.373901605606079], "all_perturbed_original_ll": [-1.9825356006622314], "perturbed_sampled_ll": -1.373901605606079, "perturbed_original_ll": -1.9825356006622314, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n   \n   \npublic class Main {\n\tstatic int INF = 2 << 28;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tint f = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint o = sc.nextInt();\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][][] memo = new int[h][w][m+1];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tArrays.fill(memo[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Data> queue = new PriorityQueue<Data>();\n\t\t\tfor(int i = 0; i < w; i++) {\n\t\t\t\tboolean[] tmp = new boolean[w];\n\t\t\t\tif(map[0][i] > 0) {\n\t\t\t\t\tqueue.add(new Data(0,i,0,Math.min(m, o - 1 + map[0][i]),tmp));\n\t\t\t\t}\n\t\t\t\telse  {\n\t\t\t\t\tqueue.add(new Data(0,i,-map[0][i],o - 1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans = -1;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tData tmp = queue.poll();\n\t\t\t\t\n\t\t\t\tif(tmp.o <= 0) continue;\n\t\t\t\ttmp.al[tmp.x] = true;\n\t\t\t\t\n\t\t\t\tif(tmp.y == h-1) {\n\t\t\t\t\tans = tmp.c;\n\t\t\t\t\tqueue.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(tmp.c >= memo[tmp.y][tmp.x][tmp.o]) continue;\n\t\t\t\tmemo[tmp.y][tmp.x][tmp.o] = tmp.c;\n\t\t\t\t\n\t\t\t\tif(tmp.x != w-1) {\n\t\t\t\t\tif(tmp.al[tmp.x+1]) {\n\t\t\t\t\t\t    queue.add(new Data(tmp.y,tmp.x+1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(map[tmp.y][tmp.x+1] > 0 && tmp.o != 1) {\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x+1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x+1]),Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(map[tmp.y][tmp.x+1] < 0){\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x+1,tmp.c - map[tmp.y][tmp.x+1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp.x != 0) {\n\t\t\t\t\tif(tmp.al[tmp.x-1]) {\n\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x-1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(map[tmp.y][tmp.x-1] > 0 && tmp.o != 1) {\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x-1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x-1]),Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(map[tmp.y][tmp.x-1] < 0){\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x-1,tmp.c - map[tmp.y][tmp.x-1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp.y != h-1) {\n\t\t\t\t\tif(map[tmp.y+1][tmp.x] > 0 && tmp.o != 1) {\n\t\t\t\t\t\tqueue.add(new Data(tmp.y+1,tmp.x,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y+1][tmp.x]),new boolean[w]));\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[tmp.y+1][tmp.x] < 0){\n\t\t\t\t\t\tqueue.add(new Data(tmp.y+1,tmp.x,tmp.c - map[tmp.y+1][tmp.x],tmp.o-1,new boolean[w]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(ans == -1 || ans >= f) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic class Data implements Comparable<Data> {\n\t\tint y;\n\t\tint x;\n\t\tint c;\n\t\tint o;\n\t\tboolean[] al;\n\t\t\n\t\tData(int y, int x, int c, int o, boolean[] al) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.c = c;\n\t\t\tthis.o = o;\n\t\t\tthis.al = al;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.c - o.c;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class State implements Comparable<State> {\n        int x, y, oxygen, cost;\n        \n        State(int x, int y, int oxygen, int cost) {\n            this.x = x;\n            this.y = y;\n            this.oxygen = oxygen;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            int W = Integer.parseInt(parts[0]);\n            int H = Integer.parseInt(parts[1]);\n            \n            if (W == 0 && H == 0) break;\n            \n            parts = br.readLine().trim().split(\"\\\\s+\");\n            int f = Integer.parseInt(parts[0]);\n            int m = Integer.parseInt(parts[1]);\n            int o = Integer.parseInt(parts[2]);\n            \n            int[][] grid = new int[H][W];\n            for (int j = 0; j < H; j++) {\n                parts = br.readLine().trim().split(\"\\\\s+\");\n                for (int i = 0; i < W; i++) {\n                    grid[j][i] = Integer.parseInt(parts[i]);\n                }\n            }\n            \n            int result = solve(W, H, f, m, o, grid);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n    }\n    \n    static int solve(int W, int H, int f, int m, int o, int[][] grid) {\n        int[][][] dist = new int[H][W][m + 1];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                Arrays.fill(dist[i][j], Integer.MAX_VALUE);\n            }\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        \n        // Start from any cell in the first row\n        for (int x = 0; x < W; x++) {\n            int cost = 0;\n            int oxygen = o;\n            \n            if (grid[0][x] < 0) {\n                cost = -grid[0][x];\n            } else {\n                oxygen = Math.min(m, oxygen + grid[0][x]);\n            }\n            \n            if (cost <= f && oxygen > 0) {\n                pq.offer(new State(x, 0, oxygen, cost));\n                dist[0][x][oxygen] = cost;\n            }\n        }\n        \n        int[] dx = {-1, 1, 0};\n        int[] dy = {0, 0, 1};\n        \n        int minCost = Integer.MAX_VALUE;\n        \n        while (!pq.isEmpty()) {\n            State curr = pq.poll();\n            \n            if (curr.y == H - 1) {\n                minCost = Math.min(minCost, curr.cost);\n                continue;\n            }\n            \n            if (curr.cost > dist[curr.y][curr.x][curr.oxygen]) {\n                continue;\n            }\n            \n            for (int d = 0; d < 3; d++) {\n                int nx = curr.x + dx[d];\n                int ny = curr.y + dy[d];\n                \n                if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n                \n                int newOxygen = curr.oxygen - 1;\n                if (newOxygen <= 0) continue;\n                \n                int newCost = curr.cost;\n                \n                if (grid[ny][nx] < 0) {\n                    newCost += -grid[ny][nx];\n                } else {\n                    newOxygen = Math.min(m, newOxygen + grid[ny][nx]);\n                }\n                \n                if (newCost > f) continue;\n                \n                if (newCost < dist[ny][nx][newOxygen]) {\n                    dist[ny][nx][newOxygen] = newCost;\n                    pq.offer(new State(nx, ny, newOxygen, newCost));\n                }\n            }\n        }\n        \n        return minCost == Integer.MAX_VALUE ? -1 : minCost;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class  x, int y, int oxygen, int cost) { this.x = x; this.y = y; this.oxygen  other) { return Integer.compare(this.cost, other.cost); } } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] parts = line.trim().split(\"\\\\s+\"); int  o = Integer.parseInt(parts[2]); int[][] grid = new int[H][W]; for (int j  solve(W, H,  + 1]; for (int i = 0; i < H; i++) { for (int j = 0; j < W; j++) { Arrays.fill(dist[i][j], Integer.MAX_VALUE); } } PriorityQueue<State> pq = new PriorityQueue<>(); //  x = 0; x < W; x++) { int cost = 0; int oxygen = o; if (grid[0][x] < 0) { cost =  } if (cost <= f && oxygen > 0) { pq.offer(new State(x, 0, oxygen, cost)); dist[0][x][oxygen] = cost; } } int[] dx = {-1, 1, 0}; int[] dy = {0, 0, 1}; int minCost = Integer.MAX_VALUE; while (!pq.isEmpty()) { State curr = pq.poll(); if (curr.y == H  (curr.cost > dist[curr.y][curr.x][curr.oxygen]) { continue; } for (int d = 0;  0 || ny >= H)  0)  newCost += -grid[ny][nx]; } else { newOxygen = Math.min(m, newOxygen +  dist[ny][nx][newOxygen]) { dist[ny][nx][newOxygen] = newCost; pq.offer(new State(nx, ny, newOxygen, newCost)); } } } return minCost == Integer.MAX_VALUE ? -1 : minCost; } }"], "perturbed_original": [" Main { static int INF  Scanner sc = new Scanner(System.in);  if(w == 0 && h == 0) break; int f = sc.nextInt(); int  new int[h][w]; for(int i = 0; i < h; i++) { for(int j =  } int[][][] memo = new int[h][w][m+1]; for(int i = 0; i < h; i++) { for(int j = 0; j < w; j++) { Arrays.fill(memo[i][j], INF); } } PriorityQueue<Data> queue = new PriorityQueue<Data>();  -1; while(!queue.isEmpty()) { Data tmp = queue.poll(); if(tmp.o  ans = tmp.c;  if(tmp.x != w-1) { if(tmp.al[tmp.x+1]) { queue.add(new Data(tmp.y,tmp.x+1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length))); } else { if(map[tmp.y][tmp.x+1] >  1 + map[tmp.y][tmp.x+1]),Arrays.copyOf(tmp.al,tmp.al.length))); } else if(map[tmp.y][tmp.x+1] < 0){ queue.add(new Data(tmp.y,tmp.x+1,tmp.c - map[tmp.y][tmp.x+1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length))); } } } if(tmp.x != 0) { if(tmp.al[tmp.x-1]) { queue.add(new Data(tmp.y,tmp.x-1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length))); } else { if(map[tmp.y][tmp.x-1] > 0 && tmp.o != 1) { queue.add(new Data(tmp.y,tmp.x-1,tmp.c,Math.min(m, tmp.o  Data(tmp.y,tmp.x-1,tmp.c - map[tmp.y][tmp.x-1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length))); } } } if(tmp.y != h-1) { if(map[tmp.y+1][tmp.x] > 0 && tmp.o != 1) { queue.add(new Data(tmp.y+1,tmp.x,tmp.c,Math.min(m, tmp.o  queue.add(new Data(tmp.y+1,tmp.x,tmp.c - map[tmp.y+1][tmp.x],tmp.o-1,new boolean[w])); } } } if(ans  { System.out.println(ans); } } }  int c; int o; boolean[] al; Data(int y, int x, int c, int o, boolean[] al) { this.y = y; this.x  al;  o.c; } } }"], "original_ll": -0.4536621570587158, "sampled_ll": -0.33493444323539734, "all_perturbed_sampled_ll": [-1.4124177694320679], "all_perturbed_original_ll": [-1.1026082038879395], "perturbed_sampled_ll": -1.4124177694320679, "perturbed_original_ll": -1.1026082038879395, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "INF = 10 ** 20\n\ndef update_state(state, newx):\n  tmp = list(state)\n  tmp[newx] = 1\n  return tuple(tmp)\n\ndef get_co(x, y):\n  dc = do = 0\n  score = mp[y][x]\n  if score < 0:\n    dc = -score\n  else:\n    do = score\n  return dc, do\n\ndef minimum_cost(nowx, nowy, state, ox, goal, dic, w, m):\n  if (nowx, nowy, state, ox) in dic:\n    return dic[(nowx, nowy, state, ox)]\n  if nowy == goal:\n    return 0\n  if ox <= 1:\n    return INF\n  \n  ret = INF\n  \n  left = right = None\n  for i in range(nowx + 1, w):\n    if state[i] == 0:\n      right = i\n      break\n\n  for i in range(nowx - 1, -1, -1):\n    if state[i] == 0:\n      left = i\n      break\n\n  if left != None:\n    dc, do = get_co(left, nowy)\n    ret = min(ret, minimum_cost(left, nowy, update_state(state, left), min(ox + do - 1, m), goal, dic, w, m) + dc)\n    for i in range(left + 1, nowx):\n      ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic, w, m))\n  \n  if right != None:\n    dc, do = get_co(right, nowy)\n    ret = min(ret, minimum_cost(right, nowy, update_state(state, right), min(ox + do - 1, m), goal, dic, w, m) + dc)\n    for i in range(nowx + 1, right):\n      ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic, w, m))\n  \n  dc, do = get_co(nowx, nowy + 1)\n  ret = min(ret, minimum_cost(nowx, nowy + 1, tuple((1 if i == nowx else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m) + dc)\n  dic[(nowx, nowy, state, ox)] = ret\n  return ret\n\nwhile True:\n  w, h = map(int, input().split())\n  if w == 0:\n    break\n  f, m, o = map(int, input().split())\n  if o <= 1:\n    print(\"NA\")\n    continue\n  mp = [list(map(int, input().split())) for _ in range(h)]\n  dic = {}\n  ans = INF\n  for i in range(w):\n    dc, do = get_co(i, 0)\n    ans = min(ans, minimum_cost(i, 0, tuple(1 if i == j else 0 for j in range(w)), min(o + do - 1, m), h - 1, dic, w, m) + dc)\n  if ans > f:\n    print(\"NA\")\n  else:\n    print(ans)\n", "sampled": "import heapq\nfrom collections import defaultdict\n\ndef solve(W, H, f, m, o, grid):\n    # State: (x, y, oxygen, used_oxygen_cells)\n    # used_oxygen_cells is a frozenset of (x, y) tuples\n    \n    # Priority queue: (cost, x, y, oxygen, used_oxygen_cells)\n    pq = []\n    \n    # Start from any cell in the first row (y=0)\n    for x in range(W):\n        cell_value = grid[0][x]\n        if cell_value < 0:  #\u571f\n            cost = -cell_value\n            new_oxygen = o - 1\n            if new_oxygen >= 0 and cost <= f:\n                heapq.heappush(pq, (cost, x, 0, new_oxygen, frozenset()))\n        else:  # \u9178\u7d20\n            new_oxygen = min(m, o + cell_value) - 1\n            if new_oxygen >= 0:\n                heapq.heappush(pq, (0, x, 0, new_oxygen, frozenset([(x, 0)])))\n    \n    # Best cost for each state (x, y, oxygen, used_oxygen_cells)\n    visited = {}\n    \n    while pq:\n        cost, x, y, oxygen, used = heapq.heappop(pq)\n        \n        # Check if we reached the bottom\n        if y == H - 1 and oxygen > 0:\n            return cost\n        \n        # Skip if we've seen this state with better or equal cost\n        state = (x, y, oxygen, used)\n        if state in visited:\n            continue\n        visited[state] = cost\n        \n        # Try moving to adjacent cells: left, right, down\n        directions = []\n        if x > 0:\n            directions.append((x - 1, y))\n        if x < W - 1:\n            directions.append((x + 1, y))\n        if y < H - 1:\n            directions.append((x, y + 1))\n        \n        for nx, ny in directions:\n            cell_value = grid[ny][nx]\n            \n            if cell_value < 0:  # \u571f\n                dig_cost = -cell_value\n                new_cost = cost + dig_cost\n                new_oxygen = oxygen - 1\n                \n                if new_oxygen >= 0 and new_cost <= f:\n                    new_state = (nx, ny, new_oxygen, used)\n                    if new_state not in visited:\n                        heapq.heappush(pq, (new_cost, nx, ny, new_oxygen, used))\n            else:  # \u9178\u7d20\n                if (nx, ny) in used:\n                    # Already used this oxygen cell\n                    new_oxygen = oxygen - 1\n                    if new_oxygen >= 0:\n                        new_state = (nx, ny, new_oxygen, used)\n                        if new_state not in visited:\n                            heapq.heappush(pq, (cost, nx, ny, new_oxygen, used))\n                else:\n                    # Use oxygen from this cell\n                    new_oxygen = min(m, oxygen + cell_value) - 1\n                    if new_oxygen >= 0:\n                        new_used = used | frozenset([(nx, ny)])\n                        new_state = (nx, ny, new_oxygen, new_used)\n                        if new_state not in visited:\n                            heapq.heappush(pq, (cost, nx, ny, new_oxygen, new_used))\n    \n    return None\n\nwhile True:\n    line = input().split()\n    W, H = int(line[0]), int(line[1])\n    if W == 0 and H == 0:\n        break\n    \n    line = input().split()\n    f, m, o = int(line[0]), int(line[1]), int(line[2])\n    \n    grid = []\n    for _ in range(H):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    result = solve(W, H, f, m, o, grid)\n    if result is None:\n        print(\"NA\")\n    else:\n        print(result)\n", "perturbed_sampled": ["import heapq from collections import defaultdict def solve(W, H, f, m, o,  a frozenset of (x, y) tuples # Priority queue: (cost, x,  cell in the first row (y=0) for x in range(W): cell_value = grid[0][x] if cell_value < 0: #\u571f cost = -cell_value new_oxygen =  frozenset([(x, 0)]))) # Best cost  while pq: cost, x, y, oxygen,  0: return cost # Skip if we've seen this state with better or equal cost state  left, right, down directions = [] if x > 0: directions.append((x - 1, y)) if x < W - 1: directions.append((x + 1, y)) if y < H - 1: directions.append((x, y  if cell_value < 0: # \u571f dig_cost = -cell_value new_cost = cost + dig_cost new_oxygen = oxygen -   if (nx,  = (nx, ny, new_oxygen, used) if new_state not in visited: heapq.heappush(pq, (cost, nx, ny, new_oxygen, used)) else: # Use oxygen from this cell new_oxygen = min(m, oxygen + cell_value) - 1 if new_oxygen >= 0: new_used = used | frozenset([(nx, ny)]) new_state = (nx, ny, new_oxygen, new_used)  new_used)) return None while True: line = input().split() W, H  0: break line = input().split() f, m, o = int(line[0]),  = list(map(int, input().split())) grid.append(row) result = solve(W, H, f, m, o, grid) if result is None: print(\"NA\") else: print(result)"], "perturbed_original": ["INF = 10 ** 20 def update_state(state, newx):  y): dc = do = 0 score = mp[y][x]  goal, dic, w, m): if (nowx, nowy, state, ox) in dic: return dic[(nowx, nowy, state, ox)] if nowy == goal: return 0 if ox <= 1: return INF ret = INF left = right = None for  i break if left !=  nowy, update_state(state,  m) + dc) for i in range(left + 1,   right), min(ox + do -  in range(nowx + 1, right): ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic, w, m)) dc, do = get_co(nowx, nowy + 1) ret = min(ret, minimum_cost(nowx, nowy + 1, tuple((1 if  + do - 1, m), goal, dic, w, m) + dc) dic[(nowx, nowy, state, ox)] = ret  w == 0: break f, m, o = map(int, input().split())  for _ in range(h)] dic = {} ans = INF for i in range(w): dc, do = get_co(i, 0) ans = min(ans, minimum_cost(i, 0, tuple(1 if i == j else 0  h - 1, dic, w, m) + dc) if ans > f: print(\"NA\") else: print(ans)"], "original_ll": -0.7175218462944031, "sampled_ll": -0.6071824431419373, "all_perturbed_sampled_ll": [-2.050480365753174], "all_perturbed_original_ll": [-2.322676181793213], "perturbed_sampled_ll": -2.050480365753174, "perturbed_original_ll": -2.322676181793213, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}], "metrics": {"roc_auc": 0.6871083333333333, "fpr": [0.0, 0.0016666666666666668, 0.0033333333333333335, 0.0033333333333333335, 0.005, 0.005, 0.006666666666666667, 0.006666666666666667, 0.01, 0.01, 0.011666666666666667, 0.011666666666666667, 0.013333333333333334, 0.013333333333333334, 0.015, 0.015, 0.016666666666666666, 0.016666666666666666, 0.018333333333333333, 0.018333333333333333, 0.02, 0.02, 0.03, 0.03, 0.03166666666666667, 0.03166666666666667, 0.03333333333333333, 0.03333333333333333, 0.03833333333333333, 0.03833333333333333, 0.04, 0.04, 0.041666666666666664, 0.041666666666666664, 0.043333333333333335, 0.043333333333333335, 0.045, 0.045, 0.04833333333333333, 0.04833333333333333, 0.05, 0.05, 0.05333333333333334, 0.05333333333333334, 0.056666666666666664, 0.056666666666666664, 0.058333333333333334, 0.058333333333333334, 0.065, 0.065, 0.06666666666666667, 0.06666666666666667, 0.06833333333333333, 0.06833333333333333, 0.07166666666666667, 0.07166666666666667, 0.07333333333333333, 0.07333333333333333, 0.075, 0.075, 0.07666666666666666, 0.07666666666666666, 0.08, 0.08, 0.08166666666666667, 0.08166666666666667, 0.08333333333333333, 0.08333333333333333, 0.085, 0.085, 0.08833333333333333, 0.08833333333333333, 0.09166666666666666, 0.09166666666666666, 0.09333333333333334, 0.09333333333333334, 0.095, 0.095, 0.09666666666666666, 0.09666666666666666, 0.09833333333333333, 0.09833333333333333, 0.1, 0.1, 0.10166666666666667, 0.10166666666666667, 0.10333333333333333, 0.10333333333333333, 0.105, 0.105, 0.10666666666666667, 0.10666666666666667, 0.10833333333333334, 0.10833333333333334, 0.11, 0.11, 0.11166666666666666, 0.11166666666666666, 0.11333333333333333, 0.11333333333333333, 0.115, 0.115, 0.11666666666666667, 0.11666666666666667, 0.12, 0.12, 0.12166666666666667, 0.12166666666666667, 0.12333333333333334, 0.12333333333333334, 0.12666666666666668, 0.12666666666666668, 0.13, 0.13, 0.13333333333333333, 0.13333333333333333, 0.13666666666666666, 0.13666666666666666, 0.13833333333333334, 0.13833333333333334, 0.14166666666666666, 0.14166666666666666, 0.145, 0.145, 0.14833333333333334, 0.14833333333333334, 0.15166666666666667, 0.15166666666666667, 0.15333333333333332, 0.15333333333333332, 0.15666666666666668, 0.15666666666666668, 0.16, 0.16, 0.16333333333333333, 0.16333333333333333, 0.165, 0.165, 0.16666666666666666, 0.16666666666666666, 0.16833333333333333, 0.16833333333333333, 0.17, 0.17, 0.17166666666666666, 0.17166666666666666, 0.17333333333333334, 0.17333333333333334, 0.175, 0.175, 0.17666666666666667, 0.17666666666666667, 0.18, 0.18, 0.18166666666666667, 0.18166666666666667, 0.18333333333333332, 0.18333333333333332, 0.18666666666666668, 0.18666666666666668, 0.18833333333333332, 0.18833333333333332, 0.19166666666666668, 0.19166666666666668, 0.195, 0.195, 0.19666666666666666, 0.19666666666666666, 0.19833333333333333, 0.19833333333333333, 0.20166666666666666, 0.20166666666666666, 0.20666666666666667, 0.20666666666666667, 0.21833333333333332, 0.21833333333333332, 0.22166666666666668, 0.22166666666666668, 0.22333333333333333, 0.22333333333333333, 0.225, 0.225, 0.22666666666666666, 0.22666666666666666, 0.22833333333333333, 0.22833333333333333, 0.23, 0.23, 0.23166666666666666, 0.23166666666666666, 0.23333333333333334, 0.23333333333333334, 0.23833333333333334, 0.23833333333333334, 0.24333333333333335, 0.24333333333333335, 0.24666666666666667, 0.24666666666666667, 0.24833333333333332, 0.24833333333333332, 0.25, 0.25, 0.25166666666666665, 0.25166666666666665, 0.25333333333333335, 0.25333333333333335, 0.25666666666666665, 0.25666666666666665, 0.26166666666666666, 0.26166666666666666, 0.2633333333333333, 0.2633333333333333, 0.26666666666666666, 0.26666666666666666, 0.27, 0.27, 0.27166666666666667, 0.27166666666666667, 0.2733333333333333, 0.2733333333333333, 0.275, 0.275, 0.28, 0.28, 0.28833333333333333, 0.28833333333333333, 0.29, 0.29, 0.2916666666666667, 0.2916666666666667, 0.2966666666666667, 0.2966666666666667, 0.3, 0.3, 0.3016666666666667, 0.3016666666666667, 0.305, 0.305, 0.30666666666666664, 0.30666666666666664, 0.30833333333333335, 0.30833333333333335, 0.31166666666666665, 0.31166666666666665, 0.31333333333333335, 0.31333333333333335, 0.315, 0.315, 0.31833333333333336, 0.31833333333333336, 0.32166666666666666, 0.32166666666666666, 0.32666666666666666, 0.32666666666666666, 0.3283333333333333, 0.3283333333333333, 0.33, 0.33, 0.33166666666666667, 0.33166666666666667, 0.33666666666666667, 0.33666666666666667, 0.3383333333333333, 0.3383333333333333, 0.3416666666666667, 0.3416666666666667, 0.3433333333333333, 0.3433333333333333, 0.345, 0.345, 0.3466666666666667, 0.3466666666666667, 0.3516666666666667, 0.3516666666666667, 0.355, 0.355, 0.3566666666666667, 0.3566666666666667, 0.36, 0.36, 0.36333333333333334, 0.36333333333333334, 0.365, 0.365, 0.36666666666666664, 0.36666666666666664, 0.37, 0.37, 0.37166666666666665, 0.37166666666666665, 0.37666666666666665, 0.37666666666666665, 0.37833333333333335, 0.37833333333333335, 0.38, 0.38, 0.38166666666666665, 0.38166666666666665, 0.385, 0.385, 0.39, 0.39, 0.39166666666666666, 0.39166666666666666, 0.3933333333333333, 0.3933333333333333, 0.395, 0.395, 0.39666666666666667, 0.39666666666666667, 0.3983333333333333, 0.3983333333333333, 0.4, 0.4, 0.405, 0.405, 0.41, 0.41, 0.4116666666666667, 0.4116666666666667, 0.41333333333333333, 0.41333333333333333, 0.41833333333333333, 0.41833333333333333, 0.42, 0.42, 0.42333333333333334, 0.42333333333333334, 0.4266666666666667, 0.4266666666666667, 0.43166666666666664, 0.43166666666666664, 0.43333333333333335, 0.43333333333333335, 0.43666666666666665, 0.43666666666666665, 0.44, 0.44, 0.44166666666666665, 0.44166666666666665, 0.44333333333333336, 0.44333333333333336, 0.445, 0.445, 0.45166666666666666, 0.45166666666666666, 0.4533333333333333, 0.4533333333333333, 0.46, 0.46, 0.465, 0.465, 0.4666666666666667, 0.4666666666666667, 0.4683333333333333, 0.4683333333333333, 0.47, 0.47, 0.4766666666666667, 0.4766666666666667, 0.47833333333333333, 0.47833333333333333, 0.48833333333333334, 0.48833333333333334, 0.49, 0.49, 0.49333333333333335, 0.49333333333333335, 0.495, 0.495, 0.49666666666666665, 0.49666666666666665, 0.49833333333333335, 0.49833333333333335, 0.5, 0.5, 0.5033333333333333, 0.5033333333333333, 0.505, 0.505, 0.5066666666666667, 0.5066666666666667, 0.5083333333333333, 0.5083333333333333, 0.51, 0.51, 0.5116666666666667, 0.5116666666666667, 0.5183333333333333, 0.5183333333333333, 0.52, 0.52, 0.5216666666666666, 0.5216666666666666, 0.5283333333333333, 0.5283333333333333, 0.53, 0.53, 0.535, 0.535, 0.5433333333333333, 0.5433333333333333, 0.5533333333333333, 0.5533333333333333, 0.555, 0.555, 0.5616666666666666, 0.5616666666666666, 0.5783333333333334, 0.5783333333333334, 0.5816666666666667, 0.5816666666666667, 0.5833333333333334, 0.5833333333333334, 0.5883333333333334, 0.5883333333333334, 0.59, 0.59, 0.595, 0.595, 0.5966666666666667, 0.5966666666666667, 0.6016666666666667, 0.6016666666666667, 0.6066666666666667, 0.6066666666666667, 0.6083333333333333, 0.6083333333333333, 0.6116666666666667, 0.6116666666666667, 0.625, 0.625, 0.6333333333333333, 0.6333333333333333, 0.64, 0.64, 0.6416666666666667, 0.6416666666666667, 0.6466666666666666, 0.6466666666666666, 0.655, 0.655, 0.6566666666666666, 0.6566666666666666, 0.6616666666666666, 0.6616666666666666, 0.6766666666666666, 0.6766666666666666, 0.6783333333333333, 0.6783333333333333, 0.68, 0.68, 0.6866666666666666, 0.6866666666666666, 0.69, 0.69, 0.6933333333333334, 0.6933333333333334, 0.695, 0.695, 0.7, 0.7, 0.7016666666666667, 0.7016666666666667, 0.7033333333333334, 0.7033333333333334, 0.7133333333333334, 0.7133333333333334, 0.715, 0.715, 0.7266666666666667, 0.7266666666666667, 0.73, 0.73, 0.735, 0.735, 0.74, 0.74, 0.75, 0.75, 0.7533333333333333, 0.7533333333333333, 0.7566666666666667, 0.7566666666666667, 0.7616666666666667, 0.7616666666666667, 0.7733333333333333, 0.7733333333333333, 0.7816666666666666, 0.7816666666666666, 0.7983333333333333, 0.7983333333333333, 0.8016666666666666, 0.8016666666666666, 0.8066666666666666, 0.8066666666666666, 0.8116666666666666, 0.8116666666666666, 0.8316666666666667, 0.8316666666666667, 0.845, 0.845, 0.8466666666666667, 0.8466666666666667, 0.8566666666666667, 0.8566666666666667, 0.86, 0.86, 0.8766666666666667, 0.8766666666666667, 0.9216666666666666, 0.9216666666666666, 0.93, 0.93, 0.95, 0.9883333333333333, 0.9983333333333333, 0.9983333333333333, 1.0], "tpr": [0.0, 0.0, 0.0, 0.0016666666666666668, 0.0016666666666666668, 0.0033333333333333335, 0.0033333333333333335, 0.006666666666666667, 0.006666666666666667, 0.01, 0.01, 0.015, 0.015, 0.016666666666666666, 0.016666666666666666, 0.02, 0.02, 0.03, 0.03, 0.04, 0.04, 0.041666666666666664, 0.041666666666666664, 0.045, 0.045, 0.05, 0.05, 0.051666666666666666, 0.051666666666666666, 0.05333333333333334, 0.05333333333333334, 0.055, 0.055, 0.058333333333333334, 0.058333333333333334, 0.06, 0.06, 0.06666666666666667, 0.06666666666666667, 0.06833333333333333, 0.06833333333333333, 0.07, 0.07, 0.07333333333333333, 0.07333333333333333, 0.07833333333333334, 0.07833333333333334, 0.08333333333333333, 0.08333333333333333, 0.09166666666666666, 0.09166666666666666, 0.095, 0.095, 0.09666666666666666, 0.09666666666666666, 0.1, 0.1, 0.10166666666666667, 0.10166666666666667, 0.10666666666666667, 0.10666666666666667, 0.11166666666666666, 0.11166666666666666, 0.11666666666666667, 0.11666666666666667, 0.12333333333333334, 0.12333333333333334, 0.13833333333333334, 0.13833333333333334, 0.145, 0.145, 0.15333333333333332, 0.15333333333333332, 0.155, 0.155, 0.15666666666666668, 0.15666666666666668, 0.16333333333333333, 0.16333333333333333, 0.16833333333333333, 0.16833333333333333, 0.17166666666666666, 0.17166666666666666, 0.175, 0.175, 0.17666666666666667, 0.17666666666666667, 0.195, 0.195, 0.2, 0.2, 0.20833333333333334, 0.20833333333333334, 0.22, 0.22, 0.22166666666666668, 0.22166666666666668, 0.22333333333333333, 0.22333333333333333, 0.225, 0.225, 0.22833333333333333, 0.22833333333333333, 0.23166666666666666, 0.23166666666666666, 0.235, 0.235, 0.23666666666666666, 0.23666666666666666, 0.24, 0.24, 0.24666666666666667, 0.24666666666666667, 0.24833333333333332, 0.24833333333333332, 0.25, 0.25, 0.25333333333333335, 0.25333333333333335, 0.25666666666666665, 0.25666666666666665, 0.26166666666666666, 0.26166666666666666, 0.265, 0.265, 0.2683333333333333, 0.2683333333333333, 0.27166666666666667, 0.27166666666666667, 0.2733333333333333, 0.2733333333333333, 0.275, 0.275, 0.2866666666666667, 0.2866666666666667, 0.3016666666666667, 0.3016666666666667, 0.30666666666666664, 0.30666666666666664, 0.31333333333333335, 0.31333333333333335, 0.325, 0.325, 0.32666666666666666, 0.32666666666666666, 0.3383333333333333, 0.3383333333333333, 0.3416666666666667, 0.3416666666666667, 0.3433333333333333, 0.3433333333333333, 0.3516666666666667, 0.3516666666666667, 0.35833333333333334, 0.35833333333333334, 0.36, 0.36, 0.36833333333333335, 0.36833333333333335, 0.37, 0.37, 0.375, 0.375, 0.37833333333333335, 0.37833333333333335, 0.38333333333333336, 0.38333333333333336, 0.39, 0.39, 0.3983333333333333, 0.3983333333333333, 0.4, 0.4, 0.40166666666666667, 0.40166666666666667, 0.4033333333333333, 0.4033333333333333, 0.405, 0.405, 0.41, 0.41, 0.4116666666666667, 0.4116666666666667, 0.415, 0.415, 0.41833333333333333, 0.41833333333333333, 0.4216666666666667, 0.4216666666666667, 0.4266666666666667, 0.4266666666666667, 0.43333333333333335, 0.43333333333333335, 0.43666666666666665, 0.43666666666666665, 0.43833333333333335, 0.43833333333333335, 0.44, 0.44, 0.44166666666666665, 0.44166666666666665, 0.44333333333333336, 0.44333333333333336, 0.445, 0.445, 0.4483333333333333, 0.4483333333333333, 0.45666666666666667, 0.45666666666666667, 0.46, 0.46, 0.4633333333333333, 0.4633333333333333, 0.4666666666666667, 0.4666666666666667, 0.4683333333333333, 0.4683333333333333, 0.48, 0.48, 0.48333333333333334, 0.48333333333333334, 0.48833333333333334, 0.48833333333333334, 0.49333333333333335, 0.49333333333333335, 0.495, 0.495, 0.49833333333333335, 0.49833333333333335, 0.5016666666666667, 0.5016666666666667, 0.505, 0.505, 0.51, 0.51, 0.5116666666666667, 0.5116666666666667, 0.515, 0.515, 0.525, 0.525, 0.5316666666666666, 0.5316666666666666, 0.5333333333333333, 0.5333333333333333, 0.5383333333333333, 0.5383333333333333, 0.545, 0.545, 0.5533333333333333, 0.5533333333333333, 0.5616666666666666, 0.5616666666666666, 0.575, 0.575, 0.5783333333333334, 0.5783333333333334, 0.5816666666666667, 0.5816666666666667, 0.585, 0.585, 0.5883333333333334, 0.5883333333333334, 0.5933333333333334, 0.5933333333333334, 0.5983333333333334, 0.5983333333333334, 0.6066666666666667, 0.6066666666666667, 0.61, 0.61, 0.6133333333333333, 0.6133333333333333, 0.6166666666666667, 0.6166666666666667, 0.6216666666666667, 0.6216666666666667, 0.6233333333333333, 0.6233333333333333, 0.625, 0.625, 0.6333333333333333, 0.6333333333333333, 0.645, 0.645, 0.6466666666666666, 0.6466666666666666, 0.6483333333333333, 0.6483333333333333, 0.6516666666666666, 0.6516666666666666, 0.6583333333333333, 0.6583333333333333, 0.66, 0.66, 0.6633333333333333, 0.6633333333333333, 0.6666666666666666, 0.6666666666666666, 0.6683333333333333, 0.6683333333333333, 0.67, 0.67, 0.6716666666666666, 0.6716666666666666, 0.675, 0.675, 0.6833333333333333, 0.6833333333333333, 0.685, 0.685, 0.6866666666666666, 0.6866666666666666, 0.69, 0.69, 0.6933333333333334, 0.6933333333333334, 0.6983333333333334, 0.6983333333333334, 0.7033333333333334, 0.7033333333333334, 0.7083333333333334, 0.7083333333333334, 0.7116666666666667, 0.7116666666666667, 0.7133333333333334, 0.7133333333333334, 0.7183333333333334, 0.7183333333333334, 0.725, 0.725, 0.7283333333333334, 0.7283333333333334, 0.73, 0.73, 0.7366666666666667, 0.7366666666666667, 0.7383333333333333, 0.7383333333333333, 0.7466666666666667, 0.7466666666666667, 0.7483333333333333, 0.7483333333333333, 0.75, 0.75, 0.7516666666666667, 0.7516666666666667, 0.7616666666666667, 0.7616666666666667, 0.765, 0.765, 0.7666666666666667, 0.7666666666666667, 0.77, 0.77, 0.7716666666666666, 0.7716666666666666, 0.775, 0.775, 0.7766666666666666, 0.7766666666666666, 0.7816666666666666, 0.7816666666666666, 0.7833333333333333, 0.7833333333333333, 0.785, 0.785, 0.7866666666666666, 0.7866666666666666, 0.7883333333333333, 0.7883333333333333, 0.79, 0.79, 0.7916666666666666, 0.7916666666666666, 0.7983333333333333, 0.7983333333333333, 0.8016666666666666, 0.8016666666666666, 0.805, 0.805, 0.81, 0.81, 0.8116666666666666, 0.8116666666666666, 0.815, 0.815, 0.8166666666666667, 0.8166666666666667, 0.8216666666666667, 0.8216666666666667, 0.8283333333333334, 0.8283333333333334, 0.83, 0.83, 0.835, 0.835, 0.8366666666666667, 0.8366666666666667, 0.8383333333333334, 0.8383333333333334, 0.845, 0.845, 0.85, 0.85, 0.8533333333333334, 0.8533333333333334, 0.8566666666666667, 0.8566666666666667, 0.86, 0.86, 0.8616666666666667, 0.8616666666666667, 0.875, 0.875, 0.8766666666666667, 0.8766666666666667, 0.8833333333333333, 0.8833333333333333, 0.885, 0.885, 0.8866666666666667, 0.8866666666666667, 0.89, 0.89, 0.8966666666666666, 0.8966666666666666, 0.8983333333333333, 0.8983333333333333, 0.9, 0.9, 0.9033333333333333, 0.9033333333333333, 0.905, 0.905, 0.91, 0.91, 0.9133333333333333, 0.9133333333333333, 0.9183333333333333, 0.9183333333333333, 0.92, 0.92, 0.9216666666666666, 0.9216666666666666, 0.9266666666666666, 0.9266666666666666, 0.9283333333333333, 0.9283333333333333, 0.93, 0.93, 0.9316666666666666, 0.9316666666666666, 0.9333333333333333, 0.9333333333333333, 0.9366666666666666, 0.9366666666666666, 0.9383333333333334, 0.9383333333333334, 0.94, 0.94, 0.9416666666666667, 0.9416666666666667, 0.945, 0.945, 0.9483333333333334, 0.9483333333333334, 0.95, 0.95, 0.9533333333333334, 0.9533333333333334, 0.955, 0.955, 0.9566666666666667, 0.9566666666666667, 0.9583333333333334, 0.9583333333333334, 0.96, 0.96, 0.9616666666666667, 0.9616666666666667, 0.965, 0.965, 0.9666666666666667, 0.9666666666666667, 0.9716666666666667, 0.9716666666666667, 0.975, 0.975, 0.9766666666666667, 0.9766666666666667, 0.9783333333333334, 0.9783333333333334, 0.98, 0.98, 0.9833333333333333, 0.9833333333333333, 0.985, 0.985, 0.9866666666666667, 0.9866666666666667, 0.9883333333333333, 0.9883333333333333, 0.99, 0.99, 0.9916666666666667, 0.9916666666666667, 0.9933333333333333, 0.9933333333333333, 0.995, 0.995, 0.9966666666666667, 0.9966666666666667, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 1.0, 1.0]}, "pr_metrics": {"pr_auc": 0.6200324346413195, "precision": [0.5, 0.5004170141784821, 0.5, 0.5004177109440268, 0.5008361204013378, 0.501255230125523, 0.501675041876047, 0.5020955574182733, 0.50251677852349, 0.5124037639007699, 0.5128424657534246, 0.5132819194515853, 0.5137221269296741, 0.5141630901287554, 0.5146048109965635, 0.5150472914875323, 0.5154905335628227, 0.5159345391903531, 0.5163793103448275, 0.5168248490077653, 0.5172711571675302, 0.5177182368193605, 0.5173010380622838, 0.5177489177489177, 0.5181975736568457, 0.5186470078057241, 0.5190972222222222, 0.5195482189400521, 0.5191304347826087, 0.5195822454308094, 0.5200348432055749, 0.5204882301656495, 0.5209424083769634, 0.5213973799126638, 0.5218531468531469, 0.5223097112860893, 0.5227670753064798, 0.523225241016652, 0.5236842105263158, 0.52414398595259, 0.5246045694200352, 0.525065963060686, 0.5255281690140845, 0.5259911894273128, 0.5264550264550265, 0.526919682259488, 0.5273851590106007, 0.5278514588859416, 0.5283185840707965, 0.5287865367581931, 0.5292553191489362, 0.5297249334516415, 0.5301953818827708, 0.5306666666666666, 0.5311387900355872, 0.5316117542297417, 0.5311942959001783, 0.5316681534344335, 0.5321428571428571, 0.5326184092940125, 0.5330948121645797, 0.5335720680393913, 0.5340501792114696, 0.5345291479820627, 0.5350089766606823, 0.5354896675651393, 0.5359712230215827, 0.5355535553555355, 0.536036036036036, 0.5365193868349865, 0.5361010830324909, 0.5365853658536586, 0.5370705244122965, 0.5375565610859728, 0.5380434782608695, 0.5385312783318223, 0.5390199637023594, 0.5386012715712988, 0.5390909090909091, 0.5386715195632393, 0.5391621129326047, 0.5396536007292616, 0.5401459854014599, 0.5406392694063927, 0.5411334552102377, 0.5416285452881976, 0.5421245421245421, 0.5426214482126489, 0.5422018348623853, 0.5426997245179064, 0.5431985294117647, 0.5436982520699172, 0.5441988950276243, 0.5447004608294931, 0.5452029520295203, 0.5457063711911357, 0.5462107208872459, 0.5467160037002775, 0.5472222222222223, 0.5477293790546802, 0.5482374768089053, 0.5478180129990715, 0.5483271375464684, 0.5488372093023256, 0.5493482309124768, 0.548928238583411, 0.5485074626865671, 0.5490196078431373, 0.5495327102803739, 0.5500467726847521, 0.549625468164794, 0.5501405810684161, 0.550656660412758, 0.5502347417840375, 0.5507518796992481, 0.5512699905926622, 0.551789077212806, 0.5523091423185674, 0.5528301886792453, 0.5533522190745986, 0.553875236294896, 0.554399243140965, 0.5549242424242424, 0.5554502369668246, 0.5550284629981025, 0.5555555555555556, 0.5560836501901141, 0.5566127497621313, 0.5571428571428572, 0.55767397521449, 0.5572519083969466, 0.556829035339064, 0.5573613766730402, 0.5578947368421052, 0.5584291187739464, 0.5589645254074784, 0.5595009596928983, 0.5600384245917387, 0.5605769230769231, 0.5601539942252165, 0.5597302504816956, 0.5593056894889104, 0.5598455598455598, 0.5603864734299517, 0.5609284332688588, 0.5605033881897387, 0.561046511627907, 0.5615906886517944, 0.5611650485436893, 0.5607385811467445, 0.561284046692607, 0.5618305744888024, 0.5614035087719298, 0.5619512195121952, 0.5625, 0.5630498533724341, 0.5636007827788649, 0.564152791380999, 0.5647058823529412, 0.5642787046123651, 0.5648330058939096, 0.5653883972468043, 0.5659448818897638, 0.5655172413793104, 0.5660749506903353, 0.5666337611056268, 0.567193675889328, 0.5667655786350149, 0.5673267326732673, 0.5678889990089198, 0.5674603174603174, 0.5680238331678252, 0.5685884691848907, 0.5691542288557214, 0.5697211155378487, 0.5702891326021934, 0.5708582834331337, 0.5714285714285714, 0.571, 0.5705705705705706, 0.5711422845691383, 0.5707121364092277, 0.571285140562249, 0.5718592964824121, 0.5724346076458753, 0.5730110775427996, 0.5735887096774194, 0.574167507568113, 0.5737373737373738, 0.5733063700707786, 0.5738866396761133, 0.5734549138804458, 0.5730223123732252, 0.5736040609137056, 0.573170731707317, 0.5737538148524923, 0.5743380855397149, 0.5749235474006116, 0.5744897959183674, 0.575076608784474, 0.5746421267893661, 0.5752302968270215, 0.5758196721311475, 0.5753846153846154, 0.5749486652977412, 0.5755395683453237, 0.5761316872427984, 0.5756951596292482, 0.5762886597938144, 0.5768833849329206, 0.5774793388429752, 0.578076525336091, 0.577639751552795, 0.5782383419689119, 0.5778008298755186, 0.5784008307372793, 0.577962577962578, 0.578563995837669, 0.5791666666666667, 0.5797705943691345, 0.5803757828810021, 0.58098223615465, 0.5815899581589958, 0.5821989528795811, 0.5828092243186582, 0.583420776495278, 0.582983193277311, 0.5825446898002103, 0.5821052631578948, 0.5827186512118019, 0.5833333333333334, 0.5839493136219641, 0.5835095137420718, 0.5841269841269842, 0.5836864406779662, 0.584305408271474, 0.5849256900212314, 0.5855472901168969, 0.5861702127659575, 0.5867944621938233, 0.5863539445628998, 0.5859124866595518, 0.5854700854700855, 0.586096256684492, 0.5867237687366167, 0.587352625937835, 0.5869098712446352, 0.5864661654135338, 0.5870967741935483, 0.5866523143164694, 0.5862068965517241, 0.5857605177993528, 0.5863930885529157, 0.587027027027027, 0.5876623376623377, 0.5882990249187432, 0.5878524945770065, 0.5884907709011944, 0.5891304347826087, 0.5897714907508161, 0.5904139433551199, 0.5910577971646674, 0.5906113537117904, 0.5901639344262295, 0.5908096280087527, 0.5914567360350493, 0.5921052631578947, 0.5927552140504939, 0.5934065934065934, 0.594059405940594, 0.5947136563876652, 0.5953693495038589, 0.5949227373068433, 0.5955801104972376, 0.5962389380530974, 0.5957918050941307, 0.5964523281596452, 0.5960044395116537, 0.5955555555555555, 0.5951056729699666, 0.5946547884187082, 0.5953177257525084, 0.5959821428571429, 0.5966480446927375, 0.5961968680089486, 0.5957446808510638, 0.5964125560538116, 0.5970819304152637, 0.597752808988764, 0.5973003374578177, 0.597972972972973, 0.5975197294250282, 0.5981941309255079, 0.5988700564971752, 0.5995475113122172, 0.5990939977349944, 0.5986394557823129, 0.5981838819523269, 0.5977272727272728, 0.5984072810011376, 0.5979498861047836, 0.5986316989737742, 0.5993150684931506, 0.6, 0.5995423340961098, 0.5990836197021764, 0.5986238532110092, 0.5981630309988519, 0.5977011494252874, 0.5972382048331415, 0.5967741935483871, 0.5963091118800461, 0.5969976905311778, 0.5965317919075145, 0.5972222222222222, 0.5979142526071842, 0.5974477958236659, 0.5969802555168409, 0.5976744186046512, 0.5983701979045402, 0.5990675990675991, 0.5997666277712952, 0.6004672897196262, 0.6011695906432749, 0.6018735362997658, 0.6025791324736225, 0.6032863849765259, 0.6039952996474736, 0.6035294117647059, 0.6030624263839811, 0.6037735849056604, 0.6044864226682408, 0.6052009456264775, 0.6059171597633136, 0.6054502369668247, 0.604982206405694, 0.6057007125890737, 0.6052318668252081, 0.6047619047619047, 0.6042908224076281, 0.6050119331742243, 0.6057347670250897, 0.6064593301435407, 0.6071856287425149, 0.6079136690647482, 0.6086434573829532, 0.6081730769230769, 0.6077015643802648, 0.6072289156626506, 0.6067551266586249, 0.607487922705314, 0.6082224909310762, 0.6089588377723971, 0.6096969696969697, 0.6104368932038835, 0.6099635479951397, 0.610705596107056, 0.6114494518879415, 0.6121951219512195, 0.6117216117216118, 0.6124694376528117, 0.6119951040391677, 0.6115196078431373, 0.6110429447852761, 0.6117936117936118, 0.6125461254612546, 0.6133004926108374, 0.6140567200986436, 0.6135802469135803, 0.6143386897404203, 0.6138613861386139, 0.6133828996282528, 0.6129032258064516, 0.6124223602484472, 0.6131840796019901, 0.6127023661270237, 0.6122194513715711, 0.6117353308364545, 0.6125, 0.6132665832290363, 0.6140350877192983, 0.6148055207026348, 0.614321608040201, 0.6150943396226415, 0.6146095717884131, 0.6141235813366961, 0.61489898989899, 0.6144121365360303, 0.6151898734177215, 0.614702154626109, 0.6142131979695431, 0.613722998729352, 0.6145038167938931, 0.6140127388535032, 0.6135204081632653, 0.6143039591315453, 0.6138107416879796, 0.6133162612035852, 0.6141025641025641, 0.6148908857509627, 0.6143958868894601, 0.6138996138996139, 0.6134020618556701, 0.6129032258064516, 0.6136950904392765, 0.6131953428201811, 0.6139896373056994, 0.6134889753566797, 0.6142857142857143, 0.6137841352405722, 0.6145833333333334, 0.6140808344198174, 0.6148825065274152, 0.615686274509804, 0.6151832460732984, 0.6159895150720839, 0.615485564304462, 0.6162943495400789, 0.6171052631578947, 0.6179183135704874, 0.6187335092348285, 0.619550858652576, 0.6203703703703703, 0.6198675496688741, 0.6193633952254642, 0.6188579017264276, 0.6196808510638298, 0.6191744340878829, 0.62, 0.6208277703604806, 0.6216577540106952, 0.6224899598393574, 0.6219839142091153, 0.6214765100671141, 0.6223118279569892, 0.6218034993270525, 0.6226415094339622, 0.6221322537112011, 0.6216216216216216, 0.6224627875507442, 0.6219512195121951, 0.6227951153324288, 0.623641304347826, 0.6244897959183674, 0.6239782016348774, 0.6234652114597544, 0.6243169398907104, 0.625170998632011, 0.626027397260274, 0.6268861454046639, 0.6263736263736264, 0.6258596973865199, 0.6253443526170799, 0.6248275862068966, 0.6243093922651933, 0.623789764868603, 0.6246537396121884, 0.624133148404993, 0.625, 0.6258692628650904, 0.6267409470752089, 0.6276150627615062, 0.6270949720670391, 0.627972027972028, 0.6274509803921569, 0.6283309957924264, 0.6278089887640449, 0.6272855133614628, 0.6267605633802817, 0.6262341325811002, 0.6257062146892656, 0.6265912305516266, 0.6260623229461756, 0.6269503546099291, 0.6278409090909091, 0.6273115220483642, 0.6267806267806267, 0.6262482168330956, 0.6257142857142857, 0.6266094420600858, 0.6275071633237822, 0.6269727403156384, 0.6278735632183908, 0.6273381294964029, 0.6268011527377522, 0.6277056277056277, 0.6286127167630058, 0.6295224312590448, 0.6289855072463768, 0.6284470246734397, 0.627906976744186, 0.6273653566229985, 0.6282798833819242, 0.6291970802919709, 0.6286549707602339, 0.6281112737920937, 0.6275659824046921, 0.6284875183553598, 0.6294117647058823, 0.6288659793814433, 0.6297935103244838, 0.6292466765140325, 0.628698224852071, 0.6296296296296297, 0.6305637982195845, 0.6315007429420505, 0.6309523809523809, 0.6304023845007451, 0.6298507462686567, 0.6307922272047832, 0.6302395209580839, 0.6296851574212894, 0.6291291291291291, 0.6300751879699248, 0.6295180722891566, 0.6289592760180995, 0.6283987915407855, 0.6293494704992436, 0.6303030303030303, 0.6312594840667678, 0.6306990881458967, 0.6301369863013698, 0.6310975609756098, 0.6320610687022901, 0.6330275229357798, 0.6324655436447167, 0.6319018404907976, 0.6328725038402457, 0.6323076923076923, 0.6332819722650231, 0.6327160493827161, 0.633693972179289, 0.6331269349845201, 0.6325581395348837, 0.6319875776397516, 0.6314152410575428, 0.6308411214953271, 0.6318252730109204, 0.63125, 0.6306729264475743, 0.6316614420062696, 0.631083202511774, 0.6320754716981132, 0.631496062992126, 0.6324921135646687, 0.6334913112164297, 0.634493670886076, 0.6339144215530903, 0.6349206349206349, 0.6359300476947536, 0.6353503184713376, 0.6347687400318979, 0.6357827476038339, 0.6352, 0.6346153846153846, 0.6356340288924559, 0.635048231511254, 0.6360708534621579, 0.635483870967742, 0.6348949919224556, 0.6343042071197411, 0.6337115072933549, 0.6347402597402597, 0.6357723577235772, 0.6368078175895765, 0.636215334420881, 0.6356209150326797, 0.6366612111292962, 0.6360655737704918, 0.6371100164203612, 0.6381578947368421, 0.6375617792421746, 0.6386138613861386, 0.6380165289256199, 0.6374172185430463, 0.6368159203980099, 0.6362126245847176, 0.6356073211314476, 0.635, 0.6343906510851419, 0.6354515050167224, 0.6348408710217756, 0.6342281879194631, 0.6336134453781512, 0.632996632996633, 0.6323777403035413, 0.6334459459459459, 0.6345177664974619, 0.6338983050847458, 0.634974533106961, 0.6360544217687075, 0.6354344122657581, 0.636518771331058, 0.6358974358974359, 0.6352739726027398, 0.6346483704974271, 0.6357388316151202, 0.6368330464716007, 0.6362068965517241, 0.6355785837651122, 0.6366782006920415, 0.6377816291161178, 0.6388888888888888, 0.6382608695652174, 0.6376306620209059, 0.6387434554973822, 0.6381118881118881, 0.637478108581436, 0.6385964912280702, 0.6379613356766256, 0.6373239436619719, 0.63668430335097, 0.6360424028268551, 0.6353982300884956, 0.6365248226950354, 0.6358792184724689, 0.6352313167259787, 0.6345811051693404, 0.6357142857142857, 0.6368515205724508, 0.6362007168458781, 0.6355475763016158, 0.6348920863309353, 0.6360360360360361, 0.6353790613718412, 0.6347197106690777, 0.6358695652173914, 0.6370235934664247, 0.6381818181818182, 0.6375227686703097, 0.6368613138686131, 0.6380255941499086, 0.6373626373626373, 0.636697247706422, 0.6378676470588235, 0.6372007366482505, 0.6365313653136532, 0.6377079482439926, 0.6370370370370371, 0.6363636363636364, 0.6356877323420075, 0.6350093109869647, 0.6343283582089553, 0.6336448598130842, 0.6329588014981273, 0.6322701688555347, 0.6334586466165414, 0.6346516007532956, 0.6358490566037736, 0.6351606805293005, 0.634469696969697, 0.6337760910815939, 0.6330798479087453, 0.6323809523809524, 0.6335877862595419, 0.6347992351816444, 0.6340996168582376, 0.6333973128598849, 0.6326923076923077, 0.6319845857418112, 0.6312741312741312, 0.632495164410058, 0.6337209302325582, 0.6330097087378641, 0.632295719844358, 0.631578947368421, 0.630859375, 0.6320939334637965, 0.6313725490196078, 0.630648330058939, 0.6299212598425197, 0.631163708086785, 0.6304347826086957, 0.6316831683168317, 0.6329365079365079, 0.6322067594433399, 0.6314741035856574, 0.6307385229540918, 0.63, 0.6312625250501002, 0.6305220883534136, 0.6297786720321932, 0.6290322580645161, 0.6282828282828283, 0.6275303643724697, 0.6267748478701826, 0.6280487804878049, 0.6272912423625254, 0.6265306122448979, 0.6278118609406953, 0.6290983606557377, 0.6283367556468172, 0.6296296296296297, 0.6288659793814433, 0.628099173553719, 0.6273291925465838, 0.6286307053941909, 0.6299376299376299, 0.6291666666666667, 0.6283924843423799, 0.6297071129707112, 0.6310272536687631, 0.6323529411764706, 0.631578947368421, 0.630801687763713, 0.6321353065539113, 0.6313559322033898, 0.6305732484076433, 0.6319148936170212, 0.6311300639658849, 0.6324786324786325, 0.6338329764453962, 0.6351931330472103, 0.6365591397849463, 0.6379310344827587, 0.6371490280777538, 0.6363636363636364, 0.6355748373101953, 0.6369565217391304, 0.6383442265795207, 0.6397379912663755, 0.6389496717724289, 0.6381578947368421, 0.6373626373626373, 0.6387665198237885, 0.6379690949227373, 0.6371681415929203, 0.6385809312638581, 0.6377777777777778, 0.6369710467706013, 0.6361607142857143, 0.6353467561521253, 0.6345291479820628, 0.6337078651685393, 0.6328828828828829, 0.6343115124153499, 0.6334841628959276, 0.6349206349206349, 0.6363636363636364, 0.6355353075170843, 0.634703196347032, 0.6361556064073226, 0.6376146788990825, 0.6367816091954023, 0.6359447004608295, 0.6374133949191686, 0.6365740740740741, 0.6357308584686775, 0.6372093023255814, 0.6386946386946387, 0.6401869158878505, 0.639344262295082, 0.6384976525821596, 0.6376470588235295, 0.6367924528301887, 0.6359338061465721, 0.6374407582938388, 0.6389548693586699, 0.638095238095238, 0.6372315035799523, 0.638755980861244, 0.6378896882494005, 0.6394230769230769, 0.6385542168674698, 0.6400966183574879, 0.639225181598063, 0.6407766990291263, 0.6399026763990268, 0.6414634146341464, 0.6430317848410758, 0.6421568627450981, 0.6437346437346437, 0.645320197044335, 0.6469135802469136, 0.6460396039603961, 0.6451612903225806, 0.6467661691542289, 0.6483790523690773, 0.65, 0.6491228070175439, 0.6482412060301508, 0.6473551637279596, 0.6464646464646465, 0.6481012658227848, 0.6472081218274112, 0.6463104325699746, 0.6454081632653061, 0.6470588235294118, 0.6461538461538462, 0.6452442159383034, 0.6469072164948454, 0.6459948320413437, 0.6450777202072538, 0.6467532467532467, 0.6458333333333334, 0.6449086161879896, 0.6465968586387435, 0.6456692913385826, 0.6473684210526316, 0.6464379947229552, 0.6455026455026455, 0.6445623342175066, 0.6462765957446809, 0.6453333333333333, 0.6470588235294118, 0.6487935656836461, 0.6478494623655914, 0.6495956873315364, 0.6513513513513514, 0.6531165311653117, 0.654891304347826, 0.6566757493188011, 0.6584699453551912, 0.6602739726027397, 0.6593406593406593, 0.6611570247933884, 0.6629834254143646, 0.6648199445983379, 0.6638888888888889, 0.6657381615598886, 0.6675977653631285, 0.6666666666666666, 0.6657303370786517, 0.6647887323943662, 0.6638418079096046, 0.6628895184135978, 0.6647727272727273, 0.6638176638176638, 0.6628571428571428, 0.66189111747851, 0.6609195402298851, 0.6628242074927954, 0.661849710982659, 0.6608695652173913, 0.6598837209302325, 0.6618075801749271, 0.6637426900584795, 0.6627565982404692, 0.6617647058823529, 0.6637168141592921, 0.665680473372781, 0.6646884272997032, 0.6636904761904762, 0.6626865671641791, 0.6646706586826348, 0.6636636636636637, 0.6656626506024096, 0.6676737160120846, 0.6666666666666666, 0.6656534954407295, 0.6646341463414634, 0.6636085626911316, 0.6625766871165644, 0.6646153846153846, 0.6635802469135802, 0.6656346749226006, 0.6645962732919255, 0.6635514018691588, 0.6625, 0.6614420062695925, 0.6635220125786163, 0.6656151419558359, 0.6645569620253164, 0.6634920634920635, 0.6624203821656051, 0.6613418530351438, 0.6602564102564102, 0.662379421221865, 0.6612903225806451, 0.6634304207119741, 0.6623376623376623, 0.6612377850162866, 0.6633986928104575, 0.6622950819672131, 0.6611842105263158, 0.6600660066006601, 0.6589403973509934, 0.6578073089700996, 0.6566666666666666, 0.6555183946488294, 0.6577181208053692, 0.6565656565656566, 0.6587837837837838, 0.6576271186440678, 0.6564625850340136, 0.6552901023890785, 0.6541095890410958, 0.6529209621993127, 0.6517241379310345, 0.6505190311418685, 0.6527777777777778, 0.6515679442508711, 0.6503496503496503, 0.6491228070175439, 0.647887323943662, 0.6501766784452296, 0.648936170212766, 0.6476868327402135, 0.6464285714285715, 0.6487455197132617, 0.6474820143884892, 0.6462093862815884, 0.644927536231884, 0.6436363636363637, 0.6423357664233577, 0.6410256410256411, 0.6397058823529411, 0.6383763837638377, 0.6370370370370371, 0.6394052044609665, 0.6417910447761194, 0.6404494382022472, 0.6390977443609023, 0.6377358490566037, 0.6363636363636364, 0.6349809885931559, 0.6335877862595419, 0.632183908045977, 0.6346153846153846, 0.637065637065637, 0.6356589147286822, 0.6381322957198443, 0.640625, 0.6392156862745098, 0.6417322834645669, 0.6403162055335968, 0.6388888888888888, 0.6414342629482072, 0.644, 0.642570281124498, 0.6411290322580645, 0.6437246963562753, 0.6463414634146342, 0.6448979591836734, 0.6434426229508197, 0.6460905349794238, 0.6487603305785123, 0.6473029045643154, 0.6458333333333334, 0.6443514644351465, 0.6470588235294118, 0.6497890295358649, 0.6483050847457628, 0.6468085106382979, 0.6495726495726496, 0.648068669527897, 0.646551724137931, 0.6493506493506493, 0.6521739130434783, 0.6506550218340611, 0.6535087719298246, 0.6563876651982379, 0.6548672566371682, 0.6577777777777778, 0.6607142857142857, 0.6591928251121076, 0.6576576576576577, 0.6561085972850679, 0.6545454545454545, 0.6575342465753424, 0.6605504587155964, 0.6589861751152074, 0.6574074074074074, 0.6604651162790698, 0.6588785046728972, 0.6619718309859155, 0.660377358490566, 0.6587677725118484, 0.6619047619047619, 0.6650717703349283, 0.6634615384615384, 0.6618357487922706, 0.6650485436893204, 0.6634146341463415, 0.6617647058823529, 0.6650246305418719, 0.6633663366336634, 0.6666666666666666, 0.665, 0.6683417085427136, 0.6666666666666666, 0.6700507614213198, 0.6683673469387755, 0.6666666666666666, 0.6649484536082474, 0.6632124352331606, 0.6614583333333334, 0.6596858638743456, 0.6578947368421053, 0.6613756613756614, 0.6595744680851063, 0.6577540106951871, 0.6559139784946236, 0.654054054054054, 0.6521739130434783, 0.6557377049180327, 0.6538461538461539, 0.6519337016574586, 0.65, 0.6536312849162011, 0.651685393258427, 0.6497175141242938, 0.6477272727272727, 0.6457142857142857, 0.6436781609195402, 0.6416184971098265, 0.6395348837209303, 0.6374269005847953, 0.6352941176470588, 0.6331360946745562, 0.6309523809523809, 0.6347305389221557, 0.6325301204819277, 0.6363636363636364, 0.6341463414634146, 0.6319018404907976, 0.6358024691358025, 0.6335403726708074, 0.63125, 0.6352201257861635, 0.6329113924050633, 0.6305732484076433, 0.6282051282051282, 0.632258064516129, 0.6298701298701299, 0.6274509803921569, 0.625, 0.6225165562913907, 0.6266666666666667, 0.6241610738255033, 0.6283783783783784, 0.6258503401360545, 0.6301369863013698, 0.6344827586206897, 0.6319444444444444, 0.6293706293706294, 0.6267605633802817, 0.624113475177305, 0.6214285714285714, 0.6258992805755396, 0.6304347826086957, 0.6277372262773723, 0.625, 0.6222222222222222, 0.6194029850746269, 0.6240601503759399, 0.6212121212121212, 0.6183206106870229, 0.6153846153846154, 0.6124031007751938, 0.609375, 0.6062992125984252, 0.6031746031746031, 0.6, 0.5967741935483871, 0.6016260162601627, 0.5983606557377049, 0.5950413223140496, 0.5916666666666667, 0.5882352941176471, 0.5932203389830508, 0.5897435897435898, 0.5862068965517241, 0.5826086956521739, 0.5877192982456141, 0.5929203539823009, 0.5892857142857143, 0.5855855855855856, 0.5818181818181818, 0.5871559633027523, 0.5833333333333334, 0.5794392523364486, 0.5754716981132075, 0.580952380952381, 0.5769230769230769, 0.5825242718446602, 0.5784313725490197, 0.5742574257425742, 0.58, 0.5858585858585859, 0.5816326530612245, 0.5876288659793815, 0.5833333333333334, 0.5789473684210527, 0.5851063829787234, 0.5806451612903226, 0.5760869565217391, 0.5714285714285714, 0.5666666666666667, 0.5617977528089888, 0.5681818181818182, 0.5747126436781609, 0.5813953488372093, 0.5882352941176471, 0.5833333333333334, 0.5783132530120482, 0.573170731707317, 0.5802469135802469, 0.575, 0.569620253164557, 0.5641025641025641, 0.5714285714285714, 0.5789473684210527, 0.5733333333333334, 0.5675675675675675, 0.5753424657534246, 0.5833333333333334, 0.5774647887323944, 0.5857142857142857, 0.5797101449275363, 0.5882352941176471, 0.5970149253731343, 0.5909090909090909, 0.5846153846153846, 0.578125, 0.5714285714285714, 0.5806451612903226, 0.5737704918032787, 0.5833333333333334, 0.576271186440678, 0.5689655172413793, 0.5789473684210527, 0.5714285714285714, 0.5818181818181818, 0.5740740740740741, 0.5849056603773585, 0.5961538461538461, 0.6078431372549019, 0.6, 0.6122448979591837, 0.6041666666666666, 0.5957446808510638, 0.5869565217391305, 0.6, 0.5909090909090909, 0.5813953488372093, 0.5952380952380952, 0.6097560975609756, 0.625, 0.6410256410256411, 0.6578947368421053, 0.6756756756756757, 0.6666666666666666, 0.6857142857142857, 0.6764705882352942, 0.6666666666666666, 0.65625, 0.6451612903225806, 0.6333333333333333, 0.6206896551724138, 0.6428571428571429, 0.6296296296296297, 0.6153846153846154, 0.6, 0.5833333333333334, 0.5652173913043478, 0.5454545454545454, 0.5714285714285714, 0.55, 0.5263157894736842, 0.5555555555555556, 0.5294117647058824, 0.5625, 0.5333333333333333, 0.5, 0.46153846153846156, 0.5, 0.45454545454545453, 0.4, 0.4444444444444444, 0.5, 0.42857142857142855, 0.3333333333333333, 0.4, 0.25, 0.3333333333333333, 0.0, 0.0, 1.0], "recall": [1.0, 1.0, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9916666666666667, 0.9916666666666667, 0.9916666666666667, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.9883333333333333, 0.9883333333333333, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.9866666666666667, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9816666666666667, 0.98, 0.98, 0.98, 0.98, 0.9783333333333334, 0.9783333333333334, 0.9783333333333334, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.975, 0.975, 0.975, 0.975, 0.975, 0.975, 0.9733333333333334, 0.9716666666666667, 0.9716666666666667, 0.9716666666666667, 0.9716666666666667, 0.9716666666666667, 0.9716666666666667, 0.9716666666666667, 0.9716666666666667, 0.97, 0.9683333333333334, 0.9666666666666667, 0.9666666666666667, 0.9666666666666667, 0.9666666666666667, 0.965, 0.965, 0.965, 0.9633333333333334, 0.9616666666666667, 0.9616666666666667, 0.9616666666666667, 0.96, 0.96, 0.96, 0.96, 0.96, 0.96, 0.96, 0.9583333333333334, 0.9583333333333334, 0.9583333333333334, 0.9583333333333334, 0.9566666666666667, 0.9566666666666667, 0.9566666666666667, 0.9566666666666667, 0.955, 0.955, 0.955, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9516666666666667, 0.95, 0.95, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9466666666666667, 0.945, 0.945, 0.9433333333333334, 0.9416666666666667, 0.9416666666666667, 0.94, 0.94, 0.94, 0.94, 0.9383333333333334, 0.9383333333333334, 0.9366666666666666, 0.9366666666666666, 0.9366666666666666, 0.935, 0.9333333333333333, 0.9333333333333333, 0.9333333333333333, 0.9316666666666666, 0.9316666666666666, 0.9316666666666666, 0.9316666666666666, 0.9316666666666666, 0.93, 0.93, 0.9283333333333333, 0.9283333333333333, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.925, 0.9233333333333333, 0.9216666666666666, 0.9216666666666666, 0.9216666666666666, 0.9216666666666666, 0.92, 0.92, 0.9183333333333333, 0.9183333333333333, 0.9183333333333333, 0.9183333333333333, 0.9183333333333333, 0.9183333333333333, 0.9166666666666666, 0.915, 0.9133333333333333, 0.9133333333333333, 0.9133333333333333, 0.9133333333333333, 0.9116666666666666, 0.91, 0.91, 0.9083333333333333, 0.9066666666666666, 0.905, 0.905, 0.905, 0.905, 0.905, 0.9033333333333333, 0.9033333333333333, 0.9033333333333333, 0.9033333333333333, 0.9033333333333333, 0.9033333333333333, 0.9016666666666666, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.8983333333333333, 0.8983333333333333, 0.8983333333333333, 0.8966666666666666, 0.8966666666666666, 0.895, 0.8933333333333333, 0.8916666666666667, 0.89, 0.89, 0.89, 0.89, 0.8883333333333333, 0.8866666666666667, 0.8866666666666667, 0.8866666666666667, 0.8866666666666667, 0.885, 0.885, 0.8833333333333333, 0.8833333333333333, 0.8833333333333333, 0.8833333333333333, 0.8816666666666667, 0.88, 0.8783333333333333, 0.8766666666666667, 0.8766666666666667, 0.875, 0.875, 0.875, 0.875, 0.8733333333333333, 0.8716666666666667, 0.87, 0.8683333333333333, 0.8666666666666667, 0.865, 0.8633333333333333, 0.8616666666666667, 0.8616666666666667, 0.86, 0.86, 0.86, 0.8583333333333333, 0.8566666666666667, 0.8566666666666667, 0.8566666666666667, 0.8566666666666667, 0.8566666666666667, 0.8566666666666667, 0.8566666666666667, 0.8566666666666667, 0.8566666666666667, 0.8566666666666667, 0.8566666666666667, 0.855, 0.8533333333333334, 0.8533333333333334, 0.8533333333333334, 0.8533333333333334, 0.8533333333333334, 0.8516666666666667, 0.85, 0.85, 0.8483333333333334, 0.8466666666666667, 0.845, 0.845, 0.845, 0.845, 0.845, 0.845, 0.845, 0.8433333333333334, 0.8416666666666667, 0.84, 0.8383333333333334, 0.8383333333333334, 0.8383333333333334, 0.8383333333333334, 0.8383333333333334, 0.8383333333333334, 0.8366666666666667, 0.8366666666666667, 0.8366666666666667, 0.8366666666666667, 0.835, 0.835, 0.8333333333333334, 0.8316666666666667, 0.83, 0.83, 0.83, 0.83, 0.83, 0.8283333333333334, 0.8283333333333334, 0.8266666666666667, 0.825, 0.8233333333333334, 0.8216666666666667, 0.8216666666666667, 0.82, 0.8183333333333334, 0.8166666666666667, 0.8166666666666667, 0.8166666666666667, 0.8166666666666667, 0.8166666666666667, 0.815, 0.815, 0.8133333333333334, 0.8116666666666666, 0.8116666666666666, 0.81, 0.81, 0.8083333333333333, 0.8066666666666666, 0.805, 0.805, 0.8033333333333333, 0.8016666666666666, 0.8016666666666666, 0.8, 0.7983333333333333, 0.7983333333333333, 0.7983333333333333, 0.7966666666666666, 0.795, 0.7933333333333333, 0.7916666666666666, 0.7916666666666666, 0.79, 0.79, 0.7883333333333333, 0.7883333333333333, 0.7866666666666666, 0.7866666666666666, 0.785, 0.785, 0.785, 0.7833333333333333, 0.7833333333333333, 0.7816666666666666, 0.7816666666666666, 0.7816666666666666, 0.7816666666666666, 0.7816666666666666, 0.7816666666666666, 0.7816666666666666, 0.78, 0.7783333333333333, 0.7766666666666666, 0.7766666666666666, 0.775, 0.775, 0.775, 0.775, 0.775, 0.7733333333333333, 0.7716666666666666, 0.7716666666666666, 0.77, 0.77, 0.7683333333333333, 0.7666666666666667, 0.7666666666666667, 0.765, 0.765, 0.765, 0.765, 0.7633333333333333, 0.7616666666666667, 0.7616666666666667, 0.7616666666666667, 0.7616666666666667, 0.7616666666666667, 0.76, 0.7583333333333333, 0.7566666666666667, 0.755, 0.7533333333333333, 0.7516666666666667, 0.7516666666666667, 0.75, 0.75, 0.75, 0.75, 0.75, 0.7483333333333333, 0.7483333333333333, 0.7466666666666667, 0.7466666666666667, 0.745, 0.7433333333333333, 0.7416666666666667, 0.74, 0.7383333333333333, 0.7383333333333333, 0.7366666666666667, 0.7366666666666667, 0.7366666666666667, 0.735, 0.7333333333333333, 0.7316666666666667, 0.73, 0.73, 0.73, 0.7283333333333334, 0.7283333333333334, 0.7266666666666667, 0.725, 0.725, 0.725, 0.725, 0.7233333333333334, 0.7216666666666667, 0.72, 0.7183333333333334, 0.7183333333333334, 0.7183333333333334, 0.7166666666666667, 0.715, 0.7133333333333334, 0.7133333333333334, 0.7133333333333334, 0.7116666666666667, 0.7116666666666667, 0.71, 0.7083333333333334, 0.7083333333333334, 0.7083333333333334, 0.7083333333333334, 0.7066666666666667, 0.705, 0.7033333333333334, 0.7033333333333334, 0.7016666666666667, 0.7, 0.6983333333333334, 0.6983333333333334, 0.6966666666666667, 0.695, 0.6933333333333334, 0.6933333333333334, 0.6933333333333334, 0.6933333333333334, 0.6916666666666667, 0.69, 0.69, 0.69, 0.69, 0.6883333333333334, 0.6866666666666666, 0.6866666666666666, 0.685, 0.685, 0.6833333333333333, 0.6833333333333333, 0.6816666666666666, 0.68, 0.6783333333333333, 0.6766666666666666, 0.675, 0.675, 0.6733333333333333, 0.6716666666666666, 0.6716666666666666, 0.67, 0.67, 0.6683333333333333, 0.6683333333333333, 0.6683333333333333, 0.6683333333333333, 0.6666666666666666, 0.6666666666666666, 0.6666666666666666, 0.665, 0.6633333333333333, 0.6633333333333333, 0.6616666666666666, 0.66, 0.66, 0.6583333333333333, 0.6583333333333333, 0.6566666666666666, 0.655, 0.6533333333333333, 0.6516666666666666, 0.6516666666666666, 0.6516666666666666, 0.6516666666666666, 0.65, 0.6483333333333333, 0.6483333333333333, 0.6466666666666666, 0.6466666666666666, 0.6466666666666666, 0.645, 0.645, 0.6433333333333333, 0.6416666666666667, 0.64, 0.6383333333333333, 0.6366666666666667, 0.635, 0.6333333333333333, 0.6333333333333333, 0.6316666666666667, 0.63, 0.6283333333333333, 0.6266666666666667, 0.625, 0.625, 0.625, 0.6233333333333333, 0.6233333333333333, 0.6233333333333333, 0.6216666666666667, 0.6216666666666667, 0.62, 0.6183333333333333, 0.6166666666666667, 0.6166666666666667, 0.6166666666666667, 0.615, 0.6133333333333333, 0.6133333333333333, 0.6133333333333333, 0.6133333333333333, 0.6116666666666667, 0.61, 0.61, 0.6083333333333333, 0.6066666666666667, 0.6066666666666667, 0.605, 0.6033333333333334, 0.6016666666666667, 0.6, 0.5983333333333334, 0.5983333333333334, 0.5966666666666667, 0.595, 0.5933333333333334, 0.5933333333333334, 0.5933333333333334, 0.5916666666666667, 0.59, 0.5883333333333334, 0.5883333333333334, 0.5866666666666667, 0.585, 0.585, 0.585, 0.585, 0.5833333333333334, 0.5816666666666667, 0.5816666666666667, 0.58, 0.5783333333333334, 0.5783333333333334, 0.5766666666666667, 0.575, 0.575, 0.5733333333333334, 0.5716666666666667, 0.57, 0.5683333333333334, 0.5666666666666667, 0.565, 0.5633333333333334, 0.5616666666666666, 0.5616666666666666, 0.5616666666666666, 0.5616666666666666, 0.56, 0.5583333333333333, 0.5566666666666666, 0.555, 0.5533333333333333, 0.5533333333333333, 0.5533333333333333, 0.5516666666666666, 0.55, 0.5483333333333333, 0.5466666666666666, 0.545, 0.545, 0.545, 0.5433333333333333, 0.5416666666666666, 0.54, 0.5383333333333333, 0.5383333333333333, 0.5366666666666666, 0.535, 0.5333333333333333, 0.5333333333333333, 0.5316666666666666, 0.5316666666666666, 0.5316666666666666, 0.53, 0.5283333333333333, 0.5266666666666666, 0.525, 0.525, 0.5233333333333333, 0.5216666666666666, 0.52, 0.5183333333333333, 0.5166666666666667, 0.515, 0.515, 0.5133333333333333, 0.5116666666666667, 0.5116666666666667, 0.5116666666666667, 0.51, 0.51, 0.5083333333333333, 0.5066666666666667, 0.505, 0.505, 0.505, 0.5033333333333333, 0.5016666666666667, 0.5016666666666667, 0.5016666666666667, 0.5016666666666667, 0.5, 0.49833333333333335, 0.49833333333333335, 0.49666666666666665, 0.495, 0.495, 0.49333333333333335, 0.49333333333333335, 0.49333333333333335, 0.49333333333333335, 0.49333333333333335, 0.49333333333333335, 0.49166666666666664, 0.49, 0.48833333333333334, 0.48833333333333334, 0.48833333333333334, 0.48833333333333334, 0.4866666666666667, 0.485, 0.48333333333333334, 0.48333333333333334, 0.4816666666666667, 0.48, 0.48, 0.47833333333333333, 0.4766666666666667, 0.475, 0.47333333333333333, 0.4716666666666667, 0.47, 0.4683333333333333, 0.4683333333333333, 0.4666666666666667, 0.4666666666666667, 0.4666666666666667, 0.465, 0.4633333333333333, 0.4633333333333333, 0.4633333333333333, 0.46166666666666667, 0.46, 0.46, 0.4583333333333333, 0.45666666666666667, 0.45666666666666667, 0.45666666666666667, 0.45666666666666667, 0.455, 0.4533333333333333, 0.45166666666666666, 0.45, 0.4483333333333333, 0.4483333333333333, 0.4483333333333333, 0.44666666666666666, 0.445, 0.445, 0.44333333333333336, 0.44333333333333336, 0.44166666666666665, 0.44166666666666665, 0.44, 0.44, 0.43833333333333335, 0.43833333333333335, 0.43833333333333335, 0.43666666666666665, 0.43666666666666665, 0.43666666666666665, 0.43666666666666665, 0.435, 0.43333333333333335, 0.43333333333333335, 0.43333333333333335, 0.43333333333333335, 0.43166666666666664, 0.43, 0.42833333333333334, 0.4266666666666667, 0.4266666666666667, 0.425, 0.42333333333333334, 0.4216666666666667, 0.4216666666666667, 0.42, 0.41833333333333333, 0.41833333333333333, 0.4166666666666667, 0.415, 0.415, 0.41333333333333333, 0.4116666666666667, 0.4116666666666667, 0.41, 0.41, 0.4083333333333333, 0.4066666666666667, 0.405, 0.405, 0.4033333333333333, 0.4033333333333333, 0.4033333333333333, 0.40166666666666667, 0.40166666666666667, 0.40166666666666667, 0.40166666666666667, 0.40166666666666667, 0.40166666666666667, 0.40166666666666667, 0.40166666666666667, 0.4, 0.4, 0.4, 0.4, 0.3983333333333333, 0.3983333333333333, 0.3983333333333333, 0.39666666666666667, 0.395, 0.3933333333333333, 0.39166666666666666, 0.39, 0.39, 0.3883333333333333, 0.38666666666666666, 0.385, 0.38333333333333336, 0.38333333333333336, 0.38166666666666665, 0.38, 0.37833333333333335, 0.37833333333333335, 0.37833333333333335, 0.37666666666666665, 0.375, 0.375, 0.375, 0.37333333333333335, 0.37166666666666665, 0.37, 0.37, 0.36833333333333335, 0.36833333333333335, 0.36833333333333335, 0.36666666666666664, 0.365, 0.36333333333333334, 0.3616666666666667, 0.36, 0.36, 0.35833333333333334, 0.35833333333333334, 0.3566666666666667, 0.355, 0.35333333333333333, 0.3516666666666667, 0.3516666666666667, 0.3516666666666667, 0.35, 0.34833333333333333, 0.3466666666666667, 0.345, 0.3433333333333333, 0.3433333333333333, 0.3416666666666667, 0.3416666666666667, 0.34, 0.3383333333333333, 0.3383333333333333, 0.33666666666666667, 0.335, 0.3333333333333333, 0.33166666666666667, 0.33, 0.3283333333333333, 0.32666666666666666, 0.32666666666666666, 0.325, 0.325, 0.3233333333333333, 0.32166666666666666, 0.32, 0.31833333333333336, 0.31666666666666665, 0.315, 0.31333333333333335, 0.31333333333333335, 0.31166666666666665, 0.31, 0.30833333333333335, 0.30666666666666664, 0.30666666666666664, 0.305, 0.30333333333333334, 0.3016666666666667, 0.3016666666666667, 0.3, 0.29833333333333334, 0.2966666666666667, 0.295, 0.29333333333333333, 0.2916666666666667, 0.29, 0.28833333333333333, 0.2866666666666667, 0.2866666666666667, 0.2866666666666667, 0.285, 0.2833333333333333, 0.2816666666666667, 0.28, 0.2783333333333333, 0.27666666666666667, 0.275, 0.275, 0.275, 0.2733333333333333, 0.2733333333333333, 0.2733333333333333, 0.27166666666666667, 0.27166666666666667, 0.27, 0.2683333333333333, 0.2683333333333333, 0.2683333333333333, 0.26666666666666666, 0.265, 0.265, 0.265, 0.2633333333333333, 0.26166666666666666, 0.26166666666666666, 0.26166666666666666, 0.26, 0.25833333333333336, 0.25666666666666665, 0.25666666666666665, 0.25666666666666665, 0.255, 0.25333333333333335, 0.25333333333333335, 0.25166666666666665, 0.25, 0.25, 0.25, 0.24833333333333332, 0.24833333333333332, 0.24833333333333332, 0.24666666666666667, 0.24666666666666667, 0.24666666666666667, 0.245, 0.24333333333333335, 0.24166666666666667, 0.24, 0.24, 0.24, 0.23833333333333334, 0.23666666666666666, 0.23666666666666666, 0.235, 0.235, 0.23333333333333334, 0.23166666666666666, 0.23166666666666666, 0.23166666666666666, 0.23, 0.22833333333333333, 0.22833333333333333, 0.22666666666666666, 0.225, 0.225, 0.22333333333333333, 0.22333333333333333, 0.22166666666666668, 0.22166666666666668, 0.22, 0.22, 0.21833333333333332, 0.21666666666666667, 0.215, 0.21333333333333335, 0.21166666666666667, 0.21, 0.20833333333333334, 0.20833333333333334, 0.20666666666666667, 0.205, 0.20333333333333334, 0.20166666666666666, 0.2, 0.2, 0.19833333333333333, 0.19666666666666666, 0.195, 0.195, 0.19333333333333333, 0.19166666666666668, 0.19, 0.18833333333333332, 0.18666666666666668, 0.185, 0.18333333333333332, 0.18166666666666667, 0.18, 0.17833333333333334, 0.17666666666666667, 0.17666666666666667, 0.175, 0.175, 0.17333333333333334, 0.17166666666666666, 0.17166666666666666, 0.17, 0.16833333333333333, 0.16833333333333333, 0.16666666666666666, 0.165, 0.16333333333333333, 0.16333333333333333, 0.16166666666666665, 0.16, 0.15833333333333333, 0.15666666666666668, 0.15666666666666668, 0.155, 0.155, 0.15333333333333332, 0.15333333333333332, 0.15333333333333332, 0.15166666666666667, 0.15, 0.14833333333333334, 0.14666666666666667, 0.145, 0.145, 0.145, 0.14333333333333334, 0.14166666666666666, 0.14, 0.13833333333333334, 0.13833333333333334, 0.13666666666666666, 0.135, 0.13333333333333333, 0.13166666666666665, 0.13, 0.12833333333333333, 0.12666666666666668, 0.125, 0.12333333333333334, 0.12333333333333334, 0.12166666666666667, 0.12, 0.11833333333333333, 0.11666666666666667, 0.11666666666666667, 0.115, 0.11333333333333333, 0.11166666666666666, 0.11166666666666666, 0.11166666666666666, 0.11, 0.10833333333333334, 0.10666666666666667, 0.10666666666666667, 0.105, 0.10333333333333333, 0.10166666666666667, 0.10166666666666667, 0.1, 0.1, 0.09833333333333333, 0.09666666666666666, 0.09666666666666666, 0.09666666666666666, 0.095, 0.095, 0.09333333333333334, 0.09166666666666666, 0.09166666666666666, 0.09, 0.08833333333333333, 0.08666666666666667, 0.085, 0.08333333333333333, 0.08333333333333333, 0.08333333333333333, 0.08333333333333333, 0.08333333333333333, 0.08166666666666667, 0.08, 0.07833333333333334, 0.07833333333333334, 0.07666666666666666, 0.075, 0.07333333333333333, 0.07333333333333333, 0.07333333333333333, 0.07166666666666667, 0.07, 0.07, 0.07, 0.06833333333333333, 0.06833333333333333, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.065, 0.06333333333333334, 0.06166666666666667, 0.06, 0.06, 0.058333333333333334, 0.058333333333333334, 0.056666666666666664, 0.055, 0.055, 0.05333333333333334, 0.05333333333333334, 0.051666666666666666, 0.051666666666666666, 0.051666666666666666, 0.051666666666666666, 0.05, 0.05, 0.04833333333333333, 0.04666666666666667, 0.045, 0.045, 0.043333333333333335, 0.041666666666666664, 0.041666666666666664, 0.041666666666666664, 0.041666666666666664, 0.041666666666666664, 0.041666666666666664, 0.041666666666666664, 0.04, 0.04, 0.03833333333333333, 0.03666666666666667, 0.035, 0.03333333333333333, 0.03166666666666667, 0.03, 0.03, 0.028333333333333332, 0.02666666666666667, 0.025, 0.023333333333333334, 0.021666666666666667, 0.02, 0.02, 0.018333333333333333, 0.016666666666666666, 0.016666666666666666, 0.015, 0.015, 0.013333333333333334, 0.011666666666666667, 0.01, 0.01, 0.008333333333333333, 0.006666666666666667, 0.006666666666666667, 0.006666666666666667, 0.005, 0.0033333333333333335, 0.0033333333333333335, 0.0016666666666666668, 0.0016666666666666668, 0.0, 0.0, 0.0]}, "loss": 0.3799675653586805}